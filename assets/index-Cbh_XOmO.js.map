{"version":3,"mappings":"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","names":["AnimationPropertiesOverride","Animation","PathCursor","_path","point","Vector3","step","f","Analyser","scene","EngineStore","AbstractEngine","Tools","workingArray","i","percent","height","offset","barWidth","hue","inputAudioNode","outputAudioNode","Instances","LastCreatedAudioEngine","AudioEngineV2","options","value","nodeIt","next","mainBus","node","_GetAudioEngine","engine","CreateAudioBusAsync","name","CreateMainAudioBusAsync","CreateSoundAsync","source","CreateSoundBufferAsync","CreateStreamingSoundAsync","_MainAudioOut","AbstractAudioNode","_WebAudioMainOut","audioContext","_WebAudioUnmuteUI","parentElement","parent","_b","_a","top","CreateAudioEngineAsync","_WebAudioEngine","FormatMimeTypes","resolve","Observable","_HasSpatialAudioListenerOptions","_CreateSpatialAudioListener","module","__vitePreload","n","bus","sound","soundBuffer","format","mimeType","audioParam","VertexAnimationBaker","meshOrSkeleton","Skeleton","ranges","boneCount","frameCount","previous","current","textureIndex","textureSize","vertexData","range","frameIndex","_reject","skeletonMatrices","texture","RawTexture","Texture","width","EncodeArrayBufferToBase64","data","DecodeBase64ToBinary","json","FaceDirectionInfo","direction","rotatedDirection","diff","ignore","AttachToBoxBehavior","_ui","Matrix","targetDirection","v","Quaternion","min","p","pos","up","ref","target","cameraPos","facing","facingUp","FadeInOutBehavior","ownerNode","fadeIn","mesh","c","MultiPointerScaleBehavior","PointerDragBehavior","behavior","ratio","change","BaseSixDofDragBehavior","currentDraggingPointerID","dragMesh","TransformNode","originMesh","pivotMesh","ray","pointerId","zDragFactor","Camera","virtualMeshesInfo","originDragDifference","TmpVectors","localOriginDragDifference","lookAt","controllerAimTransform","controllerGripTransform","cameraForwardVec","originDragDirection","controllerDragDistance","cameraToDrag","controllerToDrag","controllerToDragDistance","zOffsetScaling","minDistanceFromControllerToDragMesh","Scene","pickPredicate","m","pointerInfo","isXRPointer","isNearXRPointer","PointerEventTypes","registeredPointerIndex","worldPosition","worldRotation","worldDeltaPosition","worldDeltaRotation","arcRotateCamera","SixDofDragBehavior","deltaToAdd","deltaToAddTransformed","parentRotationMatrixInverse","rotationToApply","parentRotationInverse","transformationLocalOrigin","scaling","rotation","translationMatrix","translationMatrixInv","rotationMatrix","scaleMatrix","finalMatrix","startingPosition0","startingPosition1","startingCenter","startingVector","currentPosition0","currentPosition1","currentCenter","currentVector","translation","rotationQuaternion","oldParent","positionOffset","pointerCount","worldPivot","toCamera","quat","previousFaceCameraFlag","SurfaceMagnetismBehavior","pickingInfo","pickedNormal","pickedPoint","worldTarget","pickInfo","subPicking","pose","storedQuat","boundingMinMax","center","invWorld","elapsed","worldOffset","interpolatedPosition","currentRotation","tick","FollowBehavior","camera","followedCamera","vector","normal","currentToTarget","moveToDefault","minDistance","maxDistance","defaultDistance","currentDistance","currentDistance2D","clampedDistance","Clamp","quaternion","invertView","forward","right","Epsilon","angularClamped","rotationQuat","angle","minMaxAngle","toFollowed","length","leashToFollow","worldMatrix","pivot","position","nodeForward","distanceClamped","currentDirection","PositionNormalVertex","PositionNormalTextureVertex","uv","Vector2","StereoscopicScreenUniversalCamera","UniversalCamera","newValue","distanceToProjectionPlane","distanceBetweenEyes","TargetCamera","transform","cameraIndex","cam","b","z","Viewport","BoundingInfoHelper","computeShaderBoundingHelper","ComputeShaderBoundingHelper","defines","hasBones","hasMorphs","computeShader","join","bindingsMapping","ComputeShader","ubo","UniformBuffer","kind","stride","storageUnit","buffer","vertexCount","dataArray","StorageBuffer","id","numInfluencers","meshes","maxNumInfluencers","VertexBuffer","manager","computeShaderWithoutMorph","computeShaderWithMorph","_retryWithInterval","iterator","key","resultDataSize","resultData","resultBuffer","boneSampler","morphTargets","buffers","size","minimum","maximum","minmax","resultDataOffset","j","AxisDragGizmo","Gizmo","material","thickness","isCollider","arrow","cylinder","CreateCylinder","line","instance","childInstance","dragAxis","color","Color3","gizmoLayer","UtilityLayerRenderer","hoverColor","disableColor","StandardMaterial","collider","Mesh","currentSnapDragDistance","tmpSnapEvent","event","matrixChanged","dragSteps","light","cache","newState","matl","AxesViewer","scaleLines","renderingGroupId","xAxis","yAxis","zAxis","lineThickness","redColoredMaterial","greenColoredMaterial","blueColoredMaterial","xaxis","yaxis","zaxis","axesViewer","BoneAxesViewer","bone","Axis","PhysicsViewer","physicEngine","plugin","impostor","PhysicsImpostor","body","inertiaMesh","inertiaMatrixRef","transformMatrixRef","finalMatrixRef","inertiaAsMesh","inertiaMeshMatrixData","bodyTransformMatrixData","props","parentTransform","constraint","parentingMesh","pivotA","pivotB","axisA","axisB","perpAxisA","perpAxisB","parentConstraintMesh","parentCoordSystemNode","childCoordSystemNode","parentBody","parentBodyIndex","childBody","childBodyIndex","childTransform","parentTransformNode","childTransformNode","targetMesh","debugMesh","removed","utilityLayerScene","index","axisNumber","CreateBox","CreateSphere","CreateCapsule","wireframeOver","Logger","radius","bi","boundingInfo","max","VertexData","geometry","instanceBuffer","massProps","matrix","orientation","inertiaLocal","betaSqrd","beta","gammaSqrd","gamma","alphaSqrd","alpha","extents","inertiaBoxMesh","MeshBuilder","matrixRef","Color4","instanceIndex","tnode","minLimit","maxLimit","arcAngle","parentScaling","cage","transparentMaterial","bodiesUsingConstraint","parentedConstraintMeshes","bodyPairInfo","parentOfPair","rotTransformParent","rotTransformChild","translateTransformParent","translateTransformChild","parentAxes","childAxes","constraintAxisAngular","constraintAxis","lockCount","angularLinear","axis","constraintAxisValue","limited","axisIndex","axisMode","RayHelper","helper","CreateLines","len","meshSpaceDirection","meshSpaceOrigin","DirectionalLightFrustumViewer","show","invLightView","_c","_d","_e","_f","_g","_h","nearLines","farLines","trLines","brLines","tlLines","blLines","makePlane","positions","plane","mat","indices","NullEngineOptions","NullEngine","Engine","PerformanceConfigurator","theCurrentGlobal","vertices","DataBuffer","backBuffer","depth","stencil","useScreen","viewport","requiredWidth","requiredHeight","pipelineContext","vertexCode","fragmentCode","context","uniformsNames","attributesNames","effect","IsWrapper","cullBackFaces","force","culling","zOffset","reverseSide","zOffsetUnits","uniform","array","matrices","x","y","bool","w","mode","noDepthWriteChange","vertexBuffers","indexBuffer","bruteForce","useTriangles","indexStart","indexCount","instancesCount","fillMode","verticesStart","verticesCount","urlArg","noMipmap","invertY","samplingMode","onLoad","onError","fallback","forcedExtension","InternalTexture","url","isMulti","isCube","rtWrapper","RenderTargetWrapper","fullOptions","generateMipMaps","compression","type","creationFlags","useSRGBBuffer","faceIndex","forceFullscreenViewport","disableGenerateMipMaps","onBeforeUnbind","canvas","premulAlpha","vertexBuffer","byteOffset","byteLength","channel","_","internalFormat","lod","imageData","image","EngineFactory","WebGPUEngine","FlowGraphPathConverter","_context","_separator","path","parts","currentObject","property","FrameGraphObjectList","RotationGizmo","gizmo","transformNode","tessellation","useEulerRotation","gizmoManager","xColor","yColor","zColor","PlaneRotationGizmo","coordinatesMode","customRotationQuaternion","obs","PlaneDragGizmo","dragPlane","CreatePlane","dragPlaneNormal","tmpVector","PositionGizmo","ScaleGizmo","AxisScaleGizmo","uniformScaleGizmo","CreatePolyhedron","msh","GizmoManager","hovered","dragging","_scene","utilityLayer","keepDepthUtilityLayer","attachToMeshPointerObserver","gizmoAxisPointerObserver","found","AbstractMesh","BoundingBoxGizmo","gizmoAxisCache","k","observer","cubicBezierCurve","t","p0","p1","p2","p3","SpecularPowerToRoughness","specularPower","EngineInstrumentation","PerfCounter","SceneInstrumentation","OcclusionMaterial","ShaderMaterial","CustomProceduralTexture","ProceduralTexture","texturePath","fallbackTexture","skipJson","jsonUrl","noConfigFile","configFileUrl","xhr","WebRequest","useCameraPostProcess","RawTexture3D","textureType","RefractionTexture","RenderTargetTexture","Plane","newTexture","serializationObject","ThinRenderTargetTexture","ThinTexture","disposeOnlyFramebuffers","SetToDefaultGaussianSplatting","nodeMaterial","splatIndex","InputBlock","splatReader","SplatReaderBlock","gs","GaussianSplattingBlock","worldInput","NodeMaterialSystemValues","worldPos","TransformBlock","view","projection","gaussian","GaussianBlock","fragmentOutput","FragmentOutputBlock","vertexOutput","VertexOutputBlock","NodeMaterialModes","NodeMaterialOptimizer","_vertexOutputNodes","_fragmentOutputNodes","MapMap","a","ShadowDepthWrapper","baseMaterial","params","subMesh","depthWrapperEntries","depthWrapper","shadowGenerator","passIdForDrawWrapper","entry","drawWrapper","DrawWrapper","useInstances","origEffectAndRenderPassId","origEffect","origRenderPassId","mainDrawWrapper","RandomGUID","uniforms","vertexNormalBiasCode","vertexMetricCode","fragmentSoftTransparentShadow","fragmentBlockCode","vertexExtraDeclartion","hasLocationForSoftTransparentShadow","hasLocationForFragment","fragmentCodeToInjectAtEnd","Effect","createPBRAnisotropicPlugin","PBRBaseMaterial","PBRAnisotropicConfiguration","createPBRBRDFPlugin","PBRBRDFConfiguration","createPBRClearCoatPlugin","PBRClearCoatConfiguration","createPBRIridescencePlugin","PBRIridescenceConfiguration","createPBRSheenPlugin","PBRSheenConfiguration","createPBRSubSurfacePlugin","PBRSubSurfaceConfiguration","createDetailMapPlugin","DetailMapConfiguration","Polar","theta","polar","scale","Spherical","phi","spherical","CreateHotSpotQueryForPickingInfo","base","GetTransformedPosition","res","values","component","targetCount","influence","targetData","matricesIndicesData","matricesWeightsData","needExtras","matricesIndicesExtraData","matricesWeightsExtraData","tempMatrix","matWeightIdx","inf","weight","GetHotSpotToRef","hotSpotQuery","resPosition","resNormal","pointA","pointB","pointC","segmentA","segmentB","MeshUVSpaceRenderer","shaderLanguage","shader","textureIsReady","maskIsReady","postProcessIsReady","checkIsReady","PostProcess","rtt","yaw","pitch","projWorldMatrix","inverseProjWorldMatrix","projMatrix","screenMatrix","getExtentCorners","extent","minX","minY","minZ","maxX","maxY","maxZ","computeMaxExtents","animationGroup","animationStep","meshExtents","skinnedMeshExtents","maxLength","minPositions","maxPositions","numVertices","morphTargetManager","targetIndex","skeleton","weights","needsExtra","weightsExtra","indicesExtra","perBoneExtents","updateExtents","boneIndex","meshCorners","skinnedMeshCorners","bones","perBoneCorners","corners","inverseBindMatrix","corner","maxExtents","updateMaxExtents","currentFrame","frame","LatticePluginMaterial","MaterialPluginBase","lattice","control","uniformBuffer","samplers","code","shaderType","MeshExploder","centerMesh","centerMeshIndex","averageCenter","totalCenters","shortestToCenter","distanceToCenter","meshArray","FilesInput","FilesInputStore","sceneLoadedCallback","progressCallback","additionalRenderLoopLogicCallback","textureLoadingCallback","startingProcessingFilesCallback","onReloadCallback","errorCallback","useAppend","dontInjectRenderLoop","sceneFile","onProgress","SceneLoader","elementToMonitor","e","remaining","eventDrop","folder","files","callback","reader","relativePath","entries","file","extension","folders","items","fileToLoad","item","error","SceneRecorder","SerializationHelper","SceneSerializer","currentForceSerializeBuffers","newJSON","deltaJSON","original","originalUniqueIds","originalObject","originalUniqueId","currentObjects","newObject","currentUniqueId","originalObjet","aDifferenceWasFound","prop","originalValue","currentValue","diffFound","allGenerators","l","generators","generator","anyScene","Light","ShadowGenerator","Material","MultiMaterial","ParticleSystem","MorphTargetManager","entity","sources","finder","addNew","targetEntity","PressureObserverWrapper","update","defaultDisposeImpl","PerfCollectionStrategy","factor","wrapper","record","drawCalls","onBeforeAnimationsObserver","onAfterRenderObserver","sceneInstrumentation","startTime","PrecisionDate","timeTaken","onBeforeActiveMeshesObserver","onAfterActiveMeshesObserver","onBeforeRenderTargetsObserver","onAfterRenderTargetsObserver","onBeforeParticlesObserver","onAfterParticlesObserver","onBeforeSpritesObserver","onAfterSpritesObserver","onAfterAnimationsObserver","onBeforePhysicsObserver","onAfterPhysicsObserver","onBeforeDrawPhaseObserver","onAfterDrawPhaseObserver","engineInstrumentation","SnapshotRenderingHelper","dw","dataBuffer","ubLeftOver","BindMorphTargetParameters","cancel","callbackWhenSceneReady","targetFrameId","updateInstancedMeshes","sourceMesh","effectLayer","autoUpdate","renderPassId","sceneTransformationMatrix","frameId","func","funcName","message","captureEquirectangularFromScene","probe","ReflectionProbe","wasProbeProvided","meshesToConsider","dumpTexture","reject","pixelDataPromise","pixelData","DumpData","AsyncLock","signal","wrappedFunc","newOperation","locks","deferred","Deferred","acquiredLocks","lock","RecastJSPlugin","recastInjection","workerURL","newTimeStep","newStepCount","parameters","completion","tri","pt","meshIndices","meshPositions","worldMatrices","thinMatrices","tmpMatrix","matrixIndex","wm","transformed","rc","debugNavMesh","triangleCount","ret","result","maxRadius","destination","navPath","pointCount","start","end","maxAgents","maxAgentRadius","RecastJSCrowd","nDataBytes","dataPtr","dataHeap","buf","navmeshData","arrView","obstacle","seed","agentParams","agentIndex","agentPos","agentVel","pathTargetPos","deltaTime","timeStep","maxStepCount","iterationCount","agentPosition","dx","dz","groundY","ceilingY","distanceXZSquared","ext","SolidParticle","particleIndex","particleId","positionIndex","indiceIndex","model","shapeId","idxInShape","sps","modelBoundingInfo","materialIndex","Vector4","BoundingInfo","q","BoundingSphere","frustumPlanes","ModelShape","shapeID","shape","normals","colors","shapeUV","posFunction","vtxFunction","DepthSortedParticle","idx","ind","indLength","SolidParticleVertex","val","SolidParticleSystem","triangle","CreateDisc","faceId","part","lind","pickedData","uvKind","number","delta","meshPos","meshInd","meshUV","meshCol","meshNor","storage","totalFacets","facetPos","facetNor","facetInd","facetUV","facetCol","barycenter","sizeO","fi","i3","i2","i4","shapeInd","shapeCol","shapeNor","bInfo","modelShape","currentPos","currentInd","tmpNormal","invertedRotMatrix","particle","copy","uvs","u","storeApart","materialId","materialIndexesById","matIdx","rotMatrix","tmpVertex","tmpColor","tmpUV","tmpRotated","pivotBackTranslation","scaledPivot","someVertexFunction","copyUvs","current_ind","matIndex","idxpos","idxind","sp","nb","shapeNormals","shapeColors","bbInfo","posfunc","vtxfunc","reset","particles","currentNb","firstRemaining","shiftPos","shifInd","particlesLength","modelIndices","modelNormals","modelColors","modelUVs","solidParticleArray","currentShapeId","noNor","newPart","currentCopy","invertedMatrix","colors32","positions32","normals32","uvs32","indices32","fixedNormal32","depthSortParticles","tempVectors","camAxisX","camAxisY","camAxisZ","camInvertedPosition","tmpVector0","colidx","colorIndex","uvidx","uvIndex","vpos","particleRotationMatrix","particlePosition","particleRotation","particleScaling","particleGlobalPosition","dsp","parentRotationMatrix","parentGlobalPosition","rotatedY","rotatedX","rotatedZ","rotMatrixValues","iu","iv","vertexX","vertexY","vertexZ","px","py","pz","normalx","normaly","normalz","rotatedx","rotatedy","rotatedz","bBox","bSphere","modelBoundingInfoVectors","tempMin","tempMax","scaledX","scaledY","scaledZ","minBbox","maxBbox","bSphereCenter","halfDiag","bSphereMinBbox","bSphereMaxBbox","vb","vbp","depthSortedParticles","dspl","sid","sorted","sortedParticle","sind","particleInd","particleIdx","faceInd","tmp","picked","sortedPart","indicesByMaterial","materialIndexes","vcount","count","SubMesh","subMeshIndex","subMeshFaceId","lastMatIndex","self","vis","materials","mm","vertex","stop","PhysicsBody","PhysicsPrestepType","motionType","startsAsleep","physicsEngine","physicsPlugin","clonedBody","eventMask","prestepType","damping","linVel","angVel","impulse","location","angularImpulse","enabled","matrixData","childInstanceIndex","boneMesh","jointPivot","distToJoint","adjustRotation","boneAxis","tempQuat","boneDir","PhysicsConstraint","isEnabled","Physics6DoFLimit","Physics6DoFConstraint","constraintParams","limits","friction","limitMode","limit","motorType","maxForce","BallAndSocketConstraint","DistanceConstraint","HingeConstraint","SliderConstraint","LockConstraint","PrismaticConstraint","SpringConstraint","stiffness","PhysicsAggregate","_options","startAsleep","PhysicsShape","BoundingBox","bb","WithinEpsilon","capRadius","RagdollBoneProperties","Ragdoll","rootTransformNode","config","boneNames","ii","currentBone","currentRagdollBoneProperties","boxOffset","boneOffsetAxis","mass","restitution","aggregate","nearestParent","boneParentIndex","distanceFromParentBoxToBone","wmat","invertedWorldMat","boneAbsPos","boxAbsPos","myConnectedPivot","constraintType","rootMatrix","rootPos","qmesh","qbind","qphys","skeletonRoots","MeshAccumulator","collectIndices","includeChildren","rootScaled","InstancedMesh","worldToRoot","worldToRootScaled","childToWorld","childToRootScaled","meshToRoot","numVerts","indexOffset","nFloats","nBytes","bufferBegin","arr","BodyPluginData","bodyId","CollisionContactPoint","CollisionEvent","eventOut","intBuf","floatBuf","offA","offB","TriggerEvent","HavokPlugin","_useDeltaForWorldStep","hpInjection","BuildArray","gravity","physicsBodies","physicsBody","maxLinearVelocity","maxAngularVelocity","startIndex","endIndex","hkbody","pluginData","pluginInstancesCount","firstBodyShape","instancesToRemove","bufOffset","transformBuffer","mi","bodyTransform","bodyTranslation","bodyOrientation","finalTransform","finalTranslation","parentInverseTransform","localTransform","shapeHandle","pluginRef","shapePluginData","bodyPluginData","massPropsTuple","newProps","controlMode","shapeRes","shapeMass","computed","lv","fnToApply","av","transformedVertices","arraySize","dim","elementSize","includeChildMeshes","needIndices","accum","numVec3s","triangles","numTriangles","totalNumHeights","numBytes","heightBuffer","hkBufferIndex","bjsBufferIndex","scaleX","scaleZ","membershipMask","collideWith","collideMask","membership","dynamicFriction","staticFriction","frictionCombine","restitutionCombine","hpMaterial","hkMaterial","density","r","newChild","transformNative","childIndex","isTrigger","_shape","aabb","dataInfo","geometryRes","geometryInfo","positionsInPlugin","indicesInPlugin","jointId","bodyA","bodyB","distance","dist3d","sixdofData","axId","collisionEnabled","pairs","bodyIds","parentBodyInfo","childBodyInfo","firstId","hitData","hitBody","hitShape","hitPos","hitNormal","hitTriangle","from","to","query","queryMembership","queryCollideWith","shouldHitTriggers","bodyToIgnore","hkQuery","inputShapeResult","hitShapeResult","hitInputData","hitShapeData","fractionAlongRay","observable","collideEvents","currentCollideEvents","eventAddress","bodyInfoA","bodyInfoB","triggerCollisionInfo","worldAddr","collisionInfo","observableA","observableB","collisionInfoB","vec3","ProximityCastResult","CastingResult","ShapeCastResult","fraction","HighlightsPostProcess","reusable","useWebGPU","list","LensRenderingPipeline","PostProcessRenderPipeline","cameras","PostProcessRenderEffect","amount","disableDepthRender","RandomRange","_IblShadowsVoxelRenderer","resolutionExp","widthScale","heightScale","mipNum","isWebGPU","debugOptions","iblShadowsRenderPipeline","triPlanarVoxelization","EffectRenderer","EffectWrapper","iterations","lodLevel","mipTarget","voxelGrid","rt","bindSize","layer","voxelAxisOptions","numSlabs","voxelCombinedOptions","generateVoxelMipOptions","mipIdx","mipDim","mipSize","voxelRT","mrtArray","targetTypes","mrt_index","layerIndices","textureNames","mrt","MultiRenderTarget","mip","allReady","mipReady","rts","rtIdx","includedMeshes","rttReady","mrts","continuousRender","slabSize","voxelMaterial","mrtIndex","nearPlane","farPlane","stepSize","cameraPosition","targetPosition","upDirection","childMesh","_IblShadowsVoxelTracingPass","textureOptions","counter","highestMip","cdfGenerator","geometryBufferRenderer","depthIndex","GeometryBufferRenderer","wnormalIndex","scaleFactor","newSize","_IblShadowsSpatialBlurPass","_IblShadowsAccumulationPass","outputTextureOptions","accumulationOptions","localPositionOptions","remanence","velocityIndex","wPositionIndex","IblShadowsRenderPipeline","tex","axisNum","newResolution","IBLShadowsPluginMaterial","bounds","localBounds","halfSize","centre","invWorldScaleMatrix","blackPixels","textureTypesAndFormats","normalIndex","rows","cols","GIRSM","rsm","SpritePackedManager","SpriteManager","imgUrl","capacity","spriteJSON","epsilon"],"ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78],"sources":["../../node_modules/@babylonjs/core/Animations/animationPropertiesOverride.js","../../node_modules/@babylonjs/core/Animations/pathCursor.js","../../node_modules/@babylonjs/core/Audio/analyser.js","../../node_modules/@babylonjs/core/AudioV2/abstractAudio/audioEngineV2.js","../../node_modules/@babylonjs/core/AudioV2/abstractAudio/mainAudioOut.js","../../node_modules/@babylonjs/core/AudioV2/webAudio/webAudioMainOut.js","../../node_modules/@babylonjs/core/AudioV2/webAudio/webAudioUnmuteUI.js","../../node_modules/@babylonjs/core/AudioV2/webAudio/webAudioEngine.js","../../node_modules/@babylonjs/core/BakedVertexAnimation/vertexAnimationBaker.js","../../node_modules/@babylonjs/core/Behaviors/Meshes/attachToBoxBehavior.js","../../node_modules/@babylonjs/core/Behaviors/Meshes/fadeInOutBehavior.js","../../node_modules/@babylonjs/core/Behaviors/Meshes/multiPointerScaleBehavior.js","../../node_modules/@babylonjs/core/Behaviors/Meshes/baseSixDofDragBehavior.js","../../node_modules/@babylonjs/core/Behaviors/Meshes/sixDofDragBehavior.js","../../node_modules/@babylonjs/core/Behaviors/Meshes/surfaceMagnetismBehavior.js","../../node_modules/@babylonjs/core/Behaviors/Meshes/followBehavior.js","../../node_modules/@babylonjs/core/Maths/math.vertexFormat.js","../../node_modules/@babylonjs/core/Cameras/Stereoscopic/stereoscopicScreenUniversalCamera.js","../../node_modules/@babylonjs/core/Culling/Helper/boundingInfoHelper.js","../../node_modules/@babylonjs/core/Culling/Helper/computeShaderBoundingHelper.js","../../node_modules/@babylonjs/core/Gizmos/axisDragGizmo.js","../../node_modules/@babylonjs/core/Debug/axesViewer.js","../../node_modules/@babylonjs/core/Debug/boneAxesViewer.js","../../node_modules/@babylonjs/core/Debug/physicsViewer.js","../../node_modules/@babylonjs/core/Debug/rayHelper.js","../../node_modules/@babylonjs/core/Debug/directionalLightFrustumViewer.js","../../node_modules/@babylonjs/core/Engines/nullEngine.js","../../node_modules/@babylonjs/core/Engines/engineFactory.js","../../node_modules/@babylonjs/core/FlowGraph/flowGraphPathConverter.js","../../node_modules/@babylonjs/core/FrameGraph/frameGraphObjectList.js","../../node_modules/@babylonjs/core/Gizmos/rotationGizmo.js","../../node_modules/@babylonjs/core/Gizmos/planeDragGizmo.js","../../node_modules/@babylonjs/core/Gizmos/positionGizmo.js","../../node_modules/@babylonjs/core/Gizmos/scaleGizmo.js","../../node_modules/@babylonjs/core/Gizmos/gizmoManager.js","../../node_modules/@babylonjs/core/Helpers/materialConversionHelper.js","../../node_modules/@babylonjs/core/Instrumentation/engineInstrumentation.js","../../node_modules/@babylonjs/core/Instrumentation/sceneInstrumentation.js","../../node_modules/@babylonjs/core/Materials/Occlusion/occlusionMaterial.js","../../node_modules/@babylonjs/core/Materials/Textures/Procedurals/customProceduralTexture.js","../../node_modules/@babylonjs/core/Materials/Textures/rawTexture3D.js","../../node_modules/@babylonjs/core/Materials/Textures/refractionTexture.js","../../node_modules/@babylonjs/core/Materials/Textures/thinRenderTargetTexture.js","../../node_modules/@babylonjs/core/Materials/Node/nodeMaterialDefault.js","../../node_modules/@babylonjs/core/Materials/Node/Optimizers/nodeMaterialOptimizer.js","../../node_modules/@babylonjs/core/Materials/shadowDepthWrapper.js","../../node_modules/@babylonjs/core/Materials/materialPluginFactoryExport.js","../../node_modules/@babylonjs/core/Maths/math.polar.js","../../node_modules/@babylonjs/core/Meshes/abstractMesh.hotSpot.js","../../node_modules/@babylonjs/core/Meshes/meshUVSpaceRenderer.js","../../node_modules/@babylonjs/core/Meshes/meshUtils.js","../../node_modules/@babylonjs/core/Meshes/lattice.material.js","../../node_modules/@babylonjs/core/Misc/meshExploder.js","../../node_modules/@babylonjs/core/Misc/filesInput.js","../../node_modules/@babylonjs/core/Misc/sceneRecorder.js","../../node_modules/@babylonjs/core/Misc/pressureObserverWrapper.js","../../node_modules/@babylonjs/core/Misc/PerformanceViewer/performanceViewerCollectionStrategies.js","../../node_modules/@babylonjs/core/Misc/snapshotRenderingHelper.js","../../node_modules/@babylonjs/core/Misc/equirectangularCapture.js","../../node_modules/@babylonjs/core/Misc/asyncLock.js","../../node_modules/@babylonjs/core/Navigation/Plugins/recastJSPlugin.js","../../node_modules/@babylonjs/core/Particles/solidParticle.js","../../node_modules/@babylonjs/core/Particles/solidParticleSystem.js","../../node_modules/@babylonjs/core/Physics/v2/physicsBody.js","../../node_modules/@babylonjs/core/Physics/v2/physicsConstraint.js","../../node_modules/@babylonjs/core/Physics/v2/physicsAggregate.js","../../node_modules/@babylonjs/core/Physics/v2/ragdoll.js","../../node_modules/@babylonjs/core/Physics/v2/Plugins/havokPlugin.js","../../node_modules/@babylonjs/core/Physics/proximityCastResult.js","../../node_modules/@babylonjs/core/Physics/shapeCastResult.js","../../node_modules/@babylonjs/core/PostProcesses/highlightsPostProcess.js","../../node_modules/@babylonjs/core/PostProcesses/RenderPipeline/Pipelines/lensRenderingPipeline.js","../../node_modules/@babylonjs/core/Rendering/IBLShadows/iblShadowsVoxelRenderer.js","../../node_modules/@babylonjs/core/Rendering/IBLShadows/iblShadowsVoxelTracingPass.js","../../node_modules/@babylonjs/core/Rendering/IBLShadows/iblShadowsSpatialBlurPass.js","../../node_modules/@babylonjs/core/Rendering/IBLShadows/iblShadowsAccumulationPass.js","../../node_modules/@babylonjs/core/Rendering/IBLShadows/iblShadowsRenderPipeline.js","../../node_modules/@babylonjs/core/Rendering/GlobalIllumination/giRSM.js","../../node_modules/@babylonjs/core/Sprites/spritePackedManager.js"],"sourcesContent":["import { Animation } from \"../Animations/animation.js\";\n/**\n * Class used to override all child animations of a given target\n */\nexport class AnimationPropertiesOverride {\n    constructor() {\n        /**\n         * Gets or sets a value indicating if animation blending must be used\n         */\n        this.enableBlending = false;\n        /**\n         * Gets or sets the blending speed to use when enableBlending is true\n         */\n        this.blendingSpeed = 0.01;\n        /**\n         * Gets or sets the default loop mode to use\n         */\n        this.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE;\n    }\n}\n//# sourceMappingURL=animationPropertiesOverride.js.map","import { Vector3 } from \"../Maths/math.vector.js\";\n/**\n * A cursor which tracks a point on a path\n */\nexport class PathCursor {\n    /**\n     * Initializes the path cursor\n     * @param _path The path to track\n     */\n    constructor(_path) {\n        this._path = _path;\n        /**\n         * Stores path cursor callbacks for when an onchange event is triggered\n         */\n        this._onchange = new Array();\n        /**\n         * The value of the path cursor\n         */\n        this.value = 0;\n        /**\n         * The animation array of the path cursor\n         */\n        this.animations = [];\n    }\n    /**\n     * Gets the cursor point on the path\n     * @returns A point on the path cursor at the cursor location\n     */\n    getPoint() {\n        const point = this._path.getPointAtLengthPosition(this.value);\n        return new Vector3(point.x, 0, point.y);\n    }\n    /**\n     * Moves the cursor ahead by the step amount\n     * @param step The amount to move the cursor forward\n     * @returns This path cursor\n     */\n    moveAhead(step = 0.002) {\n        this.move(step);\n        return this;\n    }\n    /**\n     * Moves the cursor behind by the step amount\n     * @param step The amount to move the cursor back\n     * @returns This path cursor\n     */\n    moveBack(step = 0.002) {\n        this.move(-step);\n        return this;\n    }\n    /**\n     * Moves the cursor by the step amount\n     * If the step amount is greater than one, an exception is thrown\n     * @param step The amount to move the cursor\n     * @returns This path cursor\n     */\n    move(step) {\n        if (Math.abs(step) > 1) {\n            // eslint-disable-next-line no-throw-literal\n            throw \"step size should be less than 1.\";\n        }\n        this.value += step;\n        this._ensureLimits();\n        this._raiseOnChange();\n        return this;\n    }\n    /**\n     * Ensures that the value is limited between zero and one\n     * @returns This path cursor\n     */\n    _ensureLimits() {\n        while (this.value > 1) {\n            this.value -= 1;\n        }\n        while (this.value < 0) {\n            this.value += 1;\n        }\n        return this;\n    }\n    /**\n     * Runs onchange callbacks on change (used by the animation engine)\n     * @returns This path cursor\n     */\n    _raiseOnChange() {\n        this._onchange.forEach((f) => f(this));\n        return this;\n    }\n    /**\n     * Executes a function on change\n     * @param f A path cursor onchange callback\n     * @returns This path cursor\n     */\n    onchange(f) {\n        this._onchange.push(f);\n        return this;\n    }\n}\n//# sourceMappingURL=pathCursor.js.map","import { Tools } from \"../Misc/tools.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { AbstractEngine } from \"../Engines/abstractEngine.js\";\n/**\n * Class used to work with sound analyzer using fast fourier transform (FFT)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\n */\nexport class Analyser {\n    /**\n     * Creates a new analyser\n     * @param scene defines hosting scene\n     */\n    constructor(scene) {\n        /**\n         * Gets or sets the smoothing\n         * @ignorenaming\n         */\n        this.SMOOTHING = 0.75;\n        /**\n         * Gets or sets the FFT table size\n         * @ignorenaming\n         */\n        this.FFT_SIZE = 512;\n        /**\n         * Gets or sets the bar graph amplitude\n         * @ignorenaming\n         */\n        this.BARGRAPHAMPLITUDE = 256;\n        /**\n         * Gets or sets the position of the debug canvas\n         * @ignorenaming\n         */\n        this.DEBUGCANVASPOS = { x: 20, y: 20 };\n        /**\n         * Gets or sets the debug canvas size\n         * @ignorenaming\n         */\n        this.DEBUGCANVASSIZE = { width: 320, height: 200 };\n        scene = scene || EngineStore.LastCreatedScene;\n        if (!scene) {\n            return;\n        }\n        this._scene = scene;\n        if (!AbstractEngine.audioEngine) {\n            Tools.Warn(\"No audio engine initialized, failed to create an audio analyser\");\n            return;\n        }\n        this._audioEngine = AbstractEngine.audioEngine;\n        if (this._audioEngine.canUseWebAudio && this._audioEngine.audioContext) {\n            this._webAudioAnalyser = this._audioEngine.audioContext.createAnalyser();\n            this._webAudioAnalyser.minDecibels = -140;\n            this._webAudioAnalyser.maxDecibels = 0;\n            this._byteFreqs = new Uint8Array(this._webAudioAnalyser.frequencyBinCount);\n            this._byteTime = new Uint8Array(this._webAudioAnalyser.frequencyBinCount);\n            this._floatFreqs = new Float32Array(this._webAudioAnalyser.frequencyBinCount);\n        }\n    }\n    /**\n     * Get the number of data values you will have to play with for the visualization\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/frequencyBinCount\n     * @returns a number\n     */\n    getFrequencyBinCount() {\n        if (this._audioEngine.canUseWebAudio) {\n            return this._webAudioAnalyser.frequencyBinCount;\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * Gets the current frequency data as a byte array\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData\n     * @returns a Uint8Array\n     */\n    getByteFrequencyData() {\n        if (this._audioEngine.canUseWebAudio) {\n            this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING;\n            this._webAudioAnalyser.fftSize = this.FFT_SIZE;\n            this._webAudioAnalyser.getByteFrequencyData(this._byteFreqs);\n        }\n        return this._byteFreqs;\n    }\n    /**\n     * Gets the current waveform as a byte array\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteTimeDomainData\n     * @returns a Uint8Array\n     */\n    getByteTimeDomainData() {\n        if (this._audioEngine.canUseWebAudio) {\n            this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING;\n            this._webAudioAnalyser.fftSize = this.FFT_SIZE;\n            this._webAudioAnalyser.getByteTimeDomainData(this._byteTime);\n        }\n        return this._byteTime;\n    }\n    /**\n     * Gets the current frequency data as a float array\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData\n     * @returns a Float32Array\n     */\n    getFloatFrequencyData() {\n        if (this._audioEngine.canUseWebAudio) {\n            this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING;\n            this._webAudioAnalyser.fftSize = this.FFT_SIZE;\n            this._webAudioAnalyser.getFloatFrequencyData(this._floatFreqs);\n        }\n        return this._floatFreqs;\n    }\n    /**\n     * Renders the debug canvas\n     */\n    drawDebugCanvas() {\n        if (this._audioEngine.canUseWebAudio) {\n            if (!this._debugCanvas) {\n                this._debugCanvas = document.createElement(\"canvas\");\n                this._debugCanvas.width = this.DEBUGCANVASSIZE.width;\n                this._debugCanvas.height = this.DEBUGCANVASSIZE.height;\n                this._debugCanvas.style.position = \"absolute\";\n                this._debugCanvas.style.top = this.DEBUGCANVASPOS.y + \"px\";\n                this._debugCanvas.style.left = this.DEBUGCANVASPOS.x + \"px\";\n                this._debugCanvasContext = this._debugCanvas.getContext(\"2d\");\n                document.body.appendChild(this._debugCanvas);\n                this._registerFunc = () => {\n                    this.drawDebugCanvas();\n                };\n                this._scene.registerBeforeRender(this._registerFunc);\n            }\n            if (this._registerFunc && this._debugCanvasContext) {\n                const workingArray = this.getByteFrequencyData();\n                this._debugCanvasContext.fillStyle = \"rgb(0, 0, 0)\";\n                this._debugCanvasContext.fillRect(0, 0, this.DEBUGCANVASSIZE.width, this.DEBUGCANVASSIZE.height);\n                // Draw the frequency domain chart.\n                for (let i = 0; i < this.getFrequencyBinCount(); i++) {\n                    const value = workingArray[i];\n                    const percent = value / this.BARGRAPHAMPLITUDE;\n                    const height = this.DEBUGCANVASSIZE.height * percent;\n                    const offset = this.DEBUGCANVASSIZE.height - height - 1;\n                    const barWidth = this.DEBUGCANVASSIZE.width / this.getFrequencyBinCount();\n                    const hue = (i / this.getFrequencyBinCount()) * 360;\n                    this._debugCanvasContext.fillStyle = \"hsl(\" + hue + \", 100%, 50%)\";\n                    this._debugCanvasContext.fillRect(i * barWidth, offset, barWidth, height);\n                }\n            }\n        }\n    }\n    /**\n     * Stops rendering the debug canvas and removes it\n     */\n    stopDebugCanvas() {\n        if (this._debugCanvas) {\n            if (this._registerFunc) {\n                this._scene.unregisterBeforeRender(this._registerFunc);\n                this._registerFunc = null;\n            }\n            document.body.removeChild(this._debugCanvas);\n            this._debugCanvas = null;\n            this._debugCanvasContext = null;\n        }\n    }\n    /**\n     * Connects two audio nodes\n     * @param inputAudioNode defines first node to connect\n     * @param outputAudioNode defines second node to connect\n     */\n    connectAudioNodes(inputAudioNode, outputAudioNode) {\n        if (this._audioEngine.canUseWebAudio) {\n            inputAudioNode.connect(this._webAudioAnalyser);\n            this._webAudioAnalyser.connect(outputAudioNode);\n        }\n    }\n    /**\n     * Releases all associated resources\n     */\n    dispose() {\n        if (this._audioEngine.canUseWebAudio) {\n            this._webAudioAnalyser.disconnect();\n        }\n    }\n}\n//# sourceMappingURL=analyser.js.map","const Instances = [];\n/**\n * Gets the most recently created v2 audio engine.\n * @returns The most recently created v2 audio engine.\n */\nexport function LastCreatedAudioEngine() {\n    if (Instances.length === 0) {\n        return null;\n    }\n    return Instances[Instances.length - 1];\n}\n/**\n * Abstract base class for v2 audio engines.\n *\n * A v2 audio engine based on the WebAudio API can be created with the {@link CreateAudioEngineAsync} function.\n */\nexport class AudioEngineV2 {\n    constructor(options) {\n        /** Not owned, but all items should be in `_nodes` container, too, which is owned. */\n        this._mainBuses = new Set();\n        /** Owned top-level sound and bus nodes. */\n        this._nodes = new Set();\n        this._defaultMainBus = null;\n        this._parameterRampDuration = 0.01;\n        Instances.push(this);\n        if (typeof options.parameterRampDuration === \"number\") {\n            this.parameterRampDuration = options.parameterRampDuration;\n        }\n    }\n    /**\n     * The default main bus that will be used for audio buses and sounds if their `outBus` option is not set.\n     * @see {@link IAudioBusOptions.outBus}\n     * @see {@link IAbstractSoundOptions.outBus}\n     */\n    get defaultMainBus() {\n        if (this._mainBuses.size === 0) {\n            return null;\n        }\n        if (!this._defaultMainBus) {\n            this._defaultMainBus = Array.from(this._mainBuses)[0];\n        }\n        return this._defaultMainBus;\n    }\n    /**\n     * The smoothing duration to use when changing audio parameters, in seconds. Defaults to `0.01` (10 milliseconds).\n     */\n    get parameterRampDuration() {\n        return this._parameterRampDuration;\n    }\n    set parameterRampDuration(value) {\n        this._parameterRampDuration = Math.max(0, value);\n    }\n    /**\n     * Releases associated resources.\n     */\n    dispose() {\n        if (Instances.includes(this)) {\n            Instances.splice(Instances.indexOf(this), 1);\n        }\n        const nodeIt = this._nodes.values();\n        for (let next = nodeIt.next(); !next.done; next = nodeIt.next()) {\n            next.value.dispose();\n        }\n        this._mainBuses.clear();\n        this._nodes.clear();\n        this._defaultMainBus = null;\n    }\n    /**\n     * Unlocks the audio engine if it is locked.\n     * - Note that the returned promise may already be resolved if the audio engine is already unlocked.\n     * @returns A promise that is resolved when the audio engine is unlocked.\n     */\n    unlockAsync() {\n        return this.resumeAsync();\n    }\n    _addMainBus(mainBus) {\n        this._mainBuses.add(mainBus);\n        this._addNode(mainBus);\n    }\n    _removeMainBus(mainBus) {\n        this._mainBuses.delete(mainBus);\n        this._defaultMainBus = null;\n        this._removeNode(mainBus);\n    }\n    _addNode(node) {\n        this._nodes.add(node);\n    }\n    _removeNode(node) {\n        this._nodes.delete(node);\n    }\n}\n/**\n * @internal\n * @param engine - The given audio engine. If `null` then the last created audio engine is used.\n * @returns the given audio engine or the last created audio engine.\n * @throws An error if the resulting engine is `null`.\n */\nexport function _GetAudioEngine(engine) {\n    if (!engine) {\n        engine = LastCreatedAudioEngine();\n    }\n    if (engine) {\n        return engine;\n    }\n    throw new Error(\"No audio engine.\");\n}\n/**\n * Creates a new audio bus.\n * @param name - The name of the audio bus.\n * @param options - The options to use when creating the audio bus.\n * @param engine - The audio engine.\n * @returns A promise that resolves with the created audio bus.\n */\nexport function CreateAudioBusAsync(name, options = {}, engine = null) {\n    engine = _GetAudioEngine(engine);\n    return engine.createBusAsync(name, options);\n}\n/**\n * Creates a new main audio bus.\n * @param name - The name of the main audio bus.\n * @param options - The options to use when creating the main audio bus.\n * @param engine - The audio engine.\n * @returns A promise that resolves with the created main audio bus.\n */\nexport function CreateMainAudioBusAsync(name, options = {}, engine = null) {\n    engine = _GetAudioEngine(engine);\n    return engine.createMainBusAsync(name, options);\n}\n/**\n * Creates a new static sound.\n * @param name - The name of the sound.\n * @param source - The source of the sound.\n * @param options - The options for the static sound.\n * @param engine - The audio engine.\n * @returns A promise that resolves to the created static sound.\n */\nexport function CreateSoundAsync(name, source, options = {}, engine = null) {\n    engine = _GetAudioEngine(engine);\n    return engine.createSoundAsync(name, source, options);\n}\n/**\n * Creates a new static sound buffer.\n * @param source - The source of the sound buffer.\n * @param options - The options for the static sound buffer.\n * @param engine - The audio engine.\n * @returns A promise that resolves to the created static sound buffer.\n */\nexport async function CreateSoundBufferAsync(source, options = {}, engine = null) {\n    engine = _GetAudioEngine(engine);\n    return engine.createSoundBufferAsync(source, options);\n}\n/**\n * Creates a new streaming sound.\n * @param name - The name of the sound.\n * @param source - The source of the sound.\n * @param options - The options for the streaming sound.\n * @param engine - The audio engine.\n * @returns A promise that resolves to the created streaming sound.\n */\nexport function CreateStreamingSoundAsync(name, source, options = {}, engine = null) {\n    engine = _GetAudioEngine(engine);\n    return engine.createStreamingSoundAsync(name, source, options);\n}\n//# sourceMappingURL=audioEngineV2.js.map","import { AbstractAudioNode } from \"./abstractAudioNode.js\";\n/**\n * Abstract class for the main audio output node.\n *\n * A main audio output is the last audio node in the audio graph before the audio is sent to the speakers.\n *\n * @see {@link AudioEngineV2.mainOut}\n * @internal\n */\nexport class _MainAudioOut extends AbstractAudioNode {\n    constructor(engine) {\n        super(engine, 1 /* AudioNodeType.HAS_INPUTS */);\n    }\n}\n//# sourceMappingURL=mainAudioOut.js.map","import { _MainAudioOut } from \"../abstractAudio/mainAudioOut.js\";\n/** @internal */\nexport class _WebAudioMainOut extends _MainAudioOut {\n    /** @internal */\n    constructor(engine) {\n        super(engine);\n        this._volume = 1;\n        const audioContext = engine._audioContext;\n        this._gainNode = new GainNode(audioContext);\n        this._destinationNode = audioContext.destination;\n        this._gainNode.connect(this._destinationNode);\n    }\n    /** @internal */\n    get _inNode() {\n        return this._gainNode;\n    }\n    /** @internal */\n    get volume() {\n        return this._volume;\n    }\n    /** @internal */\n    set volume(value) {\n        this._volume = value;\n        this.engine._setAudioParam(this._gainNode.gain, value);\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this._gainNode.disconnect();\n        this._destinationNode.disconnect();\n    }\n    /** @internal */\n    getClassName() {\n        return \"_WebAudioMainOut\";\n    }\n}\n//# sourceMappingURL=webAudioMainOut.js.map","import { EngineStore } from \"../../Engines/engineStore.js\";\n/**\n * Adds a UI button that starts the audio engine's underlying audio context when the user presses it.\n * @internal\n */\nexport class _WebAudioUnmuteUI {\n    /** @internal */\n    constructor(engine, parentElement) {\n        this._button = null;\n        this._style = null;\n        this._onStateChanged = () => {\n            if (!this._button) {\n                return;\n            }\n            if (this._engine.state === \"running\") {\n                this._button.style.display = \"none\";\n            }\n            else {\n                this._button.style.display = \"block\";\n            }\n        };\n        this._engine = engine;\n        const parent = parentElement || EngineStore.LastCreatedEngine?.getInputElement()?.parentElement || document.body;\n        const top = (parent?.offsetTop || 0) + 20;\n        this._style = document.createElement(\"style\");\n        this._style.appendChild(document.createTextNode(`.babylonUnmute{position:absolute;top:${top}px;margin-left:20px;height:40px;width:60px;background-color:rgba(51,51,51,0.7);background-image:url(\"data:image/svg+xml;charset=UTF-8,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2239%22%20height%3D%2232%22%20viewBox%3D%220%200%2039%2032%22%3E%3Cpath%20fill%3D%22white%22%20d%3D%22M9.625%2018.938l-0.031%200.016h-4.953q-0.016%200-0.031-0.016v-12.453q0-0.016%200.031-0.016h4.953q0.031%200%200.031%200.016v12.453zM12.125%207.688l8.719-8.703v27.453l-8.719-8.719-0.016-0.047v-9.938zM23.359%207.875l1.406-1.406%204.219%204.203%204.203-4.203%201.422%201.406-4.219%204.219%204.219%204.203-1.484%201.359-4.141-4.156-4.219%204.219-1.406-1.422%204.219-4.203z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");background-size:80%;background-repeat:no-repeat;background-position:center;background-position-y:4px;border:none;outline:none;transition:transform 0.125s ease-out;cursor:pointer;z-index:9999;}.babylonUnmute:hover{transform:scale(1.05)}`));\n        document.head.appendChild(this._style);\n        this._button = document.createElement(\"button\");\n        this._button.className = \"babylonUnmute\";\n        this._button.id = \"babylonUnmuteButton\";\n        this._button.addEventListener(\"click\", () => {\n            this._engine.unlockAsync();\n        });\n        parent.appendChild(this._button);\n        this._engine.stateChangedObservable.add(this._onStateChanged);\n    }\n    /** @internal */\n    dispose() {\n        this._button?.remove();\n        this._button = null;\n        this._style?.remove();\n        this._style = null;\n        this._engine.stateChangedObservable.removeCallback(this._onStateChanged);\n    }\n}\n//# sourceMappingURL=webAudioUnmuteUI.js.map","import { Observable } from \"../../Misc/observable.js\";\nimport { AudioEngineV2 } from \"../abstractAudio/audioEngineV2.js\";\nimport { _HasSpatialAudioListenerOptions } from \"../abstractAudio/subProperties/abstractSpatialAudioListener.js\";\nimport { _CreateSpatialAudioListener } from \"./subProperties/spatialWebAudioListener.js\";\nimport { _WebAudioMainOut } from \"./webAudioMainOut.js\";\nimport { _WebAudioUnmuteUI } from \"./webAudioUnmuteUI.js\";\n/**\n * Creates a new v2 audio engine that uses the WebAudio API.\n * @param options - The options for creating the audio engine.\n * @returns A promise that resolves with the created audio engine.\n */\nexport async function CreateAudioEngineAsync(options = {}) {\n    const engine = new _WebAudioEngine(options);\n    await engine._init(options);\n    return engine;\n}\nconst FormatMimeTypes = {\n    aac: \"audio/aac\",\n    ac3: \"audio/ac3\",\n    flac: \"audio/flac\",\n    m4a: \"audio/mp4\",\n    mp3: 'audio/mpeg; codecs=\"mp3\"',\n    mp4: \"audio/mp4\",\n    ogg: 'audio/ogg; codecs=\"vorbis\"',\n    wav: \"audio/wav\",\n    webm: 'audio/webm; codecs=\"vorbis\"',\n};\n/** @internal */\nexport class _WebAudioEngine extends AudioEngineV2 {\n    /** @internal */\n    constructor(options = {}) {\n        super(options);\n        this._audioContextStarted = false;\n        this._invalidFormats = new Set();\n        this._listener = null;\n        this._pauseCalled = false;\n        this._resumeOnInteraction = true;\n        this._resumeOnPause = true;\n        this._resumeOnPauseRetryInterval = 1000;\n        this._resumeOnPauseTimerId = null;\n        this._resumePromise = null;\n        this._listenerAutoUpdate = true;\n        this._listenerMinUpdateTime = 0;\n        this._unmuteUI = null;\n        this._validFormats = new Set();\n        this._volume = 1;\n        /** @internal */\n        this.isReadyPromise = new Promise((resolve) => {\n            this._resolveIsReadyPromise = resolve;\n        });\n        /** @internal */\n        this.stateChangedObservable = new Observable();\n        /** @internal */\n        this.userGestureObservable = new Observable();\n        this._initAudioContext = async () => {\n            this._audioContext.addEventListener(\"statechange\", this._onAudioContextStateChange);\n            this._mainOut = new _WebAudioMainOut(this);\n            this._mainOut.volume = this._volume;\n            await this.createMainBusAsync(\"default\");\n        };\n        this._onAudioContextStateChange = () => {\n            if (this.state === \"running\") {\n                clearInterval(this._resumeOnPauseTimerId);\n                this._audioContextStarted = true;\n                this._resumePromise = null;\n            }\n            if (this.state === \"suspended\" || this.state === \"interrupted\") {\n                if (this._audioContextStarted && this._resumeOnPause && !this._pauseCalled) {\n                    clearInterval(this._resumeOnPauseTimerId);\n                    this._resumeOnPauseTimerId = setInterval(() => {\n                        this.resumeAsync();\n                    }, this._resumeOnPauseRetryInterval);\n                }\n            }\n            this.stateChangedObservable.notifyObservers(this.state);\n        };\n        this._onUserGesture = async () => {\n            if (this._resumeOnInteraction) {\n                await this._audioContext.resume();\n            }\n            this.userGestureObservable.notifyObservers();\n        };\n        if (typeof options.listenerAutoUpdate === \"boolean\") {\n            this._listenerAutoUpdate = options.listenerAutoUpdate;\n        }\n        if (typeof options.listenerMinUpdateTime === \"number\") {\n            this._listenerMinUpdateTime = options.listenerMinUpdateTime;\n        }\n        this._volume = options.volume ?? 1;\n        this._audioContext = options.audioContext ?? new AudioContext();\n        if (!options.disableDefaultUI) {\n            this._unmuteUI = new _WebAudioUnmuteUI(this, options.defaultUIParentElement);\n        }\n    }\n    /** @internal */\n    async _init(options) {\n        this._resumeOnInteraction = typeof options.resumeOnInteraction === \"boolean\" ? options.resumeOnInteraction : true;\n        this._resumeOnPause = typeof options.resumeOnPause === \"boolean\" ? options.resumeOnPause : true;\n        this._resumeOnPauseRetryInterval = options.resumeOnPauseRetryInterval ?? 1000;\n        document.addEventListener(\"click\", this._onUserGesture);\n        await this._initAudioContext();\n        if (_HasSpatialAudioListenerOptions(options)) {\n            this._listener = _CreateSpatialAudioListener(this, this._listenerAutoUpdate, this._listenerMinUpdateTime);\n            this._listener.setOptions(options);\n        }\n        this._resolveIsReadyPromise();\n    }\n    /** @internal */\n    get currentTime() {\n        return this._audioContext.currentTime ?? 0;\n    }\n    /** @internal */\n    get _inNode() {\n        return this._audioContext.destination;\n    }\n    /** @internal */\n    get mainOut() {\n        return this._mainOut;\n    }\n    /** @internal */\n    get listener() {\n        return this._listener ?? (this._listener = _CreateSpatialAudioListener(this, this._listenerAutoUpdate, this._listenerMinUpdateTime));\n    }\n    /** @internal */\n    get state() {\n        return this._audioContext.state;\n    }\n    /** @internal */\n    get volume() {\n        return this._volume;\n    }\n    /** @internal */\n    set volume(value) {\n        if (this._volume === value) {\n            return;\n        }\n        this._volume = value;\n        if (this._mainOut) {\n            this._mainOut.volume = value;\n        }\n    }\n    /** @internal */\n    async createBusAsync(name, options = {}) {\n        const module = await import(\"./webAudioBus.js\");\n        const bus = new module._WebAudioBus(name, this, options);\n        await bus._init(options);\n        return bus;\n    }\n    /** @internal */\n    async createMainBusAsync(name, options = {}) {\n        const module = await import(\"./webAudioMainBus.js\");\n        const bus = new module._WebAudioMainBus(name, this);\n        await bus._init(options);\n        return bus;\n    }\n    /** @internal */\n    async createSoundAsync(name, source, options = {}) {\n        const module = await import(\"./webAudioStaticSound.js\");\n        const sound = new module._WebAudioStaticSound(name, this, options);\n        await sound._init(source, options);\n        return sound;\n    }\n    /** @internal */\n    async createSoundBufferAsync(source, options = {}) {\n        const module = await import(\"./webAudioStaticSound.js\");\n        const soundBuffer = new module._WebAudioStaticSoundBuffer(this);\n        await soundBuffer._init(source, options);\n        return soundBuffer;\n    }\n    /** @internal */\n    async createStreamingSoundAsync(name, source, options = {}) {\n        const module = await import(\"./webAudioStreamingSound.js\");\n        const sound = new module._WebAudioStreamingSound(name, this, options);\n        await sound._init(source, options);\n        return sound;\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this._listener?.dispose();\n        this._listener = null;\n        if (this._audioContext.state !== \"closed\") {\n            this._audioContext.close();\n        }\n        document.removeEventListener(\"click\", this._onUserGesture);\n        this._audioContext.removeEventListener(\"statechange\", this._onAudioContextStateChange);\n        this._unmuteUI?.dispose();\n        this._unmuteUI = null;\n    }\n    /** @internal */\n    flagInvalidFormat(format) {\n        this._invalidFormats.add(format);\n    }\n    /** @internal */\n    isFormatValid(format) {\n        if (this._validFormats.has(format)) {\n            return true;\n        }\n        if (this._invalidFormats.has(format)) {\n            return false;\n        }\n        const mimeType = FormatMimeTypes[format];\n        if (mimeType === undefined) {\n            return false;\n        }\n        const audio = new Audio();\n        if (audio.canPlayType(mimeType) === \"\") {\n            this._invalidFormats.add(format);\n            return false;\n        }\n        this._validFormats.add(format);\n        return true;\n    }\n    /** @internal */\n    async pauseAsync() {\n        await this._audioContext.suspend();\n        this._pauseCalled = true;\n    }\n    /** @internal */\n    resumeAsync() {\n        this._pauseCalled = false;\n        if (this._resumePromise) {\n            return this._resumePromise;\n        }\n        this._resumePromise = this._audioContext.resume();\n        return this._resumePromise;\n    }\n    /** @internal */\n    _addMainBus(mainBus) {\n        super._addMainBus(mainBus);\n    }\n    /** @internal */\n    _removeMainBus(mainBus) {\n        super._removeMainBus(mainBus);\n    }\n    /** @internal */\n    _addNode(node) {\n        super._addNode(node);\n    }\n    /** @internal */\n    _removeNode(node) {\n        super._removeNode(node);\n    }\n    /** @internal */\n    _setAudioParam(audioParam, value) {\n        audioParam.linearRampToValueAtTime(value, this.currentTime + this.parameterRampDuration);\n    }\n}\n//# sourceMappingURL=webAudioEngine.js.map","import { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { EncodeArrayBufferToBase64, DecodeBase64ToBinary } from \"../Misc/stringTools.js\";\n\nimport { Skeleton } from \"../Bones/skeleton.js\";\n/**\n * Class to bake vertex animation textures.\n * @since 5.0\n */\nexport class VertexAnimationBaker {\n    /**\n     * Create a new VertexAnimationBaker object which can help baking animations into a texture.\n     * @param scene Defines the scene the VAT belongs to\n     * @param meshOrSkeleton Defines the skeleton or the mesh from which to retrieve the skeleton from.\n     */\n    constructor(scene, meshOrSkeleton) {\n        this._scene = scene;\n        if (meshOrSkeleton instanceof Skeleton) {\n            this._skeleton = meshOrSkeleton;\n            this._mesh = null;\n        }\n        else {\n            this._mesh = meshOrSkeleton;\n            this._skeleton = meshOrSkeleton.skeleton;\n        }\n    }\n    /**\n     * Bakes the animation into the texture. This should be called once, when the\n     * scene starts, so the VAT is generated and associated to the mesh.\n     * @param ranges Defines the ranges in the animation that will be baked.\n     * @returns The array of matrix transforms for each vertex (columns) and frame (rows), as a Float32Array.\n     */\n    async bakeVertexData(ranges) {\n        if (!this._skeleton) {\n            throw new Error(\"No skeleton provided.\");\n        }\n        const boneCount = this._skeleton.bones.length;\n        /** total number of frames in our animations */\n        const frameCount = ranges.reduce((previous, current) => previous + current.to - current.from + 1, 0);\n        if (isNaN(frameCount)) {\n            throw new Error(\"Invalid animation ranges.\");\n        }\n        // reset our loop data\n        let textureIndex = 0;\n        const textureSize = (boneCount + 1) * 4 * 4 * frameCount;\n        const vertexData = new Float32Array(textureSize);\n        this._scene.stopAnimation(this._skeleton);\n        this._skeleton.returnToRest();\n        // render all frames from our slices\n        for (const range of ranges) {\n            for (let frameIndex = range.from; frameIndex <= range.to; frameIndex++) {\n                await this._executeAnimationFrame(vertexData, frameIndex, textureIndex++);\n            }\n        }\n        return vertexData;\n    }\n    /**\n     * Runs an animation frame and stores its vertex data\n     *\n     * @param vertexData The array to save data to.\n     * @param frameIndex Current frame in the skeleton animation to render.\n     * @param textureIndex Current index of the texture data.\n     */\n    async _executeAnimationFrame(vertexData, frameIndex, textureIndex) {\n        return new Promise((resolve, _reject) => {\n            this._scene.beginAnimation(this._skeleton, frameIndex, frameIndex, false, 1.0, () => {\n                // generate matrices\n                const skeletonMatrices = this._skeleton.getTransformMatrices(this._mesh);\n                vertexData.set(skeletonMatrices, textureIndex * skeletonMatrices.length);\n                resolve();\n            });\n        });\n    }\n    /**\n     * Builds a vertex animation texture given the vertexData in an array.\n     * @param vertexData The vertex animation data. You can generate it with bakeVertexData().\n     * @returns The vertex animation texture to be used with BakedVertexAnimationManager.\n     */\n    textureFromBakedVertexData(vertexData) {\n        if (!this._skeleton) {\n            throw new Error(\"No skeleton provided.\");\n        }\n        const boneCount = this._skeleton.bones.length;\n        const texture = RawTexture.CreateRGBATexture(vertexData, (boneCount + 1) * 4, vertexData.length / ((boneCount + 1) * 4 * 4), this._scene, false, false, Texture.NEAREST_NEAREST, 1);\n        texture.name = \"VAT\" + this._skeleton.name;\n        return texture;\n    }\n    /**\n     * Serializes our vertexData to an object, with a nice string for the vertexData.\n     * @param vertexData The vertex array data.\n     * @returns This object serialized to a JS dict.\n     */\n    serializeBakedVertexDataToObject(vertexData) {\n        if (!this._skeleton) {\n            throw new Error(\"No skeleton provided.\");\n        }\n        // this converts the float array to a serialized base64 string, ~1.3x larger\n        // than the original.\n        const boneCount = this._skeleton.bones.length;\n        const width = (boneCount + 1) * 4;\n        const height = vertexData.length / ((boneCount + 1) * 4 * 4);\n        const data = {\n            vertexData: EncodeArrayBufferToBase64(vertexData),\n            width,\n            height,\n        };\n        return data;\n    }\n    /**\n     * Loads previously baked data.\n     * @param data The object as serialized by serializeBakedVertexDataToObject()\n     * @returns The array of matrix transforms for each vertex (columns) and frame (rows), as a Float32Array.\n     */\n    loadBakedVertexDataFromObject(data) {\n        return new Float32Array(DecodeBase64ToBinary(data.vertexData));\n    }\n    /**\n     * Serializes our vertexData to a JSON string, with a nice string for the vertexData.\n     * Should be called right after bakeVertexData().\n     * @param vertexData The vertex array data.\n     * @returns This object serialized to a safe string.\n     */\n    serializeBakedVertexDataToJSON(vertexData) {\n        return JSON.stringify(this.serializeBakedVertexDataToObject(vertexData));\n    }\n    /**\n     * Loads previously baked data in string format.\n     * @param json The json string as serialized by serializeBakedVertexDataToJSON().\n     * @returns The array of matrix transforms for each vertex (columns) and frame (rows), as a Float32Array.\n     */\n    loadBakedVertexDataFromJSON(json) {\n        return this.loadBakedVertexDataFromObject(JSON.parse(json));\n    }\n}\n//# sourceMappingURL=vertexAnimationBaker.js.map","import { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector.js\";\n/**\n * @internal\n */\nclass FaceDirectionInfo {\n    constructor(direction, rotatedDirection = new Vector3(), diff = 0, ignore = false) {\n        this.direction = direction;\n        this.rotatedDirection = rotatedDirection;\n        this.diff = diff;\n        this.ignore = ignore;\n    }\n}\n/**\n * A behavior that when attached to a mesh will will place a specified node on the meshes face pointing towards the camera\n */\nexport class AttachToBoxBehavior {\n    /**\n     * Creates the AttachToBoxBehavior, used to attach UI to the closest face of the box to a camera\n     * @param _ui The transform node that should be attached to the mesh\n     */\n    constructor(_ui) {\n        this._ui = _ui;\n        /**\n         *  [\"AttachToBoxBehavior\"] The name of the behavior\n         */\n        this.name = \"AttachToBoxBehavior\";\n        /**\n         * [0.15] The distance away from the face of the mesh that the UI should be attached to (default: 0.15)\n         */\n        this.distanceAwayFromFace = 0.15;\n        /**\n         * [0.15] The distance from the bottom of the face that the UI should be attached to (default: 0.15)\n         */\n        this.distanceAwayFromBottomOfFace = 0.15;\n        this._faceVectors = [\n            new FaceDirectionInfo(Vector3.Up()),\n            new FaceDirectionInfo(Vector3.Down()),\n            new FaceDirectionInfo(Vector3.Left()),\n            new FaceDirectionInfo(Vector3.Right()),\n            new FaceDirectionInfo(Vector3.Forward()),\n            new FaceDirectionInfo(Vector3.Forward().scaleInPlace(-1)),\n        ];\n        this._tmpMatrix = new Matrix();\n        this._tmpVector = new Vector3();\n        this._zeroVector = Vector3.Zero();\n        this._lookAtTmpMatrix = new Matrix();\n        /* Does nothing */\n    }\n    /**\n     *  Initializes the behavior\n     */\n    init() {\n        /* Does nothing */\n    }\n    _closestFace(targetDirection) {\n        // Go over each face and calculate the angle between the face's normal and targetDirection\n        this._faceVectors.forEach((v) => {\n            if (!this._target.rotationQuaternion) {\n                this._target.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._target.rotation.y, this._target.rotation.x, this._target.rotation.z);\n            }\n            this._target.rotationQuaternion.toRotationMatrix(this._tmpMatrix);\n            Vector3.TransformCoordinatesToRef(v.direction, this._tmpMatrix, v.rotatedDirection);\n            v.diff = Vector3.GetAngleBetweenVectors(v.rotatedDirection, targetDirection, Vector3.Cross(v.rotatedDirection, targetDirection));\n        });\n        // Return the face information of the one with the normal closest to target direction\n        return this._faceVectors.reduce((min, p) => {\n            if (min.ignore) {\n                return p;\n            }\n            else if (p.ignore) {\n                return min;\n            }\n            else {\n                return min.diff < p.diff ? min : p;\n            }\n        }, this._faceVectors[0]);\n    }\n    _lookAtToRef(pos, up = new Vector3(0, 1, 0), ref) {\n        Matrix.LookAtLHToRef(this._zeroVector, pos, up, this._lookAtTmpMatrix);\n        this._lookAtTmpMatrix.invert();\n        Quaternion.FromRotationMatrixToRef(this._lookAtTmpMatrix, ref);\n    }\n    /**\n     * Attaches the AttachToBoxBehavior to the passed in mesh\n     * @param target The mesh that the specified node will be attached to\n     */\n    attach(target) {\n        this._target = target;\n        this._scene = this._target.getScene();\n        // Every frame, update the app bars position\n        this._onRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\n            if (!this._scene.activeCamera) {\n                return;\n            }\n            // Find the face closest to the cameras position\n            let cameraPos = this._scene.activeCamera.position;\n            if (this._scene.activeCamera.devicePosition) {\n                cameraPos = this._scene.activeCamera.devicePosition;\n            }\n            const facing = this._closestFace(cameraPos.subtract(target.position));\n            if (this._scene.activeCamera.leftCamera) {\n                this._scene.activeCamera.leftCamera.computeWorldMatrix().getRotationMatrixToRef(this._tmpMatrix);\n            }\n            else {\n                this._scene.activeCamera.computeWorldMatrix().getRotationMatrixToRef(this._tmpMatrix);\n            }\n            // Get camera up direction\n            Vector3.TransformCoordinatesToRef(Vector3.Up(), this._tmpMatrix, this._tmpVector);\n            // Ignore faces to not select a parallel face for the up vector of the UI\n            this._faceVectors.forEach((v) => {\n                if (facing.direction.x && v.direction.x) {\n                    v.ignore = true;\n                }\n                if (facing.direction.y && v.direction.y) {\n                    v.ignore = true;\n                }\n                if (facing.direction.z && v.direction.z) {\n                    v.ignore = true;\n                }\n            });\n            const facingUp = this._closestFace(this._tmpVector);\n            // Unignore faces\n            this._faceVectors.forEach((v) => {\n                v.ignore = false;\n            });\n            // Position the app bar on that face\n            this._ui.position.copyFrom(target.position);\n            if (facing.direction.x) {\n                facing.rotatedDirection.scaleToRef(target.scaling.x / 2 + this.distanceAwayFromFace, this._tmpVector);\n                this._ui.position.addInPlace(this._tmpVector);\n            }\n            if (facing.direction.y) {\n                facing.rotatedDirection.scaleToRef(target.scaling.y / 2 + this.distanceAwayFromFace, this._tmpVector);\n                this._ui.position.addInPlace(this._tmpVector);\n            }\n            if (facing.direction.z) {\n                facing.rotatedDirection.scaleToRef(target.scaling.z / 2 + this.distanceAwayFromFace, this._tmpVector);\n                this._ui.position.addInPlace(this._tmpVector);\n            }\n            // Rotate to be oriented properly to the camera\n            if (!this._ui.rotationQuaternion) {\n                this._ui.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ui.rotation.y, this._ui.rotation.x, this._ui.rotation.z);\n            }\n            facing.rotatedDirection.scaleToRef(-1, this._tmpVector);\n            this._lookAtToRef(this._tmpVector, facingUp.rotatedDirection, this._ui.rotationQuaternion);\n            // Place ui the correct distance from the bottom of the mesh\n            if (facingUp.direction.x) {\n                this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.x / 2, this._tmpVector);\n            }\n            if (facingUp.direction.y) {\n                this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.y / 2, this._tmpVector);\n            }\n            if (facingUp.direction.z) {\n                this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.z / 2, this._tmpVector);\n            }\n            this._ui.position.addInPlace(this._tmpVector);\n        });\n    }\n    /**\n     *  Detaches the behavior from the mesh\n     */\n    detach() {\n        this._scene.onBeforeRenderObservable.remove(this._onRenderObserver);\n    }\n}\n//# sourceMappingURL=attachToBoxBehavior.js.map","/**\n * A behavior that when attached to a mesh will allow the mesh to fade in and out\n */\nexport class FadeInOutBehavior {\n    /**\n     * Time in milliseconds to delay before fading in (Default: 0)\n     * Will set both fade in and out delay to the same value\n     */\n    get delay() {\n        return this.fadeInDelay;\n    }\n    set delay(value) {\n        this.fadeInDelay = value;\n        this.fadeOutDelay = value;\n    }\n    /**\n     * Instantiates the FadeInOutBehavior\n     */\n    constructor() {\n        /**\n         * Time in milliseconds to delay before fading in (Default: 0)\n         */\n        this.fadeInDelay = 0;\n        /**\n         * Time in milliseconds to delay before fading out (Default: 0)\n         */\n        this.fadeOutDelay = 0;\n        /**\n         * Time in milliseconds for the mesh to fade in (Default: 300)\n         */\n        this.fadeInTime = 300;\n        /**\n         * Time in milliseconds for the mesh to fade out (Default: 300)\n         */\n        this.fadeOutTime = 300;\n        this._millisecondsPerFrame = 1000 / 60;\n        this._hovered = false;\n        this._hoverValue = 0;\n        this._ownerNode = null;\n        this._delay = 0;\n        this._time = 300;\n        this._update = () => {\n            if (this._ownerNode) {\n                this._hoverValue += this._hovered ? this._millisecondsPerFrame : -this._millisecondsPerFrame;\n                this._setAllVisibility(this._ownerNode, (this._hoverValue - this._delay) / this._time);\n                if (this._ownerNode.visibility > 1) {\n                    this._setAllVisibility(this._ownerNode, 1);\n                    if (this._hoverValue > this._time) {\n                        this._hoverValue = this._time;\n                        this._detachObserver();\n                        return;\n                    }\n                }\n                else if (this._ownerNode.visibility < 0) {\n                    this._setAllVisibility(this._ownerNode, 0);\n                    if (this._hoverValue < 0) {\n                        this._hoverValue = 0;\n                        this._detachObserver();\n                        return;\n                    }\n                }\n                this._attachObserver();\n            }\n        };\n    }\n    /**\n     *  The name of the behavior\n     */\n    get name() {\n        return \"FadeInOut\";\n    }\n    /**\n     *  Initializes the behavior\n     */\n    init() { }\n    /**\n     * Attaches the fade behavior on the passed in mesh\n     * @param ownerNode The mesh that will be faded in/out once attached\n     */\n    attach(ownerNode) {\n        this._ownerNode = ownerNode;\n        this._setAllVisibility(this._ownerNode, 0);\n    }\n    /**\n     *  Detaches the behavior from the mesh\n     */\n    detach() {\n        this._ownerNode = null;\n    }\n    /**\n     * Triggers the mesh to begin fading in (or out)\n     * @param fadeIn if the object should fade in or out (true to fade in)\n     */\n    fadeIn(fadeIn = true) {\n        this._delay = fadeIn ? this.fadeInDelay : this.fadeOutDelay;\n        this._time = fadeIn ? this.fadeInTime : this.fadeOutTime;\n        // Cancel any pending updates\n        this._detachObserver();\n        // If fading in and already visible or fading out and already not visible do nothing\n        if (this._ownerNode && ((fadeIn && this._ownerNode.visibility >= 1) || (!fadeIn && this._ownerNode.visibility <= 0))) {\n            return;\n        }\n        this._hovered = fadeIn;\n        if (!this._hovered) {\n            // Make the delay the negative of fadeout delay so the hoverValue is kept above 1 until\n            // fadeOutDelay has elapsed\n            this._delay *= -1;\n        }\n        // Reset the hoverValue.  This is necessary because we may have been fading out, e.g. but not yet reached\n        // the delay, so the hover value is greater than 1\n        if (this._ownerNode.visibility >= 1) {\n            this._hoverValue = this._time;\n        }\n        else if (this._ownerNode.visibility <= 0) {\n            this._hoverValue = 0;\n        }\n        this._update();\n    }\n    /**\n     * Triggers the mesh to begin fading out\n     */\n    fadeOut() {\n        this.fadeIn(false);\n    }\n    _setAllVisibility(mesh, value) {\n        mesh.visibility = value;\n        mesh.getChildMeshes().forEach((c) => {\n            this._setAllVisibility(c, value);\n        });\n    }\n    _attachObserver() {\n        if (!this._onBeforeRenderObserver) {\n            this._onBeforeRenderObserver = this._ownerNode?.getScene().onBeforeRenderObservable.add(this._update);\n        }\n    }\n    _detachObserver() {\n        if (this._onBeforeRenderObserver) {\n            this._ownerNode?.getScene().onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n            this._onBeforeRenderObserver = null;\n        }\n    }\n}\n//# sourceMappingURL=fadeInOutBehavior.js.map","import { PointerDragBehavior } from \"./pointerDragBehavior.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\n/**\n * A behavior that when attached to a mesh will allow the mesh to be scaled\n */\nexport class MultiPointerScaleBehavior {\n    /**\n     * Instantiate a new behavior that when attached to a mesh will allow the mesh to be scaled\n     */\n    constructor() {\n        this._startDistance = 0;\n        this._initialScale = new Vector3(0, 0, 0);\n        this._targetScale = new Vector3(0, 0, 0);\n        this._sceneRenderObserver = null;\n        this._dragBehaviorA = new PointerDragBehavior({});\n        this._dragBehaviorA.moveAttached = false;\n        this._dragBehaviorB = new PointerDragBehavior({});\n        this._dragBehaviorB.moveAttached = false;\n    }\n    /**\n     *  The name of the behavior\n     */\n    get name() {\n        return \"MultiPointerScale\";\n    }\n    /**\n     *  Initializes the behavior\n     */\n    init() { }\n    _getCurrentDistance() {\n        return this._dragBehaviorA.lastDragPosition.subtract(this._dragBehaviorB.lastDragPosition).length();\n    }\n    /**\n     * Attaches the scale behavior the passed in mesh\n     * @param ownerNode The mesh that will be scaled around once attached\n     */\n    attach(ownerNode) {\n        this._ownerNode = ownerNode;\n        // Create 2 drag behaviors such that each will only be triggered by a separate pointer\n        this._dragBehaviorA.onDragStartObservable.add(() => {\n            if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\n                if (this._dragBehaviorA.currentDraggingPointerId == this._dragBehaviorB.currentDraggingPointerId) {\n                    this._dragBehaviorA.releaseDrag();\n                }\n                else {\n                    this._initialScale.copyFrom(ownerNode.scaling);\n                    this._startDistance = this._getCurrentDistance();\n                }\n            }\n        });\n        this._dragBehaviorB.onDragStartObservable.add(() => {\n            if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\n                if (this._dragBehaviorA.currentDraggingPointerId == this._dragBehaviorB.currentDraggingPointerId) {\n                    this._dragBehaviorB.releaseDrag();\n                }\n                else {\n                    this._initialScale.copyFrom(ownerNode.scaling);\n                    this._startDistance = this._getCurrentDistance();\n                }\n            }\n        });\n        // Once both drag behaviors are active scale based on the distance between the two pointers\n        [this._dragBehaviorA, this._dragBehaviorB].forEach((behavior) => {\n            behavior.onDragObservable.add(() => {\n                if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\n                    const ratio = this._getCurrentDistance() / this._startDistance;\n                    this._initialScale.scaleToRef(ratio, this._targetScale);\n                }\n            });\n        });\n        ownerNode.addBehavior(this._dragBehaviorA);\n        ownerNode.addBehavior(this._dragBehaviorB);\n        // On every frame move towards target scaling to avoid jitter caused by vr controllers\n        this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {\n            if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\n                const change = this._targetScale.subtract(ownerNode.scaling).scaleInPlace(0.1);\n                if (change.length() > 0.01) {\n                    ownerNode.scaling.addInPlace(change);\n                }\n            }\n        });\n    }\n    /**\n     *  Detaches the behavior from the mesh\n     */\n    detach() {\n        this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\n        [this._dragBehaviorA, this._dragBehaviorB].forEach((behavior) => {\n            behavior.onDragStartObservable.clear();\n            behavior.onDragObservable.clear();\n            this._ownerNode.removeBehavior(behavior);\n        });\n    }\n}\n//# sourceMappingURL=multiPointerScaleBehavior.js.map","import { Scene } from \"../../scene.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { TransformNode } from \"../../Meshes/transformNode.js\";\nimport { Camera } from \"../../Cameras/camera.js\";\n/**\n * Base behavior for six degrees of freedom interactions in XR experiences.\n * Creates virtual meshes that are dragged around\n * And observables for position/rotation changes\n */\nexport class BaseSixDofDragBehavior {\n    constructor() {\n        this._attachedToElement = false;\n        this._virtualMeshesInfo = {};\n        this._tmpVector = new Vector3();\n        this._tmpQuaternion = new Quaternion();\n        this._dragType = {\n            NONE: 0,\n            DRAG: 1,\n            DRAG_WITH_CONTROLLER: 2,\n            NEAR_DRAG: 3,\n        };\n        this._moving = false;\n        this._dragging = this._dragType.NONE;\n        /**\n         * The list of child meshes that can receive drag events\n         * If `null`, all child meshes will receive drag event\n         */\n        this.draggableMeshes = null;\n        /**\n         * How much faster the object should move when the controller is moving towards it. This is useful to bring objects that are far away from the user to them faster. Set this to 0 to avoid any speed increase. (Default: 3)\n         */\n        this.zDragFactor = 3;\n        /**\n         * In case of multipointer interaction, all pointer ids currently active are stored here\n         */\n        this.currentDraggingPointerIds = [];\n        /**\n        /**\n         * If camera controls should be detached during the drag\n         */\n        this.detachCameraControls = true;\n        /**\n         * Fires each time a drag starts\n         */\n        this.onDragStartObservable = new Observable();\n        /**\n         * Fires each time a drag happens\n         */\n        this.onDragObservable = new Observable();\n        /**\n         *  Fires each time a drag ends (eg. mouse release after drag)\n         */\n        this.onDragEndObservable = new Observable();\n        /**\n         * Should the behavior allow simultaneous pointers to interact with the owner node.\n         */\n        this.allowMultiPointer = true;\n    }\n    /**\n     * The id of the pointer that is currently interacting with the behavior (-1 when no pointer is active)\n     */\n    get currentDraggingPointerId() {\n        if (this.currentDraggingPointerIds[0] !== undefined) {\n            return this.currentDraggingPointerIds[0];\n        }\n        return -1;\n    }\n    set currentDraggingPointerId(value) {\n        this.currentDraggingPointerIds[0] = value;\n    }\n    /**\n     * Get or set the currentDraggingPointerId\n     * @deprecated Please use currentDraggingPointerId instead\n     */\n    get currentDraggingPointerID() {\n        return this.currentDraggingPointerId;\n    }\n    set currentDraggingPointerID(currentDraggingPointerID) {\n        this.currentDraggingPointerId = currentDraggingPointerID;\n    }\n    /**\n     *  The name of the behavior\n     */\n    get name() {\n        return \"BaseSixDofDrag\";\n    }\n    /**\n     *  Returns true if the attached mesh is currently moving with this behavior\n     */\n    get isMoving() {\n        return this._moving;\n    }\n    /**\n     *  Initializes the behavior\n     */\n    init() { }\n    /**\n     * In the case of multiple active cameras, the cameraToUseForPointers should be used if set instead of active camera\n     */\n    get _pointerCamera() {\n        if (this._scene.cameraToUseForPointers) {\n            return this._scene.cameraToUseForPointers;\n        }\n        else {\n            return this._scene.activeCamera;\n        }\n    }\n    _createVirtualMeshInfo() {\n        // Setup virtual meshes to be used for dragging without dirtying the existing scene\n        const dragMesh = new TransformNode(\"\", BaseSixDofDragBehavior._virtualScene);\n        dragMesh.rotationQuaternion = new Quaternion();\n        const originMesh = new TransformNode(\"\", BaseSixDofDragBehavior._virtualScene);\n        originMesh.rotationQuaternion = new Quaternion();\n        const pivotMesh = new TransformNode(\"\", BaseSixDofDragBehavior._virtualScene);\n        pivotMesh.rotationQuaternion = new Quaternion();\n        return {\n            dragging: false,\n            moving: false,\n            dragMesh,\n            originMesh,\n            pivotMesh,\n            startingPivotPosition: new Vector3(),\n            startingPivotOrientation: new Quaternion(),\n            startingPosition: new Vector3(),\n            startingOrientation: new Quaternion(),\n            lastOriginPosition: new Vector3(),\n            lastDragPosition: new Vector3(),\n        };\n    }\n    _resetVirtualMeshesPosition() {\n        for (let i = 0; i < this.currentDraggingPointerIds.length; i++) {\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.position.copyFrom(this._ownerNode.getAbsolutePivotPoint());\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.rotationQuaternion.copyFrom(this._ownerNode.rotationQuaternion);\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPivotPosition.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.position);\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPivotOrientation.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].pivotMesh.rotationQuaternion);\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingPosition.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].dragMesh.position);\n            this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].startingOrientation.copyFrom(this._virtualMeshesInfo[this.currentDraggingPointerIds[i]].dragMesh.rotationQuaternion);\n        }\n    }\n    _pointerUpdate2D(ray, pointerId, zDragFactor) {\n        if (this._pointerCamera && this._pointerCamera.cameraRigMode == Camera.RIG_MODE_NONE && !this._pointerCamera._isLeftCamera && !this._pointerCamera._isRightCamera) {\n            ray.origin.copyFrom(this._pointerCamera.globalPosition);\n            zDragFactor = 0;\n        }\n        const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];\n        // Calculate controller drag distance in controller space\n        const originDragDifference = TmpVectors.Vector3[11];\n        ray.origin.subtractToRef(virtualMeshesInfo.lastOriginPosition, originDragDifference);\n        virtualMeshesInfo.lastOriginPosition.copyFrom(ray.origin);\n        const localOriginDragDifference = -Vector3.Dot(originDragDifference, ray.direction);\n        virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.dragMesh);\n        virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.pivotMesh);\n        this._applyZOffset(virtualMeshesInfo.dragMesh, localOriginDragDifference, zDragFactor);\n        this._applyZOffset(virtualMeshesInfo.pivotMesh, localOriginDragDifference, zDragFactor);\n        // Update the controller position\n        virtualMeshesInfo.originMesh.position.copyFrom(ray.origin);\n        const lookAt = TmpVectors.Vector3[10];\n        ray.origin.addToRef(ray.direction, lookAt);\n        virtualMeshesInfo.originMesh.lookAt(lookAt);\n        virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.dragMesh);\n        virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.pivotMesh);\n    }\n    _pointerUpdateXR(controllerAimTransform, controllerGripTransform, pointerId, zDragFactor) {\n        const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];\n        virtualMeshesInfo.originMesh.position.copyFrom(controllerAimTransform.position);\n        if (this._dragging === this._dragType.NEAR_DRAG && controllerGripTransform) {\n            virtualMeshesInfo.originMesh.rotationQuaternion.copyFrom(controllerGripTransform.rotationQuaternion);\n        }\n        else {\n            virtualMeshesInfo.originMesh.rotationQuaternion.copyFrom(controllerAimTransform.rotationQuaternion);\n        }\n        virtualMeshesInfo.pivotMesh.computeWorldMatrix(true);\n        virtualMeshesInfo.dragMesh.computeWorldMatrix(true);\n        // Z scaling logic\n        if (zDragFactor !== 0) {\n            // Camera.getForwardRay modifies TmpVectors.Vector[0-3], so cache it in advance\n            const cameraForwardVec = TmpVectors.Vector3[10];\n            const originDragDirection = TmpVectors.Vector3[11];\n            cameraForwardVec.copyFrom(this._pointerCamera.getForwardRay().direction);\n            virtualMeshesInfo.originMesh.position.subtractToRef(virtualMeshesInfo.lastOriginPosition, originDragDirection);\n            virtualMeshesInfo.lastOriginPosition.copyFrom(virtualMeshesInfo.originMesh.position);\n            const controllerDragDistance = originDragDirection.length();\n            originDragDirection.normalize();\n            const cameraToDrag = TmpVectors.Vector3[12];\n            const controllerToDrag = TmpVectors.Vector3[9];\n            virtualMeshesInfo.dragMesh.absolutePosition.subtractToRef(this._pointerCamera.globalPosition, cameraToDrag);\n            virtualMeshesInfo.dragMesh.absolutePosition.subtractToRef(virtualMeshesInfo.originMesh.position, controllerToDrag);\n            const controllerToDragDistance = controllerToDrag.length();\n            cameraToDrag.normalize();\n            controllerToDrag.normalize();\n            const controllerDragScaling = Math.abs(Vector3.Dot(originDragDirection, controllerToDrag)) * Vector3.Dot(originDragDirection, cameraForwardVec);\n            let zOffsetScaling = controllerDragScaling * zDragFactor * controllerDragDistance * controllerToDragDistance;\n            // Prevent pulling the mesh through the controller\n            const minDistanceFromControllerToDragMesh = 0.01;\n            if (zOffsetScaling < 0 && minDistanceFromControllerToDragMesh - controllerToDragDistance > zOffsetScaling) {\n                zOffsetScaling = Math.min(minDistanceFromControllerToDragMesh - controllerToDragDistance, 0);\n            }\n            controllerToDrag.scaleInPlace(zOffsetScaling);\n            controllerToDrag.addToRef(virtualMeshesInfo.pivotMesh.absolutePosition, this._tmpVector);\n            virtualMeshesInfo.pivotMesh.setAbsolutePosition(this._tmpVector);\n            controllerToDrag.addToRef(virtualMeshesInfo.dragMesh.absolutePosition, this._tmpVector);\n            virtualMeshesInfo.dragMesh.setAbsolutePosition(this._tmpVector);\n        }\n    }\n    /**\n     * Attaches the scale behavior the passed in mesh\n     * @param ownerNode The mesh that will be scaled around once attached\n     */\n    attach(ownerNode) {\n        this._ownerNode = ownerNode;\n        this._scene = this._ownerNode.getScene();\n        if (!BaseSixDofDragBehavior._virtualScene) {\n            BaseSixDofDragBehavior._virtualScene = new Scene(this._scene.getEngine(), { virtual: true });\n            BaseSixDofDragBehavior._virtualScene.detachControl();\n        }\n        const pickPredicate = (m) => {\n            return this._ownerNode === m || (m.isDescendantOf(this._ownerNode) && (!this.draggableMeshes || this.draggableMeshes.indexOf(m) !== -1));\n        };\n        this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {\n            const pointerId = pointerInfo.event.pointerId;\n            if (!this._virtualMeshesInfo[pointerId]) {\n                this._virtualMeshesInfo[pointerId] = this._createVirtualMeshInfo();\n            }\n            const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];\n            const isXRPointer = pointerInfo.event.pointerType === \"xr-near\" || pointerInfo.event.pointerType === \"xr\";\n            const isNearXRPointer = pointerInfo.event.pointerType === \"xr-near\";\n            if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\n                if (!virtualMeshesInfo.dragging &&\n                    pointerInfo.pickInfo &&\n                    pointerInfo.pickInfo.hit &&\n                    pointerInfo.pickInfo.pickedMesh &&\n                    pointerInfo.pickInfo.pickedPoint &&\n                    pointerInfo.pickInfo.ray &&\n                    (!isNearXRPointer || pointerInfo.pickInfo.aimTransform) &&\n                    pickPredicate(pointerInfo.pickInfo.pickedMesh)) {\n                    if ((!this.allowMultiPointer || isXRPointer) && this.currentDraggingPointerIds.length > 0) {\n                        return;\n                    }\n                    if (this._pointerCamera &&\n                        this._pointerCamera.cameraRigMode === Camera.RIG_MODE_NONE &&\n                        !this._pointerCamera._isLeftCamera &&\n                        !this._pointerCamera._isRightCamera) {\n                        pointerInfo.pickInfo.ray.origin.copyFrom(this._pointerCamera.globalPosition);\n                    }\n                    this._ownerNode.computeWorldMatrix(true);\n                    const virtualMeshesInfo = this._virtualMeshesInfo[pointerId];\n                    if (isXRPointer) {\n                        this._dragging = pointerInfo.pickInfo.originMesh ? this._dragType.NEAR_DRAG : this._dragType.DRAG_WITH_CONTROLLER;\n                        virtualMeshesInfo.originMesh.position.copyFrom(pointerInfo.pickInfo.aimTransform.position);\n                        if (this._dragging === this._dragType.NEAR_DRAG && pointerInfo.pickInfo.gripTransform) {\n                            virtualMeshesInfo.originMesh.rotationQuaternion.copyFrom(pointerInfo.pickInfo.gripTransform.rotationQuaternion);\n                        }\n                        else {\n                            virtualMeshesInfo.originMesh.rotationQuaternion.copyFrom(pointerInfo.pickInfo.aimTransform.rotationQuaternion);\n                        }\n                    }\n                    else {\n                        this._dragging = this._dragType.DRAG;\n                        virtualMeshesInfo.originMesh.position.copyFrom(pointerInfo.pickInfo.ray.origin);\n                    }\n                    virtualMeshesInfo.lastOriginPosition.copyFrom(virtualMeshesInfo.originMesh.position);\n                    virtualMeshesInfo.dragMesh.position.copyFrom(pointerInfo.pickInfo.pickedPoint);\n                    virtualMeshesInfo.lastDragPosition.copyFrom(pointerInfo.pickInfo.pickedPoint);\n                    virtualMeshesInfo.pivotMesh.position.copyFrom(this._ownerNode.getAbsolutePivotPoint());\n                    virtualMeshesInfo.pivotMesh.rotationQuaternion.copyFrom(this._ownerNode.absoluteRotationQuaternion);\n                    virtualMeshesInfo.startingPosition.copyFrom(virtualMeshesInfo.dragMesh.position);\n                    virtualMeshesInfo.startingPivotPosition.copyFrom(virtualMeshesInfo.pivotMesh.position);\n                    virtualMeshesInfo.startingOrientation.copyFrom(virtualMeshesInfo.dragMesh.rotationQuaternion);\n                    virtualMeshesInfo.startingPivotOrientation.copyFrom(virtualMeshesInfo.pivotMesh.rotationQuaternion);\n                    if (isNearXRPointer) {\n                        virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.dragMesh);\n                        virtualMeshesInfo.originMesh.addChild(virtualMeshesInfo.pivotMesh);\n                    }\n                    else {\n                        virtualMeshesInfo.originMesh.lookAt(virtualMeshesInfo.dragMesh.position);\n                    }\n                    // Update state\n                    virtualMeshesInfo.dragging = true;\n                    if (this.currentDraggingPointerIds.indexOf(pointerId) === -1) {\n                        this.currentDraggingPointerIds.push(pointerId);\n                    }\n                    // Detach camera controls\n                    if (this.detachCameraControls && this._pointerCamera && !this._pointerCamera.leftCamera) {\n                        if (this._pointerCamera.inputs && this._pointerCamera.inputs.attachedToElement) {\n                            this._pointerCamera.detachControl();\n                            this._attachedToElement = true;\n                        }\n                        else if (!this.allowMultiPointer || this.currentDraggingPointerIds.length === 0) {\n                            this._attachedToElement = false;\n                        }\n                    }\n                    this._targetDragStart(virtualMeshesInfo.pivotMesh.position, virtualMeshesInfo.pivotMesh.rotationQuaternion, pointerId);\n                    this.onDragStartObservable.notifyObservers({ position: virtualMeshesInfo.pivotMesh.position });\n                }\n            }\n            else if (pointerInfo.type == PointerEventTypes.POINTERUP || pointerInfo.type == PointerEventTypes.POINTERDOUBLETAP) {\n                const registeredPointerIndex = this.currentDraggingPointerIds.indexOf(pointerId);\n                // Update state\n                virtualMeshesInfo.dragging = false;\n                if (registeredPointerIndex !== -1) {\n                    this.currentDraggingPointerIds.splice(registeredPointerIndex, 1);\n                    if (this.currentDraggingPointerIds.length === 0) {\n                        this._moving = false;\n                        this._dragging = this._dragType.NONE;\n                        // Reattach camera controls\n                        if (this.detachCameraControls && this._attachedToElement && this._pointerCamera && !this._pointerCamera.leftCamera) {\n                            this._reattachCameraControls();\n                            this._attachedToElement = false;\n                        }\n                    }\n                    virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.dragMesh);\n                    virtualMeshesInfo.originMesh.removeChild(virtualMeshesInfo.pivotMesh);\n                    this._targetDragEnd(pointerId);\n                    this.onDragEndObservable.notifyObservers({});\n                }\n            }\n            else if (pointerInfo.type == PointerEventTypes.POINTERMOVE) {\n                const registeredPointerIndex = this.currentDraggingPointerIds.indexOf(pointerId);\n                if (registeredPointerIndex !== -1 && virtualMeshesInfo.dragging && pointerInfo.pickInfo && (pointerInfo.pickInfo.ray || pointerInfo.pickInfo.aimTransform)) {\n                    let zDragFactor = this.zDragFactor;\n                    // 2 pointer interaction should not have a z axis drag factor\n                    // as well as near interaction\n                    if (this.currentDraggingPointerIds.length > 1 || pointerInfo.pickInfo.originMesh) {\n                        zDragFactor = 0;\n                    }\n                    this._ownerNode.computeWorldMatrix(true);\n                    if (!isNearXRPointer) {\n                        this._pointerUpdate2D(pointerInfo.pickInfo.ray, pointerId, zDragFactor);\n                    }\n                    else {\n                        this._pointerUpdateXR(pointerInfo.pickInfo.aimTransform, pointerInfo.pickInfo.gripTransform, pointerId, zDragFactor);\n                    }\n                    // Get change in rotation\n                    this._tmpQuaternion.copyFrom(virtualMeshesInfo.startingPivotOrientation);\n                    this._tmpQuaternion.x = -this._tmpQuaternion.x;\n                    this._tmpQuaternion.y = -this._tmpQuaternion.y;\n                    this._tmpQuaternion.z = -this._tmpQuaternion.z;\n                    virtualMeshesInfo.pivotMesh.absoluteRotationQuaternion.multiplyToRef(this._tmpQuaternion, this._tmpQuaternion);\n                    virtualMeshesInfo.pivotMesh.absolutePosition.subtractToRef(virtualMeshesInfo.startingPivotPosition, this._tmpVector);\n                    this.onDragObservable.notifyObservers({ delta: this._tmpVector, position: virtualMeshesInfo.pivotMesh.position, pickInfo: pointerInfo.pickInfo });\n                    // Notify herited methods and observables\n                    this._targetDrag(this._tmpVector, this._tmpQuaternion, pointerId);\n                    virtualMeshesInfo.lastDragPosition.copyFrom(virtualMeshesInfo.dragMesh.absolutePosition);\n                    this._moving = true;\n                }\n            }\n        });\n    }\n    _applyZOffset(node, localOriginDragDifference, zDragFactor) {\n        // Determine how much the controller moved to/away towards the dragged object and use this to move the object further when its further away\n        node.position.z -= node.position.z < 1 ? localOriginDragDifference * zDragFactor : localOriginDragDifference * zDragFactor * node.position.z;\n        if (node.position.z < 0) {\n            node.position.z = 0;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _targetDragStart(worldPosition, worldRotation, pointerId) {\n        // Herited classes can override that\n    }\n    _targetDrag(worldDeltaPosition, worldDeltaRotation, pointerId) {\n        // Herited classes can override that\n    }\n    _targetDragEnd(pointerId) {\n        // Herited classes can override that\n    }\n    _reattachCameraControls() {\n        if (this._pointerCamera) {\n            // If the camera is an ArcRotateCamera, preserve the settings from the camera\n            // when reattaching control\n            if (this._pointerCamera.getClassName() === \"ArcRotateCamera\") {\n                const arcRotateCamera = this._pointerCamera;\n                arcRotateCamera.attachControl(arcRotateCamera.inputs ? arcRotateCamera.inputs.noPreventDefault : true, arcRotateCamera._useCtrlForPanning, arcRotateCamera._panningMouseButton);\n            }\n            else {\n                // preserve the settings from the camera when reattaching control\n                this._pointerCamera.attachControl(this._pointerCamera.inputs ? this._pointerCamera.inputs.noPreventDefault : true);\n            }\n        }\n    }\n    /**\n     * Detaches the behavior from the mesh\n     */\n    detach() {\n        if (this._scene) {\n            if (this.detachCameraControls && this._attachedToElement && this._pointerCamera && !this._pointerCamera.leftCamera) {\n                this._reattachCameraControls();\n                this._attachedToElement = false;\n            }\n            this._scene.onPointerObservable.remove(this._pointerObserver);\n        }\n        for (const pointerId in this._virtualMeshesInfo) {\n            this._virtualMeshesInfo[pointerId].originMesh.dispose();\n            this._virtualMeshesInfo[pointerId].dragMesh.dispose();\n        }\n        this.onDragEndObservable.clear();\n        this.onDragObservable.clear();\n        this.onDragStartObservable.clear();\n    }\n}\n//# sourceMappingURL=baseSixDofDragBehavior.js.map","import { Vector3, Quaternion, Matrix, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { BaseSixDofDragBehavior } from \"./baseSixDofDragBehavior.js\";\nimport { TransformNode } from \"../../Meshes/transformNode.js\";\n/**\n * A behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray\n */\nexport class SixDofDragBehavior extends BaseSixDofDragBehavior {\n    constructor() {\n        super(...arguments);\n        this._sceneRenderObserver = null;\n        this._targetPosition = new Vector3(0, 0, 0);\n        this._targetOrientation = new Quaternion();\n        this._targetScaling = new Vector3(1, 1, 1);\n        this._startingPosition = new Vector3(0, 0, 0);\n        this._startingOrientation = new Quaternion();\n        this._startingScaling = new Vector3(1, 1, 1);\n        /**\n         * Fires when position is updated\n         */\n        this.onPositionChangedObservable = new Observable();\n        /**\n         * The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)\n         */\n        this.dragDeltaRatio = 0.2;\n        /**\n         * If the object should rotate to face the drag origin\n         */\n        this.rotateDraggedObject = true;\n        /**\n         * If `rotateDraggedObject` is set to `true`, this parameter determines if we are only rotating around the y axis (yaw)\n         */\n        this.rotateAroundYOnly = false;\n        /**\n         * Should the behavior rotate 1:1 with the motion controller, when one is used.\n         */\n        this.rotateWithMotionController = true;\n        /**\n         * Use this flag to update the target but not move the owner node towards the target\n         */\n        this.disableMovement = false;\n        /**\n         * Should the object rotate towards the camera when we start dragging it\n         */\n        this.faceCameraOnDragStart = false;\n    }\n    /**\n     *  The name of the behavior\n     */\n    get name() {\n        return \"SixDofDrag\";\n    }\n    /**\n     * Attaches the six DoF drag behavior\n     * In XR mode the mesh and its children will have their isNearGrabbable property set to true\n     * @param ownerNode The mesh that will be dragged around once attached\n     */\n    attach(ownerNode) {\n        super.attach(ownerNode);\n        ownerNode.isNearGrabbable = true;\n        // if it has children, make sure they are grabbable too\n        ownerNode.getChildMeshes().forEach((m) => {\n            m.isNearGrabbable = true;\n        });\n        // Node that will save the owner's transform\n        this._virtualTransformNode = new TransformNode(\"virtual_sixDof\", BaseSixDofDragBehavior._virtualScene);\n        this._virtualTransformNode.rotationQuaternion = Quaternion.Identity();\n        // On every frame move towards target scaling to avoid jitter caused by vr controllers\n        this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {\n            if (this.currentDraggingPointerIds.length === 1 && this._moving && !this.disableMovement) {\n                // 1 pointer only drags mesh\n                const deltaToAdd = TmpVectors.Vector3[0];\n                deltaToAdd.copyFrom(this._targetPosition).subtractInPlace(ownerNode.absolutePosition).scaleInPlace(this.dragDeltaRatio);\n                const deltaToAddTransformed = TmpVectors.Vector3[1];\n                deltaToAddTransformed.copyFrom(deltaToAdd);\n                // If the node has a parent, transform the delta to local space, so it can be added to the\n                // position in local space\n                if (ownerNode.parent) {\n                    const parentRotationMatrixInverse = TmpVectors.Matrix[0];\n                    ownerNode.parent.absoluteRotationQuaternion.toRotationMatrix(parentRotationMatrixInverse);\n                    parentRotationMatrixInverse.invert();\n                    Vector3.TransformNormalToRef(deltaToAdd, parentRotationMatrixInverse, deltaToAddTransformed);\n                }\n                ownerNode.position.addInPlace(deltaToAddTransformed);\n                this.onPositionChangedObservable.notifyObservers({ position: ownerNode.absolutePosition });\n                // Only rotate the mesh if it's parent has uniform scaling\n                if (!ownerNode.parent || (ownerNode.parent.scaling && !ownerNode.parent.scaling.isNonUniformWithinEpsilon(0.001))) {\n                    const rotationToApply = TmpVectors.Quaternion[0];\n                    rotationToApply.copyFrom(this._targetOrientation);\n                    if (ownerNode.parent) {\n                        const parentRotationInverse = TmpVectors.Quaternion[0];\n                        parentRotationInverse.copyFrom(ownerNode.parent.absoluteRotationQuaternion);\n                        parentRotationInverse.invertInPlace();\n                        parentRotationInverse.multiplyToRef(this._targetOrientation, rotationToApply);\n                    }\n                    Quaternion.SlerpToRef(ownerNode.rotationQuaternion, rotationToApply, this.dragDeltaRatio, ownerNode.rotationQuaternion);\n                }\n            }\n        });\n    }\n    _getPositionOffsetAround(transformationLocalOrigin, scaling, rotation) {\n        const translationMatrix = TmpVectors.Matrix[0]; // T\n        const translationMatrixInv = TmpVectors.Matrix[1]; // T'\n        const rotationMatrix = TmpVectors.Matrix[2]; // R\n        const scaleMatrix = TmpVectors.Matrix[3]; // S\n        const finalMatrix = TmpVectors.Matrix[4]; // T' x R x S x T\n        Matrix.TranslationToRef(transformationLocalOrigin.x, transformationLocalOrigin.y, transformationLocalOrigin.z, translationMatrix); // T\n        Matrix.TranslationToRef(-transformationLocalOrigin.x, -transformationLocalOrigin.y, -transformationLocalOrigin.z, translationMatrixInv); // T'\n        Matrix.FromQuaternionToRef(rotation, rotationMatrix); // R\n        Matrix.ScalingToRef(scaling, scaling, scaling, scaleMatrix);\n        translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix); // T' x R\n        finalMatrix.multiplyToRef(scaleMatrix, finalMatrix); // T' x R x S\n        finalMatrix.multiplyToRef(translationMatrix, finalMatrix); // T' x R x S x T\n        return finalMatrix.getTranslation();\n    }\n    _onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation) {\n        const pointerDelta = TmpVectors.Vector3[0];\n        pointerDelta.setAll(0);\n        if (this._dragging === this._dragType.DRAG) {\n            if (this.rotateDraggedObject) {\n                if (this.rotateAroundYOnly) {\n                    // Convert change in rotation to only y axis rotation\n                    Quaternion.RotationYawPitchRollToRef(worldDeltaRotation.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);\n                }\n                else {\n                    TmpVectors.Quaternion[0].copyFrom(worldDeltaRotation);\n                }\n                TmpVectors.Quaternion[0].multiplyToRef(this._startingOrientation, this._targetOrientation);\n            }\n        }\n        else if (this._dragging === this._dragType.NEAR_DRAG || (this._dragging === this._dragType.DRAG_WITH_CONTROLLER && this.rotateWithMotionController)) {\n            worldDeltaRotation.multiplyToRef(this._startingOrientation, this._targetOrientation);\n        }\n        this._targetPosition.copyFrom(this._startingPosition).addInPlace(worldDeltaPosition);\n    }\n    _twoPointersPositionUpdated() {\n        const startingPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].startingPosition;\n        const startingPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].startingPosition;\n        const startingCenter = TmpVectors.Vector3[0];\n        startingPosition0.addToRef(startingPosition1, startingCenter);\n        startingCenter.scaleInPlace(0.5);\n        const startingVector = TmpVectors.Vector3[1];\n        startingPosition1.subtractToRef(startingPosition0, startingVector);\n        const currentPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].dragMesh.absolutePosition;\n        const currentPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].dragMesh.absolutePosition;\n        const currentCenter = TmpVectors.Vector3[2];\n        currentPosition0.addToRef(currentPosition1, currentCenter);\n        currentCenter.scaleInPlace(0.5);\n        const currentVector = TmpVectors.Vector3[3];\n        currentPosition1.subtractToRef(currentPosition0, currentVector);\n        const scaling = currentVector.length() / startingVector.length();\n        const translation = currentCenter.subtract(startingCenter);\n        const rotationQuaternion = Quaternion.FromEulerAngles(0, Vector3.GetAngleBetweenVectorsOnPlane(startingVector.normalize(), currentVector.normalize(), Vector3.UpReadOnly), 0);\n        const oldParent = this._ownerNode.parent;\n        this._ownerNode.setParent(null);\n        const positionOffset = this._getPositionOffsetAround(startingCenter.subtract(this._virtualTransformNode.getAbsolutePivotPoint()), scaling, rotationQuaternion);\n        this._virtualTransformNode.rotationQuaternion.multiplyToRef(rotationQuaternion, this._ownerNode.rotationQuaternion);\n        this._virtualTransformNode.scaling.scaleToRef(scaling, this._ownerNode.scaling);\n        this._virtualTransformNode.position.addToRef(translation.addInPlace(positionOffset), this._ownerNode.position);\n        this.onPositionChangedObservable.notifyObservers({ position: this._ownerNode.position });\n        this._ownerNode.setParent(oldParent);\n    }\n    _targetDragStart() {\n        const pointerCount = this.currentDraggingPointerIds.length;\n        if (!this._ownerNode.rotationQuaternion) {\n            this._ownerNode.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ownerNode.rotation.y, this._ownerNode.rotation.x, this._ownerNode.rotation.z);\n        }\n        const worldPivot = this._ownerNode.getAbsolutePivotPoint();\n        if (pointerCount === 1) {\n            this._targetPosition.copyFrom(this._ownerNode.absolutePosition);\n            this._targetOrientation.copyFrom(this._ownerNode.rotationQuaternion);\n            this._targetScaling.copyFrom(this._ownerNode.absoluteScaling);\n            if (this.faceCameraOnDragStart && this._scene.activeCamera) {\n                const toCamera = TmpVectors.Vector3[0];\n                this._scene.activeCamera.position.subtractToRef(worldPivot, toCamera);\n                toCamera.normalize();\n                const quat = TmpVectors.Quaternion[0];\n                if (this._scene.useRightHandedSystem) {\n                    Quaternion.FromLookDirectionRHToRef(toCamera, new Vector3(0, 1, 0), quat);\n                }\n                else {\n                    Quaternion.FromLookDirectionLHToRef(toCamera, new Vector3(0, 1, 0), quat);\n                }\n                quat.normalize();\n                Quaternion.RotationYawPitchRollToRef(quat.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);\n                this._targetOrientation.copyFrom(TmpVectors.Quaternion[0]);\n            }\n            this._startingPosition.copyFrom(this._targetPosition);\n            this._startingOrientation.copyFrom(this._targetOrientation);\n            this._startingScaling.copyFrom(this._targetScaling);\n        }\n        else if (pointerCount === 2) {\n            this._virtualTransformNode.setPivotPoint(new Vector3(0, 0, 0), 0 /* Space.LOCAL */);\n            this._virtualTransformNode.position.copyFrom(this._ownerNode.absolutePosition);\n            this._virtualTransformNode.scaling.copyFrom(this._ownerNode.absoluteScaling);\n            this._virtualTransformNode.rotationQuaternion.copyFrom(this._ownerNode.absoluteRotationQuaternion);\n            this._virtualTransformNode.setPivotPoint(worldPivot, 1 /* Space.WORLD */);\n            this._resetVirtualMeshesPosition();\n        }\n    }\n    _targetDrag(worldDeltaPosition, worldDeltaRotation) {\n        if (this.currentDraggingPointerIds.length === 1) {\n            this._onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation);\n        }\n        else if (this.currentDraggingPointerIds.length === 2) {\n            this._twoPointersPositionUpdated();\n        }\n    }\n    _targetDragEnd() {\n        if (this.currentDraggingPointerIds.length === 1) {\n            // We still have 1 active pointer, we must simulate a dragstart with a reseted position/orientation\n            this._resetVirtualMeshesPosition();\n            const previousFaceCameraFlag = this.faceCameraOnDragStart;\n            this.faceCameraOnDragStart = false;\n            this._targetDragStart();\n            this.faceCameraOnDragStart = previousFaceCameraFlag;\n        }\n    }\n    /**\n     *  Detaches the behavior from the mesh\n     */\n    detach() {\n        super.detach();\n        if (this._ownerNode) {\n            this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\n        }\n        if (this._virtualTransformNode) {\n            this._virtualTransformNode.dispose();\n        }\n    }\n}\n//# sourceMappingURL=sixDofDragBehavior.js.map","import { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector.js\";\n/**\n * A behavior that allows a transform node to stick to a surface position/orientation\n * @since 5.0.0\n */\nexport class SurfaceMagnetismBehavior {\n    constructor() {\n        this._attachPointLocalOffset = new Vector3();\n        this._workingPosition = new Vector3();\n        this._workingQuaternion = new Quaternion();\n        this._lastTick = -1;\n        this._hit = false;\n        /**\n         * Distance offset from the hit point to place the target at, along the hit normal.\n         */\n        this.hitNormalOffset = 0.05;\n        /**\n         * Spatial mapping meshes to collide with\n         */\n        this.meshes = [];\n        /**\n         * Set to false if the node should strictly follow the camera without any interpolation time\n         */\n        this.interpolatePose = true;\n        /**\n         * Rate of interpolation of position and rotation of the attached node.\n         * Higher values will give a slower interpolation.\n         */\n        this.lerpTime = 250;\n        /**\n         * If true, pitch and roll are omitted.\n         */\n        this.keepOrientationVertical = true;\n        /**\n         * Is this behavior reacting to pointer events\n         */\n        this.enabled = true;\n        /**\n         * Maximum distance for the node to stick to the surface\n         */\n        this.maxStickingDistance = 0.8;\n    }\n    /**\n     * Name of the behavior\n     */\n    get name() {\n        return \"SurfaceMagnetism\";\n    }\n    /**\n     * Function called when the behavior needs to be initialized (after attaching it to a target)\n     */\n    init() { }\n    /**\n     * Attaches the behavior to a transform node\n     * @param target defines the target where the behavior is attached to\n     * @param scene the scene\n     */\n    attach(target, scene) {\n        this._attachedMesh = target;\n        this._scene = scene || target.getScene();\n        if (!this._attachedMesh.rotationQuaternion) {\n            this._attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._attachedMesh.rotation.y, this._attachedMesh.rotation.x, this._attachedMesh.rotation.z);\n        }\n        this.updateAttachPoint();\n        this._workingPosition.copyFrom(this._attachedMesh.position);\n        this._workingQuaternion.copyFrom(this._attachedMesh.rotationQuaternion);\n        this._addObservables();\n    }\n    /**\n     * Detaches the behavior\n     */\n    detach() {\n        this._attachedMesh = null;\n        this._removeObservables();\n    }\n    _getTargetPose(pickingInfo) {\n        if (!this._attachedMesh) {\n            return null;\n        }\n        if (pickingInfo && pickingInfo.hit) {\n            const pickedNormal = pickingInfo.getNormal(true, true);\n            const pickedPoint = pickingInfo.pickedPoint;\n            if (!pickedNormal || !pickedPoint) {\n                return null;\n            }\n            pickedNormal.normalize();\n            const worldTarget = TmpVectors.Vector3[0];\n            worldTarget.copyFrom(pickedNormal);\n            worldTarget.scaleInPlace(this.hitNormalOffset);\n            worldTarget.addInPlace(pickedPoint);\n            if (this._attachedMesh.parent) {\n                TmpVectors.Matrix[0].copyFrom(this._attachedMesh.parent.getWorldMatrix()).invert();\n                Vector3.TransformNormalToRef(worldTarget, TmpVectors.Matrix[0], worldTarget);\n            }\n            return {\n                position: worldTarget,\n                quaternion: Quaternion.RotationYawPitchRoll(-Math.atan2(pickedNormal.x, -pickedNormal.z), this.keepOrientationVertical ? 0 : Math.atan2(pickedNormal.y, Math.sqrt(pickedNormal.z * pickedNormal.z + pickedNormal.x * pickedNormal.x)), 0),\n            };\n        }\n        return null;\n    }\n    /**\n     * Updates the attach point with the current geometry extents of the attached mesh\n     */\n    updateAttachPoint() {\n        this._getAttachPointOffsetToRef(this._attachPointLocalOffset);\n    }\n    /**\n     * Finds the intersection point of the given ray onto the meshes and updates the target.\n     * Transformation will be interpolated according to `interpolatePose` and `lerpTime` properties.\n     * If no mesh of `meshes` are hit, this does nothing.\n     * @param pickInfo The input pickingInfo that will be used to intersect the meshes\n     * @returns a boolean indicating if we found a hit to stick to\n     */\n    findAndUpdateTarget(pickInfo) {\n        this._hit = false;\n        if (!pickInfo.ray) {\n            return false;\n        }\n        const subPicking = pickInfo.ray.intersectsMeshes(this.meshes)[0];\n        if (this._attachedMesh && subPicking && subPicking.hit && subPicking.pickedMesh) {\n            const pose = this._getTargetPose(subPicking);\n            if (pose && Vector3.Distance(this._attachedMesh.position, pose.position) < this.maxStickingDistance) {\n                this._workingPosition.copyFrom(pose.position);\n                this._workingQuaternion.copyFrom(pose.quaternion);\n                this._hit = true;\n            }\n        }\n        return this._hit;\n    }\n    _getAttachPointOffsetToRef(ref) {\n        if (!this._attachedMesh) {\n            ref.setAll(0);\n            return;\n        }\n        const storedQuat = TmpVectors.Quaternion[0];\n        storedQuat.copyFrom(this._attachedMesh.rotationQuaternion);\n        this._attachedMesh.rotationQuaternion.copyFromFloats(0, 0, 0, 1);\n        this._attachedMesh.computeWorldMatrix();\n        const boundingMinMax = this._attachedMesh.getHierarchyBoundingVectors();\n        const center = TmpVectors.Vector3[0];\n        boundingMinMax.max.addToRef(boundingMinMax.min, center);\n        center.scaleInPlace(0.5);\n        center.z = boundingMinMax.max.z;\n        // We max the z coordinate because we want the attach point to be on the back of the mesh\n        const invWorld = TmpVectors.Matrix[0];\n        this._attachedMesh.getWorldMatrix().invertToRef(invWorld);\n        Vector3.TransformCoordinatesToRef(center, invWorld, ref);\n        this._attachedMesh.rotationQuaternion.copyFrom(storedQuat);\n    }\n    _updateTransformToGoal(elapsed) {\n        if (!this._attachedMesh || !this._hit) {\n            return;\n        }\n        const oldParent = this._attachedMesh.parent;\n        this._attachedMesh.setParent(null);\n        const worldOffset = TmpVectors.Vector3[0];\n        Vector3.TransformNormalToRef(this._attachPointLocalOffset, this._attachedMesh.getWorldMatrix(), worldOffset);\n        if (!this.interpolatePose) {\n            this._attachedMesh.position.copyFrom(this._workingPosition).subtractInPlace(worldOffset);\n            this._attachedMesh.rotationQuaternion.copyFrom(this._workingQuaternion);\n            return;\n        }\n        // position\n        const interpolatedPosition = new Vector3();\n        Vector3.SmoothToRef(this._attachedMesh.position, this._workingPosition, elapsed, this.lerpTime, interpolatedPosition);\n        this._attachedMesh.position.copyFrom(interpolatedPosition);\n        // rotation\n        const currentRotation = new Quaternion();\n        currentRotation.copyFrom(this._attachedMesh.rotationQuaternion);\n        Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this._attachedMesh.rotationQuaternion);\n        this._attachedMesh.setParent(oldParent);\n    }\n    _addObservables() {\n        this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {\n            if (this.enabled && pointerInfo.type == PointerEventTypes.POINTERMOVE && pointerInfo.pickInfo) {\n                this.findAndUpdateTarget(pointerInfo.pickInfo);\n            }\n        });\n        this._lastTick = Date.now();\n        this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {\n            const tick = Date.now();\n            this._updateTransformToGoal(tick - this._lastTick);\n            this._lastTick = tick;\n        });\n    }\n    _removeObservables() {\n        this._scene.onPointerObservable.remove(this._pointerObserver);\n        this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);\n        this._pointerObserver = null;\n        this._onBeforeRender = null;\n    }\n}\n//# sourceMappingURL=surfaceMagnetismBehavior.js.map","import { Matrix, Quaternion, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Clamp } from \"../../Maths/math.scalar.functions.js\";\nimport { Epsilon } from \"../../Maths/math.constants.js\";\n/**\n * A behavior that when attached to a mesh will follow a camera\n * @since 5.0.0\n */\nexport class FollowBehavior {\n    constructor() {\n        // Memory cache to avoid GC usage\n        this._tmpQuaternion = new Quaternion();\n        this._tmpVectors = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];\n        this._tmpMatrix = new Matrix();\n        this._tmpInvertView = new Matrix();\n        this._tmpForward = new Vector3();\n        this._tmpNodeForward = new Vector3();\n        this._tmpPosition = new Vector3();\n        this._workingPosition = new Vector3();\n        this._workingQuaternion = new Quaternion();\n        this._lastTick = -1;\n        this._recenterNextUpdate = true;\n        /**\n         * Set to false if the node should strictly follow the camera without any interpolation time\n         */\n        this.interpolatePose = true;\n        /**\n         * Rate of interpolation of position and rotation of the attached node.\n         * Higher values will give a slower interpolation.\n         */\n        this.lerpTime = 500;\n        /**\n         * If the behavior should ignore the pitch and roll of the camera.\n         */\n        this.ignoreCameraPitchAndRoll = false;\n        /**\n         * Pitch offset from camera (relative to Max Distance)\n         * Is only effective if `ignoreCameraPitchAndRoll` is set to `true`.\n         */\n        this.pitchOffset = 15;\n        /**\n         * The vertical angle from the camera forward axis to the owner will not exceed this value\n         */\n        this.maxViewVerticalDegrees = 30;\n        /**\n         * The horizontal angle from the camera forward axis to the owner will not exceed this value\n         */\n        this.maxViewHorizontalDegrees = 30;\n        /**\n         * The attached node will not reorient until the angle between its forward vector and the vector to the camera is greater than this value\n         */\n        this.orientToCameraDeadzoneDegrees = 60;\n        /**\n         * Option to ignore distance clamping\n         */\n        this.ignoreDistanceClamp = false;\n        /**\n         * Option to ignore angle clamping\n         */\n        this.ignoreAngleClamp = false;\n        /**\n         * Max vertical distance between the attachedNode and camera\n         */\n        this.verticalMaxDistance = 0;\n        /**\n         *  Default distance from eye to attached node, i.e. the sphere radius\n         */\n        this.defaultDistance = 0.8;\n        /**\n         *  Max distance from eye to attached node, i.e. the sphere radius\n         */\n        this.maximumDistance = 2;\n        /**\n         *  Min distance from eye to attached node, i.e. the sphere radius\n         */\n        this.minimumDistance = 0.3;\n        /**\n         * Ignore vertical movement and lock the Y position of the object.\n         */\n        this.useFixedVerticalOffset = false;\n        /**\n         * Fixed vertical position offset distance.\n         */\n        this.fixedVerticalOffset = 0;\n        /**\n         * Enables/disables the behavior\n         * @internal\n         */\n        this._enabled = true;\n    }\n    /**\n     * The camera that should be followed by this behavior\n     */\n    get followedCamera() {\n        return this._followedCamera || this._scene.activeCamera;\n    }\n    set followedCamera(camera) {\n        this._followedCamera = camera;\n    }\n    /**\n     *  The name of the behavior\n     */\n    get name() {\n        return \"Follow\";\n    }\n    /**\n     *  Initializes the behavior\n     */\n    init() { }\n    /**\n     * Attaches the follow behavior\n     * @param ownerNode The mesh that will be following once attached\n     * @param followedCamera The camera that should be followed by the node\n     */\n    attach(ownerNode, followedCamera) {\n        this._scene = ownerNode.getScene();\n        this.attachedNode = ownerNode;\n        if (followedCamera) {\n            this.followedCamera = followedCamera;\n        }\n        this._addObservables();\n    }\n    /**\n     *  Detaches the behavior from the mesh\n     */\n    detach() {\n        this.attachedNode = null;\n        this._removeObservables();\n    }\n    /**\n     * Recenters the attached node in front of the camera on the next update\n     */\n    recenter() {\n        this._recenterNextUpdate = true;\n    }\n    _angleBetweenVectorAndPlane(vector, normal) {\n        // Work on copies\n        this._tmpVectors[0].copyFrom(vector);\n        vector = this._tmpVectors[0];\n        this._tmpVectors[1].copyFrom(normal);\n        normal = this._tmpVectors[1];\n        vector.normalize();\n        normal.normalize();\n        return Math.PI / 2 - Math.acos(Vector3.Dot(vector, normal));\n    }\n    _length2D(vector) {\n        return Math.sqrt(vector.x * vector.x + vector.z * vector.z);\n    }\n    _distanceClamp(currentToTarget, moveToDefault = false) {\n        let minDistance = this.minimumDistance;\n        let maxDistance = this.maximumDistance;\n        const defaultDistance = this.defaultDistance;\n        const direction = this._tmpVectors[0];\n        direction.copyFrom(currentToTarget);\n        let currentDistance = direction.length();\n        direction.normalizeFromLength(currentDistance);\n        if (this.ignoreCameraPitchAndRoll) {\n            // If we don't account for pitch offset, the casted object will float up/down as the reference\n            // gets closer to it because we will still be casting in the direction of the pitched offset.\n            // To fix this, only modify the XZ position of the object.\n            minDistance = this._length2D(direction) * minDistance;\n            maxDistance = this._length2D(direction) * maxDistance;\n            const currentDistance2D = this._length2D(currentToTarget);\n            direction.scaleInPlace(currentDistance / currentDistance2D);\n            currentDistance = currentDistance2D;\n        }\n        let clampedDistance = currentDistance;\n        if (moveToDefault) {\n            clampedDistance = defaultDistance;\n        }\n        else {\n            clampedDistance = Clamp(currentDistance, minDistance, maxDistance);\n        }\n        currentToTarget.copyFrom(direction).scaleInPlace(clampedDistance);\n        return currentDistance !== clampedDistance;\n    }\n    _applyVerticalClamp(currentToTarget) {\n        if (this.verticalMaxDistance !== 0) {\n            currentToTarget.y = Clamp(currentToTarget.y, -this.verticalMaxDistance, this.verticalMaxDistance);\n        }\n    }\n    _toOrientationQuatToRef(vector, quaternion) {\n        Quaternion.RotationYawPitchRollToRef(Math.atan2(vector.x, vector.z), Math.atan2(vector.y, Math.sqrt(vector.z * vector.z + vector.x * vector.x)), 0, quaternion);\n    }\n    _applyPitchOffset(invertView) {\n        const forward = this._tmpVectors[0];\n        const right = this._tmpVectors[1];\n        forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n        right.copyFromFloats(1, 0, 0);\n        Vector3.TransformNormalToRef(forward, invertView, forward);\n        forward.y = 0;\n        forward.normalize();\n        Vector3.TransformNormalToRef(right, invertView, right);\n        Quaternion.RotationAxisToRef(right, (this.pitchOffset * Math.PI) / 180, this._tmpQuaternion);\n        forward.rotateByQuaternionToRef(this._tmpQuaternion, forward);\n        this._toOrientationQuatToRef(forward, this._tmpQuaternion);\n        this._tmpQuaternion.toRotationMatrix(this._tmpMatrix);\n        // Since we already extracted position from the invert view matrix, we can\n        // disregard the position part of the matrix in the copy\n        invertView.copyFrom(this._tmpMatrix);\n    }\n    _angularClamp(invertView, currentToTarget) {\n        const forward = this._tmpVectors[5];\n        forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n        const right = this._tmpVectors[6];\n        right.copyFromFloats(1, 0, 0);\n        // forward and right are related to camera frame of reference\n        Vector3.TransformNormalToRef(forward, invertView, forward);\n        Vector3.TransformNormalToRef(right, invertView, right);\n        // Up is global Z\n        const up = Vector3.UpReadOnly;\n        const dist = currentToTarget.length();\n        if (dist < Epsilon) {\n            return false;\n        }\n        let angularClamped = false;\n        const rotationQuat = this._tmpQuaternion;\n        // X-axis leashing\n        if (this.ignoreCameraPitchAndRoll) {\n            const angle = Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);\n            Quaternion.RotationAxisToRef(right, angle, rotationQuat);\n            currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n        }\n        else {\n            const angle = -Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);\n            const minMaxAngle = ((this.maxViewVerticalDegrees * Math.PI) / 180) * 0.5;\n            if (angle < -minMaxAngle) {\n                Quaternion.RotationAxisToRef(right, -angle - minMaxAngle, rotationQuat);\n                currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n                angularClamped = true;\n            }\n            else if (angle > minMaxAngle) {\n                Quaternion.RotationAxisToRef(right, -angle + minMaxAngle, rotationQuat);\n                currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n                angularClamped = true;\n            }\n        }\n        // Y-axis leashing\n        const angle = this._angleBetweenVectorAndPlane(currentToTarget, right) * (this._scene.useRightHandedSystem ? -1 : 1);\n        const minMaxAngle = ((this.maxViewHorizontalDegrees * Math.PI) / 180) * 0.5;\n        if (angle < -minMaxAngle) {\n            Quaternion.RotationAxisToRef(up, -angle - minMaxAngle, rotationQuat);\n            currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n            angularClamped = true;\n        }\n        else if (angle > minMaxAngle) {\n            Quaternion.RotationAxisToRef(up, -angle + minMaxAngle, rotationQuat);\n            currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n            angularClamped = true;\n        }\n        return angularClamped;\n    }\n    _orientationClamp(currentToTarget, rotationQuaternion) {\n        // Construct a rotation quat from up vector and target vector\n        const toFollowed = this._tmpVectors[0];\n        toFollowed.copyFrom(currentToTarget).scaleInPlace(-1).normalize();\n        const up = this._tmpVectors[1];\n        const right = this._tmpVectors[2];\n        // We use global up vector to orient the following node (global +Y)\n        up.copyFromFloats(0, 1, 0);\n        // Gram-Schmidt to create an orthonormal frame\n        Vector3.CrossToRef(toFollowed, up, right);\n        const length = right.length();\n        if (length < Epsilon) {\n            return;\n        }\n        right.normalizeFromLength(length);\n        Vector3.CrossToRef(right, toFollowed, up);\n        if (this.attachedNode?.getScene().useRightHandedSystem) {\n            Quaternion.FromLookDirectionRHToRef(toFollowed, up, rotationQuaternion);\n        }\n        else {\n            Quaternion.FromLookDirectionLHToRef(toFollowed, up, rotationQuaternion);\n        }\n    }\n    _passedOrientationDeadzone(currentToTarget, forward) {\n        const leashToFollow = this._tmpVectors[5];\n        leashToFollow.copyFrom(currentToTarget);\n        leashToFollow.normalize();\n        const angle = Math.abs(Vector3.GetAngleBetweenVectorsOnPlane(forward, leashToFollow, Vector3.UpReadOnly));\n        return (angle * 180) / Math.PI > this.orientToCameraDeadzoneDegrees;\n    }\n    _updateLeashing(camera) {\n        if (this.attachedNode && this._enabled) {\n            const oldParent = this.attachedNode.parent;\n            this.attachedNode.setParent(null);\n            const worldMatrix = this.attachedNode.getWorldMatrix();\n            const currentToTarget = this._workingPosition;\n            const rotationQuaternion = this._workingQuaternion;\n            const pivot = this.attachedNode.getPivotPoint();\n            const invertView = this._tmpInvertView;\n            invertView.copyFrom(camera.getViewMatrix());\n            invertView.invert();\n            Vector3.TransformCoordinatesToRef(pivot, worldMatrix, currentToTarget);\n            const position = this._tmpPosition;\n            position.copyFromFloats(0, 0, 0);\n            Vector3.TransformCoordinatesToRef(position, worldMatrix, position);\n            position.scaleInPlace(-1).subtractInPlace(pivot);\n            currentToTarget.subtractInPlace(camera.globalPosition);\n            if (this.ignoreCameraPitchAndRoll) {\n                this._applyPitchOffset(invertView);\n            }\n            let angularClamped = false;\n            const forward = this._tmpForward;\n            forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n            Vector3.TransformNormalToRef(forward, invertView, forward);\n            const nodeForward = this._tmpNodeForward;\n            nodeForward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n            Vector3.TransformNormalToRef(nodeForward, worldMatrix, nodeForward);\n            if (this._recenterNextUpdate) {\n                currentToTarget.copyFrom(forward).scaleInPlace(this.defaultDistance);\n            }\n            else {\n                if (this.ignoreAngleClamp) {\n                    const currentDistance = currentToTarget.length();\n                    currentToTarget.copyFrom(forward).scaleInPlace(currentDistance);\n                }\n                else {\n                    angularClamped = this._angularClamp(invertView, currentToTarget);\n                }\n            }\n            let distanceClamped = false;\n            if (!this.ignoreDistanceClamp) {\n                distanceClamped = this._distanceClamp(currentToTarget, angularClamped);\n                this._applyVerticalClamp(currentToTarget);\n            }\n            if (this.useFixedVerticalOffset) {\n                currentToTarget.y = position.y - camera.globalPosition.y + this.fixedVerticalOffset;\n            }\n            if (angularClamped || distanceClamped || this._passedOrientationDeadzone(currentToTarget, nodeForward) || this._recenterNextUpdate) {\n                this._orientationClamp(currentToTarget, rotationQuaternion);\n            }\n            this._workingPosition.subtractInPlace(pivot);\n            this._recenterNextUpdate = false;\n            this.attachedNode.setParent(oldParent);\n        }\n    }\n    _updateTransformToGoal(elapsed) {\n        if (!this.attachedNode || !this.followedCamera || !this._enabled) {\n            return;\n        }\n        if (!this.attachedNode.rotationQuaternion) {\n            this.attachedNode.rotationQuaternion = Quaternion.Identity();\n        }\n        const oldParent = this.attachedNode.parent;\n        this.attachedNode.setParent(null);\n        if (!this.interpolatePose) {\n            this.attachedNode.position.copyFrom(this.followedCamera.globalPosition).addInPlace(this._workingPosition);\n            this.attachedNode.rotationQuaternion.copyFrom(this._workingQuaternion);\n            return;\n        }\n        // position\n        const currentDirection = new Vector3();\n        currentDirection.copyFrom(this.attachedNode.position).subtractInPlace(this.followedCamera.globalPosition);\n        Vector3.SmoothToRef(currentDirection, this._workingPosition, elapsed, this.lerpTime, currentDirection);\n        currentDirection.addInPlace(this.followedCamera.globalPosition);\n        this.attachedNode.position.copyFrom(currentDirection);\n        // rotation\n        const currentRotation = new Quaternion();\n        currentRotation.copyFrom(this.attachedNode.rotationQuaternion);\n        Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this.attachedNode.rotationQuaternion);\n        this.attachedNode.setParent(oldParent);\n    }\n    _addObservables() {\n        this._lastTick = Date.now();\n        this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {\n            if (!this.followedCamera) {\n                return;\n            }\n            const tick = Date.now();\n            this._updateLeashing(this.followedCamera);\n            this._updateTransformToGoal(tick - this._lastTick);\n            this._lastTick = tick;\n        });\n    }\n    _removeObservables() {\n        if (this._onBeforeRender) {\n            this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);\n        }\n    }\n}\n//# sourceMappingURL=followBehavior.js.map","import { Vector3, Vector2 } from \"./math.vector.js\";\n/**\n * Contains position and normal vectors for a vertex\n */\nexport class PositionNormalVertex {\n    /**\n     * Creates a PositionNormalVertex\n     * @param position the position of the vertex (defaut: 0,0,0)\n     * @param normal the normal of the vertex (defaut: 0,1,0)\n     */\n    constructor(\n    /** [Vector3.Zero()] the position of the vertex (defaut: 0,0,0) */\n    position = Vector3.Zero(), \n    /** [Vector3.Up()] the normal of the vertex (defaut: 0,1,0) */\n    normal = Vector3.Up()) {\n        this.position = position;\n        this.normal = normal;\n    }\n    /**\n     * Clones the PositionNormalVertex\n     * @returns the cloned PositionNormalVertex\n     */\n    clone() {\n        return new PositionNormalVertex(this.position.clone(), this.normal.clone());\n    }\n}\n/**\n * Contains position, normal and uv vectors for a vertex\n */\nexport class PositionNormalTextureVertex {\n    /**\n     * Creates a PositionNormalTextureVertex\n     * @param position the position of the vertex (defaut: 0,0,0)\n     * @param normal the normal of the vertex (defaut: 0,1,0)\n     * @param uv the uv of the vertex (default: 0,0)\n     */\n    constructor(\n    /** [Vector3.Zero()] the position of the vertex (defaut: 0,0,0) */\n    position = Vector3.Zero(), \n    /** [Vector3.Up()] the normal of the vertex (defaut: 0,1,0) */\n    normal = Vector3.Up(), \n    /** [Vector3.Zero()] the uv of the vertex (default: 0,0) */\n    uv = Vector2.Zero()) {\n        this.position = position;\n        this.normal = normal;\n        this.uv = uv;\n    }\n    /**\n     * Clones the PositionNormalTextureVertex\n     * @returns the cloned PositionNormalTextureVertex\n     */\n    clone() {\n        return new PositionNormalTextureVertex(this.position.clone(), this.normal.clone(), this.uv.clone());\n    }\n}\n//# sourceMappingURL=math.vertexFormat.js.map","import { Camera } from \"../../Cameras/camera.js\";\nimport { UniversalCamera } from \"../../Cameras/universalCamera.js\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { TargetCamera } from \"../targetCamera.js\";\nimport { TransformNode } from \"../../Meshes/transformNode.js\";\nimport { Viewport } from \"../../Maths/math.viewport.js\";\n/**\n * Camera used to simulate stereoscopic rendering on real screens (based on UniversalCamera)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n */\nexport class StereoscopicScreenUniversalCamera extends UniversalCamera {\n    set distanceBetweenEyes(newValue) {\n        this._distanceBetweenEyes = newValue;\n    }\n    /**\n     * distance between the eyes\n     */\n    get distanceBetweenEyes() {\n        return this._distanceBetweenEyes;\n    }\n    set distanceToProjectionPlane(newValue) {\n        this._distanceToProjectionPlane = newValue;\n    }\n    /**\n     * Distance to projection plane (should be the same units the like distance between the eyes)\n     */\n    get distanceToProjectionPlane() {\n        return this._distanceToProjectionPlane;\n    }\n    /**\n     * Creates a new StereoscopicScreenUniversalCamera\n     * @param name defines camera name\n     * @param position defines initial position\n     * @param scene defines the hosting scene\n     * @param distanceToProjectionPlane defines distance between each color axis. The rig cameras will receive this as their negative z position!\n     * @param distanceBetweenEyes defines is stereoscopic is done side by side or over under\n     */\n    constructor(name, position, scene, distanceToProjectionPlane = 1, distanceBetweenEyes = 0.065) {\n        super(name, position, scene);\n        this._distanceBetweenEyes = distanceBetweenEyes;\n        this._distanceToProjectionPlane = distanceToProjectionPlane;\n        this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL, {\n            stereoHalfAngle: 0,\n        });\n        this._cameraRigParams.stereoHalfAngle = 0;\n        this._cameraRigParams.interaxialDistance = distanceBetweenEyes;\n    }\n    /**\n     * Gets camera class name\n     * @returns StereoscopicScreenUniversalCamera\n     */\n    getClassName() {\n        return \"StereoscopicUniversalCamera\";\n    }\n    /**\n     * @internal\n     */\n    createRigCamera(name) {\n        const camera = new TargetCamera(name, Vector3.Zero(), this.getScene());\n        const transform = new TransformNode(\"tm_\" + name, this.getScene());\n        camera.parent = transform;\n        transform.setPivotMatrix(Matrix.Identity(), false);\n        camera.isRigCamera = true;\n        camera.rigParent = this;\n        return camera;\n    }\n    /**\n     * @internal\n     */\n    _updateRigCameras() {\n        for (let cameraIndex = 0; cameraIndex < this._rigCameras.length; cameraIndex++) {\n            const cam = this._rigCameras[cameraIndex];\n            cam.minZ = this.minZ;\n            cam.maxZ = this.maxZ;\n            cam.fov = this.fov;\n            cam.upVector.copyFrom(this.upVector);\n            if (cam.rotationQuaternion) {\n                cam.rotationQuaternion.copyFrom(this.rotationQuaternion);\n            }\n            else {\n                cam.rotation.copyFrom(this.rotation);\n            }\n            this._updateCamera(this._rigCameras[cameraIndex], cameraIndex);\n        }\n    }\n    _updateCamera(camera, cameraIndex) {\n        const b = this.distanceBetweenEyes / 2;\n        const z = b / this.distanceToProjectionPlane;\n        camera.position.copyFrom(this.position);\n        camera.position.addInPlaceFromFloats(cameraIndex === 0 ? -b : b, 0, -this._distanceToProjectionPlane);\n        const transform = camera.parent;\n        const m = transform.getPivotMatrix();\n        m.setTranslationFromFloats(cameraIndex === 0 ? b : -b, 0, 0);\n        m.setRowFromFloats(2, cameraIndex === 0 ? z : -z, 0, 1, 0);\n        transform.setPivotMatrix(m, false);\n    }\n    _setRigMode() {\n        this._rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1);\n        this._rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\n        for (let cameraIndex = 0; cameraIndex < this._rigCameras.length; cameraIndex++) {\n            this._updateCamera(this._rigCameras[cameraIndex], cameraIndex);\n        }\n    }\n}\n//# sourceMappingURL=stereoscopicScreenUniversalCamera.js.map","/**\n * Utility class to help with bounding info management\n * Warning: using the BoundingInfoHelper class may be slower than executing calculations on the CPU!\n * This will happen if there are a lot of meshes / few vertices (like with the BrainStem model)\n * The BoundingInfoHelper will perform better if there are few meshes / a lot of vertices\n *  https://playground.babylonjs.com/#QPOERJ#9 : WebGL\n *  https://playground.babylonjs.com/#QPOERJ#10 : WebGPU\n */\nexport class BoundingInfoHelper {\n    /**\n     * Creates a new BoundingInfoHelper\n     * @param engine defines the engine to use\n     */\n    constructor(engine) {\n        this._engine = engine;\n    }\n    async _initializePlatform() {\n        if (!this._platform) {\n            if (this._engine.getCaps().supportComputeShaders) {\n                const module = await import(\"./computeShaderBoundingHelper.js\");\n                this._platform = new module.ComputeShaderBoundingHelper(this._engine);\n            }\n            else if (this._engine.getCaps().supportTransformFeedbacks) {\n                const module = await import(\"./transformFeedbackBoundingHelper.js\");\n                this._platform = new module.TransformFeedbackBoundingHelper(this._engine);\n            }\n            else {\n                throw new Error(\"Your engine does not support Compute Shaders or Transform Feedbacks\");\n            }\n        }\n    }\n    /**\n     * Compute the bounding info of a mesh / array of meshes using shaders\n     * @param target defines the mesh(es) to update\n     * @returns a promise that resolves when the bounding info is/are computed\n     */\n    async computeAsync(target) {\n        await this._initializePlatform();\n        return this._platform.processAsync(target);\n    }\n    /**\n     * Register a mesh / array of meshes to be processed per batch\n     * This method must be called before calling batchProcess (which can be called several times) and batchFetchResultsAsync\n     * @param target defines the mesh(es) to be processed per batch\n     * @returns a promise that resolves when the initialization is done\n     */\n    async batchInitializeAsync(target) {\n        await this._initializePlatform();\n        return this._platform.registerMeshListAsync(target);\n    }\n    /**\n     * Processes meshes registered with batchRegisterAsync\n     * If called multiple times, the second, third, etc calls will perform a union of the bounding boxes calculated in the previous calls\n     */\n    batchProcess() {\n        this._platform.processMeshList();\n    }\n    /**\n     * Update the bounding info of the meshes registered with batchRegisterAsync, after batchProcess has been called once or several times\n     * @returns a promise that resolves when the bounding info is/are computed\n     */\n    async batchFetchResultsAsync() {\n        return this._platform.fetchResultsForMeshListAsync();\n    }\n    /**\n     * Dispose and release associated resources\n     */\n    dispose() {\n        this._platform.dispose();\n    }\n}\n//# sourceMappingURL=boundingInfoHelper.js.map","import { ComputeShader } from \"../../Compute/computeShader.js\";\nimport { StorageBuffer } from \"../../Buffers/storageBuffer.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { UniformBuffer } from \"../../Materials/uniformBuffer.js\";\nimport \"../../ShadersWGSL/boundingInfo.compute.js\";\nimport { _retryWithInterval } from \"../../Misc/timingTools.js\";\n/** @internal */\nexport class ComputeShaderBoundingHelper {\n    /**\n     * Creates a new ComputeShaderBoundingHelper\n     * @param engine defines the engine to use\n     */\n    constructor(engine) {\n        this._computeShadersCache = {};\n        this._positionBuffers = {};\n        this._indexBuffers = {};\n        this._weightBuffers = {};\n        this._indexExtraBuffers = {};\n        this._weightExtraBuffers = {};\n        this._morphTargetInfluenceBuffers = {};\n        this._morphTargetTextureIndexBuffers = {};\n        this._ubos = [];\n        this._uboIndex = 0;\n        this._processedMeshes = [];\n        this._computeShaders = [];\n        this._uniqueComputeShaders = new Set();\n        this._resultBuffers = [];\n        this._engine = engine;\n    }\n    _getComputeShader(defines, hasBones, hasMorphs) {\n        let computeShader;\n        const join = defines.join(\"\\n\");\n        if (!this._computeShadersCache[join]) {\n            const bindingsMapping = {\n                positionBuffer: { group: 0, binding: 0 },\n                resultBuffer: { group: 0, binding: 1 },\n                settings: { group: 0, binding: 7 },\n            };\n            if (hasBones) {\n                bindingsMapping.boneSampler = { group: 0, binding: 2 };\n                bindingsMapping.indexBuffer = { group: 0, binding: 3 };\n                bindingsMapping.weightBuffer = { group: 0, binding: 4 };\n                bindingsMapping.indexExtraBuffer = { group: 0, binding: 5 };\n                bindingsMapping.weightExtraBuffer = { group: 0, binding: 6 };\n            }\n            if (hasMorphs) {\n                bindingsMapping.morphTargets = { group: 0, binding: 8 };\n                bindingsMapping.morphTargetInfluences = { group: 0, binding: 9 };\n                bindingsMapping.morphTargetTextureIndices = { group: 0, binding: 10 };\n            }\n            computeShader = new ComputeShader(`boundingInfoCompute${hasBones ? \"_bones\" : \"\"}${hasMorphs ? \"_morphs\" : \"\"}`, this._engine, \"boundingInfo\", {\n                bindingsMapping,\n                defines: defines,\n            });\n            this._computeShadersCache[join] = computeShader;\n        }\n        else {\n            computeShader = this._computeShadersCache[join];\n        }\n        return computeShader;\n    }\n    _getUBO() {\n        if (this._uboIndex >= this._ubos.length) {\n            const ubo = new UniformBuffer(this._engine);\n            ubo.addFloat3(\"morphTargetTextureInfo\", 0, 0, 0);\n            ubo.addUniform(\"morphTargetCount\", 1);\n            ubo.addUniform(\"indexResult\", 1);\n            this._ubos.push(ubo);\n        }\n        return this._ubos[this._uboIndex++];\n    }\n    _extractDataAndLink(computeShader, mesh, kind, stride, name, storageUnit) {\n        let buffer;\n        const vertexCount = mesh.getTotalVertices();\n        if (!storageUnit[mesh.uniqueId]) {\n            const dataArray = mesh.getVertexBuffer(kind)?.getFloatData(vertexCount);\n            buffer = new StorageBuffer(this._engine, Float32Array.BYTES_PER_ELEMENT * vertexCount * stride);\n            buffer.update(dataArray);\n            storageUnit[mesh.uniqueId] = buffer;\n        }\n        else {\n            buffer = storageUnit[mesh.uniqueId];\n        }\n        computeShader.setStorageBuffer(name, buffer);\n    }\n    _prepareStorage(computeShader, name, id, storageUnit, numInfluencers, data) {\n        let buffer;\n        if (!storageUnit[id]) {\n            buffer = new StorageBuffer(this._engine, Float32Array.BYTES_PER_ELEMENT * numInfluencers);\n            storageUnit[id] = buffer;\n        }\n        else {\n            buffer = storageUnit[id];\n        }\n        buffer.update(data);\n        computeShader.setStorageBuffer(name, buffer);\n    }\n    /** @internal */\n    async processAsync(meshes) {\n        await this.registerMeshListAsync(meshes);\n        this.processMeshList();\n        await this.fetchResultsForMeshListAsync();\n    }\n    /** @internal */\n    registerMeshListAsync(meshes) {\n        this._disposeForMeshList();\n        if (!Array.isArray(meshes)) {\n            meshes = [meshes];\n        }\n        let maxNumInfluencers = 0;\n        for (let i = 0; i < meshes.length; i++) {\n            const mesh = meshes[i];\n            const vertexCount = mesh.getTotalVertices();\n            if (vertexCount === 0 || !mesh.getVertexBuffer || !mesh.getVertexBuffer(VertexBuffer.PositionKind)) {\n                continue;\n            }\n            this._processedMeshes.push(mesh);\n            const manager = mesh.morphTargetManager;\n            if (manager && manager.supportsPositions) {\n                maxNumInfluencers = Math.max(maxNumInfluencers, manager.numTargets);\n            }\n        }\n        for (let i = 0; i < this._processedMeshes.length; i++) {\n            const mesh = this._processedMeshes[i];\n            let defines = [\"\"];\n            let hasBones = false;\n            if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n                defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n                hasBones = true;\n            }\n            const computeShaderWithoutMorph = this._getComputeShader(defines, hasBones, false);\n            this._uniqueComputeShaders.add(computeShaderWithoutMorph);\n            const manager = mesh.morphTargetManager;\n            if (manager && manager.supportsPositions) {\n                defines = defines.slice();\n                defines.push(\"#define MORPHTARGETS\");\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + maxNumInfluencers);\n                const computeShaderWithMorph = this._getComputeShader(defines, hasBones, true);\n                this._uniqueComputeShaders.add(computeShaderWithMorph);\n                this._computeShaders.push([computeShaderWithoutMorph, computeShaderWithMorph]);\n            }\n            else {\n                this._computeShaders.push([computeShaderWithoutMorph, computeShaderWithoutMorph]);\n            }\n            // Pre-build the ubos, as they won't change if there's no morph targets\n            const ubo = this._getUBO();\n            ubo.updateUInt(\"indexResult\", i);\n            ubo.update();\n        }\n        return new Promise((resolve) => {\n            _retryWithInterval(() => {\n                const iterator = this._uniqueComputeShaders.keys();\n                for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n                    const computeShader = key.value;\n                    if (!computeShader.isReady()) {\n                        return false;\n                    }\n                }\n                return true;\n            }, resolve);\n        });\n    }\n    /** @internal */\n    processMeshList() {\n        if (this._processedMeshes.length === 0) {\n            return;\n        }\n        this._uboIndex = 0;\n        const resultDataSize = 8 * this._processedMeshes.length;\n        const resultData = new Float32Array(resultDataSize);\n        const resultBuffer = new StorageBuffer(this._engine, Float32Array.BYTES_PER_ELEMENT * resultDataSize);\n        this._resultBuffers.push(resultBuffer);\n        for (let i = 0; i < this._processedMeshes.length; i++) {\n            resultData[i * 8 + 0] = Number.POSITIVE_INFINITY;\n            resultData[i * 8 + 1] = Number.POSITIVE_INFINITY;\n            resultData[i * 8 + 2] = Number.POSITIVE_INFINITY;\n            resultData[i * 8 + 3] = Number.NEGATIVE_INFINITY;\n            resultData[i * 8 + 4] = Number.NEGATIVE_INFINITY;\n            resultData[i * 8 + 5] = Number.NEGATIVE_INFINITY;\n        }\n        resultBuffer.update(resultData);\n        for (let i = 0; i < this._processedMeshes.length; i++) {\n            const mesh = this._processedMeshes[i];\n            const vertexCount = mesh.getTotalVertices();\n            const [computeShaderWithoutMorph, computeShaderWithMorph] = this._computeShaders[i];\n            const manager = mesh.morphTargetManager;\n            const hasMorphs = manager && manager.numInfluencers > 0 && manager.supportsPositions;\n            const computeShader = hasMorphs ? computeShaderWithMorph : computeShaderWithoutMorph;\n            this._extractDataAndLink(computeShader, mesh, VertexBuffer.PositionKind, 3, \"positionBuffer\", this._positionBuffers);\n            // Bones\n            if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton && mesh.skeleton.useTextureToStoreBoneMatrices) {\n                this._extractDataAndLink(computeShader, mesh, VertexBuffer.MatricesIndicesKind, 4, \"indexBuffer\", this._indexBuffers);\n                this._extractDataAndLink(computeShader, mesh, VertexBuffer.MatricesWeightsKind, 4, \"weightBuffer\", this._weightBuffers);\n                const boneSampler = mesh.skeleton.getTransformMatrixTexture(mesh);\n                computeShader.setTexture(\"boneSampler\", boneSampler, false);\n                if (mesh.numBoneInfluencers > 4) {\n                    this._extractDataAndLink(computeShader, mesh, VertexBuffer.MatricesIndicesExtraKind, 4, \"indexExtraBuffer\", this._indexExtraBuffers);\n                    this._extractDataAndLink(computeShader, mesh, VertexBuffer.MatricesWeightsExtraKind, 4, \"weightExtraBuffer\", this._weightExtraBuffers);\n                }\n            }\n            const ubo = this._getUBO();\n            // Morphs\n            if (hasMorphs) {\n                const morphTargets = manager._targetStoreTexture;\n                computeShader.setTexture(\"morphTargets\", morphTargets, false);\n                this._prepareStorage(computeShader, \"morphTargetInfluences\", mesh.uniqueId, this._morphTargetInfluenceBuffers, manager.numInfluencers, manager.influences);\n                this._prepareStorage(computeShader, \"morphTargetTextureIndices\", mesh.uniqueId, this._morphTargetTextureIndexBuffers, manager.numInfluencers, manager._morphTargetTextureIndices);\n                ubo.updateFloat3(\"morphTargetTextureInfo\", manager._textureVertexStride, manager._textureWidth, manager._textureHeight);\n                ubo.updateInt(\"morphTargetCount\", manager.numInfluencers);\n                ubo.update();\n            }\n            computeShader.setStorageBuffer(\"resultBuffer\", resultBuffer);\n            computeShader.setUniformBuffer(\"settings\", ubo);\n            // Dispatch\n            computeShader.dispatch(Math.ceil(vertexCount / 256));\n            this._engine.flushFramebuffer();\n        }\n    }\n    /** @internal */\n    fetchResultsForMeshListAsync() {\n        return new Promise((resolve) => {\n            const buffers = [];\n            let size = 0;\n            for (let i = 0; i < this._resultBuffers.length; i++) {\n                const buffer = this._resultBuffers[i].getBuffer();\n                buffers.push(buffer);\n                size += buffer.capacity;\n            }\n            const resultData = new Float32Array(size / Float32Array.BYTES_PER_ELEMENT);\n            const minimum = Vector3.Zero();\n            const maximum = Vector3.Zero();\n            const minmax = { minimum, maximum };\n            this._engine.readFromMultipleStorageBuffers(buffers, 0, undefined, resultData, true).then(() => {\n                let resultDataOffset = 0;\n                for (let j = 0; j < this._resultBuffers.length; j++) {\n                    for (let i = 0; i < this._processedMeshes.length; i++) {\n                        const mesh = this._processedMeshes[i];\n                        Vector3.FromArrayToRef(resultData, resultDataOffset + i * 8, minimum);\n                        Vector3.FromArrayToRef(resultData, resultDataOffset + i * 8 + 3, maximum);\n                        if (j > 0) {\n                            minimum.minimizeInPlace(mesh.getBoundingInfo().minimum);\n                            maximum.maximizeInPlace(mesh.getBoundingInfo().maximum);\n                        }\n                        mesh._refreshBoundingInfoDirect(minmax);\n                    }\n                    resultDataOffset += 8 * this._processedMeshes.length;\n                }\n                for (const resultBuffer of this._resultBuffers) {\n                    resultBuffer.dispose();\n                }\n                this._resultBuffers = [];\n                this._uboIndex = 0;\n                resolve();\n            });\n        });\n    }\n    _disposeCache(storageUnit) {\n        for (const key in storageUnit) {\n            storageUnit[key].dispose();\n        }\n    }\n    _disposeForMeshList() {\n        for (const resultBuffer of this._resultBuffers) {\n            resultBuffer.dispose();\n        }\n        this._resultBuffers = [];\n        this._processedMeshes = [];\n        this._computeShaders = [];\n        this._uniqueComputeShaders = new Set();\n    }\n    /** @internal */\n    dispose() {\n        this._disposeCache(this._positionBuffers);\n        this._positionBuffers = {};\n        this._disposeCache(this._indexBuffers);\n        this._indexBuffers = {};\n        this._disposeCache(this._weightBuffers);\n        this._weightBuffers = {};\n        this._disposeCache(this._morphTargetInfluenceBuffers);\n        this._morphTargetInfluenceBuffers = {};\n        this._disposeCache(this._morphTargetTextureIndexBuffers);\n        this._morphTargetTextureIndexBuffers = {};\n        for (const ubo of this._ubos) {\n            ubo.dispose();\n        }\n        this._ubos = [];\n        this._computeShadersCache = {};\n        this._engine = undefined;\n        this._disposeForMeshList();\n    }\n}\n//# sourceMappingURL=computeShaderBoundingHelper.js.map","import { Observable } from \"../Misc/observable.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder.js\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { TmpVectors } from \"../Maths/math.vector.js\";\n/**\n * Single axis drag gizmo\n */\nexport class AxisDragGizmo extends Gizmo {\n    /** Default material used to render when gizmo is not disabled or hovered */\n    get coloredMaterial() {\n        return this._coloredMaterial;\n    }\n    /** Material used to render when gizmo is hovered with mouse*/\n    get hoverMaterial() {\n        return this._hoverMaterial;\n    }\n    /** Material used to render when gizmo is disabled. typically grey.*/\n    get disableMaterial() {\n        return this._disableMaterial;\n    }\n    /**\n     * @internal\n     */\n    static _CreateArrow(scene, material, thickness = 1, isCollider = false) {\n        const arrow = new TransformNode(\"arrow\", scene);\n        const cylinder = CreateCylinder(\"cylinder\", {\n            diameterTop: 0,\n            height: 0.075,\n            diameterBottom: 0.0375 * (1 + (thickness - 1) / 4),\n            tessellation: 96,\n        }, scene);\n        const line = CreateCylinder(\"cylinder\", {\n            diameterTop: 0.005 * thickness,\n            height: 0.275,\n            diameterBottom: 0.005 * thickness,\n            tessellation: 96,\n        }, scene);\n        // Position arrow pointing in its drag axis\n        cylinder.parent = arrow;\n        cylinder.material = material;\n        cylinder.rotation.x = Math.PI / 2;\n        cylinder.position.z += 0.3;\n        line.parent = arrow;\n        line.material = material;\n        line.position.z += 0.275 / 2;\n        line.rotation.x = Math.PI / 2;\n        if (isCollider) {\n            line.visibility = 0;\n            cylinder.visibility = 0;\n        }\n        return arrow;\n    }\n    /**\n     * @internal\n     */\n    static _CreateArrowInstance(scene, arrow) {\n        const instance = new TransformNode(\"arrow\", scene);\n        for (const mesh of arrow.getChildMeshes()) {\n            const childInstance = mesh.createInstance(mesh.name);\n            childInstance.parent = instance;\n        }\n        return instance;\n    }\n    /**\n     * Creates an AxisDragGizmo\n     * @param dragAxis The axis which the gizmo will be able to drag on\n     * @param color The color of the gizmo\n     * @param gizmoLayer The utility layer the gizmo will be added to\n     * @param parent\n     * @param thickness display gizmo axis thickness\n     * @param hoverColor The color of the gizmo when hovering over and dragging\n     * @param disableColor The Color of the gizmo when its disabled\n     */\n    constructor(dragAxis, color = Color3.Gray(), gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, parent = null, thickness = 1, hoverColor = Color3.Yellow(), disableColor = Color3.Gray()) {\n        super(gizmoLayer);\n        this._pointerObserver = null;\n        /**\n         * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\n         */\n        this.snapDistance = 0;\n        /**\n         * Event that fires each time the gizmo snaps to a new location.\n         * * snapDistance is the change in distance\n         */\n        this.onSnapObservable = new Observable();\n        this._isEnabled = true;\n        this._parent = null;\n        this._dragging = false;\n        this._parent = parent;\n        // Create Material\n        this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n        this._coloredMaterial.diffuseColor = color;\n        this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));\n        this._hoverMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n        this._hoverMaterial.diffuseColor = hoverColor;\n        this._disableMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n        this._disableMaterial.diffuseColor = disableColor;\n        this._disableMaterial.alpha = 0.4;\n        // Build Mesh + Collider\n        const arrow = AxisDragGizmo._CreateArrow(gizmoLayer.utilityLayerScene, this._coloredMaterial, thickness);\n        const collider = AxisDragGizmo._CreateArrow(gizmoLayer.utilityLayerScene, this._coloredMaterial, thickness + 4, true);\n        // Add to Root Node\n        this._gizmoMesh = new Mesh(\"\", gizmoLayer.utilityLayerScene);\n        this._gizmoMesh.addChild(arrow);\n        this._gizmoMesh.addChild(collider);\n        this._gizmoMesh.lookAt(this._rootMesh.position.add(dragAxis));\n        this._gizmoMesh.scaling.scaleInPlace(1 / 3);\n        this._gizmoMesh.parent = this._rootMesh;\n        let currentSnapDragDistance = 0;\n        const tmpSnapEvent = { snapDistance: 0 };\n        // Add drag behavior to handle events when the gizmo is dragged\n        this.dragBehavior = new PointerDragBehavior({ dragAxis: dragAxis });\n        this.dragBehavior.moveAttached = false;\n        this.dragBehavior.updateDragPlane = false;\n        this._rootMesh.addBehavior(this.dragBehavior);\n        this.dragBehavior.onDragObservable.add((event) => {\n            if (this.attachedNode) {\n                // Keep world translation and use it to update world transform\n                // if the node has parent, the local transform properties (position, rotation, scale)\n                // will be recomputed in _matrixChanged function\n                let matrixChanged = false;\n                // Snapping logic\n                if (this.snapDistance == 0) {\n                    this.attachedNode.getWorldMatrix().getTranslationToRef(TmpVectors.Vector3[2]);\n                    TmpVectors.Vector3[2].addInPlace(event.delta);\n                    if (this.dragBehavior.validateDrag(TmpVectors.Vector3[2])) {\n                        if (this.attachedNode.position) {\n                            // Required for nodes like lights\n                            this.attachedNode.position.addInPlaceFromFloats(event.delta.x, event.delta.y, event.delta.z);\n                        }\n                        // use _worldMatrix to not force a matrix update when calling GetWorldMatrix especially with Cameras\n                        this.attachedNode.getWorldMatrix().addTranslationFromFloats(event.delta.x, event.delta.y, event.delta.z);\n                        this.attachedNode.updateCache();\n                        matrixChanged = true;\n                    }\n                }\n                else {\n                    currentSnapDragDistance += event.dragDistance;\n                    if (Math.abs(currentSnapDragDistance) > this.snapDistance) {\n                        const dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / this.snapDistance);\n                        currentSnapDragDistance = currentSnapDragDistance % this.snapDistance;\n                        event.delta.normalizeToRef(TmpVectors.Vector3[1]);\n                        TmpVectors.Vector3[1].scaleInPlace(this.snapDistance * dragSteps);\n                        this.attachedNode.getWorldMatrix().getTranslationToRef(TmpVectors.Vector3[2]);\n                        TmpVectors.Vector3[2].addInPlace(TmpVectors.Vector3[1]);\n                        if (this.dragBehavior.validateDrag(TmpVectors.Vector3[2])) {\n                            this.attachedNode.getWorldMatrix().addTranslationFromFloats(TmpVectors.Vector3[1].x, TmpVectors.Vector3[1].y, TmpVectors.Vector3[1].z);\n                            this.attachedNode.updateCache();\n                            tmpSnapEvent.snapDistance = this.snapDistance * dragSteps * Math.sign(currentSnapDragDistance);\n                            this.onSnapObservable.notifyObservers(tmpSnapEvent);\n                            matrixChanged = true;\n                        }\n                    }\n                }\n                if (matrixChanged) {\n                    this._matrixChanged();\n                }\n            }\n        });\n        this.dragBehavior.onDragStartObservable.add(() => {\n            this._dragging = true;\n        });\n        this.dragBehavior.onDragEndObservable.add(() => {\n            this._dragging = false;\n        });\n        const light = gizmoLayer._getSharedGizmoLight();\n        light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes(false));\n        const cache = {\n            gizmoMeshes: arrow.getChildMeshes(),\n            colliderMeshes: collider.getChildMeshes(),\n            material: this._coloredMaterial,\n            hoverMaterial: this._hoverMaterial,\n            disableMaterial: this._disableMaterial,\n            active: false,\n            dragBehavior: this.dragBehavior,\n        };\n        this._parent?.addToAxisCache(collider, cache);\n        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\n            if (this._customMeshSet) {\n                return;\n            }\n            this._isHovered = !!(cache.colliderMeshes.indexOf(pointerInfo?.pickInfo?.pickedMesh) != -1);\n            if (!this._parent) {\n                const material = this.dragBehavior.enabled ? (this._isHovered || this._dragging ? this._hoverMaterial : this._coloredMaterial) : this._disableMaterial;\n                this._setGizmoMeshMaterial(cache.gizmoMeshes, material);\n            }\n        });\n        this.dragBehavior.onEnabledObservable.add((newState) => {\n            this._setGizmoMeshMaterial(cache.gizmoMeshes, newState ? cache.material : cache.disableMaterial);\n        });\n    }\n    _attachedNodeChanged(value) {\n        if (this.dragBehavior) {\n            this.dragBehavior.enabled = value ? true : false;\n        }\n    }\n    /**\n     * If the gizmo is enabled\n     */\n    set isEnabled(value) {\n        this._isEnabled = value;\n        if (!value) {\n            this.attachedMesh = null;\n            this.attachedNode = null;\n        }\n        else {\n            if (this._parent) {\n                this.attachedMesh = this._parent.attachedMesh;\n                this.attachedNode = this._parent.attachedNode;\n            }\n        }\n    }\n    get isEnabled() {\n        return this._isEnabled;\n    }\n    /**\n     * Disposes of the gizmo\n     */\n    dispose() {\n        this.onSnapObservable.clear();\n        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n        this.dragBehavior.detach();\n        if (this._gizmoMesh) {\n            this._gizmoMesh.dispose();\n        }\n        [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach((matl) => {\n            if (matl) {\n                matl.dispose();\n            }\n        });\n        super.dispose();\n    }\n}\n//# sourceMappingURL=axisDragGizmo.js.map","import { Vector3 } from \"../Maths/math.vector.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { AxisDragGizmo } from \"../Gizmos/axisDragGizmo.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n/**\n * The Axes viewer will show 3 axes in a specific point in space\n * @see https://doc.babylonjs.com/toolsAndResources/utilities/World_Axes\n */\nexport class AxesViewer {\n    /**\n     * Gets or sets a number used to scale line length\n     */\n    get scaleLines() {\n        return this._scaleLines;\n    }\n    set scaleLines(value) {\n        this._scaleLines = value;\n        this._xAxis.scaling.setAll(this._scaleLines * this._scaleLinesFactor);\n        this._yAxis.scaling.setAll(this._scaleLines * this._scaleLinesFactor);\n        this._zAxis.scaling.setAll(this._scaleLines * this._scaleLinesFactor);\n    }\n    /** Gets the node hierarchy used to render x-axis */\n    get xAxis() {\n        return this._xAxis;\n    }\n    /** Gets the node hierarchy used to render y-axis */\n    get yAxis() {\n        return this._yAxis;\n    }\n    /** Gets the node hierarchy used to render z-axis */\n    get zAxis() {\n        return this._zAxis;\n    }\n    /**\n     * Creates a new AxesViewer\n     * @param scene defines the hosting scene\n     * @param scaleLines defines a number used to scale line length (1 by default)\n     * @param renderingGroupId defines a number used to set the renderingGroupId of the meshes (2 by default)\n     * @param xAxis defines the node hierarchy used to render the x-axis\n     * @param yAxis defines the node hierarchy used to render the y-axis\n     * @param zAxis defines the node hierarchy used to render the z-axis\n     * @param lineThickness The line thickness to use when creating the arrow. defaults to 1.\n     */\n    constructor(scene, scaleLines = 1, renderingGroupId = 2, xAxis, yAxis, zAxis, lineThickness = 1) {\n        this._scaleLinesFactor = 4;\n        this._instanced = false;\n        /**\n         * Gets the hosting scene\n         */\n        this.scene = null;\n        this._scaleLines = 1;\n        scene = scene || EngineStore.LastCreatedScene;\n        if (!scene) {\n            return;\n        }\n        if (!xAxis) {\n            const redColoredMaterial = new StandardMaterial(\"xAxisMaterial\", scene);\n            redColoredMaterial.disableLighting = true;\n            redColoredMaterial.emissiveColor = Color3.Red().scale(0.5);\n            xAxis = AxisDragGizmo._CreateArrow(scene, redColoredMaterial, lineThickness);\n        }\n        if (!yAxis) {\n            const greenColoredMaterial = new StandardMaterial(\"yAxisMaterial\", scene);\n            greenColoredMaterial.disableLighting = true;\n            greenColoredMaterial.emissiveColor = Color3.Green().scale(0.5);\n            yAxis = AxisDragGizmo._CreateArrow(scene, greenColoredMaterial, lineThickness);\n        }\n        if (!zAxis) {\n            const blueColoredMaterial = new StandardMaterial(\"zAxisMaterial\", scene);\n            blueColoredMaterial.disableLighting = true;\n            blueColoredMaterial.emissiveColor = Color3.Blue().scale(0.5);\n            zAxis = AxisDragGizmo._CreateArrow(scene, blueColoredMaterial, lineThickness);\n        }\n        this._xAxis = xAxis;\n        this._yAxis = yAxis;\n        this._zAxis = zAxis;\n        this.scaleLines = scaleLines;\n        if (renderingGroupId != null) {\n            AxesViewer._SetRenderingGroupId(this._xAxis, renderingGroupId);\n            AxesViewer._SetRenderingGroupId(this._yAxis, renderingGroupId);\n            AxesViewer._SetRenderingGroupId(this._zAxis, renderingGroupId);\n        }\n        this.scene = scene;\n        this.update(new Vector3(), Vector3.Right(), Vector3.Up(), Vector3.Forward());\n    }\n    /**\n     * Force the viewer to update\n     * @param position defines the position of the viewer\n     * @param xaxis defines the x axis of the viewer\n     * @param yaxis defines the y axis of the viewer\n     * @param zaxis defines the z axis of the viewer\n     */\n    update(position, xaxis, yaxis, zaxis) {\n        this._xAxis.position.copyFrom(position);\n        this._xAxis.setDirection(xaxis);\n        this._yAxis.position.copyFrom(position);\n        this._yAxis.setDirection(yaxis);\n        this._zAxis.position.copyFrom(position);\n        this._zAxis.setDirection(zaxis);\n    }\n    /**\n     * Creates an instance of this axes viewer.\n     * @returns a new axes viewer with instanced meshes\n     */\n    createInstance() {\n        const xAxis = AxisDragGizmo._CreateArrowInstance(this.scene, this._xAxis);\n        const yAxis = AxisDragGizmo._CreateArrowInstance(this.scene, this._yAxis);\n        const zAxis = AxisDragGizmo._CreateArrowInstance(this.scene, this._zAxis);\n        const axesViewer = new AxesViewer(this.scene, this.scaleLines, null, xAxis, yAxis, zAxis);\n        axesViewer._instanced = true;\n        return axesViewer;\n    }\n    /** Releases resources */\n    dispose() {\n        if (this._xAxis) {\n            this._xAxis.dispose(false, !this._instanced);\n        }\n        if (this._yAxis) {\n            this._yAxis.dispose(false, !this._instanced);\n        }\n        if (this._zAxis) {\n            this._zAxis.dispose(false, !this._instanced);\n        }\n        this.scene = null;\n    }\n    static _SetRenderingGroupId(node, id) {\n        node.getChildMeshes().forEach((mesh) => {\n            mesh.renderingGroupId = id;\n        });\n    }\n}\n//# sourceMappingURL=axesViewer.js.map","import { AxesViewer } from \"../Debug/axesViewer.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Axis } from \"../Maths/math.axis.js\";\n/**\n * The BoneAxesViewer will attach 3 axes to a specific bone of a specific mesh\n * @see demo here: https://www.babylonjs-playground.com/#0DE8F4#8\n */\nexport class BoneAxesViewer extends AxesViewer {\n    /**\n     * Creates a new BoneAxesViewer\n     * @param scene defines the hosting scene\n     * @param bone defines the target bone\n     * @param mesh defines the target mesh\n     * @param scaleLines defines a scaling factor for line length (1 by default)\n     */\n    constructor(scene, bone, mesh, scaleLines = 1) {\n        super(scene, scaleLines);\n        /** Gets current position */\n        this.pos = Vector3.Zero();\n        /** Gets direction of X axis */\n        this.xaxis = Vector3.Zero();\n        /** Gets direction of Y axis */\n        this.yaxis = Vector3.Zero();\n        /** Gets direction of Z axis */\n        this.zaxis = Vector3.Zero();\n        this.mesh = mesh;\n        this.bone = bone;\n    }\n    /**\n     * Force the viewer to update\n     */\n    update() {\n        if (!this.mesh || !this.bone) {\n            return;\n        }\n        const bone = this.bone;\n        bone.getAbsolutePositionToRef(this.mesh, this.pos);\n        bone.getDirectionToRef(Axis.X, this.mesh, this.xaxis);\n        bone.getDirectionToRef(Axis.Y, this.mesh, this.yaxis);\n        bone.getDirectionToRef(Axis.Z, this.mesh, this.zaxis);\n        super.update(this.pos, this.xaxis, this.yaxis, this.zaxis);\n    }\n    /** Releases resources */\n    dispose() {\n        if (this.mesh) {\n            this.mesh = null;\n            this.bone = null;\n            super.dispose();\n        }\n    }\n}\n//# sourceMappingURL=boneAxesViewer.js.map","import { Mesh } from \"../Meshes/mesh.js\";\nimport { CreateBox } from \"../Meshes/Builders/boxBuilder.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { Matrix, Quaternion, TmpVectors, Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { PhysicsImpostor } from \"../Physics/v1/physicsImpostor.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder.js\";\nimport { CreateCapsule } from \"../Meshes/Builders/capsuleBuilder.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { MeshBuilder } from \"../Meshes/meshBuilder.js\";\nimport { AxesViewer } from \"./axesViewer.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\n/**\n * Used to show the physics impostor around the specific mesh\n */\nexport class PhysicsViewer {\n    /**\n     * Creates a new PhysicsViewer\n     * @param scene defines the hosting scene\n     * @param size Physics V2 size scalar\n     */\n    constructor(scene, size) {\n        /** @internal */\n        this._impostors = [];\n        /** @internal */\n        this._meshes = [];\n        /** @internal */\n        this._bodies = [];\n        /** @internal */\n        this._inertiaBodies = [];\n        /** @internal */\n        this._constraints = [];\n        /** @internal */\n        this._bodyMeshes = [];\n        /** @internal */\n        this._inertiaMeshes = [];\n        /** @internal */\n        this._constraintMeshes = [];\n        /** @internal */\n        this._numMeshes = 0;\n        /** @internal */\n        this._numBodies = 0;\n        /** @internal */\n        this._numInertiaBodies = 0;\n        /** @internal */\n        this._numConstraints = 0;\n        this._debugMeshMeshes = new Array();\n        this._constraintAxesSize = 0.4;\n        this._constraintAngularSize = 0.4;\n        this._scene = scene || EngineStore.LastCreatedScene;\n        if (!this._scene) {\n            return;\n        }\n        const physicEngine = this._scene.getPhysicsEngine();\n        if (physicEngine) {\n            this._physicsEnginePlugin = physicEngine.getPhysicsPlugin();\n        }\n        this._utilityLayer = new UtilityLayerRenderer(this._scene, false);\n        this._utilityLayer.pickUtilitySceneFirst = false;\n        this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;\n        if (size) {\n            this._constraintAxesSize = 0.4 * size;\n            this._constraintAngularSize = 0.4 * size;\n        }\n    }\n    /**\n     * Updates the debug meshes of the physics engine.\n     *\n     * This code is useful for synchronizing the debug meshes of the physics engine with the physics impostor and mesh.\n     * It checks if the impostor is disposed and if the plugin version is 1, then it syncs the mesh with the impostor.\n     * This ensures that the debug meshes are up to date with the physics engine.\n     */\n    _updateDebugMeshes() {\n        const plugin = this._physicsEnginePlugin;\n        if (plugin?.getPluginVersion() === 1) {\n            this._updateDebugMeshesV1();\n        }\n        else {\n            this._updateDebugMeshesV2();\n        }\n    }\n    /**\n     * Updates the debug meshes of the physics engine.\n     *\n     * This method is useful for synchronizing the debug meshes with the physics impostors.\n     * It iterates through the impostors and meshes, and if the plugin version is 1, it syncs the mesh with the impostor.\n     * This ensures that the debug meshes accurately reflect the physics impostors, which is important for debugging the physics engine.\n     */\n    _updateDebugMeshesV1() {\n        const plugin = this._physicsEnginePlugin;\n        for (let i = 0; i < this._numMeshes; i++) {\n            const impostor = this._impostors[i];\n            if (!impostor) {\n                continue;\n            }\n            if (impostor.isDisposed) {\n                this.hideImpostor(this._impostors[i--]);\n            }\n            else {\n                if (impostor.type === PhysicsImpostor.MeshImpostor) {\n                    continue;\n                }\n                const mesh = this._meshes[i];\n                if (mesh && plugin) {\n                    plugin.syncMeshWithImpostor(mesh, impostor);\n                }\n            }\n        }\n    }\n    /**\n     * Updates the debug meshes of the physics engine for V2 plugin.\n     *\n     * This method is useful for synchronizing the debug meshes of the physics engine with the current state of the bodies.\n     * It iterates through the bodies array and updates the debug meshes with the current transform of each body.\n     * This ensures that the debug meshes accurately reflect the current state of the physics engine.\n     */\n    _updateDebugMeshesV2() {\n        const plugin = this._physicsEnginePlugin;\n        for (let i = 0; i < this._numBodies;) {\n            const body = this._bodies[i];\n            if (body && body.isDisposed && this.hideBody(body)) {\n                continue;\n            }\n            const transform = this._bodyMeshes[i];\n            if (body && transform) {\n                plugin.syncTransform(body, transform);\n            }\n            i++;\n        }\n    }\n    _updateInertiaMeshes() {\n        for (let i = 0; i < this._numInertiaBodies;) {\n            const body = this._inertiaBodies[i];\n            if (body && body.isDisposed && this.hideInertia(body)) {\n                continue;\n            }\n            const mesh = this._inertiaMeshes[i];\n            if (body && mesh) {\n                this._updateDebugInertia(body, mesh);\n            }\n            i++;\n        }\n    }\n    _updateDebugInertia(body, inertiaMesh) {\n        const inertiaMatrixRef = Matrix.Identity();\n        const transformMatrixRef = Matrix.Identity();\n        const finalMatrixRef = Matrix.Identity();\n        if (body._pluginDataInstances.length) {\n            const inertiaAsMesh = inertiaMesh;\n            const inertiaMeshMatrixData = inertiaAsMesh._thinInstanceDataStorage.matrixData;\n            const bodyTransformMatrixData = body.transformNode._thinInstanceDataStorage.matrixData;\n            for (let i = 0; i < body._pluginDataInstances.length; i++) {\n                const props = body.getMassProperties(i);\n                this._getMeshDebugInertiaMatrixToRef(props, inertiaMatrixRef);\n                Matrix.FromArrayToRef(bodyTransformMatrixData, i * 16, transformMatrixRef);\n                inertiaMatrixRef.multiplyToRef(transformMatrixRef, finalMatrixRef);\n                finalMatrixRef.copyToArray(inertiaMeshMatrixData, i * 16);\n            }\n            inertiaAsMesh.thinInstanceBufferUpdated(\"matrix\");\n        }\n        else {\n            const props = body.getMassProperties();\n            this._getMeshDebugInertiaMatrixToRef(props, inertiaMatrixRef);\n            body.transformNode.rotationQuaternion?.toRotationMatrix(transformMatrixRef);\n            transformMatrixRef.setTranslation(body.transformNode.position);\n            if (body.transformNode.parent) {\n                const parentTransform = body.transformNode.parent.computeWorldMatrix(true);\n                transformMatrixRef.multiplyToRef(parentTransform, transformMatrixRef);\n            }\n            inertiaMatrixRef.multiplyToRef(transformMatrixRef, inertiaMatrixRef);\n            inertiaMatrixRef.decomposeToTransformNode(inertiaMesh);\n        }\n    }\n    _updateDebugConstraints() {\n        for (let i = 0; i < this._numConstraints; i++) {\n            const constraint = this._constraints[i];\n            const mesh = this._constraintMeshes[i];\n            if (constraint && mesh) {\n                this._updateDebugConstraint(constraint, mesh[0]);\n            }\n        }\n    }\n    /**\n     * Given a scaling vector, make all of its components\n     * 1, preserving the sign\n     * @param scaling\n     */\n    _makeScalingUnitInPlace(scaling) {\n        if (Math.abs(scaling.x - 1) > Epsilon) {\n            scaling.x = 1 * Math.sign(scaling.x);\n        }\n        if (Math.abs(scaling.y - 1) > Epsilon) {\n            scaling.y = 1 * Math.sign(scaling.y);\n        }\n        if (Math.abs(scaling.z - 1) > Epsilon) {\n            scaling.z = 1 * Math.sign(scaling.z);\n        }\n    }\n    _updateDebugConstraint(constraint, parentingMesh) {\n        if (!constraint._initOptions) {\n            return;\n        }\n        // Get constraint pivot and axes\n        const { pivotA, pivotB, axisA, axisB, perpAxisA, perpAxisB } = constraint._initOptions;\n        if (!pivotA || !pivotB || !axisA || !axisB || !perpAxisA || !perpAxisB) {\n            return;\n        }\n        parentingMesh.getDescendants(true).forEach((parentConstraintMesh) => {\n            // Get the parent transform\n            const parentCoordSystemNode = parentConstraintMesh.getDescendants(true)[0];\n            const childCoordSystemNode = parentConstraintMesh.getDescendants(true)[1];\n            const { parentBody, parentBodyIndex } = parentCoordSystemNode.metadata;\n            const { childBody, childBodyIndex } = childCoordSystemNode.metadata;\n            const parentTransform = this._getTransformFromBodyToRef(parentBody, TmpVectors.Matrix[0], parentBodyIndex);\n            const childTransform = this._getTransformFromBodyToRef(childBody, TmpVectors.Matrix[1], childBodyIndex);\n            parentTransform.decomposeToTransformNode(parentCoordSystemNode);\n            this._makeScalingUnitInPlace(parentCoordSystemNode.scaling);\n            childTransform.decomposeToTransformNode(childCoordSystemNode);\n            this._makeScalingUnitInPlace(childCoordSystemNode.scaling);\n            // Create a transform node and set its matrix\n            const parentTransformNode = parentCoordSystemNode.getDescendants(true)[0];\n            parentTransformNode.position.copyFrom(pivotA);\n            const childTransformNode = childCoordSystemNode.getDescendants(true)[0];\n            childTransformNode.position.copyFrom(pivotB);\n            // Get the transform to align the XYZ axes to the constraint axes\n            Quaternion.FromRotationMatrixToRef(Matrix.FromXYZAxesToRef(axisA, perpAxisA, Vector3.CrossToRef(axisA, perpAxisA, TmpVectors.Vector3[0]), TmpVectors.Matrix[0]), parentTransformNode.rotationQuaternion);\n            Quaternion.FromRotationMatrixToRef(Matrix.FromXYZAxesToRef(axisB, perpAxisB, Vector3.CrossToRef(axisB, perpAxisB, TmpVectors.Vector3[1]), TmpVectors.Matrix[1]), childTransformNode.rotationQuaternion);\n        });\n    }\n    /**\n     * Renders a specified physic impostor\n     * @param impostor defines the impostor to render\n     * @param targetMesh defines the mesh represented by the impostor\n     * @returns the new debug mesh used to render the impostor\n     */\n    showImpostor(impostor, targetMesh) {\n        if (!this._scene) {\n            return null;\n        }\n        for (let i = 0; i < this._numMeshes; i++) {\n            if (this._impostors[i] == impostor) {\n                return null;\n            }\n        }\n        const debugMesh = this._getDebugMesh(impostor, targetMesh);\n        if (debugMesh) {\n            this._impostors[this._numMeshes] = impostor;\n            this._meshes[this._numMeshes] = debugMesh;\n            if (this._numMeshes === 0) {\n                this._renderFunction = () => this._updateDebugMeshes();\n                this._scene.registerBeforeRender(this._renderFunction);\n            }\n            this._numMeshes++;\n        }\n        return debugMesh;\n    }\n    /**\n     * Shows a debug mesh for a given physics body.\n     * @param body The physics body to show.\n     * @returns The debug mesh, or null if the body is already shown.\n     *\n     * This function is useful for visualizing the physics body in the scene.\n     * It creates a debug mesh for the given body and adds it to the scene.\n     * It also registers a before render function to update the debug mesh position and rotation.\n     */\n    showBody(body) {\n        if (!this._scene) {\n            return null;\n        }\n        for (let i = 0; i < this._numBodies; i++) {\n            if (this._bodies[i] == body) {\n                return null;\n            }\n        }\n        const debugMesh = this._getDebugBodyMesh(body);\n        if (debugMesh) {\n            this._bodies[this._numBodies] = body;\n            this._bodyMeshes[this._numBodies] = debugMesh;\n            if (this._numBodies === 0) {\n                this._renderFunction = () => this._updateDebugMeshes();\n                this._scene.registerBeforeRender(this._renderFunction);\n            }\n            this._numBodies++;\n        }\n        return debugMesh;\n    }\n    /**\n     * Shows a debug box corresponding to the inertia of a given body\n     * @param body the physics body used to get the inertia\n     * @returns the debug mesh used to show the inertia, or null if the body is already shown\n     */\n    showInertia(body) {\n        if (!this._scene) {\n            return null;\n        }\n        for (let i = 0; i < this._numInertiaBodies; i++) {\n            if (this._inertiaBodies[i] == body) {\n                return null;\n            }\n        }\n        const debugMesh = this._getDebugInertiaMesh(body);\n        if (debugMesh) {\n            this._inertiaBodies[this._numInertiaBodies] = body;\n            this._inertiaMeshes[this._numInertiaBodies] = debugMesh;\n            if (this._numInertiaBodies === 0) {\n                this._inertiaRenderFunction = () => this._updateInertiaMeshes();\n                this._scene.registerBeforeRender(this._inertiaRenderFunction);\n            }\n            this._numInertiaBodies++;\n        }\n        return debugMesh;\n    }\n    /**\n     * Shows a debug mesh for a given physics constraint.\n     * @param constraint the physics constraint to show\n     * @returns the debug mesh, or null if the constraint is already shown\n     */\n    showConstraint(constraint) {\n        if (!this._scene) {\n            return null;\n        }\n        for (let i = 0; i < this._numConstraints; i++) {\n            if (this._constraints[i] == constraint) {\n                return null;\n            }\n        }\n        const debugMesh = this._getDebugConstraintMesh(constraint);\n        if (debugMesh) {\n            this._constraints[this._numConstraints] = constraint;\n            this._constraintMeshes[this._numConstraints] = debugMesh;\n            if (this._numConstraints === 0) {\n                this._constraintRenderFunction = () => this._updateDebugConstraints();\n                this._scene.registerBeforeRender(this._constraintRenderFunction);\n            }\n            this._numConstraints++;\n        }\n        return debugMesh ? debugMesh[0] : null;\n    }\n    /**\n     * Hides an impostor from the scene.\n     * @param impostor - The impostor to hide.\n     *\n     * This method is useful for hiding an impostor from the scene. It removes the\n     * impostor from the utility layer scene, disposes the mesh, and removes the\n     * impostor from the list of impostors. If the impostor is the last one in the\n     * list, it also unregisters the render function.\n     */\n    hideImpostor(impostor) {\n        if (!impostor || !this._scene || !this._utilityLayer) {\n            return;\n        }\n        let removed = false;\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n        for (let i = 0; i < this._numMeshes; i++) {\n            if (this._impostors[i] == impostor) {\n                const mesh = this._meshes[i];\n                if (!mesh) {\n                    continue;\n                }\n                utilityLayerScene.removeMesh(mesh);\n                mesh.dispose();\n                const index = this._debugMeshMeshes.indexOf(mesh);\n                if (index > -1) {\n                    this._debugMeshMeshes.splice(index, 1);\n                }\n                this._numMeshes--;\n                if (this._numMeshes > 0) {\n                    this._meshes[i] = this._meshes[this._numMeshes];\n                    this._impostors[i] = this._impostors[this._numMeshes];\n                    this._meshes[this._numMeshes] = null;\n                    this._impostors[this._numMeshes] = null;\n                }\n                else {\n                    this._meshes[0] = null;\n                    this._impostors[0] = null;\n                }\n                removed = true;\n                break;\n            }\n        }\n        if (removed && this._numMeshes === 0) {\n            this._scene.unregisterBeforeRender(this._renderFunction);\n        }\n    }\n    /**\n     * Hides a body from the physics engine.\n     * @param body - The body to hide.\n     * @returns true if body actually removed\n     *\n     * This function is useful for hiding a body from the physics engine.\n     * It removes the body from the utility layer scene and disposes the mesh associated with it.\n     * It also unregisters the render function if the number of bodies is 0.\n     * This is useful for hiding a body from the physics engine without deleting it.\n     */\n    hideBody(body) {\n        if (!body || !this._scene || !this._utilityLayer) {\n            return false;\n        }\n        let removed = false;\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n        for (let i = 0; i < this._numBodies; i++) {\n            if (this._bodies[i] === body) {\n                const mesh = this._bodyMeshes[i];\n                if (!mesh) {\n                    continue;\n                }\n                utilityLayerScene.removeMesh(mesh);\n                mesh.dispose();\n                this._numBodies--;\n                if (this._numBodies > 0) {\n                    this._bodyMeshes[i] = this._bodyMeshes[this._numBodies];\n                    this._bodies[i] = this._bodies[this._numBodies];\n                    this._bodyMeshes[this._numBodies] = null;\n                    this._bodies[this._numBodies] = null;\n                }\n                else {\n                    this._bodyMeshes[0] = null;\n                    this._bodies[0] = null;\n                }\n                removed = true;\n                break;\n            }\n        }\n        if (removed && this._numBodies === 0) {\n            this._scene.unregisterBeforeRender(this._renderFunction);\n        }\n        return removed;\n    }\n    /**\n     * Hides a body's inertia from the viewer utility layer\n     * @param body the body to hide\n     * @returns true if inertia actually removed\n     */\n    hideInertia(body) {\n        if (!body || !this._scene || !this._utilityLayer) {\n            return false;\n        }\n        let removed = false;\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n        for (let i = 0; i < this._numInertiaBodies; i++) {\n            if (this._inertiaBodies[i] === body) {\n                const mesh = this._inertiaMeshes[i];\n                if (!mesh) {\n                    continue;\n                }\n                utilityLayerScene.removeMesh(mesh);\n                mesh.dispose();\n                this._inertiaBodies.splice(i, 1);\n                this._inertiaMeshes.splice(i, 1);\n                this._numInertiaBodies--;\n                removed = true;\n                break;\n            }\n        }\n        if (removed && this._numInertiaBodies === 0) {\n            this._scene.unregisterBeforeRender(this._inertiaRenderFunction);\n        }\n        return removed;\n    }\n    /**\n     * Hide a physics constraint from the viewer utility layer\n     * @param constraint the constraint to hide\n     */\n    hideConstraint(constraint) {\n        if (!constraint || !this._scene || !this._utilityLayer) {\n            return;\n        }\n        let removed = false;\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n        for (let i = 0; i < this._numConstraints; i++) {\n            if (this._constraints[i] === constraint) {\n                const meshes = this._constraintMeshes[i];\n                if (!meshes) {\n                    continue;\n                }\n                meshes.forEach((mesh) => {\n                    utilityLayerScene.removeMesh(mesh);\n                    mesh.dispose();\n                });\n                this._constraints.splice(i, 1);\n                this._constraintMeshes.splice(i, 1);\n                this._numConstraints--;\n                if (this._numConstraints > 0) {\n                    this._constraints[i] = this._constraints[this._numConstraints];\n                    this._constraintMeshes[i] = this._constraintMeshes[this._numConstraints];\n                    this._constraints[this._numConstraints] = null;\n                    this._constraintMeshes[this._numConstraints] = null;\n                }\n                else {\n                    this._constraints[0] = null;\n                    this._constraintMeshes[0] = null;\n                }\n                removed = true;\n                break;\n            }\n        }\n        if (removed && this._numConstraints === 0) {\n            this._scene.unregisterBeforeRender(this._constraintRenderFunction);\n        }\n    }\n    _getDebugMaterial(scene) {\n        if (!this._debugMaterial) {\n            this._debugMaterial = new StandardMaterial(\"\", scene);\n            this._debugMaterial.wireframe = true;\n            this._debugMaterial.emissiveColor = Color3.White();\n            this._debugMaterial.disableLighting = true;\n        }\n        return this._debugMaterial;\n    }\n    _getDebugInertiaMaterial(scene) {\n        if (!this._debugInertiaMaterial) {\n            this._debugInertiaMaterial = new StandardMaterial(\"\", scene);\n            this._debugInertiaMaterial.disableLighting = true;\n            this._debugInertiaMaterial.alpha = 0.0;\n        }\n        return this._debugInertiaMaterial;\n    }\n    _getDebugAxisColoredMaterial(axisNumber, scene) {\n        const material = new StandardMaterial(\"\", scene);\n        material.emissiveColor = axisNumber == 0 ? Color3.Red() : axisNumber == 1 ? Color3.Green() : Color3.Blue();\n        material.disableLighting = true;\n        return material;\n    }\n    _getDebugBoxMesh(scene) {\n        if (!this._debugBoxMesh) {\n            this._debugBoxMesh = CreateBox(\"physicsBodyBoxViewMesh\", { size: 1 }, scene);\n            this._debugBoxMesh.rotationQuaternion = Quaternion.Identity();\n            this._debugBoxMesh.material = this._getDebugMaterial(scene);\n            this._debugBoxMesh.setEnabled(false);\n        }\n        return this._debugBoxMesh.createInstance(\"physicsBodyBoxViewInstance\");\n    }\n    _getDebugSphereMesh(scene) {\n        if (!this._debugSphereMesh) {\n            this._debugSphereMesh = CreateSphere(\"physicsBodySphereViewMesh\", { diameter: 1 }, scene);\n            this._debugSphereMesh.rotationQuaternion = Quaternion.Identity();\n            this._debugSphereMesh.material = this._getDebugMaterial(scene);\n            this._debugSphereMesh.setEnabled(false);\n        }\n        return this._debugSphereMesh.createInstance(\"physicsBodySphereViewInstance\");\n    }\n    _getDebugCapsuleMesh(scene) {\n        if (!this._debugCapsuleMesh) {\n            this._debugCapsuleMesh = CreateCapsule(\"physicsBodyCapsuleViewMesh\", { height: 1 }, scene);\n            this._debugCapsuleMesh.rotationQuaternion = Quaternion.Identity();\n            this._debugCapsuleMesh.material = this._getDebugMaterial(scene);\n            this._debugCapsuleMesh.setEnabled(false);\n        }\n        return this._debugCapsuleMesh.createInstance(\"physicsBodyCapsuleViewInstance\");\n    }\n    _getDebugCylinderMesh(scene) {\n        if (!this._debugCylinderMesh) {\n            this._debugCylinderMesh = CreateCylinder(\"physicsBodyCylinderViewMesh\", { diameterTop: 1, diameterBottom: 1, height: 1 }, scene);\n            this._debugCylinderMesh.rotationQuaternion = Quaternion.Identity();\n            this._debugCylinderMesh.material = this._getDebugMaterial(scene);\n            this._debugCylinderMesh.setEnabled(false);\n        }\n        return this._debugCylinderMesh.createInstance(\"physicsBodyCylinderViewInstance\");\n    }\n    _getDebugMeshMesh(mesh, scene) {\n        const wireframeOver = new Mesh(mesh.name, scene, null, mesh);\n        wireframeOver.setParent(mesh);\n        wireframeOver.position = Vector3.Zero();\n        wireframeOver.material = this._getDebugMaterial(scene);\n        this._debugMeshMeshes.push(wireframeOver);\n        return wireframeOver;\n    }\n    _getDebugMesh(impostor, targetMesh) {\n        if (!this._utilityLayer) {\n            return null;\n        }\n        // Only create child impostor debug meshes when evaluating the parent\n        if (targetMesh && targetMesh.parent && targetMesh.parent.physicsImpostor) {\n            return null;\n        }\n        let mesh = null;\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n        if (!impostor.physicsBody) {\n            Logger.Warn(\"Unable to get physicsBody of impostor. It might be initialized later by its parent's impostor.\");\n            return null;\n        }\n        switch (impostor.type) {\n            case PhysicsImpostor.BoxImpostor:\n                mesh = this._getDebugBoxMesh(utilityLayerScene);\n                impostor.getBoxSizeToRef(mesh.scaling);\n                break;\n            case PhysicsImpostor.SphereImpostor: {\n                mesh = this._getDebugSphereMesh(utilityLayerScene);\n                const radius = impostor.getRadius();\n                mesh.scaling.x = radius * 2;\n                mesh.scaling.y = radius * 2;\n                mesh.scaling.z = radius * 2;\n                break;\n            }\n            case PhysicsImpostor.CapsuleImpostor: {\n                mesh = this._getDebugCapsuleMesh(utilityLayerScene);\n                const bi = impostor.object.getBoundingInfo();\n                mesh.scaling.x = (bi.boundingBox.maximum.x - bi.boundingBox.minimum.x) * 2 * impostor.object.scaling.x;\n                mesh.scaling.y = (bi.boundingBox.maximum.y - bi.boundingBox.minimum.y) * impostor.object.scaling.y;\n                mesh.scaling.z = (bi.boundingBox.maximum.z - bi.boundingBox.minimum.z) * 2 * impostor.object.scaling.z;\n                break;\n            }\n            case PhysicsImpostor.MeshImpostor:\n                if (targetMesh) {\n                    mesh = this._getDebugMeshMesh(targetMesh, utilityLayerScene);\n                }\n                break;\n            case PhysicsImpostor.NoImpostor:\n                if (targetMesh) {\n                    // Handle compound impostors\n                    const childMeshes = targetMesh.getChildMeshes().filter((c) => {\n                        return c.physicsImpostor ? 1 : 0;\n                    });\n                    childMeshes.forEach((m) => {\n                        if (m.physicsImpostor && m.getClassName() === \"Mesh\") {\n                            const boundingInfo = m.getBoundingInfo();\n                            const min = boundingInfo.boundingBox.minimum;\n                            const max = boundingInfo.boundingBox.maximum;\n                            switch (m.physicsImpostor.type) {\n                                case PhysicsImpostor.BoxImpostor:\n                                    mesh = this._getDebugBoxMesh(utilityLayerScene);\n                                    mesh.position.copyFrom(min);\n                                    mesh.position.addInPlace(max);\n                                    mesh.position.scaleInPlace(0.5);\n                                    break;\n                                case PhysicsImpostor.SphereImpostor:\n                                    mesh = this._getDebugSphereMesh(utilityLayerScene);\n                                    break;\n                                case PhysicsImpostor.CylinderImpostor:\n                                    mesh = this._getDebugCylinderMesh(utilityLayerScene);\n                                    break;\n                                default:\n                                    mesh = null;\n                                    break;\n                            }\n                            if (mesh) {\n                                mesh.scaling.x = max.x - min.x;\n                                mesh.scaling.y = max.y - min.y;\n                                mesh.scaling.z = max.z - min.z;\n                                mesh.parent = m;\n                            }\n                        }\n                    });\n                }\n                else {\n                    Logger.Warn(\"No target mesh parameter provided for NoImpostor. Skipping.\");\n                }\n                mesh = null;\n                break;\n            case PhysicsImpostor.CylinderImpostor: {\n                mesh = this._getDebugCylinderMesh(utilityLayerScene);\n                const bi = impostor.object.getBoundingInfo();\n                mesh.scaling.x = (bi.boundingBox.maximum.x - bi.boundingBox.minimum.x) * impostor.object.scaling.x;\n                mesh.scaling.y = (bi.boundingBox.maximum.y - bi.boundingBox.minimum.y) * impostor.object.scaling.y;\n                mesh.scaling.z = (bi.boundingBox.maximum.z - bi.boundingBox.minimum.z) * impostor.object.scaling.z;\n                break;\n            }\n        }\n        return mesh;\n    }\n    /**\n     * Creates a debug mesh for a given physics body\n     * @param body The physics body to create the debug mesh for\n     * @returns The created debug mesh or null if the utility layer is not available\n     *\n     * This code is useful for creating a debug mesh for a given physics body.\n     * It creates a Mesh object with a VertexData object containing the positions and indices\n     * of the geometry of the body. The mesh is then assigned a debug material from the utility layer scene.\n     * This allows for visualizing the physics body in the scene.\n     */\n    _getDebugBodyMesh(body) {\n        if (!this._utilityLayer) {\n            return null;\n        }\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n        const mesh = new Mesh(\"custom\", utilityLayerScene);\n        const vertexData = new VertexData();\n        const geometry = body.getGeometry();\n        vertexData.positions = geometry.positions;\n        vertexData.indices = geometry.indices;\n        vertexData.applyToMesh(mesh);\n        if (body._pluginDataInstances) {\n            const instanceBuffer = new Float32Array(body._pluginDataInstances.length * 16);\n            mesh.thinInstanceSetBuffer(\"matrix\", instanceBuffer, 16, false);\n        }\n        mesh.material = this._getDebugMaterial(utilityLayerScene);\n        return mesh;\n    }\n    _getMeshDebugInertiaMatrixToRef(massProps, matrix) {\n        const orientation = massProps.inertiaOrientation ?? Quaternion.Identity();\n        const inertiaLocal = massProps.inertia ?? Vector3.Zero();\n        const center = massProps.centerOfMass ?? Vector3.Zero();\n        const betaSqrd = (inertiaLocal.x - inertiaLocal.y + inertiaLocal.z) * 6;\n        const beta = Math.sqrt(Math.max(betaSqrd, 0)); // Safety check for zeroed elements!\n        const gammaSqrd = inertiaLocal.x * 12 - betaSqrd;\n        const gamma = Math.sqrt(Math.max(gammaSqrd, 0)); // Safety check for zeroed elements!\n        const alphaSqrd = inertiaLocal.z * 12 - betaSqrd;\n        const alpha = Math.sqrt(Math.max(alphaSqrd, 0)); // Safety check for zeroed elements!\n        const extents = TmpVectors.Vector3[0];\n        extents.set(alpha, beta, gamma);\n        const scaling = Matrix.ScalingToRef(extents.x, extents.y, extents.z, TmpVectors.Matrix[0]);\n        const rotation = orientation.toRotationMatrix(TmpVectors.Matrix[1]);\n        const translation = Matrix.TranslationToRef(center.x, center.y, center.z, TmpVectors.Matrix[2]);\n        scaling.multiplyToRef(rotation, matrix);\n        matrix.multiplyToRef(translation, matrix);\n        return matrix;\n    }\n    _getDebugInertiaMesh(body) {\n        if (!this._utilityLayer) {\n            return null;\n        }\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n        // The base inertia mesh is going to be a 1x1 cube that's scaled and rotated according to the inertia\n        const inertiaBoxMesh = MeshBuilder.CreateBox(\"custom\", { size: 1 }, utilityLayerScene);\n        const matrixRef = Matrix.Identity();\n        if (body._pluginDataInstances.length) {\n            const instanceBuffer = new Float32Array(body._pluginDataInstances.length * 16);\n            for (let i = 0; i < body._pluginDataInstances.length; ++i) {\n                const props = body.getMassProperties(i);\n                this._getMeshDebugInertiaMatrixToRef(props, matrixRef);\n                matrixRef.copyToArray(instanceBuffer, i * 16);\n            }\n            inertiaBoxMesh.thinInstanceSetBuffer(\"matrix\", instanceBuffer, 16, false);\n        }\n        else {\n            const props = body.getMassProperties();\n            this._getMeshDebugInertiaMatrixToRef(props, matrixRef);\n            matrixRef.decomposeToTransformNode(inertiaBoxMesh);\n        }\n        inertiaBoxMesh.enableEdgesRendering();\n        inertiaBoxMesh.edgesWidth = 2.0;\n        inertiaBoxMesh.edgesColor = new Color4(1, 0, 1, 1);\n        inertiaBoxMesh.material = this._getDebugInertiaMaterial(utilityLayerScene);\n        return inertiaBoxMesh;\n    }\n    _getTransformFromBodyToRef(body, matrix, instanceIndex) {\n        const tnode = body.transformNode;\n        if (instanceIndex && instanceIndex >= 0) {\n            return Matrix.FromArrayToRef(tnode._thinInstanceDataStorage.matrixData, instanceIndex, matrix);\n        }\n        else {\n            return matrix.copyFrom(tnode.getWorldMatrix());\n        }\n    }\n    _createAngularConstraintMesh(minLimit, maxLimit, axisNumber, parent, scene) {\n        const arcAngle = (maxLimit - minLimit) / (Math.PI * 2);\n        const mesh = MeshBuilder.CreateCylinder(\"ConstraintCylinder\", { height: 0.0001, diameter: 3 * this._constraintAngularSize, arc: arcAngle }, scene);\n        mesh.material = this._getDebugAxisColoredMaterial(axisNumber, scene);\n        mesh.parent = parent;\n        const parentScaling = parent.absoluteScaling;\n        switch (axisNumber) {\n            case 0:\n                mesh.rotation.z = Math.PI * 0.5;\n                mesh.rotation.x = -minLimit + Math.PI * 0.5;\n                // scaling on y,z\n                mesh.scaling.x = 1 / parentScaling.x;\n                mesh.scaling.y = 1 / parentScaling.z;\n                mesh.scaling.z = 1 / parentScaling.y;\n                break;\n            case 1:\n                mesh.rotation.y = Math.PI * 1.5 + minLimit;\n                // flip x,z\n                mesh.scaling.x = 1 / parentScaling.z;\n                mesh.scaling.y = 1 / parentScaling.y;\n                mesh.scaling.z = 1 / parentScaling.x;\n                break;\n            case 2:\n                mesh.rotation.x = Math.PI * 0.5;\n                // flip z,y\n                mesh.scaling.x = 1 / parentScaling.x;\n                mesh.scaling.y = 1 / parentScaling.z;\n                mesh.scaling.z = 1 / parentScaling.y;\n                break;\n        }\n        return mesh;\n    }\n    _createCage(parent, scene) {\n        const cage = MeshBuilder.CreateBox(\"cage\", { size: 1 }, scene);\n        cage.setPivotPoint(new Vector3(-0.5, -0.5, -0.5));\n        const transparentMaterial = new StandardMaterial(\"cage_material\", scene);\n        transparentMaterial.alpha = 0; // Fully transparent\n        cage.material = transparentMaterial;\n        cage.enableEdgesRendering();\n        cage.edgesWidth = 4.0;\n        cage.edgesColor = new Color4(1, 1, 1, 1);\n        cage.parent = parent;\n        return cage;\n    }\n    _getDebugConstraintMesh(constraint) {\n        if (!this._utilityLayer) {\n            return null;\n        }\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n        if (!constraint._initOptions) {\n            return null;\n        }\n        // Get constraint pivot and axes\n        const { pivotA, pivotB, axisA, axisB, perpAxisA, perpAxisB } = constraint._initOptions;\n        if (!pivotA || !pivotB || !axisA || !axisB || !perpAxisA || !perpAxisB) {\n            return null;\n        }\n        // Create a mesh to parent all the constraint debug meshes to\n        const parentingMesh = new Mesh(\"parentingDebugConstraint\", utilityLayerScene);\n        // First, get a reference to all physic bodies that are using this constraint\n        const bodiesUsingConstraint = constraint.getBodiesUsingConstraint();\n        const parentedConstraintMeshes = [];\n        parentedConstraintMeshes.push(parentingMesh);\n        for (const bodyPairInfo of bodiesUsingConstraint) {\n            // Create a mesh to keep the pair of constraint axes\n            const parentOfPair = new TransformNode(\"parentOfPair\", utilityLayerScene);\n            parentOfPair.parent = parentingMesh;\n            const { parentBody, parentBodyIndex, childBody, childBodyIndex } = bodyPairInfo;\n            // Get the parent transform\n            const parentTransform = this._getTransformFromBodyToRef(parentBody, TmpVectors.Matrix[0], parentBodyIndex);\n            const childTransform = this._getTransformFromBodyToRef(childBody, TmpVectors.Matrix[1], childBodyIndex);\n            const parentCoordSystemNode = new TransformNode(\"parentCoordSystem\", utilityLayerScene);\n            // parentCoordSystemNode.parent = parentingMesh;\n            parentCoordSystemNode.parent = parentOfPair;\n            // Save parent and index here to be able to get the transform on update\n            parentCoordSystemNode.metadata = { parentBody, parentBodyIndex };\n            parentTransform.decomposeToTransformNode(parentCoordSystemNode);\n            const childCoordSystemNode = new TransformNode(\"childCoordSystem\", utilityLayerScene);\n            // childCoordSystemNode.parent = parentingMesh;\n            childCoordSystemNode.parent = parentOfPair;\n            // Save child and index here to be able to get the transform on update\n            childCoordSystemNode.metadata = { childBody, childBodyIndex };\n            childTransform.decomposeToTransformNode(childCoordSystemNode);\n            // Get the transform to align the XYZ axes to the constraint axes\n            const rotTransformParent = Quaternion.FromRotationMatrix(Matrix.FromXYZAxesToRef(axisA, perpAxisA, axisA.cross(perpAxisA), TmpVectors.Matrix[0]));\n            const rotTransformChild = Quaternion.FromRotationMatrix(Matrix.FromXYZAxesToRef(axisB, perpAxisB, axisB.cross(perpAxisB), TmpVectors.Matrix[0]));\n            const translateTransformParent = pivotA;\n            const translateTransformChild = pivotB;\n            // Create a transform node and set its matrix\n            const parentTransformNode = new TransformNode(\"constraint_parent\", utilityLayerScene);\n            parentTransformNode.position.copyFrom(translateTransformParent);\n            parentTransformNode.rotationQuaternion = rotTransformParent;\n            parentTransformNode.parent = parentCoordSystemNode;\n            const childTransformNode = new TransformNode(\"constraint_child\", utilityLayerScene);\n            childTransformNode.parent = childCoordSystemNode;\n            childTransformNode.position.copyFrom(translateTransformChild);\n            childTransformNode.rotationQuaternion = rotTransformChild;\n            // Create axes for the constraint\n            const parentAxes = new AxesViewer(utilityLayerScene, this._constraintAxesSize);\n            parentAxes.xAxis.parent = parentTransformNode;\n            parentAxes.yAxis.parent = parentTransformNode;\n            parentAxes.zAxis.parent = parentTransformNode;\n            const childAxes = new AxesViewer(utilityLayerScene, this._constraintAxesSize);\n            childAxes.xAxis.parent = childTransformNode;\n            childAxes.yAxis.parent = childTransformNode;\n            childAxes.zAxis.parent = childTransformNode;\n            // constrain vis\n            const engine = this._physicsEnginePlugin;\n            const constraintAxisAngular = [3 /* PhysicsConstraintAxis.ANGULAR_X */, 4 /* PhysicsConstraintAxis.ANGULAR_Y */, 5 /* PhysicsConstraintAxis.ANGULAR_Z */];\n            const constraintAxisLinear = [0 /* PhysicsConstraintAxis.LINEAR_X */, 1 /* PhysicsConstraintAxis.LINEAR_Y */, 2 /* PhysicsConstraintAxis.LINEAR_Z */];\n            const constraintAxis = [constraintAxisAngular, constraintAxisLinear];\n            // count axis. Angular and Linear\n            const lockCount = [0, 0];\n            for (let angularLinear = 0; angularLinear < 2; angularLinear++) {\n                for (let axis = 0; axis < 3; axis++) {\n                    const constraintAxisValue = constraintAxis[angularLinear][axis];\n                    const axisMode = engine.getAxisMode(constraint, constraintAxisValue);\n                    if (axisMode == 2 /* PhysicsConstraintAxisLimitMode.LOCKED */) {\n                        lockCount[angularLinear]++;\n                    }\n                }\n            }\n            // Any free/limited Linear axis\n            if (lockCount[1] != 3) {\n                const cage = this._createCage(parentTransformNode, utilityLayerScene);\n                const min = TmpVectors.Vector3[0];\n                const max = TmpVectors.Vector3[1];\n                const limited = [false, false, false];\n                limited[0] = engine.getAxisMode(constraint, 0 /* PhysicsConstraintAxis.LINEAR_X */) == 1 /* PhysicsConstraintAxisLimitMode.LIMITED */;\n                limited[1] = engine.getAxisMode(constraint, 1 /* PhysicsConstraintAxis.LINEAR_Y */) == 1 /* PhysicsConstraintAxisLimitMode.LIMITED */;\n                limited[2] = engine.getAxisMode(constraint, 2 /* PhysicsConstraintAxis.LINEAR_Z */) == 1 /* PhysicsConstraintAxisLimitMode.LIMITED */;\n                min.x = limited[0] ? engine.getAxisMinLimit(constraint, 0 /* PhysicsConstraintAxis.LINEAR_X */) : 0;\n                max.x = limited[0] ? engine.getAxisMaxLimit(constraint, 0 /* PhysicsConstraintAxis.LINEAR_X */) : 0;\n                min.y = limited[1] ? engine.getAxisMinLimit(constraint, 1 /* PhysicsConstraintAxis.LINEAR_Y */) : 0;\n                max.y = limited[1] ? engine.getAxisMaxLimit(constraint, 1 /* PhysicsConstraintAxis.LINEAR_Y */) : 0;\n                min.z = limited[2] ? engine.getAxisMinLimit(constraint, 2 /* PhysicsConstraintAxis.LINEAR_Z */) : 0;\n                max.z = limited[2] ? engine.getAxisMaxLimit(constraint, 2 /* PhysicsConstraintAxis.LINEAR_Z */) : 0;\n                cage.position.x = min.x + 0.5;\n                cage.position.y = min.y + 0.5;\n                cage.position.z = min.z + 0.5;\n                cage.scaling.x = max.x - min.x + Epsilon;\n                cage.scaling.y = max.y - min.y + Epsilon;\n                cage.scaling.z = max.z - min.z + Epsilon;\n                parentedConstraintMeshes.push(cage);\n            }\n            // Angular\n            if (lockCount[0] != 3) {\n                for (let axisIndex = 0; axisIndex < 3; axisIndex++) {\n                    const axis = constraintAxisAngular[axisIndex];\n                    const axisMode = engine.getAxisMode(constraint, axis);\n                    let minLimit = 0;\n                    let maxLimit = Math.PI * 2;\n                    if (axisMode == 1 /* PhysicsConstraintAxisLimitMode.LIMITED */) {\n                        minLimit = engine.getAxisMinLimit(constraint, axis);\n                        maxLimit = engine.getAxisMaxLimit(constraint, axis);\n                    }\n                    if (axisMode != 2 /* PhysicsConstraintAxisLimitMode.LOCKED */ && constraint.options.pivotB) {\n                        const mesh = this._createAngularConstraintMesh(minLimit, maxLimit, axisIndex, childBody.transformNode, utilityLayerScene);\n                        mesh.position.copyFrom(constraint.options.pivotB);\n                        parentedConstraintMeshes.push(mesh);\n                    }\n                }\n            }\n        }\n        return parentedConstraintMeshes;\n    }\n    /**\n     * Clean up physics debug display\n     */\n    dispose() {\n        // impostors\n        for (let index = this._numMeshes - 1; index >= 0; index--) {\n            this.hideImpostor(this._impostors[0]);\n        }\n        // bodies\n        for (let index = this._numBodies - 1; index >= 0; index--) {\n            this.hideBody(this._bodies[0]);\n        }\n        // inertia\n        for (let index = this._numInertiaBodies - 1; index >= 0; index--) {\n            this.hideInertia(this._inertiaBodies[0]);\n        }\n        if (this._debugBoxMesh) {\n            this._debugBoxMesh.dispose();\n        }\n        if (this._debugSphereMesh) {\n            this._debugSphereMesh.dispose();\n        }\n        if (this._debugCylinderMesh) {\n            this._debugCylinderMesh.dispose();\n        }\n        if (this._debugMaterial) {\n            this._debugMaterial.dispose();\n        }\n        this._impostors.length = 0;\n        this._scene = null;\n        this._physicsEnginePlugin = null;\n        if (this._utilityLayer) {\n            this._utilityLayer.dispose();\n            this._utilityLayer = null;\n        }\n    }\n}\n//# sourceMappingURL=physicsViewer.js.map","import { Vector3 } from \"../Maths/math.vector.js\";\nimport { CreateLines } from \"../Meshes/Builders/linesBuilder.js\";\n/**\n * As raycast might be hard to debug, the RayHelper can help rendering the different rays\n * in order to better appreciate the issue one might have.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/picking_collisions#debugging\n */\nexport class RayHelper {\n    /**\n     * Helper function to create a colored helper in a scene in one line.\n     * @param ray Defines the ray we are currently trying to visualize\n     * @param scene Defines the scene the ray is used in\n     * @param color Defines the color we want to see the ray in\n     * @returns The newly created ray helper.\n     */\n    static CreateAndShow(ray, scene, color) {\n        const helper = new RayHelper(ray);\n        helper.show(scene, color);\n        return helper;\n    }\n    /**\n     * Instantiate a new ray helper.\n     * As raycast might be hard to debug, the RayHelper can help rendering the different rays\n     * in order to better appreciate the issue one might have.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/picking_collisions#debugging\n     * @param ray Defines the ray we are currently trying to visualize\n     */\n    constructor(ray) {\n        this.ray = ray;\n    }\n    /**\n     * Shows the ray we are willing to debug.\n     * @param scene Defines the scene the ray needs to be rendered in\n     * @param color Defines the color the ray needs to be rendered in\n     */\n    show(scene, color) {\n        if (!this._renderFunction && this.ray) {\n            const ray = this.ray;\n            this._renderFunction = () => this._render();\n            this._scene = scene;\n            this._renderPoints = [ray.origin, ray.origin.add(ray.direction.scale(ray.length))];\n            this._renderLine = CreateLines(\"ray\", { points: this._renderPoints, updatable: true }, scene);\n            this._renderLine.isPickable = false;\n            if (this._renderFunction) {\n                this._scene.registerBeforeRender(this._renderFunction);\n            }\n        }\n        if (color && this._renderLine) {\n            this._renderLine.color.copyFrom(color);\n        }\n    }\n    /**\n     * Hides the ray we are debugging.\n     */\n    hide() {\n        if (this._renderFunction && this._scene) {\n            this._scene.unregisterBeforeRender(this._renderFunction);\n            this._scene = null;\n            this._renderFunction = null;\n            if (this._renderLine) {\n                this._renderLine.dispose();\n                this._renderLine = null;\n            }\n            this._renderPoints = [];\n        }\n    }\n    _render() {\n        const ray = this.ray;\n        if (!ray) {\n            return;\n        }\n        const point = this._renderPoints[1];\n        const len = Math.min(ray.length, 1000000);\n        point.copyFrom(ray.direction);\n        point.scaleInPlace(len);\n        point.addInPlace(ray.origin);\n        this._renderPoints[0].copyFrom(ray.origin);\n        CreateLines(\"ray\", { points: this._renderPoints, updatable: true, instance: this._renderLine }, this._scene);\n        this._renderLine?.refreshBoundingInfo();\n    }\n    /**\n     * Attach a ray helper to a mesh so that we can easily see its orientation for instance or information like its normals.\n     * @param mesh Defines the mesh we want the helper attached to\n     * @param meshSpaceDirection Defines the direction of the Ray in mesh space (local space of the mesh node)\n     * @param meshSpaceOrigin Defines the origin of the Ray in mesh space (local space of the mesh node)\n     * @param length Defines the length of the ray\n     */\n    attachToMesh(mesh, meshSpaceDirection, meshSpaceOrigin, length) {\n        this._attachedToMesh = mesh;\n        const ray = this.ray;\n        if (!ray) {\n            return;\n        }\n        if (!ray.direction) {\n            ray.direction = Vector3.Zero();\n        }\n        if (!ray.origin) {\n            ray.origin = Vector3.Zero();\n        }\n        if (length) {\n            ray.length = length;\n        }\n        if (!meshSpaceOrigin) {\n            meshSpaceOrigin = Vector3.Zero();\n        }\n        if (!meshSpaceDirection) {\n            // -1 so that this will work with Mesh.lookAt\n            meshSpaceDirection = new Vector3(0, 0, -1);\n        }\n        if (!this._scene) {\n            this._scene = mesh.getScene();\n        }\n        if (!this._meshSpaceDirection) {\n            this._meshSpaceDirection = meshSpaceDirection.clone();\n            this._meshSpaceOrigin = meshSpaceOrigin.clone();\n        }\n        else {\n            this._meshSpaceDirection.copyFrom(meshSpaceDirection);\n            this._meshSpaceOrigin.copyFrom(meshSpaceOrigin);\n        }\n        if (!this._onAfterRenderObserver) {\n            this._onAfterRenderObserver = this._scene.onBeforeRenderObservable.add(() => this._updateToMesh());\n            this._onAfterStepObserver = this._scene.onAfterStepObservable.add(() => this._updateToMesh());\n        }\n        // force world matrix computation before the first ray helper computation\n        this._attachedToMesh.computeWorldMatrix(true);\n        this._updateToMesh();\n    }\n    /**\n     * Detach the ray helper from the mesh it has previously been attached to.\n     */\n    detachFromMesh() {\n        if (this._attachedToMesh && this._scene) {\n            if (this._onAfterRenderObserver) {\n                this._scene.onBeforeRenderObservable.remove(this._onAfterRenderObserver);\n                this._scene.onAfterStepObservable.remove(this._onAfterStepObserver);\n            }\n            this._attachedToMesh = null;\n            this._onAfterRenderObserver = null;\n            this._onAfterStepObserver = null;\n            this._scene = null;\n        }\n    }\n    _updateToMesh() {\n        const ray = this.ray;\n        if (!this._attachedToMesh || !ray) {\n            return;\n        }\n        if (this._attachedToMesh.isDisposed()) {\n            this.detachFromMesh();\n            return;\n        }\n        this._attachedToMesh.getDirectionToRef(this._meshSpaceDirection, ray.direction);\n        Vector3.TransformCoordinatesToRef(this._meshSpaceOrigin, this._attachedToMesh.getWorldMatrix(), ray.origin);\n    }\n    /**\n     * Dispose the helper and release its associated resources.\n     */\n    dispose() {\n        this.hide();\n        this.detachFromMesh();\n        this.ray = null;\n    }\n}\n//# sourceMappingURL=rayHelper.js.map","import { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Matrix, TmpVectors, Vector3 } from \"../Maths/math.vector.js\";\nimport { CreateLines } from \"../Meshes/Builders/linesBuilder.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\n\n/**\n * Class used to render a debug view of the frustum for a directional light\n * @see https://playground.babylonjs.com/#7EFGSG#4\n * @since 5.0.0\n */\nexport class DirectionalLightFrustumViewer {\n    /**\n     * Gets or sets the transparency of the frustum planes\n     */\n    get transparency() {\n        return this._transparency;\n    }\n    set transparency(alpha) {\n        this._transparency = alpha;\n        for (let i = 6; i < 12; ++i) {\n            this._lightHelperFrustumMeshes[i].material.alpha = alpha;\n        }\n    }\n    /**\n     * true to display the edges of the frustum\n     */\n    get showLines() {\n        return this._showLines;\n    }\n    set showLines(show) {\n        if (this._showLines === show) {\n            return;\n        }\n        this._showLines = show;\n        for (let i = 0; i < 6; ++i) {\n            this._lightHelperFrustumMeshes[i].setEnabled(show);\n        }\n    }\n    /**\n     * true to display the planes of the frustum\n     */\n    get showPlanes() {\n        return this._showPlanes;\n    }\n    set showPlanes(show) {\n        if (this._showPlanes === show) {\n            return;\n        }\n        this._showPlanes = show;\n        for (let i = 6; i < 12; ++i) {\n            this._lightHelperFrustumMeshes[i].setEnabled(show);\n        }\n    }\n    /**\n     * Creates a new frustum viewer\n     * @param light directional light to display the frustum for\n     * @param camera camera used to retrieve the minZ / maxZ values if the shadowMinZ/shadowMaxZ values of the light are not setup\n     */\n    constructor(light, camera = null) {\n        this._oldPosition = new Vector3(Number.NaN, Number.NaN, Number.NaN);\n        this._oldDirection = new Vector3(Number.NaN, Number.NaN, Number.NaN);\n        this._transparency = 0.3;\n        this._showLines = true;\n        this._showPlanes = true;\n        this._scene = light.getScene();\n        this._light = light;\n        this._camera = camera;\n        this._inverseViewMatrix = Matrix.Identity();\n        this._lightHelperFrustumMeshes = [];\n        this._createGeometry();\n        this.show();\n        this.update();\n    }\n    /**\n     * Shows the frustum\n     */\n    show() {\n        this._lightHelperFrustumMeshes.forEach((mesh, index) => {\n            mesh.setEnabled((index < 6 && this._showLines) || (index >= 6 && this._showPlanes));\n        });\n        this._oldPosition.set(Number.NaN, Number.NaN, Number.NaN);\n        this._visible = true;\n    }\n    /**\n     * Hides the frustum\n     */\n    hide() {\n        this._lightHelperFrustumMeshes.forEach((mesh) => {\n            mesh.setEnabled(false);\n        });\n        this._visible = false;\n    }\n    /**\n     * Updates the frustum.\n     * Call this method to update the frustum view if the light has changed position/direction\n     */\n    update() {\n        if (!this._visible) {\n            return;\n        }\n        if (this._oldPosition.equals(this._light.position) &&\n            this._oldDirection.equals(this._light.direction) &&\n            this._oldAutoCalc === this._light.autoCalcShadowZBounds &&\n            this._oldMinZ === this._light.shadowMinZ &&\n            this._oldMaxZ === this._light.shadowMaxZ) {\n            return;\n        }\n        this._oldPosition.copyFrom(this._light.position);\n        this._oldDirection.copyFrom(this._light.direction);\n        this._oldAutoCalc = this._light.autoCalcShadowZBounds;\n        this._oldMinZ = this._light.shadowMinZ;\n        this._oldMaxZ = this._light.shadowMaxZ;\n        TmpVectors.Vector3[0].set(this._light.orthoLeft, this._light.orthoBottom, this._light.shadowMinZ !== undefined ? this._light.shadowMinZ : (this._camera?.minZ ?? 0)); // min light extents\n        TmpVectors.Vector3[1].set(this._light.orthoRight, this._light.orthoTop, this._light.shadowMaxZ !== undefined ? this._light.shadowMaxZ : (this._camera?.maxZ ?? 10000)); // max light extents\n        const invLightView = this._getInvertViewMatrix();\n        TmpVectors.Vector3[2].copyFromFloats(TmpVectors.Vector3[1].x, TmpVectors.Vector3[1].y, TmpVectors.Vector3[0].z); // n1\n        TmpVectors.Vector3[3].copyFromFloats(TmpVectors.Vector3[1].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z); // n2\n        TmpVectors.Vector3[4].copyFromFloats(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z); // n3\n        TmpVectors.Vector3[5].copyFromFloats(TmpVectors.Vector3[0].x, TmpVectors.Vector3[1].y, TmpVectors.Vector3[0].z); // n4\n        Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[2], invLightView, TmpVectors.Vector3[2]); // near1\n        Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[3], invLightView, TmpVectors.Vector3[3]); // near2\n        Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[4], invLightView, TmpVectors.Vector3[4]); // near3\n        Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[5], invLightView, TmpVectors.Vector3[5]); // near4\n        TmpVectors.Vector3[6].copyFromFloats(TmpVectors.Vector3[1].x, TmpVectors.Vector3[1].y, TmpVectors.Vector3[1].z); // f1\n        TmpVectors.Vector3[7].copyFromFloats(TmpVectors.Vector3[1].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[1].z); // f2\n        TmpVectors.Vector3[8].copyFromFloats(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[1].z); // f3\n        TmpVectors.Vector3[9].copyFromFloats(TmpVectors.Vector3[0].x, TmpVectors.Vector3[1].y, TmpVectors.Vector3[1].z); // f4\n        Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[6], invLightView, TmpVectors.Vector3[6]); // far1\n        Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[7], invLightView, TmpVectors.Vector3[7]); // far2\n        Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[8], invLightView, TmpVectors.Vector3[8]); // far3\n        Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[9], invLightView, TmpVectors.Vector3[9]); // far4\n        CreateLines(\"nearlines\", { updatable: true, points: this._nearLinesPoints, instance: this._lightHelperFrustumMeshes[0] }, this._scene);\n        CreateLines(\"farlines\", { updatable: true, points: this._farLinesPoints, instance: this._lightHelperFrustumMeshes[1] }, this._scene);\n        CreateLines(\"trlines\", { updatable: true, points: this._trLinesPoints, instance: this._lightHelperFrustumMeshes[2] }, this._scene);\n        CreateLines(\"brlines\", { updatable: true, points: this._brLinesPoints, instance: this._lightHelperFrustumMeshes[3] }, this._scene);\n        CreateLines(\"tllines\", { updatable: true, points: this._tlLinesPoints, instance: this._lightHelperFrustumMeshes[4] }, this._scene);\n        CreateLines(\"bllines\", { updatable: true, points: this._blLinesPoints, instance: this._lightHelperFrustumMeshes[5] }, this._scene);\n        TmpVectors.Vector3[2].toArray(this._nearPlaneVertices, 0);\n        TmpVectors.Vector3[3].toArray(this._nearPlaneVertices, 3);\n        TmpVectors.Vector3[4].toArray(this._nearPlaneVertices, 6);\n        TmpVectors.Vector3[5].toArray(this._nearPlaneVertices, 9);\n        this._lightHelperFrustumMeshes[6].geometry?.updateVerticesDataDirectly(\"position\", this._nearPlaneVertices, 0);\n        TmpVectors.Vector3[6].toArray(this._farPlaneVertices, 0);\n        TmpVectors.Vector3[7].toArray(this._farPlaneVertices, 3);\n        TmpVectors.Vector3[8].toArray(this._farPlaneVertices, 6);\n        TmpVectors.Vector3[9].toArray(this._farPlaneVertices, 9);\n        this._lightHelperFrustumMeshes[7].geometry?.updateVerticesDataDirectly(\"position\", this._farPlaneVertices, 0);\n        TmpVectors.Vector3[2].toArray(this._rightPlaneVertices, 0);\n        TmpVectors.Vector3[6].toArray(this._rightPlaneVertices, 3);\n        TmpVectors.Vector3[7].toArray(this._rightPlaneVertices, 6);\n        TmpVectors.Vector3[3].toArray(this._rightPlaneVertices, 9);\n        this._lightHelperFrustumMeshes[8].geometry?.updateVerticesDataDirectly(\"position\", this._rightPlaneVertices, 0);\n        TmpVectors.Vector3[5].toArray(this._leftPlaneVertices, 0);\n        TmpVectors.Vector3[9].toArray(this._leftPlaneVertices, 3);\n        TmpVectors.Vector3[8].toArray(this._leftPlaneVertices, 6);\n        TmpVectors.Vector3[4].toArray(this._leftPlaneVertices, 9);\n        this._lightHelperFrustumMeshes[9].geometry?.updateVerticesDataDirectly(\"position\", this._leftPlaneVertices, 0);\n        TmpVectors.Vector3[2].toArray(this._topPlaneVertices, 0);\n        TmpVectors.Vector3[6].toArray(this._topPlaneVertices, 3);\n        TmpVectors.Vector3[9].toArray(this._topPlaneVertices, 6);\n        TmpVectors.Vector3[5].toArray(this._topPlaneVertices, 9);\n        this._lightHelperFrustumMeshes[10].geometry?.updateVerticesDataDirectly(\"position\", this._topPlaneVertices, 0);\n        TmpVectors.Vector3[3].toArray(this._bottomPlaneVertices, 0);\n        TmpVectors.Vector3[7].toArray(this._bottomPlaneVertices, 3);\n        TmpVectors.Vector3[8].toArray(this._bottomPlaneVertices, 6);\n        TmpVectors.Vector3[4].toArray(this._bottomPlaneVertices, 9);\n        this._lightHelperFrustumMeshes[11].geometry?.updateVerticesDataDirectly(\"position\", this._bottomPlaneVertices, 0);\n    }\n    /**\n     * Dispose of the class / remove the frustum view\n     */\n    dispose() {\n        this._lightHelperFrustumMeshes.forEach((mesh) => {\n            mesh.material?.dispose();\n            mesh.dispose();\n        });\n        this._rootNode.dispose();\n    }\n    _createGeometry() {\n        this._rootNode = new TransformNode(\"directionalLightHelperRoot_\" + this._light.name, this._scene);\n        this._rootNode.parent = this._light.parent;\n        this._nearLinesPoints = [TmpVectors.Vector3[0], TmpVectors.Vector3[1], TmpVectors.Vector3[2], TmpVectors.Vector3[3], TmpVectors.Vector3[4]];\n        const nearLines = CreateLines(\"nearlines\", { updatable: true, points: this._nearLinesPoints }, this._scene);\n        nearLines.parent = this._rootNode;\n        nearLines.alwaysSelectAsActiveMesh = true;\n        this._farLinesPoints = [TmpVectors.Vector3[5], TmpVectors.Vector3[6], TmpVectors.Vector3[7], TmpVectors.Vector3[8], TmpVectors.Vector3[9]];\n        const farLines = CreateLines(\"farlines\", { updatable: true, points: this._farLinesPoints }, this._scene);\n        farLines.parent = this._rootNode;\n        farLines.alwaysSelectAsActiveMesh = true;\n        this._trLinesPoints = [TmpVectors.Vector3[10], TmpVectors.Vector3[11]];\n        const trLines = CreateLines(\"trlines\", { updatable: true, points: this._trLinesPoints }, this._scene);\n        trLines.parent = this._rootNode;\n        trLines.alwaysSelectAsActiveMesh = true;\n        this._brLinesPoints = [TmpVectors.Vector3[12], TmpVectors.Vector3[0]];\n        const brLines = CreateLines(\"brlines\", { updatable: true, points: this._brLinesPoints }, this._scene);\n        brLines.parent = this._rootNode;\n        brLines.alwaysSelectAsActiveMesh = true;\n        this._tlLinesPoints = [TmpVectors.Vector3[1], TmpVectors.Vector3[2]];\n        const tlLines = CreateLines(\"tllines\", { updatable: true, points: this._tlLinesPoints }, this._scene);\n        tlLines.parent = this._rootNode;\n        tlLines.alwaysSelectAsActiveMesh = true;\n        this._blLinesPoints = [TmpVectors.Vector3[3], TmpVectors.Vector3[4]];\n        const blLines = CreateLines(\"bllines\", { updatable: true, points: this._blLinesPoints }, this._scene);\n        blLines.parent = this._rootNode;\n        blLines.alwaysSelectAsActiveMesh = true;\n        this._lightHelperFrustumMeshes.push(nearLines, farLines, trLines, brLines, tlLines, blLines);\n        const makePlane = (name, color, positions) => {\n            const plane = new Mesh(name + \"plane\", this._scene);\n            const mat = new StandardMaterial(name + \"PlaneMat\", this._scene);\n            plane.material = mat;\n            plane.parent = this._rootNode;\n            plane.alwaysSelectAsActiveMesh = true;\n            mat.emissiveColor = color;\n            mat.alpha = this.transparency;\n            mat.backFaceCulling = false;\n            mat.disableLighting = true;\n            const indices = [0, 1, 2, 0, 2, 3];\n            const vertexData = new VertexData();\n            vertexData.positions = positions;\n            vertexData.indices = indices;\n            vertexData.applyToMesh(plane, true);\n            this._lightHelperFrustumMeshes.push(plane);\n        };\n        this._nearPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        this._farPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        this._rightPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        this._leftPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        this._topPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        this._bottomPlaneVertices = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        makePlane(\"near\", new Color3(1, 0, 0), this._nearPlaneVertices);\n        makePlane(\"far\", new Color3(0.3, 0, 0), this._farPlaneVertices);\n        makePlane(\"right\", new Color3(0, 1, 0), this._rightPlaneVertices);\n        makePlane(\"left\", new Color3(0, 0.3, 0), this._leftPlaneVertices);\n        makePlane(\"top\", new Color3(0, 0, 1), this._topPlaneVertices);\n        makePlane(\"bottom\", new Color3(0, 0, 0.3), this._bottomPlaneVertices);\n        this._nearLinesPoints[0] = TmpVectors.Vector3[2];\n        this._nearLinesPoints[1] = TmpVectors.Vector3[3];\n        this._nearLinesPoints[2] = TmpVectors.Vector3[4];\n        this._nearLinesPoints[3] = TmpVectors.Vector3[5];\n        this._nearLinesPoints[4] = TmpVectors.Vector3[2];\n        this._farLinesPoints[0] = TmpVectors.Vector3[6];\n        this._farLinesPoints[1] = TmpVectors.Vector3[7];\n        this._farLinesPoints[2] = TmpVectors.Vector3[8];\n        this._farLinesPoints[3] = TmpVectors.Vector3[9];\n        this._farLinesPoints[4] = TmpVectors.Vector3[6];\n        this._trLinesPoints[0] = TmpVectors.Vector3[2];\n        this._trLinesPoints[1] = TmpVectors.Vector3[6];\n        this._brLinesPoints[0] = TmpVectors.Vector3[3];\n        this._brLinesPoints[1] = TmpVectors.Vector3[7];\n        this._tlLinesPoints[0] = TmpVectors.Vector3[4];\n        this._tlLinesPoints[1] = TmpVectors.Vector3[8];\n        this._blLinesPoints[0] = TmpVectors.Vector3[5];\n        this._blLinesPoints[1] = TmpVectors.Vector3[9];\n    }\n    _getInvertViewMatrix() {\n        Matrix.LookAtLHToRef(this._light.position, this._light.position.add(this._light.direction), Vector3.UpReadOnly, this._inverseViewMatrix);\n        this._inverseViewMatrix.invertToRef(this._inverseViewMatrix);\n        return this._inverseViewMatrix;\n    }\n}\n//# sourceMappingURL=directionalLightFrustumViewer.js.map","/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { Logger } from \"../Misc/logger.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { InternalTexture } from \"../Materials/Textures/internalTexture.js\";\n\nimport { DataBuffer } from \"../Buffers/dataBuffer.js\";\nimport { PerformanceConfigurator } from \"./performanceConfigurator.js\";\nimport { RenderTargetWrapper } from \"./renderTargetWrapper.js\";\nimport { IsWrapper } from \"../Materials/drawWrapper.functions.js\";\n/**\n * Options to create the null engine\n */\nexport class NullEngineOptions {\n    constructor() {\n        /**\n         * Render width (Default: 512)\n         */\n        this.renderWidth = 512;\n        /**\n         * Render height (Default: 256)\n         */\n        this.renderHeight = 256;\n        /**\n         * Texture size (Default: 512)\n         */\n        this.textureSize = 512;\n        /**\n         * If delta time between frames should be constant\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n         */\n        this.deterministicLockstep = false;\n        /**\n         * Maximum about of steps between frames (Default: 4)\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n         */\n        this.lockstepMaxSteps = 4;\n    }\n}\n/**\n * The null engine class provides support for headless version of babylon.js.\n * This can be used in server side scenario or for testing purposes\n */\nexport class NullEngine extends Engine {\n    /**\n     * Gets a boolean indicating that the engine is running in deterministic lock step mode\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n     * @returns true if engine is in deterministic lock step mode\n     */\n    isDeterministicLockStep() {\n        return this._options.deterministicLockstep;\n    }\n    /**\n     * Gets the max steps when engine is running in deterministic lock step\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep\n     * @returns the max steps\n     */\n    getLockstepMaxSteps() {\n        return this._options.lockstepMaxSteps;\n    }\n    /**\n     * Gets the current hardware scaling level.\n     * By default the hardware scaling level is computed from the window device ratio.\n     * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.\n     * @returns a number indicating the current hardware scaling level\n     */\n    getHardwareScalingLevel() {\n        return 1.0;\n    }\n    constructor(options = new NullEngineOptions()) {\n        super(null);\n        if (options.deterministicLockstep === undefined) {\n            options.deterministicLockstep = false;\n        }\n        if (options.timeStep !== undefined) {\n            this._timeStep = options.timeStep;\n        }\n        if (options.lockstepMaxSteps === undefined) {\n            options.lockstepMaxSteps = 4;\n        }\n        this._options = options;\n        PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);\n        // Init caps\n        // We consider we are on a webgl1 capable device\n        this._caps = {\n            maxTexturesImageUnits: 16,\n            maxVertexTextureImageUnits: 16,\n            maxCombinedTexturesImageUnits: 32,\n            maxTextureSize: 512,\n            maxCubemapTextureSize: 512,\n            maxDrawBuffers: 0,\n            maxRenderTextureSize: 512,\n            maxVertexAttribs: 16,\n            maxVaryingVectors: 16,\n            maxFragmentUniformVectors: 16,\n            maxVertexUniformVectors: 16,\n            standardDerivatives: false,\n            astc: null,\n            pvrtc: null,\n            etc1: null,\n            etc2: null,\n            bptc: null,\n            maxAnisotropy: 0,\n            uintIndices: false,\n            fragmentDepthSupported: false,\n            highPrecisionShaderSupported: true,\n            colorBufferFloat: false,\n            supportFloatTexturesResolve: false,\n            rg11b10ufColorRenderable: false,\n            textureFloat: false,\n            textureFloatLinearFiltering: false,\n            textureFloatRender: false,\n            textureHalfFloat: false,\n            textureHalfFloatLinearFiltering: false,\n            textureHalfFloatRender: false,\n            textureLOD: false,\n            texelFetch: false,\n            drawBuffersExtension: false,\n            depthTextureExtension: false,\n            vertexArrayObject: false,\n            instancedArrays: false,\n            supportOcclusionQuery: false,\n            canUseTimestampForTimerQuery: false,\n            maxMSAASamples: 1,\n            blendMinMax: false,\n            canUseGLInstanceID: false,\n            canUseGLVertexID: false,\n            supportComputeShaders: false,\n            supportSRGBBuffers: false,\n            supportTransformFeedbacks: false,\n            textureMaxLevel: false,\n            texture2DArrayMaxLayerCount: 128,\n            disableMorphTargetTexture: false,\n            textureNorm16: false,\n        };\n        this._features = {\n            forceBitmapOverHTMLImageElement: false,\n            supportRenderAndCopyToLodForFloatTextures: false,\n            supportDepthStencilTexture: false,\n            supportShadowSamplers: false,\n            uniformBufferHardCheckMatrix: false,\n            allowTexturePrefiltering: false,\n            trackUbosInFrame: false,\n            checkUbosContentBeforeUpload: false,\n            supportCSM: false,\n            basisNeedsPOT: false,\n            support3DTextures: false,\n            needTypeSuffixInShaderConstants: false,\n            supportMSAA: false,\n            supportSSAO2: false,\n            supportIBLShadows: false,\n            supportExtendedTextureFormats: false,\n            supportSwitchCaseInShader: false,\n            supportSyncTextureRead: false,\n            needsInvertingBitmap: false,\n            useUBOBindingCache: false,\n            needShaderCodeInlining: false,\n            needToAlwaysBindUniformBuffers: false,\n            supportRenderPasses: true,\n            supportSpriteInstancing: false,\n            forceVertexBufferStrideAndOffsetMultiple4Bytes: false,\n            _checkNonFloatVertexBuffersDontRecreatePipelineContext: false,\n            _collectUbosUpdatedInFrame: false,\n        };\n        if (options.renderingCanvas) {\n            this._renderingCanvas = options.renderingCanvas;\n        }\n        Logger.Log(`Babylon.js v${Engine.Version} - Null engine`);\n        // Wrappers\n        const theCurrentGlobal = typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : window;\n        if (typeof URL === \"undefined\") {\n            theCurrentGlobal.URL = {\n                createObjectURL: function () { },\n                revokeObjectURL: function () { },\n            };\n        }\n        if (typeof Blob === \"undefined\") {\n            theCurrentGlobal.Blob = function () { };\n        }\n    }\n    /**\n     * Creates a vertex buffer\n     * @param vertices the data for the vertex buffer\n     * @returns the new WebGL static buffer\n     */\n    createVertexBuffer(vertices) {\n        const buffer = new DataBuffer();\n        buffer.references = 1;\n        return buffer;\n    }\n    /**\n     * Creates a new index buffer\n     * @param indices defines the content of the index buffer\n     * @returns a new webGL buffer\n     */\n    createIndexBuffer(indices) {\n        const buffer = new DataBuffer();\n        buffer.references = 1;\n        return buffer;\n    }\n    /**\n     * Clear the current render buffer or the current render target (if any is set up)\n     * @param color defines the color to use\n     * @param backBuffer defines if the back buffer must be cleared\n     * @param depth defines if the depth buffer must be cleared\n     * @param stencil defines if the stencil buffer must be cleared\n     */\n    clear(color, backBuffer, depth, stencil = false) { }\n    /**\n     * Gets the current render width\n     * @param useScreen defines if screen size must be used (or the current render target if any)\n     * @returns a number defining the current render width\n     */\n    getRenderWidth(useScreen = false) {\n        if (!useScreen && this._currentRenderTarget) {\n            return this._currentRenderTarget.width;\n        }\n        return this._options.renderWidth;\n    }\n    /**\n     * Gets the current render height\n     * @param useScreen defines if screen size must be used (or the current render target if any)\n     * @returns a number defining the current render height\n     */\n    getRenderHeight(useScreen = false) {\n        if (!useScreen && this._currentRenderTarget) {\n            return this._currentRenderTarget.height;\n        }\n        return this._options.renderHeight;\n    }\n    /**\n     * Set the WebGL's viewport\n     * @param viewport defines the viewport element to be used\n     * @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used\n     * @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used\n     */\n    setViewport(viewport, requiredWidth, requiredHeight) {\n        this._cachedViewport = viewport;\n    }\n    createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines, context) {\n        return {\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            __SPECTOR_rebuildProgram: null,\n        };\n    }\n    /**\n     * Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names\n     * @param pipelineContext defines the pipeline context to use\n     * @param uniformsNames defines the list of uniform names\n     * @returns an array of webGL uniform locations\n     */\n    getUniforms(pipelineContext, uniformsNames) {\n        return [];\n    }\n    /**\n     * Gets the lsit of active attributes for a given webGL program\n     * @param pipelineContext defines the pipeline context to use\n     * @param attributesNames defines the list of attribute names to get\n     * @returns an array of indices indicating the offset of each attribute\n     */\n    getAttributes(pipelineContext, attributesNames) {\n        return [];\n    }\n    /**\n     * Binds an effect to the webGL context\n     * @param effect defines the effect to bind\n     */\n    bindSamplers(effect) {\n        this._currentEffect = null;\n    }\n    /**\n     * Activates an effect, making it the current one (ie. the one used for rendering)\n     * @param effect defines the effect to activate\n     */\n    enableEffect(effect) {\n        effect = effect !== null && IsWrapper(effect) ? effect.effect : effect; // get only the effect, we don't need a Wrapper in the WebGL engine\n        this._currentEffect = effect;\n        if (!effect) {\n            return;\n        }\n        if (effect.onBind) {\n            effect.onBind(effect);\n        }\n        if (effect._onBindObservable) {\n            effect._onBindObservable.notifyObservers(effect);\n        }\n    }\n    setStateCullFaceType(cullBackFaces, force) { }\n    /**\n     * Set various states to the webGL context\n     * @param culling defines culling state: true to enable culling, false to disable it\n     * @param zOffset defines the value to apply to zOffset (0 by default)\n     * @param force defines if states must be applied even if cache is up to date\n     * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)\n     * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)\n     * @param stencil stencil states to set\n     * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)\n     */\n    setState(culling, zOffset = 0, force, reverseSide = false, cullBackFaces, stencil, zOffsetUnits = 0) { }\n    /**\n     * Set the value of an uniform to an array of int32\n     * @param uniform defines the webGL uniform location where to store the value\n     * @param array defines the array of int32 to store\n     * @returns true if value was set\n     */\n    setIntArray(uniform, array) {\n        return true;\n    }\n    /**\n     * Set the value of an uniform to an array of int32 (stored as vec2)\n     * @param uniform defines the webGL uniform location where to store the value\n     * @param array defines the array of int32 to store\n     * @returns true if value was set\n     */\n    setIntArray2(uniform, array) {\n        return true;\n    }\n    /**\n     * Set the value of an uniform to an array of int32 (stored as vec3)\n     * @param uniform defines the webGL uniform location where to store the value\n     * @param array defines the array of int32 to store\n     * @returns true if value was set\n     */\n    setIntArray3(uniform, array) {\n        return true;\n    }\n    /**\n     * Set the value of an uniform to an array of int32 (stored as vec4)\n     * @param uniform defines the webGL uniform location where to store the value\n     * @param array defines the array of int32 to store\n     * @returns true if value was set\n     */\n    setIntArray4(uniform, array) {\n        return true;\n    }\n    /**\n     * Set the value of an uniform to an array of float32\n     * @param uniform defines the webGL uniform location where to store the value\n     * @param array defines the array of float32 to store\n     * @returns true if value was set\n     */\n    setFloatArray(uniform, array) {\n        return true;\n    }\n    /**\n     * Set the value of an uniform to an array of float32 (stored as vec2)\n     * @param uniform defines the webGL uniform location where to store the value\n     * @param array defines the array of float32 to store\n     * @returns true if value was set\n     */\n    setFloatArray2(uniform, array) {\n        return true;\n    }\n    /**\n     * Set the value of an uniform to an array of float32 (stored as vec3)\n     * @param uniform defines the webGL uniform location where to store the value\n     * @param array defines the array of float32 to store\n     * @returns true if value was set\n     */\n    setFloatArray3(uniform, array) {\n        return true;\n    }\n    /**\n     * Set the value of an uniform to an array of float32 (stored as vec4)\n     * @param uniform defines the webGL uniform location where to store the value\n     * @param array defines the array of float32 to store\n     * @returns true if value was set\n     */\n    setFloatArray4(uniform, array) {\n        return true;\n    }\n    /**\n     * Set the value of an uniform to an array of number\n     * @param uniform defines the webGL uniform location where to store the value\n     * @param array defines the array of number to store\n     * @returns true if value was set\n     */\n    setArray(uniform, array) {\n        return true;\n    }\n    /**\n     * Set the value of an uniform to an array of number (stored as vec2)\n     * @param uniform defines the webGL uniform location where to store the value\n     * @param array defines the array of number to store\n     * @returns true if value was set\n     */\n    setArray2(uniform, array) {\n        return true;\n    }\n    /**\n     * Set the value of an uniform to an array of number (stored as vec3)\n     * @param uniform defines the webGL uniform location where to store the value\n     * @param array defines the array of number to store\n     * @returns true if value was set\n     */\n    setArray3(uniform, array) {\n        return true;\n    }\n    /**\n     * Set the value of an uniform to an array of number (stored as vec4)\n     * @param uniform defines the webGL uniform location where to store the value\n     * @param array defines the array of number to store\n     * @returns true if value was set\n     */\n    setArray4(uniform, array) {\n        return true;\n    }\n    /**\n     * Set the value of an uniform to an array of float32 (stored as matrices)\n     * @param uniform defines the webGL uniform location where to store the value\n     * @param matrices defines the array of float32 to store\n     * @returns true if value was set\n     */\n    setMatrices(uniform, matrices) {\n        return true;\n    }\n    /**\n     * Set the value of an uniform to a matrix (3x3)\n     * @param uniform defines the webGL uniform location where to store the value\n     * @param matrix defines the Float32Array representing the 3x3 matrix to store\n     * @returns true if value was set\n     */\n    setMatrix3x3(uniform, matrix) {\n        return true;\n    }\n    /**\n     * Set the value of an uniform to a matrix (2x2)\n     * @param uniform defines the webGL uniform location where to store the value\n     * @param matrix defines the Float32Array representing the 2x2 matrix to store\n     * @returns true if value was set\n     */\n    setMatrix2x2(uniform, matrix) {\n        return true;\n    }\n    /**\n     * Set the value of an uniform to a number (float)\n     * @param uniform defines the webGL uniform location where to store the value\n     * @param value defines the float number to store\n     * @returns true if value was set\n     */\n    setFloat(uniform, value) {\n        return true;\n    }\n    /**\n     * Set the value of an uniform to a vec2\n     * @param uniform defines the webGL uniform location where to store the value\n     * @param x defines the 1st component of the value\n     * @param y defines the 2nd component of the value\n     * @returns true if value was set\n     */\n    setFloat2(uniform, x, y) {\n        return true;\n    }\n    /**\n     * Set the value of an uniform to a vec3\n     * @param uniform defines the webGL uniform location where to store the value\n     * @param x defines the 1st component of the value\n     * @param y defines the 2nd component of the value\n     * @param z defines the 3rd component of the value\n     * @returns true if value was set\n     */\n    setFloat3(uniform, x, y, z) {\n        return true;\n    }\n    /**\n     * Set the value of an uniform to a boolean\n     * @param uniform defines the webGL uniform location where to store the value\n     * @param bool defines the boolean to store\n     * @returns true if value was set\n     */\n    setBool(uniform, bool) {\n        return true;\n    }\n    /**\n     * Set the value of an uniform to a vec4\n     * @param uniform defines the webGL uniform location where to store the value\n     * @param x defines the 1st component of the value\n     * @param y defines the 2nd component of the value\n     * @param z defines the 3rd component of the value\n     * @param w defines the 4th component of the value\n     * @returns true if value was set\n     */\n    setFloat4(uniform, x, y, z, w) {\n        return true;\n    }\n    /**\n     * Sets the current alpha mode\n     * @param mode defines the mode to use (one of the Engine.ALPHA_XXX)\n     * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\n     */\n    setAlphaMode(mode, noDepthWriteChange = false) {\n        if (this._alphaMode === mode) {\n            return;\n        }\n        this.alphaState.alphaBlend = mode !== 0;\n        if (!noDepthWriteChange) {\n            this.setDepthWrite(mode === 0);\n        }\n        this._alphaMode = mode;\n    }\n    /**\n     * Bind webGl buffers directly to the webGL context\n     * @param vertexBuffers defines the vertex buffer to bind\n     * @param indexBuffer defines the index buffer to bind\n     * @param effect defines the effect associated with the vertex buffer\n     */\n    bindBuffers(vertexBuffers, indexBuffer, effect) { }\n    /**\n     * Force the entire cache to be cleared\n     * You should not have to use this function unless your engine needs to share the webGL context with another engine\n     * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)\n     */\n    wipeCaches(bruteForce) {\n        if (this.preventCacheWipeBetweenFrames) {\n            return;\n        }\n        this.resetTextureCache();\n        this._currentEffect = null;\n        if (bruteForce) {\n            this._currentProgram = null;\n            this._stencilStateComposer.reset();\n            this.depthCullingState.reset();\n            this.alphaState.reset();\n        }\n        this._cachedVertexBuffers = null;\n        this._cachedIndexBuffer = null;\n        this._cachedEffectForVertexBuffers = null;\n    }\n    /**\n     * Send a draw order\n     * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)\n     * @param indexStart defines the starting index\n     * @param indexCount defines the number of index to draw\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n     */\n    draw(useTriangles, indexStart, indexCount, instancesCount) { }\n    /**\n     * Draw a list of indexed primitives\n     * @param fillMode defines the primitive to use\n     * @param indexStart defines the starting index\n     * @param indexCount defines the number of index to draw\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n     */\n    drawElementsType(fillMode, indexStart, indexCount, instancesCount) { }\n    /**\n     * Draw a list of unindexed primitives\n     * @param fillMode defines the primitive to use\n     * @param verticesStart defines the index of first vertex to draw\n     * @param verticesCount defines the count of vertices to draw\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n     */\n    drawArraysType(fillMode, verticesStart, verticesCount, instancesCount) { }\n    /** @internal */\n    _createTexture() {\n        return {};\n    }\n    /**\n     * @internal\n     */\n    _releaseTexture(texture) { }\n    /**\n     * Usually called from Texture.ts.\n     * Passed information to create a WebGLTexture\n     * @param urlArg defines a value which contains one of the following:\n     * * A conventional http URL, e.g. 'http://...' or 'file://...'\n     * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\n     * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\n     * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\n     * @param scene needed for loading to the correct scene\n     * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\n     * @param onLoad optional callback to be called upon successful completion\n     * @param onError optional callback to be called upon failure\n     * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\n     * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\n     * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\n     * @param forcedExtension defines the extension to use to pick the right loader\n     * @param mimeType defines an optional mime type\n     * @returns a InternalTexture for assignment back into BABYLON.Texture\n     */\n    createTexture(urlArg, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType) {\n        const texture = new InternalTexture(this, 1 /* InternalTextureSource.Url */);\n        const url = String(urlArg);\n        texture.url = url;\n        texture.generateMipMaps = !noMipmap;\n        texture.samplingMode = samplingMode;\n        texture.invertY = invertY;\n        texture.baseWidth = this._options.textureSize;\n        texture.baseHeight = this._options.textureSize;\n        texture.width = this._options.textureSize;\n        texture.height = this._options.textureSize;\n        if (format) {\n            texture.format = format;\n        }\n        texture.isReady = true;\n        if (onLoad) {\n            setTimeout(() => {\n                onLoad(texture);\n            });\n        }\n        this._internalTexturesCache.push(texture);\n        return texture;\n    }\n    /**\n     * @internal\n     */\n    _createHardwareRenderTargetWrapper(isMulti, isCube, size) {\n        const rtWrapper = new RenderTargetWrapper(isMulti, isCube, size, this);\n        this._renderTargetWrapperCache.push(rtWrapper);\n        return rtWrapper;\n    }\n    /**\n     * Creates a new render target wrapper\n     * @param size defines the size of the texture\n     * @param options defines the options used to create the texture\n     * @returns a new render target wrapper\n     */\n    createRenderTargetTexture(size, options) {\n        const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);\n        const fullOptions = {};\n        if (options !== undefined && typeof options === \"object\") {\n            fullOptions.generateMipMaps = options.generateMipMaps;\n            fullOptions.generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n            fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && options.generateStencilBuffer;\n            fullOptions.type = options.type === undefined ? 0 : options.type;\n            fullOptions.samplingMode = options.samplingMode === undefined ? 3 : options.samplingMode;\n        }\n        else {\n            fullOptions.generateMipMaps = options;\n            fullOptions.generateDepthBuffer = true;\n            fullOptions.generateStencilBuffer = false;\n            fullOptions.type = 0;\n            fullOptions.samplingMode = 3;\n        }\n        const texture = new InternalTexture(this, 5 /* InternalTextureSource.RenderTarget */);\n        const width = size.width || size;\n        const height = size.height || size;\n        rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\n        rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;\n        texture.baseWidth = width;\n        texture.baseHeight = height;\n        texture.width = width;\n        texture.height = height;\n        texture.isReady = true;\n        texture.samples = 1;\n        texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\n        texture.samplingMode = fullOptions.samplingMode;\n        texture.type = fullOptions.type;\n        this._internalTexturesCache.push(texture);\n        return rtWrapper;\n    }\n    /**\n     * Creates a new render target wrapper\n     * @param size defines the size of the texture\n     * @param options defines the options used to create the texture\n     * @returns a new render target wrapper\n     */\n    createRenderTargetCubeTexture(size, options) {\n        const rtWrapper = this._createHardwareRenderTargetWrapper(false, true, size);\n        const fullOptions = {\n            generateMipMaps: true,\n            generateDepthBuffer: true,\n            generateStencilBuffer: false,\n            type: 0,\n            samplingMode: 3,\n            format: 5,\n            ...options,\n        };\n        fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;\n        if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {\n            // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\n            fullOptions.samplingMode = 1;\n        }\n        else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n            fullOptions.samplingMode = 1;\n        }\n        rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;\n        rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer ? true : false;\n        const texture = new InternalTexture(this, 5 /* InternalTextureSource.RenderTarget */);\n        texture.baseWidth = size;\n        texture.baseHeight = size;\n        texture.width = size;\n        texture.height = size;\n        texture.isReady = true;\n        texture.isCube = true;\n        texture.samples = 1;\n        texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;\n        texture.samplingMode = fullOptions.samplingMode;\n        texture.type = fullOptions.type;\n        this._internalTexturesCache.push(texture);\n        return rtWrapper;\n    }\n    /**\n     * Update the sampling mode of a given texture\n     * @param samplingMode defines the required sampling mode\n     * @param texture defines the texture to update\n     */\n    updateTextureSamplingMode(samplingMode, texture) {\n        texture.samplingMode = samplingMode;\n    }\n    /**\n     * Creates a raw texture\n     * @param data defines the data to store in the texture\n     * @param width defines the width of the texture\n     * @param height defines the height of the texture\n     * @param format defines the format of the data\n     * @param generateMipMaps defines if the engine should generate the mip levels\n     * @param invertY defines if data must be stored with Y axis inverted\n     * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\n     * @param compression defines the compression used (null by default)\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)\n     * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n     * @returns the raw texture inside an InternalTexture\n     */\n    createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, creationFlags = 0, useSRGBBuffer = false) {\n        const texture = new InternalTexture(this, 3 /* InternalTextureSource.Raw */);\n        texture.baseWidth = width;\n        texture.baseHeight = height;\n        texture.width = width;\n        texture.height = height;\n        texture.format = format;\n        texture.generateMipMaps = generateMipMaps;\n        texture.samplingMode = samplingMode;\n        texture.invertY = invertY;\n        texture._compression = compression;\n        texture.type = type;\n        texture._useSRGBBuffer = useSRGBBuffer;\n        if (!this._doNotHandleContextLost) {\n            texture._bufferView = data;\n        }\n        return texture;\n    }\n    /**\n     * Update a raw texture\n     * @param texture defines the texture to update\n     * @param data defines the data to store in the texture\n     * @param format defines the format of the data\n     * @param invertY defines if data must be stored with Y axis inverted\n     * @param compression defines the compression used (null by default)\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n     */\n    updateRawTexture(texture, data, format, invertY, compression = null, type = 0, useSRGBBuffer = false) {\n        if (texture) {\n            texture._bufferView = data;\n            texture.format = format;\n            texture.invertY = invertY;\n            texture._compression = compression;\n            texture.type = type;\n            texture._useSRGBBuffer = useSRGBBuffer;\n        }\n    }\n    /**\n     * Binds the frame buffer to the specified texture.\n     * @param rtWrapper The render target wrapper to render to\n     * @param faceIndex The face of the texture to render to in case of cube texture\n     * @param requiredWidth The width of the target to render to\n     * @param requiredHeight The height of the target to render to\n     * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true\n     */\n    bindFramebuffer(rtWrapper, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport) {\n        if (this._currentRenderTarget) {\n            this.unBindFramebuffer(this._currentRenderTarget);\n        }\n        this._currentRenderTarget = rtWrapper;\n        this._currentFramebuffer = null;\n        if (this._cachedViewport && !forceFullscreenViewport) {\n            this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);\n        }\n    }\n    /**\n     * Unbind the current render target texture from the webGL context\n     * @param rtWrapper defines the render target wrapper to unbind\n     * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\n     * @param onBeforeUnbind defines a function which will be called before the effective unbind\n     */\n    unBindFramebuffer(rtWrapper, disableGenerateMipMaps = false, onBeforeUnbind) {\n        this._currentRenderTarget = null;\n        if (onBeforeUnbind) {\n            onBeforeUnbind();\n        }\n        this._currentFramebuffer = null;\n    }\n    /**\n     * Creates a dynamic vertex buffer\n     * @param vertices the data for the dynamic vertex buffer\n     * @returns the new WebGL dynamic buffer\n     */\n    createDynamicVertexBuffer(vertices) {\n        const buffer = new DataBuffer();\n        buffer.references = 1;\n        buffer.capacity = 1;\n        return buffer;\n    }\n    /**\n     * Update the content of a dynamic texture\n     * @param texture defines the texture to update\n     * @param canvas defines the canvas containing the source\n     * @param invertY defines if data must be stored with Y axis inverted\n     * @param premulAlpha defines if alpha is stored as premultiplied\n     * @param format defines the format of the data\n     */\n    updateDynamicTexture(texture, canvas, invertY, premulAlpha = false, format) { }\n    /**\n     * Gets a boolean indicating if all created effects are ready\n     * @returns true if all effects are ready\n     */\n    areAllEffectsReady() {\n        return true;\n    }\n    /**\n     * @internal\n     * Get the current error code of the webGL context\n     * @returns the error code\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError\n     */\n    getError() {\n        return 0;\n    }\n    /** @internal */\n    _getUnpackAlignement() {\n        return 1;\n    }\n    /**\n     * @internal\n     */\n    _unpackFlipY(value) { }\n    /**\n     * Update a dynamic index buffer\n     * @param indexBuffer defines the target index buffer\n     * @param indices defines the data to update\n     * @param offset defines the offset in the target index buffer where update should start\n     */\n    updateDynamicIndexBuffer(indexBuffer, indices, offset = 0) { }\n    /**\n     * Updates a dynamic vertex buffer.\n     * @param vertexBuffer the vertex buffer to update\n     * @param vertices the data used to update the vertex buffer\n     * @param byteOffset the byte offset of the data (optional)\n     * @param byteLength the byte length of the data (optional)\n     */\n    updateDynamicVertexBuffer(vertexBuffer, vertices, byteOffset, byteLength) { }\n    /**\n     * @internal\n     */\n    _bindTextureDirectly(target, texture) {\n        if (this._boundTexturesCache[this._activeChannel] !== texture) {\n            this._boundTexturesCache[this._activeChannel] = texture;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * @internal\n     */\n    _bindTexture(channel, texture) {\n        if (channel < 0) {\n            return;\n        }\n        this._bindTextureDirectly(0, texture);\n    }\n    _deleteBuffer(buffer) { }\n    /**\n     * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\n     */\n    releaseEffects() { }\n    displayLoadingUI() { }\n    hideLoadingUI() { }\n    set loadingUIText(_) { }\n    flushFramebuffer() { }\n    /**\n     * @internal\n     */\n    _uploadCompressedDataToTextureDirectly(texture, internalFormat, width, height, data, faceIndex = 0, lod = 0) { }\n    /**\n     * @internal\n     */\n    _uploadDataToTextureDirectly(texture, imageData, faceIndex = 0, lod = 0) { }\n    /**\n     * @internal\n     */\n    _uploadArrayBufferViewToTexture(texture, imageData, faceIndex = 0, lod = 0) { }\n    /**\n     * @internal\n     */\n    _uploadImageToTexture(texture, image, faceIndex = 0, lod = 0) { }\n}\n//# sourceMappingURL=nullEngine.js.map","import { Engine } from \"./engine.js\";\nimport { NullEngine } from \"./nullEngine.js\";\nimport { WebGPUEngine } from \"./webgpuEngine.js\";\n/**\n * Helper class to create the best engine depending on the current hardware\n */\nexport class EngineFactory {\n    /**\n     * Creates an engine based on the capabilities of the underlying hardware\n     * @param canvas Defines the canvas to use to display the result\n     * @param options Defines the options passed to the engine to create the context dependencies\n     * @returns a promise that resolves with the created engine\n     */\n    static async CreateAsync(canvas, options) {\n        const supported = await WebGPUEngine.IsSupportedAsync;\n        if (supported) {\n            return WebGPUEngine.CreateAsync(canvas, options);\n        }\n        if (Engine.IsSupported) {\n            return new Engine(canvas, undefined, options);\n        }\n        return new NullEngine(options);\n    }\n}\n//# sourceMappingURL=engineFactory.js.map","/**\n * @deprecated Avoid using this on the flow-graph (glTF only)\n * A path converter that converts a path on the flow graph context variables to an object accessor.\n */\nexport class FlowGraphPathConverter {\n    constructor(_context, _separator = \"/\") {\n        this._context = _context;\n        this._separator = _separator;\n    }\n    convert(path) {\n        const parts = path.split(this._separator);\n        if (parts.length < 2) {\n            throw new Error(`Path ${path} is invalid`);\n        }\n        let currentObject = this._context.getVariable(parts[0]);\n        const property = parts[parts.length - 1];\n        for (let i = 1; i < parts.length - 1; i++) {\n            currentObject = currentObject[parts[i]];\n        }\n        return {\n            object: currentObject,\n            info: {\n                type: \"object\",\n                get: () => currentObject[property],\n                set: (value) => (currentObject[property] = value),\n                getTarget: () => currentObject,\n                getPropertyName: [() => property],\n            },\n        };\n    }\n}\n//# sourceMappingURL=flowGraphPathConverter.js.map","/**\n * Structure used by the frame graph to reference objects.\n * @experimental\n */\nexport class FrameGraphObjectList {\n}\n//# sourceMappingURL=frameGraphObjectList.js.map","import { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { PlaneRotationGizmo } from \"./planeRotationGizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\n/**\n * Gizmo that enables rotating a mesh along 3 axis\n */\nexport class RotationGizmo extends Gizmo {\n    get attachedMesh() {\n        return this._meshAttached;\n    }\n    set attachedMesh(mesh) {\n        this._meshAttached = mesh;\n        this._nodeAttached = mesh;\n        this._checkBillboardTransform();\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\n            if (gizmo.isEnabled) {\n                gizmo.attachedMesh = mesh;\n            }\n            else {\n                gizmo.attachedMesh = null;\n            }\n        });\n    }\n    get attachedNode() {\n        return this._nodeAttached;\n    }\n    set attachedNode(node) {\n        this._meshAttached = null;\n        this._nodeAttached = node;\n        this._checkBillboardTransform();\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\n            if (gizmo.isEnabled) {\n                gizmo.attachedNode = node;\n            }\n            else {\n                gizmo.attachedNode = null;\n            }\n        });\n    }\n    _checkBillboardTransform() {\n        if (this._nodeAttached && this._nodeAttached.billboardMode) {\n            Logger.Log(\"Rotation Gizmo will not work with transforms in billboard mode.\");\n        }\n    }\n    /**\n     * Sensitivity factor for dragging (Default: 1)\n     */\n    set sensitivity(value) {\n        this._sensitivity = value;\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\n            if (gizmo) {\n                gizmo.sensitivity = value;\n            }\n        });\n    }\n    get sensitivity() {\n        return this._sensitivity;\n    }\n    /**\n     * True when the mouse pointer is hovering a gizmo mesh\n     */\n    get isHovered() {\n        return this.xGizmo.isHovered || this.yGizmo.isHovered || this.zGizmo.isHovered;\n    }\n    /**\n     * True when the mouse pointer is dragging a gizmo mesh\n     */\n    get isDragging() {\n        return this.xGizmo.dragBehavior.dragging || this.yGizmo.dragBehavior.dragging || this.zGizmo.dragBehavior.dragging;\n    }\n    get additionalTransformNode() {\n        return this._additionalTransformNode;\n    }\n    set additionalTransformNode(transformNode) {\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\n            gizmo.additionalTransformNode = transformNode;\n        });\n    }\n    /**\n     * Creates a RotationGizmo\n     * @param gizmoLayer The utility layer the gizmo will be added to\n     * @param tessellation Amount of tessellation to be used when creating rotation circles\n     * @param useEulerRotation Use and update Euler angle instead of quaternion\n     * @param thickness display gizmo axis thickness\n     * @param gizmoManager Gizmo manager\n     * @param options More options\n     */\n    constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, tessellation = 32, useEulerRotation = false, thickness = 1, gizmoManager, options) {\n        super(gizmoLayer);\n        /** Fires an event when any of it's sub gizmos are dragged */\n        this.onDragStartObservable = new Observable();\n        /** Fires an event when any of it's sub gizmos are being dragged */\n        this.onDragObservable = new Observable();\n        /** Fires an event when any of it's sub gizmos are released from dragging */\n        this.onDragEndObservable = new Observable();\n        this._observables = [];\n        this._sensitivity = 1;\n        /** Node Caching for quick lookup */\n        this._gizmoAxisCache = new Map();\n        const xColor = options && options.xOptions && options.xOptions.color ? options.xOptions.color : Color3.Red().scale(0.5);\n        const yColor = options && options.yOptions && options.yOptions.color ? options.yOptions.color : Color3.Green().scale(0.5);\n        const zColor = options && options.zOptions && options.zOptions.color ? options.zOptions.color : Color3.Blue().scale(0.5);\n        this.xGizmo = new PlaneRotationGizmo(new Vector3(1, 0, 0), xColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);\n        this.yGizmo = new PlaneRotationGizmo(new Vector3(0, 1, 0), yColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);\n        this.zGizmo = new PlaneRotationGizmo(new Vector3(0, 0, 1), zColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);\n        this.additionalTransformNode = options?.additionalTransformNode;\n        // Relay drag events and set update scale\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\n            //must set updateScale on each gizmo, as setting it on root RotationGizmo doesnt prevent individual gizmos from updating\n            //currently updateScale is a property with no getter/setter, so no good way to override behavior at runtime, so we will at least set it on startup\n            if (options && options.updateScale != undefined) {\n                gizmo.updateScale = options.updateScale;\n            }\n            gizmo.dragBehavior.onDragStartObservable.add(() => {\n                this.onDragStartObservable.notifyObservers({});\n            });\n            gizmo.dragBehavior.onDragObservable.add(() => {\n                this.onDragObservable.notifyObservers({});\n            });\n            gizmo.dragBehavior.onDragEndObservable.add(() => {\n                this.onDragEndObservable.notifyObservers({});\n            });\n        });\n        this.attachedMesh = null;\n        this.attachedNode = null;\n        if (gizmoManager) {\n            gizmoManager.addToAxisCache(this._gizmoAxisCache);\n        }\n        else {\n            // Only subscribe to pointer event if gizmoManager isnt\n            Gizmo.GizmoAxisPointerObserver(gizmoLayer, this._gizmoAxisCache);\n        }\n    }\n    /**\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\n     * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation\n     */\n    set updateGizmoRotationToMatchAttachedMesh(value) {\n        if (this.xGizmo) {\n            this.xGizmo.updateGizmoRotationToMatchAttachedMesh = value;\n            this.yGizmo.updateGizmoRotationToMatchAttachedMesh = value;\n            this.zGizmo.updateGizmoRotationToMatchAttachedMesh = value;\n        }\n    }\n    get updateGizmoRotationToMatchAttachedMesh() {\n        return this.xGizmo.updateGizmoRotationToMatchAttachedMesh;\n    }\n    set updateGizmoPositionToMatchAttachedMesh(value) {\n        if (this.xGizmo) {\n            this.xGizmo.updateGizmoPositionToMatchAttachedMesh = value;\n            this.yGizmo.updateGizmoPositionToMatchAttachedMesh = value;\n            this.zGizmo.updateGizmoPositionToMatchAttachedMesh = value;\n        }\n    }\n    get updateGizmoPositionToMatchAttachedMesh() {\n        return this.xGizmo.updateGizmoPositionToMatchAttachedMesh;\n    }\n    set anchorPoint(value) {\n        this._anchorPoint = value;\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\n            gizmo.anchorPoint = value;\n        });\n    }\n    get anchorPoint() {\n        return this._anchorPoint;\n    }\n    /**\n     * Set the coordinate system to use. By default it's local.\n     * But it's possible for a user to tweak so its local for translation and world for rotation.\n     * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`\n     */\n    set coordinatesMode(coordinatesMode) {\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\n            gizmo.coordinatesMode = coordinatesMode;\n        });\n    }\n    set updateScale(value) {\n        if (this.xGizmo) {\n            this.xGizmo.updateScale = value;\n            this.yGizmo.updateScale = value;\n            this.zGizmo.updateScale = value;\n        }\n    }\n    get updateScale() {\n        return this.xGizmo.updateScale;\n    }\n    /**\n     * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\n     */\n    set snapDistance(value) {\n        if (this.xGizmo) {\n            this.xGizmo.snapDistance = value;\n            this.yGizmo.snapDistance = value;\n            this.zGizmo.snapDistance = value;\n        }\n    }\n    get snapDistance() {\n        return this.xGizmo.snapDistance;\n    }\n    /**\n     * Ratio for the scale of the gizmo (Default: 1)\n     */\n    set scaleRatio(value) {\n        if (this.xGizmo) {\n            this.xGizmo.scaleRatio = value;\n            this.yGizmo.scaleRatio = value;\n            this.zGizmo.scaleRatio = value;\n        }\n    }\n    get scaleRatio() {\n        return this.xGizmo.scaleRatio;\n    }\n    /**\n     * posture that the gizmo will be display\n     * When set null, default value will be used (Quaternion(0, 0, 0, 1))\n     */\n    get customRotationQuaternion() {\n        return this._customRotationQuaternion;\n    }\n    set customRotationQuaternion(customRotationQuaternion) {\n        this._customRotationQuaternion = customRotationQuaternion;\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\n            if (gizmo) {\n                gizmo.customRotationQuaternion = customRotationQuaternion;\n            }\n        });\n    }\n    /**\n     * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\n     * @param mesh Axis gizmo mesh\n     * @param cache Gizmo axis definition used for reactive gizmo UI\n     */\n    addToAxisCache(mesh, cache) {\n        this._gizmoAxisCache.set(mesh, cache);\n    }\n    /**\n     * Force release the drag action by code\n     */\n    releaseDrag() {\n        this.xGizmo.dragBehavior.releaseDrag();\n        this.yGizmo.dragBehavior.releaseDrag();\n        this.zGizmo.dragBehavior.releaseDrag();\n    }\n    /**\n     * Disposes of the gizmo\n     */\n    dispose() {\n        this.xGizmo.dispose();\n        this.yGizmo.dispose();\n        this.zGizmo.dispose();\n        this.onDragStartObservable.clear();\n        this.onDragObservable.clear();\n        this.onDragEndObservable.clear();\n        this._observables.forEach((obs) => {\n            this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);\n        });\n        super.dispose();\n    }\n    /**\n     * CustomMeshes are not supported by this gizmo\n     */\n    setCustomMesh() {\n        Logger.Error(\"Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo)\");\n    }\n}\n//# sourceMappingURL=rotationGizmo.js.map","import { Observable } from \"../Misc/observable.js\";\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder.js\";\nimport { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\n/**\n * Single plane drag gizmo\n */\nexport class PlaneDragGizmo extends Gizmo {\n    /** Default material used to render when gizmo is not disabled or hovered */\n    get coloredMaterial() {\n        return this._coloredMaterial;\n    }\n    /** Material used to render when gizmo is hovered with mouse*/\n    get hoverMaterial() {\n        return this._hoverMaterial;\n    }\n    /** Material used to render when gizmo is disabled. typically grey.*/\n    get disableMaterial() {\n        return this._disableMaterial;\n    }\n    /**\n     * @internal\n     */\n    static _CreatePlane(scene, material) {\n        const plane = new TransformNode(\"plane\", scene);\n        //make sure plane is double sided\n        const dragPlane = CreatePlane(\"dragPlane\", { width: 0.1375, height: 0.1375, sideOrientation: 2 }, scene);\n        dragPlane.material = material;\n        dragPlane.parent = plane;\n        return plane;\n    }\n    /**\n     * Creates a PlaneDragGizmo\n     * @param dragPlaneNormal The axis normal to which the gizmo will be able to drag on\n     * @param color The color of the gizmo\n     * @param gizmoLayer The utility layer the gizmo will be added to\n     * @param parent\n     * @param hoverColor The color of the gizmo when hovering over and dragging\n     * @param disableColor The Color of the gizmo when its disabled\n     */\n    constructor(dragPlaneNormal, color = Color3.Gray(), gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, parent = null, hoverColor = Color3.Yellow(), disableColor = Color3.Gray()) {\n        super(gizmoLayer);\n        this._pointerObserver = null;\n        /**\n         * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\n         */\n        this.snapDistance = 0;\n        /**\n         * Event that fires each time the gizmo snaps to a new location.\n         * * snapDistance is the change in distance\n         */\n        this.onSnapObservable = new Observable();\n        this._isEnabled = false;\n        this._parent = null;\n        this._dragging = false;\n        this._parent = parent;\n        // Create Material\n        this._coloredMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n        this._coloredMaterial.diffuseColor = color;\n        this._coloredMaterial.specularColor = color.subtract(new Color3(0.1, 0.1, 0.1));\n        this._hoverMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n        this._hoverMaterial.diffuseColor = hoverColor;\n        this._disableMaterial = new StandardMaterial(\"\", gizmoLayer.utilityLayerScene);\n        this._disableMaterial.diffuseColor = disableColor;\n        this._disableMaterial.alpha = 0.4;\n        // Build plane mesh on root node\n        this._gizmoMesh = PlaneDragGizmo._CreatePlane(gizmoLayer.utilityLayerScene, this._coloredMaterial);\n        this._gizmoMesh.lookAt(this._rootMesh.position.add(dragPlaneNormal));\n        this._gizmoMesh.scaling.scaleInPlace(1 / 3);\n        this._gizmoMesh.parent = this._rootMesh;\n        let currentSnapDragDistance = 0;\n        const tmpVector = new Vector3();\n        const tmpSnapEvent = { snapDistance: 0 };\n        // Add dragPlaneNormal drag behavior to handle events when the gizmo is dragged\n        this.dragBehavior = new PointerDragBehavior({ dragPlaneNormal: dragPlaneNormal });\n        this.dragBehavior.moveAttached = false;\n        this._rootMesh.addBehavior(this.dragBehavior);\n        this.dragBehavior.onDragObservable.add((event) => {\n            if (this.attachedNode) {\n                // Keep world translation and use it to update world transform\n                // if the node has parent, the local transform properties (position, rotation, scale)\n                // will be recomputed in _matrixChanged function\n                // Snapping logic\n                if (this.snapDistance == 0) {\n                    this.attachedNode.getWorldMatrix().getTranslationToRef(TmpVectors.Vector3[0]);\n                    TmpVectors.Vector3[0].addToRef(event.delta, TmpVectors.Vector3[0]);\n                    if (this.dragBehavior.validateDrag(TmpVectors.Vector3[0])) {\n                        this.attachedNode.getWorldMatrix().addTranslationFromFloats(event.delta.x, event.delta.y, event.delta.z);\n                    }\n                }\n                else {\n                    currentSnapDragDistance += event.dragDistance;\n                    if (Math.abs(currentSnapDragDistance) > this.snapDistance) {\n                        const dragSteps = Math.floor(Math.abs(currentSnapDragDistance) / this.snapDistance);\n                        currentSnapDragDistance = currentSnapDragDistance % this.snapDistance;\n                        event.delta.normalizeToRef(tmpVector);\n                        tmpVector.scaleInPlace(this.snapDistance * dragSteps);\n                        this.attachedNode.getWorldMatrix().getTranslationToRef(TmpVectors.Vector3[0]);\n                        TmpVectors.Vector3[0].addToRef(tmpVector, TmpVectors.Vector3[0]);\n                        if (this.dragBehavior.validateDrag(TmpVectors.Vector3[0])) {\n                            this.attachedNode.getWorldMatrix().addTranslationFromFloats(tmpVector.x, tmpVector.y, tmpVector.z);\n                            tmpSnapEvent.snapDistance = this.snapDistance * dragSteps;\n                            this.onSnapObservable.notifyObservers(tmpSnapEvent);\n                        }\n                    }\n                }\n                this._matrixChanged();\n            }\n        });\n        this.dragBehavior.onDragStartObservable.add(() => {\n            this._dragging = true;\n        });\n        this.dragBehavior.onDragEndObservable.add(() => {\n            this._dragging = false;\n        });\n        const light = gizmoLayer._getSharedGizmoLight();\n        light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes(false));\n        const cache = {\n            gizmoMeshes: this._gizmoMesh.getChildMeshes(),\n            colliderMeshes: this._gizmoMesh.getChildMeshes(),\n            material: this._coloredMaterial,\n            hoverMaterial: this._hoverMaterial,\n            disableMaterial: this._disableMaterial,\n            active: false,\n            dragBehavior: this.dragBehavior,\n        };\n        this._parent?.addToAxisCache(this._gizmoMesh, cache);\n        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\n            if (this._customMeshSet) {\n                return;\n            }\n            this._isHovered = !!(cache.colliderMeshes.indexOf(pointerInfo?.pickInfo?.pickedMesh) != -1);\n            if (!this._parent) {\n                const material = cache.dragBehavior.enabled ? (this._isHovered || this._dragging ? this._hoverMaterial : this._coloredMaterial) : this._disableMaterial;\n                this._setGizmoMeshMaterial(cache.gizmoMeshes, material);\n            }\n        });\n        this.dragBehavior.onEnabledObservable.add((newState) => {\n            this._setGizmoMeshMaterial(cache.gizmoMeshes, newState ? this._coloredMaterial : this._disableMaterial);\n        });\n    }\n    _attachedNodeChanged(value) {\n        if (this.dragBehavior) {\n            this.dragBehavior.enabled = value ? true : false;\n        }\n    }\n    /**\n     * If the gizmo is enabled\n     */\n    set isEnabled(value) {\n        this._isEnabled = value;\n        if (!value) {\n            this.attachedNode = null;\n        }\n        else {\n            if (this._parent) {\n                this.attachedNode = this._parent.attachedNode;\n            }\n        }\n    }\n    get isEnabled() {\n        return this._isEnabled;\n    }\n    /**\n     * Disposes of the gizmo\n     */\n    dispose() {\n        this.onSnapObservable.clear();\n        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n        this.dragBehavior.detach();\n        super.dispose();\n        if (this._gizmoMesh) {\n            this._gizmoMesh.dispose();\n        }\n        [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach((matl) => {\n            if (matl) {\n                matl.dispose();\n            }\n        });\n    }\n}\n//# sourceMappingURL=planeDragGizmo.js.map","import { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { AxisDragGizmo } from \"./axisDragGizmo.js\";\nimport { PlaneDragGizmo } from \"./planeDragGizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\n/**\n * Gizmo that enables dragging a mesh along 3 axis\n */\nexport class PositionGizmo extends Gizmo {\n    get attachedMesh() {\n        return this._meshAttached;\n    }\n    set attachedMesh(mesh) {\n        this._meshAttached = mesh;\n        this._nodeAttached = mesh;\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\n            if (gizmo.isEnabled) {\n                gizmo.attachedMesh = mesh;\n            }\n            else {\n                gizmo.attachedMesh = null;\n            }\n        });\n    }\n    get attachedNode() {\n        return this._nodeAttached;\n    }\n    set attachedNode(node) {\n        this._meshAttached = null;\n        this._nodeAttached = node;\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\n            if (gizmo.isEnabled) {\n                gizmo.attachedNode = node;\n            }\n            else {\n                gizmo.attachedNode = null;\n            }\n        });\n    }\n    /**\n     * True when the mouse pointer is hovering a gizmo mesh\n     */\n    get isHovered() {\n        return this.xGizmo.isHovered || this.yGizmo.isHovered || this.zGizmo.isHovered || this.xPlaneGizmo.isHovered || this.yPlaneGizmo.isHovered || this.zPlaneGizmo.isHovered;\n    }\n    get isDragging() {\n        return (this.xGizmo.dragBehavior.dragging ||\n            this.yGizmo.dragBehavior.dragging ||\n            this.zGizmo.dragBehavior.dragging ||\n            this.xPlaneGizmo.dragBehavior.dragging ||\n            this.yPlaneGizmo.dragBehavior.dragging ||\n            this.zPlaneGizmo.dragBehavior.dragging);\n    }\n    get additionalTransformNode() {\n        return this._additionalTransformNode;\n    }\n    set additionalTransformNode(transformNode) {\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\n            gizmo.additionalTransformNode = transformNode;\n        });\n    }\n    /**\n     * Creates a PositionGizmo\n     * @param gizmoLayer The utility layer the gizmo will be added to\n     * @param thickness display gizmo axis thickness\n     * @param gizmoManager\n     * @param options More options\n     */\n    constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, thickness = 1, gizmoManager, options) {\n        super(gizmoLayer);\n        /**\n         * protected variables\n         */\n        this._meshAttached = null;\n        this._nodeAttached = null;\n        this._observables = [];\n        /** Node Caching for quick lookup */\n        this._gizmoAxisCache = new Map();\n        /** Fires an event when any of it's sub gizmos are dragged */\n        this.onDragStartObservable = new Observable();\n        /** Fires an event when any of it's sub gizmos are being dragged */\n        this.onDragObservable = new Observable();\n        /** Fires an event when any of it's sub gizmos are released from dragging */\n        this.onDragEndObservable = new Observable();\n        /**\n         * If set to true, planar drag is enabled\n         */\n        this._planarGizmoEnabled = false;\n        this.xGizmo = new AxisDragGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), gizmoLayer, this, thickness);\n        this.yGizmo = new AxisDragGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), gizmoLayer, this, thickness);\n        this.zGizmo = new AxisDragGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), gizmoLayer, this, thickness);\n        this.xPlaneGizmo = new PlaneDragGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), this.gizmoLayer, this);\n        this.yPlaneGizmo = new PlaneDragGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), this.gizmoLayer, this);\n        this.zPlaneGizmo = new PlaneDragGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), this.gizmoLayer, this);\n        this.additionalTransformNode = options?.additionalTransformNode;\n        // Relay drag events\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\n            gizmo.dragBehavior.onDragStartObservable.add(() => {\n                this.onDragStartObservable.notifyObservers({});\n            });\n            gizmo.dragBehavior.onDragObservable.add(() => {\n                this.onDragObservable.notifyObservers({});\n            });\n            gizmo.dragBehavior.onDragEndObservable.add(() => {\n                this.onDragEndObservable.notifyObservers({});\n            });\n        });\n        this.attachedMesh = null;\n        if (gizmoManager) {\n            gizmoManager.addToAxisCache(this._gizmoAxisCache);\n        }\n        else {\n            // Only subscribe to pointer event if gizmoManager isnt\n            Gizmo.GizmoAxisPointerObserver(gizmoLayer, this._gizmoAxisCache);\n        }\n    }\n    /**\n     * If the planar drag gizmo is enabled\n     * setting this will enable/disable XY, XZ and YZ planes regardless of individual gizmo settings.\n     */\n    set planarGizmoEnabled(value) {\n        this._planarGizmoEnabled = value;\n        [this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\n            if (gizmo) {\n                gizmo.isEnabled = value;\n                if (value) {\n                    if (gizmo.attachedMesh) {\n                        gizmo.attachedMesh = this.attachedMesh;\n                    }\n                    else {\n                        gizmo.attachedNode = this.attachedNode;\n                    }\n                }\n            }\n        }, this);\n    }\n    get planarGizmoEnabled() {\n        return this._planarGizmoEnabled;\n    }\n    /**\n     * posture that the gizmo will be display\n     * When set null, default value will be used (Quaternion(0, 0, 0, 1))\n     */\n    get customRotationQuaternion() {\n        return this._customRotationQuaternion;\n    }\n    set customRotationQuaternion(customRotationQuaternion) {\n        this._customRotationQuaternion = customRotationQuaternion;\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\n            if (gizmo) {\n                gizmo.customRotationQuaternion = customRotationQuaternion;\n            }\n        });\n    }\n    /**\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\n     * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation\n     */\n    set updateGizmoRotationToMatchAttachedMesh(value) {\n        this._updateGizmoRotationToMatchAttachedMesh = value;\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\n            if (gizmo) {\n                gizmo.updateGizmoRotationToMatchAttachedMesh = value;\n            }\n        });\n    }\n    get updateGizmoRotationToMatchAttachedMesh() {\n        return this._updateGizmoRotationToMatchAttachedMesh;\n    }\n    set updateGizmoPositionToMatchAttachedMesh(value) {\n        this._updateGizmoPositionToMatchAttachedMesh = value;\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\n            if (gizmo) {\n                gizmo.updateGizmoPositionToMatchAttachedMesh = value;\n            }\n        });\n    }\n    get updateGizmoPositionToMatchAttachedMesh() {\n        return this._updateGizmoPositionToMatchAttachedMesh;\n    }\n    set anchorPoint(value) {\n        this._anchorPoint = value;\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\n            gizmo.anchorPoint = value;\n        });\n    }\n    get anchorPoint() {\n        return this._anchorPoint;\n    }\n    /**\n     * Set the coordinate system to use. By default it's local.\n     * But it's possible for a user to tweak so its local for translation and world for rotation.\n     * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`\n     */\n    set coordinatesMode(coordinatesMode) {\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\n            gizmo.coordinatesMode = coordinatesMode;\n        });\n    }\n    set updateScale(value) {\n        if (this.xGizmo) {\n            this.xGizmo.updateScale = value;\n            this.yGizmo.updateScale = value;\n            this.zGizmo.updateScale = value;\n        }\n    }\n    get updateScale() {\n        return this.xGizmo.updateScale;\n    }\n    /**\n     * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\n     */\n    set snapDistance(value) {\n        this._snapDistance = value;\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\n            if (gizmo) {\n                gizmo.snapDistance = value;\n            }\n        });\n    }\n    get snapDistance() {\n        return this._snapDistance;\n    }\n    /**\n     * Ratio for the scale of the gizmo (Default: 1)\n     */\n    set scaleRatio(value) {\n        this._scaleRatio = value;\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\n            if (gizmo) {\n                gizmo.scaleRatio = value;\n            }\n        });\n    }\n    get scaleRatio() {\n        return this._scaleRatio;\n    }\n    /**\n     * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\n     * @param mesh Axis gizmo mesh\n     * @param cache Gizmo axis definition used for reactive gizmo UI\n     */\n    addToAxisCache(mesh, cache) {\n        this._gizmoAxisCache.set(mesh, cache);\n    }\n    /**\n     * Force release the drag action by code\n     */\n    releaseDrag() {\n        this.xGizmo.dragBehavior.releaseDrag();\n        this.yGizmo.dragBehavior.releaseDrag();\n        this.zGizmo.dragBehavior.releaseDrag();\n        this.xPlaneGizmo.dragBehavior.releaseDrag();\n        this.yPlaneGizmo.dragBehavior.releaseDrag();\n        this.zPlaneGizmo.dragBehavior.releaseDrag();\n    }\n    /**\n     * Disposes of the gizmo\n     */\n    dispose() {\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\n            if (gizmo) {\n                gizmo.dispose();\n            }\n        });\n        this._observables.forEach((obs) => {\n            this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);\n        });\n        this.onDragStartObservable.clear();\n        this.onDragObservable.clear();\n        this.onDragEndObservable.clear();\n        super.dispose();\n    }\n    /**\n     * CustomMeshes are not supported by this gizmo\n     */\n    setCustomMesh() {\n        Logger.Error(\"Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo,gizmo.xPlaneGizmo, gizmo.yPlaneGizmo, gizmo.zPlaneGizmo)\");\n    }\n}\n//# sourceMappingURL=positionGizmo.js.map","import { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { CreatePolyhedron } from \"../Meshes/Builders/polyhedronBuilder.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { AxisScaleGizmo } from \"./axisScaleGizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\n/**\n * Gizmo that enables scaling a mesh along 3 axis\n */\nexport class ScaleGizmo extends Gizmo {\n    /** Default material used to render when gizmo is not disabled or hovered */\n    get coloredMaterial() {\n        return this._coloredMaterial;\n    }\n    /** Material used to render when gizmo is hovered with mouse*/\n    get hoverMaterial() {\n        return this._hoverMaterial;\n    }\n    /** Material used to render when gizmo is disabled. typically grey.*/\n    get disableMaterial() {\n        return this._disableMaterial;\n    }\n    get attachedMesh() {\n        return this._meshAttached;\n    }\n    set attachedMesh(mesh) {\n        this._meshAttached = mesh;\n        this._nodeAttached = mesh;\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {\n            if (gizmo.isEnabled) {\n                gizmo.attachedMesh = mesh;\n            }\n            else {\n                gizmo.attachedMesh = null;\n            }\n        });\n    }\n    get attachedNode() {\n        return this._nodeAttached;\n    }\n    set attachedNode(node) {\n        this._meshAttached = null;\n        this._nodeAttached = node;\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {\n            if (gizmo.isEnabled) {\n                gizmo.attachedNode = node;\n            }\n            else {\n                gizmo.attachedNode = null;\n            }\n        });\n    }\n    set updateScale(value) {\n        if (this.xGizmo) {\n            this.xGizmo.updateScale = value;\n            this.yGizmo.updateScale = value;\n            this.zGizmo.updateScale = value;\n        }\n    }\n    get updateScale() {\n        return this.xGizmo.updateScale;\n    }\n    /**\n     * True when the mouse pointer is hovering a gizmo mesh\n     */\n    get isHovered() {\n        return this.xGizmo.isHovered || this.yGizmo.isHovered || this.zGizmo.isHovered || this.uniformScaleGizmo.isHovered;\n    }\n    /**\n     * True when the mouse pointer is dragging a gizmo mesh\n     */\n    get isDragging() {\n        return this.xGizmo.dragBehavior.dragging || this.yGizmo.dragBehavior.dragging || this.zGizmo.dragBehavior.dragging || this.uniformScaleGizmo.dragBehavior.dragging;\n    }\n    get additionalTransformNode() {\n        return this._additionalTransformNode;\n    }\n    set additionalTransformNode(transformNode) {\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {\n            gizmo.additionalTransformNode = transformNode;\n        });\n    }\n    /**\n     * Creates a ScaleGizmo\n     * @param gizmoLayer The utility layer the gizmo will be added to\n     * @param thickness display gizmo axis thickness\n     * @param gizmoManager\n     * @param options More options\n     */\n    constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, thickness = 1, gizmoManager, options) {\n        super(gizmoLayer);\n        this._meshAttached = null;\n        this._nodeAttached = null;\n        this._incrementalSnap = false;\n        this._sensitivity = 1;\n        this._observables = [];\n        /** Node Caching for quick lookup */\n        this._gizmoAxisCache = new Map();\n        /** Fires an event when any of it's sub gizmos are dragged */\n        this.onDragStartObservable = new Observable();\n        /** Fires an event when any of it's sub gizmos are being dragged */\n        this.onDragObservable = new Observable();\n        /** Fires an event when any of it's sub gizmos are released from dragging */\n        this.onDragEndObservable = new Observable();\n        this.uniformScaleGizmo = this._createUniformScaleMesh();\n        this.xGizmo = new AxisScaleGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), gizmoLayer, this, thickness);\n        this.yGizmo = new AxisScaleGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), gizmoLayer, this, thickness);\n        this.zGizmo = new AxisScaleGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), gizmoLayer, this, thickness);\n        this.additionalTransformNode = options?.additionalTransformNode;\n        // Relay drag events\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {\n            gizmo.dragBehavior.onDragStartObservable.add(() => {\n                this.onDragStartObservable.notifyObservers({});\n            });\n            gizmo.dragBehavior.onDragObservable.add(() => {\n                this.onDragObservable.notifyObservers({});\n            });\n            gizmo.dragBehavior.onDragEndObservable.add(() => {\n                this.onDragEndObservable.notifyObservers({});\n            });\n        });\n        this.attachedMesh = null;\n        this.attachedNode = null;\n        if (gizmoManager) {\n            gizmoManager.addToAxisCache(this._gizmoAxisCache);\n        }\n        else {\n            // Only subscribe to pointer event if gizmoManager isnt\n            Gizmo.GizmoAxisPointerObserver(gizmoLayer, this._gizmoAxisCache);\n        }\n    }\n    /**\n     * @internal\n     * Create Geometry for Gizmo\n     */\n    _createUniformScaleMesh() {\n        this._coloredMaterial = new StandardMaterial(\"\", this.gizmoLayer.utilityLayerScene);\n        this._coloredMaterial.diffuseColor = Color3.Gray();\n        this._hoverMaterial = new StandardMaterial(\"\", this.gizmoLayer.utilityLayerScene);\n        this._hoverMaterial.diffuseColor = Color3.Yellow();\n        this._disableMaterial = new StandardMaterial(\"\", this.gizmoLayer.utilityLayerScene);\n        this._disableMaterial.diffuseColor = Color3.Gray();\n        this._disableMaterial.alpha = 0.4;\n        const uniformScaleGizmo = new AxisScaleGizmo(new Vector3(0, 1, 0), Color3.Gray().scale(0.5), this.gizmoLayer, this);\n        uniformScaleGizmo.updateGizmoRotationToMatchAttachedMesh = false;\n        uniformScaleGizmo.uniformScaling = true;\n        this._uniformScalingMesh = CreatePolyhedron(\"uniform\", { type: 1 }, uniformScaleGizmo.gizmoLayer.utilityLayerScene);\n        this._uniformScalingMesh.scaling.scaleInPlace(0.01);\n        this._uniformScalingMesh.visibility = 0;\n        this._octahedron = CreatePolyhedron(\"\", { type: 1 }, uniformScaleGizmo.gizmoLayer.utilityLayerScene);\n        this._octahedron.scaling.scaleInPlace(0.007);\n        this._uniformScalingMesh.addChild(this._octahedron);\n        uniformScaleGizmo.setCustomMesh(this._uniformScalingMesh, true);\n        const light = this.gizmoLayer._getSharedGizmoLight();\n        light.includedOnlyMeshes = light.includedOnlyMeshes.concat(this._octahedron);\n        const cache = {\n            gizmoMeshes: [this._octahedron, this._uniformScalingMesh],\n            colliderMeshes: [this._octahedron, this._uniformScalingMesh],\n            material: this._coloredMaterial,\n            hoverMaterial: this._hoverMaterial,\n            disableMaterial: this._disableMaterial,\n            active: false,\n            dragBehavior: uniformScaleGizmo.dragBehavior,\n        };\n        this.addToAxisCache(uniformScaleGizmo._rootMesh, cache);\n        return uniformScaleGizmo;\n    }\n    set updateGizmoRotationToMatchAttachedMesh(value) {\n        if (!value) {\n            Logger.Warn(\"Setting updateGizmoRotationToMatchAttachedMesh = false on scaling gizmo is not supported.\");\n        }\n        else {\n            this._updateGizmoRotationToMatchAttachedMesh = value;\n            [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {\n                if (gizmo) {\n                    gizmo.updateGizmoRotationToMatchAttachedMesh = value;\n                }\n            });\n        }\n    }\n    get updateGizmoRotationToMatchAttachedMesh() {\n        return this._updateGizmoRotationToMatchAttachedMesh;\n    }\n    set anchorPoint(value) {\n        this._anchorPoint = value;\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {\n            if (gizmo) {\n                gizmo.anchorPoint = value;\n            }\n        });\n    }\n    get anchorPoint() {\n        return this._anchorPoint;\n    }\n    /**\n     * posture that the gizmo will be display\n     * When set null, default value will be used (Quaternion(0, 0, 0, 1))\n     */\n    get customRotationQuaternion() {\n        return this._customRotationQuaternion;\n    }\n    set customRotationQuaternion(customRotationQuaternion) {\n        this._customRotationQuaternion = customRotationQuaternion;\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {\n            if (gizmo) {\n                gizmo.customRotationQuaternion = customRotationQuaternion;\n            }\n        });\n    }\n    /**\n     * Set the coordinate system to use. By default it's local.\n     * But it's possible for a user to tweak so its local for translation and world for rotation.\n     * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`\n     */\n    set coordinatesMode(coordinatesMode) {\n        if (coordinatesMode == 0 /* GizmoCoordinatesMode.World */) {\n            Logger.Warn(\"Setting coordinates Mode to world on scaling gizmo is not supported.\");\n        }\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {\n            gizmo.coordinatesMode = 1 /* GizmoCoordinatesMode.Local */;\n        });\n    }\n    /**\n     * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\n     */\n    set snapDistance(value) {\n        this._snapDistance = value;\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {\n            if (gizmo) {\n                gizmo.snapDistance = value;\n            }\n        });\n    }\n    get snapDistance() {\n        return this._snapDistance;\n    }\n    /**\n     * Incremental snap scaling (default is false). When true, with a snapDistance of 0.1, scaling will be 1.1,1.2,1.3 instead of, when false: 1.1,1.21,1.33,...\n     */\n    set incrementalSnap(value) {\n        this._incrementalSnap = value;\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {\n            if (gizmo) {\n                gizmo.incrementalSnap = value;\n            }\n        });\n    }\n    get incrementalSnap() {\n        return this._incrementalSnap;\n    }\n    /**\n     * Ratio for the scale of the gizmo (Default: 1)\n     */\n    set scaleRatio(value) {\n        this._scaleRatio = value;\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {\n            if (gizmo) {\n                gizmo.scaleRatio = value;\n            }\n        });\n    }\n    get scaleRatio() {\n        return this._scaleRatio;\n    }\n    /**\n     * Sensitivity factor for dragging (Default: 1)\n     */\n    set sensitivity(value) {\n        this._sensitivity = value;\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {\n            if (gizmo) {\n                gizmo.sensitivity = value;\n            }\n        });\n    }\n    get sensitivity() {\n        return this._sensitivity;\n    }\n    /**\n     * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\n     * @param mesh Axis gizmo mesh\n     * @param cache Gizmo axis definition used for reactive gizmo UI\n     */\n    addToAxisCache(mesh, cache) {\n        this._gizmoAxisCache.set(mesh, cache);\n    }\n    /**\n     * Get the cache set with addToAxisCache for a specific mesh\n     * @param mesh Axis gizmo mesh\n     * @returns Gizmo axis definition used for reactive gizmo UI\n     */\n    getAxisCache(mesh) {\n        return this._gizmoAxisCache.get(mesh);\n    }\n    /**\n     * Force release the drag action by code\n     */\n    releaseDrag() {\n        this.xGizmo.dragBehavior.releaseDrag();\n        this.yGizmo.dragBehavior.releaseDrag();\n        this.zGizmo.dragBehavior.releaseDrag();\n        this.uniformScaleGizmo.dragBehavior.releaseDrag();\n    }\n    /**\n     * Disposes of the gizmo\n     */\n    dispose() {\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.uniformScaleGizmo].forEach((gizmo) => {\n            if (gizmo) {\n                gizmo.dispose();\n            }\n        });\n        this._observables.forEach((obs) => {\n            this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);\n        });\n        this.onDragStartObservable.clear();\n        this.onDragObservable.clear();\n        this.onDragEndObservable.clear();\n        [this._uniformScalingMesh, this._octahedron].forEach((msh) => {\n            if (msh) {\n                msh.dispose();\n            }\n        });\n        [this._coloredMaterial, this._hoverMaterial, this._disableMaterial].forEach((matl) => {\n            if (matl) {\n                matl.dispose();\n            }\n        });\n    }\n}\n//# sourceMappingURL=scaleGizmo.js.map","import { Observable } from \"../Misc/observable.js\";\nimport { PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { SixDofDragBehavior } from \"../Behaviors/Meshes/sixDofDragBehavior.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { RotationGizmo } from \"./rotationGizmo.js\";\nimport { PositionGizmo } from \"./positionGizmo.js\";\nimport { ScaleGizmo } from \"./scaleGizmo.js\";\nimport { BoundingBoxGizmo } from \"./boundingBoxGizmo.js\";\n/**\n * Helps setup gizmo's in the scene to rotate/scale/position nodes\n */\nexport class GizmoManager {\n    /**\n     * Utility layer that the bounding box gizmo belongs to\n     */\n    get keepDepthUtilityLayer() {\n        return this._defaultKeepDepthUtilityLayer;\n    }\n    /**\n     * Utility layer that all gizmos besides bounding box belong to\n     */\n    get utilityLayer() {\n        return this._defaultUtilityLayer;\n    }\n    /**\n     * True when the mouse pointer is hovering a gizmo mesh\n     */\n    get isHovered() {\n        let hovered = false;\n        for (const key in this.gizmos) {\n            const gizmo = this.gizmos[key];\n            if (gizmo && gizmo.isHovered) {\n                hovered = true;\n                break;\n            }\n        }\n        return hovered;\n    }\n    /**\n     * True when the mouse pointer is dragging a gizmo mesh\n     */\n    get isDragging() {\n        let dragging = false;\n        [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo, this.gizmos.boundingBoxGizmo].forEach((gizmo) => {\n            if (gizmo && gizmo.isDragging) {\n                dragging = true;\n            }\n        });\n        return dragging;\n    }\n    /**\n     * Ratio for the scale of the gizmo (Default: 1)\n     */\n    set scaleRatio(value) {\n        this._scaleRatio = value;\n        [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo].forEach((gizmo) => {\n            if (gizmo) {\n                gizmo.scaleRatio = value;\n            }\n        });\n    }\n    get scaleRatio() {\n        return this._scaleRatio;\n    }\n    /**\n     * Set the coordinate system to use. By default it's local.\n     * But it's possible for a user to tweak so its local for translation and world for rotation.\n     * In that case, setting the coordinate system will change `updateGizmoRotationToMatchAttachedMesh` and `updateGizmoPositionToMatchAttachedMesh`\n     */\n    set coordinatesMode(coordinatesMode) {\n        this._coordinatesMode = coordinatesMode;\n        [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo].forEach((gizmo) => {\n            if (gizmo) {\n                gizmo.coordinatesMode = coordinatesMode;\n            }\n        });\n    }\n    get coordinatesMode() {\n        return this._coordinatesMode;\n    }\n    /**\n     * The mesh the gizmo's is attached to\n     */\n    get attachedMesh() {\n        return this._attachedMesh;\n    }\n    /**\n     * The node the gizmo's is attached to\n     */\n    get attachedNode() {\n        return this._attachedNode;\n    }\n    /**\n     * Additional transform node that will be used to transform all the gizmos\n     */\n    get additionalTransformNode() {\n        return this._additionalTransformNode;\n    }\n    /**\n     * Instantiates a gizmo manager\n     * @param _scene the scene to overlay the gizmos on top of\n     * @param thickness display gizmo axis thickness\n     * @param utilityLayer the layer where gizmos are rendered\n     * @param keepDepthUtilityLayer the layer where occluded gizmos are rendered\n     */\n    constructor(_scene, thickness = 1, utilityLayer = UtilityLayerRenderer.DefaultUtilityLayer, keepDepthUtilityLayer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer) {\n        this._scene = _scene;\n        /** When true, the gizmo will be detached from the current object when a pointer down occurs with an empty picked mesh */\n        this.clearGizmoOnEmptyPointerEvent = false;\n        /** When true (default), picking to attach a new mesh is enabled. This works in sync with inspector autopicking. */\n        this.enableAutoPicking = true;\n        /** Fires an event when the manager is attached to a mesh */\n        this.onAttachedToMeshObservable = new Observable();\n        /** Fires an event when the manager is attached to a node */\n        this.onAttachedToNodeObservable = new Observable();\n        this._gizmosEnabled = { positionGizmo: false, rotationGizmo: false, scaleGizmo: false, boundingBoxGizmo: false };\n        this._pointerObservers = [];\n        this._attachedMesh = null;\n        this._attachedNode = null;\n        this._boundingBoxColor = Color3.FromHexString(\"#0984e3\");\n        this._thickness = 1;\n        this._scaleRatio = 1;\n        this._coordinatesMode = 1 /* GizmoCoordinatesMode.Local */;\n        /** Node Caching for quick lookup */\n        this._gizmoAxisCache = new Map();\n        /**\n         * When bounding box gizmo is enabled, this can be used to track drag/end events\n         */\n        this.boundingBoxDragBehavior = new SixDofDragBehavior();\n        /**\n         * Array of meshes which will have the gizmo attached when a pointer selected them. If null, all meshes are attachable. (Default: null)\n         */\n        this.attachableMeshes = null;\n        /**\n         * Array of nodes which will have the gizmo attached when a pointer selected them. If null, all nodes are attachable. (Default: null)\n         */\n        this.attachableNodes = null;\n        /**\n         * If pointer events should perform attaching/detaching a gizmo, if false this can be done manually via attachToMesh/attachToNode. (Default: true)\n         */\n        this.usePointerToAttachGizmos = true;\n        this._defaultUtilityLayer = utilityLayer;\n        this._defaultKeepDepthUtilityLayer = keepDepthUtilityLayer;\n        this._defaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\n        this._thickness = thickness;\n        this.gizmos = { positionGizmo: null, rotationGizmo: null, scaleGizmo: null, boundingBoxGizmo: null };\n        const attachToMeshPointerObserver = this._attachToMeshPointerObserver(_scene);\n        const gizmoAxisPointerObserver = Gizmo.GizmoAxisPointerObserver(this._defaultUtilityLayer, this._gizmoAxisCache);\n        this._pointerObservers = [attachToMeshPointerObserver, gizmoAxisPointerObserver];\n    }\n    /**\n     * @internal\n     * Subscribes to pointer down events, for attaching and detaching mesh\n     * @param scene The scene layer the observer will be added to\n     * @returns the pointer observer\n     */\n    _attachToMeshPointerObserver(scene) {\n        // Instantiate/dispose gizmos based on pointer actions\n        const pointerObserver = scene.onPointerObservable.add((pointerInfo) => {\n            if (!this.usePointerToAttachGizmos) {\n                return;\n            }\n            if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\n                if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh) {\n                    if (this.enableAutoPicking) {\n                        let node = pointerInfo.pickInfo.pickedMesh;\n                        if (this.attachableMeshes == null) {\n                            // Attach to the most parent node\n                            while (node && node.parent != null) {\n                                node = node.parent;\n                            }\n                        }\n                        else {\n                            // Attach to the parent node that is an attachableMesh\n                            let found = false;\n                            this.attachableMeshes.forEach((mesh) => {\n                                if (node && (node == mesh || node.isDescendantOf(mesh))) {\n                                    node = mesh;\n                                    found = true;\n                                }\n                            });\n                            if (!found) {\n                                node = null;\n                            }\n                        }\n                        if (node instanceof AbstractMesh) {\n                            if (this._attachedMesh != node) {\n                                this.attachToMesh(node);\n                            }\n                        }\n                        else {\n                            if (this.clearGizmoOnEmptyPointerEvent) {\n                                this.attachToMesh(null);\n                            }\n                        }\n                    }\n                }\n                else {\n                    if (this.clearGizmoOnEmptyPointerEvent) {\n                        this.attachToMesh(null);\n                    }\n                }\n            }\n        });\n        return pointerObserver;\n    }\n    /**\n     * Attaches a set of gizmos to the specified mesh\n     * @param mesh The mesh the gizmo's should be attached to\n     */\n    attachToMesh(mesh) {\n        if (this._attachedMesh) {\n            this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n        }\n        if (this._attachedNode) {\n            this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n        }\n        this._attachedMesh = mesh;\n        this._attachedNode = null;\n        for (const key in this.gizmos) {\n            const gizmo = this.gizmos[key];\n            if (gizmo && this._gizmosEnabled[key]) {\n                gizmo.attachedMesh = mesh;\n            }\n        }\n        if (this.boundingBoxGizmoEnabled && this._attachedMesh) {\n            this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\n        }\n        this.onAttachedToMeshObservable.notifyObservers(mesh);\n    }\n    /**\n     * Attaches a set of gizmos to the specified node\n     * @param node The node the gizmo's should be attached to\n     */\n    attachToNode(node) {\n        if (this._attachedMesh) {\n            this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n        }\n        if (this._attachedNode) {\n            this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n        }\n        this._attachedMesh = null;\n        this._attachedNode = node;\n        for (const key in this.gizmos) {\n            const gizmo = this.gizmos[key];\n            if (gizmo && this._gizmosEnabled[key]) {\n                gizmo.attachedNode = node;\n            }\n        }\n        if (this.boundingBoxGizmoEnabled && this._attachedNode) {\n            this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\n        }\n        this.onAttachedToNodeObservable.notifyObservers(node);\n    }\n    /**\n     * If the position gizmo is enabled\n     */\n    set positionGizmoEnabled(value) {\n        if (value) {\n            if (!this.gizmos.positionGizmo) {\n                this.gizmos.positionGizmo = new PositionGizmo(this._defaultUtilityLayer, this._thickness, this);\n            }\n            if (this._attachedNode) {\n                this.gizmos.positionGizmo.attachedNode = this._attachedNode;\n            }\n            else {\n                this.gizmos.positionGizmo.attachedMesh = this._attachedMesh;\n            }\n        }\n        else if (this.gizmos.positionGizmo) {\n            this.gizmos.positionGizmo.attachedNode = null;\n        }\n        this._gizmosEnabled.positionGizmo = value;\n        this._setAdditionalTransformNode();\n    }\n    get positionGizmoEnabled() {\n        return this._gizmosEnabled.positionGizmo;\n    }\n    /**\n     * If the rotation gizmo is enabled\n     */\n    set rotationGizmoEnabled(value) {\n        if (value) {\n            if (!this.gizmos.rotationGizmo) {\n                this.gizmos.rotationGizmo = new RotationGizmo(this._defaultUtilityLayer, 32, false, this._thickness, this);\n            }\n            if (this._attachedNode) {\n                this.gizmos.rotationGizmo.attachedNode = this._attachedNode;\n            }\n            else {\n                this.gizmos.rotationGizmo.attachedMesh = this._attachedMesh;\n            }\n        }\n        else if (this.gizmos.rotationGizmo) {\n            this.gizmos.rotationGizmo.attachedNode = null;\n        }\n        this._gizmosEnabled.rotationGizmo = value;\n        this._setAdditionalTransformNode();\n    }\n    get rotationGizmoEnabled() {\n        return this._gizmosEnabled.rotationGizmo;\n    }\n    /**\n     * If the scale gizmo is enabled\n     */\n    set scaleGizmoEnabled(value) {\n        if (value) {\n            this.gizmos.scaleGizmo = this.gizmos.scaleGizmo || new ScaleGizmo(this._defaultUtilityLayer, this._thickness, this);\n            if (this._attachedNode) {\n                this.gizmos.scaleGizmo.attachedNode = this._attachedNode;\n            }\n            else {\n                this.gizmos.scaleGizmo.attachedMesh = this._attachedMesh;\n            }\n        }\n        else if (this.gizmos.scaleGizmo) {\n            this.gizmos.scaleGizmo.attachedNode = null;\n        }\n        this._gizmosEnabled.scaleGizmo = value;\n        this._setAdditionalTransformNode();\n    }\n    get scaleGizmoEnabled() {\n        return this._gizmosEnabled.scaleGizmo;\n    }\n    /**\n     * If the boundingBox gizmo is enabled\n     */\n    set boundingBoxGizmoEnabled(value) {\n        if (value) {\n            this.gizmos.boundingBoxGizmo = this.gizmos.boundingBoxGizmo || new BoundingBoxGizmo(this._boundingBoxColor, this._defaultKeepDepthUtilityLayer);\n            if (this._attachedMesh) {\n                this.gizmos.boundingBoxGizmo.attachedMesh = this._attachedMesh;\n            }\n            else {\n                this.gizmos.boundingBoxGizmo.attachedNode = this._attachedNode;\n            }\n            if (this._attachedMesh) {\n                this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n                this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\n            }\n            else if (this._attachedNode) {\n                this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n                this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\n            }\n        }\n        else if (this.gizmos.boundingBoxGizmo) {\n            if (this._attachedMesh) {\n                this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n            }\n            else if (this._attachedNode) {\n                this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n            }\n            this.gizmos.boundingBoxGizmo.attachedNode = null;\n        }\n        this._gizmosEnabled.boundingBoxGizmo = value;\n        this._setAdditionalTransformNode();\n    }\n    get boundingBoxGizmoEnabled() {\n        return this._gizmosEnabled.boundingBoxGizmo;\n    }\n    /**\n     * Sets the additional transform applied to all the gizmos.\n     * @See Gizmo.additionalTransformNode for more detail\n     */\n    set additionalTransformNode(node) {\n        this._additionalTransformNode = node;\n        this._setAdditionalTransformNode();\n    }\n    _setAdditionalTransformNode() {\n        for (const key in this.gizmos) {\n            const gizmo = this.gizmos[key];\n            if (gizmo && this._gizmosEnabled[key]) {\n                gizmo.additionalTransformNode = this._additionalTransformNode;\n            }\n        }\n    }\n    /**\n     * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\n     * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\n     */\n    addToAxisCache(gizmoAxisCache) {\n        if (gizmoAxisCache.size > 0) {\n            gizmoAxisCache.forEach((v, k) => {\n                this._gizmoAxisCache.set(k, v);\n            });\n        }\n    }\n    /**\n     * Force release the drag action by code\n     */\n    releaseDrag() {\n        [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo, this.gizmos.boundingBoxGizmo].forEach((gizmo) => {\n            gizmo?.releaseDrag();\n        });\n    }\n    /**\n     * Disposes of the gizmo manager\n     */\n    dispose() {\n        this._pointerObservers.forEach((observer) => {\n            this._scene.onPointerObservable.remove(observer);\n        });\n        for (const key in this.gizmos) {\n            const gizmo = this.gizmos[key];\n            if (gizmo) {\n                gizmo.dispose();\n            }\n        }\n        if (this._defaultKeepDepthUtilityLayer !== UtilityLayerRenderer._DefaultKeepDepthUtilityLayer) {\n            this._defaultKeepDepthUtilityLayer?.dispose();\n        }\n        if (this._defaultUtilityLayer !== UtilityLayerRenderer._DefaultUtilityLayer) {\n            this._defaultUtilityLayer?.dispose();\n        }\n        this.boundingBoxDragBehavior.detach();\n        this.onAttachedToMeshObservable.clear();\n    }\n}\n//# sourceMappingURL=gizmoManager.js.map","import { Vector2 } from \"../Maths/math.vector.js\";\n/**\n * Given the control points, solve for x based on a given t for a cubic bezier curve\n * @param t a value between 0 and 1\n * @param p0 first control point\n * @param p1 second control point\n * @param p2 third control point\n * @param p3 fourth control point\n * @returns number result of cubic bezier curve at the specified t\n */\nfunction cubicBezierCurve(t, p0, p1, p2, p3) {\n    return (1 - t) * (1 - t) * (1 - t) * p0 + 3 * (1 - t) * (1 - t) * t * p1 + 3 * (1 - t) * t * t * p2 + t * t * t * p3;\n}\n/**\n * Evaluates a specified specular power value to determine the appropriate roughness value,\n * based on a pre-defined cubic bezier curve with specular on the abscissa axis (x-axis)\n * and roughness on the ordinant axis (y-axis)\n * @param specularPower specular power of standard material\n * @param p0 first control point\n * @param p1 second control point\n * @param p2 third control point\n * @param p3 fourth control point\n * @returns Number representing the roughness value\n */\nexport function SpecularPowerToRoughness(specularPower, p0 = new Vector2(0, 1), p1 = new Vector2(0, 0.1), p2 = new Vector2(0, 0.1), p3 = new Vector2(1300, 0.1)) {\n    // Given P0.x = 0, P1.x = 0, P2.x = 0\n    //   x = t * t * t * P3.x\n    //   t = (x / P3.x)^(1/3)\n    const t = Math.pow(specularPower / p3.x, 0.333333);\n    return cubicBezierCurve(t, p0.y, p1.y, p2.y, p3.y);\n}\n//# sourceMappingURL=materialConversionHelper.js.map","import { PerfCounter } from \"../Misc/perfCounter.js\";\n/**\n * This class can be used to get instrumentation data from a Babylon engine\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#engineinstrumentation\n */\nexport class EngineInstrumentation {\n    // Properties\n    /**\n     * Gets the perf counter used for GPU frame time\n     */\n    get gpuFrameTimeCounter() {\n        return this.engine.getGPUFrameTimeCounter();\n    }\n    /**\n     * Gets the GPU frame time capture status\n     */\n    get captureGPUFrameTime() {\n        return this._captureGPUFrameTime;\n    }\n    /**\n     * Enable or disable the GPU frame time capture\n     */\n    set captureGPUFrameTime(value) {\n        if (value === this._captureGPUFrameTime) {\n            return;\n        }\n        this._captureGPUFrameTime = value;\n        this.engine.captureGPUFrameTime(value);\n    }\n    /**\n     * Gets the perf counter used for shader compilation time\n     */\n    get shaderCompilationTimeCounter() {\n        return this._shaderCompilationTime;\n    }\n    /**\n     * Gets the shader compilation time capture status\n     */\n    get captureShaderCompilationTime() {\n        return this._captureShaderCompilationTime;\n    }\n    /**\n     * Enable or disable the shader compilation time capture\n     */\n    set captureShaderCompilationTime(value) {\n        if (value === this._captureShaderCompilationTime) {\n            return;\n        }\n        this._captureShaderCompilationTime = value;\n        if (value) {\n            this._onBeforeShaderCompilationObserver = this.engine.onBeforeShaderCompilationObservable.add(() => {\n                this._shaderCompilationTime.fetchNewFrame();\n                this._shaderCompilationTime.beginMonitoring();\n            });\n            this._onAfterShaderCompilationObserver = this.engine.onAfterShaderCompilationObservable.add(() => {\n                this._shaderCompilationTime.endMonitoring();\n            });\n        }\n        else {\n            this.engine.onBeforeShaderCompilationObservable.remove(this._onBeforeShaderCompilationObserver);\n            this._onBeforeShaderCompilationObserver = null;\n            this.engine.onAfterShaderCompilationObservable.remove(this._onAfterShaderCompilationObserver);\n            this._onAfterShaderCompilationObserver = null;\n        }\n    }\n    /**\n     * Instantiates a new engine instrumentation.\n     * This class can be used to get instrumentation data from a Babylon engine\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#engineinstrumentation\n     * @param engine Defines the engine to instrument\n     */\n    constructor(\n    /**\n     * Define the instrumented engine.\n     */\n    engine) {\n        this.engine = engine;\n        this._captureGPUFrameTime = false;\n        this._captureShaderCompilationTime = false;\n        this._shaderCompilationTime = new PerfCounter();\n        // Observers\n        this._onBeginFrameObserver = null;\n        this._onEndFrameObserver = null;\n        this._onBeforeShaderCompilationObserver = null;\n        this._onAfterShaderCompilationObserver = null;\n    }\n    /**\n     * Dispose and release associated resources.\n     */\n    dispose() {\n        this.engine.onBeginFrameObservable.remove(this._onBeginFrameObserver);\n        this._onBeginFrameObserver = null;\n        this.engine.onEndFrameObservable.remove(this._onEndFrameObserver);\n        this._onEndFrameObserver = null;\n        this.engine.onBeforeShaderCompilationObservable.remove(this._onBeforeShaderCompilationObserver);\n        this._onBeforeShaderCompilationObserver = null;\n        this.engine.onAfterShaderCompilationObservable.remove(this._onAfterShaderCompilationObserver);\n        this._onAfterShaderCompilationObserver = null;\n        this.engine = null;\n    }\n}\n//# sourceMappingURL=engineInstrumentation.js.map","import { Tools } from \"../Misc/tools.js\";\nimport { PerfCounter } from \"../Misc/perfCounter.js\";\n/**\n * This class can be used to get instrumentation data from a Babylon engine\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#sceneinstrumentation\n */\nexport class SceneInstrumentation {\n    // Properties\n    /**\n     * Gets the perf counter used for active meshes evaluation time\n     */\n    get activeMeshesEvaluationTimeCounter() {\n        return this._activeMeshesEvaluationTime;\n    }\n    /**\n     * Gets the active meshes evaluation time capture status\n     */\n    get captureActiveMeshesEvaluationTime() {\n        return this._captureActiveMeshesEvaluationTime;\n    }\n    /**\n     * Enable or disable the active meshes evaluation time capture\n     */\n    set captureActiveMeshesEvaluationTime(value) {\n        if (value === this._captureActiveMeshesEvaluationTime) {\n            return;\n        }\n        this._captureActiveMeshesEvaluationTime = value;\n        if (value) {\n            this._onBeforeActiveMeshesEvaluationObserver = this.scene.onBeforeActiveMeshesEvaluationObservable.add(() => {\n                Tools.StartPerformanceCounter(\"Active meshes evaluation\");\n                this._activeMeshesEvaluationTime.beginMonitoring();\n            });\n            this._onAfterActiveMeshesEvaluationObserver = this.scene.onAfterActiveMeshesEvaluationObservable.add(() => {\n                Tools.EndPerformanceCounter(\"Active meshes evaluation\");\n                this._activeMeshesEvaluationTime.endMonitoring(false);\n            });\n        }\n        else {\n            this.scene.onBeforeActiveMeshesEvaluationObservable.remove(this._onBeforeActiveMeshesEvaluationObserver);\n            this._onBeforeActiveMeshesEvaluationObserver = null;\n            this.scene.onAfterActiveMeshesEvaluationObservable.remove(this._onAfterActiveMeshesEvaluationObserver);\n            this._onAfterActiveMeshesEvaluationObserver = null;\n        }\n    }\n    /**\n     * Gets the perf counter used for render targets render time\n     */\n    get renderTargetsRenderTimeCounter() {\n        return this._renderTargetsRenderTime;\n    }\n    /**\n     * Gets the render targets render time capture status\n     */\n    get captureRenderTargetsRenderTime() {\n        return this._captureRenderTargetsRenderTime;\n    }\n    /**\n     * Enable or disable the render targets render time capture\n     */\n    set captureRenderTargetsRenderTime(value) {\n        if (value === this._captureRenderTargetsRenderTime) {\n            return;\n        }\n        this._captureRenderTargetsRenderTime = value;\n        if (value) {\n            this._onBeforeRenderTargetsRenderObserver = this.scene.onBeforeRenderTargetsRenderObservable.add(() => {\n                Tools.StartPerformanceCounter(\"Render targets rendering\");\n                this._renderTargetsRenderTime.beginMonitoring();\n            });\n            this._onAfterRenderTargetsRenderObserver = this.scene.onAfterRenderTargetsRenderObservable.add(() => {\n                Tools.EndPerformanceCounter(\"Render targets rendering\");\n                this._renderTargetsRenderTime.endMonitoring(false);\n            });\n        }\n        else {\n            this.scene.onBeforeRenderTargetsRenderObservable.remove(this._onBeforeRenderTargetsRenderObserver);\n            this._onBeforeRenderTargetsRenderObserver = null;\n            this.scene.onAfterRenderTargetsRenderObservable.remove(this._onAfterRenderTargetsRenderObserver);\n            this._onAfterRenderTargetsRenderObserver = null;\n        }\n    }\n    /**\n     * Gets the perf counter used for particles render time\n     */\n    get particlesRenderTimeCounter() {\n        return this._particlesRenderTime;\n    }\n    /**\n     * Gets the particles render time capture status\n     */\n    get captureParticlesRenderTime() {\n        return this._captureParticlesRenderTime;\n    }\n    /**\n     * Enable or disable the particles render time capture\n     */\n    set captureParticlesRenderTime(value) {\n        if (value === this._captureParticlesRenderTime) {\n            return;\n        }\n        this._captureParticlesRenderTime = value;\n        if (value) {\n            this._onBeforeParticlesRenderingObserver = this.scene.onBeforeParticlesRenderingObservable.add(() => {\n                Tools.StartPerformanceCounter(\"Particles\");\n                this._particlesRenderTime.beginMonitoring();\n            });\n            this._onAfterParticlesRenderingObserver = this.scene.onAfterParticlesRenderingObservable.add(() => {\n                Tools.EndPerformanceCounter(\"Particles\");\n                this._particlesRenderTime.endMonitoring(false);\n            });\n        }\n        else {\n            this.scene.onBeforeParticlesRenderingObservable.remove(this._onBeforeParticlesRenderingObserver);\n            this._onBeforeParticlesRenderingObserver = null;\n            this.scene.onAfterParticlesRenderingObservable.remove(this._onAfterParticlesRenderingObserver);\n            this._onAfterParticlesRenderingObserver = null;\n        }\n    }\n    /**\n     * Gets the perf counter used for sprites render time\n     */\n    get spritesRenderTimeCounter() {\n        return this._spritesRenderTime;\n    }\n    /**\n     * Gets the sprites render time capture status\n     */\n    get captureSpritesRenderTime() {\n        return this._captureSpritesRenderTime;\n    }\n    /**\n     * Enable or disable the sprites render time capture\n     */\n    set captureSpritesRenderTime(value) {\n        if (value === this._captureSpritesRenderTime) {\n            return;\n        }\n        this._captureSpritesRenderTime = value;\n        if (!this.scene.spriteManagers) {\n            return;\n        }\n        if (value) {\n            this._onBeforeSpritesRenderingObserver = this.scene.onBeforeSpritesRenderingObservable.add(() => {\n                Tools.StartPerformanceCounter(\"Sprites\");\n                this._spritesRenderTime.beginMonitoring();\n            });\n            this._onAfterSpritesRenderingObserver = this.scene.onAfterSpritesRenderingObservable.add(() => {\n                Tools.EndPerformanceCounter(\"Sprites\");\n                this._spritesRenderTime.endMonitoring(false);\n            });\n        }\n        else {\n            this.scene.onBeforeSpritesRenderingObservable.remove(this._onBeforeSpritesRenderingObserver);\n            this._onBeforeSpritesRenderingObserver = null;\n            this.scene.onAfterSpritesRenderingObservable.remove(this._onAfterSpritesRenderingObserver);\n            this._onAfterSpritesRenderingObserver = null;\n        }\n    }\n    /**\n     * Gets the perf counter used for physics time\n     */\n    get physicsTimeCounter() {\n        return this._physicsTime;\n    }\n    /**\n     * Gets the physics time capture status\n     */\n    get capturePhysicsTime() {\n        return this._capturePhysicsTime;\n    }\n    /**\n     * Enable or disable the physics time capture\n     */\n    set capturePhysicsTime(value) {\n        if (value === this._capturePhysicsTime) {\n            return;\n        }\n        if (!this.scene.onBeforePhysicsObservable) {\n            return;\n        }\n        this._capturePhysicsTime = value;\n        if (value) {\n            this._onBeforePhysicsObserver = this.scene.onBeforePhysicsObservable.add(() => {\n                Tools.StartPerformanceCounter(\"Physics\");\n                this._physicsTime.beginMonitoring();\n            });\n            this._onAfterPhysicsObserver = this.scene.onAfterPhysicsObservable.add(() => {\n                Tools.EndPerformanceCounter(\"Physics\");\n                this._physicsTime.endMonitoring();\n            });\n        }\n        else {\n            this.scene.onBeforePhysicsObservable.remove(this._onBeforePhysicsObserver);\n            this._onBeforePhysicsObserver = null;\n            this.scene.onAfterPhysicsObservable.remove(this._onAfterPhysicsObserver);\n            this._onAfterPhysicsObserver = null;\n        }\n    }\n    /**\n     * Gets the perf counter used for animations time\n     */\n    get animationsTimeCounter() {\n        return this._animationsTime;\n    }\n    /**\n     * Gets the animations time capture status\n     */\n    get captureAnimationsTime() {\n        return this._captureAnimationsTime;\n    }\n    /**\n     * Enable or disable the animations time capture\n     */\n    set captureAnimationsTime(value) {\n        if (value === this._captureAnimationsTime) {\n            return;\n        }\n        this._captureAnimationsTime = value;\n        if (value) {\n            this._onAfterAnimationsObserver = this.scene.onAfterAnimationsObservable.add(() => {\n                this._animationsTime.endMonitoring();\n            });\n        }\n        else {\n            this.scene.onAfterAnimationsObservable.remove(this._onAfterAnimationsObserver);\n            this._onAfterAnimationsObserver = null;\n        }\n    }\n    /**\n     * Gets the perf counter used for frame time capture\n     */\n    get frameTimeCounter() {\n        return this._frameTime;\n    }\n    /**\n     * Gets the frame time capture status\n     */\n    get captureFrameTime() {\n        return this._captureFrameTime;\n    }\n    /**\n     * Enable or disable the frame time capture\n     */\n    set captureFrameTime(value) {\n        this._captureFrameTime = value;\n    }\n    /**\n     * Gets the perf counter used for inter-frames time capture\n     */\n    get interFrameTimeCounter() {\n        return this._interFrameTime;\n    }\n    /**\n     * Gets the inter-frames time capture status\n     */\n    get captureInterFrameTime() {\n        return this._captureInterFrameTime;\n    }\n    /**\n     * Enable or disable the inter-frames time capture\n     */\n    set captureInterFrameTime(value) {\n        this._captureInterFrameTime = value;\n    }\n    /**\n     * Gets the perf counter used for render time capture\n     */\n    get renderTimeCounter() {\n        return this._renderTime;\n    }\n    /**\n     * Gets the render time capture status\n     */\n    get captureRenderTime() {\n        return this._captureRenderTime;\n    }\n    /**\n     * Enable or disable the render time capture\n     */\n    set captureRenderTime(value) {\n        if (value === this._captureRenderTime) {\n            return;\n        }\n        this._captureRenderTime = value;\n        if (value) {\n            this._onBeforeDrawPhaseObserver = this.scene.onBeforeDrawPhaseObservable.add(() => {\n                this._renderTime.beginMonitoring();\n                Tools.StartPerformanceCounter(\"Main render\");\n            });\n            this._onAfterDrawPhaseObserver = this.scene.onAfterDrawPhaseObservable.add(() => {\n                this._renderTime.endMonitoring(false);\n                Tools.EndPerformanceCounter(\"Main render\");\n            });\n        }\n        else {\n            this.scene.onBeforeDrawPhaseObservable.remove(this._onBeforeDrawPhaseObserver);\n            this._onBeforeDrawPhaseObserver = null;\n            this.scene.onAfterDrawPhaseObservable.remove(this._onAfterDrawPhaseObserver);\n            this._onAfterDrawPhaseObserver = null;\n        }\n    }\n    /**\n     * Gets the perf counter used for camera render time capture\n     */\n    get cameraRenderTimeCounter() {\n        return this._cameraRenderTime;\n    }\n    /**\n     * Gets the camera render time capture status\n     */\n    get captureCameraRenderTime() {\n        return this._captureCameraRenderTime;\n    }\n    /**\n     * Enable or disable the camera render time capture\n     */\n    set captureCameraRenderTime(value) {\n        if (value === this._captureCameraRenderTime) {\n            return;\n        }\n        this._captureCameraRenderTime = value;\n        if (value) {\n            this._onBeforeCameraRenderObserver = this.scene.onBeforeCameraRenderObservable.add((camera) => {\n                this._cameraRenderTime.beginMonitoring();\n                Tools.StartPerformanceCounter(`Rendering camera ${camera.name}`);\n            });\n            this._onAfterCameraRenderObserver = this.scene.onAfterCameraRenderObservable.add((camera) => {\n                this._cameraRenderTime.endMonitoring(false);\n                Tools.EndPerformanceCounter(`Rendering camera ${camera.name}`);\n            });\n        }\n        else {\n            this.scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n            this._onBeforeCameraRenderObserver = null;\n            this.scene.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);\n            this._onAfterCameraRenderObserver = null;\n        }\n    }\n    /**\n     * Gets the perf counter used for draw calls\n     */\n    get drawCallsCounter() {\n        return this.scene.getEngine()._drawCalls;\n    }\n    /**\n     * Instantiates a new scene instrumentation.\n     * This class can be used to get instrumentation data from a Babylon engine\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#sceneinstrumentation\n     * @param scene Defines the scene to instrument\n     */\n    constructor(\n    /**\n     * Defines the scene to instrument\n     */\n    scene) {\n        this.scene = scene;\n        this._captureActiveMeshesEvaluationTime = false;\n        this._activeMeshesEvaluationTime = new PerfCounter();\n        this._captureRenderTargetsRenderTime = false;\n        this._renderTargetsRenderTime = new PerfCounter();\n        this._captureFrameTime = false;\n        this._frameTime = new PerfCounter();\n        this._captureRenderTime = false;\n        this._renderTime = new PerfCounter();\n        this._captureInterFrameTime = false;\n        this._interFrameTime = new PerfCounter();\n        this._captureParticlesRenderTime = false;\n        this._particlesRenderTime = new PerfCounter();\n        this._captureSpritesRenderTime = false;\n        this._spritesRenderTime = new PerfCounter();\n        this._capturePhysicsTime = false;\n        this._physicsTime = new PerfCounter();\n        this._captureAnimationsTime = false;\n        this._animationsTime = new PerfCounter();\n        this._captureCameraRenderTime = false;\n        this._cameraRenderTime = new PerfCounter();\n        // Observers\n        this._onBeforeActiveMeshesEvaluationObserver = null;\n        this._onAfterActiveMeshesEvaluationObserver = null;\n        this._onBeforeRenderTargetsRenderObserver = null;\n        this._onAfterRenderTargetsRenderObserver = null;\n        this._onAfterRenderObserver = null;\n        this._onBeforeDrawPhaseObserver = null;\n        this._onAfterDrawPhaseObserver = null;\n        this._onBeforeAnimationsObserver = null;\n        this._onBeforeParticlesRenderingObserver = null;\n        this._onAfterParticlesRenderingObserver = null;\n        this._onBeforeSpritesRenderingObserver = null;\n        this._onAfterSpritesRenderingObserver = null;\n        this._onBeforePhysicsObserver = null;\n        this._onAfterPhysicsObserver = null;\n        this._onAfterAnimationsObserver = null;\n        this._onBeforeCameraRenderObserver = null;\n        this._onAfterCameraRenderObserver = null;\n        // Before render\n        this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n            if (this._captureActiveMeshesEvaluationTime) {\n                this._activeMeshesEvaluationTime.fetchNewFrame();\n            }\n            if (this._captureRenderTargetsRenderTime) {\n                this._renderTargetsRenderTime.fetchNewFrame();\n            }\n            if (this._captureFrameTime) {\n                Tools.StartPerformanceCounter(\"Scene rendering\");\n                this._frameTime.beginMonitoring();\n            }\n            if (this._captureInterFrameTime) {\n                this._interFrameTime.endMonitoring();\n            }\n            if (this._captureParticlesRenderTime) {\n                this._particlesRenderTime.fetchNewFrame();\n            }\n            if (this._captureSpritesRenderTime) {\n                this._spritesRenderTime.fetchNewFrame();\n            }\n            if (this._captureAnimationsTime) {\n                this._animationsTime.beginMonitoring();\n            }\n            if (this._captureRenderTime) {\n                this._renderTime.fetchNewFrame();\n            }\n            if (this._captureCameraRenderTime) {\n                this._cameraRenderTime.fetchNewFrame();\n            }\n            this.scene.getEngine()._drawCalls.fetchNewFrame();\n        });\n        // After render\n        this._onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {\n            if (this._captureFrameTime) {\n                Tools.EndPerformanceCounter(\"Scene rendering\");\n                this._frameTime.endMonitoring();\n            }\n            if (this._captureRenderTime) {\n                this._renderTime.endMonitoring(false);\n            }\n            if (this._captureInterFrameTime) {\n                this._interFrameTime.beginMonitoring();\n            }\n            if (this._captureActiveMeshesEvaluationTime) {\n                this._activeMeshesEvaluationTime.endFrame();\n            }\n            if (this._captureRenderTargetsRenderTime) {\n                this._renderTargetsRenderTime.endFrame();\n            }\n            if (this._captureParticlesRenderTime) {\n                this._particlesRenderTime.endFrame();\n            }\n            if (this._captureSpritesRenderTime) {\n                this._spritesRenderTime.endFrame();\n            }\n            if (this._captureRenderTime) {\n                this._renderTime.endFrame();\n            }\n            if (this._captureCameraRenderTime) {\n                this._cameraRenderTime.endFrame();\n            }\n        });\n    }\n    /**\n     * Dispose and release associated resources.\n     */\n    dispose() {\n        this.scene.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n        this._onAfterRenderObserver = null;\n        this.scene.onBeforeActiveMeshesEvaluationObservable.remove(this._onBeforeActiveMeshesEvaluationObserver);\n        this._onBeforeActiveMeshesEvaluationObserver = null;\n        this.scene.onAfterActiveMeshesEvaluationObservable.remove(this._onAfterActiveMeshesEvaluationObserver);\n        this._onAfterActiveMeshesEvaluationObserver = null;\n        this.scene.onBeforeRenderTargetsRenderObservable.remove(this._onBeforeRenderTargetsRenderObserver);\n        this._onBeforeRenderTargetsRenderObserver = null;\n        this.scene.onAfterRenderTargetsRenderObservable.remove(this._onAfterRenderTargetsRenderObserver);\n        this._onAfterRenderTargetsRenderObserver = null;\n        this.scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);\n        this._onBeforeAnimationsObserver = null;\n        this.scene.onBeforeParticlesRenderingObservable.remove(this._onBeforeParticlesRenderingObserver);\n        this._onBeforeParticlesRenderingObserver = null;\n        this.scene.onAfterParticlesRenderingObservable.remove(this._onAfterParticlesRenderingObserver);\n        this._onAfterParticlesRenderingObserver = null;\n        if (this._onBeforeSpritesRenderingObserver) {\n            this.scene.onBeforeSpritesRenderingObservable.remove(this._onBeforeSpritesRenderingObserver);\n            this._onBeforeSpritesRenderingObserver = null;\n        }\n        if (this._onAfterSpritesRenderingObserver) {\n            this.scene.onAfterSpritesRenderingObservable.remove(this._onAfterSpritesRenderingObserver);\n            this._onAfterSpritesRenderingObserver = null;\n        }\n        this.scene.onBeforeDrawPhaseObservable.remove(this._onBeforeDrawPhaseObserver);\n        this._onBeforeDrawPhaseObserver = null;\n        this.scene.onAfterDrawPhaseObservable.remove(this._onAfterDrawPhaseObserver);\n        this._onAfterDrawPhaseObserver = null;\n        if (this._onBeforePhysicsObserver) {\n            this.scene.onBeforePhysicsObservable.remove(this._onBeforePhysicsObserver);\n            this._onBeforePhysicsObserver = null;\n        }\n        if (this._onAfterPhysicsObserver) {\n            this.scene.onAfterPhysicsObservable.remove(this._onAfterPhysicsObserver);\n            this._onAfterPhysicsObserver = null;\n        }\n        this.scene.onAfterAnimationsObservable.remove(this._onAfterAnimationsObserver);\n        this._onAfterAnimationsObserver = null;\n        this.scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n        this._onBeforeCameraRenderObserver = null;\n        this.scene.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);\n        this._onAfterCameraRenderObserver = null;\n        this.scene = null;\n    }\n}\n//# sourceMappingURL=sceneInstrumentation.js.map","import { Color4 } from \"../../Maths/math.color.js\";\nimport { ShaderMaterial } from \"../shaderMaterial.js\";\nimport \"../../Shaders/color.fragment.js\";\nimport \"../../Shaders/color.vertex.js\";\n/**\n * A material to use for fast depth-only rendering.\n * @since 5.0.0\n */\nexport class OcclusionMaterial extends ShaderMaterial {\n    constructor(name, scene) {\n        super(name, scene, \"color\", {\n            attributes: [\"position\"],\n            uniforms: [\"world\", \"viewProjection\", \"color\"],\n        });\n        this.disableColorWrite = true;\n        this.forceDepthWrite = true;\n        this.setColor4(\"color\", new Color4(0, 0, 0, 1));\n    }\n}\n//# sourceMappingURL=occlusionMaterial.js.map","import { Logger } from \"../../../Misc/logger.js\";\nimport { Vector3, Vector2 } from \"../../../Maths/math.vector.js\";\nimport { Color4, Color3 } from \"../../../Maths/math.color.js\";\nimport { Texture } from \"../../../Materials/Textures/texture.js\";\nimport { ProceduralTexture } from \"./proceduralTexture.js\";\nimport { WebRequest } from \"../../../Misc/webRequest.js\";\n/**\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\n * Custom Procedural textures are the easiest way to create your own procedural in your application.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures#creating-custom-procedural-textures\n */\nexport class CustomProceduralTexture extends ProceduralTexture {\n    /**\n     * Instantiates a new Custom Procedural Texture.\n     * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\n     * Custom Procedural textures are the easiest way to create your own procedural in your application.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures#creating-custom-procedural-textures\n     * @param name Define the name of the texture\n     * @param texturePath Define the folder path containing all the custom texture related files (config, shaders...)\n     * @param size Define the size of the texture to create\n     * @param scene Define the scene the texture belongs to\n     * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\n     * @param generateMipMaps Define if the texture should creates mip maps or not\n     * @param skipJson Define a boolena indicating that there is no json config file to load\n     */\n    constructor(name, texturePath, size, scene, fallbackTexture, generateMipMaps, skipJson) {\n        super(name, size, null, scene, fallbackTexture, generateMipMaps);\n        this._animate = true;\n        this._time = 0;\n        this._texturePath = texturePath;\n        if (fallbackTexture && !(fallbackTexture instanceof Texture)) {\n            skipJson = !!fallbackTexture.skipJson;\n        }\n        if (!skipJson) {\n            //Try to load json\n            this._loadJson(texturePath);\n        }\n        else {\n            this.setFragment(this._texturePath);\n        }\n        this.refreshRate = 1;\n    }\n    _loadJson(jsonUrl) {\n        const noConfigFile = () => {\n            try {\n                this.setFragment(this._texturePath);\n            }\n            catch (ex) {\n                Logger.Log(\"No json or ShaderStore or DOM element found for CustomProceduralTexture\");\n            }\n        };\n        const configFileUrl = jsonUrl + \"/config.json\";\n        const xhr = new WebRequest();\n        xhr.open(\"GET\", configFileUrl);\n        xhr.addEventListener(\"load\", () => {\n            if (xhr.status === 200 || (xhr.responseText && xhr.responseText.length > 0)) {\n                try {\n                    this._config = JSON.parse(xhr.response);\n                    this.updateShaderUniforms();\n                    this.updateTextures();\n                    this.setFragment(this._texturePath + \"/custom\");\n                    this._animate = this._config.animate;\n                    this.refreshRate = this._config.refreshrate;\n                }\n                catch (ex) {\n                    noConfigFile();\n                }\n            }\n            else {\n                noConfigFile();\n            }\n        }, false);\n        xhr.addEventListener(\"error\", () => {\n            noConfigFile();\n        }, false);\n        try {\n            xhr.send();\n        }\n        catch (ex) {\n            Logger.Error(\"CustomProceduralTexture: Error on XHR send request.\");\n        }\n    }\n    /**\n     * Is the texture ready to be used ? (rendered at least once)\n     * @returns true if ready, otherwise, false.\n     */\n    isReady() {\n        if (!super.isReady()) {\n            return false;\n        }\n        for (const name in this._textures) {\n            const texture = this._textures[name];\n            if (!texture.isReady()) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Render the texture to its associated render target.\n     * @param useCameraPostProcess Define if camera post process should be applied to the texture\n     */\n    render(useCameraPostProcess) {\n        const scene = this.getScene();\n        if (this._animate && scene) {\n            this._time += scene.getAnimationRatio() * 0.03;\n            this.updateShaderUniforms();\n        }\n        super.render(useCameraPostProcess);\n    }\n    /**\n     * Update the list of dependant textures samplers in the shader.\n     */\n    updateTextures() {\n        for (let i = 0; i < this._config.sampler2Ds.length; i++) {\n            this.setTexture(this._config.sampler2Ds[i].sample2Dname, new Texture(this._texturePath + \"/\" + this._config.sampler2Ds[i].textureRelativeUrl, this.getScene()));\n        }\n    }\n    /**\n     * Update the uniform values of the procedural texture in the shader.\n     */\n    updateShaderUniforms() {\n        if (this._config) {\n            for (let j = 0; j < this._config.uniforms.length; j++) {\n                const uniform = this._config.uniforms[j];\n                switch (uniform.type) {\n                    case \"float\":\n                        this.setFloat(uniform.name, uniform.value);\n                        break;\n                    case \"color3\":\n                        this.setColor3(uniform.name, new Color3(uniform.r, uniform.g, uniform.b));\n                        break;\n                    case \"color4\":\n                        this.setColor4(uniform.name, new Color4(uniform.r, uniform.g, uniform.b, uniform.a));\n                        break;\n                    case \"vector2\":\n                        this.setVector2(uniform.name, new Vector2(uniform.x, uniform.y));\n                        break;\n                    case \"vector3\":\n                        this.setVector3(uniform.name, new Vector3(uniform.x, uniform.y, uniform.z));\n                        break;\n                }\n            }\n        }\n        this.setFloat(\"time\", this._time);\n    }\n    /**\n     * Define if the texture animates or not.\n     */\n    get animate() {\n        return this._animate;\n    }\n    set animate(value) {\n        this._animate = value;\n    }\n}\n//# sourceMappingURL=customProceduralTexture.js.map","import { Texture } from \"./texture.js\";\n\n/**\n * Class used to store 3D textures containing user data\n */\nexport class RawTexture3D extends Texture {\n    /**\n     * Gets the width of the texture\n     */\n    get width() {\n        return this._texture ? this._texture.width : 0;\n    }\n    /**\n     * Gets the height of the texture\n     */\n    get height() {\n        return this._texture ? this._texture.height : 0;\n    }\n    /**\n     * Gets the depth of the texture\n     */\n    get depth() {\n        return this._texture ? this._texture.depth : 0;\n    }\n    /**\n     * Create a new RawTexture3D\n     * @param data defines the data of the texture\n     * @param width defines the width of the texture\n     * @param height defines the height of the texture\n     * @param depth defines the depth of the texture\n     * @param format defines the texture format to use\n     * @param scene defines the hosting scene\n     * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)\n     * @param invertY defines if texture must be stored with Y axis inverted\n     * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)\n     * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_BYTE, Engine.TEXTURETYPE_FLOAT...)\n     * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n     */\n    constructor(data, width, height, depth, \n    /** Gets or sets the texture format to use */\n    format, scene, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, textureType = 0, creationFlags) {\n        super(null, scene, !generateMipMaps, invertY);\n        this.format = format;\n        this._texture = scene.getEngine().createRawTexture3D(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType, creationFlags);\n        this.is3D = true;\n    }\n    /**\n     * Update the texture with new data\n     * @param data defines the data to store in the texture\n     */\n    update(data) {\n        if (!this._texture) {\n            return;\n        }\n        this._getEngine().updateRawTexture3D(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);\n    }\n}\n//# sourceMappingURL=rawTexture3D.js.map","import { Plane } from \"../../Maths/math.plane.js\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture.js\";\n/**\n * Creates a refraction texture used by refraction channel of the standard material.\n * It is like a mirror but to see through a material.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#refractiontexture\n */\nexport class RefractionTexture extends RenderTargetTexture {\n    /**\n     * Creates a refraction texture used by refraction channel of the standard material.\n     * It is like a mirror but to see through a material.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#refraction\n     * @param name Define the texture name\n     * @param size Define the size of the underlying texture\n     * @param scene Define the scene the refraction belongs to\n     * @param generateMipMaps Define if we need to generate mips level for the refraction\n     */\n    constructor(name, size, scene, generateMipMaps) {\n        super(name, size, scene, generateMipMaps, true);\n        /**\n         * Define the reflection plane we want to use. The refractionPlane is usually set to the constructed refractor.\n         * It is possible to directly set the refractionPlane by directly using a Plane(a, b, c, d) where a, b and c give the plane normal vector (a, b, c) and d is a scalar displacement from the refractionPlane to the origin. However in all but the very simplest of situations it is more straight forward to set it to the refractor as stated in the doc.\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#refraction\n         */\n        this.refractionPlane = new Plane(0, 1, 0, 1);\n        /**\n         * Define how deep under the surface we should see.\n         */\n        this.depth = 2.0;\n        this.onBeforeRenderObservable.add(() => {\n            this.getScene().clipPlane = this.refractionPlane;\n        });\n        this.onAfterRenderObservable.add(() => {\n            this.getScene().clipPlane = null;\n        });\n    }\n    /**\n     * Clone the refraction texture.\n     * @returns the cloned texture\n     */\n    clone() {\n        const scene = this.getScene();\n        if (!scene) {\n            return this;\n        }\n        const textureSize = this.getSize();\n        const newTexture = new RefractionTexture(this.name, textureSize.width, scene, this._generateMipMaps);\n        // Base texture\n        newTexture.hasAlpha = this.hasAlpha;\n        newTexture.level = this.level;\n        // Refraction Texture\n        newTexture.refractionPlane = this.refractionPlane.clone();\n        if (this.renderList) {\n            newTexture.renderList = this.renderList.slice(0);\n        }\n        newTexture.depth = this.depth;\n        return newTexture;\n    }\n    /**\n     * Serialize the texture to a JSON representation you could use in Parse later on\n     * @returns the serialized JSON representation\n     */\n    serialize() {\n        if (!this.name) {\n            return null;\n        }\n        const serializationObject = super.serialize();\n        serializationObject.mirrorPlane = this.refractionPlane.asArray();\n        serializationObject.depth = this.depth;\n        return serializationObject;\n    }\n}\n//# sourceMappingURL=refractionTexture.js.map","import { ThinTexture } from \"./thinTexture.js\";\n/**\n * This is a tiny helper class to wrap a RenderTargetWrapper in a texture\n * usable as the input of an effect.\n */\nexport class ThinRenderTargetTexture extends ThinTexture {\n    /**\n     * Gets the render target wrapper associated with this render target\n     */\n    get renderTarget() {\n        return this._renderTarget;\n    }\n    /**\n     * Instantiates a new ThinRenderTargetTexture.\n     * Tiny helper class to wrap a RenderTargetWrapper in a texture.\n     * This can be used as an internal texture wrapper in ThinEngine to benefit from the cache and to hold on the associated RTT\n     * @param engine Define the internalTexture to wrap\n     * @param size Define the size of the RTT to create\n     * @param options Define rendertarget options\n     */\n    constructor(engine, size, options) {\n        super(null);\n        this._renderTarget = null;\n        this._engine = engine;\n        this._renderTargetOptions = options;\n        this.resize(size);\n    }\n    /**\n     * Resize the texture to a new desired size.\n     * Be careful as it will recreate all the data in the new texture.\n     * @param size Define the new size. It can be:\n     *   - a number for squared texture,\n     *   - an object containing { width: number, height: number }\n     */\n    resize(size) {\n        this._renderTarget?.dispose();\n        this._renderTarget = null;\n        this._texture = null;\n        this._size = size;\n        if (this._engine) {\n            this._renderTarget = this._engine.createRenderTargetTexture(this._size, this._renderTargetOptions);\n        }\n        this._texture = this.renderTarget.texture;\n    }\n    /**\n     * Get the underlying lower level texture from Babylon.\n     * @returns the internal texture\n     */\n    getInternalTexture() {\n        return this._texture;\n    }\n    /**\n     * Get the class name of the texture.\n     * @returns \"ThinRenderTargetTexture\"\n     */\n    getClassName() {\n        return \"ThinRenderTargetTexture\";\n    }\n    /**\n     * Dispose the texture and release its associated resources.\n     * @param disposeOnlyFramebuffers if set to true it will dispose only the frame buffers (default: false)\n     */\n    dispose(disposeOnlyFramebuffers = false) {\n        this._renderTarget?.dispose(true);\n        this._renderTarget = null;\n        if (!disposeOnlyFramebuffers) {\n            super.dispose();\n        }\n    }\n}\n//# sourceMappingURL=thinRenderTargetTexture.js.map","import { TransformBlock } from \"./Blocks/transformBlock.js\";\nimport { VertexOutputBlock } from \"./Blocks/Vertex/vertexOutputBlock.js\";\nimport { FragmentOutputBlock } from \"./Blocks/Fragment/fragmentOutputBlock.js\";\nimport { InputBlock } from \"./Blocks/Input/inputBlock.js\";\nimport { GaussianSplattingBlock } from \"./Blocks/GaussianSplatting/gaussianSplattingBlock.js\";\nimport { GaussianBlock } from \"./Blocks/GaussianSplatting/gaussianBlock.js\";\nimport { SplatReaderBlock } from \"./Blocks/GaussianSplatting/splatReaderBlock.js\";\nimport { NodeMaterialModes } from \"./Enums/nodeMaterialModes.js\";\nimport { NodeMaterialSystemValues } from \"./Enums/nodeMaterialSystemValues.js\";\n/**\n * Clear the material and set it to a default state for gaussian splatting\n * @param nodeMaterial node material to use\n */\nexport function SetToDefaultGaussianSplatting(nodeMaterial) {\n    nodeMaterial.clear();\n    nodeMaterial.editorData = null;\n    // reading splat datas\n    const splatIndex = new InputBlock(\"SplatIndex\");\n    splatIndex.setAsAttribute(\"splatIndex\");\n    const splatReader = new SplatReaderBlock(\"SplatReader\");\n    splatIndex.connectTo(splatReader);\n    // transforming datas into renderable positions\n    const gs = new GaussianSplattingBlock(\"GaussianSplatting\");\n    splatReader.connectTo(gs);\n    // world transformation\n    const worldInput = new InputBlock(\"World\");\n    worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\n    const worldPos = new TransformBlock(\"WorldPos\");\n    splatReader.connectTo(worldPos);\n    worldInput.connectTo(worldPos);\n    worldPos.connectTo(gs, { output: \"xyz\", input: \"splatPosition\" });\n    // view and projections\n    const view = new InputBlock(\"view\");\n    view.setAsSystemValue(NodeMaterialSystemValues.View);\n    const projection = new InputBlock(\"Projection\");\n    projection.setAsSystemValue(NodeMaterialSystemValues.Projection);\n    worldInput.connectTo(gs, { input: \"world\" });\n    view.connectTo(gs, { input: \"view\" });\n    projection.connectTo(gs, { input: \"projection\" });\n    // from color to gaussian color\n    const gaussian = new GaussianBlock(\"Gaussian\");\n    splatReader.connectTo(gaussian, { input: \"splatColor\", output: \"splatColor\" });\n    // fragment and vertex outputs\n    const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    gaussian.connectTo(fragmentOutput);\n    const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\n    gs.connectTo(vertexOutput);\n    // Add to nodes\n    nodeMaterial.addOutputNode(vertexOutput);\n    nodeMaterial.addOutputNode(fragmentOutput);\n    nodeMaterial._mode = NodeMaterialModes.GaussianSplatting;\n}\n//# sourceMappingURL=nodeMaterialDefault.js.map","/**\n * Root class for all node material optimizers\n */\nexport class NodeMaterialOptimizer {\n    /**\n     * Function used to optimize a NodeMaterial graph\n     * @param _vertexOutputNodes defines the list of output nodes for the vertex shader\n     * @param _fragmentOutputNodes defines the list of output nodes for the fragment shader\n     */\n    optimize(_vertexOutputNodes, _fragmentOutputNodes) {\n        // Do nothing by default\n    }\n}\n//# sourceMappingURL=nodeMaterialOptimizer.js.map","import { Effect } from \"./effect.js\";\nimport { RandomGUID } from \"../Misc/guid.js\";\nimport { DrawWrapper } from \"./drawWrapper.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nclass MapMap {\n    constructor() {\n        this.mm = new Map();\n    }\n    get(a, b) {\n        const m = this.mm.get(a);\n        if (m !== undefined) {\n            return m.get(b);\n        }\n        return undefined;\n    }\n    set(a, b, v) {\n        let m = this.mm.get(a);\n        if (m === undefined) {\n            this.mm.set(a, (m = new Map()));\n        }\n        m.set(b, v);\n    }\n}\n/**\n * Class that can be used to wrap a base material to generate accurate shadows when using custom vertex/fragment code in the base material\n */\nexport class ShadowDepthWrapper {\n    /** Gets the standalone status of the wrapper */\n    get standalone() {\n        return this._options?.standalone ?? false;\n    }\n    /** Gets the base material the wrapper is built upon */\n    get baseMaterial() {\n        return this._baseMaterial;\n    }\n    /** Gets the doNotInjectCode status of the wrapper */\n    get doNotInjectCode() {\n        return this._options?.doNotInjectCode ?? false;\n    }\n    /**\n     * Instantiate a new shadow depth wrapper.\n     * It works by injecting some specific code in the vertex/fragment shaders of the base material and is used by a shadow generator to\n     * generate the shadow depth map. For more information, please refer to the documentation:\n     * https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows\n     * @param baseMaterial Material to wrap\n     * @param scene Define the scene the material belongs to\n     * @param options Options used to create the wrapper\n     */\n    constructor(baseMaterial, scene, options) {\n        this._baseMaterial = baseMaterial;\n        this._scene = scene ?? EngineStore.LastCreatedScene;\n        this._options = options;\n        this._subMeshToEffect = new Map();\n        this._subMeshToDepthWrapper = new MapMap();\n        this._meshes = new Map();\n        // Register for onEffectCreated to store the effect of the base material when it is (re)generated. This effect will be used\n        // to create the depth effect later on\n        this._onEffectCreatedObserver = this._baseMaterial.onEffectCreatedObservable.add((params) => {\n            const mesh = params.subMesh?.getMesh();\n            if (mesh && !this._meshes.has(mesh)) {\n                // Register for mesh onDispose to clean up our internal maps when a mesh is disposed\n                this._meshes.set(mesh, mesh.onDisposeObservable.add((mesh) => {\n                    const iterator = this._subMeshToEffect.keys();\n                    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n                        const subMesh = key.value;\n                        if (subMesh?.getMesh() === mesh) {\n                            this._subMeshToEffect.delete(subMesh);\n                            this._deleteDepthWrapperEffect(subMesh);\n                        }\n                    }\n                }));\n            }\n            if (this._subMeshToEffect.get(params.subMesh)?.[0] !== params.effect) {\n                this._subMeshToEffect.set(params.subMesh, [params.effect, this._scene.getEngine().currentRenderPassId]);\n                this._deleteDepthWrapperEffect(params.subMesh);\n            }\n        });\n    }\n    _deleteDepthWrapperEffect(subMesh) {\n        const depthWrapperEntries = this._subMeshToDepthWrapper.mm.get(subMesh);\n        if (depthWrapperEntries) {\n            // find and release the previous depth effect\n            depthWrapperEntries.forEach((depthWrapper) => {\n                depthWrapper.mainDrawWrapper.effect?.dispose();\n            });\n            this._subMeshToDepthWrapper.mm.delete(subMesh); // trigger a depth effect recreation\n        }\n    }\n    /**\n     * Gets the effect to use to generate the depth map\n     * @param subMesh subMesh to get the effect for\n     * @param shadowGenerator shadow generator to get the effect for\n     * @param passIdForDrawWrapper Id of the pass for which the effect from the draw wrapper must be retrieved from\n     * @returns the effect to use to generate the depth map for the subMesh + shadow generator specified\n     */\n    getEffect(subMesh, shadowGenerator, passIdForDrawWrapper) {\n        const entry = this._subMeshToDepthWrapper.mm.get(subMesh)?.get(shadowGenerator);\n        if (!entry) {\n            return null;\n        }\n        let drawWrapper = entry.drawWrapper[passIdForDrawWrapper];\n        if (!drawWrapper) {\n            drawWrapper = entry.drawWrapper[passIdForDrawWrapper] = new DrawWrapper(this._scene.getEngine());\n            drawWrapper.setEffect(entry.mainDrawWrapper.effect, entry.mainDrawWrapper.defines);\n        }\n        return drawWrapper;\n    }\n    /**\n     * Specifies that the submesh is ready to be used for depth rendering\n     * @param subMesh submesh to check\n     * @param defines the list of defines to take into account when checking the effect\n     * @param shadowGenerator combined with subMesh, it defines the effect to check\n     * @param useInstances specifies that instances should be used\n     * @param passIdForDrawWrapper Id of the pass for which the draw wrapper should be created\n     * @returns a boolean indicating that the submesh is ready or not\n     */\n    isReadyForSubMesh(subMesh, defines, shadowGenerator, useInstances, passIdForDrawWrapper) {\n        if (this.standalone) {\n            // will ensure the effect is (re)created for the base material\n            if (!this._baseMaterial.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances)) {\n                return false;\n            }\n        }\n        return this._makeEffect(subMesh, defines, shadowGenerator, passIdForDrawWrapper)?.isReady() ?? false;\n    }\n    /**\n     * Disposes the resources\n     */\n    dispose() {\n        this._baseMaterial.onEffectCreatedObservable.remove(this._onEffectCreatedObserver);\n        this._onEffectCreatedObserver = null;\n        const iterator = this._meshes.entries();\n        for (let entry = iterator.next(); entry.done !== true; entry = iterator.next()) {\n            const [mesh, observer] = entry.value;\n            mesh.onDisposeObservable.remove(observer);\n        }\n    }\n    _makeEffect(subMesh, defines, shadowGenerator, passIdForDrawWrapper) {\n        const engine = this._scene.getEngine();\n        const origEffectAndRenderPassId = this._subMeshToEffect.get(subMesh);\n        if (!origEffectAndRenderPassId) {\n            return null;\n        }\n        const [origEffect, origRenderPassId] = origEffectAndRenderPassId;\n        let params = this._subMeshToDepthWrapper.get(subMesh, shadowGenerator);\n        if (!params) {\n            const mainDrawWrapper = new DrawWrapper(engine);\n            mainDrawWrapper.defines = subMesh._getDrawWrapper(origRenderPassId)?.defines ?? null;\n            params = {\n                drawWrapper: [],\n                mainDrawWrapper,\n                depthDefines: \"\",\n                token: RandomGUID(),\n            };\n            params.drawWrapper[passIdForDrawWrapper] = mainDrawWrapper;\n            this._subMeshToDepthWrapper.set(subMesh, shadowGenerator, params);\n        }\n        const join = defines.join(\"\\n\");\n        if (params.mainDrawWrapper.effect) {\n            if (join === params.depthDefines) {\n                // we already created the depth effect and it is still up to date for this submesh + shadow generator\n                return params.mainDrawWrapper.effect;\n            }\n        }\n        params.depthDefines = join;\n        const uniforms = origEffect.getUniformNames().slice();\n        // the depth effect is either out of date or has not been created yet\n        let vertexCode = origEffect.vertexSourceCodeBeforeMigration, fragmentCode = origEffect.fragmentSourceCodeBeforeMigration;\n        if (!this.doNotInjectCode) {\n            // Declare the shadow map includes\n            const vertexNormalBiasCode = this._options && this._options.remappedVariables\n                ? `#include<shadowMapVertexNormalBias>(${this._options.remappedVariables.join(\",\")})`\n                : `#include<shadowMapVertexNormalBias>`, vertexMetricCode = this._options && this._options.remappedVariables\n                ? `#include<shadowMapVertexMetric>(${this._options.remappedVariables.join(\",\")})`\n                : `#include<shadowMapVertexMetric>`, fragmentSoftTransparentShadow = this._options && this._options.remappedVariables\n                ? `#include<shadowMapFragmentSoftTransparentShadow>(${this._options.remappedVariables.join(\",\")})`\n                : `#include<shadowMapFragmentSoftTransparentShadow>`, fragmentBlockCode = `#include<shadowMapFragment>`, vertexExtraDeclartion = `#include<shadowMapVertexExtraDeclaration>`;\n            // vertex code\n            if (origEffect.shaderLanguage === 0 /* ShaderLanguage.GLSL */) {\n                vertexCode = vertexCode.replace(/void\\s+?main/g, `\\n${vertexExtraDeclartion}\\nvoid main`);\n            }\n            else {\n                vertexCode = vertexCode.replace(/@vertex/g, `\\n${vertexExtraDeclartion}\\n@vertex`);\n            }\n            vertexCode = vertexCode.replace(/#define SHADOWDEPTH_NORMALBIAS|#define CUSTOM_VERTEX_UPDATE_WORLDPOS/g, vertexNormalBiasCode);\n            if (vertexCode.indexOf(\"#define SHADOWDEPTH_METRIC\") !== -1) {\n                vertexCode = vertexCode.replace(/#define SHADOWDEPTH_METRIC/g, vertexMetricCode);\n            }\n            else {\n                vertexCode = vertexCode.replace(/}\\s*$/g, vertexMetricCode + \"\\n}\");\n            }\n            vertexCode = vertexCode.replace(/#define SHADER_NAME.*?\\n|out vec4 glFragColor;\\n/g, \"\");\n            // fragment code\n            const hasLocationForSoftTransparentShadow = fragmentCode.indexOf(\"#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW\") >= 0 || fragmentCode.indexOf(\"#define CUSTOM_FRAGMENT_BEFORE_FOG\") >= 0;\n            const hasLocationForFragment = fragmentCode.indexOf(\"#define SHADOWDEPTH_FRAGMENT\") !== -1;\n            let fragmentCodeToInjectAtEnd = \"\";\n            if (!hasLocationForSoftTransparentShadow) {\n                fragmentCodeToInjectAtEnd = fragmentSoftTransparentShadow + \"\\n\";\n            }\n            else {\n                fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW|#define CUSTOM_FRAGMENT_BEFORE_FOG/g, fragmentSoftTransparentShadow);\n            }\n            fragmentCode = fragmentCode.replace(/void\\s+?main/g, Effect.IncludesShadersStore[\"shadowMapFragmentExtraDeclaration\"] + \"\\nvoid main\");\n            if (hasLocationForFragment) {\n                fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_FRAGMENT/g, fragmentBlockCode);\n            }\n            else {\n                fragmentCodeToInjectAtEnd += fragmentBlockCode + \"\\n\";\n            }\n            if (fragmentCodeToInjectAtEnd) {\n                fragmentCode = fragmentCode.replace(/}\\s*$/g, fragmentCodeToInjectAtEnd + \"}\");\n            }\n            uniforms.push(\"biasAndScaleSM\", \"depthValuesSM\", \"lightDataSM\", \"softTransparentShadowSM\");\n        }\n        params.mainDrawWrapper.effect = engine.createEffect({\n            vertexSource: vertexCode,\n            fragmentSource: fragmentCode,\n            vertexToken: params.token,\n            fragmentToken: params.token,\n        }, {\n            attributes: origEffect.getAttributesNames(),\n            uniformsNames: uniforms,\n            uniformBuffersNames: origEffect.getUniformBuffersNames(),\n            samplers: origEffect.getSamplers(),\n            defines: join + \"\\n\" + origEffect.defines.replace(\"#define SHADOWS\", \"\").replace(/#define SHADOW\\d/g, \"\"),\n            indexParameters: origEffect.getIndexParameters(),\n            shaderLanguage: origEffect.shaderLanguage,\n        }, engine);\n        for (let id = 0; id < params.drawWrapper.length; ++id) {\n            if (id !== passIdForDrawWrapper) {\n                params.drawWrapper[id]?.setEffect(params.mainDrawWrapper.effect, params.mainDrawWrapper.defines);\n            }\n        }\n        return params.mainDrawWrapper.effect;\n    }\n}\n//# sourceMappingURL=shadowDepthWrapper.js.map","import { DetailMapConfiguration } from \"./material.detailMapConfiguration.js\";\nimport { PBRAnisotropicConfiguration } from \"./PBR/pbrAnisotropicConfiguration.js\";\nimport { PBRBaseMaterial } from \"./PBR/pbrBaseMaterial.js\";\nimport { PBRBRDFConfiguration } from \"./PBR/pbrBRDFConfiguration.js\";\nimport { PBRClearCoatConfiguration } from \"./PBR/pbrClearCoatConfiguration.js\";\nimport { PBRIridescenceConfiguration } from \"./PBR/pbrIridescenceConfiguration.js\";\nimport { PBRSheenConfiguration } from \"./PBR/pbrSheenConfiguration.js\";\nimport { PBRSubSurfaceConfiguration } from \"./PBR/pbrSubSurfaceConfiguration.js\";\nimport { StandardMaterial } from \"./standardMaterial.js\";\n/**\n * Creates an instance of the anisotropic plugin\n * @param material parent material the plugin will be created for\n * @returns the plugin instance or null if the plugin is incompatible with material\n */\nexport function createPBRAnisotropicPlugin(material) {\n    if (material instanceof PBRBaseMaterial) {\n        return new PBRAnisotropicConfiguration(material);\n    }\n    return null;\n}\n/**\n * Creates an instance of the brdf plugin\n * @param material parent material the plugin will be created for\n * @returns the plugin instance or null if the plugin is incompatible with material\n */\nexport function createPBRBRDFPlugin(material) {\n    if (material instanceof PBRBaseMaterial) {\n        return new PBRBRDFConfiguration(material);\n    }\n    return null;\n}\n/**\n * Creates an instance of the clear coat plugin\n * @param material parent material the plugin will be created for\n * @returns the plugin instance or null if the plugin is incompatible with material\n */\nexport function createPBRClearCoatPlugin(material) {\n    if (material instanceof PBRBaseMaterial) {\n        return new PBRClearCoatConfiguration(material);\n    }\n    return null;\n}\n/**\n * Creates an instance of the iridescence plugin\n * @param material parent material the plugin will be created for\n * @returns the plugin instance or null if the plugin is incompatible with material\n */\nexport function createPBRIridescencePlugin(material) {\n    if (material instanceof PBRBaseMaterial) {\n        return new PBRIridescenceConfiguration(material);\n    }\n    return null;\n}\n/**\n * Creates an instance of the sheen plugin\n * @param material parent material the plugin will be created for\n * @returns the plugin instance or null if the plugin is incompatible with material\n */\nexport function createPBRSheenPlugin(material) {\n    if (material instanceof PBRBaseMaterial) {\n        return new PBRSheenConfiguration(material);\n    }\n    return null;\n}\n/**\n * Creates an instance of the sub surface plugin\n * @param material parent material the plugin will be created for\n * @returns the plugin instance or null if the plugin is incompatible with material\n */\nexport function createPBRSubSurfacePlugin(material) {\n    if (material instanceof PBRBaseMaterial) {\n        return new PBRSubSurfaceConfiguration(material);\n    }\n    return null;\n}\n/**\n * Creates an instance of the detail map plugin\n * @param material parent material the plugin will be created for\n * @returns the plugin instance or null if the plugin is incompatible with material\n */\nexport function createDetailMapPlugin(material) {\n    if (material instanceof PBRBaseMaterial || material instanceof StandardMaterial) {\n        return new DetailMapConfiguration(material);\n    }\n    return null;\n}\n//# sourceMappingURL=materialPluginFactoryExport.js.map","import { Vector2, Vector3 } from \"./math.vector.js\";\n/**\n * Class used to store (r, theta) vector representation\n */\nexport class Polar {\n    /**\n     * Creates a new Polar object\n     * @param radius the radius of the vector\n     * @param theta the angle of the vector\n     */\n    constructor(radius, theta) {\n        this.radius = radius;\n        this.theta = theta;\n        this.radius = radius;\n        this.theta = theta;\n    }\n    /**\n     * Gets the class name\n     * @returns the string \"Polar\"\n     */\n    getClassName() {\n        return \"Polar\";\n    }\n    /**\n     * Converts the current polar to a string\n     * @returns the current polar as a string\n     */\n    toString() {\n        return JSON.stringify(this);\n    }\n    /**\n     * Converts the current polar to an array\n     * @returns the current polar as an array\n     */\n    asArray() {\n        return [this.radius, this.theta];\n    }\n    /**\n     * Adds the current Polar and the given Polar and stores the result\n     * @param polar the polar to add\n     * @param ref the polar to store the result in\n     * @returns the updated ref\n     */\n    addToRef(polar, ref) {\n        ref.radius = this.radius + polar.radius;\n        ref.theta = this.theta + polar.theta;\n        return ref;\n    }\n    /**\n     * Adds the current Polar and the given Polar\n     * @param polar the polar to add\n     * @returns the sum polar\n     */\n    add(polar) {\n        const ref = new Polar(0, 0);\n        this.addToRef(polar, ref);\n        return ref;\n    }\n    /**\n     * Adds the given polar to the current polar\n     * @param polar the polar to add\n     * @returns the current polar\n     */\n    addInPlace(polar) {\n        this.addToRef(polar, this);\n        return this;\n    }\n    /**\n     * Adds the provided values to the current polar\n     * @param radius the amount to add to the radius\n     * @param theta the amount to add to the theta\n     * @returns the current polar\n     */\n    addInPlaceFromFloats(radius, theta) {\n        this.radius += radius;\n        this.theta += theta;\n        return this;\n    }\n    /**\n     * Subtracts the given Polar from the current Polar and stores the result\n     * @param polar the polar to subtract\n     * @param ref the polar to store the result in\n     * @returns the updated ref\n     */\n    subtractToRef(polar, ref) {\n        ref.radius = this.radius - polar.radius;\n        ref.theta = this.theta - polar.theta;\n        return ref;\n    }\n    /**\n     * Subtracts the given Polar from the current Polar\n     * @param polar the polar to subtract\n     * @returns the difference polar\n     */\n    subtract(polar) {\n        const ref = new Polar(0, 0);\n        this.subtractToRef(polar, ref);\n        return ref;\n    }\n    /**\n     * Subtracts the given Polar from the current Polar\n     * @param polar the polar to subtract\n     * @returns the current polar\n     */\n    subtractInPlace(polar) {\n        this.subtractToRef(polar, this);\n        return this;\n    }\n    /**\n     * Subtracts the given floats from the current polar\n     * @param radius the amount to subtract from the radius\n     * @param theta the amount to subtract from the theta\n     * @param ref the polar to store the result in\n     * @returns the updated ref\n     */\n    subtractFromFloatsToRef(radius, theta, ref) {\n        ref.radius = this.radius - radius;\n        ref.theta = this.theta - theta;\n        return ref;\n    }\n    /**\n     * Subtracts the given floats from the current polar\n     * @param radius the amount to subtract from the radius\n     * @param theta the amount to subtract from the theta\n     * @returns the difference polar\n     */\n    subtractFromFloats(radius, theta) {\n        const ref = new Polar(0, 0);\n        this.subtractFromFloatsToRef(radius, theta, ref);\n        return ref;\n    }\n    /**\n     * Multiplies the given Polar with the current Polar and stores the result\n     * @param polar the polar to multiply\n     * @param ref the polar to store the result in\n     * @returns the updated ref\n     */\n    multiplyToRef(polar, ref) {\n        ref.radius = this.radius * polar.radius;\n        ref.theta = this.theta * polar.theta;\n        return ref;\n    }\n    /**\n     * Multiplies the given Polar with the current Polar\n     * @param polar the polar to multiply\n     * @returns the product polar\n     */\n    multiply(polar) {\n        const ref = new Polar(0, 0);\n        this.multiplyToRef(polar, ref);\n        return ref;\n    }\n    /**\n     * Multiplies the given Polar with the current Polar\n     * @param polar the polar to multiply\n     * @returns the current polar\n     */\n    multiplyInPlace(polar) {\n        this.multiplyToRef(polar, this);\n        return this;\n    }\n    /**\n     * Divides the current Polar by the given Polar and stores the result\n     * @param polar the polar to divide\n     * @param ref the polar to store the result in\n     * @returns the updated ref\n     */\n    divideToRef(polar, ref) {\n        ref.radius = this.radius / polar.radius;\n        ref.theta = this.theta / polar.theta;\n        return ref;\n    }\n    /**\n     * Divides the current Polar by the given Polar\n     * @param polar the polar to divide\n     * @returns the quotient polar\n     */\n    divide(polar) {\n        const ref = new Polar(0, 0);\n        this.divideToRef(polar, ref);\n        return ref;\n    }\n    /**\n     * Divides the current Polar by the given Polar\n     * @param polar the polar to divide\n     * @returns the current polar\n     */\n    divideInPlace(polar) {\n        this.divideToRef(polar, this);\n        return this;\n    }\n    /**\n     * Clones the current polar\n     * @returns a clone of the current polar\n     */\n    clone() {\n        return new Polar(this.radius, this.theta);\n    }\n    /**\n     * Copies the source polar into the current polar\n     * @param source the polar to copy from\n     * @returns the current polar\n     */\n    copyFrom(source) {\n        this.radius = source.radius;\n        this.theta = source.theta;\n        return this;\n    }\n    /**\n     * Copies the given values into the current polar\n     * @param radius the radius to use\n     * @param theta the theta to use\n     * @returns the current polar\n     */\n    copyFromFloats(radius, theta) {\n        this.radius = radius;\n        this.theta = theta;\n        return this;\n    }\n    /**\n     * Scales the current polar and stores the result\n     * @param scale defines the multiplication factor\n     * @param ref where to store the result\n     * @returns the updated ref\n     */\n    scaleToRef(scale, ref) {\n        ref.radius = this.radius * scale;\n        ref.theta = this.theta * scale;\n        return ref;\n    }\n    /**\n     * Scales the current polar and returns a new polar with the scaled coordinates\n     * @param scale defines the multiplication factor\n     * @returns the scaled polar\n     */\n    scale(scale) {\n        const ref = new Polar(0, 0);\n        this.scaleToRef(scale, ref);\n        return ref;\n    }\n    /**\n     * Scales the current polar\n     * @param scale defines the multiplication factor\n     * @returns the current polar\n     */\n    scaleInPlace(scale) {\n        this.scaleToRef(scale, this);\n        return this;\n    }\n    /**\n     * Sets the values of the current polar\n     * @param radius the new radius\n     * @param theta the new theta\n     * @returns the current polar\n     */\n    set(radius, theta) {\n        this.radius = radius;\n        this.theta = theta;\n        return this;\n    }\n    /**\n     * Sets the values of the current polar\n     * @param value the new values\n     * @returns the current polar\n     */\n    setAll(value) {\n        this.set(value, value);\n        return this;\n    }\n    /**\n     * Gets the rectangular coordinates of the current Polar\n     * @param ref the reference to assign the result\n     * @returns the updated reference\n     */\n    toVector2ToRef(ref) {\n        const x = this.radius * Math.cos(this.theta);\n        const y = this.radius * Math.sin(this.theta);\n        ref.set(x, y);\n        return ref;\n    }\n    /**\n     * Gets the rectangular coordinates of the current Polar\n     * @returns the rectangular coordinates\n     */\n    toVector2() {\n        const ref = new Vector2(0, 0);\n        return this.toVector2ToRef(ref);\n    }\n    /**\n     * Converts a given Vector2 to its polar coordinates\n     * @param v the Vector2 to convert\n     * @param ref the reference to assign the result\n     * @returns the updated reference\n     */\n    static FromVector2ToRef(v, ref) {\n        const theta = Math.sign(v.y) * Math.acos(v.x / v.length());\n        ref.radius = v.length();\n        ref.theta = theta;\n        return ref;\n    }\n    /**\n     * Converts a given Vector2 to its polar coordinates\n     * @param v the Vector2 to convert\n     * @returns a Polar\n     */\n    static FromVector2(v) {\n        const polar = new Polar(0, 0);\n        Polar.FromVector2ToRef(v, polar);\n        return polar;\n    }\n    /**\n     * Converts an array of floats to a polar\n     * @param array the array to convert\n     * @returns the converted polar\n     */\n    static FromArray(array) {\n        return new Polar(array[0], array[1]);\n    }\n}\n/**\n * Class used for (radius, theta, phi) vector representation.\n */\nexport class Spherical {\n    /**\n     * Creates a new Spherical object from the given spherical coordinates\n     * @param radius spherical radius\n     * @param theta angle from positive y axis to radial line from 0 to PI (vertical)\n     * @param phi angle from positive x axis measured anticlockwise from -PI to PI (horizontal)\n     */\n    constructor(radius, theta, phi) {\n        this.radius = radius;\n        this.theta = theta;\n        this.phi = phi;\n        this.radius = radius;\n        this.theta = theta;\n        this.phi = phi;\n    }\n    /**\n     * Gets the class name\n     * @returns the string \"Spherical\"\n     */\n    getClassName() {\n        return \"Spherical\";\n    }\n    /**\n     * Converts the current spherical to a string\n     * @returns the current spherical as a string\n     */\n    toString() {\n        return JSON.stringify(this);\n    }\n    /**\n     * Converts the current spherical to an array\n     * @returns the current spherical as an array\n     */\n    asArray() {\n        return [this.radius, this.theta, this.phi];\n    }\n    /**\n     * Adds the current Spherical and the given Spherical and stores the result\n     * @param spherical the spherical to add\n     * @param ref the spherical to store the result in\n     * @returns the updated ref\n     */\n    addToRef(spherical, ref) {\n        ref.radius = this.radius + spherical.radius;\n        ref.theta = this.theta + spherical.theta;\n        ref.phi = this.phi + spherical.phi;\n        return ref;\n    }\n    /**\n     * Adds the current Spherical and the given Spherical\n     * @param spherical the spherical to add\n     * @returns the sum spherical\n     */\n    add(spherical) {\n        const ref = new Spherical(0, 0, 0);\n        this.addToRef(spherical, ref);\n        return ref;\n    }\n    /**\n     * Adds the given spherical to the current spherical\n     * @param spherical the spherical to add\n     * @returns the current spherical\n     */\n    addInPlace(spherical) {\n        this.addToRef(spherical, this);\n        return this;\n    }\n    /**\n     * Adds the provided values to the current spherical\n     * @param radius the amount to add to the radius\n     * @param theta the amount to add to the theta\n     * @param phi the amount to add to the phi\n     * @returns the current spherical\n     */\n    addInPlaceFromFloats(radius, theta, phi) {\n        this.radius += radius;\n        this.theta += theta;\n        this.phi += phi;\n        return this;\n    }\n    /**\n     * Subtracts the given Spherical from the current Spherical and stores the result\n     * @param spherical the spherical to subtract\n     * @param ref the spherical to store the result in\n     * @returns the updated ref\n     */\n    subtractToRef(spherical, ref) {\n        ref.radius = this.radius - spherical.radius;\n        ref.theta = this.theta - spherical.theta;\n        ref.phi = this.phi - spherical.phi;\n        return ref;\n    }\n    /**\n     * Subtracts the given Spherical from the current Spherical\n     * @param spherical the spherical to subtract\n     * @returns the difference spherical\n     */\n    subtract(spherical) {\n        const ref = new Spherical(0, 0, 0);\n        this.subtractToRef(spherical, ref);\n        return ref;\n    }\n    /**\n     * Subtracts the given Spherical from the current Spherical\n     * @param spherical the spherical to subtract\n     * @returns the current spherical\n     */\n    subtractInPlace(spherical) {\n        this.subtractToRef(spherical, this);\n        return this;\n    }\n    /**\n     * Subtracts the given floats from the current spherical\n     * @param radius the amount to subtract from the radius\n     * @param theta the amount to subtract from the theta\n     * @param phi the amount to subtract from the phi\n     * @param ref the spherical to store the result in\n     * @returns the updated ref\n     */\n    subtractFromFloatsToRef(radius, theta, phi, ref) {\n        ref.radius = this.radius - radius;\n        ref.theta = this.theta - theta;\n        ref.phi = this.phi - phi;\n        return ref;\n    }\n    /**\n     * Subtracts the given floats from the current spherical\n     * @param radius the amount to subtract from the radius\n     * @param theta the amount to subtract from the theta\n     * @param phi the amount to subtract from the phi\n     * @returns the difference spherical\n     */\n    subtractFromFloats(radius, theta, phi) {\n        const ref = new Spherical(0, 0, 0);\n        this.subtractFromFloatsToRef(radius, theta, phi, ref);\n        return ref;\n    }\n    /**\n     * Multiplies the given Spherical with the current Spherical and stores the result\n     * @param spherical the spherical to multiply\n     * @param ref the spherical to store the result in\n     * @returns the updated ref\n     */\n    multiplyToRef(spherical, ref) {\n        ref.radius = this.radius * spherical.radius;\n        ref.theta = this.theta * spherical.theta;\n        ref.phi = this.phi * spherical.phi;\n        return ref;\n    }\n    /**\n     * Multiplies the given Spherical with the current Spherical\n     * @param spherical the spherical to multiply\n     * @returns the product spherical\n     */\n    multiply(spherical) {\n        const ref = new Spherical(0, 0, 0);\n        this.multiplyToRef(spherical, ref);\n        return ref;\n    }\n    /**\n     * Multiplies the given Spherical with the current Spherical\n     * @param spherical the spherical to multiply\n     * @returns the current spherical\n     */\n    multiplyInPlace(spherical) {\n        this.multiplyToRef(spherical, this);\n        return this;\n    }\n    /**\n     * Divides the current Spherical by the given Spherical and stores the result\n     * @param spherical the spherical to divide\n     * @param ref the spherical to store the result in\n     * @returns the updated ref\n     */\n    divideToRef(spherical, ref) {\n        ref.radius = this.radius / spherical.radius;\n        ref.theta = this.theta / spherical.theta;\n        ref.phi = this.phi / spherical.phi;\n        return ref;\n    }\n    /**\n     * Divides the current Spherical by the given Spherical\n     * @param spherical the spherical to divide\n     * @returns the quotient spherical\n     */\n    divide(spherical) {\n        const ref = new Spherical(0, 0, 0);\n        this.divideToRef(spherical, ref);\n        return ref;\n    }\n    /**\n     * Divides the current Spherical by the given Spherical\n     * @param spherical the spherical to divide\n     * @returns the current spherical\n     */\n    divideInPlace(spherical) {\n        this.divideToRef(spherical, this);\n        return this;\n    }\n    /**\n     * Clones the current spherical\n     * @returns a clone of the current spherical\n     */\n    clone() {\n        return new Spherical(this.radius, this.theta, this.phi);\n    }\n    /**\n     * Copies the source spherical into the current spherical\n     * @param source the spherical to copy from\n     * @returns the current spherical\n     */\n    copyFrom(source) {\n        this.radius = source.radius;\n        this.theta = source.theta;\n        this.phi = source.phi;\n        return this;\n    }\n    /**\n     * Copies the given values into the current spherical\n     * @param radius the radius to use\n     * @param theta the theta to use\n     * @param phi the phi to use\n     * @returns the current spherical\n     */\n    copyFromFloats(radius, theta, phi) {\n        this.radius = radius;\n        this.theta = theta;\n        this.phi = phi;\n        return this;\n    }\n    /**\n     * Scales the current spherical and stores the result\n     * @param scale defines the multiplication factor\n     * @param ref where to store the result\n     * @returns the updated ref\n     */\n    scaleToRef(scale, ref) {\n        ref.radius = this.radius * scale;\n        ref.theta = this.theta * scale;\n        ref.phi = this.phi * scale;\n        return ref;\n    }\n    /**\n     * Scales the current spherical and returns a new spherical with the scaled coordinates\n     * @param scale defines the multiplication factor\n     * @returns the scaled spherical\n     */\n    scale(scale) {\n        const ref = new Spherical(0, 0, 0);\n        this.scaleToRef(scale, ref);\n        return ref;\n    }\n    /**\n     * Scales the current spherical\n     * @param scale defines the multiplication factor\n     * @returns the current spherical\n     */\n    scaleInPlace(scale) {\n        this.scaleToRef(scale, this);\n        return this;\n    }\n    /**\n     * Sets the values of the current spherical\n     * @param radius the new radius\n     * @param theta the new theta\n     * @param phi the new phi\n     * @returns the current spherical\n     */\n    set(radius, theta, phi) {\n        this.radius = radius;\n        this.theta = theta;\n        this.phi = phi;\n        return this;\n    }\n    /**\n     * Sets the values of the current spherical\n     * @param value the new values\n     * @returns the current spherical\n     */\n    setAll(value) {\n        this.set(value, value, value);\n        return this;\n    }\n    /**\n     * Assigns the rectangular coordinates of the current Spherical to a Vector3\n     * @param ref the Vector3 to update\n     * @returns the updated Vector3\n     */\n    toVector3ToRef(ref) {\n        const x = this.radius * Math.sin(this.theta) * Math.cos(this.phi);\n        const y = this.radius * Math.cos(this.theta);\n        const z = this.radius * Math.sin(this.theta) * Math.sin(this.phi);\n        ref.set(x, y, z);\n        return ref;\n    }\n    /**\n     * Gets a Vector3 from the current spherical coordinates\n     * @returns the (x, y,z) form of the current Spherical\n     */\n    toVector3() {\n        const ref = new Vector3(0, 0, 0);\n        return this.toVector3ToRef(ref);\n    }\n    /**\n     * Assigns the spherical coordinates from a Vector3\n     * @param vector the vector to convert\n     * @param ref the Spherical to update\n     * @returns the updated ref\n     */\n    static FromVector3ToRef(vector, ref) {\n        ref.radius = vector.length();\n        ref.theta = Math.acos(vector.y / ref.radius);\n        ref.phi = Math.atan2(vector.z, vector.x);\n        return ref;\n    }\n    /**\n     * Gets a Spherical from a Vector3\n     * @param vector defines the vector in (x, y, z) coordinate space\n     * @returns a new Spherical\n     */\n    static FromVector3(vector) {\n        const spherical = new Spherical(0, 0, 0);\n        Spherical.FromVector3ToRef(vector, spherical);\n        return spherical;\n    }\n    /**\n     * Converts an array of floats to a spherical\n     * @param array the array to convert\n     * @returns the converted spherical\n     */\n    static FromArray(array) {\n        return new Spherical(array[0], array[1], array[2]);\n    }\n}\n//# sourceMappingURL=math.polar.js.map","import { Vector3, TmpVectors, Matrix } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\n\n/**\n * Create a HotSpotQuery from a picking info\n * @remarks If there is no pickedMesh or the pickedMesh has no indices, the faceId is used as the base index\n * @param pickingInfo picking info to use\n * @returns the created HotSpotQuery\n */\nexport function CreateHotSpotQueryForPickingInfo(pickingInfo) {\n    const indices = pickingInfo.pickedMesh?.getIndices();\n    const base = pickingInfo.faceId * 3;\n    return {\n        pointIndex: indices ? [indices[base], indices[base + 1], indices[base + 2]] : [base, base + 1, base + 2],\n        barycentric: [pickingInfo.bu, pickingInfo.bv, 1 - pickingInfo.bu - pickingInfo.bv],\n    };\n}\n/**\n * Return a transformed local position from a mesh and vertex index\n * @param mesh mesh used to get vertex array from\n * @param index vertex index\n * @param res resulting local position\n * @returns false if it was not possible to compute the position for that vertex\n */\nexport function GetTransformedPosition(mesh, index, res) {\n    const data = mesh.getVerticesData(VertexBuffer.PositionKind);\n    if (!data) {\n        return false;\n    }\n    const base = index * 3;\n    const values = [data[base + 0], data[base + 1], data[base + 2]];\n    if (values.some((value) => isNaN(value ?? Number.NaN))) {\n        return false;\n    }\n    if (mesh.morphTargetManager) {\n        for (let component = 0; component < 3; component++) {\n            let value = values[component];\n            for (let targetCount = 0; targetCount < mesh.morphTargetManager.numTargets; targetCount++) {\n                const target = mesh.morphTargetManager.getTarget(targetCount);\n                const influence = target.influence;\n                if (influence !== 0) {\n                    const targetData = target.getPositions();\n                    if (targetData) {\n                        value += (targetData[base + component] - data[base + component]) * influence;\n                    }\n                }\n            }\n            values[component] = value;\n        }\n    }\n    res.fromArray(values);\n    if (mesh.skeleton) {\n        const matricesIndicesData = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\n        const matricesWeightsData = mesh.getVerticesData(VertexBuffer.MatricesWeightsKind);\n        if (matricesWeightsData && matricesIndicesData) {\n            const needExtras = mesh.numBoneInfluencers > 4;\n            const matricesIndicesExtraData = needExtras ? mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\n            const matricesWeightsExtraData = needExtras ? mesh.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\n            const skeletonMatrices = mesh.skeleton.getTransformMatrices(mesh);\n            const finalMatrix = TmpVectors.Matrix[0];\n            const tempMatrix = TmpVectors.Matrix[1];\n            finalMatrix.reset();\n            const matWeightIdx = index * 4;\n            let inf;\n            let weight;\n            for (inf = 0; inf < 4; inf++) {\n                weight = matricesWeightsData[matWeightIdx + inf];\n                if (weight > 0) {\n                    Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);\n                    finalMatrix.addToSelf(tempMatrix);\n                }\n            }\n            if (matricesIndicesExtraData && matricesWeightsExtraData) {\n                for (inf = 0; inf < 4; inf++) {\n                    weight = matricesWeightsExtraData[matWeightIdx + inf];\n                    if (weight > 0) {\n                        Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);\n                        finalMatrix.addToSelf(tempMatrix);\n                    }\n                }\n            }\n            Vector3.TransformCoordinatesFromFloatsToRef(values[0], values[1], values[2], finalMatrix, res);\n        }\n    }\n    return true;\n}\n/**\n * Compute a world space hotspot position\n * TmpVectors.Vector3[0..4] are modified by this function. Do not use them as result output.\n * @param mesh mesh used to get hotspot from\n * @param hotSpotQuery point indices and barycentric\n * @param resPosition output world position\n * @param resNormal optional output world normal\n * @returns false if it was not possible to compute the hotspot position\n */\nexport function GetHotSpotToRef(mesh, hotSpotQuery, resPosition, resNormal) {\n    resPosition.set(0, 0, 0);\n    for (let i = 0; i < 3; i++) {\n        const index = hotSpotQuery.pointIndex[i];\n        if (!GetTransformedPosition(mesh, index, TmpVectors.Vector3[i])) {\n            return false;\n        }\n        TmpVectors.Vector3[i].scaleAndAddToRef(hotSpotQuery.barycentric[i], resPosition);\n    }\n    // Convert the result to world space\n    Vector3.TransformCoordinatesToRef(resPosition, mesh.getWorldMatrix(), resPosition);\n    // compute normal in world space\n    if (resNormal) {\n        const pointA = TmpVectors.Vector3[0];\n        const pointB = TmpVectors.Vector3[1];\n        const pointC = TmpVectors.Vector3[2];\n        const segmentA = TmpVectors.Vector3[3];\n        const segmentB = TmpVectors.Vector3[4];\n        segmentA.copyFrom(pointB);\n        segmentA.subtractInPlace(pointA);\n        segmentB.copyFrom(pointC);\n        segmentB.subtractInPlace(pointA);\n        segmentA.normalize();\n        segmentB.normalize();\n        Vector3.CrossToRef(segmentA, segmentB, resNormal);\n        // flip normal when face culling is changed\n        const flipNormal = mesh.material &&\n            mesh.material.sideOrientation ===\n                (mesh.getScene().useRightHandedSystem ? 0 : 1);\n        if (flipNormal) {\n            resNormal.scaleInPlace(-1);\n        }\n        // Convert the result to world space\n        Vector3.TransformNormalToRef(resNormal, mesh.getWorldMatrix(), resNormal);\n        resNormal.normalize();\n    }\n    return true;\n}\n//# sourceMappingURL=abstractMesh.hotSpot.js.map","import { Matrix } from \"../Maths/math.vector.js\";\n\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\n/**\n * Class used to render in the mesh UV space\n * @since 5.49.1\n */\nexport class MeshUVSpaceRenderer {\n    static _GetShader(scene, shaderLanguage) {\n        if (!scene._meshUVSpaceRendererShader) {\n            const shader = new ShaderMaterial(\"meshUVSpaceRendererShader\", scene, {\n                vertex: \"meshUVSpaceRenderer\",\n                fragment: \"meshUVSpaceRenderer\",\n            }, {\n                attributes: [\"position\", \"normal\", \"uv\"],\n                uniforms: [\"world\", \"projMatrix\"],\n                samplers: [\"textureSampler\"],\n                needAlphaBlending: true,\n                shaderLanguage: shaderLanguage,\n            });\n            shader.backFaceCulling = false;\n            shader.alphaMode = 2;\n            scene.onDisposeObservable.add(() => {\n                scene._meshUVSpaceRendererShader?.dispose();\n                scene._meshUVSpaceRendererShader = null;\n            });\n            scene._meshUVSpaceRendererShader = shader;\n        }\n        return scene._meshUVSpaceRendererShader;\n    }\n    static _GetMaskShader(scene, shaderLanguage) {\n        if (!scene._meshUVSpaceRendererMaskShader) {\n            const shader = new ShaderMaterial(\"meshUVSpaceRendererMaskShader\", scene, {\n                vertex: \"meshUVSpaceRendererMasker\",\n                fragment: \"meshUVSpaceRendererMasker\",\n            }, {\n                attributes: [\"position\", \"uv\"],\n                uniforms: [\"worldViewProjection\"],\n                shaderLanguage: shaderLanguage,\n            });\n            shader.backFaceCulling = false;\n            shader.alphaMode = 2;\n            scene.onDisposeObservable.add(() => {\n                scene._meshUVSpaceRendererMaskShader?.dispose();\n                scene._meshUVSpaceRendererMaskShader = null;\n            });\n            scene._meshUVSpaceRendererMaskShader = shader;\n        }\n        return scene._meshUVSpaceRendererMaskShader;\n    }\n    static _IsRenderTargetTexture(texture) {\n        return texture.renderList !== undefined;\n    }\n    /**\n     * Gets the shader language used in this material.\n     */\n    get shaderLanguage() {\n        return this._shaderLanguage;\n    }\n    /**\n     * Creates a new MeshUVSpaceRenderer\n     * @param mesh The mesh used for the source UV space\n     * @param scene The scene the mesh belongs to\n     * @param options The options to use when creating the texture\n     */\n    constructor(mesh, scene, options) {\n        this._textureCreatedInternally = false;\n        this._configureUserCreatedTexture = true;\n        this._maskTexture = null;\n        this._finalPostProcess = null;\n        this._shadersLoaded = false;\n        this._isDisposed = false;\n        /**\n         * Clear color of the texture\n         */\n        this.clearColor = new Color4(0, 0, 0, 0);\n        /**\n         * Target texture used for rendering\n         * If you don't set the property, a RenderTargetTexture will be created internally given the options provided to the constructor.\n         * If you provide a RenderTargetTexture, it will be used directly.\n         */\n        this.texture = null;\n        /** Shader language used by the material */\n        this._shaderLanguage = 0 /* ShaderLanguage.GLSL */;\n        this._mesh = mesh;\n        this._scene = scene;\n        this._options = {\n            width: 1024,\n            height: 1024,\n            textureType: 0,\n            generateMipMaps: true,\n            optimizeUVAllocation: true,\n            uvEdgeBlending: false,\n            ...options,\n        };\n        this._initShaderSourceAsync();\n    }\n    async _initShaderSourceAsync() {\n        const engine = this._scene.getEngine();\n        if (engine.isWebGPU) {\n            this._shaderLanguage = 1 /* ShaderLanguage.WGSL */;\n            await Promise.all([\n                import(\"../ShadersWGSL/meshUVSpaceRenderer.vertex.js\"),\n                import(\"../ShadersWGSL/meshUVSpaceRenderer.fragment.js\"),\n                import(\"../ShadersWGSL/meshUVSpaceRendererMasker.vertex.js\"),\n                import(\"../ShadersWGSL/meshUVSpaceRendererMasker.fragment.js\"),\n                import(\"../ShadersWGSL/meshUVSpaceRendererFinaliser.vertex.js\"),\n                import(\"../ShadersWGSL/meshUVSpaceRendererFinaliser.fragment.js\"),\n            ]);\n        }\n        else {\n            await Promise.all([\n                import(\"../Shaders/meshUVSpaceRenderer.vertex.js\"),\n                import(\"../Shaders/meshUVSpaceRenderer.fragment.js\"),\n                import(\"../Shaders/meshUVSpaceRendererMasker.vertex.js\"),\n                import(\"../Shaders/meshUVSpaceRendererMasker.fragment.js\"),\n                import(\"../Shaders/meshUVSpaceRendererFinaliser.vertex.js\"),\n                import(\"../Shaders/meshUVSpaceRendererFinaliser.fragment.js\"),\n            ]);\n        }\n        if (this._isDisposed) {\n            return;\n        }\n        this._shadersLoaded = true;\n    }\n    /**\n     * Checks if the texture is ready to be used\n     * @returns true if the texture is ready to be used\n     */\n    isReady() {\n        if (!this._shadersLoaded) {\n            return false;\n        }\n        if (!this.texture) {\n            this._createDiffuseRTT();\n        }\n        else if (this._configureUserCreatedTexture) {\n            this._configureUserCreatedRTT();\n        }\n        // this.texture is guaranteed to be non-null here as it is created in _createDiffuseRTT above\n        const textureIsReady = MeshUVSpaceRenderer._IsRenderTargetTexture(this.texture) ? this.texture.isReadyForRendering() : this.texture.isReady();\n        const maskIsReady = this._maskTexture?.isReadyForRendering() ?? true;\n        const postProcessIsReady = this._finalPostProcess?.isReady() ?? true;\n        return textureIsReady && maskIsReady && postProcessIsReady;\n    }\n    /**\n     * Projects and renders a texture in the mesh UV space\n     * @param texture The texture\n     * @param position The position of the center of projection (world space coordinates)\n     * @param normal The direction of the projection (world space coordinates)\n     * @param size The size of the projection\n     * @param angle The rotation angle around the direction of the projection (default: 0)\n     * @param checkIsReady If true, it will check if the texture is ready before rendering (default: true). If the texture is not ready, a new attempt will be scheduled in 16ms\n     */\n    renderTexture(texture, position, normal, size, angle = 0, checkIsReady = true) {\n        if (checkIsReady && !this.isReady()) {\n            setTimeout(() => {\n                this.renderTexture(texture, position, normal, size, angle, checkIsReady);\n            }, 16);\n            return;\n        }\n        if (!this.texture) {\n            this._createDiffuseRTT();\n        }\n        else if (this._configureUserCreatedTexture) {\n            this._configureUserCreatedRTT();\n        }\n        // this.texture is guaranteed to be non-null here as it is created in _createDiffuseRTT above\n        if (MeshUVSpaceRenderer._IsRenderTargetTexture(this.texture)) {\n            const matrix = this._createProjectionMatrix(position, normal, size, angle);\n            const shader = MeshUVSpaceRenderer._GetShader(this._scene, this._shaderLanguage);\n            shader.setTexture(\"textureSampler\", texture);\n            shader.setMatrix(\"projMatrix\", matrix);\n            this.texture.render();\n            // We needed the texture only once for the render() call above, so we can remove it from the shader.\n            // It's important to do that, because this texture could be disposed by the user, meaning that shader.isReady() would return false as part of the this.texture.isReadyForRendering() call of isReady()\n            shader.removeTexture(\"textureSampler\");\n        }\n    }\n    /**\n     * Clears the texture map\n     */\n    clear() {\n        if (this.texture && MeshUVSpaceRenderer._IsRenderTargetTexture(this.texture) && this.texture.renderTarget) {\n            const engine = this._scene.getEngine();\n            engine.bindFramebuffer(this.texture.renderTarget);\n            engine.clear(this.clearColor, true, true, true);\n            engine.unBindFramebuffer(this.texture.renderTarget);\n        }\n        if (this._finalPostProcess?.inputTexture) {\n            const engine = this._scene.getEngine();\n            engine.bindFramebuffer(this._finalPostProcess?.inputTexture);\n            engine.clear(this.clearColor, true, true, true);\n            engine.unBindFramebuffer(this._finalPostProcess?.inputTexture);\n        }\n    }\n    /**\n     * Disposes of the resources\n     */\n    dispose() {\n        if (this._textureCreatedInternally) {\n            this.texture?.dispose();\n            this._textureCreatedInternally = false;\n        }\n        this._configureUserCreatedTexture = true;\n        this._maskTexture?.dispose();\n        this._maskTexture = null;\n        this._finalPostProcess?.dispose();\n        this._finalPostProcess = null;\n        this._isDisposed = true;\n    }\n    _configureUserCreatedRTT() {\n        this._configureUserCreatedTexture = false;\n        if (this.texture && MeshUVSpaceRenderer._IsRenderTargetTexture(this.texture)) {\n            this.texture.setMaterialForRendering(this._mesh, MeshUVSpaceRenderer._GetShader(this._scene, this._shaderLanguage));\n            this.texture.onClearObservable.add(() => { });\n            this.texture.renderList = [this._mesh];\n            if (this._options.uvEdgeBlending) {\n                this._createMaskTexture();\n                this._createPostProcess();\n                this.texture.addPostProcess(this._finalPostProcess);\n            }\n        }\n    }\n    _createDiffuseRTT() {\n        this._textureCreatedInternally = true;\n        const texture = this._createRenderTargetTexture(this._options.width, this._options.height);\n        texture.setMaterialForRendering(this._mesh, MeshUVSpaceRenderer._GetShader(this._scene, this._shaderLanguage));\n        this.texture = texture;\n        this._configureUserCreatedTexture = false;\n        if (this._options.uvEdgeBlending) {\n            this._createMaskTexture();\n            this._createPostProcess();\n            texture.addPostProcess(this._finalPostProcess);\n        }\n    }\n    _createMaskTexture() {\n        if (this._maskTexture) {\n            return;\n        }\n        this._maskTexture = new RenderTargetTexture(this._mesh.name + \"_maskTexture\", { width: this._options.width, height: this._options.height }, this._scene, false, // No mipmaps for the mask texture\n        true, 0, false, 2, undefined, undefined, undefined, 6);\n        this._maskTexture.clearColor = new Color4(0, 0, 0, 0);\n        // Render the mesh with the mask material to the mask texture\n        this._maskTexture.renderList.push(this._mesh);\n        this._maskTexture.setMaterialForRendering(this._mesh, MeshUVSpaceRenderer._GetMaskShader(this._scene, this._shaderLanguage));\n        // Ensure the mask texture is updated\n        this._maskTexture.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\n        this._scene.customRenderTargets.push(this._maskTexture);\n    }\n    _createPostProcess() {\n        if (this._finalPostProcess) {\n            return;\n        }\n        this._finalPostProcess = new PostProcess(this._mesh.name + \"_fixSeamsPostProcess\", \"meshUVSpaceRendererFinaliser\", [\"textureSize\"], [\"textureSampler\", \"maskTextureSampler\"], 1.0, null, 1, this._scene.getEngine(), false, null, this._options.textureType, undefined, undefined, undefined, undefined, this._shaderLanguage);\n        this._finalPostProcess.onApplyObservable.add((effect) => {\n            effect.setTexture(\"maskTextureSampler\", this._maskTexture);\n            effect.setFloat2(\"textureSize\", this._options.width, this._options.height);\n        });\n    }\n    _createRenderTargetTexture(width, height) {\n        const rtt = new RenderTargetTexture(this._mesh.name + \"_uvspaceTexture\", { width, height }, this._scene, this._options.generateMipMaps, true, this._options.textureType, false, this._options.generateMipMaps ? 3 : 2, false, false, false, 5);\n        rtt.renderParticles = false;\n        rtt.optimizeUVAllocation = !!this._options.optimizeUVAllocation;\n        rtt.onClearObservable.addOnce(() => {\n            this._scene.getEngine().clear(this.clearColor, true, true, true);\n            rtt.onClearObservable.add(() => { }); // this disables clearing the texture for the next frames\n        });\n        rtt.renderList = [this._mesh];\n        return rtt;\n    }\n    _createProjectionMatrix(position, normal, size, angle = 0) {\n        const yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;\n        const len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);\n        const pitch = Math.atan2(normal.y, len);\n        const p = position.add(normal.scale(size.z * 0.5));\n        const projWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(p.x, p.y, p.z));\n        const inverseProjWorldMatrix = Matrix.Invert(projWorldMatrix);\n        const projMatrix = Matrix.FromArray([2 / size.x, 0, 0, 0, 0, 2 / size.y, 0, 0, 0, 0, 1 / size.z, 0, 0, 0, 0, 1]);\n        const screenMatrix = Matrix.FromArray([0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 1, 0, 0.5, 0.5, 0.0, 1]);\n        return inverseProjWorldMatrix.multiply(projMatrix).multiply(screenMatrix);\n    }\n}\n//# sourceMappingURL=meshUVSpaceRenderer.js.map","import { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector.js\";\nfunction getExtentCorners(extent) {\n    const minX = extent.minimum.x;\n    const minY = extent.minimum.y;\n    const minZ = extent.minimum.z;\n    const maxX = extent.maximum.x;\n    const maxY = extent.maximum.y;\n    const maxZ = extent.maximum.z;\n    return [\n        new Vector3(minX, minY, minZ),\n        new Vector3(maxX, maxY, maxZ),\n        new Vector3(maxX, minY, minZ),\n        new Vector3(minX, maxY, minZ),\n        new Vector3(minX, minY, maxZ),\n        new Vector3(maxX, maxY, minZ),\n        new Vector3(minX, maxY, maxZ),\n        new Vector3(maxX, minY, maxZ),\n    ];\n}\n/**\n * Computes the maximum extents of the given meshes considering animation, skeleton, and morph targets.\n * @param meshes The array of meshes to compute\n * @param animationGroup An optional animation group to animate (must be started to take effect)\n * @param animationStep An optional value indicating the number of seconds to step while looping through the given animation group\n * @returns An array of world space extents corresponding to the given meshes\n */\nexport function computeMaxExtents(meshes, animationGroup = null, animationStep = 1 / 6) {\n    // Local vector to avoid allocations.\n    const position = TmpVectors.Vector3[0];\n    const meshExtents = new Map();\n    const skinnedMeshExtents = new Map();\n    // Compute the non-skinned and skinned mesh extents.\n    const maxLength = meshes.reduce((previous, current) => Math.max(previous, current.getTotalVertices()), 0);\n    const minPositions = Array.from({ length: maxLength }, () => new Vector3());\n    const maxPositions = Array.from({ length: maxLength }, () => new Vector3());\n    for (const mesh of meshes) {\n        const positions = mesh.getVerticesData(VertexBuffer.PositionKind);\n        if (!positions) {\n            continue;\n        }\n        // Initialize min/max positions with the original positions.\n        const numVertices = mesh.getTotalVertices();\n        minPositions.length = Math.max(minPositions.length, numVertices);\n        maxPositions.length = Math.max(minPositions.length, numVertices);\n        for (let i = 0, j = 0; i < numVertices; i++, j += 3) {\n            position.set(positions[j], positions[j + 1], positions[j + 2]);\n            minPositions[i].copyFrom(position);\n            maxPositions[i].copyFrom(position);\n        }\n        // Apply morph targets to the min/max positions.\n        const morphTargetManager = mesh.morphTargetManager;\n        if (morphTargetManager) {\n            for (let targetIndex = 0; targetIndex < morphTargetManager.numTargets; ++targetIndex) {\n                const target = morphTargetManager.getTarget(targetIndex);\n                const positions = target.getPositions();\n                if (positions) {\n                    for (let i = 0, j = 0; i < numVertices; i++, j += 3) {\n                        position.set(positions[j], positions[j + 1], positions[j + 2]);\n                        minPositions[i].minimizeInPlace(position);\n                        maxPositions[i].maximizeInPlace(position);\n                    }\n                }\n            }\n        }\n        // Compute extent per mesh.\n        const skeleton = mesh.skeleton;\n        const weights = skeleton ? mesh.getVerticesData(VertexBuffer.MatricesWeightsKind) : null;\n        const indices = skeleton ? mesh.getVerticesData(VertexBuffer.MatricesIndicesKind) : null;\n        if (weights && indices) {\n            // Compute extent per bone for skinned meshes.\n            const needsExtra = mesh.numBoneInfluencers > 4;\n            const weightsExtra = needsExtra ? mesh.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\n            const indicesExtra = needsExtra ? mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\n            const perBoneExtents = skinnedMeshExtents.get(mesh.uniqueId) || new Map();\n            skinnedMeshExtents.set(mesh.uniqueId, perBoneExtents);\n            const updateExtents = (i, j, weights, indices) => {\n                for (let k = j; k < j + 4; k++) {\n                    if (weights[k] > 0) {\n                        const boneIndex = indices[k];\n                        const extent = perBoneExtents.get(boneIndex);\n                        if (extent) {\n                            extent.minimum.minimizeInPlace(minPositions[i]);\n                            extent.maximum.maximizeInPlace(maxPositions[i]);\n                        }\n                        else {\n                            perBoneExtents.set(boneIndex, {\n                                minimum: minPositions[i].clone(),\n                                maximum: maxPositions[i].clone(),\n                            });\n                        }\n                    }\n                }\n            };\n            for (let i = 0, j = 0; i < numVertices; i++, j += 4) {\n                updateExtents(i, j, weights, indices);\n                if (weightsExtra && indicesExtra) {\n                    updateExtents(i, j, weightsExtra, indicesExtra);\n                }\n            }\n        }\n        else {\n            // Compute extent for the whole mesh for non-skinned meshes.\n            const extent = meshExtents.get(mesh.uniqueId) || {\n                minimum: new Vector3().setAll(Number.POSITIVE_INFINITY),\n                maximum: new Vector3().setAll(Number.NEGATIVE_INFINITY),\n            };\n            meshExtents.set(mesh.uniqueId, extent);\n            for (let i = 0; i < numVertices; i++) {\n                extent.minimum.minimizeInPlace(minPositions[i]);\n                extent.maximum.maximizeInPlace(maxPositions[i]);\n            }\n        }\n    }\n    // Create the 8 corners of each non-skinned and skinned extent.\n    const meshCorners = new Map();\n    const skinnedMeshCorners = new Map();\n    for (const mesh of meshes) {\n        const extent = meshExtents.get(mesh.uniqueId);\n        if (extent) {\n            meshCorners.set(mesh.uniqueId, getExtentCorners(extent));\n        }\n        else {\n            const perBoneExtents = skinnedMeshExtents.get(mesh.uniqueId);\n            if (perBoneExtents) {\n                const bones = mesh.skeleton.bones;\n                const perBoneCorners = new Map();\n                skinnedMeshCorners.set(mesh.uniqueId, perBoneCorners);\n                perBoneExtents.forEach((extent, boneIndex) => {\n                    const corners = getExtentCorners(extent);\n                    // Transform the coordinates of the corners for skinned meshes to bone space.\n                    const inverseBindMatrix = bones[boneIndex].getAbsoluteInverseBindMatrix();\n                    for (const corner of corners) {\n                        Vector3.TransformCoordinatesToRef(corner, inverseBindMatrix, corner);\n                    }\n                    perBoneCorners.set(boneIndex, corners);\n                });\n            }\n        }\n    }\n    const maxExtents = Array.from({ length: meshes.length }, () => ({\n        minimum: new Vector3().setAll(Number.POSITIVE_INFINITY),\n        maximum: new Vector3().setAll(Number.NEGATIVE_INFINITY),\n    }));\n    const updateMaxExtents = () => {\n        for (let i = 0; i < meshes.length; i++) {\n            const mesh = meshes[i];\n            const positions = mesh.getVerticesData(VertexBuffer.PositionKind);\n            if (!positions) {\n                continue;\n            }\n            const worldMatrix = mesh.computeWorldMatrix(true);\n            const skeleton = mesh.skeleton;\n            if (skeleton) {\n                skeleton.prepare(true);\n                const bones = skeleton.bones;\n                const perBoneCorners = skinnedMeshCorners.get(mesh.uniqueId);\n                perBoneCorners.forEach((corners, boneIndex) => {\n                    // Transform the per-bone corners into world space and update the max extent for each corner.\n                    for (const corner of corners) {\n                        const matrix = bones[boneIndex].getFinalMatrix().multiplyToRef(worldMatrix, TmpVectors.Matrix[0]);\n                        Vector3.TransformCoordinatesToRef(corner, matrix, position);\n                        maxExtents[i].minimum.minimizeInPlace(position);\n                        maxExtents[i].maximum.maximizeInPlace(position);\n                    }\n                });\n            }\n            else {\n                // Transform the corners into world space and update the max extent for each corner.\n                for (const corner of meshCorners.get(mesh.uniqueId)) {\n                    Vector3.TransformCoordinatesToRef(corner, worldMatrix, position);\n                    maxExtents[i].minimum.minimizeInPlace(position);\n                    maxExtents[i].maximum.maximizeInPlace(position);\n                }\n            }\n        }\n    };\n    if (animationGroup && animationGroup.isStarted) {\n        const currentFrame = animationGroup.getCurrentFrame();\n        const step = animationStep / animationGroup.getLength(0, 1);\n        for (let frame = animationGroup.from; frame <= animationGroup.to; frame += step) {\n            animationGroup.goToFrame(frame);\n            updateMaxExtents();\n        }\n        animationGroup.goToFrame(currentFrame);\n    }\n    else {\n        updateMaxExtents();\n    }\n    return maxExtents;\n}\n//# sourceMappingURL=meshUtils.js.map","import { RawTexture3D } from \"../Materials/Textures/rawTexture3D.js\";\nimport { MaterialPluginBase } from \"../Materials/materialPluginBase.js\";\n\n/**\n * Material plugin to add hardware accelerated lattice support\n * @see [webgl2](https://playground.babylonjs.com/#HBZD72#5)\n * @see [webgpu](https://playground.babylonjs.com/#HBZD72#6)\n */\nexport class LatticePluginMaterial extends MaterialPluginBase {\n    /**\n     * Create a new LatticePluginMaterial\n     * @param lattice defines the lattice this plugin is associated with\n     * @param material defines the material this plugin is associated with\n     */\n    constructor(lattice, material) {\n        super(material, \"Lattice\", 200);\n        this._lattice = lattice;\n        this.refreshData();\n        // let's enable it by default\n        this._enable(true);\n    }\n    /**\n     * Get the class name of the plugin\n     * @returns the string \"LatticePluginMaterial\"\n     */\n    getClassName() {\n        return \"LatticePluginMaterial\";\n    }\n    /**\n     * Defines if the plugin supports the specified shader language\n     * @param shaderLanguage defines the shader language to check\n     * @returns true if supported, false otherwise\n     */\n    isCompatible(shaderLanguage) {\n        switch (shaderLanguage) {\n            case 0 /* ShaderLanguage.GLSL */:\n            case 1 /* ShaderLanguage.WGSL */:\n                return true;\n            default:\n                return false;\n        }\n    }\n    /**\n     * Must be called when the lattice data was updated\n     */\n    refreshData() {\n        const length = this._lattice.resolutionX * this._lattice.resolutionY * this._lattice.resolutionZ * 4;\n        if (!this._latticeData || this._latticeData.length !== length) {\n            this._latticeData = new Float32Array(length);\n        }\n        for (let i = 0; i < this._lattice.resolutionX; i++) {\n            for (let j = 0; j < this._lattice.resolutionY; j++) {\n                for (let k = 0; k < this._lattice.resolutionZ; k++) {\n                    const control = this._lattice.data[i][j][k];\n                    const index = i + this._lattice.resolutionX * (j + this._lattice.resolutionY * k);\n                    control.toArray(this._latticeData, index * 4);\n                }\n            }\n        }\n        if (!this._latticeDataTexture ||\n            this._latticeDataTexture.width !== this._lattice.resolutionX ||\n            this._latticeDataTexture.height !== this._lattice.resolutionY ||\n            this._latticeDataTexture.depth !== this._lattice.resolutionZ) {\n            if (this._latticeDataTexture) {\n                this._latticeDataTexture.dispose();\n            }\n            this._latticeDataTexture = new RawTexture3D(this._latticeData, this._lattice.resolutionX, this._lattice.resolutionY, this._lattice.resolutionZ, 5, this._material.getScene(), false, false, 1, 1);\n        }\n        else {\n            this._latticeDataTexture.update(this._latticeData);\n        }\n    }\n    /**\n     * Gets the description of the uniforms to add to the ubo (if engine supports ubos) or to inject directly in the vertex/fragment shaders (if engine does not support ubos)\n     * @param shaderLanguage The shader language to use.\n     * @returns the description of the uniforms\n     */\n    getUniforms(shaderLanguage = 0 /* ShaderLanguage.GLSL */) {\n        if (shaderLanguage === 1 /* ShaderLanguage.WGSL */) {\n            // For webgpu we only define the UBO with the correct type and size.\n            return {\n                ubo: [\n                    { name: \"lattice_cellSize\", size: 3, type: \"vec3\" },\n                    { name: \"lattice_min\", size: 3, type: \"vec3\" },\n                    { name: \"lattice_max\", size: 3, type: \"vec3\" },\n                    { name: \"lattice_resolution\", size: 3, type: \"vec3\" },\n                    { name: \"lattice_position\", size: 3, type: \"vec3\" },\n                ],\n            };\n        }\n        return {\n            // first, define the UBO with the correct type and size.\n            ubo: [\n                { name: \"lattice_cellSize\", size: 3, type: \"vec3\" },\n                { name: \"lattice_min\", size: 3, type: \"vec3\" },\n                { name: \"lattice_max\", size: 3, type: \"vec3\" },\n                { name: \"lattice_resolution\", size: 3, type: \"vec3\" },\n                { name: \"lattice_position\", size: 3, type: \"vec3\" },\n            ],\n            // now, on the vertex shader, add the uniform itself in case uniform buffers are not supported by the engine\n            vertex: `\r\n                    uniform vec3 lattice_cellSize;\r\n                    uniform vec3 lattice_min;\r\n                    uniform vec3 lattice_max;\r\n                    uniform vec3 lattice_resolution;\r\n                    uniform vec3 lattice_position;\r\n                    `,\n        };\n    }\n    /**\n     * Binds the material data.\n     * @param uniformBuffer defines the Uniform buffer to fill in.\n     */\n    bindForSubMesh(uniformBuffer) {\n        this._lattice.updateInternals();\n        uniformBuffer.updateVector3(\"lattice_cellSize\", this._lattice.cellSize);\n        uniformBuffer.updateVector3(\"lattice_min\", this._lattice.min);\n        uniformBuffer.updateVector3(\"lattice_max\", this._lattice.max);\n        uniformBuffer.updateFloat3(\"lattice_resolution\", this._lattice.resolutionX, this._lattice.resolutionY, this._lattice.resolutionZ);\n        uniformBuffer.updateVector3(\"lattice_position\", this._lattice.position);\n        uniformBuffer.setTexture(\"latticeData\", this._latticeDataTexture);\n    }\n    /**\n     * Gets the samplers used by the plugin.\n     * @param samplers list that the sampler names should be added to.\n     */\n    getSamplers(samplers) {\n        samplers.push(\"latticeData\");\n    }\n    _prepareCode(shaderLanguage = 0 /* ShaderLanguage.GLSL */) {\n        if (this._code) {\n            return this._code;\n        }\n        let code = `\r\n            if (positionUpdated.x >= lattice_min.x && positionUpdated.x <= lattice_max.x &&\r\n                positionUpdated.y >= lattice_min.y && positionUpdated.y <= lattice_max.y &&\r\n                positionUpdated.z >= lattice_min.z && positionUpdated.z <= lattice_max.z) {\r\n\r\n                // Map vertex position to lattice local coordinates\r\n                vec3d localPos = vec3c((positionUpdated.x - lattice_min.x) / lattice_cellSize.x, (positionUpdated.y - lattice_min.y) / lattice_cellSize.y, (positionUpdated.z - lattice_min.z) / lattice_cellSize.z);\r\n\r\n                // Get integer lattice indices\r\n                intd i0 = intc(floor(localPos.x));\r\n                intd j0 = intc(floor(localPos.y));\r\n                intd k0 = intc(floor(localPos.z));\r\n\r\n                intd resX = intc(lattice_resolution.x) - 1;\r\n                intd resY = intc(lattice_resolution.y) - 1;\r\n                intd resZ = intc(lattice_resolution.z) - 1;\r\n\r\n                intd i1 = min(i0 + 1, resX);\r\n                intd j1 = min(j0 + 1, resY);\r\n                intd k1 = min(k0 + 1, resZ);\r\n\r\n                // Compute interpolation weights\r\n                floatd tx = localPos.x - floatc(i0);\r\n                floatd ty = localPos.y - floatc(j0);\r\n                floatd tz = localPos.z - floatc(k0);\r\n\r\n                // Ensure indices are within bounds\r\n                intd ii0 = clamp(i0, 0, resX);\r\n                intd jj0 = clamp(j0, 0, resY);\r\n                intd kk0 = clamp(k0, 0, resZ);\r\n                intd ii1 = clamp(i1, 0, resX);\r\n                intd jj1 = clamp(j1, 0, resY);\r\n                intd kk1 = clamp(k1, 0, resZ);\r\n\r\n                // Get lattice control points\r\n                vec3d p000 = texelFetch(latticeData, ivec3c(ii0, jj0, kk0), 0).rgb;\r\n                vec3d p100 = texelFetch(latticeData, ivec3c(ii1, jj0, kk0), 0).rgb;\r\n                vec3d p010 = texelFetch(latticeData, ivec3c(ii0, jj1, kk0), 0).rgb;\r\n                vec3d p110 = texelFetch(latticeData, ivec3c(ii1, jj1, kk0), 0).rgb;\r\n                vec3d p001 = texelFetch(latticeData, ivec3c(ii0, jj0, kk1), 0).rgb;\r\n                vec3d p101 = texelFetch(latticeData, ivec3c(ii1, jj0, kk1), 0).rgb;\r\n                vec3d p011 = texelFetch(latticeData, ivec3c(ii0, jj1, kk1), 0).rgb;\r\n                vec3d p111 = texelFetch(latticeData, ivec3c(ii1, jj1, kk1), 0).rgb;\r\n\r\n                // Trilinear interpolation\r\n                vec3d p00 = mix(p000, p100, tx);\r\n                vec3d p01 = mix(p001, p101, tx);\r\n                vec3d p10 = mix(p010, p110, tx);\r\n                vec3d p11 = mix(p011, p111, tx);\r\n\r\n                vec3d p0 = mix(p00, p10, ty);\r\n                vec3d p1 = mix(p01, p11, ty);\r\n\r\n                vec3d deformedPos = mix(p0, p1, tz);\r\n                positionUpdated = deformedPos + lattice_position;\r\n            };\r\n        `;\n        if (shaderLanguage === 1 /* ShaderLanguage.WGSL */) {\n            code =\n                `\r\n                let lattice_min = uniforms.lattice_min;\r\n                let lattice_max = uniforms.lattice_max;\r\n                let lattice_resolution = uniforms.lattice_resolution;\r\n                let lattice_position = uniforms.lattice_position;\r\n                let lattice_cellSize = uniforms.lattice_cellSize;\r\n            ` + code;\n            code = code.replace(/ivec3c/g, \"vec3i\");\n            code = code.replace(/vec3d/g, \"var\");\n            code = code.replace(/vec3c/g, \"vec3f\");\n            code = code.replace(/intd/g, \"var\");\n            code = code.replace(/intc/g, \"i32\");\n            code = code.replace(/floatd/g, \"var\");\n            code = code.replace(/floatc/g, \"f32\");\n            code = code.replace(/texelFetch/g, \"textureLoad\");\n        }\n        else {\n            code = code.replace(/ivec3c/g, \"ivec3\");\n            code = code.replace(/vec3d/g, \"vec3\");\n            code = code.replace(/vec3c/g, \"vec3\");\n            code = code.replace(/intd/g, \"int\");\n            code = code.replace(/intc/g, \"int\");\n            code = code.replace(/floatd/g, \"float\");\n            code = code.replace(/floatc/g, \"float\");\n        }\n        this._code = code;\n        return this._code;\n    }\n    /**\n     * Returns a list of custom shader code fragments to customize the shader.\n     * @param shaderType \"vertex\" or \"fragment\"\n     * @param shaderLanguage The shader language to use.\n     * @returns null if no code to be added, or a list of pointName =\\> code.\n     */\n    getCustomCode(shaderType, shaderLanguage = 0 /* ShaderLanguage.GLSL */) {\n        if (shaderType === \"vertex\") {\n            // we're adding this specific code at the end of the main() function\n            if (shaderLanguage === 1 /* ShaderLanguage.WGSL */) {\n                return {\n                    CUSTOM_VERTEX_DEFINITIONS: `\r\n                        var latticeData: texture_3d<f32>;\r\n                    `,\n                    CUSTOM_VERTEX_UPDATE_POSITION: this._prepareCode(shaderLanguage),\n                };\n            }\n            return {\n                CUSTOM_VERTEX_DEFINITIONS: `\r\n                    precision highp sampler3D;\r\n                    uniform sampler3D latticeData;\r\n                `,\n                CUSTOM_VERTEX_UPDATE_POSITION: this._prepareCode(shaderLanguage),\n            };\n        }\n        // for other shader types we're not doing anything, return null\n        return null;\n    }\n    /**\n     * Disposes the resources of the material.\n     */\n    dispose() {\n        if (this._latticeDataTexture) {\n            this._latticeDataTexture.dispose();\n            this._latticeDataTexture = null;\n        }\n    }\n}\n//# sourceMappingURL=lattice.material.js.map","import { Vector3 } from \"../Maths/math.vector.js\";\n/**\n * Class used to explode meshes (ie. to have a center and move them away from that center to better see the overall organization)\n */\nexport class MeshExploder {\n    /**\n     * Explodes meshes from a center mesh.\n     * @param meshes The meshes to explode.\n     * @param centerMesh The mesh to be center of explosion.\n     */\n    constructor(meshes, centerMesh) {\n        this._meshesOrigins = [];\n        this._toCenterVectors = [];\n        this._scaledDirection = new Vector3(1, 1, 1);\n        this._newPosition = Vector3.Zero();\n        this._centerPosition = Vector3.Zero();\n        this._meshes = meshes.slice();\n        if (centerMesh) {\n            this._centerMesh = centerMesh;\n        }\n        else {\n            this._setCenterMesh();\n        }\n        this._centerMesh.computeWorldMatrix(true);\n        const centerMeshIndex = this._meshes.indexOf(this._centerMesh);\n        if (centerMeshIndex >= 0) {\n            this._meshes.splice(centerMeshIndex, 1);\n        }\n        this._centerPosition = this._centerMesh.getAbsolutePosition().clone();\n        for (let index = 0; index < this._meshes.length; index++) {\n            if (this._meshes[index]) {\n                const mesh = this._meshes[index];\n                this._meshesOrigins[index] = mesh.getAbsolutePosition().clone();\n                this._toCenterVectors[index] = Vector3.Zero();\n                if (mesh.hasBoundingInfo && this._centerMesh.hasBoundingInfo) {\n                    mesh.computeWorldMatrix(true);\n                    mesh.getBoundingInfo().boundingBox.centerWorld.subtractToRef(this._centerMesh.getBoundingInfo().boundingBox.centerWorld, this._toCenterVectors[index]);\n                }\n            }\n        }\n    }\n    _setCenterMesh() {\n        let averageCenter = Vector3.Zero();\n        const totalCenters = Vector3.Zero();\n        let shortestToCenter = Number.MAX_VALUE;\n        for (let index = 0; index < this._meshes.length; index++) {\n            if (this._meshes[index]) {\n                const mesh = this._meshes[index];\n                const boundingInfo = mesh.getBoundingInfo();\n                if (boundingInfo) {\n                    totalCenters.addInPlace(boundingInfo.boundingBox.centerWorld);\n                }\n            }\n        }\n        averageCenter = totalCenters.scale(1 / this._meshes.length);\n        for (let index = 0; index < this._meshes.length; index++) {\n            if (this._meshes[index]) {\n                const mesh = this._meshes[index];\n                const boundingInfo = mesh.getBoundingInfo();\n                if (boundingInfo) {\n                    const distanceToCenter = boundingInfo.boundingBox.centerWorld.subtract(averageCenter).lengthSquared();\n                    if (distanceToCenter < shortestToCenter) {\n                        this._centerMesh = mesh;\n                        shortestToCenter = distanceToCenter;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Get class name\n     * @returns \"MeshExploder\"\n     */\n    getClassName() {\n        return \"MeshExploder\";\n    }\n    /**\n     * \"Exploded meshes\"\n     * @returns Array of meshes with the centerMesh at index 0.\n     */\n    getMeshes() {\n        const meshArray = this._meshes.slice();\n        meshArray.unshift(this._centerMesh);\n        return meshArray;\n    }\n    /**\n     * Explodes meshes giving a specific direction\n     * @param direction Number to multiply distance of each mesh's origin from center. Use a negative number to implode, or zero to reset.\n     */\n    explode(direction = 1.0) {\n        for (let index = 0; index < this._meshes.length; index++) {\n            if (this._meshes[index] && this._meshesOrigins[index] && this._toCenterVectors[index]) {\n                this._toCenterVectors[index].scaleToRef(direction, this._scaledDirection);\n                this._meshesOrigins[index].addToRef(this._scaledDirection, this._newPosition);\n                this._meshes[index].setAbsolutePosition(this._newPosition);\n            }\n        }\n        this._centerMesh.setAbsolutePosition(this._centerPosition);\n    }\n}\n//# sourceMappingURL=meshExploder.js.map","import { SceneLoader } from \"../Loading/sceneLoader.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { FilesInputStore } from \"./filesInputStore.js\";\n/**\n * Class used to help managing file picking and drag-n-drop\n */\nexport class FilesInput {\n    /**\n     * List of files ready to be loaded\n     */\n    static get FilesToLoad() {\n        return FilesInputStore.FilesToLoad;\n    }\n    /**\n     * Creates a new FilesInput\n     * @param engine defines the rendering engine\n     * @param scene defines the hosting scene\n     * @param sceneLoadedCallback callback called when scene (files provided) is loaded\n     * @param progressCallback callback called to track progress\n     * @param additionalRenderLoopLogicCallback callback called to add user logic to the rendering loop\n     * @param textureLoadingCallback callback called when a texture is loading\n     * @param startingProcessingFilesCallback callback called when the system is about to process all files\n     * @param onReloadCallback callback called when a reload is requested\n     * @param errorCallback callback call if an error occurs\n     * @param useAppend defines if the file loaded must be appended (true) or have the scene replaced (false, default behavior)\n     * @param dontInjectRenderLoop defines if the render loop mustn't be injected into engine (default is false). Used only if useAppend is false.\n     */\n    constructor(engine, scene, sceneLoadedCallback, progressCallback, additionalRenderLoopLogicCallback, textureLoadingCallback, startingProcessingFilesCallback, onReloadCallback, errorCallback, useAppend = false, dontInjectRenderLoop = false) {\n        this.useAppend = useAppend;\n        this.dontInjectRenderLoop = dontInjectRenderLoop;\n        /**\n         * Callback called when a file is processed\n         * @returns false to abort the process\n         */\n        this.onProcessFileCallback = () => {\n            return true;\n        };\n        /**\n         * If a loading UI should be displayed while loading a file\n         */\n        this.displayLoadingUI = true;\n        /**\n         * Function used when loading the scene file\n         * @param sceneFile defines the file to load\n         * @param onProgress onProgress callback called while loading the file\n         * @returns a promise completing when the load is complete\n         */\n        this.loadAsync = (sceneFile, onProgress) => this.useAppend ? SceneLoader.AppendAsync(\"file:\", sceneFile, this._currentScene, onProgress) : SceneLoader.LoadAsync(\"file:\", sceneFile, this._engine, onProgress);\n        this._engine = engine;\n        this._currentScene = scene;\n        this._sceneLoadedCallback = sceneLoadedCallback;\n        this._progressCallback = progressCallback;\n        this._additionalRenderLoopLogicCallback = additionalRenderLoopLogicCallback;\n        this._textureLoadingCallback = textureLoadingCallback;\n        this._startingProcessingFilesCallback = startingProcessingFilesCallback;\n        this._onReloadCallback = onReloadCallback;\n        this._errorCallback = errorCallback;\n    }\n    /**\n     * Calls this function to listen to drag'n'drop events on a specific DOM element\n     * @param elementToMonitor defines the DOM element to track\n     */\n    monitorElementForDragNDrop(elementToMonitor) {\n        if (elementToMonitor) {\n            this._elementToMonitor = elementToMonitor;\n            this._dragEnterHandler = (e) => {\n                this._drag(e);\n            };\n            this._dragOverHandler = (e) => {\n                this._drag(e);\n            };\n            this._dropHandler = (e) => {\n                this._drop(e);\n            };\n            this._elementToMonitor.addEventListener(\"dragenter\", this._dragEnterHandler, false);\n            this._elementToMonitor.addEventListener(\"dragover\", this._dragOverHandler, false);\n            this._elementToMonitor.addEventListener(\"drop\", this._dropHandler, false);\n        }\n    }\n    /** Gets the current list of files to load */\n    get filesToLoad() {\n        return this._filesToLoad;\n    }\n    /**\n     * Release all associated resources\n     */\n    dispose() {\n        if (!this._elementToMonitor) {\n            return;\n        }\n        this._elementToMonitor.removeEventListener(\"dragenter\", this._dragEnterHandler);\n        this._elementToMonitor.removeEventListener(\"dragover\", this._dragOverHandler);\n        this._elementToMonitor.removeEventListener(\"drop\", this._dropHandler);\n    }\n    _renderFunction() {\n        if (this._additionalRenderLoopLogicCallback) {\n            this._additionalRenderLoopLogicCallback();\n        }\n        if (this._currentScene) {\n            if (this._textureLoadingCallback) {\n                const remaining = this._currentScene.getWaitingItemsCount();\n                if (remaining > 0) {\n                    this._textureLoadingCallback(remaining);\n                }\n            }\n            this._currentScene.render();\n        }\n    }\n    _drag(e) {\n        e.stopPropagation();\n        e.preventDefault();\n    }\n    _drop(eventDrop) {\n        eventDrop.stopPropagation();\n        eventDrop.preventDefault();\n        this.loadFiles(eventDrop);\n    }\n    _traverseFolder(folder, files, remaining, callback) {\n        const reader = folder.createReader();\n        const relativePath = folder.fullPath.replace(/^\\//, \"\").replace(/(.+?)\\/?$/, \"$1/\");\n        reader.readEntries((entries) => {\n            remaining.count += entries.length;\n            for (const entry of entries) {\n                if (entry.isFile) {\n                    entry.file((file) => {\n                        file.correctName = relativePath + file.name;\n                        files.push(file);\n                        if (--remaining.count === 0) {\n                            callback();\n                        }\n                    });\n                }\n                else if (entry.isDirectory) {\n                    this._traverseFolder(entry, files, remaining, callback);\n                }\n            }\n            if (--remaining.count === 0) {\n                callback();\n            }\n        });\n    }\n    _processFiles(files) {\n        for (let i = 0; i < files.length; i++) {\n            const name = files[i].correctName.toLowerCase();\n            const extension = name.split(\".\").pop();\n            if (!this.onProcessFileCallback(files[i], name, extension, (sceneFile) => (this._sceneFileToLoad = sceneFile))) {\n                continue;\n            }\n            if (SceneLoader.IsPluginForExtensionAvailable(\".\" + extension)) {\n                this._sceneFileToLoad = files[i];\n            }\n            FilesInput.FilesToLoad[name] = files[i];\n        }\n    }\n    /**\n     * Load files from a drop event\n     * @param event defines the drop event to use as source\n     */\n    loadFiles(event) {\n        // Handling data transfer via drag'n'drop\n        if (event && event.dataTransfer && event.dataTransfer.files) {\n            this._filesToLoad = event.dataTransfer.files;\n        }\n        // Handling files from input files\n        if (event && event.target && event.target.files) {\n            this._filesToLoad = event.target.files;\n        }\n        if (!this._filesToLoad || this._filesToLoad.length === 0) {\n            return;\n        }\n        if (this._startingProcessingFilesCallback) {\n            this._startingProcessingFilesCallback(this._filesToLoad);\n        }\n        if (this._filesToLoad && this._filesToLoad.length > 0) {\n            const files = [];\n            const folders = [];\n            const items = event.dataTransfer ? event.dataTransfer.items : null;\n            for (let i = 0; i < this._filesToLoad.length; i++) {\n                const fileToLoad = this._filesToLoad[i];\n                const name = fileToLoad.name.toLowerCase();\n                let entry;\n                fileToLoad.correctName = name;\n                if (items) {\n                    const item = items[i];\n                    if (item.getAsEntry) {\n                        entry = item.getAsEntry();\n                    }\n                    else if (item.webkitGetAsEntry) {\n                        entry = item.webkitGetAsEntry();\n                    }\n                }\n                if (!entry) {\n                    files.push(fileToLoad);\n                }\n                else {\n                    if (entry.isDirectory) {\n                        folders.push(entry);\n                    }\n                    else {\n                        files.push(fileToLoad);\n                    }\n                }\n            }\n            if (folders.length === 0) {\n                this._processFiles(files);\n                this._processReload();\n            }\n            else {\n                const remaining = { count: folders.length };\n                for (const folder of folders) {\n                    this._traverseFolder(folder, files, remaining, () => {\n                        this._processFiles(files);\n                        if (remaining.count === 0) {\n                            this._processReload();\n                        }\n                    });\n                }\n            }\n        }\n    }\n    _processReload() {\n        if (this._onReloadCallback) {\n            this._onReloadCallback(this._sceneFileToLoad);\n        }\n        else {\n            this.reload();\n        }\n    }\n    /**\n     * Reload the current scene from the loaded files\n     */\n    reload() {\n        // If a scene file has been provided\n        if (this._sceneFileToLoad) {\n            if (!this.useAppend) {\n                if (this._currentScene) {\n                    if (Logger.errorsCount > 0) {\n                        Logger.ClearLogCache();\n                    }\n                    this._engine.stopRenderLoop();\n                }\n            }\n            SceneLoader.ShowLoadingScreen = false;\n            if (this.displayLoadingUI) {\n                this._engine.displayLoadingUI();\n            }\n            this.loadAsync(this._sceneFileToLoad, this._progressCallback)\n                .then((scene) => {\n                // if appending do nothing\n                if (!this.useAppend) {\n                    if (this._currentScene) {\n                        this._currentScene.dispose();\n                    }\n                    this._currentScene = scene;\n                    // Wait for textures and shaders to be ready\n                    this._currentScene.executeWhenReady(() => {\n                        if (this.displayLoadingUI) {\n                            this._engine.hideLoadingUI();\n                        }\n                        if (!this.dontInjectRenderLoop) {\n                            this._engine.runRenderLoop(() => {\n                                this._renderFunction();\n                            });\n                        }\n                    });\n                }\n                else {\n                    if (this.displayLoadingUI) {\n                        this._engine.hideLoadingUI();\n                    }\n                }\n                if (this._sceneLoadedCallback && this._currentScene) {\n                    this._sceneLoadedCallback(this._sceneFileToLoad, this._currentScene);\n                }\n            })\n                .catch((error) => {\n                if (this.displayLoadingUI) {\n                    this._engine.hideLoadingUI();\n                }\n                if (this._errorCallback) {\n                    this._errorCallback(this._sceneFileToLoad, this._currentScene, error.message);\n                }\n            });\n        }\n        else {\n            if (this._filesToLoad.length === 1) {\n                const name = this._filesToLoad[0].name.toLowerCase();\n                const extension = name.split(\".\").pop();\n                if (extension) {\n                    switch (extension.toLowerCase()) {\n                        case \"dds\":\n                        case \"env\":\n                        case \"hdr\": {\n                            return; // Ignore error in that case\n                        }\n                    }\n                }\n            }\n            Logger.Error(\"Please provide a valid .babylon file.\");\n        }\n    }\n}\n//# sourceMappingURL=filesInput.js.map","import { SceneSerializer } from \"./sceneSerializer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Light } from \"../Lights/light.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { Skeleton } from \"../Bones/skeleton.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { MultiMaterial } from \"../Materials/multiMaterial.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\nimport { ParticleSystem } from \"../Particles/particleSystem.js\";\nimport { MorphTargetManager } from \"../Morph/morphTargetManager.js\";\nimport { ShadowGenerator } from \"../Lights/Shadows/shadowGenerator.js\";\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { SerializationHelper } from \"./decorators.serialization.js\";\n/**\n * Class used to record delta files between 2 scene states\n */\nexport class SceneRecorder {\n    constructor() {\n        this._trackedScene = null;\n    }\n    /**\n     * Track a given scene. This means the current scene state will be considered the original state\n     * @param scene defines the scene to track\n     */\n    track(scene) {\n        this._trackedScene = scene;\n        SerializationHelper.AllowLoadingUniqueId = true;\n        this._savedJSON = SceneSerializer.Serialize(scene);\n        SerializationHelper.AllowLoadingUniqueId = false;\n    }\n    /**\n     * Get the delta between current state and original state\n     * @returns a any containing the delta\n     */\n    getDelta() {\n        if (!this._trackedScene) {\n            return null;\n        }\n        const currentForceSerializeBuffers = Texture.ForceSerializeBuffers;\n        Texture.ForceSerializeBuffers = false;\n        SerializationHelper.AllowLoadingUniqueId = true;\n        const newJSON = SceneSerializer.Serialize(this._trackedScene);\n        SerializationHelper.AllowLoadingUniqueId = false;\n        const deltaJSON = {};\n        for (const node in newJSON) {\n            this._compareCollections(node, this._savedJSON[node], newJSON[node], deltaJSON);\n        }\n        Texture.ForceSerializeBuffers = currentForceSerializeBuffers;\n        return deltaJSON;\n    }\n    _compareArray(key, original, current, deltaJSON) {\n        if (original.length === 0 && current.length === 0) {\n            return true;\n        }\n        // Numbers?\n        if ((original.length && !isNaN(original[0])) || (current.length && !isNaN(current[0]))) {\n            if (original.length !== current.length) {\n                return false;\n            }\n            if (original.length === 0) {\n                return true;\n            }\n            for (let index = 0; index < original.length; index++) {\n                if (original[index] !== current[index]) {\n                    deltaJSON[key] = current;\n                    return false;\n                }\n            }\n            return true;\n        }\n        // let's use uniqueId to find similar objects\n        const originalUniqueIds = [];\n        for (let index = 0; index < original.length; index++) {\n            const originalObject = original[index];\n            const originalUniqueId = originalObject.uniqueId;\n            originalUniqueIds.push(originalUniqueId);\n            // Look for that object in current state\n            const currentObjects = current.filter((c) => c.uniqueId === originalUniqueId);\n            if (currentObjects.length) {\n                // We have a candidate\n                const currentObject = currentObjects[0];\n                const newObject = {};\n                if (!this._compareObjects(originalObject, currentObject, newObject)) {\n                    if (!deltaJSON[key]) {\n                        deltaJSON[key] = [];\n                    }\n                    newObject.__state = {\n                        id: currentObject.id || currentObject.name,\n                    };\n                    deltaJSON[key].push(newObject);\n                }\n            }\n            else {\n                // We need to delete\n                const newObject = {\n                    __state: {\n                        deleteId: originalObject.id || originalObject.name,\n                    },\n                };\n                if (!deltaJSON[key]) {\n                    deltaJSON[key] = [];\n                }\n                deltaJSON[key].push(newObject);\n            }\n        }\n        // Checking for new objects\n        for (let index = 0; index < current.length; index++) {\n            const currentObject = current[index];\n            const currentUniqueId = currentObject.uniqueId;\n            // Object was added\n            if (originalUniqueIds.indexOf(currentUniqueId) === -1) {\n                if (!deltaJSON[key]) {\n                    deltaJSON[key] = [];\n                }\n                deltaJSON[key].push(currentObject);\n            }\n        }\n        return true;\n    }\n    _compareObjects(originalObjet, currentObject, deltaJSON) {\n        let aDifferenceWasFound = false;\n        for (const prop in originalObjet) {\n            if (!Object.prototype.hasOwnProperty.call(originalObjet, prop)) {\n                continue;\n            }\n            const originalValue = originalObjet[prop];\n            const currentValue = currentObject[prop];\n            let diffFound = false;\n            if (Array.isArray(originalValue)) {\n                diffFound = JSON.stringify(originalValue) !== JSON.stringify(currentValue);\n            }\n            else if (!isNaN(originalValue) || Object.prototype.toString.call(originalValue) == \"[object String]\") {\n                diffFound = originalValue !== currentValue;\n            }\n            else if (typeof originalValue === \"object\" && typeof currentValue === \"object\") {\n                const newObject = {};\n                if (!this._compareObjects(originalValue, currentValue, newObject)) {\n                    deltaJSON[prop] = newObject;\n                    aDifferenceWasFound = true;\n                }\n            }\n            if (diffFound) {\n                aDifferenceWasFound = true;\n                deltaJSON[prop] = currentValue;\n            }\n        }\n        return !aDifferenceWasFound;\n    }\n    _compareCollections(key, original, current, deltaJSON) {\n        // Same ?\n        if (original === current) {\n            return;\n        }\n        if (original && current) {\n            // Array?\n            if (Array.isArray(original) && Array.isArray(current)) {\n                if (this._compareArray(key, original, current, deltaJSON)) {\n                    return;\n                }\n            }\n            else if (typeof original === \"object\" && typeof current === \"object\") {\n                // Object\n                const newObject = {};\n                if (!this._compareObjects(original, current, newObject)) {\n                    deltaJSON[key] = newObject;\n                }\n                return;\n            }\n        }\n    }\n    static GetShadowGeneratorById(scene, id) {\n        const allGenerators = scene.lights.map((l) => l.getShadowGenerators());\n        for (const generators of allGenerators) {\n            if (generators) {\n                const iterator = generators.values();\n                for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n                    const generator = key.value;\n                    if (generator && generator.id === id) {\n                        return generator;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Apply a given delta to a given scene\n     * @param deltaJSON defines the JSON containing the delta\n     * @param scene defines the scene to apply the delta to\n     */\n    static ApplyDelta(deltaJSON, scene) {\n        if (typeof deltaJSON === \"string\") {\n            deltaJSON = JSON.parse(deltaJSON);\n        }\n        // Scene\n        const anyScene = scene;\n        for (const prop in deltaJSON) {\n            const source = deltaJSON[prop];\n            const property = anyScene[prop];\n            if (Array.isArray(property) || prop === \"shadowGenerators\") {\n                // Restore array\n                switch (prop) {\n                    case \"cameras\":\n                        this._ApplyDeltaForEntity(source, scene, scene.getCameraById.bind(scene), (data) => Camera.Parse(data, scene));\n                        break;\n                    case \"lights\":\n                        this._ApplyDeltaForEntity(source, scene, scene.getLightById.bind(scene), (data) => Light.Parse(data, scene));\n                        break;\n                    case \"shadowGenerators\":\n                        this._ApplyDeltaForEntity(source, scene, (id) => this.GetShadowGeneratorById(scene, id), (data) => ShadowGenerator.Parse(data, scene));\n                        break;\n                    case \"meshes\":\n                        this._ApplyDeltaForEntity(source, scene, scene.getMeshById.bind(scene), (data) => Mesh.Parse(data, scene, \"\"));\n                        break;\n                    case \"skeletons\":\n                        this._ApplyDeltaForEntity(source, scene, scene.getSkeletonById.bind(scene), (data) => Skeleton.Parse(data, scene));\n                        break;\n                    case \"materials\":\n                        this._ApplyDeltaForEntity(source, scene, scene.getMaterialById.bind(scene), (data) => Material.Parse(data, scene, \"\"));\n                        break;\n                    case \"multiMaterials\":\n                        this._ApplyDeltaForEntity(source, scene, scene.getMaterialById.bind(scene), (data) => MultiMaterial.Parse(data, scene, \"\"));\n                        break;\n                    case \"transformNodes\":\n                        this._ApplyDeltaForEntity(source, scene, scene.getTransformNodeById.bind(scene), (data) => TransformNode.Parse(data, scene, \"\"));\n                        break;\n                    case \"particleSystems\":\n                        this._ApplyDeltaForEntity(source, scene, scene.getParticleSystemById.bind(scene), (data) => ParticleSystem.Parse(data, scene, \"\"));\n                        break;\n                    case \"morphTargetManagers\":\n                        this._ApplyDeltaForEntity(source, scene, scene.getMorphTargetById.bind(scene), (data) => MorphTargetManager.Parse(data, scene));\n                        break;\n                    case \"postProcesses\":\n                        this._ApplyDeltaForEntity(source, scene, scene.getPostProcessByName.bind(scene), (data) => PostProcess.Parse(data, scene, \"\"));\n                        break;\n                }\n            }\n            else if (!isNaN(property)) {\n                anyScene[prop] = source;\n            }\n            else if (property.fromArray) {\n                property.fromArray(source);\n            }\n        }\n    }\n    static _ApplyPropertiesToEntity(deltaJSON, entity) {\n        for (const prop in deltaJSON) {\n            const source = deltaJSON[prop];\n            const property = entity[prop];\n            if (property === undefined) {\n                continue;\n            }\n            if (!isNaN(property) || Array.isArray(property)) {\n                entity[prop] = source;\n            }\n            else if (property.fromArray) {\n                property.fromArray(source);\n            }\n            else if (typeof property === \"object\" && property !== null) {\n                this._ApplyPropertiesToEntity(source, property);\n            }\n        }\n    }\n    static _ApplyDeltaForEntity(sources, scene, finder, addNew) {\n        for (const source of sources) {\n            // Update\n            if (source.__state && source.__state.id !== undefined) {\n                const targetEntity = finder(source.__state.id);\n                if (targetEntity) {\n                    // This first pass applies properties that aren't on the serialization list\n                    this._ApplyPropertiesToEntity(source, targetEntity);\n                    // The second pass applies the serializable properties\n                    SerializationHelper.ParseProperties(source, targetEntity, scene, null);\n                }\n            }\n            else if (source.__state && source.__state.deleteId !== undefined) {\n                const target = finder(source.__state.deleteId);\n                target?.dispose();\n            }\n            else {\n                // New\n                addNew(source);\n            }\n        }\n    }\n}\n//# sourceMappingURL=sceneRecorder.js.map","import { Observable } from \"./observable.js\";\n/**\n * A wrapper for the experimental pressure api which allows a callback to be called whenever certain thresholds are met.\n */\nexport class PressureObserverWrapper {\n    /**\n     * A pressure observer will call this callback, whenever these thresholds are met.\n     * @param options An object containing the thresholds used to decide what value to to return for each update property (average of start and end of a threshold boundary).\n     */\n    constructor(options) {\n        this._observer = null;\n        this._currentState = [];\n        /**\n         * An event triggered when the cpu usage/speed meets certain thresholds.\n         * Note: pressure is an experimental API.\n         */\n        this.onPressureChanged = new Observable();\n        if (PressureObserverWrapper.IsAvailable) {\n            this._observer = new PressureObserver((update) => {\n                this._currentState = update;\n                this.onPressureChanged.notifyObservers(update);\n            }, options);\n        }\n    }\n    /**\n     * Returns true if PressureObserver is available for use, false otherwise.\n     */\n    static get IsAvailable() {\n        return typeof PressureObserver !== \"undefined\" && PressureObserver.knownSources && PressureObserver.knownSources.includes(\"cpu\");\n    }\n    /**\n     * Method that must be called to begin observing changes, and triggering callbacks.\n     * @param source defines the source to observe\n     */\n    observe(source) {\n        try {\n            this._observer?.observe(source);\n            this.onPressureChanged.notifyObservers(this._currentState);\n        }\n        catch {\n            // Ignore error\n        }\n    }\n    /**\n     * Method that must be called to stop observing changes and triggering callbacks (cleanup function).\n     * @param source defines the source to unobserve\n     */\n    unobserve(source) {\n        try {\n            this._observer?.unobserve(source);\n        }\n        catch {\n            // Ignore error\n        }\n    }\n    /**\n     * Release the associated resources.\n     */\n    dispose() {\n        this._observer?.disconnect();\n        this._observer = null;\n        this.onPressureChanged.clear();\n    }\n}\n//# sourceMappingURL=pressureObserverWrapper.js.map","import { EngineInstrumentation } from \"../../Instrumentation/engineInstrumentation.js\";\nimport { PrecisionDate } from \"../precisionDate.js\";\nimport { SceneInstrumentation } from \"../../Instrumentation/sceneInstrumentation.js\";\nimport { PressureObserverWrapper } from \"../pressureObserverWrapper.js\";\n// Dispose which does nothing.\nconst defaultDisposeImpl = () => { };\n/**\n * Defines the predefined strategies used in the performance viewer.\n */\nexport class PerfCollectionStrategy {\n    /**\n     * Gets the initializer for the strategy used for collection of fps metrics\n     * @returns the initializer for the fps strategy\n     */\n    static FpsStrategy() {\n        return (scene) => {\n            const engine = scene.getEngine();\n            return {\n                id: \"FPS\",\n                getData: () => engine.getFps(),\n                dispose: defaultDisposeImpl,\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of thermal utilization metrics.\n     * Needs the experimental pressure API.\n     * @returns the initializer for the thermal utilization strategy\n     */\n    static ThermalStrategy() {\n        return this._PressureStrategy(\"Thermal utilization\", \"thermal\");\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of power supply utilization metrics.\n     * Needs the experimental pressure API.\n     * @returns the initializer for the power supply utilization strategy\n     */\n    static PowerSupplyStrategy() {\n        return this._PressureStrategy(\"Power supply utilization\", \"power-supply\");\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of pressure metrics.\n     * Needs the experimental pressure API.\n     * @returns the initializer for the pressure strategy\n     */\n    static PressureStrategy() {\n        return this._PressureStrategy(\"Pressure\");\n    }\n    static _PressureStrategy(name, factor = null) {\n        return () => {\n            let value = 0;\n            const wrapper = new PressureObserverWrapper();\n            wrapper.observe(\"cpu\");\n            wrapper.onPressureChanged.add((update) => {\n                for (const record of update) {\n                    if ((factor && record.factors.includes(factor)) || (!factor && (record.factors?.length ?? 0) === 0)) {\n                        // Let s consider each step being 25% of the total pressure.\n                        switch (record.state) {\n                            case \"nominal\":\n                                value = 0;\n                                break;\n                            case \"fair\":\n                                value = 0.25;\n                                break;\n                            case \"serious\":\n                                value = 0.5;\n                                break;\n                            case \"critical\":\n                                value = 1;\n                                break;\n                        }\n                    }\n                }\n            });\n            return {\n                id: name,\n                getData: () => value,\n                dispose: () => wrapper.dispose(),\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of total meshes metrics.\n     * @returns the initializer for the total meshes strategy\n     */\n    static TotalMeshesStrategy() {\n        return (scene) => {\n            return {\n                id: \"Total meshes\",\n                getData: () => scene.meshes.length,\n                dispose: defaultDisposeImpl,\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of active meshes metrics.\n     * @returns the initializer for the active meshes strategy\n     */\n    static ActiveMeshesStrategy() {\n        return (scene) => {\n            return {\n                id: \"Active meshes\",\n                getData: () => scene.getActiveMeshes().length,\n                dispose: defaultDisposeImpl,\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of active indices metrics.\n     * @returns the initializer for the active indices strategy\n     */\n    static ActiveIndicesStrategy() {\n        return (scene) => {\n            return {\n                id: \"Active indices\",\n                getData: () => scene.getActiveIndices(),\n                dispose: defaultDisposeImpl,\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of active faces metrics.\n     * @returns the initializer for the active faces strategy\n     */\n    static ActiveFacesStrategy() {\n        return (scene) => {\n            return {\n                id: \"Active faces\",\n                getData: () => scene.getActiveIndices() / 3,\n                dispose: defaultDisposeImpl,\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of active bones metrics.\n     * @returns the initializer for the active bones strategy\n     */\n    static ActiveBonesStrategy() {\n        return (scene) => {\n            return {\n                id: \"Active bones\",\n                getData: () => scene.getActiveBones(),\n                dispose: defaultDisposeImpl,\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of active particles metrics.\n     * @returns the initializer for the active particles strategy\n     */\n    static ActiveParticlesStrategy() {\n        return (scene) => {\n            return {\n                id: \"Active particles\",\n                getData: () => scene.getActiveParticles(),\n                dispose: defaultDisposeImpl,\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of draw calls metrics.\n     * @returns the initializer for the draw calls strategy\n     */\n    static DrawCallsStrategy() {\n        return (scene) => {\n            let drawCalls = 0;\n            const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n                scene.getEngine()._drawCalls.fetchNewFrame();\n            });\n            const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {\n                drawCalls = scene.getEngine()._drawCalls.current;\n            });\n            return {\n                id: \"Draw calls\",\n                getData: () => drawCalls,\n                dispose: () => {\n                    scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\n                    scene.onAfterRenderObservable.remove(onAfterRenderObserver);\n                },\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of total lights metrics.\n     * @returns the initializer for the total lights strategy\n     */\n    static TotalLightsStrategy() {\n        return (scene) => {\n            return {\n                id: \"Total lights\",\n                getData: () => scene.lights.length,\n                dispose: defaultDisposeImpl,\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of total vertices metrics.\n     * @returns the initializer for the total vertices strategy\n     */\n    static TotalVerticesStrategy() {\n        return (scene) => {\n            return {\n                id: \"Total vertices\",\n                getData: () => scene.getTotalVertices(),\n                dispose: defaultDisposeImpl,\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of total materials metrics.\n     * @returns the initializer for the total materials strategy\n     */\n    static TotalMaterialsStrategy() {\n        return (scene) => {\n            return {\n                id: \"Total materials\",\n                getData: () => scene.materials.length,\n                dispose: defaultDisposeImpl,\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of total textures metrics.\n     * @returns the initializer for the total textures strategy\n     */\n    static TotalTexturesStrategy() {\n        return (scene) => {\n            return {\n                id: \"Total textures\",\n                getData: () => scene.textures.length,\n                dispose: defaultDisposeImpl,\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of absolute fps metrics.\n     * @returns the initializer for the absolute fps strategy\n     */\n    static AbsoluteFpsStrategy() {\n        return (scene) => {\n            const sceneInstrumentation = new SceneInstrumentation(scene);\n            sceneInstrumentation.captureFrameTime = true;\n            return {\n                id: \"Absolute FPS\",\n                getData: () => {\n                    return 1000.0 / sceneInstrumentation.frameTimeCounter.lastSecAverage;\n                },\n                dispose: defaultDisposeImpl,\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of meshes selection time metrics.\n     * @returns the initializer for the meshes selection time strategy\n     */\n    static MeshesSelectionStrategy() {\n        return (scene) => {\n            let startTime = PrecisionDate.Now;\n            let timeTaken = 0;\n            const onBeforeActiveMeshesObserver = scene.onBeforeActiveMeshesEvaluationObservable.add(() => {\n                startTime = PrecisionDate.Now;\n            });\n            const onAfterActiveMeshesObserver = scene.onAfterActiveMeshesEvaluationObservable.add(() => {\n                timeTaken = PrecisionDate.Now - startTime;\n            });\n            return {\n                id: \"Meshes Selection\",\n                getData: () => timeTaken,\n                dispose: () => {\n                    scene.onBeforeActiveMeshesEvaluationObservable.remove(onBeforeActiveMeshesObserver);\n                    scene.onAfterActiveMeshesEvaluationObservable.remove(onAfterActiveMeshesObserver);\n                },\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of render targets time metrics.\n     * @returns the initializer for the render targets time strategy\n     */\n    static RenderTargetsStrategy() {\n        return (scene) => {\n            let startTime = PrecisionDate.Now;\n            let timeTaken = 0;\n            const onBeforeRenderTargetsObserver = scene.onBeforeRenderTargetsRenderObservable.add(() => {\n                startTime = PrecisionDate.Now;\n            });\n            const onAfterRenderTargetsObserver = scene.onAfterRenderTargetsRenderObservable.add(() => {\n                timeTaken = PrecisionDate.Now - startTime;\n            });\n            return {\n                id: \"Render Targets\",\n                getData: () => timeTaken,\n                dispose: () => {\n                    scene.onBeforeRenderTargetsRenderObservable.remove(onBeforeRenderTargetsObserver);\n                    scene.onAfterRenderTargetsRenderObservable.remove(onAfterRenderTargetsObserver);\n                },\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of particles time metrics.\n     * @returns the initializer for the particles time strategy\n     */\n    static ParticlesStrategy() {\n        return (scene) => {\n            let startTime = PrecisionDate.Now;\n            let timeTaken = 0;\n            const onBeforeParticlesObserver = scene.onBeforeParticlesRenderingObservable.add(() => {\n                startTime = PrecisionDate.Now;\n            });\n            const onAfterParticlesObserver = scene.onAfterParticlesRenderingObservable.add(() => {\n                timeTaken = PrecisionDate.Now - startTime;\n            });\n            return {\n                id: \"Particles\",\n                getData: () => timeTaken,\n                dispose: () => {\n                    scene.onBeforeParticlesRenderingObservable.remove(onBeforeParticlesObserver);\n                    scene.onAfterParticlesRenderingObservable.remove(onAfterParticlesObserver);\n                },\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of sprites time metrics.\n     * @returns the initializer for the sprites time strategy\n     */\n    static SpritesStrategy() {\n        return (scene) => {\n            let startTime = PrecisionDate.Now;\n            let timeTaken = 0;\n            const onBeforeSpritesObserver = scene.onBeforeSpritesRenderingObservable?.add(() => {\n                startTime = PrecisionDate.Now;\n            });\n            const onAfterSpritesObserver = scene.onAfterSpritesRenderingObservable?.add(() => {\n                timeTaken = PrecisionDate.Now - startTime;\n            });\n            return {\n                id: \"Sprites\",\n                getData: () => timeTaken,\n                dispose: () => {\n                    scene.onBeforeSpritesRenderingObservable?.remove(onBeforeSpritesObserver);\n                    scene.onAfterSpritesRenderingObservable?.remove(onAfterSpritesObserver);\n                },\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of animations time metrics.\n     * @returns the initializer for the animations time strategy\n     */\n    static AnimationsStrategy() {\n        return (scene) => {\n            let startTime = PrecisionDate.Now;\n            let timeTaken = 0;\n            const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n                startTime = PrecisionDate.Now;\n            });\n            const onAfterAnimationsObserver = scene.onAfterAnimationsObservable.add(() => {\n                timeTaken = PrecisionDate.Now - startTime;\n            });\n            return {\n                id: \"Animations\",\n                getData: () => timeTaken,\n                dispose: () => {\n                    scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\n                    scene.onAfterAnimationsObservable.remove(onAfterAnimationsObserver);\n                },\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of physics time metrics.\n     * @returns the initializer for the physics time strategy\n     */\n    static PhysicsStrategy() {\n        return (scene) => {\n            let startTime = PrecisionDate.Now;\n            let timeTaken = 0;\n            const onBeforePhysicsObserver = scene.onBeforePhysicsObservable?.add(() => {\n                startTime = PrecisionDate.Now;\n            });\n            const onAfterPhysicsObserver = scene.onAfterPhysicsObservable?.add(() => {\n                timeTaken = PrecisionDate.Now - startTime;\n            });\n            return {\n                id: \"Physics\",\n                getData: () => timeTaken,\n                dispose: () => {\n                    scene.onBeforePhysicsObservable?.remove(onBeforePhysicsObserver);\n                    scene.onAfterPhysicsObservable?.remove(onAfterPhysicsObserver);\n                },\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of render time metrics.\n     * @returns the initializer for the render time strategy\n     */\n    static RenderStrategy() {\n        return (scene) => {\n            let startTime = PrecisionDate.Now;\n            let timeTaken = 0;\n            const onBeforeDrawPhaseObserver = scene.onBeforeDrawPhaseObservable.add(() => {\n                startTime = PrecisionDate.Now;\n            });\n            const onAfterDrawPhaseObserver = scene.onAfterDrawPhaseObservable.add(() => {\n                timeTaken = PrecisionDate.Now - startTime;\n            });\n            return {\n                id: \"Render\",\n                getData: () => timeTaken,\n                dispose: () => {\n                    scene.onBeforeDrawPhaseObservable.remove(onBeforeDrawPhaseObserver);\n                    scene.onAfterDrawPhaseObservable.remove(onAfterDrawPhaseObserver);\n                },\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of total frame time metrics.\n     * @returns the initializer for the total frame time strategy\n     */\n    static FrameTotalStrategy() {\n        return (scene) => {\n            let startTime = PrecisionDate.Now;\n            let timeTaken = 0;\n            const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n                startTime = PrecisionDate.Now;\n            });\n            const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {\n                timeTaken = PrecisionDate.Now - startTime;\n            });\n            return {\n                id: \"Frame Total\",\n                getData: () => timeTaken,\n                dispose: () => {\n                    scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\n                    scene.onAfterRenderObservable.remove(onAfterRenderObserver);\n                },\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of inter-frame time metrics.\n     * @returns the initializer for the inter-frame time strategy\n     */\n    static InterFrameStrategy() {\n        return (scene) => {\n            let startTime = PrecisionDate.Now;\n            let timeTaken = 0;\n            const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n                timeTaken = PrecisionDate.Now - startTime;\n            });\n            const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {\n                startTime = PrecisionDate.Now;\n            });\n            return {\n                id: \"Inter-frame\",\n                getData: () => timeTaken,\n                dispose: () => {\n                    scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\n                    scene.onAfterRenderObservable.remove(onAfterRenderObserver);\n                },\n            };\n        };\n    }\n    /**\n     * Gets the initializer for the strategy used for collection of gpu frame time metrics.\n     * @returns the initializer for the gpu frame time strategy\n     */\n    static GpuFrameTimeStrategy() {\n        return (scene) => {\n            const engineInstrumentation = new EngineInstrumentation(scene.getEngine());\n            engineInstrumentation.captureGPUFrameTime = true;\n            return {\n                id: \"GPU frame time\",\n                getData: () => Math.max(engineInstrumentation.gpuFrameTimeCounter.current * 0.000001, 0),\n                dispose: () => {\n                    engineInstrumentation.dispose();\n                },\n            };\n        };\n    }\n}\n//# sourceMappingURL=performanceViewerCollectionStrategies.js.map","\nimport { BindMorphTargetParameters } from \"../Materials/materialHelper.functions.js\";\nimport { Logger } from \"./logger.js\";\n/**\n * A helper class to simplify work with FAST snapshot mode (WebGPU only - can be used in WebGL too, but won't do anything).\n */\nexport class SnapshotRenderingHelper {\n    /**\n     * Creates a new snapshot rendering helper\n     * Note that creating an instance of the helper will set the snapshot rendering mode to SNAPSHOTRENDERING_FAST but will not enable snapshot rendering (engine.snapshotRendering is not updated).\n     * Note also that fixMeshes() is called as part of the construction\n     * @param scene The scene to use the helper in\n     * @param options The options for the helper\n     */\n    constructor(scene, options) {\n        this._disableRenderingRefCount = 0;\n        this._currentPerformancePriorityMode = 0 /* ScenePerformancePriority.BackwardCompatible */;\n        this._isEnabling = false;\n        this._enableCancelFunctions = new Map(); // first function is the callback, second function is the cancel function\n        this._disableCancelFunctions = new Map(); // same as above\n        /**\n         * Indicates if debug logs should be displayed\n         */\n        this.showDebugLogs = false;\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        if (!this._engine.isWebGPU) {\n            return;\n        }\n        this._options = {\n            morphTargetsNumMaxInfluences: 20,\n            ...options,\n        };\n        this._engine.snapshotRenderingMode = 1;\n        this.fixMeshes();\n        this._onResizeObserver = this._engine.onResizeObservable.add(() => {\n            this._log(\"onResize\", \"start\");\n            // enableSnapshotRendering() will delay the actual enabling of snapshot rendering by at least a frame, so these two lines are not redundant!\n            if (this._fastSnapshotRenderingEnabled) {\n                this.disableSnapshotRendering();\n                this.enableSnapshotRendering();\n            }\n            this._log(\"onResize\", \"end\");\n        });\n        this._scene.onBeforeRenderObservable.add(() => {\n            if (!this._fastSnapshotRenderingEnabled) {\n                return;\n            }\n            // Animate skeletons\n            scene.skeletons.forEach((skeleton) => skeleton.prepare(true));\n            for (const mesh of scene.meshes) {\n                if (mesh.infiniteDistance) {\n                    mesh.transferToEffect(mesh.computeWorldMatrix(true));\n                }\n                if (mesh.skeleton) {\n                    mesh.transferToEffect(mesh.computeWorldMatrix(true));\n                }\n                if (mesh.getClassName() === \"GaussianSplattingMesh\") {\n                    mesh._postToWorker();\n                }\n                if (mesh.morphTargetManager && mesh.subMeshes) {\n                    // Make sure morph target animations work\n                    for (const subMesh of mesh.subMeshes) {\n                        const dw = subMesh._drawWrapper;\n                        const effect = dw.effect;\n                        if (effect) {\n                            const dataBuffer = dw.drawContext.buffers[\"LeftOver\"];\n                            const ubLeftOver = effect._pipelineContext?.uniformBuffer;\n                            if (dataBuffer && ubLeftOver && ubLeftOver.setDataBuffer(dataBuffer)) {\n                                mesh.morphTargetManager._bind(effect);\n                                BindMorphTargetParameters(mesh, effect);\n                                ubLeftOver.update();\n                            }\n                        }\n                    }\n                }\n            }\n        });\n    }\n    /**\n     * Gets a value indicating if the helper is in a steady state (not in the process of enabling snapshot rendering).\n     */\n    get isReady() {\n        return !this._isEnabling;\n    }\n    /**\n     * Enable snapshot rendering\n     * Use this method instead of engine.snapshotRendering=true, to make sure everything is ready before enabling snapshot rendering.\n     * Note that this method is ref-counted and works in pair with disableSnapshotRendering(): you should call enableSnapshotRendering() as many times as you call disableSnapshotRendering().\n     */\n    enableSnapshotRendering() {\n        if (!this._engine.isWebGPU) {\n            return;\n        }\n        if (--this._disableRenderingRefCount > 0) {\n            return;\n        }\n        this._log(\"enableSnapshotRendering\", \"called\");\n        if (this._disableCancelFunctions.size > 0) {\n            this._log(\"enableSnapshotRendering\", `cancelling ${this._disableCancelFunctions.size} \"disable\" callbacks`);\n        }\n        this._disableCancelFunctions.forEach((cancel) => cancel());\n        this._disableCancelFunctions.clear();\n        this._isEnabling = true;\n        this._disableRenderingRefCount = 0;\n        this._currentPerformancePriorityMode = this._pendingCurrentPerformancePriorityMode ?? this._scene.performancePriority;\n        this._pendingCurrentPerformancePriorityMode = undefined;\n        this._scene.performancePriority = 0 /* ScenePerformancePriority.BackwardCompatible */;\n        const callbackWhenSceneReady = () => {\n            this._enableCancelFunctions.delete(callbackWhenSceneReady);\n            // Make sure a full frame is rendered before enabling snapshot rendering, so use \"+2\" instead of \"+1\"\n            const targetFrameId = this._engine.frameId + 2;\n            this._log(\"enableSnapshotRendering\", `scene ready, add callbacks for frames ${targetFrameId} and ${targetFrameId + 1}`);\n            this._executeAtFrame(targetFrameId, () => {\n                this._log(\"enableSnapshotRendering\", `callback #1, enable snapshot rendering at the engine level`);\n                this._engine.snapshotRendering = true;\n            });\n            // Render one frame with snapshot rendering enabled to make sure everything is ready\n            this._executeAtFrame(targetFrameId + 1, () => {\n                this._log(\"enableSnapshotRendering\", `callback #2, signals that snapshot rendering helper is ready`);\n                this._isEnabling = false;\n            });\n        };\n        this._enableCancelFunctions.set(callbackWhenSceneReady, () => this._scene.onReadyObservable.removeCallback(callbackWhenSceneReady));\n        this._scene.executeWhenReady(callbackWhenSceneReady);\n    }\n    /**\n     * Disable snapshot rendering\n     * Note that this method is ref-counted and works in pair with disableSnapshotRendering(): you should call enableSnapshotRendering() as many times as you call disableSnapshotRendering().\n     */\n    disableSnapshotRendering() {\n        if (!this._engine.isWebGPU) {\n            return;\n        }\n        this._log(\"disableSnapshotRendering\", \"called\");\n        if (this._disableRenderingRefCount === 0) {\n            if (this._enableCancelFunctions.size > 0) {\n                this._log(\"disableSnapshotRendering\", `cancelling ${this._enableCancelFunctions.size} \"enable\" callbacks`);\n            }\n            this._enableCancelFunctions.forEach((cancel) => cancel());\n            this._enableCancelFunctions.clear();\n            this._isEnabling = false;\n            // Snapshot rendering switches from enabled to disabled\n            // We reset the performance priority mode to that which it was before enabling snapshot rendering, but first set it to BackwardCompatible to allow the system to regenerate resources that may have been optimized for snapshot rendering.\n            // We'll then restore the original mode at the next frame.\n            this._scene.performancePriority = 0 /* ScenePerformancePriority.BackwardCompatible */;\n            if (this._currentPerformancePriorityMode !== 0 /* ScenePerformancePriority.BackwardCompatible */) {\n                this._log(\"disableSnapshotRendering\", `makes sure that the scene is rendered once in BackwardCompatible mode (code: ${0 /* ScenePerformancePriority.BackwardCompatible */}) before switching to mode ${this._currentPerformancePriorityMode}`);\n                this._pendingCurrentPerformancePriorityMode = this._currentPerformancePriorityMode;\n                const callbackWhenSceneReady = () => {\n                    this._log(\"disableSnapshotRendering\", `scene ready, add callback for frame ${this._engine.frameId + 2}`);\n                    this._executeAtFrame(this._engine.frameId + 2, () => {\n                        this._log(\"disableSnapshotRendering\", `switching to performance priority mode ${this._pendingCurrentPerformancePriorityMode}`);\n                        this._scene.performancePriority = this._pendingCurrentPerformancePriorityMode;\n                        this._pendingCurrentPerformancePriorityMode = undefined;\n                    }, \"whenDisabled\");\n                };\n                this._disableCancelFunctions.set(callbackWhenSceneReady, () => this._scene.onReadyObservable.removeCallback(callbackWhenSceneReady));\n                this._scene.executeWhenReady(callbackWhenSceneReady);\n            }\n        }\n        this._engine.snapshotRendering = false;\n        this._disableRenderingRefCount++;\n    }\n    /**\n     * Fix meshes for snapshot rendering.\n     * This method will make sure that some features are disabled or fixed to make sure snapshot rendering works correctly.\n     * @param meshes List of meshes to fix. If not provided, all meshes in the scene will be fixed.\n     */\n    fixMeshes(meshes) {\n        if (!this._engine.isWebGPU) {\n            return;\n        }\n        meshes = meshes || this._scene.meshes;\n        for (const mesh of meshes) {\n            mesh.ignoreCameraMaxZ = false;\n            if (mesh.morphTargetManager) {\n                mesh.morphTargetManager.numMaxInfluencers = Math.min(mesh.morphTargetManager.numTargets, this._options.morphTargetsNumMaxInfluences);\n            }\n        }\n    }\n    /**\n     * Call this method to update a mesh on the GPU after some properties have changed (position, rotation, scaling, visibility).\n     * @param mesh The mesh to update. Can be a single mesh or an array of meshes to update.\n     * @param updateInstancedMeshes If true, the method will also update instanced meshes. Default is true. If you know instanced meshes won't move (or you don't have instanced meshes), you can set this to false to save some CPU time.\n     */\n    updateMesh(mesh, updateInstancedMeshes = true) {\n        if (!this._fastSnapshotRenderingEnabled) {\n            return;\n        }\n        if (Array.isArray(mesh)) {\n            for (const m of mesh) {\n                if (!updateInstancedMeshes || !this._updateInstancedMesh(m)) {\n                    m.transferToEffect(m.computeWorldMatrix());\n                }\n            }\n            return;\n        }\n        if (!updateInstancedMeshes || !this._updateInstancedMesh(mesh)) {\n            mesh.transferToEffect(mesh.computeWorldMatrix());\n        }\n    }\n    _updateInstancedMesh(mesh) {\n        if (mesh.hasInstances) {\n            if (mesh.subMeshes) {\n                const sourceMesh = mesh;\n                for (const subMesh of sourceMesh.subMeshes) {\n                    sourceMesh._updateInstancedBuffers(subMesh, sourceMesh._getInstancesRenderList(subMesh._id), sourceMesh._instanceDataStorage.instancesBufferSize, this._engine);\n                }\n            }\n            return true;\n        }\n        else if (mesh.isAnInstance) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Update the meshes used in an effect layer to ensure that snapshot rendering works correctly for these meshes in this layer.\n     * @param effectLayer The effect layer\n     * @param autoUpdate If true, the helper will automatically update the effect layer meshes with each frame. If false, you'll need to call this method manually when the camera or layer meshes move or rotate.\n     */\n    updateMeshesForEffectLayer(effectLayer, autoUpdate = true) {\n        if (!this._engine.isWebGPU) {\n            return;\n        }\n        const renderPassId = effectLayer.mainTexture.renderPassId;\n        if (autoUpdate) {\n            this._onBeforeRenderObserverUpdateLayer = this._scene.onBeforeRenderObservable.add(() => {\n                this._updateMeshMatricesForRenderPassId(renderPassId);\n            });\n        }\n        else {\n            this._updateMeshMatricesForRenderPassId(renderPassId);\n        }\n    }\n    /**\n     * Dispose the helper\n     */\n    dispose() {\n        if (!this._engine.isWebGPU) {\n            return;\n        }\n        this._scene.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n        this._scene.onBeforeRenderObservable.remove(this._onBeforeRenderObserverUpdateLayer);\n        this._engine.onResizeObservable.remove(this._onResizeObserver);\n    }\n    get _fastSnapshotRenderingEnabled() {\n        return this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1;\n    }\n    _updateMeshMatricesForRenderPassId(renderPassId) {\n        if (!this._fastSnapshotRenderingEnabled) {\n            return;\n        }\n        const sceneTransformationMatrix = this._scene.getTransformMatrix();\n        for (let i = 0; i < this._scene.meshes.length; ++i) {\n            const mesh = this._scene.meshes[i];\n            if (!mesh.subMeshes) {\n                continue;\n            }\n            for (let j = 0; j < mesh.subMeshes.length; ++j) {\n                const dw = mesh.subMeshes[j]._getDrawWrapper(renderPassId);\n                const effect = dw?.effect;\n                if (effect) {\n                    const dataBuffer = dw.drawContext.buffers[\"LeftOver\"];\n                    const ubLeftOver = effect._pipelineContext?.uniformBuffer;\n                    if (dataBuffer && ubLeftOver && ubLeftOver.setDataBuffer(dataBuffer)) {\n                        effect.setMatrix(\"viewProjection\", sceneTransformationMatrix);\n                        effect.setMatrix(\"world\", mesh.computeWorldMatrix());\n                        ubLeftOver.update();\n                    }\n                }\n            }\n        }\n    }\n    _executeAtFrame(frameId, func, mode = \"whenEnabled\") {\n        const callback = () => {\n            if (this._engine.frameId >= frameId) {\n                this._engine.onEndFrameObservable.remove(obs);\n                if (mode === \"whenEnabled\") {\n                    this._enableCancelFunctions.delete(callback);\n                }\n                else {\n                    this._disableCancelFunctions.delete(callback);\n                }\n                func();\n            }\n        };\n        const obs = this._engine.onEndFrameObservable.add(callback);\n        if (mode === \"whenEnabled\") {\n            this._enableCancelFunctions.set(callback, () => this._engine.onEndFrameObservable.remove(obs));\n        }\n        else {\n            this._disableCancelFunctions.set(callback, () => this._engine.onEndFrameObservable.remove(obs));\n        }\n    }\n    _log(funcName, message) {\n        if (this.showDebugLogs) {\n            Logger.Log(`[Frame: ${this._engine.frameId}] SnapshotRenderingHelper:${funcName} - ${message}`);\n        }\n    }\n}\n//# sourceMappingURL=snapshotRenderingHelper.js.map","import { ReflectionProbe } from \"../Probes/reflectionProbe.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { CustomProceduralTexture } from \"../Materials/Textures/Procedurals/customProceduralTexture.js\";\nimport { DumpData } from \"./dumpTools.js\";\nimport \"../Shaders/equirectangularPanorama.fragment.js\";\n/**\n * @param scene This refers to the scene which would be rendered in the given equirectangular capture\n * @param options This refers to the options for a given equirectangular capture\n * @returns the requested capture's pixel-data or auto downloads the file if options.filename is specified\n */\nexport async function captureEquirectangularFromScene(scene, options) {\n    const probe = options.probe ?? new ReflectionProbe(\"tempProbe\", options.size, scene);\n    const wasProbeProvided = !!options.probe;\n    if (!wasProbeProvided) {\n        if (options.position) {\n            probe.position = options.position.clone();\n        }\n        else if (scene.activeCamera) {\n            probe.position = scene.activeCamera.position.clone();\n        }\n    }\n    const meshesToConsider = options.meshesFilter ? scene.meshes.filter(options.meshesFilter) : scene.meshes;\n    probe.renderList?.push(...meshesToConsider);\n    probe.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\n    probe.cubeTexture.render();\n    const dumpTexture = new CustomProceduralTexture(\"tempProceduralTexture\", \"equirectangularPanorama\", { width: options.size * 2, height: options.size }, scene);\n    dumpTexture.setTexture(\"cubeMap\", probe.cubeTexture);\n    return new Promise((resolve, reject) => {\n        dumpTexture.onGeneratedObservable.addOnce(() => {\n            const pixelDataPromise = dumpTexture.readPixels();\n            if (!pixelDataPromise) {\n                reject(new Error(\"No Pixel Data found on procedural texture\"));\n                dumpTexture.dispose();\n                if (!wasProbeProvided) {\n                    probe.dispose();\n                }\n                return;\n            }\n            pixelDataPromise.then((pixelData) => {\n                dumpTexture.dispose();\n                if (!wasProbeProvided) {\n                    probe.dispose();\n                }\n                if (options.filename) {\n                    DumpData(options.size * 2, options.size, pixelData, undefined, \"image/png\", options.filename);\n                    resolve(null);\n                }\n                else {\n                    resolve(pixelData);\n                }\n            });\n        });\n    });\n}\n//# sourceMappingURL=equirectangularCapture.js.map","import { Deferred } from \"./deferred.js\";\n/**\n * Provides a simple way of creating the rough equivalent of an async critical section.\n *\n * @example\n * ```typescript\n * const myLock = new AsyncLock();\n *\n * private async MyFuncAsync(): Promise<void> {\n *   await myLock.lockAsync(async () => {\n *     await operation1Async();\n *     await operation2Async();\n *   });\n * }\n * ```\n */\nexport class AsyncLock {\n    constructor() {\n        this._currentOperation = Promise.resolve();\n    }\n    /**\n     * Executes the provided function when the lock is acquired (e.g. when the previous operation finishes).\n     * @param func The function to execute.\n     * @param signal An optional signal that can be used to abort the operation.\n     * @returns A promise that resolves when the func finishes executing.\n     */\n    lockAsync(func, signal) {\n        signal?.throwIfAborted();\n        const wrappedFunc = signal\n            ? () => {\n                signal.throwIfAborted();\n                return func();\n            }\n            : func;\n        const newOperation = this._currentOperation.then(wrappedFunc);\n        // NOTE: It would be simpler to just hold a Promise<unknown>, but this class should not prevent an object held by the returned promise from being garbage collected.\n        this._currentOperation = new Promise((resolve) => newOperation.then(() => resolve(), resolve));\n        return newOperation;\n    }\n    /**\n     * Executes the provided function when all the specified locks are acquired.\n     * @param func The function to execute.\n     * @param locks The locks to acquire.\n     * @param signal An optional signal that can be used to abort the operation.\n     * @returns A promise that resolves when the func finishes executing.\n     */\n    static async LockAsync(func, locks, signal) {\n        signal?.throwIfAborted();\n        if (locks.length === 0) {\n            return await func();\n        }\n        const deferred = new Deferred();\n        let acquiredLocks = 0;\n        locks.forEach((lock) => lock\n            .lockAsync(async () => {\n            acquiredLocks++;\n            if (acquiredLocks === locks.length) {\n                deferred.resolve(await func());\n            }\n            return deferred.promise;\n        }, signal)\n            .catch((e) => deferred.reject(e)));\n        return deferred.promise;\n    }\n}\n//# sourceMappingURL=asyncLock.js.map","import { Logger } from \"../../Misc/logger.js\";\nimport { VertexData } from \"../../Meshes/mesh.vertexData.js\";\nimport { Mesh } from \"../../Meshes/mesh.js\";\nimport { Epsilon, Vector3, Matrix } from \"../../Maths/math.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\n/**\n * RecastJS navigation plugin\n */\nexport class RecastJSPlugin {\n    /**\n     * Initializes the recastJS plugin\n     * @param recastInjection can be used to inject your own recast reference\n     */\n    constructor(recastInjection = Recast) {\n        /**\n         * Reference to the Recast library\n         */\n        this.bjsRECAST = {};\n        /**\n         * plugin name\n         */\n        this.name = \"RecastJSPlugin\";\n        this._maximumSubStepCount = 10;\n        this._timeStep = 1 / 60;\n        this._timeFactor = 1;\n        this._worker = null;\n        if (typeof recastInjection === \"function\") {\n            Logger.Error(\"RecastJS is not ready. Please make sure you await Recast() before using the plugin.\");\n        }\n        else {\n            this.bjsRECAST = recastInjection;\n        }\n        if (!this.isSupported()) {\n            Logger.Error(\"RecastJS is not available. Please make sure you included the js file.\");\n            return;\n        }\n        this.setTimeStep();\n        this._tempVec1 = new this.bjsRECAST.Vec3();\n        this._tempVec2 = new this.bjsRECAST.Vec3();\n    }\n    /**\n     * Set worker URL to be used when generating a new navmesh\n     * @param workerURL url string\n     * @returns boolean indicating if worker is created\n     */\n    setWorkerURL(workerURL) {\n        if (window && window.Worker) {\n            this._worker = new Worker(workerURL);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Set the time step of the navigation tick update.\n     * Default is 1/60.\n     * A value of 0 will disable fixed time update\n     * @param newTimeStep the new timestep to apply to this world.\n     */\n    setTimeStep(newTimeStep = 1 / 60) {\n        this._timeStep = newTimeStep;\n    }\n    /**\n     * Get the time step of the navigation tick update.\n     * @returns the current time step\n     */\n    getTimeStep() {\n        return this._timeStep;\n    }\n    /**\n     * If delta time in navigation tick update is greater than the time step\n     * a number of sub iterations are done. If more iterations are need to reach deltatime\n     * they will be discarded.\n     * A value of 0 will set to no maximum and update will use as many substeps as needed\n     * @param newStepCount the maximum number of iterations\n     */\n    setMaximumSubStepCount(newStepCount = 10) {\n        this._maximumSubStepCount = newStepCount;\n    }\n    /**\n     * Get the maximum number of iterations per navigation tick update\n     * @returns the maximum number of iterations\n     */\n    getMaximumSubStepCount() {\n        return this._maximumSubStepCount;\n    }\n    /**\n     * Time factor applied when updating crowd agents (default 1). A value of 0 will pause crowd updates.\n     * @param value the time factor applied at update\n     */\n    set timeFactor(value) {\n        this._timeFactor = Math.max(value, 0);\n    }\n    /**\n     * Get the time factor used for crowd agent update\n     * @returns the time factor\n     */\n    get timeFactor() {\n        return this._timeFactor;\n    }\n    /**\n     * Creates a navigation mesh\n     * @param meshes array of all the geometry used to compute the navigation mesh\n     * @param parameters bunch of parameters used to filter geometry\n     * @param completion callback when data is available from the worker. Not used without a worker\n     */\n    createNavMesh(meshes, parameters, completion) {\n        if (this._worker && !completion) {\n            Logger.Warn(\"A worker is avaible but no completion callback. Defaulting to blocking navmesh creation\");\n        }\n        else if (!this._worker && completion) {\n            Logger.Warn(\"A completion callback is avaible but no worker. Defaulting to blocking navmesh creation\");\n        }\n        this.navMesh = new this.bjsRECAST.NavMesh();\n        let index;\n        let tri;\n        let pt;\n        const indices = [];\n        const positions = [];\n        let offset = 0;\n        for (index = 0; index < meshes.length; index++) {\n            if (meshes[index]) {\n                const mesh = meshes[index];\n                const meshIndices = mesh.getIndices();\n                if (!meshIndices) {\n                    continue;\n                }\n                const meshPositions = mesh.getVerticesData(VertexBuffer.PositionKind, false, false);\n                if (!meshPositions) {\n                    continue;\n                }\n                const worldMatrices = [];\n                const worldMatrix = mesh.computeWorldMatrix(true);\n                if (mesh.hasThinInstances) {\n                    const thinMatrices = mesh.thinInstanceGetWorldMatrices();\n                    for (let instanceIndex = 0; instanceIndex < thinMatrices.length; instanceIndex++) {\n                        const tmpMatrix = new Matrix();\n                        const thinMatrix = thinMatrices[instanceIndex];\n                        thinMatrix.multiplyToRef(worldMatrix, tmpMatrix);\n                        worldMatrices.push(tmpMatrix);\n                    }\n                }\n                else {\n                    worldMatrices.push(worldMatrix);\n                }\n                for (let matrixIndex = 0; matrixIndex < worldMatrices.length; matrixIndex++) {\n                    const wm = worldMatrices[matrixIndex];\n                    for (tri = 0; tri < meshIndices.length; tri++) {\n                        indices.push(meshIndices[tri] + offset);\n                    }\n                    const transformed = Vector3.Zero();\n                    const position = Vector3.Zero();\n                    for (pt = 0; pt < meshPositions.length; pt += 3) {\n                        Vector3.FromArrayToRef(meshPositions, pt, position);\n                        Vector3.TransformCoordinatesToRef(position, wm, transformed);\n                        positions.push(transformed.x, transformed.y, transformed.z);\n                    }\n                    offset += meshPositions.length / 3;\n                }\n            }\n        }\n        if (this._worker && completion) {\n            // spawn worker and send message\n            this._worker.postMessage([positions, offset, indices, indices.length, parameters]);\n            this._worker.onmessage = function (e) {\n                completion(e.data);\n            };\n        }\n        else {\n            // blocking calls\n            const rc = new this.bjsRECAST.rcConfig();\n            rc.cs = parameters.cs;\n            rc.ch = parameters.ch;\n            rc.borderSize = parameters.borderSize ? parameters.borderSize : 0;\n            rc.tileSize = parameters.tileSize ? parameters.tileSize : 0;\n            rc.walkableSlopeAngle = parameters.walkableSlopeAngle;\n            rc.walkableHeight = parameters.walkableHeight;\n            rc.walkableClimb = parameters.walkableClimb;\n            rc.walkableRadius = parameters.walkableRadius;\n            rc.maxEdgeLen = parameters.maxEdgeLen;\n            rc.maxSimplificationError = parameters.maxSimplificationError;\n            rc.minRegionArea = parameters.minRegionArea;\n            rc.mergeRegionArea = parameters.mergeRegionArea;\n            rc.maxVertsPerPoly = parameters.maxVertsPerPoly;\n            rc.detailSampleDist = parameters.detailSampleDist;\n            rc.detailSampleMaxError = parameters.detailSampleMaxError;\n            this.navMesh.build(positions, offset, indices, indices.length, rc);\n        }\n    }\n    /**\n     * Create a navigation mesh debug mesh\n     * @param scene is where the mesh will be added\n     * @returns debug display mesh\n     */\n    createDebugNavMesh(scene) {\n        let tri;\n        let pt;\n        const debugNavMesh = this.navMesh.getDebugNavMesh();\n        const triangleCount = debugNavMesh.getTriangleCount();\n        const indices = [];\n        const positions = [];\n        for (tri = 0; tri < triangleCount * 3; tri++) {\n            indices.push(tri);\n        }\n        for (tri = 0; tri < triangleCount; tri++) {\n            for (pt = 0; pt < 3; pt++) {\n                const point = debugNavMesh.getTriangle(tri).getPoint(pt);\n                positions.push(point.x, point.y, point.z);\n            }\n        }\n        const mesh = new Mesh(\"NavMeshDebug\", scene);\n        const vertexData = new VertexData();\n        vertexData.indices = indices;\n        vertexData.positions = positions;\n        vertexData.applyToMesh(mesh, false);\n        return mesh;\n    }\n    /**\n     * Get a navigation mesh constrained position, closest to the parameter position\n     * @param position world position\n     * @returns the closest point to position constrained by the navigation mesh\n     */\n    getClosestPoint(position) {\n        this._tempVec1.x = position.x;\n        this._tempVec1.y = position.y;\n        this._tempVec1.z = position.z;\n        const ret = this.navMesh.getClosestPoint(this._tempVec1);\n        const pr = new Vector3(ret.x, ret.y, ret.z);\n        return pr;\n    }\n    /**\n     * Get a navigation mesh constrained position, closest to the parameter position\n     * @param position world position\n     * @param result output the closest point to position constrained by the navigation mesh\n     */\n    getClosestPointToRef(position, result) {\n        this._tempVec1.x = position.x;\n        this._tempVec1.y = position.y;\n        this._tempVec1.z = position.z;\n        const ret = this.navMesh.getClosestPoint(this._tempVec1);\n        result.set(ret.x, ret.y, ret.z);\n    }\n    /**\n     * Get a navigation mesh constrained position, within a particular radius\n     * @param position world position\n     * @param maxRadius the maximum distance to the constrained world position\n     * @returns the closest point to position constrained by the navigation mesh\n     */\n    getRandomPointAround(position, maxRadius) {\n        this._tempVec1.x = position.x;\n        this._tempVec1.y = position.y;\n        this._tempVec1.z = position.z;\n        const ret = this.navMesh.getRandomPointAround(this._tempVec1, maxRadius);\n        const pr = new Vector3(ret.x, ret.y, ret.z);\n        return pr;\n    }\n    /**\n     * Get a navigation mesh constrained position, within a particular radius\n     * @param position world position\n     * @param maxRadius the maximum distance to the constrained world position\n     * @param result output the closest point to position constrained by the navigation mesh\n     */\n    getRandomPointAroundToRef(position, maxRadius, result) {\n        this._tempVec1.x = position.x;\n        this._tempVec1.y = position.y;\n        this._tempVec1.z = position.z;\n        const ret = this.navMesh.getRandomPointAround(this._tempVec1, maxRadius);\n        result.set(ret.x, ret.y, ret.z);\n    }\n    /**\n     * Compute the final position from a segment made of destination-position\n     * @param position world position\n     * @param destination world position\n     * @returns the resulting point along the navmesh\n     */\n    moveAlong(position, destination) {\n        this._tempVec1.x = position.x;\n        this._tempVec1.y = position.y;\n        this._tempVec1.z = position.z;\n        this._tempVec2.x = destination.x;\n        this._tempVec2.y = destination.y;\n        this._tempVec2.z = destination.z;\n        const ret = this.navMesh.moveAlong(this._tempVec1, this._tempVec2);\n        const pr = new Vector3(ret.x, ret.y, ret.z);\n        return pr;\n    }\n    /**\n     * Compute the final position from a segment made of destination-position\n     * @param position world position\n     * @param destination world position\n     * @param result output the resulting point along the navmesh\n     */\n    moveAlongToRef(position, destination, result) {\n        this._tempVec1.x = position.x;\n        this._tempVec1.y = position.y;\n        this._tempVec1.z = position.z;\n        this._tempVec2.x = destination.x;\n        this._tempVec2.y = destination.y;\n        this._tempVec2.z = destination.z;\n        const ret = this.navMesh.moveAlong(this._tempVec1, this._tempVec2);\n        result.set(ret.x, ret.y, ret.z);\n    }\n    _convertNavPathPoints(navPath) {\n        let pt;\n        const pointCount = navPath.getPointCount();\n        const positions = [];\n        for (pt = 0; pt < pointCount; pt++) {\n            const p = navPath.getPoint(pt);\n            positions.push(new Vector3(p.x, p.y, p.z));\n        }\n        return positions;\n    }\n    /**\n     * Compute a navigation path from start to end. Returns an empty array if no path can be computed\n     * Path is straight.\n     * @param start world position\n     * @param end world position\n     * @returns array containing world position composing the path\n     */\n    computePath(start, end) {\n        this._tempVec1.x = start.x;\n        this._tempVec1.y = start.y;\n        this._tempVec1.z = start.z;\n        this._tempVec2.x = end.x;\n        this._tempVec2.y = end.y;\n        this._tempVec2.z = end.z;\n        const navPath = this.navMesh.computePath(this._tempVec1, this._tempVec2);\n        return this._convertNavPathPoints(navPath);\n    }\n    /**\n     * Compute a navigation path from start to end. Returns an empty array if no path can be computed.\n     * Path follows navigation mesh geometry.\n     * @param start world position\n     * @param end world position\n     * @returns array containing world position composing the path\n     */\n    computePathSmooth(start, end) {\n        this._tempVec1.x = start.x;\n        this._tempVec1.y = start.y;\n        this._tempVec1.z = start.z;\n        this._tempVec2.x = end.x;\n        this._tempVec2.y = end.y;\n        this._tempVec2.z = end.z;\n        const navPath = this.navMesh.computePathSmooth(this._tempVec1, this._tempVec2);\n        return this._convertNavPathPoints(navPath);\n    }\n    /**\n     * Create a new Crowd so you can add agents\n     * @param maxAgents the maximum agent count in the crowd\n     * @param maxAgentRadius the maximum radius an agent can have\n     * @param scene to attach the crowd to\n     * @returns the crowd you can add agents to\n     */\n    createCrowd(maxAgents, maxAgentRadius, scene) {\n        const crowd = new RecastJSCrowd(this, maxAgents, maxAgentRadius, scene);\n        return crowd;\n    }\n    /**\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\n     * The queries will try to find a solution within those bounds\n     * default is (1,1,1)\n     * @param extent x,y,z value that define the extent around the queries point of reference\n     */\n    setDefaultQueryExtent(extent) {\n        this._tempVec1.x = extent.x;\n        this._tempVec1.y = extent.y;\n        this._tempVec1.z = extent.z;\n        this.navMesh.setDefaultQueryExtent(this._tempVec1);\n    }\n    /**\n     * Get the Bounding box extent specified by setDefaultQueryExtent\n     * @returns the box extent values\n     */\n    getDefaultQueryExtent() {\n        const p = this.navMesh.getDefaultQueryExtent();\n        return new Vector3(p.x, p.y, p.z);\n    }\n    /**\n     * build the navmesh from a previously saved state using getNavmeshData\n     * @param data the Uint8Array returned by getNavmeshData\n     */\n    buildFromNavmeshData(data) {\n        const nDataBytes = data.length * data.BYTES_PER_ELEMENT;\n        const dataPtr = this.bjsRECAST._malloc(nDataBytes);\n        const dataHeap = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, dataPtr, nDataBytes);\n        dataHeap.set(data);\n        const buf = new this.bjsRECAST.NavmeshData();\n        buf.dataPointer = dataHeap.byteOffset;\n        buf.size = data.length;\n        this.navMesh = new this.bjsRECAST.NavMesh();\n        this.navMesh.buildFromNavmeshData(buf);\n        // Free memory\n        this.bjsRECAST._free(dataHeap.byteOffset);\n    }\n    /**\n     * returns the navmesh data that can be used later. The navmesh must be built before retrieving the data\n     * @returns data the Uint8Array that can be saved and reused\n     */\n    getNavmeshData() {\n        const navmeshData = this.navMesh.getNavmeshData();\n        const arrView = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, navmeshData.dataPointer, navmeshData.size);\n        const ret = new Uint8Array(navmeshData.size);\n        ret.set(arrView);\n        this.navMesh.freeNavmeshData(navmeshData);\n        return ret;\n    }\n    /**\n     * Get the Bounding box extent result specified by setDefaultQueryExtent\n     * @param result output the box extent values\n     */\n    getDefaultQueryExtentToRef(result) {\n        const p = this.navMesh.getDefaultQueryExtent();\n        result.set(p.x, p.y, p.z);\n    }\n    /**\n     * Disposes\n     */\n    dispose() { }\n    /**\n     * Creates a cylinder obstacle and add it to the navigation\n     * @param position world position\n     * @param radius cylinder radius\n     * @param height cylinder height\n     * @returns the obstacle freshly created\n     */\n    addCylinderObstacle(position, radius, height) {\n        this._tempVec1.x = position.x;\n        this._tempVec1.y = position.y;\n        this._tempVec1.z = position.z;\n        return this.navMesh.addCylinderObstacle(this._tempVec1, radius, height);\n    }\n    /**\n     * Creates an oriented box obstacle and add it to the navigation\n     * @param position world position\n     * @param extent box size\n     * @param angle angle in radians of the box orientation on Y axis\n     * @returns the obstacle freshly created\n     */\n    addBoxObstacle(position, extent, angle) {\n        this._tempVec1.x = position.x;\n        this._tempVec1.y = position.y;\n        this._tempVec1.z = position.z;\n        this._tempVec2.x = extent.x;\n        this._tempVec2.y = extent.y;\n        this._tempVec2.z = extent.z;\n        return this.navMesh.addBoxObstacle(this._tempVec1, this._tempVec2, angle);\n    }\n    /**\n     * Removes an obstacle created by addCylinderObstacle or addBoxObstacle\n     * @param obstacle obstacle to remove from the navigation\n     */\n    removeObstacle(obstacle) {\n        this.navMesh.removeObstacle(obstacle);\n    }\n    /**\n     * If this plugin is supported\n     * @returns true if plugin is supported\n     */\n    isSupported() {\n        return this.bjsRECAST !== undefined;\n    }\n    /**\n     * Returns the seed used for randomized functions like `getRandomPointAround`\n     * @returns seed number\n     */\n    getRandomSeed() {\n        return this.bjsRECAST._getRandomSeed();\n    }\n    /**\n     * Set the seed used for randomized functions like `getRandomPointAround`\n     * @param seed number used as seed for random functions\n     */\n    setRandomSeed(seed) {\n        this.bjsRECAST._setRandomSeed(seed);\n    }\n}\n/**\n * Recast detour crowd implementation\n */\nexport class RecastJSCrowd {\n    /**\n     * Constructor\n     * @param plugin recastJS plugin\n     * @param maxAgents the maximum agent count in the crowd\n     * @param maxAgentRadius the maximum radius an agent can have\n     * @param scene to attach the crowd to\n     * @returns the crowd you can add agents to\n     */\n    constructor(plugin, maxAgents, maxAgentRadius, scene) {\n        /**\n         * Link to the detour crowd\n         */\n        this.recastCrowd = {};\n        /**\n         * One transform per agent\n         */\n        this.transforms = new Array();\n        /**\n         * All agents created\n         */\n        this.agents = new Array();\n        /**\n         * agents reach radius\n         */\n        this.reachRadii = new Array();\n        /**\n         * true when a destination is active for an agent and notifier hasn't been notified of reach\n         */\n        this._agentDestinationArmed = new Array();\n        /**\n         * agent current target\n         */\n        this._agentDestination = new Array();\n        /**\n         * Observer for crowd updates\n         */\n        this._onBeforeAnimationsObserver = null;\n        /**\n         * Fires each time an agent is in reach radius of its destination\n         */\n        this.onReachTargetObservable = new Observable();\n        this.bjsRECASTPlugin = plugin;\n        this.recastCrowd = new this.bjsRECASTPlugin.bjsRECAST.Crowd(maxAgents, maxAgentRadius, this.bjsRECASTPlugin.navMesh.getNavMesh());\n        this._scene = scene;\n        this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n            this.update(scene.getEngine().getDeltaTime() * 0.001 * plugin.timeFactor);\n        });\n    }\n    /**\n     * Add a new agent to the crowd with the specified parameter a corresponding transformNode.\n     * You can attach anything to that node. The node position is updated in the scene update tick.\n     * @param pos world position that will be constrained by the navigation mesh\n     * @param parameters agent parameters\n     * @param transform hooked to the agent that will be update by the scene\n     * @returns agent index\n     */\n    addAgent(pos, parameters, transform) {\n        const agentParams = new this.bjsRECASTPlugin.bjsRECAST.dtCrowdAgentParams();\n        agentParams.radius = parameters.radius;\n        agentParams.height = parameters.height;\n        agentParams.maxAcceleration = parameters.maxAcceleration;\n        agentParams.maxSpeed = parameters.maxSpeed;\n        agentParams.collisionQueryRange = parameters.collisionQueryRange;\n        agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\n        agentParams.separationWeight = parameters.separationWeight;\n        agentParams.updateFlags = 7;\n        agentParams.obstacleAvoidanceType = 0;\n        agentParams.queryFilterType = 0;\n        agentParams.userData = 0;\n        const agentIndex = this.recastCrowd.addAgent(new this.bjsRECASTPlugin.bjsRECAST.Vec3(pos.x, pos.y, pos.z), agentParams);\n        this.transforms.push(transform);\n        this.agents.push(agentIndex);\n        this.reachRadii.push(parameters.reachRadius ? parameters.reachRadius : parameters.radius);\n        this._agentDestinationArmed.push(false);\n        this._agentDestination.push(new Vector3(0, 0, 0));\n        return agentIndex;\n    }\n    /**\n     * Returns the agent position in world space\n     * @param index agent index returned by addAgent\n     * @returns world space position\n     */\n    getAgentPosition(index) {\n        const agentPos = this.recastCrowd.getAgentPosition(index);\n        return new Vector3(agentPos.x, agentPos.y, agentPos.z);\n    }\n    /**\n     * Returns the agent position result in world space\n     * @param index agent index returned by addAgent\n     * @param result output world space position\n     */\n    getAgentPositionToRef(index, result) {\n        const agentPos = this.recastCrowd.getAgentPosition(index);\n        result.set(agentPos.x, agentPos.y, agentPos.z);\n    }\n    /**\n     * Returns the agent velocity in world space\n     * @param index agent index returned by addAgent\n     * @returns world space velocity\n     */\n    getAgentVelocity(index) {\n        const agentVel = this.recastCrowd.getAgentVelocity(index);\n        return new Vector3(agentVel.x, agentVel.y, agentVel.z);\n    }\n    /**\n     * Returns the agent velocity result in world space\n     * @param index agent index returned by addAgent\n     * @param result output world space velocity\n     */\n    getAgentVelocityToRef(index, result) {\n        const agentVel = this.recastCrowd.getAgentVelocity(index);\n        result.set(agentVel.x, agentVel.y, agentVel.z);\n    }\n    /**\n     * Returns the agent next target point on the path\n     * @param index agent index returned by addAgent\n     * @returns world space position\n     */\n    getAgentNextTargetPath(index) {\n        const pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\n        return new Vector3(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\n    }\n    /**\n     * Returns the agent next target point on the path\n     * @param index agent index returned by addAgent\n     * @param result output world space position\n     */\n    getAgentNextTargetPathToRef(index, result) {\n        const pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\n        result.set(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\n    }\n    /**\n     * Gets the agent state\n     * @param index agent index returned by addAgent\n     * @returns agent state\n     */\n    getAgentState(index) {\n        return this.recastCrowd.getAgentState(index);\n    }\n    /**\n     * returns true if the agent in over an off mesh link connection\n     * @param index agent index returned by addAgent\n     * @returns true if over an off mesh link connection\n     */\n    overOffmeshConnection(index) {\n        return this.recastCrowd.overOffmeshConnection(index);\n    }\n    /**\n     * Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh\n     * @param index agent index returned by addAgent\n     * @param destination targeted world position\n     */\n    agentGoto(index, destination) {\n        this.recastCrowd.agentGoto(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\n        // arm observer\n        const item = this.agents.indexOf(index);\n        if (item > -1) {\n            this._agentDestinationArmed[item] = true;\n            this._agentDestination[item].set(destination.x, destination.y, destination.z);\n        }\n    }\n    /**\n     * Teleport the agent to a new position\n     * @param index agent index returned by addAgent\n     * @param destination targeted world position\n     */\n    agentTeleport(index, destination) {\n        this.recastCrowd.agentTeleport(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\n    }\n    /**\n     * Update agent parameters\n     * @param index agent index returned by addAgent\n     * @param parameters agent parameters\n     */\n    updateAgentParameters(index, parameters) {\n        const agentParams = this.recastCrowd.getAgentParameters(index);\n        if (parameters.radius !== undefined) {\n            agentParams.radius = parameters.radius;\n        }\n        if (parameters.height !== undefined) {\n            agentParams.height = parameters.height;\n        }\n        if (parameters.maxAcceleration !== undefined) {\n            agentParams.maxAcceleration = parameters.maxAcceleration;\n        }\n        if (parameters.maxSpeed !== undefined) {\n            agentParams.maxSpeed = parameters.maxSpeed;\n        }\n        if (parameters.collisionQueryRange !== undefined) {\n            agentParams.collisionQueryRange = parameters.collisionQueryRange;\n        }\n        if (parameters.pathOptimizationRange !== undefined) {\n            agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\n        }\n        if (parameters.separationWeight !== undefined) {\n            agentParams.separationWeight = parameters.separationWeight;\n        }\n        this.recastCrowd.setAgentParameters(index, agentParams);\n    }\n    /**\n     * remove a particular agent previously created\n     * @param index agent index returned by addAgent\n     */\n    removeAgent(index) {\n        this.recastCrowd.removeAgent(index);\n        const item = this.agents.indexOf(index);\n        if (item > -1) {\n            this.agents.splice(item, 1);\n            this.transforms.splice(item, 1);\n            this.reachRadii.splice(item, 1);\n            this._agentDestinationArmed.splice(item, 1);\n            this._agentDestination.splice(item, 1);\n        }\n    }\n    /**\n     * get the list of all agents attached to this crowd\n     * @returns list of agent indices\n     */\n    getAgents() {\n        return this.agents;\n    }\n    /**\n     * Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function\n     * @param deltaTime in seconds\n     */\n    update(deltaTime) {\n        // update obstacles\n        this.bjsRECASTPlugin.navMesh.update();\n        if (deltaTime <= Epsilon) {\n            return;\n        }\n        // update crowd\n        const timeStep = this.bjsRECASTPlugin.getTimeStep();\n        const maxStepCount = this.bjsRECASTPlugin.getMaximumSubStepCount();\n        if (timeStep <= Epsilon) {\n            this.recastCrowd.update(deltaTime);\n        }\n        else {\n            let iterationCount = Math.floor(deltaTime / timeStep);\n            if (maxStepCount && iterationCount > maxStepCount) {\n                iterationCount = maxStepCount;\n            }\n            if (iterationCount < 1) {\n                iterationCount = 1;\n            }\n            const step = deltaTime / iterationCount;\n            for (let i = 0; i < iterationCount; i++) {\n                this.recastCrowd.update(step);\n            }\n        }\n        // update transforms\n        for (let index = 0; index < this.agents.length; index++) {\n            // update transform position\n            const agentIndex = this.agents[index];\n            const agentPosition = this.getAgentPosition(agentIndex);\n            this.transforms[index].position = agentPosition;\n            // check agent reach destination\n            if (this._agentDestinationArmed[index]) {\n                const dx = agentPosition.x - this._agentDestination[index].x;\n                const dz = agentPosition.z - this._agentDestination[index].z;\n                const radius = this.reachRadii[index];\n                const groundY = this._agentDestination[index].y - this.reachRadii[index];\n                const ceilingY = this._agentDestination[index].y + this.reachRadii[index];\n                const distanceXZSquared = dx * dx + dz * dz;\n                if (agentPosition.y > groundY && agentPosition.y < ceilingY && distanceXZSquared < radius * radius) {\n                    this._agentDestinationArmed[index] = false;\n                    this.onReachTargetObservable.notifyObservers({ agentIndex: agentIndex, destination: this._agentDestination[index] });\n                }\n            }\n        }\n    }\n    /**\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\n     * The queries will try to find a solution within those bounds\n     * default is (1,1,1)\n     * @param extent x,y,z value that define the extent around the queries point of reference\n     */\n    setDefaultQueryExtent(extent) {\n        const ext = new this.bjsRECASTPlugin.bjsRECAST.Vec3(extent.x, extent.y, extent.z);\n        this.recastCrowd.setDefaultQueryExtent(ext);\n    }\n    /**\n     * Get the Bounding box extent specified by setDefaultQueryExtent\n     * @returns the box extent values\n     */\n    getDefaultQueryExtent() {\n        const p = this.recastCrowd.getDefaultQueryExtent();\n        return new Vector3(p.x, p.y, p.z);\n    }\n    /**\n     * Get the Bounding box extent result specified by setDefaultQueryExtent\n     * @param result output the box extent values\n     */\n    getDefaultQueryExtentToRef(result) {\n        const p = this.recastCrowd.getDefaultQueryExtent();\n        result.set(p.x, p.y, p.z);\n    }\n    /**\n     * Get the next corner points composing the path (max 4 points)\n     * @param index agent index returned by addAgent\n     * @returns array containing world position composing the path\n     */\n    getCorners(index) {\n        let pt;\n        const navPath = this.recastCrowd.getCorners(index);\n        const pointCount = navPath.getPointCount();\n        const positions = [];\n        for (pt = 0; pt < pointCount; pt++) {\n            const p = navPath.getPoint(pt);\n            positions.push(new Vector3(p.x, p.y, p.z));\n        }\n        return positions;\n    }\n    /**\n     * Release all resources\n     */\n    dispose() {\n        this.recastCrowd.destroy();\n        this._scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);\n        this._onBeforeAnimationsObserver = null;\n        this.onReachTargetObservable.clear();\n    }\n}\n//# sourceMappingURL=recastJSPlugin.js.map","import { Vector3, TmpVectors, Quaternion, Vector4, Vector2 } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\nimport { BoundingSphere } from \"../Culling/boundingSphere.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\n/**\n * Represents one particle of a solid particle system.\n */\nexport class SolidParticle {\n    /**\n     * Particle BoundingInfo object\n     * @returns a BoundingInfo\n     */\n    getBoundingInfo() {\n        return this._boundingInfo;\n    }\n    /**\n     * Returns true if there is already a bounding info\n     */\n    get hasBoundingInfo() {\n        return this._boundingInfo !== null;\n    }\n    /**\n     * Creates a Solid Particle object.\n     * Don't create particles manually, use instead the Solid Particle System internal tools like _addParticle()\n     * @param particleIndex (integer) is the particle index in the Solid Particle System pool.\n     * @param particleId (integer) is the particle identifier. Unless some particles are removed from the SPS, it's the same value than the particle idx.\n     * @param positionIndex (integer) is the starting index of the particle vertices in the SPS \"positions\" array.\n     * @param indiceIndex (integer) is the starting index of the particle indices in the SPS \"indices\" array.\n     * @param model (ModelShape) is a reference to the model shape on what the particle is designed.\n     * @param shapeId (integer) is the model shape identifier in the SPS.\n     * @param idxInShape (integer) is the index of the particle in the current model (ex: the 10th box of addShape(box, 30))\n     * @param sps defines the sps it is associated to\n     * @param modelBoundingInfo is the reference to the model BoundingInfo used for intersection computations.\n     * @param materialIndex is the particle material identifier (integer) when the MultiMaterials are enabled in the SPS.\n     */\n    constructor(particleIndex, particleId, positionIndex, indiceIndex, model, shapeId, idxInShape, sps, modelBoundingInfo = null, materialIndex = null) {\n        /**\n         * particle global index\n         */\n        this.idx = 0;\n        /**\n         * particle identifier\n         */\n        this.id = 0;\n        /**\n         * The color of the particle\n         */\n        this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n        /**\n         * The world space position of the particle.\n         */\n        this.position = Vector3.Zero();\n        /**\n         * The world space rotation of the particle. (Not use if rotationQuaternion is set)\n         */\n        this.rotation = Vector3.Zero();\n        /**\n         * The scaling of the particle.\n         */\n        this.scaling = Vector3.One();\n        /**\n         * The uvs of the particle.\n         */\n        this.uvs = new Vector4(0.0, 0.0, 1.0, 1.0);\n        /**\n         * The current speed of the particle.\n         */\n        this.velocity = Vector3.Zero();\n        /**\n         * The pivot point in the particle local space.\n         */\n        this.pivot = Vector3.Zero();\n        /**\n         * Must the particle be translated from its pivot point in its local space ?\n         * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\n         * Default : false\n         */\n        this.translateFromPivot = false;\n        /**\n         * Is the particle active or not ?\n         */\n        this.alive = true;\n        /**\n         * Is the particle visible or not ?\n         */\n        this.isVisible = true;\n        /**\n         * Index of this particle in the global \"positions\" array (Internal use)\n         * @internal\n         */\n        this._pos = 0;\n        /**\n         * @internal Index of this particle in the global \"indices\" array (Internal use)\n         */\n        this._ind = 0;\n        /**\n         * ModelShape id of this particle\n         */\n        this.shapeId = 0;\n        /**\n         * Index of the particle in its shape id\n         */\n        this.idxInShape = 0;\n        /**\n         * @internal Still set as invisible in order to skip useless computations (Internal use)\n         */\n        this._stillInvisible = false;\n        /**\n         * @internal Last computed particle rotation matrix\n         */\n        this._rotationMatrix = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\n        /**\n         * Parent particle Id, if any.\n         * Default null.\n         */\n        this.parentId = null;\n        /**\n         * The particle material identifier (integer) when MultiMaterials are enabled in the SPS.\n         */\n        this.materialIndex = null;\n        /**\n         * Custom object or properties.\n         */\n        this.props = null;\n        /**\n         * The culling strategy to use to check whether the solid particle must be culled or not when using isInFrustum().\n         * The possible values are :\n         * - AbstractMesh.CULLINGSTRATEGY_STANDARD\n         * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\n         * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\n         * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\n         * The default value for solid particles is AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\n         * Please read each static variable documentation in the class AbstractMesh to get details about the culling process.\n         * */\n        this.cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;\n        /**\n         * @internal Internal global position in the SPS.\n         */\n        this._globalPosition = Vector3.Zero();\n        this.idx = particleIndex;\n        this.id = particleId;\n        this._pos = positionIndex;\n        this._ind = indiceIndex;\n        this._model = model;\n        this.shapeId = shapeId;\n        this.idxInShape = idxInShape;\n        this._sps = sps;\n        if (modelBoundingInfo) {\n            this._modelBoundingInfo = modelBoundingInfo;\n            this._boundingInfo = new BoundingInfo(modelBoundingInfo.minimum, modelBoundingInfo.maximum);\n        }\n        if (materialIndex !== null) {\n            this.materialIndex = materialIndex;\n        }\n    }\n    /**\n     * Copies the particle property values into the existing target : position, rotation, scaling, uvs, colors, pivot, parent, visibility, alive\n     * @param target the particle target\n     * @returns the current particle\n     */\n    copyToRef(target) {\n        target.position.copyFrom(this.position);\n        target.rotation.copyFrom(this.rotation);\n        if (this.rotationQuaternion) {\n            if (target.rotationQuaternion) {\n                target.rotationQuaternion.copyFrom(this.rotationQuaternion);\n            }\n            else {\n                target.rotationQuaternion = this.rotationQuaternion.clone();\n            }\n        }\n        target.scaling.copyFrom(this.scaling);\n        if (this.color) {\n            if (target.color) {\n                target.color.copyFrom(this.color);\n            }\n            else {\n                target.color = this.color.clone();\n            }\n        }\n        target.uvs.copyFrom(this.uvs);\n        target.velocity.copyFrom(this.velocity);\n        target.pivot.copyFrom(this.pivot);\n        target.translateFromPivot = this.translateFromPivot;\n        target.alive = this.alive;\n        target.isVisible = this.isVisible;\n        target.parentId = this.parentId;\n        target.cullingStrategy = this.cullingStrategy;\n        if (this.materialIndex !== null) {\n            target.materialIndex = this.materialIndex;\n        }\n        return this;\n    }\n    /**\n     * Legacy support, changed scale to scaling\n     */\n    get scale() {\n        return this.scaling;\n    }\n    /**\n     * Legacy support, changed scale to scaling\n     */\n    set scale(scale) {\n        this.scaling = scale;\n    }\n    /**\n     * Legacy support, changed quaternion to rotationQuaternion\n     */\n    get quaternion() {\n        return this.rotationQuaternion;\n    }\n    /**\n     * Legacy support, changed quaternion to rotationQuaternion\n     */\n    set quaternion(q) {\n        this.rotationQuaternion = q;\n    }\n    /**\n     * Returns a boolean. True if the particle intersects another particle or another mesh, else false.\n     * The intersection is computed on the particle bounding sphere and Axis Aligned Bounding Box (AABB)\n     * @param target is the object (solid particle or mesh) what the intersection is computed against.\n     * @returns true if it intersects\n     */\n    intersectsMesh(target) {\n        if (!this._boundingInfo || !target.hasBoundingInfo) {\n            return false;\n        }\n        if (this._sps._bSphereOnly) {\n            return BoundingSphere.Intersects(this._boundingInfo.boundingSphere, target.getBoundingInfo().boundingSphere);\n        }\n        return this._boundingInfo.intersects(target.getBoundingInfo(), false);\n    }\n    /**\n     * Returns `true` if the solid particle is within the frustum defined by the passed array of planes.\n     * A particle is in the frustum if its bounding box intersects the frustum\n     * @param frustumPlanes defines the frustum to test\n     * @returns true if the particle is in the frustum planes\n     */\n    isInFrustum(frustumPlanes) {\n        return this._boundingInfo !== null && this._boundingInfo.isInFrustum(frustumPlanes, this.cullingStrategy);\n    }\n    /**\n     * get the rotation matrix of the particle\n     * @internal\n     */\n    getRotationMatrix(m) {\n        let quaternion;\n        if (this.rotationQuaternion) {\n            quaternion = this.rotationQuaternion;\n        }\n        else {\n            quaternion = TmpVectors.Quaternion[0];\n            const rotation = this.rotation;\n            Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\n        }\n        quaternion.toRotationMatrix(m);\n    }\n}\n/**\n * Represents the shape of the model used by one particle of a solid particle system.\n * SPS internal tool, don't use it manually.\n */\nexport class ModelShape {\n    /**\n     * Get or set the shapeId\n     * @deprecated Please use shapeId instead\n     */\n    get shapeID() {\n        return this.shapeId;\n    }\n    set shapeID(shapeID) {\n        this.shapeId = shapeID;\n    }\n    /**\n     * Creates a ModelShape object. This is an internal simplified reference to a mesh used as for a model to replicate particles from by the SPS.\n     * SPS internal tool, don't use it manually.\n     * @internal\n     */\n    constructor(id, shape, indices, normals, colors, shapeUV, posFunction, vtxFunction, material) {\n        /**\n         * length of the shape in the model indices array (internal use)\n         * @internal\n         */\n        this._indicesLength = 0;\n        this.shapeId = id;\n        this._shape = shape;\n        this._indices = indices;\n        this._indicesLength = indices.length;\n        this._shapeUV = shapeUV;\n        this._shapeColors = colors;\n        this._normals = normals;\n        this._positionFunction = posFunction;\n        this._vertexFunction = vtxFunction;\n        this._material = material;\n    }\n}\n/**\n * Represents a Depth Sorted Particle in the solid particle system.\n * @internal\n */\nexport class DepthSortedParticle {\n    /**\n     * Creates a new sorted particle\n     * @param idx\n     * @param ind\n     * @param indLength\n     * @param materialIndex\n     */\n    constructor(idx, ind, indLength, materialIndex) {\n        /**\n         * Particle index\n         */\n        this.idx = 0;\n        /**\n         * Index of the particle in the \"indices\" array\n         */\n        this.ind = 0;\n        /**\n         * Length of the particle shape in the \"indices\" array\n         */\n        this.indicesLength = 0;\n        /**\n         * Squared distance from the particle to the camera\n         */\n        this.sqDistance = 0.0;\n        /**\n         * Material index when used with MultiMaterials\n         */\n        this.materialIndex = 0;\n        this.idx = idx;\n        this.ind = ind;\n        this.indicesLength = indLength;\n        this.materialIndex = materialIndex;\n    }\n}\n/**\n * Represents a solid particle vertex\n */\nexport class SolidParticleVertex {\n    /**\n     * Creates a new solid particle vertex\n     */\n    constructor() {\n        this.position = Vector3.Zero();\n        this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n        this.uv = Vector2.Zero();\n    }\n    // Getters and Setters for back-compatibility\n    /** Vertex x coordinate */\n    get x() {\n        return this.position.x;\n    }\n    set x(val) {\n        this.position.x = val;\n    }\n    /** Vertex y coordinate */\n    get y() {\n        return this.position.y;\n    }\n    set y(val) {\n        this.position.y = val;\n    }\n    /** Vertex z coordinate */\n    get z() {\n        return this.position.z;\n    }\n    set z(val) {\n        this.position.z = val;\n    }\n}\n//# sourceMappingURL=solidParticle.js.map","import { Vector3, Matrix, TmpVectors, Quaternion } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { CreateDisc } from \"../Meshes/Builders/discBuilder.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { DepthSortedParticle, SolidParticle, ModelShape, SolidParticleVertex } from \"./solidParticle.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\nimport { Axis } from \"../Maths/math.axis.js\";\nimport { SubMesh } from \"../Meshes/subMesh.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { MultiMaterial } from \"../Materials/multiMaterial.js\";\n/**\n * The SPS is a single updatable mesh. The solid particles are simply separate parts or faces of this big mesh.\n *As it is just a mesh, the SPS has all the same properties than any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\n\n * The SPS is also a particle system. It provides some methods to manage the particles.\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\n *\n * Full documentation here : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/sps_intro\n */\nexport class SolidParticleSystem {\n    /**\n     * Creates a SPS (Solid Particle System) object.\n     * @param name (String) is the SPS name, this will be the underlying mesh name.\n     * @param scene (Scene) is the scene in which the SPS is added.\n     * @param options defines the options of the sps e.g.\n     * * updatable (optional boolean, default true) : if the SPS must be updatable or immutable.\n     * * isPickable (optional boolean, default false) : if the solid particles must be pickable.\n     * * enableDepthSort (optional boolean, default false) : if the solid particles must be sorted in the geometry according to their distance to the camera.\n     * * useModelMaterial (optional boolean, default false) : if the model materials must be used to create the SPS multimaterial. This enables the multimaterial supports of the SPS.\n     * * enableMultiMaterial (optional boolean, default false) : if the solid particles can be given different materials.\n     * * expandable (optional boolean, default false) : if particles can still be added after the initial SPS mesh creation.\n     * * particleIntersection (optional boolean, default false) : if the solid particle intersections must be computed.\n     * * boundingSphereOnly (optional boolean, default false) : if the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster).\n     * * bSphereRadiusFactor (optional float, default 1.0) : a number to multiply the bounding sphere radius by in order to reduce it for instance.\n     * * computeBoundingBox (optional boolean, default false): if the bounding box of the entire SPS will be computed (for occlusion detection, for example). If it is false, the bounding box will be the bounding box of the first particle.\n     * * autoFixFaceOrientation (optional boolean, default false): if the particle face orientations will be flipped for transformations that change orientation (scale (-1, 1, 1), for example)\n     * @param options.updatable\n     * @param options.isPickable\n     * @param options.enableDepthSort\n     * @param options.particleIntersection\n     * @param options.boundingSphereOnly\n     * @param options.bSphereRadiusFactor\n     * @param options.expandable\n     * @param options.useModelMaterial\n     * @param options.enableMultiMaterial\n     * @param options.computeBoundingBox\n     * @param options.autoFixFaceOrientation\n     * @example bSphereRadiusFactor = 1.0 / Math.sqrt(3.0) => the bounding sphere exactly matches a spherical mesh.\n     */\n    constructor(name, scene, options) {\n        /**\n         *  The SPS array of Solid Particle objects. Just access each particle as with any classic array.\n         *  Example : var p = SPS.particles[i];\n         */\n        this.particles = new Array();\n        /**\n         * The SPS total number of particles. Read only. Use SPS.counter instead if you need to set your own value.\n         */\n        this.nbParticles = 0;\n        /**\n         * If the particles must ever face the camera (default false). Useful for planar particles.\n         */\n        this.billboard = false;\n        /**\n         * Recompute normals when adding a shape\n         */\n        this.recomputeNormals = false;\n        /**\n         * This a counter ofr your own usage. It's not set by any SPS functions.\n         */\n        this.counter = 0;\n        /**\n         * This empty object is intended to store some SPS specific or temporary values in order to lower the Garbage Collector activity.\n         * Please read : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/optimize_sps#limit-garbage-collection\n         */\n        this.vars = {};\n        /**\n         * If the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster). (Internal use only)\n         * @internal\n         */\n        this._bSphereOnly = false;\n        /**\n         * A number to multiply the bounding sphere radius by in order to reduce it for instance. (Internal use only)\n         * @internal\n         */\n        this._bSphereRadiusFactor = 1.0;\n        this._positions = new Array();\n        this._indices = new Array();\n        this._normals = new Array();\n        this._colors = new Array();\n        this._uvs = new Array();\n        this._index = 0; // indices index\n        this._updatable = true;\n        this._pickable = false;\n        this._isVisibilityBoxLocked = false;\n        this._alwaysVisible = false;\n        this._depthSort = false;\n        this._expandable = false;\n        this._shapeCounter = 0;\n        this._copy = new SolidParticle(0, 0, 0, 0, null, 0, 0, this);\n        this._color = new Color4(0, 0, 0, 0);\n        this._computeParticleColor = true;\n        this._computeParticleTexture = true;\n        this._computeParticleRotation = true;\n        this._computeParticleVertex = false;\n        this._computeBoundingBox = false;\n        this._autoFixFaceOrientation = false;\n        this._depthSortParticles = true;\n        this._mustUnrotateFixedNormals = false;\n        this._particlesIntersect = false;\n        this._needs32Bits = false;\n        this._isNotBuilt = true;\n        this._lastParticleId = 0;\n        this._idxOfId = []; // array : key = particle.id / value = particle.idx\n        this._multimaterialEnabled = false;\n        this._useModelMaterial = false;\n        this._depthSortFunction = (p1, p2) => p2.sqDistance - p1.sqDistance;\n        this._materialSortFunction = (p1, p2) => p1.materialIndex - p2.materialIndex;\n        this._autoUpdateSubMeshes = false;\n        this._recomputeInvisibles = false;\n        this.name = name;\n        this._scene = scene || EngineStore.LastCreatedScene;\n        this._camera = scene.activeCamera;\n        this._pickable = options ? options.isPickable : false;\n        this._depthSort = options ? options.enableDepthSort : false;\n        this._multimaterialEnabled = options ? options.enableMultiMaterial : false;\n        this._useModelMaterial = options ? options.useModelMaterial : false;\n        this._multimaterialEnabled = this._useModelMaterial ? true : this._multimaterialEnabled;\n        this._expandable = options ? options.expandable : false;\n        this._particlesIntersect = options ? options.particleIntersection : false;\n        this._bSphereOnly = options ? options.boundingSphereOnly : false;\n        this._bSphereRadiusFactor = options && options.bSphereRadiusFactor ? options.bSphereRadiusFactor : 1.0;\n        this._computeBoundingBox = options?.computeBoundingBox ? options.computeBoundingBox : false;\n        this._autoFixFaceOrientation = options?.autoFixFaceOrientation ? options.autoFixFaceOrientation : false;\n        if (options && options.updatable !== undefined) {\n            this._updatable = options.updatable;\n        }\n        else {\n            this._updatable = true;\n        }\n        if (this._pickable) {\n            this.pickedBySubMesh = [[]];\n            this.pickedParticles = this.pickedBySubMesh[0];\n        }\n        if (this._depthSort || this._multimaterialEnabled) {\n            this.depthSortedParticles = [];\n        }\n        if (this._multimaterialEnabled) {\n            this._multimaterial = new MultiMaterial(this.name + \"MultiMaterial\", this._scene);\n            this._materials = [];\n            this._materialIndexesById = {};\n        }\n        this._tmpVertex = new SolidParticleVertex();\n    }\n    /**\n     * Builds the SPS underlying mesh. Returns a standard Mesh.\n     * If no model shape was added to the SPS, the returned mesh is just a single triangular plane.\n     * @returns the created mesh\n     */\n    buildMesh() {\n        if (!this._isNotBuilt && this.mesh) {\n            return this.mesh;\n        }\n        if (this.nbParticles === 0 && !this.mesh) {\n            const triangle = CreateDisc(\"\", { radius: 1, tessellation: 3 }, this._scene);\n            this.addShape(triangle, 1);\n            triangle.dispose();\n        }\n        this._indices32 = this._needs32Bits ? new Uint32Array(this._indices) : new Uint16Array(this._indices);\n        this._positions32 = new Float32Array(this._positions);\n        this._uvs32 = new Float32Array(this._uvs);\n        this._colors32 = new Float32Array(this._colors);\n        if (!this.mesh) {\n            // in case it's already expanded\n            const mesh = new Mesh(this.name, this._scene);\n            this.mesh = mesh;\n        }\n        if (!this._updatable && this._multimaterialEnabled) {\n            this._sortParticlesByMaterial(); // this may reorder the indices32\n        }\n        if (this.recomputeNormals) {\n            VertexData.ComputeNormals(this._positions32, this._indices32, this._normals);\n        }\n        this._normals32 = new Float32Array(this._normals);\n        this._fixedNormal32 = new Float32Array(this._normals);\n        if (this._mustUnrotateFixedNormals) {\n            // the particles could be created already rotated in the mesh with a positionFunction\n            this._unrotateFixedNormals();\n        }\n        const vertexData = new VertexData();\n        vertexData.indices = this._depthSort ? this._indices : this._indices32;\n        vertexData.set(this._positions32, VertexBuffer.PositionKind);\n        vertexData.set(this._normals32, VertexBuffer.NormalKind);\n        if (this._uvs32.length > 0) {\n            vertexData.set(this._uvs32, VertexBuffer.UVKind);\n        }\n        if (this._colors32.length > 0) {\n            vertexData.set(this._colors32, VertexBuffer.ColorKind);\n        }\n        vertexData.applyToMesh(this.mesh, this._updatable);\n        this.mesh.isPickable = this._pickable;\n        if (this._pickable) {\n            let faceId = 0;\n            for (let p = 0; p < this.nbParticles; p++) {\n                const part = this.particles[p];\n                const lind = part._model._indicesLength;\n                for (let i = 0; i < lind; i++) {\n                    const f = i % 3;\n                    if (f == 0) {\n                        const pickedData = { idx: part.idx, faceId: faceId };\n                        this.pickedParticles[faceId] = pickedData;\n                        faceId++;\n                    }\n                }\n            }\n        }\n        if (this._multimaterialEnabled) {\n            this.setMultiMaterial(this._materials);\n        }\n        if (!this._expandable) {\n            // free memory\n            if (!this._depthSort && !this._multimaterialEnabled && !this._autoFixFaceOrientation) {\n                this._indices = null;\n            }\n            this._positions = null;\n            this._normals = null;\n            this._uvs = null;\n            this._colors = null;\n            if (!this._updatable) {\n                this.particles.length = 0;\n            }\n        }\n        this._isNotBuilt = false;\n        this.recomputeNormals = false;\n        this._recomputeInvisibles = true;\n        return this.mesh;\n    }\n    _getUVKind(mesh, uvKind) {\n        if (uvKind === -1) {\n            if (mesh.material?.diffuseTexture) {\n                uvKind = mesh.material.diffuseTexture.coordinatesIndex;\n            }\n            else if (mesh.material?.albedoTexture) {\n                uvKind = mesh.material.albedoTexture.coordinatesIndex;\n            }\n        }\n        return \"uv\" + (uvKind ? uvKind + 1 : \"\");\n    }\n    /**\n     * Digests the mesh and generates as many solid particles in the system as wanted. Returns the SPS.\n     * These particles will have the same geometry than the mesh parts and will be positioned at the same localisation than the mesh original places.\n     * Thus the particles generated from `digest()` have their property `position` set yet.\n     * @param mesh ( Mesh ) is the mesh to be digested\n     * @param options {facetNb} (optional integer, default 1) is the number of mesh facets per particle, this parameter is overridden by the parameter `number` if any\n     * {delta} (optional integer, default 0) is the random extra number of facets per particle , each particle will have between `facetNb` and `facetNb + delta` facets\n     * {number} (optional positive integer) is the wanted number of particles : each particle is built with `mesh_total_facets / number` facets\n     * {storage} (optional existing array) is an array where the particles will be stored for a further use instead of being inserted in the SPS.\n     * {uvKind} (optional positive integer, default 0) is the kind of UV to read from. Use -1 to deduce it from the diffuse/albedo texture (if any) of the mesh material\n     * @param options.facetNb\n     * @param options.number\n     * @param options.delta\n     * @param options.storage\n     * @param options.uvKind\n     * @returns the current SPS\n     */\n    digest(mesh, options) {\n        let size = (options && options.facetNb) || 1;\n        let number = (options && options.number) || 0;\n        let delta = (options && options.delta) || 0;\n        const meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n        const meshInd = mesh.getIndices();\n        const meshUV = mesh.getVerticesData(this._getUVKind(mesh, options?.uvKind ?? 0));\n        const meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);\n        const meshNor = mesh.getVerticesData(VertexBuffer.NormalKind);\n        const storage = options && options.storage ? options.storage : null;\n        let f = 0; // facet counter\n        const totalFacets = meshInd.length / 3; // a facet is a triangle, so 3 indices\n        // compute size from number\n        if (number) {\n            number = number > totalFacets ? totalFacets : number;\n            size = Math.round(totalFacets / number);\n            delta = 0;\n        }\n        else {\n            size = size > totalFacets ? totalFacets : size;\n        }\n        const facetPos = []; // submesh positions\n        const facetNor = [];\n        const facetInd = []; // submesh indices\n        const facetUV = []; // submesh UV\n        const facetCol = []; // submesh colors\n        const barycenter = Vector3.Zero();\n        const sizeO = size;\n        while (f < totalFacets) {\n            size = sizeO + Math.floor((1 + delta) * Math.random());\n            if (f > totalFacets - size) {\n                size = totalFacets - f;\n            }\n            // reset temp arrays\n            facetPos.length = 0;\n            facetNor.length = 0;\n            facetInd.length = 0;\n            facetUV.length = 0;\n            facetCol.length = 0;\n            // iterate over \"size\" facets\n            let fi = 0;\n            for (let j = f * 3; j < (f + size) * 3; j++) {\n                facetInd.push(fi);\n                const i = meshInd[j];\n                const i3 = i * 3;\n                facetPos.push(meshPos[i3], meshPos[i3 + 1], meshPos[i3 + 2]);\n                facetNor.push(meshNor[i3], meshNor[i3 + 1], meshNor[i3 + 2]);\n                if (meshUV) {\n                    const i2 = i * 2;\n                    facetUV.push(meshUV[i2], meshUV[i2 + 1]);\n                }\n                if (meshCol) {\n                    const i4 = i * 4;\n                    facetCol.push(meshCol[i4], meshCol[i4 + 1], meshCol[i4 + 2], meshCol[i4 + 3]);\n                }\n                fi++;\n            }\n            // create a model shape for each single particle\n            let idx = this.nbParticles;\n            const shape = this._posToShape(facetPos);\n            const shapeUV = this._uvsToShapeUV(facetUV);\n            const shapeInd = facetInd.slice();\n            const shapeCol = facetCol.slice();\n            const shapeNor = facetNor.slice();\n            // compute the barycenter of the shape\n            barycenter.copyFromFloats(0, 0, 0);\n            let v;\n            for (v = 0; v < shape.length; v++) {\n                barycenter.addInPlace(shape[v]);\n            }\n            barycenter.scaleInPlace(1 / shape.length);\n            // shift the shape from its barycenter to the origin\n            // and compute the BBox required for intersection.\n            const minimum = new Vector3(Infinity, Infinity, Infinity);\n            const maximum = new Vector3(-Infinity, -Infinity, -Infinity);\n            for (v = 0; v < shape.length; v++) {\n                shape[v].subtractInPlace(barycenter);\n                minimum.minimizeInPlaceFromFloats(shape[v].x, shape[v].y, shape[v].z);\n                maximum.maximizeInPlaceFromFloats(shape[v].x, shape[v].y, shape[v].z);\n            }\n            let bInfo;\n            if (this._particlesIntersect) {\n                bInfo = new BoundingInfo(minimum, maximum);\n            }\n            let material = null;\n            if (this._useModelMaterial) {\n                material = mesh.material ? mesh.material : this._setDefaultMaterial();\n            }\n            const modelShape = new ModelShape(this._shapeCounter, shape, shapeInd, shapeNor, shapeCol, shapeUV, null, null, material);\n            // add the particle in the SPS\n            const currentPos = this._positions.length;\n            const currentInd = this._indices.length;\n            this._meshBuilder(this._index, currentInd, shape, this._positions, shapeInd, this._indices, facetUV, this._uvs, shapeCol, this._colors, shapeNor, this._normals, idx, 0, null, modelShape);\n            this._addParticle(idx, this._lastParticleId, currentPos, currentInd, modelShape, this._shapeCounter, 0, bInfo, storage);\n            // initialize the particle position\n            this.particles[this.nbParticles].position.addInPlace(barycenter);\n            if (!storage) {\n                this._index += shape.length;\n                idx++;\n                this.nbParticles++;\n                this._lastParticleId++;\n            }\n            this._shapeCounter++;\n            f += size;\n        }\n        this._isNotBuilt = true; // buildMesh() is now expected for setParticles() to work\n        return this;\n    }\n    /**\n     * Unrotate the fixed normals in case the mesh was built with pre-rotated particles, ex : use of positionFunction in addShape()\n     * @internal\n     */\n    _unrotateFixedNormals() {\n        let index = 0;\n        let idx = 0;\n        const tmpNormal = TmpVectors.Vector3[0];\n        const quaternion = TmpVectors.Quaternion[0];\n        const invertedRotMatrix = TmpVectors.Matrix[0];\n        for (let p = 0; p < this.particles.length; p++) {\n            const particle = this.particles[p];\n            const shape = particle._model._shape;\n            // computing the inverse of the rotation matrix from the quaternion\n            // is equivalent to computing the matrix of the inverse quaternion, i.e of the conjugate quaternion\n            if (particle.rotationQuaternion) {\n                particle.rotationQuaternion.conjugateToRef(quaternion);\n            }\n            else {\n                const rotation = particle.rotation;\n                Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\n                quaternion.conjugateInPlace();\n            }\n            quaternion.toRotationMatrix(invertedRotMatrix);\n            for (let pt = 0; pt < shape.length; pt++) {\n                idx = index + pt * 3;\n                Vector3.TransformNormalFromFloatsToRef(this._normals32[idx], this._normals32[idx + 1], this._normals32[idx + 2], invertedRotMatrix, tmpNormal);\n                tmpNormal.toArray(this._fixedNormal32, idx);\n            }\n            index = idx + 3;\n        }\n    }\n    /**\n     * Resets the temporary working copy particle\n     * @internal\n     */\n    _resetCopy() {\n        const copy = this._copy;\n        copy.position.setAll(0);\n        copy.rotation.setAll(0);\n        copy.rotationQuaternion = null;\n        copy.scaling.setAll(1);\n        copy.uvs.copyFromFloats(0.0, 0.0, 1.0, 1.0);\n        copy.color = null;\n        copy.translateFromPivot = false;\n        copy.shapeId = 0;\n        copy.materialIndex = null;\n    }\n    /**\n     * Inserts the shape model geometry in the global SPS mesh by updating the positions, indices, normals, colors, uvs arrays\n     * @param p the current index in the positions array to be updated\n     * @param ind the current index in the indices array\n     * @param shape a Vector3 array, the shape geometry\n     * @param positions the positions array to be updated\n     * @param meshInd the shape indices array\n     * @param indices the indices array to be updated\n     * @param meshUV the shape uv array\n     * @param uvs the uv array to be updated\n     * @param meshCol the shape color array\n     * @param colors the color array to be updated\n     * @param meshNor the shape normals array\n     * @param normals the normals array to be updated\n     * @param idx the particle index\n     * @param idxInShape the particle index in its shape\n     * @param options the addShape() method  passed options\n     * @param model\n     * @model the particle model\n     * @internal\n     */\n    _meshBuilder(p, ind, shape, positions, meshInd, indices, meshUV, uvs, meshCol, colors, meshNor, normals, idx, idxInShape, options, model) {\n        let i;\n        let u = 0;\n        let c = 0;\n        let n = 0;\n        this._resetCopy();\n        const copy = this._copy;\n        const storeApart = options && options.storage ? true : false;\n        copy.idx = idx;\n        copy.idxInShape = idxInShape;\n        copy.shapeId = model.shapeId;\n        if (this._useModelMaterial) {\n            const materialId = model._material.uniqueId;\n            const materialIndexesById = this._materialIndexesById;\n            if (!Object.prototype.hasOwnProperty.call(materialIndexesById, materialId)) {\n                materialIndexesById[materialId] = this._materials.length;\n                this._materials.push(model._material);\n            }\n            const matIdx = materialIndexesById[materialId];\n            copy.materialIndex = matIdx;\n        }\n        if (options && options.positionFunction) {\n            // call to custom positionFunction\n            options.positionFunction(copy, idx, idxInShape);\n            this._mustUnrotateFixedNormals = true;\n        }\n        // in case the particle geometry must NOT be inserted in the SPS mesh geometry\n        if (storeApart) {\n            return copy;\n        }\n        const rotMatrix = TmpVectors.Matrix[0];\n        const tmpVertex = this._tmpVertex;\n        const tmpVector = tmpVertex.position;\n        const tmpColor = tmpVertex.color;\n        const tmpUV = tmpVertex.uv;\n        const tmpRotated = TmpVectors.Vector3[1];\n        const pivotBackTranslation = TmpVectors.Vector3[2];\n        const scaledPivot = TmpVectors.Vector3[3];\n        Matrix.IdentityToRef(rotMatrix);\n        copy.getRotationMatrix(rotMatrix);\n        copy.pivot.multiplyToRef(copy.scaling, scaledPivot);\n        if (copy.translateFromPivot) {\n            pivotBackTranslation.setAll(0.0);\n        }\n        else {\n            pivotBackTranslation.copyFrom(scaledPivot);\n        }\n        const someVertexFunction = options && options.vertexFunction;\n        for (i = 0; i < shape.length; i++) {\n            tmpVector.copyFrom(shape[i]);\n            if (copy.color) {\n                tmpColor.copyFrom(copy.color);\n            }\n            if (meshUV) {\n                tmpUV.copyFromFloats(meshUV[u], meshUV[u + 1]);\n            }\n            if (someVertexFunction) {\n                options.vertexFunction(copy, tmpVertex, i);\n            }\n            tmpVector.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);\n            Vector3.TransformCoordinatesToRef(tmpVector, rotMatrix, tmpRotated);\n            tmpRotated.addInPlace(pivotBackTranslation).addInPlace(copy.position);\n            positions.push(tmpRotated.x, tmpRotated.y, tmpRotated.z);\n            if (meshUV) {\n                const copyUvs = copy.uvs;\n                uvs.push((copyUvs.z - copyUvs.x) * tmpUV.x + copyUvs.x, (copyUvs.w - copyUvs.y) * tmpUV.y + copyUvs.y);\n                u += 2;\n            }\n            if (copy.color) {\n                this._color.copyFrom(tmpColor);\n            }\n            else {\n                const color = this._color;\n                if (meshCol && meshCol[c] !== undefined) {\n                    color.r = meshCol[c];\n                    color.g = meshCol[c + 1];\n                    color.b = meshCol[c + 2];\n                    color.a = meshCol[c + 3];\n                }\n                else {\n                    color.r = 1.0;\n                    color.g = 1.0;\n                    color.b = 1.0;\n                    color.a = 1.0;\n                }\n            }\n            colors.push(this._color.r, this._color.g, this._color.b, this._color.a);\n            c += 4;\n            if (!this.recomputeNormals && meshNor) {\n                Vector3.TransformNormalFromFloatsToRef(meshNor[n], meshNor[n + 1], meshNor[n + 2], rotMatrix, tmpVector);\n                normals.push(tmpVector.x, tmpVector.y, tmpVector.z);\n                n += 3;\n            }\n        }\n        for (i = 0; i < meshInd.length; i++) {\n            const current_ind = p + meshInd[i];\n            indices.push(current_ind);\n            if (current_ind > 65535) {\n                this._needs32Bits = true;\n            }\n        }\n        if (this._depthSort || this._multimaterialEnabled) {\n            const matIndex = copy.materialIndex !== null ? copy.materialIndex : 0;\n            this.depthSortedParticles.push(new DepthSortedParticle(idx, ind, meshInd.length, matIndex));\n        }\n        return copy;\n    }\n    /**\n     * Returns a shape Vector3 array from positions float array\n     * @param positions float array\n     * @returns a vector3 array\n     * @internal\n     */\n    _posToShape(positions) {\n        const shape = [];\n        for (let i = 0; i < positions.length; i += 3) {\n            shape.push(Vector3.FromArray(positions, i));\n        }\n        return shape;\n    }\n    /**\n     * Returns a shapeUV array from a float uvs (array deep copy)\n     * @param uvs as a float array\n     * @returns a shapeUV array\n     * @internal\n     */\n    _uvsToShapeUV(uvs) {\n        const shapeUV = [];\n        if (uvs) {\n            for (let i = 0; i < uvs.length; i++) {\n                shapeUV.push(uvs[i]);\n            }\n        }\n        return shapeUV;\n    }\n    /**\n     * Adds a new particle object in the particles array\n     * @param idx particle index in particles array\n     * @param id particle id\n     * @param idxpos positionIndex : the starting index of the particle vertices in the SPS \"positions\" array\n     * @param idxind indiceIndex : he starting index of the particle indices in the SPS \"indices\" array\n     * @param model particle ModelShape object\n     * @param shapeId model shape identifier\n     * @param idxInShape index of the particle in the current model\n     * @param bInfo model bounding info object\n     * @param storage target storage array, if any\n     * @internal\n     */\n    _addParticle(idx, id, idxpos, idxind, model, shapeId, idxInShape, bInfo = null, storage = null) {\n        const sp = new SolidParticle(idx, id, idxpos, idxind, model, shapeId, idxInShape, this, bInfo);\n        const target = storage ? storage : this.particles;\n        target.push(sp);\n        return sp;\n    }\n    /**\n     * Adds some particles to the SPS from the model shape. Returns the shape id.\n     * Please read the doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/immutable_sps\n     * @param mesh is any Mesh object that will be used as a model for the solid particles. If the mesh does not have vertex normals, it will turn on the recomputeNormals attribute.\n     * @param nb (positive integer) the number of particles to be created from this model\n     * @param options {positionFunction} is an optional javascript function to called for each particle on SPS creation.\n     * {vertexFunction} is an optional javascript function to called for each vertex of each particle on SPS creation\n     * {storage} (optional existing array) is an array where the particles will be stored for a further use instead of being inserted in the SPS.\n     * @param options.positionFunction\n     * @param options.vertexFunction\n     * @param options.storage\n     * @returns the number of shapes in the system\n     */\n    addShape(mesh, nb, options) {\n        const meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n        const meshInd = mesh.getIndices();\n        const meshUV = mesh.getVerticesData(VertexBuffer.UVKind);\n        const meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);\n        const meshNor = mesh.getVerticesData(VertexBuffer.NormalKind);\n        this.recomputeNormals = meshNor ? false : true;\n        const indices = Array.from(meshInd);\n        const shapeNormals = meshNor ? Array.from(meshNor) : [];\n        const shapeColors = meshCol ? Array.from(meshCol) : [];\n        const storage = options && options.storage ? options.storage : null;\n        let bbInfo = null;\n        if (this._particlesIntersect) {\n            bbInfo = mesh.getBoundingInfo();\n        }\n        const shape = this._posToShape(meshPos);\n        const shapeUV = this._uvsToShapeUV(meshUV);\n        const posfunc = options ? options.positionFunction : null;\n        const vtxfunc = options ? options.vertexFunction : null;\n        let material = null;\n        if (this._useModelMaterial) {\n            material = mesh.material ? mesh.material : this._setDefaultMaterial();\n        }\n        const modelShape = new ModelShape(this._shapeCounter, shape, indices, shapeNormals, shapeColors, shapeUV, posfunc, vtxfunc, material);\n        // particles\n        for (let i = 0; i < nb; i++) {\n            this._insertNewParticle(this.nbParticles, i, modelShape, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, storage, options);\n        }\n        this._shapeCounter++;\n        this._isNotBuilt = true; // buildMesh() call is now expected for setParticles() to work\n        return this._shapeCounter - 1;\n    }\n    /**\n     * Rebuilds a particle back to its just built status : if needed, recomputes the custom positions and vertices\n     * @internal\n     */\n    _rebuildParticle(particle, reset = false) {\n        this._resetCopy();\n        const copy = this._copy;\n        if (particle._model._positionFunction) {\n            // recall to stored custom positionFunction\n            particle._model._positionFunction(copy, particle.idx, particle.idxInShape);\n        }\n        const rotMatrix = TmpVectors.Matrix[0];\n        const tmpVertex = TmpVectors.Vector3[0];\n        const tmpRotated = TmpVectors.Vector3[1];\n        const pivotBackTranslation = TmpVectors.Vector3[2];\n        const scaledPivot = TmpVectors.Vector3[3];\n        copy.getRotationMatrix(rotMatrix);\n        particle.pivot.multiplyToRef(particle.scaling, scaledPivot);\n        if (copy.translateFromPivot) {\n            pivotBackTranslation.copyFromFloats(0.0, 0.0, 0.0);\n        }\n        else {\n            pivotBackTranslation.copyFrom(scaledPivot);\n        }\n        const shape = particle._model._shape;\n        for (let pt = 0; pt < shape.length; pt++) {\n            tmpVertex.copyFrom(shape[pt]);\n            if (particle._model._vertexFunction) {\n                particle._model._vertexFunction(copy, tmpVertex, pt); // recall to stored vertexFunction\n            }\n            tmpVertex.multiplyInPlace(copy.scaling).subtractInPlace(scaledPivot);\n            Vector3.TransformCoordinatesToRef(tmpVertex, rotMatrix, tmpRotated);\n            tmpRotated\n                .addInPlace(pivotBackTranslation)\n                .addInPlace(copy.position)\n                .toArray(this._positions32, particle._pos + pt * 3);\n        }\n        if (reset) {\n            particle.position.setAll(0.0);\n            particle.rotation.setAll(0.0);\n            particle.rotationQuaternion = null;\n            particle.scaling.setAll(1.0);\n            particle.uvs.setAll(0.0);\n            particle.pivot.setAll(0.0);\n            particle.translateFromPivot = false;\n            particle.parentId = null;\n        }\n    }\n    /**\n     * Rebuilds the whole mesh and updates the VBO : custom positions and vertices are recomputed if needed.\n     * @param reset boolean, default false : if the particles must be reset at position and rotation zero, scaling 1, color white, initial UVs and not parented.\n     * @returns the SPS.\n     */\n    rebuildMesh(reset = false) {\n        for (let p = 0; p < this.particles.length; p++) {\n            this._rebuildParticle(this.particles[p], reset);\n        }\n        this.mesh.updateVerticesData(VertexBuffer.PositionKind, this._positions32, false, false);\n        return this;\n    }\n    /** Removes the particles from the start-th to the end-th included from an expandable SPS (required).\n     *  Returns an array with the removed particles.\n     *  If the number of particles to remove is lower than zero or greater than the global remaining particle number, then an empty array is returned.\n     *  The SPS can't be empty so at least one particle needs to remain in place.\n     *  Under the hood, the VertexData array, so the VBO buffer, is recreated each call.\n     * @param start index of the first particle to remove\n     * @param end index of the last particle to remove (included)\n     * @returns an array populated with the removed particles\n     */\n    removeParticles(start, end) {\n        const nb = end - start + 1;\n        if (!this._expandable || nb <= 0 || nb >= this.nbParticles || !this._updatable) {\n            return [];\n        }\n        const particles = this.particles;\n        const currentNb = this.nbParticles;\n        if (end < currentNb - 1) {\n            // update the particle indexes in the positions array in case they're remaining particles after the last removed\n            const firstRemaining = end + 1;\n            const shiftPos = particles[firstRemaining]._pos - particles[start]._pos;\n            const shifInd = particles[firstRemaining]._ind - particles[start]._ind;\n            for (let i = firstRemaining; i < currentNb; i++) {\n                const part = particles[i];\n                part._pos -= shiftPos;\n                part._ind -= shifInd;\n            }\n        }\n        const removed = particles.splice(start, nb);\n        this._positions.length = 0;\n        this._indices.length = 0;\n        this._colors.length = 0;\n        this._uvs.length = 0;\n        this._normals.length = 0;\n        this._index = 0;\n        this._idxOfId.length = 0;\n        if (this._depthSort || this._multimaterialEnabled) {\n            this.depthSortedParticles = [];\n        }\n        let ind = 0;\n        const particlesLength = particles.length;\n        for (let p = 0; p < particlesLength; p++) {\n            const particle = particles[p];\n            const model = particle._model;\n            const shape = model._shape;\n            const modelIndices = model._indices;\n            const modelNormals = model._normals;\n            const modelColors = model._shapeColors;\n            const modelUVs = model._shapeUV;\n            particle.idx = p;\n            this._idxOfId[particle.id] = p;\n            this._meshBuilder(this._index, ind, shape, this._positions, modelIndices, this._indices, modelUVs, this._uvs, modelColors, this._colors, modelNormals, this._normals, particle.idx, particle.idxInShape, null, model);\n            this._index += shape.length;\n            ind += modelIndices.length;\n        }\n        this.nbParticles -= nb;\n        this._isNotBuilt = true; // buildMesh() call is now expected for setParticles() to work\n        return removed;\n    }\n    /**\n     * Inserts some pre-created particles in the solid particle system so that they can be managed by setParticles().\n     * @param solidParticleArray an array populated with Solid Particles objects\n     * @returns the SPS\n     */\n    insertParticlesFromArray(solidParticleArray) {\n        if (!this._expandable) {\n            return this;\n        }\n        let idxInShape = 0;\n        let currentShapeId = solidParticleArray[0].shapeId;\n        const nb = solidParticleArray.length;\n        for (let i = 0; i < nb; i++) {\n            const sp = solidParticleArray[i];\n            const model = sp._model;\n            const shape = model._shape;\n            const meshInd = model._indices;\n            const meshUV = model._shapeUV;\n            const meshCol = model._shapeColors;\n            const meshNor = model._normals;\n            const noNor = meshNor ? false : true;\n            this.recomputeNormals = noNor || this.recomputeNormals;\n            const bbInfo = sp.getBoundingInfo();\n            const newPart = this._insertNewParticle(this.nbParticles, idxInShape, model, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, null, null);\n            sp.copyToRef(newPart);\n            idxInShape++;\n            if (currentShapeId != sp.shapeId) {\n                currentShapeId = sp.shapeId;\n                idxInShape = 0;\n            }\n        }\n        this._isNotBuilt = true; // buildMesh() call is now expected for setParticles() to work\n        return this;\n    }\n    /**\n     * Creates a new particle and modifies the SPS mesh geometry :\n     * - calls _meshBuilder() to increase the SPS mesh geometry step by step\n     * - calls _addParticle() to populate the particle array\n     * factorized code from addShape() and insertParticlesFromArray()\n     * @param idx particle index in the particles array\n     * @param i particle index in its shape\n     * @param modelShape particle ModelShape object\n     * @param shape shape vertex array\n     * @param meshInd shape indices array\n     * @param meshUV shape uv array\n     * @param meshCol shape color array\n     * @param meshNor shape normals array\n     * @param bbInfo shape bounding info\n     * @param storage target particle storage\n     * @param options\n     * @options addShape() passed options\n     * @internal\n     */\n    _insertNewParticle(idx, i, modelShape, shape, meshInd, meshUV, meshCol, meshNor, bbInfo, storage, options) {\n        const currentPos = this._positions.length;\n        const currentInd = this._indices.length;\n        const currentCopy = this._meshBuilder(this._index, currentInd, shape, this._positions, meshInd, this._indices, meshUV, this._uvs, meshCol, this._colors, meshNor, this._normals, idx, i, options, modelShape);\n        let sp = null;\n        if (this._updatable) {\n            sp = this._addParticle(this.nbParticles, this._lastParticleId, currentPos, currentInd, modelShape, this._shapeCounter, i, bbInfo, storage);\n            sp.position.copyFrom(currentCopy.position);\n            sp.rotation.copyFrom(currentCopy.rotation);\n            if (currentCopy.rotationQuaternion) {\n                if (sp.rotationQuaternion) {\n                    sp.rotationQuaternion.copyFrom(currentCopy.rotationQuaternion);\n                }\n                else {\n                    sp.rotationQuaternion = currentCopy.rotationQuaternion.clone();\n                }\n            }\n            if (currentCopy.color) {\n                if (sp.color) {\n                    sp.color.copyFrom(currentCopy.color);\n                }\n                else {\n                    sp.color = currentCopy.color.clone();\n                }\n            }\n            sp.scaling.copyFrom(currentCopy.scaling);\n            sp.uvs.copyFrom(currentCopy.uvs);\n            if (currentCopy.materialIndex !== null) {\n                sp.materialIndex = currentCopy.materialIndex;\n            }\n            if (this.expandable) {\n                this._idxOfId[sp.id] = sp.idx;\n            }\n        }\n        if (!storage) {\n            this._index += shape.length;\n            this.nbParticles++;\n            this._lastParticleId++;\n        }\n        return sp;\n    }\n    /**\n     *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\n     *  This method calls `updateParticle()` for each particle of the SPS.\n     *  For an animated SPS, it is usually called within the render loop.\n     * This methods does nothing if called on a non updatable or not yet built SPS. Example : buildMesh() not called after having added or removed particles from an expandable SPS.\n     * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\n     * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\n     * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\n     * @returns the SPS.\n     */\n    setParticles(start = 0, end = this.nbParticles - 1, update = true) {\n        if (!this._updatable || this._isNotBuilt) {\n            return this;\n        }\n        // custom beforeUpdate\n        this.beforeUpdateParticles(start, end, update);\n        const rotMatrix = TmpVectors.Matrix[0];\n        const invertedMatrix = TmpVectors.Matrix[1];\n        const mesh = this.mesh;\n        const colors32 = this._colors32;\n        const positions32 = this._positions32;\n        const normals32 = this._normals32;\n        const uvs32 = this._uvs32;\n        const indices32 = this._indices32;\n        const indices = this._indices;\n        const fixedNormal32 = this._fixedNormal32;\n        const depthSortParticles = this._depthSort && this._depthSortParticles;\n        const tempVectors = TmpVectors.Vector3;\n        const camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\n        const camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\n        const camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\n        const minimum = tempVectors[8].setAll(Number.MAX_VALUE);\n        const maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\n        const camInvertedPosition = tempVectors[10].setAll(0);\n        const tmpVertex = this._tmpVertex;\n        const tmpVector = tmpVertex.position;\n        const tmpColor = tmpVertex.color;\n        const tmpUV = tmpVertex.uv;\n        // cases when the World Matrix is to be computed first\n        if (this.billboard || this._depthSort) {\n            this.mesh.computeWorldMatrix(true);\n            this.mesh._worldMatrix.invertToRef(invertedMatrix);\n        }\n        // if the particles will always face the camera\n        if (this.billboard) {\n            // compute the camera position and un-rotate it by the current mesh rotation\n            const tmpVector0 = tempVectors[0];\n            this._camera.getDirectionToRef(Axis.Z, tmpVector0);\n            Vector3.TransformNormalToRef(tmpVector0, invertedMatrix, camAxisZ);\n            camAxisZ.normalize();\n            // same for camera up vector extracted from the cam view matrix\n            const view = this._camera.getViewMatrix(true);\n            Vector3.TransformNormalFromFloatsToRef(view.m[1], view.m[5], view.m[9], invertedMatrix, camAxisY);\n            Vector3.CrossToRef(camAxisY, camAxisZ, camAxisX);\n            camAxisY.normalize();\n            camAxisX.normalize();\n        }\n        // if depthSort, compute the camera global position in the mesh local system\n        if (this._depthSort) {\n            Vector3.TransformCoordinatesToRef(this._camera.globalPosition, invertedMatrix, camInvertedPosition); // then un-rotate the camera\n        }\n        Matrix.IdentityToRef(rotMatrix);\n        let idx = 0; // current position index in the global array positions32\n        let index = 0; // position start index in the global array positions32 of the current particle\n        let colidx = 0; // current color index in the global array colors32\n        let colorIndex = 0; // color start index in the global array colors32 of the current particle\n        let uvidx = 0; // current uv index in the global array uvs32\n        let uvIndex = 0; // uv start index in the global array uvs32 of the current particle\n        let pt = 0; // current index in the particle model shape\n        if (this.mesh.isFacetDataEnabled) {\n            this._computeBoundingBox = true;\n        }\n        end = end >= this.nbParticles ? this.nbParticles - 1 : end;\n        if (this._computeBoundingBox) {\n            if (start != 0 || end != this.nbParticles - 1) {\n                // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\n                const boundingInfo = this.mesh.getBoundingInfo();\n                if (boundingInfo) {\n                    minimum.copyFrom(boundingInfo.minimum);\n                    maximum.copyFrom(boundingInfo.maximum);\n                }\n            }\n        }\n        // particle loop\n        index = this.particles[start]._pos;\n        const vpos = (index / 3) | 0;\n        colorIndex = vpos * 4;\n        uvIndex = vpos * 2;\n        for (let p = start; p <= end; p++) {\n            const particle = this.particles[p];\n            // call to custom user function to update the particle properties\n            this.updateParticle(particle);\n            const shape = particle._model._shape;\n            const shapeUV = particle._model._shapeUV;\n            const particleRotationMatrix = particle._rotationMatrix;\n            const particlePosition = particle.position;\n            const particleRotation = particle.rotation;\n            const particleScaling = particle.scaling;\n            const particleGlobalPosition = particle._globalPosition;\n            // camera-particle distance for depth sorting\n            if (depthSortParticles) {\n                const dsp = this.depthSortedParticles[p];\n                dsp.idx = particle.idx;\n                dsp.ind = particle._ind;\n                dsp.indicesLength = particle._model._indicesLength;\n                dsp.sqDistance = Vector3.DistanceSquared(particle.position, camInvertedPosition);\n            }\n            // skip the computations for inactive or already invisible particles\n            if (!particle.alive || (particle._stillInvisible && !particle.isVisible && !this._recomputeInvisibles)) {\n                // increment indexes for the next particle\n                pt = shape.length;\n                index += pt * 3;\n                colorIndex += pt * 4;\n                uvIndex += pt * 2;\n                continue;\n            }\n            if (particle.isVisible) {\n                particle._stillInvisible = false; // un-mark permanent invisibility\n                const scaledPivot = tempVectors[12];\n                particle.pivot.multiplyToRef(particleScaling, scaledPivot);\n                // particle rotation matrix\n                if (this.billboard) {\n                    particleRotation.x = 0.0;\n                    particleRotation.y = 0.0;\n                }\n                if (this._computeParticleRotation || this.billboard) {\n                    particle.getRotationMatrix(rotMatrix);\n                }\n                const particleHasParent = particle.parentId !== null;\n                if (particleHasParent) {\n                    const parent = this.getParticleById(particle.parentId);\n                    if (parent) {\n                        const parentRotationMatrix = parent._rotationMatrix;\n                        const parentGlobalPosition = parent._globalPosition;\n                        const rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\n                        const rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\n                        const rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\n                        particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;\n                        particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;\n                        particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;\n                        if (this._computeParticleRotation || this.billboard) {\n                            const rotMatrixValues = rotMatrix.m;\n                            particleRotationMatrix[0] =\n                                rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\n                            particleRotationMatrix[1] =\n                                rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\n                            particleRotationMatrix[2] =\n                                rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\n                            particleRotationMatrix[3] =\n                                rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\n                            particleRotationMatrix[4] =\n                                rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\n                            particleRotationMatrix[5] =\n                                rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\n                            particleRotationMatrix[6] =\n                                rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\n                            particleRotationMatrix[7] =\n                                rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\n                            particleRotationMatrix[8] =\n                                rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\n                        }\n                    }\n                    else {\n                        // in case the parent were removed at some moment\n                        particle.parentId = null;\n                    }\n                }\n                else {\n                    particleGlobalPosition.x = particlePosition.x;\n                    particleGlobalPosition.y = particlePosition.y;\n                    particleGlobalPosition.z = particlePosition.z;\n                    if (this._computeParticleRotation || this.billboard) {\n                        const rotMatrixValues = rotMatrix.m;\n                        particleRotationMatrix[0] = rotMatrixValues[0];\n                        particleRotationMatrix[1] = rotMatrixValues[1];\n                        particleRotationMatrix[2] = rotMatrixValues[2];\n                        particleRotationMatrix[3] = rotMatrixValues[4];\n                        particleRotationMatrix[4] = rotMatrixValues[5];\n                        particleRotationMatrix[5] = rotMatrixValues[6];\n                        particleRotationMatrix[6] = rotMatrixValues[8];\n                        particleRotationMatrix[7] = rotMatrixValues[9];\n                        particleRotationMatrix[8] = rotMatrixValues[10];\n                    }\n                }\n                const pivotBackTranslation = tempVectors[11];\n                if (particle.translateFromPivot) {\n                    pivotBackTranslation.setAll(0.0);\n                }\n                else {\n                    pivotBackTranslation.copyFrom(scaledPivot);\n                }\n                // particle vertex loop\n                for (pt = 0; pt < shape.length; pt++) {\n                    idx = index + pt * 3;\n                    colidx = colorIndex + pt * 4;\n                    uvidx = uvIndex + pt * 2;\n                    const iu = 2 * pt;\n                    const iv = iu + 1;\n                    tmpVector.copyFrom(shape[pt]);\n                    if (this._computeParticleColor && particle.color) {\n                        tmpColor.copyFrom(particle.color);\n                    }\n                    if (this._computeParticleTexture) {\n                        tmpUV.copyFromFloats(shapeUV[iu], shapeUV[iv]);\n                    }\n                    if (this._computeParticleVertex) {\n                        this.updateParticleVertex(particle, tmpVertex, pt);\n                    }\n                    // positions\n                    const vertexX = tmpVector.x * particleScaling.x - scaledPivot.x;\n                    const vertexY = tmpVector.y * particleScaling.y - scaledPivot.y;\n                    const vertexZ = tmpVector.z * particleScaling.z - scaledPivot.z;\n                    let rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\n                    let rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\n                    let rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\n                    rotatedX += pivotBackTranslation.x;\n                    rotatedY += pivotBackTranslation.y;\n                    rotatedZ += pivotBackTranslation.z;\n                    const px = (positions32[idx] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ);\n                    const py = (positions32[idx + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ);\n                    const pz = (positions32[idx + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ);\n                    if (this._computeBoundingBox) {\n                        minimum.minimizeInPlaceFromFloats(px, py, pz);\n                        maximum.maximizeInPlaceFromFloats(px, py, pz);\n                    }\n                    // normals : if the particles can't be morphed then just rotate the normals, what is much more faster than ComputeNormals()\n                    if (!this._computeParticleVertex) {\n                        const normalx = fixedNormal32[idx];\n                        const normaly = fixedNormal32[idx + 1];\n                        const normalz = fixedNormal32[idx + 2];\n                        const rotatedx = normalx * particleRotationMatrix[0] + normaly * particleRotationMatrix[3] + normalz * particleRotationMatrix[6];\n                        const rotatedy = normalx * particleRotationMatrix[1] + normaly * particleRotationMatrix[4] + normalz * particleRotationMatrix[7];\n                        const rotatedz = normalx * particleRotationMatrix[2] + normaly * particleRotationMatrix[5] + normalz * particleRotationMatrix[8];\n                        normals32[idx] = camAxisX.x * rotatedx + camAxisY.x * rotatedy + camAxisZ.x * rotatedz;\n                        normals32[idx + 1] = camAxisX.y * rotatedx + camAxisY.y * rotatedy + camAxisZ.y * rotatedz;\n                        normals32[idx + 2] = camAxisX.z * rotatedx + camAxisY.z * rotatedy + camAxisZ.z * rotatedz;\n                    }\n                    if (this._computeParticleColor && particle.color) {\n                        const colors32 = this._colors32;\n                        colors32[colidx] = tmpColor.r;\n                        colors32[colidx + 1] = tmpColor.g;\n                        colors32[colidx + 2] = tmpColor.b;\n                        colors32[colidx + 3] = tmpColor.a;\n                    }\n                    if (this._computeParticleTexture) {\n                        const uvs = particle.uvs;\n                        uvs32[uvidx] = tmpUV.x * (uvs.z - uvs.x) + uvs.x;\n                        uvs32[uvidx + 1] = tmpUV.y * (uvs.w - uvs.y) + uvs.y;\n                    }\n                }\n            }\n            // particle just set invisible : scaled to zero and positioned at the origin\n            else {\n                particle._stillInvisible = true; // mark the particle as invisible\n                for (pt = 0; pt < shape.length; pt++) {\n                    idx = index + pt * 3;\n                    colidx = colorIndex + pt * 4;\n                    uvidx = uvIndex + pt * 2;\n                    positions32[idx] = positions32[idx + 1] = positions32[idx + 2] = 0;\n                    normals32[idx] = normals32[idx + 1] = normals32[idx + 2] = 0;\n                    if (this._computeParticleColor && particle.color) {\n                        const color = particle.color;\n                        colors32[colidx] = color.r;\n                        colors32[colidx + 1] = color.g;\n                        colors32[colidx + 2] = color.b;\n                        colors32[colidx + 3] = color.a;\n                    }\n                    if (this._computeParticleTexture) {\n                        const uvs = particle.uvs;\n                        uvs32[uvidx] = shapeUV[pt * 2] * (uvs.z - uvs.x) + uvs.x;\n                        uvs32[uvidx + 1] = shapeUV[pt * 2 + 1] * (uvs.w - uvs.y) + uvs.y;\n                    }\n                }\n            }\n            // if the particle intersections must be computed : update the bbInfo\n            if (this._particlesIntersect) {\n                const bInfo = particle.getBoundingInfo();\n                const bBox = bInfo.boundingBox;\n                const bSphere = bInfo.boundingSphere;\n                const modelBoundingInfo = particle._modelBoundingInfo;\n                if (!this._bSphereOnly) {\n                    // place, scale and rotate the particle bbox within the SPS local system, then update it\n                    const modelBoundingInfoVectors = modelBoundingInfo.boundingBox.vectors;\n                    const tempMin = tempVectors[1];\n                    const tempMax = tempVectors[2];\n                    tempMin.setAll(Number.MAX_VALUE);\n                    tempMax.setAll(-Number.MAX_VALUE);\n                    for (let b = 0; b < 8; b++) {\n                        const scaledX = modelBoundingInfoVectors[b].x * particleScaling.x;\n                        const scaledY = modelBoundingInfoVectors[b].y * particleScaling.y;\n                        const scaledZ = modelBoundingInfoVectors[b].z * particleScaling.z;\n                        const rotatedX = scaledX * particleRotationMatrix[0] + scaledY * particleRotationMatrix[3] + scaledZ * particleRotationMatrix[6];\n                        const rotatedY = scaledX * particleRotationMatrix[1] + scaledY * particleRotationMatrix[4] + scaledZ * particleRotationMatrix[7];\n                        const rotatedZ = scaledX * particleRotationMatrix[2] + scaledY * particleRotationMatrix[5] + scaledZ * particleRotationMatrix[8];\n                        const x = particlePosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;\n                        const y = particlePosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;\n                        const z = particlePosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;\n                        tempMin.minimizeInPlaceFromFloats(x, y, z);\n                        tempMax.maximizeInPlaceFromFloats(x, y, z);\n                    }\n                    bBox.reConstruct(tempMin, tempMax, mesh._worldMatrix);\n                }\n                // place and scale the particle bouding sphere in the SPS local system, then update it\n                const minBbox = modelBoundingInfo.minimum.multiplyToRef(particleScaling, tempVectors[1]);\n                const maxBbox = modelBoundingInfo.maximum.multiplyToRef(particleScaling, tempVectors[2]);\n                const bSphereCenter = maxBbox.addToRef(minBbox, tempVectors[3]).scaleInPlace(0.5).addInPlace(particleGlobalPosition);\n                const halfDiag = maxBbox.subtractToRef(minBbox, tempVectors[4]).scaleInPlace(0.5 * this._bSphereRadiusFactor);\n                const bSphereMinBbox = bSphereCenter.subtractToRef(halfDiag, tempVectors[1]);\n                const bSphereMaxBbox = bSphereCenter.addToRef(halfDiag, tempVectors[2]);\n                bSphere.reConstruct(bSphereMinBbox, bSphereMaxBbox, mesh._worldMatrix);\n            }\n            // increment indexes for the next particle\n            index = idx + 3;\n            colorIndex = colidx + 4;\n            uvIndex = uvidx + 2;\n        }\n        // if the VBO must be updated\n        if (update) {\n            if (this._computeParticleColor) {\n                const vb = mesh.getVertexBuffer(VertexBuffer.ColorKind);\n                if (vb && !mesh.isPickable) {\n                    vb.updateDirectly(colors32, 0);\n                }\n                else {\n                    mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\n                }\n            }\n            if (this._computeParticleTexture) {\n                const vb = mesh.getVertexBuffer(VertexBuffer.UVKind);\n                if (vb && !mesh.isPickable) {\n                    vb.updateDirectly(uvs32, 0);\n                }\n                else {\n                    mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\n                }\n            }\n            const vbp = mesh.getVertexBuffer(VertexBuffer.PositionKind);\n            if (vbp && !mesh.isPickable) {\n                vbp.updateDirectly(positions32, 0);\n            }\n            else {\n                mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\n            }\n            if (!mesh.areNormalsFrozen || mesh.isFacetDataEnabled) {\n                if (this._computeParticleVertex || mesh.isFacetDataEnabled) {\n                    // recompute the normals only if the particles can be morphed, update then also the normal reference array _fixedNormal32[]\n                    const params = mesh.isFacetDataEnabled ? mesh.getFacetDataParameters() : null;\n                    VertexData.ComputeNormals(positions32, indices32, normals32, params);\n                    for (let i = 0; i < normals32.length; i++) {\n                        fixedNormal32[i] = normals32[i];\n                    }\n                }\n                if (!mesh.areNormalsFrozen) {\n                    const vb = mesh.getVertexBuffer(VertexBuffer.NormalKind);\n                    if (vb && !mesh.isPickable) {\n                        vb.updateDirectly(normals32, 0);\n                    }\n                    else {\n                        mesh.updateVerticesData(VertexBuffer.NormalKind, normals32, false, false);\n                    }\n                }\n            }\n            if (depthSortParticles) {\n                const depthSortedParticles = this.depthSortedParticles;\n                depthSortedParticles.sort(this._depthSortFunction);\n                const dspl = depthSortedParticles.length;\n                let sid = 0;\n                let faceId = 0;\n                for (let sorted = 0; sorted < dspl; sorted++) {\n                    const sortedParticle = depthSortedParticles[sorted];\n                    const lind = sortedParticle.indicesLength;\n                    const sind = sortedParticle.ind;\n                    for (let i = 0; i < lind; i++) {\n                        indices32[sid] = indices[sind + i];\n                        sid++;\n                        if (this._pickable) {\n                            const f = i % 3;\n                            if (f == 0) {\n                                const pickedData = this.pickedParticles[faceId];\n                                pickedData.idx = sortedParticle.idx;\n                                pickedData.faceId = faceId;\n                                faceId++;\n                            }\n                        }\n                    }\n                }\n            }\n            if (this._autoFixFaceOrientation) {\n                let particleInd = 0;\n                for (let particleIdx = 0; particleIdx < this.particles.length; particleIdx++) {\n                    const particle = depthSortParticles ? this.particles[this.depthSortedParticles[particleIdx].idx] : this.particles[particleIdx];\n                    const flipFaces = particle.scale.x * particle.scale.y * particle.scale.z < 0;\n                    if (flipFaces) {\n                        for (let faceInd = 0; faceInd < particle._model._indicesLength; faceInd += 3) {\n                            const tmp = indices[particle._ind + faceInd];\n                            indices32[particleInd + faceInd] = indices[particle._ind + faceInd + 1];\n                            indices32[particleInd + faceInd + 1] = tmp;\n                        }\n                    }\n                    particleInd += particle._model._indicesLength;\n                }\n            }\n            if (depthSortParticles || this._autoFixFaceOrientation) {\n                mesh.updateIndices(indices32);\n            }\n        }\n        if (this._computeBoundingBox) {\n            if (mesh.hasBoundingInfo) {\n                mesh.getBoundingInfo().reConstruct(minimum, maximum, mesh._worldMatrix);\n            }\n            else {\n                mesh.buildBoundingInfo(minimum, maximum, mesh._worldMatrix);\n            }\n        }\n        if (this._autoUpdateSubMeshes) {\n            this.computeSubMeshes();\n        }\n        this._recomputeInvisibles = false;\n        this.afterUpdateParticles(start, end, update);\n        return this;\n    }\n    /**\n     * Disposes the SPS.\n     */\n    dispose() {\n        this.mesh.dispose();\n        this.vars = null;\n        // drop references to internal big arrays for the GC\n        this._positions = null;\n        this._indices = null;\n        this._normals = null;\n        this._uvs = null;\n        this._colors = null;\n        this._indices32 = null;\n        this._positions32 = null;\n        this._normals32 = null;\n        this._fixedNormal32 = null;\n        this._uvs32 = null;\n        this._colors32 = null;\n        this.pickedParticles = null;\n        this.pickedBySubMesh = null;\n        this._materials = null;\n        this._materialIndexes = null;\n        this._indicesByMaterial = null;\n        this._idxOfId = null;\n    }\n    /** Returns an object {idx: number faceId: number} for the picked particle from the passed pickingInfo object.\n     * idx is the particle index in the SPS\n     * faceId is the picked face index counted within this particle.\n     * Returns null if the pickInfo can't identify a picked particle.\n     * @param pickingInfo (PickingInfo object)\n     * @returns {idx: number, faceId: number} or null\n     */\n    pickedParticle(pickingInfo) {\n        if (pickingInfo.hit) {\n            const subMesh = pickingInfo.subMeshId;\n            const faceId = pickingInfo.faceId - this.mesh.subMeshes[subMesh].indexStart / 3;\n            const picked = this.pickedBySubMesh;\n            if (picked[subMesh] && picked[subMesh][faceId]) {\n                return picked[subMesh][faceId];\n            }\n        }\n        return null;\n    }\n    /**\n     * Returns a SolidParticle object from its identifier : particle.id\n     * @param id (integer) the particle Id\n     * @returns the searched particle or null if not found in the SPS.\n     */\n    getParticleById(id) {\n        const p = this.particles[id];\n        if (p && p.id == id) {\n            return p;\n        }\n        const particles = this.particles;\n        const idx = this._idxOfId[id];\n        if (idx !== undefined) {\n            return particles[idx];\n        }\n        let i = 0;\n        const nb = this.nbParticles;\n        while (i < nb) {\n            const particle = particles[i];\n            if (particle.id == id) {\n                return particle;\n            }\n            i++;\n        }\n        return null;\n    }\n    /**\n     * Returns a new array populated with the particles having the passed shapeId.\n     * @param shapeId (integer) the shape identifier\n     * @returns a new solid particle array\n     */\n    getParticlesByShapeId(shapeId) {\n        const ref = [];\n        this.getParticlesByShapeIdToRef(shapeId, ref);\n        return ref;\n    }\n    /**\n     * Populates the passed array \"ref\" with the particles having the passed shapeId.\n     * @param shapeId the shape identifier\n     * @param ref array to populate\n     * @returns the SPS\n     */\n    getParticlesByShapeIdToRef(shapeId, ref) {\n        ref.length = 0;\n        for (let i = 0; i < this.nbParticles; i++) {\n            const p = this.particles[i];\n            if (p.shapeId == shapeId) {\n                ref.push(p);\n            }\n        }\n        return this;\n    }\n    /**\n     * Computes the required SubMeshes according the materials assigned to the particles.\n     * @returns the solid particle system.\n     * Does nothing if called before the SPS mesh is built.\n     */\n    computeSubMeshes() {\n        if (!this.mesh || !this._multimaterialEnabled) {\n            return this;\n        }\n        const depthSortedParticles = this.depthSortedParticles;\n        if (this.particles.length > 0) {\n            for (let p = 0; p < this.particles.length; p++) {\n                const part = this.particles[p];\n                if (!part.materialIndex) {\n                    part.materialIndex = 0;\n                }\n                const sortedPart = depthSortedParticles[p];\n                sortedPart.materialIndex = part.materialIndex;\n                sortedPart.ind = part._ind;\n                sortedPart.indicesLength = part._model._indicesLength;\n                sortedPart.idx = part.idx;\n            }\n        }\n        this._sortParticlesByMaterial();\n        const indicesByMaterial = this._indicesByMaterial;\n        const materialIndexes = this._materialIndexes;\n        const mesh = this.mesh;\n        mesh.subMeshes = [];\n        const vcount = mesh.getTotalVertices();\n        for (let m = 0; m < materialIndexes.length; m++) {\n            const start = indicesByMaterial[m];\n            const count = indicesByMaterial[m + 1] - start;\n            const matIndex = materialIndexes[m];\n            new SubMesh(matIndex, 0, vcount, start, count, mesh);\n        }\n        return this;\n    }\n    /**\n     * Sorts the solid particles by material when MultiMaterial is enabled.\n     * Updates the indices32 array.\n     * Updates the indicesByMaterial array.\n     * Updates the mesh indices array.\n     * @returns the SPS\n     * @internal\n     */\n    _sortParticlesByMaterial() {\n        const indicesByMaterial = [0];\n        this._indicesByMaterial = indicesByMaterial;\n        const materialIndexes = [];\n        this._materialIndexes = materialIndexes;\n        const depthSortedParticles = this.depthSortedParticles;\n        depthSortedParticles.sort(this._materialSortFunction);\n        const length = depthSortedParticles.length;\n        const indices32 = this._indices32;\n        const indices = this._indices;\n        let subMeshIndex = 0;\n        let subMeshFaceId = 0;\n        let sid = 0;\n        let lastMatIndex = depthSortedParticles[0].materialIndex;\n        materialIndexes.push(lastMatIndex);\n        if (this._pickable) {\n            this.pickedBySubMesh = [[]];\n            this.pickedParticles = this.pickedBySubMesh[0];\n        }\n        for (let sorted = 0; sorted < length; sorted++) {\n            const sortedPart = depthSortedParticles[sorted];\n            const lind = sortedPart.indicesLength;\n            const sind = sortedPart.ind;\n            if (sortedPart.materialIndex !== lastMatIndex) {\n                lastMatIndex = sortedPart.materialIndex;\n                indicesByMaterial.push(sid);\n                materialIndexes.push(lastMatIndex);\n                if (this._pickable) {\n                    subMeshIndex++;\n                    this.pickedBySubMesh[subMeshIndex] = [];\n                    subMeshFaceId = 0;\n                }\n            }\n            let faceId = 0;\n            for (let i = 0; i < lind; i++) {\n                indices32[sid] = indices[sind + i];\n                if (this._pickable) {\n                    const f = i % 3;\n                    if (f == 0) {\n                        const pickedData = this.pickedBySubMesh[subMeshIndex][subMeshFaceId];\n                        if (pickedData) {\n                            pickedData.idx = sortedPart.idx;\n                            pickedData.faceId = faceId;\n                        }\n                        else {\n                            this.pickedBySubMesh[subMeshIndex][subMeshFaceId] = { idx: sortedPart.idx, faceId: faceId };\n                        }\n                        subMeshFaceId++;\n                        faceId++;\n                    }\n                }\n                sid++;\n            }\n        }\n        indicesByMaterial.push(indices32.length); // add the last number to ease the indices start/count values for subMeshes creation\n        if (this._updatable) {\n            this.mesh.updateIndices(indices32);\n        }\n        return this;\n    }\n    /**\n     * Sets the material indexes by id materialIndexesById[id] = materialIndex\n     * @internal\n     */\n    _setMaterialIndexesById() {\n        this._materialIndexesById = {};\n        for (let i = 0; i < this._materials.length; i++) {\n            const id = this._materials[i].uniqueId;\n            this._materialIndexesById[id] = i;\n        }\n    }\n    /**\n     * Returns an array with unique values of Materials from the passed array\n     * @param array the material array to be checked and filtered\n     * @internal\n     */\n    _filterUniqueMaterialId(array) {\n        const filtered = array.filter(function (value, index, self) {\n            return self.indexOf(value) === index;\n        });\n        return filtered;\n    }\n    /**\n     * Sets a new Standard Material as _defaultMaterial if not already set.\n     * @internal\n     */\n    _setDefaultMaterial() {\n        if (!this._defaultMaterial) {\n            this._defaultMaterial = new StandardMaterial(this.name + \"DefaultMaterial\", this._scene);\n        }\n        return this._defaultMaterial;\n    }\n    /**\n     * Visibility helper : Recomputes the visible size according to the mesh bounding box\n     * doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/sps_visibility\n     * @returns the SPS.\n     */\n    refreshVisibleSize() {\n        if (!this._isVisibilityBoxLocked) {\n            this.mesh.refreshBoundingInfo();\n        }\n        return this;\n    }\n    /**\n     * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\n     * @param size the size (float) of the visibility box\n     * note : this doesn't lock the SPS mesh bounding box.\n     * doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/sps_visibility\n     */\n    setVisibilityBox(size) {\n        const vis = size / 2;\n        this.mesh.buildBoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\n    }\n    /**\n     * Gets whether the SPS as always visible or not\n     * doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/sps_visibility\n     */\n    get isAlwaysVisible() {\n        return this._alwaysVisible;\n    }\n    /**\n     * Sets the SPS as always visible or not\n     * doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/sps_visibility\n     */\n    set isAlwaysVisible(val) {\n        this._alwaysVisible = val;\n        this.mesh.alwaysSelectAsActiveMesh = val;\n    }\n    /**\n     * Sets the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.\n     * doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/sps_visibility\n     */\n    set isVisibilityBoxLocked(val) {\n        this._isVisibilityBoxLocked = val;\n        const boundingInfo = this.mesh.getBoundingInfo();\n        boundingInfo.isLocked = val;\n    }\n    /**\n     * Gets if the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.\n     * doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/sps_visibility\n     */\n    get isVisibilityBoxLocked() {\n        return this._isVisibilityBoxLocked;\n    }\n    /**\n     * Tells to `setParticles()` to compute the particle rotations or not.\n     * Default value : true. The SPS is faster when it's set to false.\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.\n     */\n    set computeParticleRotation(val) {\n        this._computeParticleRotation = val;\n    }\n    /**\n     * Tells to `setParticles()` to compute the particle colors or not.\n     * Default value : true. The SPS is faster when it's set to false.\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n     */\n    set computeParticleColor(val) {\n        this._computeParticleColor = val;\n    }\n    set computeParticleTexture(val) {\n        this._computeParticleTexture = val;\n    }\n    /**\n     * Tells to `setParticles()` to call the vertex function for each vertex of each particle, or not.\n     * Default value : false. The SPS is faster when it's set to false.\n     * Note : the particle custom vertex positions aren't stored values.\n     */\n    set computeParticleVertex(val) {\n        this._computeParticleVertex = val;\n    }\n    /**\n     * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\n     */\n    set computeBoundingBox(val) {\n        this._computeBoundingBox = val;\n    }\n    /**\n     * Tells to `setParticles()` to sort or not the distance between each particle and the camera.\n     * Skipped when `enableDepthSort` is set to `false` (default) at construction time.\n     * Default : `true`\n     */\n    set depthSortParticles(val) {\n        this._depthSortParticles = val;\n    }\n    /**\n     * Gets if `setParticles()` computes the particle rotations or not.\n     * Default value : true. The SPS is faster when it's set to false.\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.\n     */\n    get computeParticleRotation() {\n        return this._computeParticleRotation;\n    }\n    /**\n     * Gets if `setParticles()` computes the particle colors or not.\n     * Default value : true. The SPS is faster when it's set to false.\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n     */\n    get computeParticleColor() {\n        return this._computeParticleColor;\n    }\n    /**\n     * Gets if `setParticles()` computes the particle textures or not.\n     * Default value : true. The SPS is faster when it's set to false.\n     * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\n     */\n    get computeParticleTexture() {\n        return this._computeParticleTexture;\n    }\n    /**\n     * Gets if `setParticles()` calls the vertex function for each vertex of each particle, or not.\n     * Default value : false. The SPS is faster when it's set to false.\n     * Note : the particle custom vertex positions aren't stored values.\n     */\n    get computeParticleVertex() {\n        return this._computeParticleVertex;\n    }\n    /**\n     * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\n     */\n    get computeBoundingBox() {\n        return this._computeBoundingBox;\n    }\n    /**\n     * Gets if `setParticles()` sorts or not the distance between each particle and the camera.\n     * Skipped when `enableDepthSort` is set to `false` (default) at construction time.\n     * Default : `true`\n     */\n    get depthSortParticles() {\n        return this._depthSortParticles;\n    }\n    /**\n     * Gets if the SPS is created as expandable at construction time.\n     * Default : `false`\n     */\n    get expandable() {\n        return this._expandable;\n    }\n    /**\n     * Gets if the SPS supports the Multi Materials\n     */\n    get multimaterialEnabled() {\n        return this._multimaterialEnabled;\n    }\n    /**\n     * Gets if the SPS uses the model materials for its own multimaterial.\n     */\n    get useModelMaterial() {\n        return this._useModelMaterial;\n    }\n    /**\n     * The SPS used material array.\n     */\n    get materials() {\n        return this._materials;\n    }\n    /**\n     * Sets the SPS MultiMaterial from the passed materials.\n     * Note : the passed array is internally copied and not used then by reference.\n     * @param materials an array of material objects. This array indexes are the materialIndex values of the particles.\n     */\n    setMultiMaterial(materials) {\n        this._materials = this._filterUniqueMaterialId(materials);\n        this._setMaterialIndexesById();\n        if (this._multimaterial) {\n            this._multimaterial.dispose();\n        }\n        this._multimaterial = new MultiMaterial(this.name + \"MultiMaterial\", this._scene);\n        for (let m = 0; m < this._materials.length; m++) {\n            this._multimaterial.subMaterials.push(this._materials[m]);\n        }\n        this.computeSubMeshes();\n        this.mesh.material = this._multimaterial;\n    }\n    /**\n     * The SPS computed multimaterial object\n     */\n    get multimaterial() {\n        return this._multimaterial;\n    }\n    set multimaterial(mm) {\n        this._multimaterial = mm;\n    }\n    /**\n     * If the subMeshes must be updated on the next call to setParticles()\n     */\n    get autoUpdateSubMeshes() {\n        return this._autoUpdateSubMeshes;\n    }\n    set autoUpdateSubMeshes(val) {\n        this._autoUpdateSubMeshes = val;\n    }\n    // =======================================================================\n    // Particle behavior logic\n    // these following methods may be overwritten by the user to fit his needs\n    /**\n     * This function does nothing. It may be overwritten to set all the particle first values.\n     * The SPS doesn't call this function, you may have to call it by your own.\n     * doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/manage_sps_particles\n     */\n    initParticles() { }\n    /**\n     * This function does nothing. It may be overwritten to recycle a particle.\n     * The SPS doesn't call this function, you may have to call it by your own.\n     * doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/manage_sps_particles\n     * @param particle The particle to recycle\n     * @returns the recycled particle\n     */\n    recycleParticle(particle) {\n        return particle;\n    }\n    /**\n     * Updates a particle : this function should  be overwritten by the user.\n     * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\n     * doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/manage_sps_particles\n     * @example : just set a particle position or velocity and recycle conditions\n     * @param particle The particle to update\n     * @returns the updated particle\n     */\n    updateParticle(particle) {\n        return particle;\n    }\n    /**\n     * Updates a vertex of a particle : it can be overwritten by the user.\n     * This will be called on each vertex particle by `setParticles()` if `computeParticleVertex` is set to true only.\n     * @param particle the current particle\n     * @param vertex the current vertex of the current particle : a SolidParticleVertex object\n     * @param pt the index of the current vertex in the particle shape\n     * doc : https://doc.babylonjs.com/features/featuresDeepDive/particles/solid_particle_system/sps_vertices\n     * @example : just set a vertex particle position or color\n     * @returns the sps\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    updateParticleVertex(particle, vertex, pt) {\n        return this;\n    }\n    /**\n     * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\n     * This does nothing and may be overwritten by the user.\n     * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n     * @param update the boolean update value actually passed to setParticles()\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    beforeUpdateParticles(start, stop, update) { }\n    /**\n     * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\n     * This will be passed three parameters.\n     * This does nothing and may be overwritten by the user.\n     * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n     * @param update the boolean update value actually passed to setParticles()\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    afterUpdateParticles(start, stop, update) { }\n}\n//# sourceMappingURL=solidParticleSystem.js.map","import { PhysicsPrestepType } from \"./IPhysicsEnginePlugin.js\";\nimport { Vector3, Quaternion, TmpVectors } from \"../../Maths/math.vector.js\";\n/**\n * PhysicsBody is useful for creating a physics body that can be used in a physics engine. It allows\n * the user to set the mass and velocity of the body, which can then be used to calculate the\n * motion of the body in the physics engine.\n */\nexport class PhysicsBody {\n    /**\n     * Disable pre-step that consists in updating Physics Body from Transform Node Translation/Orientation.\n     * True by default for maximum performance.\n     */\n    get disablePreStep() {\n        return this._prestepType == PhysicsPrestepType.DISABLED;\n    }\n    set disablePreStep(value) {\n        this._prestepType = value ? PhysicsPrestepType.DISABLED : PhysicsPrestepType.TELEPORT;\n    }\n    /**\n     * Constructs a new physics body for the given node.\n     * @param transformNode - The Transform Node to construct the physics body for. For better performance, it is advised that this node does not have a parent.\n     * @param motionType - The motion type of the physics body. The options are:\n     *  - PhysicsMotionType.STATIC - Static bodies are not moving and unaffected by forces or collisions. They are good for level boundaries or terrain.\n     *  - PhysicsMotionType.DYNAMIC - Dynamic bodies are fully simulated. They can move and collide with other objects.\n     *  - PhysicsMotionType.ANIMATED - They behave like dynamic bodies, but they won't be affected by other bodies, but still push other bodies out of the way.\n     * @param startsAsleep - Whether the physics body should start in a sleeping state (not a guarantee). Defaults to false.\n     * @param scene - The scene containing the physics engine.\n     *\n     * This code is useful for creating a physics body for a given Transform Node in a scene.\n     * It checks the version of the physics engine and the physics plugin, and initializes the body accordingly.\n     * It also sets the node's rotation quaternion if it is not already set. Finally, it adds the body to the physics engine.\n     */\n    constructor(transformNode, motionType, startsAsleep, scene) {\n        /**\n         * V2 Physics plugin private data for single Transform\n         */\n        this._pluginData = undefined;\n        /**\n         * V2 Physics plugin private data for instances\n         */\n        this._pluginDataInstances = [];\n        /**\n         * If the collision callback is enabled\n         */\n        this._collisionCBEnabled = false;\n        /**\n         * If the collision ended callback is enabled\n         */\n        this._collisionEndedCBEnabled = false;\n        /**\n         * Disable sync from physics to transformNode. This value is set to true at body creation or at motionType setting when the body is not dynamic.\n         */\n        this.disableSync = false;\n        this._isDisposed = false;\n        this._shape = null;\n        this._prestepType = PhysicsPrestepType.DISABLED;\n        if (!scene) {\n            return;\n        }\n        const physicsEngine = scene.getPhysicsEngine();\n        if (!physicsEngine) {\n            throw new Error(\"No Physics Engine available.\");\n        }\n        this._physicsEngine = physicsEngine;\n        if (physicsEngine.getPluginVersion() != 2) {\n            throw new Error(\"Plugin version is incorrect. Expected version 2.\");\n        }\n        const physicsPlugin = physicsEngine.getPhysicsPlugin();\n        if (!physicsPlugin) {\n            throw new Error(\"No Physics Plugin available.\");\n        }\n        this._physicsPlugin = physicsPlugin;\n        if (!transformNode.rotationQuaternion) {\n            transformNode.rotationQuaternion = Quaternion.FromEulerAngles(transformNode.rotation.x, transformNode.rotation.y, transformNode.rotation.z);\n        }\n        this.startAsleep = startsAsleep;\n        this._motionType = motionType;\n        // only dynamic and animated body needs sync from physics to transformNode\n        this.disableSync = motionType == 0 /* PhysicsMotionType.STATIC */;\n        // instances?\n        const m = transformNode;\n        if (m.hasThinInstances) {\n            this._physicsPlugin.initBodyInstances(this, motionType, m);\n        }\n        else {\n            // single instance\n            if (transformNode.parent) {\n                // Force computation of world matrix so that the parent transforms are correctly reflected in absolutePosition/absoluteRotationQuaternion.\n                transformNode.computeWorldMatrix(true);\n            }\n            this._physicsPlugin.initBody(this, motionType, transformNode.absolutePosition, transformNode.absoluteRotationQuaternion);\n        }\n        this.transformNode = transformNode;\n        transformNode.physicsBody = this;\n        physicsEngine.addBody(this);\n        this._nodeDisposeObserver = transformNode.onDisposeObservable.add(() => {\n            this.dispose();\n        });\n    }\n    /**\n     * Returns the string \"PhysicsBody\".\n     * @returns \"PhysicsBody\"\n     */\n    getClassName() {\n        return \"PhysicsBody\";\n    }\n    /**\n     * Clone the PhysicsBody to a new body and assign it to the transformNode parameter\n     * @param transformNode transformNode that will be used for the cloned PhysicsBody\n     * @returns the newly cloned PhysicsBody\n     */\n    clone(transformNode) {\n        const clonedBody = new PhysicsBody(transformNode, this.getMotionType(), this.startAsleep, this.transformNode.getScene());\n        clonedBody.shape = this.shape;\n        clonedBody.setMassProperties(this.getMassProperties());\n        clonedBody.setLinearDamping(this.getLinearDamping());\n        clonedBody.setAngularDamping(this.getAngularDamping());\n        return clonedBody;\n    }\n    /**\n     * If a physics body is connected to an instanced node, update the number physic instances to match the number of node instances.\n     */\n    updateBodyInstances() {\n        const m = this.transformNode;\n        if (m.hasThinInstances) {\n            this._physicsPlugin.updateBodyInstances(this, m);\n        }\n    }\n    /**\n     * This returns the number of internal instances of the physics body\n     */\n    get numInstances() {\n        return this._pluginDataInstances.length;\n    }\n    /**\n     * Get the motion type of the physics body. Can be STATIC, DYNAMIC, or ANIMATED.\n     */\n    get motionType() {\n        return this._motionType;\n    }\n    /**\n     * Sets the shape of the physics body.\n     * @param shape - The shape of the physics body.\n     *\n     * This method is useful for setting the shape of the physics body, which is necessary for the physics engine to accurately simulate the body's behavior.\n     * The shape is used to calculate the body's mass, inertia, and other properties.\n     */\n    set shape(shape) {\n        this._shape = shape;\n        if (shape) {\n            this._physicsPlugin.setShape(this, shape);\n        }\n    }\n    /**\n     * Retrieves the physics shape associated with this object.\n     *\n     * @returns The physics shape associated with this object, or `undefined` if no\n     * shape is associated.\n     *\n     * This method is useful for retrieving the physics shape associated with this object,\n     * which can be used to apply physical forces to the object or to detect collisions.\n     */\n    get shape() {\n        return this._shape;\n    }\n    /**\n     * Returns the bounding box of the physics body.\n     * @returns The bounding box of the physics body.\n     */\n    getBoundingBox() {\n        return this._physicsPlugin.getBodyBoundingBox(this);\n    }\n    /**\n     * Sets the event mask for the physics engine.\n     *\n     * @param eventMask - A bitmask that determines which events will be sent to the physics engine.\n     * @param instanceIndex - If this body is instanced, the index of the instance to set the event mask for.\n     *\n     * This method is useful for setting the event mask for the physics engine, which determines which events\n     * will be sent to the physics engine. This allows the user to control which events the physics engine will respond to.\n     */\n    setEventMask(eventMask, instanceIndex) {\n        this._physicsPlugin.setEventMask(this, eventMask, instanceIndex);\n    }\n    /**\n     * Gets the event mask of the physics engine.\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the event mask for.\n     * @returns The event mask of the physics engine.\n     *\n     * This method is useful for getting the event mask of the physics engine,\n     * which is used to determine which events the engine will respond to.\n     * This is important for ensuring that the engine is responding to the correct events and not\n     * wasting resources on unnecessary events.\n     */\n    getEventMask(instanceIndex) {\n        return this._physicsPlugin.getEventMask(this, instanceIndex);\n    }\n    /**\n     * Sets the motion type of the physics body. Can be STATIC, DYNAMIC, or ANIMATED.\n     * @param motionType - The motion type to set.\n     * @param instanceIndex - If this body is instanced, the index of the instance to set the motion type for.\n     */\n    setMotionType(motionType, instanceIndex) {\n        this.disableSync = motionType == 0 /* PhysicsMotionType.STATIC */;\n        this._physicsPlugin.setMotionType(this, motionType, instanceIndex);\n    }\n    /**\n     * Gets the motion type of the physics body. Can be STATIC, DYNAMIC, or ANIMATED.\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the motion type for.\n     * @returns The motion type of the physics body.\n     */\n    getMotionType(instanceIndex) {\n        return this._physicsPlugin.getMotionType(this, instanceIndex);\n    }\n    /**\n     * Set the prestep type of the body\n     * @param prestepType prestep type provided by PhysicsPrestepType\n     */\n    setPrestepType(prestepType) {\n        this._prestepType = prestepType;\n    }\n    /**\n     * Get the current prestep type of the body\n     * @returns the type of prestep associated with the body and its instance index\n     */\n    getPrestepType() {\n        return this._prestepType;\n    }\n    /**\n     * Computes the mass properties of the physics object, based on the set of physics shapes this body uses.\n     * This method is useful for computing the initial mass properties of a physics object, such as its mass,\n     * inertia, and center of mass; these values are important for accurately simulating the physics of the\n     * object in the physics engine, and computing values based on the shape will provide you with reasonable\n     * initial values, which you can then customize.\n     * @param instanceIndex - The index of the instance to compute the mass properties for.\n     * @returns The mass properties of the object.\n     */\n    computeMassProperties(instanceIndex) {\n        return this._physicsPlugin.computeMassProperties(this, instanceIndex);\n    }\n    /**\n     * Sets the mass properties of the physics object.\n     *\n     * @param massProps - The mass properties to set.\n     * @param instanceIndex - The index of the instance to set the mass properties for. If not defined, the mass properties will be set for all instances.\n     *\n     * This method is useful for setting the mass properties of a physics object, such as its mass,\n     * inertia, and center of mass. This is important for accurately simulating the physics of the object in the physics engine.\n     */\n    setMassProperties(massProps, instanceIndex) {\n        this._physicsPlugin.setMassProperties(this, massProps, instanceIndex);\n    }\n    /**\n     * Retrieves the mass properties of the object.\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the mass properties for.\n     * @returns The mass properties of the object.\n     *\n     * This method is useful for physics simulations, as it allows the user to\n     * retrieve the mass properties of the object, such as its mass, center of mass,\n     * and moment of inertia. This information is necessary for accurate physics\n     * simulations.\n     */\n    getMassProperties(instanceIndex) {\n        return this._physicsPlugin.getMassProperties(this, instanceIndex);\n    }\n    /**\n     * Sets the linear damping of the physics body.\n     *\n     * @param damping - The linear damping value.\n     * @param instanceIndex - If this body is instanced, the index of the instance to set the linear damping for.\n     *\n     * This method is useful for controlling the linear damping of the physics body,\n     * which is the rate at which the body's velocity decreases over time. This is useful for simulating\n     * the effects of air resistance or other forms of friction.\n     */\n    setLinearDamping(damping, instanceIndex) {\n        this._physicsPlugin.setLinearDamping(this, damping, instanceIndex);\n    }\n    /**\n     * Gets the linear damping of the physics body.\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the linear damping for.\n     * @returns The linear damping of the physics body.\n     *\n     * This method is useful for retrieving the linear damping of the physics body, which is the amount of\n     * resistance the body has to linear motion. This is useful for simulating realistic physics behavior\n     * in a game.\n     */\n    getLinearDamping(instanceIndex) {\n        return this._physicsPlugin.getLinearDamping(this, instanceIndex);\n    }\n    /**\n     * Sets the angular damping of the physics body.\n     * @param damping The angular damping of the body.\n     * @param instanceIndex - If this body is instanced, the index of the instance to set the angular damping for.\n     *\n     * This method is useful for controlling the angular velocity of a physics body.\n     * By setting the damping, the body's angular velocity will be reduced over time, simulating the effect of friction.\n     * This can be used to create realistic physical behavior in a physics engine.\n     */\n    setAngularDamping(damping, instanceIndex) {\n        this._physicsPlugin.setAngularDamping(this, damping, instanceIndex);\n    }\n    /**\n     * Gets the angular damping of the physics body.\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the angular damping for.\n     *\n     * @returns The angular damping of the physics body.\n     *\n     * This method is useful for getting the angular damping of the physics body,\n     * which is the rate of reduction of the angular velocity over time.\n     * This is important for simulating realistic physics behavior in a game.\n     */\n    getAngularDamping(instanceIndex) {\n        return this._physicsPlugin.getAngularDamping(this, instanceIndex);\n    }\n    /**\n     * Sets the linear velocity of the physics object.\n     * @param linVel - The linear velocity to set.\n     * @param instanceIndex - If this body is instanced, the index of the instance to set the linear velocity for.\n     *\n     * This method is useful for setting the linear velocity of a physics object,\n     * which is necessary for simulating realistic physics in a game engine.\n     * By setting the linear velocity, the physics object will move in the direction and speed specified by the vector.\n     * This allows for realistic physics simulations, such as simulating the motion of a ball rolling down a hill.\n     */\n    setLinearVelocity(linVel, instanceIndex) {\n        this._physicsPlugin.setLinearVelocity(this, linVel, instanceIndex);\n    }\n    /**\n     * Gets the linear velocity of the physics body and stores it in the given vector3.\n     * @param linVel - The vector3 to store the linear velocity in.\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the linear velocity for.\n     *\n     * This method is useful for getting the linear velocity of a physics body in a physics engine.\n     * This can be used to determine the speed and direction of the body, which can be used to calculate the motion of the body.\n     */\n    getLinearVelocityToRef(linVel, instanceIndex) {\n        this._physicsPlugin.getLinearVelocityToRef(this, linVel, instanceIndex);\n    }\n    /**\n     * Gets the linear velocity of the physics body as a new vector3.\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the linear velocity for.\n     * @returns The linear velocity of the physics body.\n     *\n     * This method is useful for getting the linear velocity of a physics body in a physics engine.\n     * This can be used to determine the speed and direction of the body, which can be used to calculate the motion of the body.\n     */\n    getLinearVelocity(instanceIndex) {\n        const ref = new Vector3();\n        this.getLinearVelocityToRef(ref, instanceIndex);\n        return ref;\n    }\n    /**\n     * Sets the angular velocity of the physics object.\n     * @param angVel - The angular velocity to set.\n     * @param instanceIndex - If this body is instanced, the index of the instance to set the angular velocity for.\n     *\n     * This method is useful for setting the angular velocity of a physics object, which is necessary for\n     * simulating realistic physics behavior. The angular velocity is used to determine the rate of rotation of the object,\n     * which is important for simulating realistic motion.\n     */\n    setAngularVelocity(angVel, instanceIndex) {\n        this._physicsPlugin.setAngularVelocity(this, angVel, instanceIndex);\n    }\n    /**\n     * Gets the angular velocity of the physics body and stores it in the given vector3.\n     * @param angVel - The vector3 to store the angular velocity in.\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the angular velocity for.\n     *\n     * This method is useful for getting the angular velocity of a physics body, which can be used to determine the body's\n     * rotational speed. This information can be used to create realistic physics simulations.\n     */\n    getAngularVelocityToRef(angVel, instanceIndex) {\n        this._physicsPlugin.getAngularVelocityToRef(this, angVel, instanceIndex);\n    }\n    /**\n     * Gets the angular velocity of the physics body as a new vector3.\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the angular velocity for.\n     * @returns The angular velocity of the physics body.\n     *\n     * This method is useful for getting the angular velocity of a physics body, which can be used to determine the body's\n     * rotational speed. This information can be used to create realistic physics simulations.\n     */\n    getAngularVelocity(instanceIndex) {\n        const ref = new Vector3();\n        this.getAngularVelocityToRef(ref, instanceIndex);\n        return ref;\n    }\n    /**\n     * Applies an impulse to the physics object.\n     *\n     * @param impulse The impulse vector.\n     * @param location The location of the impulse.\n     * @param instanceIndex For a instanced body, the instance to where the impulse should be applied. If not specified, the impulse is applied to all instances.\n     *\n     * This method is useful for applying an impulse to a physics object, which can be used to simulate physical forces such as gravity,\n     * collisions, and explosions. This can be used to create realistic physics simulations in a game or other application.\n     */\n    applyImpulse(impulse, location, instanceIndex) {\n        this._physicsPlugin.applyImpulse(this, impulse, location, instanceIndex);\n    }\n    /**\n     * Add torque to a physics body\n     * @param angularImpulse The angular impulse vector.\n     * @param instanceIndex For a instanced body, the instance to where the impulse should be applied. If not specified, the impulse is applied to all instances.\n     */\n    applyAngularImpulse(angularImpulse, instanceIndex) {\n        this._physicsPlugin.applyAngularImpulse(this, angularImpulse, instanceIndex);\n    }\n    /**\n     * Applies a force to the physics object.\n     *\n     * @param force The force vector.\n     * @param location The location of the force.\n     * @param instanceIndex For a instanced body, the instance to where the force should be applied. If not specified, the force is applied to all instances.\n     *\n     * This method is useful for applying a force to a physics object, which can be used to simulate physical forces such as gravity,\n     * collisions, and explosions. This can be used to create realistic physics simulations in a game or other application.\n     */\n    applyForce(force, location, instanceIndex) {\n        this._physicsPlugin.applyForce(this, force, location, instanceIndex);\n    }\n    /**\n     * Retrieves the geometry of the body from the physics plugin.\n     *\n     * @returns The geometry of the body.\n     *\n     * This method is useful for retrieving the geometry of the body from the physics plugin, which can be used for various physics calculations.\n     */\n    getGeometry() {\n        return this._physicsPlugin.getBodyGeometry(this);\n    }\n    /**\n     * Returns an observable that will be notified for when a collision starts or continues for this PhysicsBody\n     * @returns Observable\n     */\n    getCollisionObservable() {\n        return this._physicsPlugin.getCollisionObservable(this);\n    }\n    /**\n     * Returns an observable that will be notified when the body has finished colliding with another body\n     * @returns\n     */\n    getCollisionEndedObservable() {\n        return this._physicsPlugin.getCollisionEndedObservable(this);\n    }\n    /**\n     * Enable or disable collision callback for this PhysicsBody.\n     * @param enabled true if PhysicsBody's collision will rise a collision event and notifies the observable\n     */\n    setCollisionCallbackEnabled(enabled) {\n        this._collisionCBEnabled = enabled;\n        this._physicsPlugin.setCollisionCallbackEnabled(this, enabled);\n    }\n    /**\n     * Enable or disable collision ended callback for this PhysicsBody.\n     * @param enabled true if PhysicsBody's collision ended will rise a collision event and notifies the observable\n     */\n    setCollisionEndedCallbackEnabled(enabled) {\n        this._collisionEndedCBEnabled = enabled;\n        this._physicsPlugin.setCollisionEndedCallbackEnabled(this, enabled);\n    }\n    /**\n     * Get the center of the object in world space.\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the center for.\n     * @returns geometric center of the associated mesh\n     */\n    getObjectCenterWorld(instanceIndex) {\n        const ref = new Vector3();\n        return this.getObjectCenterWorldToRef(ref, instanceIndex);\n    }\n    /**\n     * Get the center of the object in world space.\n     * @param ref - The vector3 to store the result in.\n     * @param instanceIndex - If this body is instanced, the index of the instance to get the center for.\n     * @returns geometric center of the associated mesh\n     */\n    getObjectCenterWorldToRef(ref, instanceIndex) {\n        if (this._pluginDataInstances?.length > 0) {\n            const index = instanceIndex || 0;\n            const matrixData = this.transformNode._thinInstanceDataStorage.matrixData;\n            if (matrixData) {\n                ref.set(matrixData[index * 16 + 12], matrixData[index * 16 + 13], matrixData[index * 16 + 14]);\n            }\n        }\n        else {\n            ref.copyFrom(this.transformNode.position);\n        }\n        return ref;\n    }\n    /**\n     * Adds a constraint to the physics engine.\n     *\n     * @param childBody - The body to which the constraint will be applied.\n     * @param constraint - The constraint to be applied.\n     * @param instanceIndex - If this body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\n     * @param childInstanceIndex - If the child body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\n     *\n     */\n    addConstraint(childBody, constraint, instanceIndex, childInstanceIndex) {\n        this._physicsPlugin.addConstraint(this, childBody, constraint, instanceIndex, childInstanceIndex);\n    }\n    /**\n     * Sync with a bone\n     * @param bone The bone that the impostor will be synced to.\n     * @param boneMesh The mesh that the bone is influencing.\n     * @param jointPivot The pivot of the joint / bone in local space.\n     * @param distToJoint Optional distance from the impostor to the joint.\n     * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\n     * @param boneAxis Optional vector3 axis the bone is aligned with\n     */\n    syncWithBone(bone, boneMesh, jointPivot, distToJoint, adjustRotation, boneAxis) {\n        const mesh = this.transformNode;\n        if (mesh.rotationQuaternion) {\n            if (adjustRotation) {\n                const tempQuat = TmpVectors.Quaternion[0];\n                bone.getRotationQuaternionToRef(1 /* Space.WORLD */, boneMesh, tempQuat);\n                tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);\n            }\n            else {\n                bone.getRotationQuaternionToRef(1 /* Space.WORLD */, boneMesh, mesh.rotationQuaternion);\n            }\n        }\n        const pos = TmpVectors.Vector3[0];\n        const boneDir = TmpVectors.Vector3[1];\n        if (!boneAxis) {\n            boneAxis = TmpVectors.Vector3[2];\n            boneAxis.x = 0;\n            boneAxis.y = 1;\n            boneAxis.z = 0;\n        }\n        bone.getDirectionToRef(boneAxis, boneMesh, boneDir);\n        bone.getAbsolutePositionToRef(boneMesh, pos);\n        if ((distToJoint === undefined || distToJoint === null) && jointPivot) {\n            distToJoint = jointPivot.length();\n        }\n        if (distToJoint !== undefined && distToJoint !== null) {\n            pos.x += boneDir.x * distToJoint;\n            pos.y += boneDir.y * distToJoint;\n            pos.z += boneDir.z * distToJoint;\n        }\n        mesh.setAbsolutePosition(pos);\n    }\n    /**\n     * Executes a callback on the body or all of the instances of a body\n     * @param callback the callback to execute\n     */\n    iterateOverAllInstances(callback) {\n        if (this._pluginDataInstances?.length > 0) {\n            for (let i = 0; i < this._pluginDataInstances.length; i++) {\n                callback(this, i);\n            }\n        }\n        else {\n            callback(this, undefined);\n        }\n    }\n    /**\n     * Sets the gravity factor of the physics body\n     * @param factor the gravity factor to set\n     * @param instanceIndex the instance of the body to set, if undefined all instances will be set\n     */\n    setGravityFactor(factor, instanceIndex) {\n        this._physicsPlugin.setGravityFactor(this, factor, instanceIndex);\n    }\n    /**\n     * Gets the gravity factor of the physics body\n     * @param instanceIndex the instance of the body to get, if undefined the value of first instance will be returned\n     * @returns the gravity factor\n     */\n    getGravityFactor(instanceIndex) {\n        return this._physicsPlugin.getGravityFactor(this, instanceIndex);\n    }\n    /**\n     * Set the target transformation (position and rotation) of the body, such that the body will set its velocity to reach that target\n     * @param position The target position\n     * @param rotation The target rotation\n     * @param instanceIndex The index of the instance in an instanced body\n     */\n    setTargetTransform(position, rotation, instanceIndex) {\n        this._physicsPlugin.setTargetTransform(this, position, rotation, instanceIndex);\n    }\n    /**\n     * Returns if the body has been disposed.\n     * @returns true if disposed, false otherwise.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Disposes the body from the physics engine.\n     *\n     * This method is useful for cleaning up the physics engine when a body is no longer needed. Disposing the body will free up resources and prevent memory leaks.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        // Disable collisions CB so it doesn't fire when the body is disposed\n        if (this._collisionCBEnabled) {\n            this.setCollisionCallbackEnabled(false);\n        }\n        if (this._collisionEndedCBEnabled) {\n            this.setCollisionEndedCallbackEnabled(false);\n        }\n        if (this._nodeDisposeObserver) {\n            this.transformNode.onDisposeObservable.remove(this._nodeDisposeObserver);\n            this._nodeDisposeObserver = null;\n        }\n        this._physicsEngine.removeBody(this);\n        this._physicsPlugin.removeBody(this);\n        this._physicsPlugin.disposeBody(this);\n        this.transformNode.physicsBody = null;\n        this._pluginData = null;\n        this._pluginDataInstances.length = 0;\n        this._isDisposed = true;\n        this.shape = null;\n    }\n}\n//# sourceMappingURL=physicsBody.js.map","/**\n * This is a holder class for the physics constraint created by the physics plugin\n * It holds a set of functions to control the underlying constraint\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\n */\nexport class PhysicsConstraint {\n    /**\n     * Constructs a new constraint for the physics constraint.\n     * @param type The type of constraint to create.\n     * @param options The options for the constraint.\n     * @param scene The scene the constraint belongs to.\n     *\n     * This code is useful for creating a new constraint for the physics engine. It checks if the scene has a physics engine, and if the plugin version is correct.\n     * If all checks pass, it initializes the constraint with the given type and options.\n     */\n    constructor(type, options, scene) {\n        /**\n         * V2 Physics plugin private data for a physics material\n         */\n        this._pluginData = undefined;\n        if (!scene) {\n            throw new Error(\"Missing scene parameter for constraint constructor.\");\n        }\n        const physicsEngine = scene.getPhysicsEngine();\n        if (!physicsEngine) {\n            throw new Error(\"No Physics Engine available.\");\n        }\n        if (physicsEngine.getPluginVersion() != 2) {\n            throw new Error(\"Plugin version is incorrect. Expected version 2.\");\n        }\n        const physicsPlugin = physicsEngine.getPhysicsPlugin();\n        if (!physicsPlugin) {\n            throw new Error(\"No Physics Plugin available.\");\n        }\n        this._physicsPlugin = physicsPlugin;\n        this._options = options;\n        this._type = type;\n    }\n    /**\n     * Gets the type of the constraint.\n     *\n     * @returns The type of the constraint.\n     *\n     */\n    get type() {\n        return this._type;\n    }\n    /**\n     * Retrieves the options of the physics constraint.\n     *\n     * @returns The physics constraint parameters.\n     *\n     */\n    get options() {\n        return this._options;\n    }\n    /**\n     * Enable/disable the constraint\n     * @param isEnabled value for the constraint\n     */\n    set isEnabled(isEnabled) {\n        this._physicsPlugin.setEnabled(this, isEnabled);\n    }\n    /**\n     *\n     * @returns true if constraint is enabled\n     */\n    get isEnabled() {\n        return this._physicsPlugin.getEnabled(this);\n    }\n    /**\n     * Enables or disables collisions for the physics engine.\n     *\n     * @param isEnabled - A boolean value indicating whether collisions should be enabled or disabled.\n     *\n     */\n    set isCollisionsEnabled(isEnabled) {\n        this._physicsPlugin.setCollisionsEnabled(this, isEnabled);\n    }\n    /**\n     * Gets whether collisions are enabled for this physics object.\n     *\n     * @returns `true` if collisions are enabled, `false` otherwise.\n     *\n     */\n    get isCollisionsEnabled() {\n        return this._physicsPlugin.getCollisionsEnabled(this);\n    }\n    /**\n     * Gets all bodies that are using this constraint\n     * @returns\n     */\n    getBodiesUsingConstraint() {\n        return this._physicsPlugin.getBodiesUsingConstraint(this);\n    }\n    /**\n     * Disposes the constraint from the physics engine.\n     *\n     * This method is useful for cleaning up the physics engine when a body is no longer needed. Disposing the body will free up resources and prevent memory leaks.\n     */\n    dispose() {\n        this._physicsPlugin.disposeConstraint(this);\n    }\n}\n/**\n * This describes a single limit used by Physics6DoFConstraint\n */\nexport class Physics6DoFLimit {\n}\n/**\n * A generic constraint, which can be used to build more complex constraints than those specified\n * in PhysicsConstraintType. The axis and pivot options in PhysicsConstraintParameters define the space\n * the constraint operates in. This constraint contains a set of limits, which restrict the\n * relative movement of the bodies in that coordinate system\n */\nexport class Physics6DoFConstraint extends PhysicsConstraint {\n    constructor(constraintParams, limits, scene) {\n        super(7 /* PhysicsConstraintType.SIX_DOF */, constraintParams, scene);\n        this.limits = limits;\n    }\n    /**\n     * Sets the friction of the given axis of the physics engine.\n     * @param axis - The axis of the physics engine to set the friction for.\n     * @param friction - The friction to set for the given axis.\n     *\n     */\n    setAxisFriction(axis, friction) {\n        this._physicsPlugin.setAxisFriction(this, axis, friction);\n    }\n    /**\n     * Gets the friction of the given axis of the physics engine.\n     * @param axis - The axis of the physics engine.\n     * @returns The friction of the given axis, or null if the constraint hasn't been initialized yet.\n     *\n     */\n    getAxisFriction(axis) {\n        return this._physicsPlugin.getAxisFriction(this, axis);\n    }\n    /**\n     * Sets the limit mode for the given axis of the constraint.\n     * @param axis The axis to set the limit mode for.\n     * @param limitMode The limit mode to set.\n     *\n     * This method is useful for setting the limit mode for a given axis of the constraint. This is important for\n     * controlling the behavior of the physics engine when the constraint is reached. By setting the limit mode,\n     * the engine can be configured to either stop the motion of the objects, or to allow them to continue\n     * moving beyond the constraint.\n     */\n    setAxisMode(axis, limitMode) {\n        this._physicsPlugin.setAxisMode(this, axis, limitMode);\n    }\n    /**\n     * Gets the limit mode of the given axis of the constraint.\n     *\n     * @param axis - The axis of the constraint.\n     * @returns The limit mode of the given axis, or null if the constraint hasn't been initialized yet.\n     *\n     */\n    getAxisMode(axis) {\n        return this._physicsPlugin.getAxisMode(this, axis);\n    }\n    /**\n     * Sets the minimum limit of a given axis of a constraint.\n     * @param axis - The axis of the constraint.\n     * @param minLimit - The minimum limit of the axis.\n     *\n     */\n    setAxisMinLimit(axis, minLimit) {\n        this._physicsPlugin.setAxisMinLimit(this, axis, minLimit);\n    }\n    /**\n     * Gets the minimum limit of the given axis of the physics engine.\n     * @param axis - The axis of the physics engine.\n     * @returns The minimum limit of the given axis, or null if the constraint hasn't been initialized yet.\n     *\n     */\n    getAxisMinLimit(axis) {\n        return this._physicsPlugin.getAxisMinLimit(this, axis);\n    }\n    /**\n     * Sets the maximum limit of the given axis for the physics engine.\n     * @param axis - The axis to set the limit for.\n     * @param limit - The maximum limit of the axis.\n     *\n     * This method is useful for setting the maximum limit of the given axis for the physics engine,\n     * which can be used to control the movement of the physics object. This helps to ensure that the\n     * physics object does not move beyond the given limit.\n     */\n    setAxisMaxLimit(axis, limit) {\n        this._physicsPlugin.setAxisMaxLimit(this, axis, limit);\n    }\n    /**\n     * Gets the maximum limit of the given axis of the physics engine.\n     * @param axis - The axis of the physics engine.\n     * @returns The maximum limit of the given axis, or null if the constraint hasn't been initialized yet.\n     *\n     */\n    getAxisMaxLimit(axis) {\n        return this._physicsPlugin.getAxisMaxLimit(this, axis);\n    }\n    /**\n     * Sets the motor type of the given axis of the constraint.\n     * @param axis - The axis of the constraint.\n     * @param motorType - The type of motor to use.\n     */\n    setAxisMotorType(axis, motorType) {\n        this._physicsPlugin.setAxisMotorType(this, axis, motorType);\n    }\n    /**\n     * Gets the motor type of the specified axis of the constraint.\n     *\n     * @param axis - The axis of the constraint.\n     * @returns The motor type of the specified axis, or null if the constraint hasn't been initialized yet.\n     *\n     */\n    getAxisMotorType(axis) {\n        return this._physicsPlugin.getAxisMotorType(this, axis);\n    }\n    /**\n     * Sets the target velocity of the motor associated with the given axis of the constraint.\n     * @param axis - The axis of the constraint.\n     * @param target - The target velocity of the motor.\n     *\n     * This method is useful for setting the target velocity of the motor associated with the given axis of the constraint.\n     */\n    setAxisMotorTarget(axis, target) {\n        this._physicsPlugin.setAxisMotorTarget(this, axis, target);\n    }\n    /**\n     * Gets the target velocity of the motor associated to the given constraint axis.\n     * @param axis - The constraint axis associated to the motor.\n     * @returns The target velocity of the motor, or null if the constraint hasn't been initialized yet.\n     *\n     */\n    getAxisMotorTarget(axis) {\n        return this._physicsPlugin.getAxisMotorTarget(this, axis);\n    }\n    /**\n     * Sets the maximum force of the motor of the given axis of the constraint.\n     * @param axis - The axis of the constraint.\n     * @param maxForce - The maximum force of the motor.\n     *\n     */\n    setAxisMotorMaxForce(axis, maxForce) {\n        this._physicsPlugin.setAxisMotorMaxForce(this, axis, maxForce);\n    }\n    /**\n     * Gets the maximum force of the motor of the given axis of the constraint.\n     * @param axis - The axis of the constraint.\n     * @returns The maximum force of the motor, or null if the constraint hasn't been initialized yet.\n     *\n     */\n    getAxisMotorMaxForce(axis) {\n        return this._physicsPlugin.getAxisMotorMaxForce(this, axis);\n    }\n}\n/**\n * Represents a Ball and Socket Constraint, used to simulate a joint\n * This class is useful for simulating a joint between two bodies in a physics engine.\n * It allows for the two bodies to move relative to each other in a way that mimics a ball and socket joint, such as a shoulder or hip joint.\n * @param pivotA - The first pivot, defined locally in the first body frame\n * @param pivotB - The second pivot, defined locally in the second body frame\n * @param axisA - The axis of the first body\n * @param axisB - The axis of the second body\n * @param scene - The scene the constraint is applied to\n * @returns The Ball and Socket Constraint\n */\nexport class BallAndSocketConstraint extends PhysicsConstraint {\n    constructor(pivotA, pivotB, axisA, axisB, scene) {\n        super(1 /* PhysicsConstraintType.BALL_AND_SOCKET */, { pivotA: pivotA, pivotB: pivotB, axisA: axisA, axisB: axisB }, scene);\n    }\n}\n/**\n * Creates a distance constraint.\n *\n * This code is useful for creating a distance constraint in a physics engine.\n * A distance constraint is a type of constraint that keeps two objects at a certain distance from each other.\n * The scene is used to add the constraint to the physics engine.\n * @param maxDistance distance between bodies\n * @param scene The scene the constraint belongs to\n * @returns DistanceConstraint\n */\nexport class DistanceConstraint extends PhysicsConstraint {\n    constructor(maxDistance, scene) {\n        super(2 /* PhysicsConstraintType.DISTANCE */, { maxDistance: maxDistance }, scene);\n    }\n}\n/**\n * Creates a HingeConstraint, which is a type of PhysicsConstraint.\n *\n * This code is useful for creating a HingeConstraint, which is a type of PhysicsConstraint.\n * This constraint is used to simulate a hinge joint between two rigid bodies, allowing them to rotate around a single axis.\n * @param pivotA - The first pivot point, in world space.\n * @param pivotB - The second pivot point, in world space.\n * @param scene - The scene the constraint is used in.\n * @returns The new HingeConstraint.\n */\nexport class HingeConstraint extends PhysicsConstraint {\n    constructor(pivotA, pivotB, axisA, axisB, scene) {\n        super(3 /* PhysicsConstraintType.HINGE */, { pivotA: pivotA, pivotB: pivotB, axisA: axisA, axisB: axisB }, scene);\n    }\n}\n/**\n * Creates a SliderConstraint, which is a type of PhysicsConstraint.\n *\n * This code is useful for creating a SliderConstraint, which is a type of PhysicsConstraint.\n * It allows the user to specify the two pivots and two axes of the constraint in world space, as well as the scene the constraint belongs to.\n * This is useful for creating a constraint between two rigid bodies that allows them to move along a certain axis.\n * @param pivotA - The first pivot of the constraint, in world space.\n * @param pivotB - The second pivot of the constraint, in world space.\n * @param axisA - The first axis of the constraint, in world space.\n * @param axisB - The second axis of the constraint, in world space.\n * @param scene - The scene the constraint belongs to.\n * @returns The created SliderConstraint.\n */\nexport class SliderConstraint extends PhysicsConstraint {\n    constructor(pivotA, pivotB, axisA, axisB, scene) {\n        super(4 /* PhysicsConstraintType.SLIDER */, { pivotA: pivotA, pivotB: pivotB, axisA: axisA, axisB: axisB }, scene);\n    }\n}\n/**\n * Creates a LockConstraint, which is a type of PhysicsConstraint.\n *\n * This code is useful for creating a LockConstraint, which is a type of PhysicsConstraint.\n * It takes in two pivots and two axes in local space, as well as the scene the constraint belongs to, and creates a LockConstraint.\n * @param pivotA - The first pivot of the constraint in local space.\n * @param pivotB - The second pivot of the constraint in local space.\n * @param axisA - The first axis of the constraint in local space.\n * @param axisB - The second axis of the constraint in local space.\n * @param scene - The scene the constraint belongs to.\n * @returns The created LockConstraint.\n */\nexport class LockConstraint extends PhysicsConstraint {\n    constructor(pivotA, pivotB, axisA, axisB, scene) {\n        super(5 /* PhysicsConstraintType.LOCK */, { pivotA: pivotA, pivotB: pivotB, axisA: axisA, axisB: axisB }, scene);\n    }\n}\n/**\n * Creates a PrismaticConstraint, which is a type of PhysicsConstraint.\n *\n * This code is useful for creating a PrismaticConstraint, which is a type of PhysicsConstraint.\n * It takes in two pivots and two axes in local space, as well as the scene the constraint belongs to, and creates a PrismaticConstraint.\n * @param pivotA - The first pivot of the constraint in local space.\n * @param pivotB - The second pivot of the constraint in local space.\n * @param axisA - The first axis of the constraint in local space.\n * @param axisB - The second axis of the constraint in local space.\n * @param scene - The scene the constraint belongs to.\n * @returns The created LockConstraint.\n */\nexport class PrismaticConstraint extends PhysicsConstraint {\n    constructor(pivotA, pivotB, axisA, axisB, scene) {\n        super(6 /* PhysicsConstraintType.PRISMATIC */, { pivotA: pivotA, pivotB: pivotB, axisA: axisA, axisB: axisB }, scene);\n    }\n}\n/**\n * Creates a SpringConstraint, which is a type of Physics6DoFConstraint. This constraint applies a force at the ends which is proportional\n * to the distance between ends, and a stiffness and damping factor. The force is calculated as (stiffness * positionError) - (damping * velocity)\n *\n * @param pivotA - The first pivot of the constraint in local space.\n * @param pivotB - The second pivot of the constraint in local space.\n * @param axisA - The first axis of the constraint in local space.\n * @param axisB - The second axis of the constraint in local space.\n * @param minDistance - The minimum distance between the two pivots.\n * @param maxDistance - The maximum distance between the two pivots.\n * @param stiffness - The stiffness of the spring.\n * @param damping - The damping of the spring.\n * @param scene - The scene the constraint belongs to.\n * @returns The created SpringConstraint.\n */\nexport class SpringConstraint extends Physics6DoFConstraint {\n    constructor(pivotA, pivotB, axisA, axisB, minDistance, maxDistance, stiffness, damping, scene) {\n        super({ pivotA, pivotB, axisA, axisB }, [{ axis: 6 /* PhysicsConstraintAxis.LINEAR_DISTANCE */, minLimit: minDistance, maxLimit: maxDistance, stiffness, damping }], scene);\n    }\n}\n//# sourceMappingURL=physicsConstraint.js.map","import { PhysicsBody } from \"./physicsBody.js\";\nimport { PhysicsShape } from \"./physicsShape.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector.js\";\nimport { WithinEpsilon } from \"../../Maths/math.scalar.functions.js\";\nimport { BoundingBox } from \"../../Culling/boundingBox.js\";\n/**\n * Helper class to create and interact with a PhysicsAggregate.\n * This is a transition object that works like Physics Plugin V1 Impostors.\n * This helper instanciate all mandatory physics objects to get a body/shape and material.\n * It's less efficient that handling body and shapes independently but for prototyping or\n * a small numbers of physics objects, it's good enough.\n */\nexport class PhysicsAggregate {\n    constructor(\n    /**\n     * The physics-enabled object used as the physics aggregate\n     */\n    transformNode, \n    /**\n     * The type of the physics aggregate\n     */\n    type, _options = { mass: 0 }, _scene) {\n        this.transformNode = transformNode;\n        this.type = type;\n        this._options = _options;\n        this._scene = _scene;\n        this._disposeShapeWhenDisposed = true;\n        //sanity check!\n        if (!this.transformNode) {\n            Logger.Error(\"No object was provided. A physics object is obligatory\");\n            return;\n        }\n        const m = transformNode;\n        if (this.transformNode.parent && this._options.mass !== 0 && m.hasThinInstances) {\n            Logger.Warn(\"A physics body has been created for an object which has a parent and thin instances. Babylon physics currently works in local space so unexpected issues may occur.\");\n        }\n        // Legacy support for old syntax.\n        if (!this._scene && transformNode.getScene) {\n            this._scene = transformNode.getScene();\n        }\n        if (!this._scene) {\n            return;\n        }\n        //default options params\n        this._options.mass = _options.mass === void 0 ? 0 : _options.mass;\n        this._options.friction = _options.friction === void 0 ? 0.2 : _options.friction;\n        this._options.restitution = _options.restitution === void 0 ? 0.2 : _options.restitution;\n        const motionType = this._options.mass === 0 ? 0 /* PhysicsMotionType.STATIC */ : 2 /* PhysicsMotionType.DYNAMIC */;\n        const startAsleep = this._options.startAsleep ?? false;\n        this.body = new PhysicsBody(transformNode, motionType, startAsleep, this._scene);\n        this._addSizeOptions();\n        if (type.getClassName && type.getClassName() === \"PhysicsShape\") {\n            this.shape = type;\n            this._disposeShapeWhenDisposed = false;\n        }\n        else {\n            this.shape = new PhysicsShape({ type: type, parameters: this._options }, this._scene);\n        }\n        if (this._options.isTriggerShape) {\n            this.shape.isTrigger = true;\n        }\n        this.material = { friction: this._options.friction, restitution: this._options.restitution };\n        this.body.shape = this.shape;\n        this.shape.material = this.material;\n        this.body.setMassProperties({ mass: this._options.mass });\n        this._nodeDisposeObserver = this.transformNode.onDisposeObservable.add(() => {\n            this.dispose();\n        });\n    }\n    _getObjectBoundingBox() {\n        if (this.transformNode.getRawBoundingInfo) {\n            return this.transformNode.getRawBoundingInfo().boundingBox;\n        }\n        else {\n            return new BoundingBox(new Vector3(-0.5, -0.5, -0.5), new Vector3(0.5, 0.5, 0.5));\n        }\n    }\n    _hasVertices(node) {\n        return node?.getTotalVertices() > 0;\n    }\n    _addSizeOptions() {\n        this.transformNode.computeWorldMatrix(true);\n        const bb = this._getObjectBoundingBox();\n        const extents = TmpVectors.Vector3[0];\n        extents.copyFrom(bb.extendSize);\n        extents.scaleInPlace(2);\n        extents.multiplyInPlace(this.transformNode.absoluteScaling);\n        // In case we had any negative scaling, we need to take the absolute value of the extents.\n        extents.x = Math.abs(extents.x);\n        extents.y = Math.abs(extents.y);\n        extents.z = Math.abs(extents.z);\n        const min = TmpVectors.Vector3[1];\n        min.copyFrom(bb.minimum);\n        min.multiplyInPlace(this.transformNode.absoluteScaling);\n        if (!this._options.center) {\n            const center = new Vector3();\n            center.copyFrom(bb.center);\n            center.multiplyInPlace(this.transformNode.absoluteScaling);\n            this._options.center = center;\n        }\n        switch (this.type) {\n            case 0 /* PhysicsShapeType.SPHERE */:\n                if (!this._options.radius && WithinEpsilon(extents.x, extents.y, 0.0001) && WithinEpsilon(extents.x, extents.z, 0.0001)) {\n                    this._options.radius = extents.x / 2;\n                }\n                else if (!this._options.radius) {\n                    Logger.Warn(\"Non uniform scaling is unsupported for sphere shapes. Setting the radius to the biggest bounding box extent.\");\n                    this._options.radius = Math.max(extents.x, extents.y, extents.z) / 2;\n                }\n                break;\n            case 1 /* PhysicsShapeType.CAPSULE */:\n                {\n                    const capRadius = extents.x / 2;\n                    this._options.radius = this._options.radius ?? capRadius;\n                    this._options.pointA = this._options.pointA ?? new Vector3(0, min.y + capRadius, 0);\n                    this._options.pointB = this._options.pointB ?? new Vector3(0, min.y + extents.y - capRadius, 0);\n                }\n                break;\n            case 2 /* PhysicsShapeType.CYLINDER */:\n                {\n                    const capRadius = extents.x / 2;\n                    this._options.radius = this._options.radius ?? capRadius;\n                    this._options.pointA = this._options.pointA ?? new Vector3(0, min.y, 0);\n                    this._options.pointB = this._options.pointB ?? new Vector3(0, min.y + extents.y, 0);\n                }\n                break;\n            case 6 /* PhysicsShapeType.MESH */:\n            case 4 /* PhysicsShapeType.CONVEX_HULL */:\n            case 7 /* PhysicsShapeType.HEIGHTFIELD */:\n                if (!this._options.mesh && this._hasVertices(this.transformNode)) {\n                    this._options.mesh = this.transformNode;\n                }\n                else if (!this._options.mesh || !this._hasVertices(this._options.mesh)) {\n                    throw new Error(\"No valid mesh was provided for mesh or convex hull shape parameter. Please provide a mesh with valid geometry (number of vertices greater than 0).\");\n                }\n                break;\n            case 3 /* PhysicsShapeType.BOX */:\n                this._options.extents = this._options.extents ?? new Vector3(extents.x, extents.y, extents.z);\n                this._options.rotation = this._options.rotation ?? Quaternion.Identity();\n                break;\n        }\n    }\n    /**\n     * Releases the body, shape and material\n     */\n    dispose() {\n        if (this._nodeDisposeObserver) {\n            this.body.transformNode.onDisposeObservable.remove(this._nodeDisposeObserver);\n            this._nodeDisposeObserver = null;\n        }\n        this.body.dispose();\n        if (this._disposeShapeWhenDisposed) {\n            this.shape.dispose();\n        }\n    }\n}\n//# sourceMappingURL=physicsAggregate.js.map","import { Vector3, Matrix, TmpVectors, Quaternion } from \"../../Maths/math.vector.js\";\nimport { PhysicsAggregate } from \"./physicsAggregate.js\";\nimport { PhysicsConstraint } from \"./physicsConstraint.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { TransformNode } from \"../../Meshes/transformNode.js\";\n/**\n * Ragdoll bone properties\n * @experimental\n */\nexport class RagdollBoneProperties {\n}\n/**\n * Ragdoll for Physics V2\n * @experimental\n */\nexport class Ragdoll {\n    /**\n     * Construct a new Ragdoll object. Once ready, it can be made dynamic by calling `Ragdoll` method\n     * @param skeleton The skeleton containing bones to be physicalized\n     * @param rootTransformNode The mesh or its transform used by the skeleton\n     * @param config an array of `RagdollBoneProperties` corresponding to bones and their properties used to instanciate physics bodies\n     */\n    constructor(skeleton, rootTransformNode, config) {\n        this._boxConfigs = new Array();\n        this._constraints = new Array();\n        this._bones = new Array();\n        this._initialRotation = new Array();\n        // without mesh transform, to figure out later\n        this._initialRotation2 = new Array();\n        this._boneNames = [];\n        this._transforms = new Array();\n        this._aggregates = new Array();\n        this._ragdollMode = false;\n        this._rootBoneName = \"\";\n        this._rootBoneIndex = -1;\n        this._mass = 10;\n        this._restitution = 0;\n        /**\n         * Pause synchronization between physics and bone position/orientation\n         */\n        this.pauseSync = false;\n        this._defaultJoint = 3 /* PhysicsConstraintType.HINGE */;\n        this._defaultJointMin = -90;\n        this._defaultJointMax = 90;\n        this._skeleton = skeleton;\n        this._scene = skeleton.getScene();\n        this._rootTransformNode = rootTransformNode;\n        this._config = config; // initial, user defined box configs. May have several box configs jammed into 1 index.\n        this._boxConfigs = []; // final box configs. Every element is a separate box config (this.config may have several configs jammed into 1 index).\n        this._putBoxesInBoneCenter = false;\n        this._defaultJoint = 3 /* PhysicsConstraintType.HINGE */;\n        this._init();\n    }\n    /**\n     * returns an array of created constraints\n     * @returns array of created constraints\n     */\n    getConstraints() {\n        return this._constraints;\n    }\n    /**\n     * Returns the aggregate corresponding to the ragdoll bone index\n     * @param index ragdoll bone aggregate index\n     * @returns the aggregate for the bone index for the root aggregate if index is invalid\n     */\n    getAggregate(index) {\n        if (index < 0 || index >= this._aggregates.length) {\n            return this._aggregates[this._rootBoneIndex];\n        }\n        return this._aggregates[index];\n    }\n    _createColliders() {\n        this._rootTransformNode.computeWorldMatrix();\n        this._skeleton.computeAbsoluteMatrices(true);\n        this._skeleton.prepare(true);\n        const config = this._config;\n        for (let i = 0; i < config.length; i++) {\n            const boneNames = config[i].bone !== undefined ? [config[i].bone] : config[i].bones;\n            for (let ii = 0; ii < boneNames.length; ii++) {\n                const currentBone = this._skeleton.bones[this._skeleton.getBoneIndexByName(boneNames[ii])];\n                if (currentBone == undefined) {\n                    return;\n                }\n                // First define the box dimensions, so we can then use them when calling CreateBox().\n                const currentRagdollBoneProperties = {\n                    width: this._config[i].width,\n                    depth: this._config[i].depth,\n                    height: this._config[i].height,\n                    size: this._config[i].size,\n                };\n                currentRagdollBoneProperties.width = currentRagdollBoneProperties.width ?? currentRagdollBoneProperties.size;\n                currentRagdollBoneProperties.depth = currentRagdollBoneProperties.depth ?? currentRagdollBoneProperties.size;\n                currentRagdollBoneProperties.height = currentRagdollBoneProperties.height ?? currentRagdollBoneProperties.size;\n                const transform = new TransformNode(boneNames[ii] + \"_transform\", this._scene);\n                // Define the rest of the box properties.\n                currentRagdollBoneProperties.joint = config[i].joint !== undefined ? config[i].joint : this._defaultJoint;\n                currentRagdollBoneProperties.rotationAxis = config[i].rotationAxis !== undefined ? config[i].rotationAxis : Axis.X;\n                currentRagdollBoneProperties.min = config[i].min !== undefined ? config[i].min : this._defaultJointMin;\n                currentRagdollBoneProperties.max = config[i].max !== undefined ? config[i].max : this._defaultJointMax;\n                // Offset value.\n                let boxOffset = 0;\n                if ((config[i].putBoxInBoneCenter !== undefined && config[i].putBoxInBoneCenter) || this._putBoxesInBoneCenter) {\n                    if (currentBone.length === undefined) {\n                        Logger.Log(\"The length property is not defined for bone \" + currentBone.name);\n                    }\n                    boxOffset = currentBone.length / 2;\n                }\n                else if (config[i].boxOffset !== undefined) {\n                    boxOffset = config[i].boxOffset;\n                }\n                currentRagdollBoneProperties.boxOffset = boxOffset;\n                // Offset axis.\n                const boneOffsetAxis = config[i].boneOffsetAxis !== undefined ? config[i].boneOffsetAxis : Axis.Y;\n                const boneDir = currentBone.getDirection(boneOffsetAxis, this._rootTransformNode);\n                currentRagdollBoneProperties.boneOffsetAxis = boneOffsetAxis;\n                transform.position = currentBone.getAbsolutePosition(this._rootTransformNode).add(boneDir.scale(boxOffset));\n                const mass = config[i].mass !== undefined ? config[i].mass : this._mass;\n                const restitution = config[i].restitution !== undefined ? config[i].restitution : this._restitution;\n                const aggregate = new PhysicsAggregate(transform, 3 /* PhysicsShapeType.BOX */, {\n                    mass: mass,\n                    restitution: restitution,\n                    friction: 0.6,\n                    extents: new Vector3(currentRagdollBoneProperties.width, currentRagdollBoneProperties.height, currentRagdollBoneProperties.depth),\n                }, this._scene);\n                aggregate.body.setCollisionCallbackEnabled(true);\n                aggregate.body.disablePreStep = false;\n                aggregate.body.setMotionType(1 /* PhysicsMotionType.ANIMATED */);\n                this._aggregates.push(aggregate);\n                this._bones.push(currentBone);\n                this._boneNames.push(currentBone.name);\n                this._transforms.push(transform);\n                this._boxConfigs.push(currentRagdollBoneProperties);\n                this._initialRotation.push(currentBone.getRotationQuaternion(1 /* Space.WORLD */, this._rootTransformNode));\n                this._initialRotation2.push(currentBone.getRotationQuaternion(1 /* Space.WORLD */));\n            }\n        }\n    }\n    _initJoints() {\n        this._rootTransformNode.computeWorldMatrix();\n        for (let i = 0; i < this._bones.length; i++) {\n            // The root bone has no joints.\n            if (i == this._rootBoneIndex)\n                continue;\n            const nearestParent = this._findNearestParent(i);\n            if (nearestParent == null) {\n                Logger.Warn(\"Couldn't find a nearest parent bone in the configs for bone called \" + this._boneNames[i]);\n                return;\n            }\n            const boneParentIndex = this._boneNames.indexOf(nearestParent.name);\n            let distanceFromParentBoxToBone = this._bones[i].getAbsolutePosition(this._rootTransformNode).subtract(this._transforms[boneParentIndex].position);\n            const wmat = this._transforms[boneParentIndex].computeWorldMatrix();\n            const invertedWorldMat = Matrix.Invert(wmat);\n            distanceFromParentBoxToBone = Vector3.TransformCoordinates(this._bones[i].getAbsolutePosition(this._rootTransformNode), invertedWorldMat);\n            const boneAbsPos = this._bones[i].getAbsolutePosition(this._rootTransformNode);\n            const boxAbsPos = this._transforms[i].position.clone();\n            const myConnectedPivot = boneAbsPos.subtract(boxAbsPos);\n            const constraintType = this._boxConfigs[i].joint ?? this._defaultJoint;\n            const constraint = new PhysicsConstraint(constraintType, {\n                pivotA: distanceFromParentBoxToBone,\n                pivotB: myConnectedPivot,\n                axisA: this._boxConfigs[i].rotationAxis,\n                axisB: this._boxConfigs[i].rotationAxis,\n                collision: false,\n            }, this._scene);\n            this._aggregates[boneParentIndex].body.addConstraint(this._aggregates[i].body, constraint);\n            constraint.isEnabled = false;\n            this._constraints.push(constraint);\n        }\n    }\n    // set physics body orientation/position from bones\n    _syncBonesToPhysics() {\n        const rootMatrix = this._rootTransformNode.getWorldMatrix();\n        for (let i = 0; i < this._bones.length; i++) {\n            // position\n            const transform = this._aggregates[i].transformNode;\n            const rootPos = this._bones[i].getAbsolutePosition();\n            Vector3.TransformCoordinatesToRef(rootPos, rootMatrix, transform.position);\n            // added offset\n            this._bones[i].getDirectionToRef(this._boxConfigs[i].boneOffsetAxis, this._rootTransformNode, TmpVectors.Vector3[0]);\n            TmpVectors.Vector3[0].scaleInPlace(this._boxConfigs[i].boxOffset ?? 0);\n            transform.position.addInPlace(TmpVectors.Vector3[0]);\n            this._setBoneOrientationToBody(i);\n        }\n    }\n    _setBoneOrientationToBody(boneIndex) {\n        const transform = this._aggregates[boneIndex].transformNode;\n        const bone = this._bones[boneIndex];\n        this._initialRotation[boneIndex].conjugateToRef(TmpVectors.Quaternion[0]);\n        bone.getRotationQuaternionToRef(1 /* Space.WORLD */, this._rootTransformNode, TmpVectors.Quaternion[1]);\n        TmpVectors.Quaternion[1].multiplyToRef(TmpVectors.Quaternion[0], transform.rotationQuaternion);\n        transform.rotationQuaternion.normalize();\n    }\n    _syncBonesAndBoxes() {\n        if (this.pauseSync) {\n            return;\n        }\n        if (this._ragdollMode) {\n            this._setBodyOrientationToBone(this._rootBoneIndex);\n            const rootPos = this._aggregates[this._rootBoneIndex].body.transformNode.position;\n            this._rootTransformNode.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\n            Vector3.TransformCoordinatesToRef(rootPos, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\n            this._bones[this._rootBoneIndex].setAbsolutePosition(TmpVectors.Vector3[0]);\n            for (let i = 0; i < this._bones.length; i++) {\n                if (i == this._rootBoneIndex)\n                    continue;\n                this._setBodyOrientationToBone(i);\n            }\n        }\n        else {\n            this._syncBonesToPhysics();\n        }\n    }\n    _setBodyOrientationToBone(boneIndex) {\n        const qmesh = this._rootTransformNode.rotationQuaternion ??\n            Quaternion.FromEulerAngles(this._rootTransformNode.rotation.x, this._rootTransformNode.rotation.y, this._rootTransformNode.rotation.z);\n        const qbind = this._initialRotation2[boneIndex];\n        const qphys = this._aggregates[boneIndex].body?.transformNode?.rotationQuaternion;\n        qmesh.multiplyToRef(qbind, TmpVectors.Quaternion[1]);\n        qphys.multiplyToRef(TmpVectors.Quaternion[1], TmpVectors.Quaternion[0]);\n        this._bones[boneIndex].setRotationQuaternion(TmpVectors.Quaternion[0], 1 /* Space.WORLD */, this._rootTransformNode);\n    }\n    // Return true if root bone is valid/exists in this.bonesNames. false otherwise.\n    _defineRootBone() {\n        const skeletonRoots = this._skeleton.getChildren();\n        if (skeletonRoots.length != 1) {\n            Logger.Log(\"Ragdoll creation failed: there can only be one root in the skeleton.\");\n            return false;\n        }\n        this._rootBoneName = skeletonRoots[0].name;\n        this._rootBoneIndex = this._boneNames.indexOf(this._rootBoneName);\n        if (this._rootBoneIndex == -1) {\n            Logger.Log(\"Ragdoll creation failed: the array boneNames doesn't have the root bone. The root bone is \" + this._skeleton.getChildren());\n            return false;\n        }\n        return true;\n    }\n    _findNearestParent(boneIndex) {\n        let nearestParent = this._bones[boneIndex].getParent();\n        do {\n            if (nearestParent != null && this._boneNames.includes(nearestParent.name)) {\n                break;\n            }\n            nearestParent = nearestParent?.getParent();\n        } while (nearestParent != null);\n        return nearestParent;\n    }\n    _init() {\n        this._createColliders();\n        // If this.defineRootBone() returns ... there is not root bone.\n        if (!this._defineRootBone()) {\n            return;\n        }\n        this._initJoints();\n        this._scene.registerBeforeRender(() => {\n            this._syncBonesAndBoxes();\n        });\n        this._syncBonesToPhysics();\n    }\n    /**\n     * Enable ragdoll mode. Create physics objects and make them dynamic.\n     */\n    ragdoll() {\n        this._ragdollMode = true;\n        // detach bones with link transform to let physics have control\n        this._skeleton.bones.forEach((bone) => {\n            bone.linkTransformNode(null);\n        });\n        for (let i = 0; i < this._constraints.length; i++) {\n            this._constraints[i].isEnabled = true;\n        }\n        for (let i = 0; i < this._aggregates.length; i++) {\n            this._aggregates[i].body.setMotionType(2 /* PhysicsMotionType.DYNAMIC */);\n        }\n    }\n    /**\n     * Dispose resources and remove physics objects\n     */\n    dispose() {\n        this._aggregates.forEach((aggregate) => {\n            aggregate.dispose();\n        });\n    }\n}\n//# sourceMappingURL=ragdoll.js.map","import { Matrix, Quaternion, TmpVectors, Vector3 } from \"../../../Maths/math.vector.js\";\nimport { PhysicsPrestepType, } from \"../IPhysicsEnginePlugin.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { PhysicsShape } from \"../physicsShape.js\";\nimport { BoundingBox } from \"../../../Culling/boundingBox.js\";\nimport { Mesh } from \"../../../Meshes/mesh.js\";\nimport { InstancedMesh } from \"../../../Meshes/instancedMesh.js\";\nimport { VertexBuffer } from \"../../../Buffers/buffer.js\";\nimport { BuildArray } from \"../../../Misc/arrayTools.js\";\nimport { Observable } from \"../../../Misc/observable.js\";\nclass MeshAccumulator {\n    /**\n     * Constructor of the mesh accumulator\n     * @param mesh - The mesh used to compute the world matrix.\n     * @param collectIndices - use mesh indices\n     * @param scene - The scene used to determine the right handed system.\n     *\n     * Merge mesh and its children so whole hierarchy can be used as a mesh shape or convex hull\n     */\n    constructor(mesh, collectIndices, scene) {\n        this._vertices = []; /// Vertices in body space\n        this._indices = [];\n        this._isRightHanded = scene.useRightHandedSystem;\n        this._collectIndices = collectIndices;\n    }\n    /**\n     * Adds a mesh to the physics engine.\n     * @param mesh The mesh to add.\n     * @param includeChildren Whether to include the children of the mesh.\n     *\n     * This method adds a mesh to the physics engine by computing the world matrix,\n     * multiplying it with the body from world matrix, and then transforming the\n     * coordinates of the mesh's vertices. It also adds the indices of the mesh\n     * to the physics engine. If includeChildren is true, it will also add the\n     * children of the mesh to the physics engine, ignoring any children which\n     * have a physics impostor. This is useful for creating a physics engine\n     * that accurately reflects the mesh and its children.\n     */\n    addNodeMeshes(mesh, includeChildren) {\n        // Force absoluteScaling to be computed; we're going to use that to bake\n        // the scale of any parent nodes into this shape, as physics engines\n        // usually use rigid transforms, so can't handle arbitrary scale.\n        mesh.computeWorldMatrix(true);\n        const rootScaled = TmpVectors.Matrix[0];\n        Matrix.ScalingToRef(mesh.absoluteScaling.x, mesh.absoluteScaling.y, mesh.absoluteScaling.z, rootScaled);\n        if (mesh instanceof Mesh) {\n            this._addMesh(mesh, rootScaled);\n        }\n        else if (mesh instanceof InstancedMesh) {\n            this._addMesh(mesh.sourceMesh, rootScaled);\n        }\n        if (includeChildren) {\n            const worldToRoot = TmpVectors.Matrix[1];\n            mesh.computeWorldMatrix().invertToRef(worldToRoot);\n            const worldToRootScaled = TmpVectors.Matrix[2];\n            worldToRoot.multiplyToRef(rootScaled, worldToRootScaled);\n            const children = mesh.getChildMeshes(false);\n            //  Ignore any children which have a physics body.\n            //  Other plugin implementations do not have this check, which appears to be\n            //  a bug, as otherwise, the mesh will have a duplicate collider\n            children\n                .filter((m) => !m.physicsBody)\n                .forEach((m) => {\n                const childToWorld = m.computeWorldMatrix();\n                const childToRootScaled = TmpVectors.Matrix[3];\n                childToWorld.multiplyToRef(worldToRootScaled, childToRootScaled);\n                if (m instanceof Mesh) {\n                    this._addMesh(m, childToRootScaled);\n                }\n                else if (m instanceof InstancedMesh) {\n                    this._addMesh(m.sourceMesh, childToRootScaled);\n                }\n            });\n        }\n    }\n    _addMesh(mesh, meshToRoot) {\n        const vertexData = mesh.getVerticesData(VertexBuffer.PositionKind) || [];\n        const numVerts = vertexData.length / 3;\n        const indexOffset = this._vertices.length;\n        for (let v = 0; v < numVerts; v++) {\n            const pos = new Vector3(vertexData[v * 3 + 0], vertexData[v * 3 + 1], vertexData[v * 3 + 2]);\n            this._vertices.push(Vector3.TransformCoordinates(pos, meshToRoot));\n        }\n        if (this._collectIndices) {\n            const meshIndices = mesh.getIndices();\n            if (meshIndices) {\n                for (let i = 0; i < meshIndices.length; i += 3) {\n                    // Havok wants the correct triangle winding to enable the interior triangle optimization\n                    if (this._isRightHanded) {\n                        this._indices.push(meshIndices[i + 0] + indexOffset);\n                        this._indices.push(meshIndices[i + 1] + indexOffset);\n                        this._indices.push(meshIndices[i + 2] + indexOffset);\n                    }\n                    else {\n                        this._indices.push(meshIndices[i + 2] + indexOffset);\n                        this._indices.push(meshIndices[i + 1] + indexOffset);\n                        this._indices.push(meshIndices[i + 0] + indexOffset);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Allocate and populate the vertex positions inside the physics plugin.\n     *\n     * @param plugin - The plugin to allocate the memory in.\n     * @returns An array of floats, whose backing memory is inside the plugin. The array contains the\n     * positions of the mesh vertices, where a position is defined by three floats. You must call\n     * freeBuffer() on the returned array once you have finished with it, in order to free the\n     * memory inside the plugin..\n     */\n    getVertices(plugin) {\n        const nFloats = this._vertices.length * 3;\n        const bytesPerFloat = 4;\n        const nBytes = nFloats * bytesPerFloat;\n        const bufferBegin = plugin._malloc(nBytes);\n        const ret = new Float32Array(plugin.HEAPU8.buffer, bufferBegin, nFloats);\n        for (let i = 0; i < this._vertices.length; i++) {\n            ret[i * 3 + 0] = this._vertices[i].x;\n            ret[i * 3 + 1] = this._vertices[i].y;\n            ret[i * 3 + 2] = this._vertices[i].z;\n        }\n        return { offset: bufferBegin, numObjects: nFloats };\n    }\n    freeBuffer(plugin, arr) {\n        plugin._free(arr.offset);\n    }\n    /**\n     * Allocate and populate the triangle indices inside the physics plugin\n     *\n     * @param plugin - The plugin to allocate the memory in.\n     * @returns A new Int32Array, whose backing memory is inside the plugin. The array contains the indices\n     * of the triangle positions, where a single triangle is defined by three indices. You must call\n     * freeBuffer() on this array once you have finished with it, to free the memory inside the plugin..\n     */\n    getTriangles(plugin) {\n        const bytesPerInt = 4;\n        const nBytes = this._indices.length * bytesPerInt;\n        const bufferBegin = plugin._malloc(nBytes);\n        const ret = new Int32Array(plugin.HEAPU8.buffer, bufferBegin, this._indices.length);\n        for (let i = 0; i < this._indices.length; i++) {\n            ret[i] = this._indices[i];\n        }\n        return { offset: bufferBegin, numObjects: this._indices.length };\n    }\n}\nclass BodyPluginData {\n    constructor(bodyId) {\n        this.hpBodyId = bodyId;\n        this.userMassProps = { centerOfMass: undefined, mass: undefined, inertia: undefined, inertiaOrientation: undefined };\n    }\n}\n/*\nclass ShapePath\n{\n    public colliderId: number;\n    public pathData: number;\n}\n*/\nclass CollisionContactPoint {\n    constructor() {\n        this.bodyId = BigInt(0); //0,2\n        //public colliderId: number = 0; //2,4\n        //public shapePath: ShapePath = new ShapePath(); //4,8\n        this.position = new Vector3(); //8,11\n        this.normal = new Vector3(); //11,14\n        //public triIdx: number = 0; //14,15\n    }\n}\nclass CollisionEvent {\n    constructor() {\n        this.contactOnA = new CollisionContactPoint(); //1\n        this.contactOnB = new CollisionContactPoint();\n        this.impulseApplied = 0;\n        this.type = 0;\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static readToRef(buffer, offset, eventOut) {\n        const intBuf = new Int32Array(buffer, offset);\n        const floatBuf = new Float32Array(buffer, offset);\n        const offA = 2;\n        eventOut.contactOnA.bodyId = BigInt(intBuf[offA]); //<todo Need to get the high+low words!\n        eventOut.contactOnA.position.set(floatBuf[offA + 8], floatBuf[offA + 9], floatBuf[offA + 10]);\n        eventOut.contactOnA.normal.set(floatBuf[offA + 11], floatBuf[offA + 12], floatBuf[offA + 13]);\n        const offB = 18;\n        eventOut.contactOnB.bodyId = BigInt(intBuf[offB]);\n        eventOut.contactOnB.position.set(floatBuf[offB + 8], floatBuf[offB + 9], floatBuf[offB + 10]);\n        eventOut.contactOnB.normal.set(floatBuf[offB + 11], floatBuf[offB + 12], floatBuf[offB + 13]);\n        eventOut.impulseApplied = floatBuf[offB + 13 + 3];\n        eventOut.type = intBuf[0];\n    }\n}\nclass TriggerEvent {\n    constructor() {\n        this.bodyIdA = BigInt(0);\n        this.bodyIdB = BigInt(0);\n        this.type = 0;\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static readToRef(buffer, offset, eventOut) {\n        const intBuf = new Int32Array(buffer, offset);\n        eventOut.type = intBuf[0];\n        eventOut.bodyIdA = BigInt(intBuf[2]);\n        eventOut.bodyIdB = BigInt(intBuf[6]);\n    }\n}\n/**\n * The Havok Physics plugin\n */\nexport class HavokPlugin {\n    constructor(_useDeltaForWorldStep = true, hpInjection = HK) {\n        this._useDeltaForWorldStep = _useDeltaForWorldStep;\n        /**\n         * Reference to the WASM library\n         */\n        this._hknp = {};\n        /**\n         * Name of the plugin\n         */\n        this.name = \"HavokPlugin\";\n        this._fixedTimeStep = 1 / 60;\n        this._tmpVec3 = BuildArray(3, Vector3.Zero);\n        this._bodies = new Map();\n        this._shapes = new Map();\n        this._bodyCollisionObservable = new Map();\n        // Map from constraint id to the pair of bodies, where the first is the parent and the second is the child\n        this._constraintToBodyIdPair = new Map();\n        this._bodyCollisionEndedObservable = new Map();\n        /**\n         * Observable for collision started and collision continued events\n         */\n        this.onCollisionObservable = new Observable();\n        /**\n         * Observable for collision ended events\n         */\n        this.onCollisionEndedObservable = new Observable();\n        /**\n         * Observable for trigger entered and trigger exited events\n         */\n        this.onTriggerCollisionObservable = new Observable();\n        if (typeof hpInjection === \"function\") {\n            Logger.Error(\"Havok is not ready. Please make sure you await HK() before using the plugin.\");\n            return;\n        }\n        else {\n            this._hknp = hpInjection;\n        }\n        if (!this.isSupported()) {\n            Logger.Error(\"Havok is not available. Please make sure you included the js file.\");\n            return;\n        }\n        this.world = this._hknp.HP_World_Create()[1];\n        this._queryCollector = this._hknp.HP_QueryCollector_Create(1)[1];\n    }\n    /**\n     * If this plugin is supported\n     * @returns true if its supported\n     */\n    isSupported() {\n        return this._hknp !== undefined;\n    }\n    /**\n     * Sets the gravity of the physics world.\n     *\n     * @param gravity - The gravity vector to set.\n     *\n     */\n    setGravity(gravity) {\n        this._hknp.HP_World_SetGravity(this.world, this._bVecToV3(gravity));\n    }\n    /**\n     * Sets the fixed time step for the physics engine.\n     *\n     * @param timeStep - The fixed time step to use for the physics engine.\n     *\n     */\n    setTimeStep(timeStep) {\n        this._fixedTimeStep = timeStep;\n    }\n    /**\n     * Gets the fixed time step used by the physics engine.\n     *\n     * @returns The fixed time step used by the physics engine.\n     *\n     */\n    getTimeStep() {\n        return this._fixedTimeStep;\n    }\n    /**\n     * Executes a single step of the physics engine.\n     *\n     * @param delta The time delta in seconds since the last step.\n     * @param physicsBodies An array of physics bodies to be simulated.\n     *\n     * This method is useful for simulating the physics engine. It sets the physics body transformation,\n     * steps the world, syncs the physics body, and notifies collisions. This allows for the physics engine\n     * to accurately simulate the physics bodies in the world.\n     */\n    executeStep(delta, physicsBodies) {\n        for (const physicsBody of physicsBodies) {\n            if (physicsBody.disablePreStep) {\n                continue;\n            }\n            this.setPhysicsBodyTransformation(physicsBody, physicsBody.transformNode);\n        }\n        const deltaTime = this._useDeltaForWorldStep ? delta : this._fixedTimeStep;\n        this._hknp.HP_World_SetIdealStepTime(this.world, deltaTime);\n        this._hknp.HP_World_Step(this.world, deltaTime);\n        this._bodyBuffer = this._hknp.HP_World_GetBodyBuffer(this.world)[1];\n        for (const physicsBody of physicsBodies) {\n            if (!physicsBody.disableSync) {\n                this.sync(physicsBody);\n            }\n        }\n        this._notifyCollisions();\n        this._notifyTriggers();\n    }\n    /**\n     * Returns the version of the physics engine plugin.\n     *\n     * @returns The version of the physics engine plugin.\n     *\n     * This method is useful for determining the version of the physics engine plugin that is currently running.\n     */\n    getPluginVersion() {\n        return 2;\n    }\n    /**\n     * Set the maximum allowed linear and angular velocities\n     * @param maxLinearVelocity maximum allowed linear velocity\n     * @param maxAngularVelocity maximum allowed angular velocity\n     */\n    setVelocityLimits(maxLinearVelocity, maxAngularVelocity) {\n        this._hknp.HP_World_SetSpeedLimit(this.world, maxLinearVelocity, maxAngularVelocity);\n    }\n    /**\n     * @returns maximum allowed linear velocity\n     */\n    getMaxLinearVelocity() {\n        const limits = this._hknp.HP_World_GetSpeedLimit(this.world);\n        return limits[1];\n    }\n    /**\n     * @returns maximum allowed angular velocity\n     */\n    getMaxAngularVelocity() {\n        const limits = this._hknp.HP_World_GetSpeedLimit(this.world);\n        return limits[2];\n    }\n    /**\n     * Initializes a physics body with the given position and orientation.\n     *\n     * @param body - The physics body to initialize.\n     * @param motionType - The motion type of the body.\n     * @param position - The position of the body.\n     * @param orientation - The orientation of the body.\n     * This code is useful for initializing a physics body with the given position and orientation.\n     * It creates a plugin data for the body and adds it to the world. It then converts the position\n     * and orientation to a transform and sets the body's transform to the given values.\n     */\n    initBody(body, motionType, position, orientation) {\n        body._pluginData = new BodyPluginData(this._hknp.HP_Body_Create()[1]);\n        this._internalSetMotionType(body._pluginData, motionType);\n        const transform = [this._bVecToV3(position), this._bQuatToV4(orientation)]; //<todo temp transform?\n        this._hknp.HP_Body_SetQTransform(body._pluginData.hpBodyId, transform);\n        this._hknp.HP_World_AddBody(this.world, body._pluginData.hpBodyId, body.startAsleep);\n        this._bodies.set(body._pluginData.hpBodyId[0], { body: body, index: 0 });\n    }\n    /**\n     * Removes a body from the world. To dispose of a body, it is necessary to remove it from the world first.\n     *\n     * @param body - The body to remove.\n     */\n    removeBody(body) {\n        if (body._pluginDataInstances && body._pluginDataInstances.length > 0) {\n            for (const instance of body._pluginDataInstances) {\n                this._bodyCollisionObservable.delete(instance.hpBodyId[0]);\n                this._hknp.HP_World_RemoveBody(this.world, instance.hpBodyId);\n                this._bodies.delete(instance.hpBodyId[0]);\n            }\n        }\n        if (body._pluginData) {\n            this._bodyCollisionObservable.delete(body._pluginData.hpBodyId[0]);\n            this._hknp.HP_World_RemoveBody(this.world, body._pluginData.hpBodyId);\n            this._bodies.delete(body._pluginData.hpBodyId[0]);\n        }\n    }\n    /**\n     * Initializes the body instances for a given physics body and mesh.\n     *\n     * @param body - The physics body to initialize.\n     * @param motionType - How the body will be handled by the engine\n     * @param mesh - The mesh to initialize.\n     *\n     * This code is useful for creating a physics body from a mesh. It creates a\n     * body instance for each instance of the mesh and adds it to the world. It also\n     * sets the position of the body instance to the position of the mesh instance.\n     * This allows for the physics engine to accurately simulate the mesh in the\n     * world.\n     */\n    initBodyInstances(body, motionType, mesh) {\n        const instancesCount = mesh._thinInstanceDataStorage?.instancesCount ?? 0;\n        const matrixData = mesh._thinInstanceDataStorage.matrixData;\n        if (!matrixData) {\n            return; // TODO: error handling\n        }\n        this._createOrUpdateBodyInstances(body, motionType, matrixData, 0, instancesCount, false);\n        body._pluginDataInstances.forEach((bodyId, index) => {\n            this._bodies.set(bodyId.hpBodyId[0], { body: body, index: index });\n        });\n    }\n    _createOrUpdateBodyInstances(body, motionType, matrixData, startIndex, endIndex, update) {\n        const rotation = TmpVectors.Quaternion[0];\n        const rotationMatrix = Matrix.Identity();\n        for (let i = startIndex; i < endIndex; i++) {\n            const position = [matrixData[i * 16 + 12], matrixData[i * 16 + 13], matrixData[i * 16 + 14]];\n            let hkbody;\n            if (!update) {\n                hkbody = this._hknp.HP_Body_Create()[1];\n            }\n            else {\n                hkbody = body._pluginDataInstances[i].hpBodyId;\n            }\n            rotationMatrix.setRowFromFloats(0, matrixData[i * 16 + 0], matrixData[i * 16 + 1], matrixData[i * 16 + 2], 0);\n            rotationMatrix.setRowFromFloats(1, matrixData[i * 16 + 4], matrixData[i * 16 + 5], matrixData[i * 16 + 6], 0);\n            rotationMatrix.setRowFromFloats(2, matrixData[i * 16 + 8], matrixData[i * 16 + 9], matrixData[i * 16 + 10], 0);\n            Quaternion.FromRotationMatrixToRef(rotationMatrix, rotation);\n            const transform = [position, [rotation.x, rotation.y, rotation.z, rotation.w]];\n            this._hknp.HP_Body_SetQTransform(hkbody, transform);\n            if (!update) {\n                const pluginData = new BodyPluginData(hkbody);\n                if (body._pluginDataInstances.length) {\n                    // If an instance already exists, copy any user-provided mass properties\n                    pluginData.userMassProps = body._pluginDataInstances[0].userMassProps;\n                }\n                this._internalSetMotionType(pluginData, motionType);\n                this._internalUpdateMassProperties(pluginData);\n                body._pluginDataInstances.push(pluginData);\n                this._hknp.HP_World_AddBody(this.world, hkbody, body.startAsleep);\n                pluginData.worldTransformOffset = this._hknp.HP_Body_GetWorldTransformOffset(hkbody)[1];\n            }\n        }\n    }\n    /**\n     * Update the internal body instances for a given physics body to match the instances in a mesh.\n     * @param body the body that will be updated\n     * @param mesh the mesh with reference instances\n     */\n    updateBodyInstances(body, mesh) {\n        const instancesCount = mesh._thinInstanceDataStorage?.instancesCount ?? 0;\n        const matrixData = mesh._thinInstanceDataStorage.matrixData;\n        if (!matrixData) {\n            return; // TODO: error handling\n        }\n        const pluginInstancesCount = body._pluginDataInstances.length;\n        const motionType = this.getMotionType(body);\n        if (instancesCount > pluginInstancesCount) {\n            this._createOrUpdateBodyInstances(body, motionType, matrixData, pluginInstancesCount, instancesCount, false);\n            const firstBodyShape = this._hknp.HP_Body_GetShape(body._pluginDataInstances[0].hpBodyId)[1];\n            // firstBodyShape[0] might be 0 in the case where thin instances data is set (with thinInstancesSetBuffer call) after body creation\n            // in that case, use the shape provided at body creation.\n            if (!firstBodyShape[0]) {\n                firstBodyShape[0] = body.shape?._pluginData[0];\n            }\n            for (let i = pluginInstancesCount; i < instancesCount; i++) {\n                this._hknp.HP_Body_SetShape(body._pluginDataInstances[i].hpBodyId, firstBodyShape);\n                this._internalUpdateMassProperties(body._pluginDataInstances[i]);\n                this._bodies.set(body._pluginDataInstances[i].hpBodyId[0], { body: body, index: i });\n            }\n        }\n        else if (instancesCount < pluginInstancesCount) {\n            const instancesToRemove = pluginInstancesCount - instancesCount;\n            for (let i = 0; i < instancesToRemove; i++) {\n                const hkbody = body._pluginDataInstances.pop();\n                this._bodies.delete(hkbody.hpBodyId[0]);\n                this._hknp.HP_World_RemoveBody(this.world, hkbody.hpBodyId);\n                this._hknp.HP_Body_Release(hkbody.hpBodyId);\n            }\n            this._createOrUpdateBodyInstances(body, motionType, matrixData, 0, instancesCount, true);\n        }\n    }\n    /**\n     * Synchronizes the transform of a physics body with its transform node.\n     * @param body - The physics body to synchronize.\n     *\n     * This function is useful for keeping the physics body's transform in sync with its transform node.\n     * This is important for ensuring that the physics body is accurately represented in the physics engine.\n     */\n    sync(body) {\n        this.syncTransform(body, body.transformNode);\n    }\n    /**\n     * Synchronizes the transform of a physics body with the transform of its\n     * corresponding transform node.\n     *\n     * @param body - The physics body to synchronize.\n     * @param transformNode - The destination Transform Node.\n     *\n     * This code is useful for synchronizing the position and orientation of a\n     * physics body with the position and orientation of its corresponding\n     * transform node. This is important for ensuring that the physics body and\n     * the transform node are in the same position and orientation in the scene.\n     * This is necessary for the physics engine to accurately simulate the\n     * physical behavior of the body.\n     */\n    syncTransform(body, transformNode) {\n        if (body._pluginDataInstances.length) {\n            // instances\n            const m = transformNode;\n            const matrixData = m._thinInstanceDataStorage.matrixData;\n            if (!matrixData) {\n                return; // TODO: error handling\n            }\n            const instancesCount = body._pluginDataInstances.length;\n            for (let i = 0; i < instancesCount; i++) {\n                const bufOffset = body._pluginDataInstances[i].worldTransformOffset;\n                const transformBuffer = new Float32Array(this._hknp.HEAPU8.buffer, this._bodyBuffer + bufOffset, 16);\n                const index = i * 16;\n                for (let mi = 0; mi < 15; mi++) {\n                    if ((mi & 3) != 3) {\n                        matrixData[index + mi] = transformBuffer[mi];\n                    }\n                }\n                matrixData[index + 15] = 1;\n            }\n            m.thinInstanceBufferUpdated(\"matrix\");\n        }\n        else {\n            try {\n                // regular\n                const bodyTransform = this._hknp.HP_Body_GetQTransform(body._pluginData.hpBodyId)[1];\n                const bodyTranslation = bodyTransform[0];\n                const bodyOrientation = bodyTransform[1];\n                const quat = TmpVectors.Quaternion[0];\n                quat.set(bodyOrientation[0], bodyOrientation[1], bodyOrientation[2], bodyOrientation[3]);\n                const parent = transformNode.parent;\n                // transform position/orientation in parent space\n                if (parent && !parent.getWorldMatrix().isIdentity()) {\n                    parent.computeWorldMatrix(true);\n                    // Save scaling for future use\n                    TmpVectors.Vector3[1].copyFrom(transformNode.scaling);\n                    quat.normalize();\n                    const finalTransform = TmpVectors.Matrix[0];\n                    const finalTranslation = TmpVectors.Vector3[0];\n                    finalTranslation.copyFromFloats(bodyTranslation[0], bodyTranslation[1], bodyTranslation[2]);\n                    Matrix.ComposeToRef(transformNode.absoluteScaling, quat, finalTranslation, finalTransform);\n                    const parentInverseTransform = TmpVectors.Matrix[1];\n                    parent.getWorldMatrix().invertToRef(parentInverseTransform);\n                    const localTransform = TmpVectors.Matrix[2];\n                    finalTransform.multiplyToRef(parentInverseTransform, localTransform);\n                    localTransform.decomposeToTransformNode(transformNode);\n                    transformNode.rotationQuaternion?.normalize();\n                    // Keep original scaling. Re-injecting scaling can introduce discontinuity between frames. Basically, it grows or shrinks.\n                    transformNode.scaling.copyFrom(TmpVectors.Vector3[1]);\n                }\n                else {\n                    transformNode.position.set(bodyTranslation[0], bodyTranslation[1], bodyTranslation[2]);\n                    if (transformNode.rotationQuaternion) {\n                        transformNode.rotationQuaternion.copyFrom(quat);\n                    }\n                    else {\n                        quat.toEulerAnglesToRef(transformNode.rotation);\n                    }\n                }\n            }\n            catch (e) {\n                Logger.Error(`Syncing transform failed for node ${transformNode.name}: ${e.message}...`);\n            }\n        }\n    }\n    /**\n     * Sets the shape of a physics body.\n     * @param body - The physics body to set the shape for.\n     * @param shape - The physics shape to set.\n     *\n     * This function is used to set the shape of a physics body. It is useful for\n     * creating a physics body with a specific shape, such as a box or a sphere,\n     * which can then be used to simulate physical interactions in a physics engine.\n     * This function is especially useful for meshes with multiple instances, as it\n     * will set the shape for each instance of the mesh.\n     */\n    setShape(body, shape) {\n        const shapeHandle = shape && shape._pluginData ? shape._pluginData : BigInt(0);\n        if (!(body.transformNode instanceof Mesh) || !body.transformNode._thinInstanceDataStorage?.matrixData) {\n            this._hknp.HP_Body_SetShape(body._pluginData.hpBodyId, shapeHandle);\n            this._internalUpdateMassProperties(body._pluginData);\n            return;\n        }\n        const m = body.transformNode;\n        const instancesCount = m._thinInstanceDataStorage?.instancesCount ?? 0;\n        for (let i = 0; i < instancesCount; i++) {\n            this._hknp.HP_Body_SetShape(body._pluginDataInstances[i].hpBodyId, shapeHandle);\n            this._internalUpdateMassProperties(body._pluginDataInstances[i]);\n        }\n    }\n    /**\n     * Returns a reference to the first instance of the plugin data for a physics body.\n     * @param body\n     * @param instanceIndex\n     * @returns a reference to the first instance\n     */\n    _getPluginReference(body, instanceIndex) {\n        return body._pluginDataInstances?.length ? body._pluginDataInstances[instanceIndex ?? 0] : body._pluginData;\n    }\n    /**\n     * Gets the shape of a physics body. This will create a new shape object\n     *\n     * @param body - The physics body.\n     * @returns The shape of the physics body.\n     *\n     */\n    getShape(body) {\n        const pluginRef = this._getPluginReference(body);\n        const shapePluginData = this._hknp.HP_Body_GetShape(pluginRef.hpBodyId)[1];\n        if (shapePluginData != 0) {\n            const scene = body.transformNode.getScene();\n            return new PhysicsShape({ pluginData: shapePluginData }, scene);\n        }\n        return null;\n    }\n    /**\n     * Gets the type of a physics shape.\n     * @param shape - The physics shape to get the type for.\n     * @returns The type of the physics shape.\n     *\n     */\n    getShapeType(shape) {\n        if (shape.type) {\n            return shape.type;\n        }\n        else {\n            //<todo This returns a native type!\n            return this._hknp.HP_Shape_GetType(shape._pluginData);\n        }\n    }\n    /**\n     * Sets the event mask of a physics body.\n     * @param body - The physics body to set the event mask for.\n     * @param eventMask - The event mask to set.\n     * @param instanceIndex - The index of the instance to set the event mask for\n     *\n     * This function is useful for setting the event mask of a physics body, which is used to determine which events the body will respond to. This is important for ensuring that the physics engine is able to accurately simulate the behavior of the body in the game world.\n     */\n    setEventMask(body, eventMask, instanceIndex) {\n        this._applyToBodyOrInstances(body, (bodyPluginData) => {\n            this._hknp.HP_Body_SetEventMask(bodyPluginData.hpBodyId, eventMask);\n        }, instanceIndex);\n    }\n    /**\n     * Retrieves the event mask of a physics body.\n     *\n     * @param body - The physics body to retrieve the event mask from.\n     * @param instanceIndex - The index of the instance to retrieve the event mask from.\n     * @returns The event mask of the physics body.\n     *\n     */\n    getEventMask(body, instanceIndex) {\n        const pluginRef = this._getPluginReference(body, instanceIndex);\n        return this._hknp.HP_Body_GetEventMask(pluginRef.hpBodyId)[1];\n    }\n    _fromMassPropertiesTuple(massPropsTuple) {\n        return {\n            centerOfMass: Vector3.FromArray(massPropsTuple[0]),\n            mass: massPropsTuple[1],\n            inertia: Vector3.FromArray(massPropsTuple[2]),\n            inertiaOrientation: Quaternion.FromArray(massPropsTuple[3]),\n        };\n    }\n    _internalUpdateMassProperties(pluginData) {\n        // Recompute the mass based on the shape\n        const newProps = this._internalComputeMassProperties(pluginData);\n        const massProps = pluginData.userMassProps;\n        // Override the computed values with any the user has set\n        if (massProps.centerOfMass) {\n            newProps[0] = massProps.centerOfMass.asArray();\n        }\n        if (massProps.mass != undefined) {\n            newProps[1] = massProps.mass;\n        }\n        if (massProps.inertia) {\n            newProps[2] = massProps.inertia.asArray();\n        }\n        if (massProps.inertiaOrientation) {\n            newProps[3] = massProps.inertiaOrientation.asArray();\n        }\n        this._hknp.HP_Body_SetMassProperties(pluginData.hpBodyId, newProps);\n    }\n    _internalSetMotionType(pluginData, motionType) {\n        switch (motionType) {\n            case 0 /* PhysicsMotionType.STATIC */:\n                this._hknp.HP_Body_SetMotionType(pluginData.hpBodyId, this._hknp.MotionType.STATIC);\n                break;\n            case 1 /* PhysicsMotionType.ANIMATED */:\n                this._hknp.HP_Body_SetMotionType(pluginData.hpBodyId, this._hknp.MotionType.KINEMATIC);\n                break;\n            case 2 /* PhysicsMotionType.DYNAMIC */:\n                this._hknp.HP_Body_SetMotionType(pluginData.hpBodyId, this._hknp.MotionType.DYNAMIC);\n                break;\n        }\n    }\n    /**\n     * sets the motion type of a physics body.\n     * @param body - The physics body to set the motion type for.\n     * @param motionType - The motion type to set.\n     * @param instanceIndex - The index of the instance to set the motion type for. If undefined, the motion type of all the bodies will be set.\n     */\n    setMotionType(body, motionType, instanceIndex) {\n        this._applyToBodyOrInstances(body, (pluginData) => {\n            this._internalSetMotionType(pluginData, motionType);\n        }, instanceIndex);\n    }\n    /**\n     * Gets the motion type of a physics body.\n     * @param body - The physics body to get the motion type from.\n     * @param instanceIndex - The index of the instance to get the motion type from. If not specified, the motion type of the first instance will be returned.\n     * @returns The motion type of the physics body.\n     */\n    getMotionType(body, instanceIndex) {\n        const pluginRef = this._getPluginReference(body, instanceIndex);\n        const type = this._hknp.HP_Body_GetMotionType(pluginRef.hpBodyId)[1];\n        switch (type) {\n            case this._hknp.MotionType.STATIC:\n                return 0 /* PhysicsMotionType.STATIC */;\n            case this._hknp.MotionType.KINEMATIC:\n                return 1 /* PhysicsMotionType.ANIMATED */;\n            case this._hknp.MotionType.DYNAMIC:\n                return 2 /* PhysicsMotionType.DYNAMIC */;\n        }\n        throw new Error(\"Unknown motion type: \" + type);\n    }\n    /**\n     * sets the activation control mode of a physics body, for instance if you need the body to never sleep.\n     * @param body - The physics body to set the activation control mode.\n     * @param controlMode - The activation control mode.\n     */\n    setActivationControl(body, controlMode) {\n        switch (controlMode) {\n            case 1 /* PhysicsActivationControl.ALWAYS_ACTIVE */:\n                this._hknp.HP_Body_SetActivationControl(body._pluginData.hpBodyId, this._hknp.ActivationControl.ALWAYS_ACTIVE);\n                break;\n            case 2 /* PhysicsActivationControl.ALWAYS_INACTIVE */:\n                this._hknp.HP_Body_SetActivationControl(body._pluginData.hpBodyId, this._hknp.ActivationControl.ALWAYS_INACTIVE);\n                break;\n            case 0 /* PhysicsActivationControl.SIMULATION_CONTROLLED */:\n                this._hknp.HP_Body_SetActivationControl(body._pluginData.hpBodyId, this._hknp.ActivationControl.SIMULATION_CONTROLLED);\n                break;\n        }\n    }\n    _internalComputeMassProperties(pluginData) {\n        const shapeRes = this._hknp.HP_Body_GetShape(pluginData.hpBodyId);\n        if (shapeRes[0] == this._hknp.Result.RESULT_OK) {\n            const shapeMass = this._hknp.HP_Shape_BuildMassProperties(shapeRes[1]);\n            if (shapeMass[0] == this._hknp.Result.RESULT_OK) {\n                return shapeMass[1];\n            }\n        }\n        // Failed; return a unit inertia\n        return [[0, 0, 0], 1, [1, 1, 1], [0, 0, 0, 1]];\n    }\n    /**\n     * Computes the mass properties of a physics body, from it's shape\n     *\n     * @param body - The physics body to copmute the mass properties of\n     * @param instanceIndex - The index of the instance to compute the mass properties of.\n     * @returns The mass properties of the physics body.\n     */\n    computeMassProperties(body, instanceIndex) {\n        const pluginRef = this._getPluginReference(body, instanceIndex);\n        const computed = this._internalComputeMassProperties(pluginRef);\n        return this._fromMassPropertiesTuple(computed);\n    }\n    /**\n     * Sets the mass properties of a physics body.\n     *\n     * @param body - The physics body to set the mass properties of.\n     * @param massProps - The mass properties to set.\n     * @param instanceIndex - The index of the instance to set the mass properties of. If undefined, the mass properties of all the bodies will be set.\n     * This function is useful for setting the mass properties of a physics body,\n     * such as its mass, inertia, and center of mass. This is important for\n     * accurately simulating the physics of the body in the physics engine.\n     *\n     */\n    setMassProperties(body, massProps, instanceIndex) {\n        this._applyToBodyOrInstances(body, (pluginData) => {\n            pluginData.userMassProps = massProps;\n            this._internalUpdateMassProperties(pluginData);\n        }, instanceIndex);\n    }\n    /**\n     * Gets the mass properties of a physics body.\n     * @param body - The physics body to get the mass properties from.\n     * @param instanceIndex - The index of the instance to get the mass properties from. If not specified, the mass properties of the first instance will be returned.\n     * @returns The mass properties of the physics body.\n     */\n    getMassProperties(body, instanceIndex) {\n        const pluginRef = this._getPluginReference(body, instanceIndex);\n        const massPropsTuple = this._hknp.HP_Body_GetMassProperties(pluginRef.hpBodyId)[1];\n        return this._fromMassPropertiesTuple(massPropsTuple);\n    }\n    /**\n     * Sets the linear damping of the given body.\n     * @param body - The body to set the linear damping for.\n     * @param damping - The linear damping to set.\n     * @param instanceIndex - The index of the instance to set the linear damping for. If not specified, the linear damping of the first instance will be set.\n     *\n     * This method is useful for controlling the linear damping of a body in a physics engine.\n     * Linear damping is a force that opposes the motion of the body, and is proportional to the velocity of the body.\n     * This method allows the user to set the linear damping of a body, which can be used to control the motion of the body.\n     */\n    setLinearDamping(body, damping, instanceIndex) {\n        this._applyToBodyOrInstances(body, (pluginData) => {\n            this._hknp.HP_Body_SetLinearDamping(pluginData.hpBodyId, damping);\n        }, instanceIndex);\n    }\n    /**\n     * Gets the linear damping of the given body.\n     * @param body - The body to get the linear damping from.\n     * @param instanceIndex - The index of the instance to get the linear damping from. If not specified, the linear damping of the first instance will be returned.\n     * @returns The linear damping of the given body.\n     *\n     * This method is useful for getting the linear damping of a body in a physics engine.\n     * Linear damping is a force that opposes the motion of the body and is proportional to the velocity of the body.\n     * It is used to simulate the effects of air resistance and other forms of friction.\n     */\n    getLinearDamping(body, instanceIndex) {\n        const pluginRef = this._getPluginReference(body, instanceIndex);\n        return this._hknp.HP_Body_GetLinearDamping(pluginRef.hpBodyId)[1];\n    }\n    /**\n     * Sets the angular damping of a physics body.\n     * @param body - The physics body to set the angular damping for.\n     * @param damping - The angular damping value to set.\n     * @param instanceIndex - The index of the instance to set the angular damping for. If not specified, the angular damping of the first instance will be set.\n     *\n     * This function is useful for controlling the angular velocity of a physics body.\n     * By setting the angular damping, the body's angular velocity will be reduced over time, allowing for more realistic physics simulations.\n     */\n    setAngularDamping(body, damping, instanceIndex) {\n        this._applyToBodyOrInstances(body, (pluginData) => {\n            this._hknp.HP_Body_SetAngularDamping(pluginData.hpBodyId, damping);\n        }, instanceIndex);\n    }\n    /**\n     * Gets the angular damping of a physics body.\n     * @param body - The physics body to get the angular damping from.\n     * @param instanceIndex - The index of the instance to get the angular damping from. If not specified, the angular damping of the first instance will be returned.\n     * @returns The angular damping of the body.\n     *\n     * This function is useful for retrieving the angular damping of a physics body,\n     * which is used to control the rotational motion of the body. The angular damping is a value between 0 and 1, where 0 is no damping and 1 is full damping.\n     */\n    getAngularDamping(body, instanceIndex) {\n        const pluginRef = this._getPluginReference(body, instanceIndex);\n        return this._hknp.HP_Body_GetAngularDamping(pluginRef.hpBodyId)[1];\n    }\n    /**\n     * Sets the linear velocity of a physics body.\n     * @param body - The physics body to set the linear velocity of.\n     * @param linVel - The linear velocity to set.\n     * @param instanceIndex - The index of the instance to set the linear velocity of. If not specified, the linear velocity of the first instance will be set.\n     *\n     * This function is useful for setting the linear velocity of a physics body, which is necessary for simulating\n     * motion in a physics engine. The linear velocity is the speed and direction of the body's movement.\n     */\n    setLinearVelocity(body, linVel, instanceIndex) {\n        this._applyToBodyOrInstances(body, (pluginData) => {\n            this._hknp.HP_Body_SetLinearVelocity(pluginData.hpBodyId, this._bVecToV3(linVel));\n        }, instanceIndex);\n    }\n    /**\n     * Gets the linear velocity of a physics body and stores it in a given vector.\n     * @param body - The physics body to get the linear velocity from.\n     * @param linVel - The vector to store the linear velocity in.\n     * @param instanceIndex - The index of the instance to get the linear velocity from. If not specified, the linear velocity of the first instance will be returned.\n     *\n     * This function is useful for retrieving the linear velocity of a physics body,\n     * which can be used to determine the speed and direction of the body. This\n     * information can be used to simulate realistic physics behavior in a game.\n     */\n    getLinearVelocityToRef(body, linVel, instanceIndex) {\n        const pluginRef = this._getPluginReference(body, instanceIndex);\n        const lv = this._hknp.HP_Body_GetLinearVelocity(pluginRef.hpBodyId)[1];\n        this._v3ToBvecRef(lv, linVel);\n    }\n    /*\n     * Apply an operation either to all instances of a body, if instanceIndex is not specified, or to a specific instance.\n     */\n    _applyToBodyOrInstances(body, fnToApply, instanceIndex) {\n        if (body._pluginDataInstances?.length > 0 && instanceIndex === undefined) {\n            for (let i = 0; i < body._pluginDataInstances.length; i++) {\n                fnToApply(body._pluginDataInstances[i]);\n            }\n        }\n        else {\n            fnToApply(this._getPluginReference(body, instanceIndex));\n        }\n    }\n    /**\n     * Applies an impulse to a physics body at a given location.\n     * @param body - The physics body to apply the impulse to.\n     * @param impulse - The impulse vector to apply.\n     * @param location - The location in world space to apply the impulse.\n     * @param instanceIndex - The index of the instance to apply the impulse to. If not specified, the impulse will be applied to all instances.\n     *\n     * This method is useful for applying an impulse to a physics body at a given location.\n     * This can be used to simulate physical forces such as explosions, collisions, and gravity.\n     */\n    applyImpulse(body, impulse, location, instanceIndex) {\n        this._applyToBodyOrInstances(body, (pluginRef) => {\n            this._hknp.HP_Body_ApplyImpulse(pluginRef.hpBodyId, this._bVecToV3(location), this._bVecToV3(impulse));\n        }, instanceIndex);\n    }\n    /**\n     * Applies an angular impulse(torque) to a physics body\n     * @param body - The physics body to apply the impulse to.\n     * @param angularImpulse - The torque value\n     * @param instanceIndex - The index of the instance to apply the impulse to. If not specified, the impulse will be applied to all instances.\n     */\n    applyAngularImpulse(body, angularImpulse, instanceIndex) {\n        this._applyToBodyOrInstances(body, (pluginRef) => {\n            this._hknp.HP_Body_ApplyAngularImpulse(pluginRef.hpBodyId, this._bVecToV3(angularImpulse));\n        }, instanceIndex);\n    }\n    /**\n     * Applies a force to a physics body at a given location.\n     * @param body - The physics body to apply the impulse to.\n     * @param force - The force vector to apply.\n     * @param location - The location in world space to apply the impulse.\n     * @param instanceIndex - The index of the instance to apply the force to. If not specified, the force will be applied to all instances.\n     *\n     * This method is useful for applying a force to a physics body at a given location.\n     * This can be used to simulate physical forces such as explosions, collisions, and gravity.\n     */\n    applyForce(body, force, location, instanceIndex) {\n        force.scaleToRef(this.getTimeStep(), this._tmpVec3[0]);\n        this.applyImpulse(body, this._tmpVec3[0], location, instanceIndex);\n    }\n    /**\n     * Sets the angular velocity of a physics body.\n     *\n     * @param body - The physics body to set the angular velocity of.\n     * @param angVel - The angular velocity to set.\n     * @param instanceIndex - The index of the instance to set the angular velocity of. If not specified, the angular velocity of the first instance will be set.\n     *\n     * This function is useful for setting the angular velocity of a physics body in a physics engine.\n     * This allows for more realistic simulations of physical objects, as they can be given a rotational velocity.\n     */\n    setAngularVelocity(body, angVel, instanceIndex) {\n        this._applyToBodyOrInstances(body, (pluginRef) => {\n            this._hknp.HP_Body_SetAngularVelocity(pluginRef.hpBodyId, this._bVecToV3(angVel));\n        }, instanceIndex);\n    }\n    /**\n     * Gets the angular velocity of a body.\n     * @param body - The body to get the angular velocity from.\n     * @param angVel - The vector3 to store the angular velocity.\n     * @param instanceIndex - The index of the instance to get the angular velocity from. If not specified, the angular velocity of the first instance will be returned.\n     *\n     * This method is useful for getting the angular velocity of a body in a physics engine. It\n     * takes the body and a vector3 as parameters and stores the angular velocity of the body\n     * in the vector3. This is useful for getting the angular velocity of a body in order to\n     * calculate the motion of the body in the physics engine.\n     */\n    getAngularVelocityToRef(body, angVel, instanceIndex) {\n        const pluginRef = this._getPluginReference(body, instanceIndex);\n        const av = this._hknp.HP_Body_GetAngularVelocity(pluginRef.hpBodyId)[1];\n        this._v3ToBvecRef(av, angVel);\n    }\n    /**\n     * Sets the transformation of the given physics body to the given transform node.\n     * @param body The physics body to set the transformation for.\n     * @param node The transform node to set the transformation from.\n     * Sets the transformation of the given physics body to the given transform node.\n     *\n     * This function is useful for setting the transformation of a physics body to a\n     * transform node, which is necessary for the physics engine to accurately simulate\n     * the motion of the body. It also takes into account instances of the transform\n     * node, which is necessary for accurate simulation of multiple bodies with the\n     * same transformation.\n     */\n    setPhysicsBodyTransformation(body, node) {\n        if (body.getPrestepType() == PhysicsPrestepType.TELEPORT) {\n            const transformNode = body.transformNode;\n            if (body.numInstances > 0) {\n                // instances\n                const m = transformNode;\n                const matrixData = m._thinInstanceDataStorage.matrixData;\n                if (!matrixData) {\n                    return; // TODO: error handling\n                }\n                const instancesCount = body.numInstances;\n                this._createOrUpdateBodyInstances(body, body.getMotionType(), matrixData, 0, instancesCount, true);\n            }\n            else {\n                // regular\n                this._hknp.HP_Body_SetQTransform(body._pluginData.hpBodyId, this._getTransformInfos(node));\n            }\n        }\n        else if (body.getPrestepType() == PhysicsPrestepType.ACTION) {\n            this.setTargetTransform(body, node.absolutePosition, node.absoluteRotationQuaternion);\n        }\n        else if (body.getPrestepType() == PhysicsPrestepType.DISABLED) {\n            Logger.Warn(\"Prestep type is set to DISABLED. Unable to set physics body transformation.\");\n        }\n        else {\n            Logger.Warn(\"Invalid prestep type set to physics body.\");\n        }\n    }\n    /**\n     * Set the target transformation (position and rotation) of the body, such that the body will set its velocity to reach that target\n     * @param body The physics body to set the target transformation for.\n     * @param position The target position\n     * @param rotation The target rotation\n     * @param instanceIndex The index of the instance in an instanced body\n     */\n    setTargetTransform(body, position, rotation, instanceIndex) {\n        this._applyToBodyOrInstances(body, (pluginRef) => {\n            this._hknp.HP_Body_SetTargetQTransform(pluginRef.hpBodyId, [this._bVecToV3(position), this._bQuatToV4(rotation)]);\n        }, instanceIndex);\n    }\n    /**\n     * Sets the gravity factor of a body\n     * @param body the physics body to set the gravity factor for\n     * @param factor the gravity factor\n     * @param instanceIndex the index of the instance in an instanced body\n     */\n    setGravityFactor(body, factor, instanceIndex) {\n        this._applyToBodyOrInstances(body, (pluginRef) => {\n            this._hknp.HP_Body_SetGravityFactor(pluginRef.hpBodyId, factor);\n        }, instanceIndex);\n    }\n    /**\n     * Get the gravity factor of a body\n     * @param body the physics body to get the gravity factor from\n     * @param instanceIndex the index of the instance in an instanced body. If not specified, the gravity factor of the first instance will be returned.\n     * @returns the gravity factor\n     */\n    getGravityFactor(body, instanceIndex) {\n        const pluginRef = this._getPluginReference(body, instanceIndex);\n        return this._hknp.HP_Body_GetGravityFactor(pluginRef.hpBodyId)[1];\n    }\n    /**\n     * Disposes a physics body.\n     *\n     * @param body - The physics body to dispose.\n     *\n     * This method is useful for releasing the resources associated with a physics body when it is no longer needed.\n     * This is important for avoiding memory leaks in the physics engine.\n     */\n    disposeBody(body) {\n        if (body._pluginDataInstances && body._pluginDataInstances.length > 0) {\n            for (const instance of body._pluginDataInstances) {\n                this._hknp.HP_Body_Release(instance.hpBodyId);\n                instance.hpBodyId = undefined;\n            }\n        }\n        if (body._pluginData) {\n            this._hknp.HP_Body_Release(body._pluginData.hpBodyId);\n            body._pluginData.hpBodyId = undefined;\n        }\n    }\n    _createOptionsFromGroundMesh(options) {\n        const mesh = options.groundMesh;\n        if (!mesh) {\n            return;\n        }\n        let pos = mesh.getVerticesData(VertexBuffer.PositionKind);\n        const transform = mesh.computeWorldMatrix(true);\n        // convert rawVerts to object space\n        const transformedVertices = [];\n        let index;\n        for (index = 0; index < pos.length; index += 3) {\n            Vector3.FromArrayToRef(pos, index, TmpVectors.Vector3[0]);\n            Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[0], transform, TmpVectors.Vector3[1]);\n            TmpVectors.Vector3[1].toArray(transformedVertices, index);\n        }\n        pos = transformedVertices;\n        const arraySize = ~~(Math.sqrt(pos.length / 3) - 1);\n        const boundingInfo = mesh.getBoundingInfo();\n        const dim = Math.min(boundingInfo.boundingBox.extendSizeWorld.x, boundingInfo.boundingBox.extendSizeWorld.z);\n        const minX = boundingInfo.boundingBox.minimumWorld.x;\n        const minY = boundingInfo.boundingBox.minimumWorld.y;\n        const minZ = boundingInfo.boundingBox.minimumWorld.z;\n        const matrix = new Float32Array((arraySize + 1) * (arraySize + 1));\n        const elementSize = (dim * 2) / arraySize;\n        for (let i = 0; i < matrix.length; i++) {\n            matrix[i] = minY;\n        }\n        for (let i = 0; i < pos.length; i = i + 3) {\n            const x = Math.round((pos[i + 0] - minX) / elementSize);\n            const z = arraySize - Math.round((pos[i + 2] - minZ) / elementSize);\n            const y = pos[i + 1] - minY;\n            matrix[z * (arraySize + 1) + x] = y;\n        }\n        options.numHeightFieldSamplesX = arraySize + 1;\n        options.numHeightFieldSamplesZ = arraySize + 1;\n        options.heightFieldSizeX = boundingInfo.boundingBox.extendSizeWorld.x * 2;\n        options.heightFieldSizeZ = boundingInfo.boundingBox.extendSizeWorld.z * 2;\n        options.heightFieldData = matrix;\n    }\n    /**\n     * Initializes a physics shape with the given type and parameters.\n     * @param shape - The physics shape to initialize.\n     * @param type - The type of shape to initialize.\n     * @param options - The parameters for the shape.\n     *\n     * This code is useful for initializing a physics shape with the given type and parameters.\n     * It allows for the creation of a sphere, box, capsule, container, cylinder, mesh, and heightfield.\n     * Depending on the type of shape, different parameters are required.\n     * For example, a sphere requires a radius, while a box requires extents and a rotation.\n     */\n    initShape(shape, type, options) {\n        switch (type) {\n            case 0 /* PhysicsShapeType.SPHERE */:\n                {\n                    const radius = options.radius || 1;\n                    const center = options.center ? this._bVecToV3(options.center) : [0, 0, 0];\n                    shape._pluginData = this._hknp.HP_Shape_CreateSphere(center, radius)[1];\n                }\n                break;\n            case 3 /* PhysicsShapeType.BOX */:\n                {\n                    const rotation = options.rotation ? this._bQuatToV4(options.rotation) : [0, 0, 0, 1];\n                    const extent = options.extents ? this._bVecToV3(options.extents) : [1, 1, 1];\n                    const center = options.center ? this._bVecToV3(options.center) : [0, 0, 0];\n                    shape._pluginData = this._hknp.HP_Shape_CreateBox(center, rotation, extent)[1];\n                }\n                break;\n            case 1 /* PhysicsShapeType.CAPSULE */:\n                {\n                    const pointA = options.pointA ? this._bVecToV3(options.pointA) : [0, 0, 0];\n                    const pointB = options.pointB ? this._bVecToV3(options.pointB) : [0, 1, 0];\n                    const radius = options.radius || 0;\n                    shape._pluginData = this._hknp.HP_Shape_CreateCapsule(pointA, pointB, radius)[1];\n                }\n                break;\n            case 5 /* PhysicsShapeType.CONTAINER */:\n                {\n                    shape._pluginData = this._hknp.HP_Shape_CreateContainer()[1];\n                }\n                break;\n            case 2 /* PhysicsShapeType.CYLINDER */:\n                {\n                    const pointA = options.pointA ? this._bVecToV3(options.pointA) : [0, 0, 0];\n                    const pointB = options.pointB ? this._bVecToV3(options.pointB) : [0, 1, 0];\n                    const radius = options.radius || 0;\n                    shape._pluginData = this._hknp.HP_Shape_CreateCylinder(pointA, pointB, radius)[1];\n                }\n                break;\n            case 4 /* PhysicsShapeType.CONVEX_HULL */:\n            case 6 /* PhysicsShapeType.MESH */:\n                {\n                    const mesh = options.mesh;\n                    if (mesh) {\n                        const includeChildMeshes = !!options.includeChildMeshes;\n                        const needIndices = type != 4 /* PhysicsShapeType.CONVEX_HULL */;\n                        const accum = new MeshAccumulator(mesh, needIndices, mesh?.getScene());\n                        accum.addNodeMeshes(mesh, includeChildMeshes);\n                        const positions = accum.getVertices(this._hknp);\n                        const numVec3s = positions.numObjects / 3;\n                        if (type == 4 /* PhysicsShapeType.CONVEX_HULL */) {\n                            shape._pluginData = this._hknp.HP_Shape_CreateConvexHull(positions.offset, numVec3s)[1];\n                        }\n                        else {\n                            const triangles = accum.getTriangles(this._hknp);\n                            const numTriangles = triangles.numObjects / 3;\n                            shape._pluginData = this._hknp.HP_Shape_CreateMesh(positions.offset, numVec3s, triangles.offset, numTriangles)[1];\n                            accum.freeBuffer(this._hknp, triangles);\n                        }\n                        accum.freeBuffer(this._hknp, positions);\n                    }\n                    else {\n                        throw new Error(\"No mesh provided to create physics shape.\");\n                    }\n                }\n                break;\n            case 7 /* PhysicsShapeType.HEIGHTFIELD */:\n                {\n                    if (options.groundMesh) {\n                        // update options with datas from groundMesh\n                        this._createOptionsFromGroundMesh(options);\n                    }\n                    if (options.numHeightFieldSamplesX && options.numHeightFieldSamplesZ && options.heightFieldSizeX && options.heightFieldSizeZ && options.heightFieldData) {\n                        const totalNumHeights = options.numHeightFieldSamplesX * options.numHeightFieldSamplesZ;\n                        const numBytes = totalNumHeights * 4;\n                        const bufferBegin = this._hknp._malloc(numBytes);\n                        const heightBuffer = new Float32Array(this._hknp.HEAPU8.buffer, bufferBegin, totalNumHeights);\n                        for (let x = 0; x < options.numHeightFieldSamplesX; x++) {\n                            for (let z = 0; z < options.numHeightFieldSamplesZ; z++) {\n                                const hkBufferIndex = z * options.numHeightFieldSamplesX + x;\n                                const bjsBufferIndex = (options.numHeightFieldSamplesX - 1 - x) * options.numHeightFieldSamplesZ + z;\n                                heightBuffer[hkBufferIndex] = options.heightFieldData[bjsBufferIndex];\n                            }\n                        }\n                        const scaleX = options.heightFieldSizeX / (options.numHeightFieldSamplesX - 1);\n                        const scaleZ = options.heightFieldSizeZ / (options.numHeightFieldSamplesZ - 1);\n                        shape._pluginData = this._hknp.HP_Shape_CreateHeightField(options.numHeightFieldSamplesX, options.numHeightFieldSamplesZ, [scaleX, 1, scaleZ], bufferBegin)[1];\n                        this._hknp._free(bufferBegin);\n                    }\n                    else {\n                        throw new Error(\"Missing required heightfield parameters\");\n                    }\n                }\n                break;\n            default:\n                throw new Error(\"Unsupported Shape Type.\");\n                break;\n        }\n        this._shapes.set(shape._pluginData[0], shape);\n    }\n    /**\n     * Sets the shape filter membership mask of a body\n     * @param shape - The physics body to set the shape filter membership mask for.\n     * @param membershipMask - The shape filter membership mask to set.\n     */\n    setShapeFilterMembershipMask(shape, membershipMask) {\n        const collideWith = this._hknp.HP_Shape_GetFilterInfo(shape._pluginData)[1][1];\n        this._hknp.HP_Shape_SetFilterInfo(shape._pluginData, [membershipMask, collideWith]);\n    }\n    /**\n     * Gets the shape filter membership mask of a body\n     * @param shape - The physics body to get the shape filter membership mask from.\n     * @returns The shape filter membership mask of the given body.\n     */\n    getShapeFilterMembershipMask(shape) {\n        return this._hknp.HP_Shape_GetFilterInfo(shape._pluginData)[1][0];\n    }\n    /**\n     * Sets the shape filter collide mask of a body\n     * @param shape - The physics body to set the shape filter collide mask for.\n     * @param collideMask - The shape filter collide mask to set.\n     */\n    setShapeFilterCollideMask(shape, collideMask) {\n        const membership = this._hknp.HP_Shape_GetFilterInfo(shape._pluginData)[1][0];\n        this._hknp.HP_Shape_SetFilterInfo(shape._pluginData, [membership, collideMask]);\n    }\n    /**\n     * Gets the shape filter collide mask of a body\n     * @param shape - The physics body to get the shape filter collide mask from.\n     * @returns The shape filter collide mask of the given body.\n     */\n    getShapeFilterCollideMask(shape) {\n        return this._hknp.HP_Shape_GetFilterInfo(shape._pluginData)[1][1];\n    }\n    /**\n     * Sets the material of a physics shape.\n     * @param shape - The physics shape to set the material of.\n     * @param material - The material to set.\n     *\n     */\n    setMaterial(shape, material) {\n        const dynamicFriction = material.friction ?? 0.5;\n        const staticFriction = material.staticFriction ?? dynamicFriction;\n        const restitution = material.restitution ?? 0.0;\n        const frictionCombine = material.frictionCombine ?? 1 /* PhysicsMaterialCombineMode.MINIMUM */;\n        const restitutionCombine = material.restitutionCombine ?? 2 /* PhysicsMaterialCombineMode.MAXIMUM */;\n        const hpMaterial = [staticFriction, dynamicFriction, restitution, this._materialCombineToNative(frictionCombine), this._materialCombineToNative(restitutionCombine)];\n        this._hknp.HP_Shape_SetMaterial(shape._pluginData, hpMaterial);\n    }\n    /**\n     * Gets the material associated with a physics shape.\n     * @param shape - The shape to get the material from.\n     * @returns The material associated with the shape.\n     */\n    getMaterial(shape) {\n        const hkMaterial = this._hknp.HP_Shape_GetMaterial(shape._pluginData)[1];\n        return {\n            staticFriction: hkMaterial[0],\n            friction: hkMaterial[1],\n            restitution: hkMaterial[2],\n            frictionCombine: this._nativeToMaterialCombine(hkMaterial[3]),\n            restitutionCombine: this._nativeToMaterialCombine(hkMaterial[4]),\n        };\n    }\n    /**\n     * Sets the density of a physics shape.\n     * @param shape - The physics shape to set the density of.\n     * @param density - The density to set.\n     *\n     */\n    setDensity(shape, density) {\n        this._hknp.HP_Shape_SetDensity(shape._pluginData, density);\n    }\n    /**\n     * Calculates the density of a given physics shape.\n     *\n     * @param shape - The physics shape to calculate the density of.\n     * @returns The density of the given physics shape.\n     *\n     */\n    getDensity(shape) {\n        return this._hknp.HP_Shape_GetDensity(shape._pluginData)[1];\n    }\n    /**\n     * Gets the transform infos of a given transform node.\n     * This code is useful for getting the position and orientation of a given transform node.\n     * It first checks if the node has a rotation quaternion, and if not, it creates one from the node's rotation.\n     * It then creates an array containing the position and orientation of the node and returns it.\n     * @param node - The transform node.\n     * @returns An array containing the position and orientation of the node.\n     */\n    _getTransformInfos(node) {\n        if (node.parent) {\n            node.computeWorldMatrix(true);\n            return [this._bVecToV3(node.absolutePosition), this._bQuatToV4(node.absoluteRotationQuaternion)];\n        }\n        let orientation = TmpVectors.Quaternion[0];\n        if (node.rotationQuaternion) {\n            orientation = node.rotationQuaternion;\n        }\n        else {\n            const r = node.rotation;\n            Quaternion.FromEulerAnglesToRef(r.x, r.y, r.z, orientation);\n        }\n        const transform = [this._bVecToV3(node.position), this._bQuatToV4(orientation)];\n        return transform;\n    }\n    /**\n     * Adds a child shape to the given shape.\n     * @param shape - The parent shape.\n     * @param newChild - The child shape to add.\n     * @param translation - The relative translation of the child from the parent shape\n     * @param rotation - The relative rotation of the child from the parent shape\n     * @param scale - The relative scale scale of the child from the parent shaep\n     *\n     */\n    addChild(shape, newChild, translation, rotation, scale) {\n        const transformNative = [\n            translation ? this._bVecToV3(translation) : [0, 0, 0],\n            rotation ? this._bQuatToV4(rotation) : [0, 0, 0, 1],\n            scale ? this._bVecToV3(scale) : [1, 1, 1],\n        ];\n        this._hknp.HP_Shape_AddChild(shape._pluginData, newChild._pluginData, transformNative);\n    }\n    /**\n     * Removes a child shape from a parent shape.\n     * @param shape - The parent shape.\n     * @param childIndex - The index of the child shape to remove.\n     *\n     */\n    removeChild(shape, childIndex) {\n        this._hknp.HP_Shape_RemoveChild(shape._pluginData, childIndex);\n    }\n    /**\n     * Returns the number of children of the given shape.\n     *\n     * @param shape - The shape to get the number of children from.\n     * @returns The number of children of the given shape.\n     *\n     */\n    getNumChildren(shape) {\n        return this._hknp.HP_Shape_GetNumChildren(shape._pluginData)[1];\n    }\n    /**\n     * Marks the shape as a trigger\n     * @param shape the shape to mark as a trigger\n     * @param isTrigger if the shape is a trigger\n     */\n    setTrigger(shape, isTrigger) {\n        this._hknp.HP_Shape_SetTrigger(shape._pluginData, isTrigger);\n    }\n    /**\n     * Calculates the bounding box of a given physics shape.\n     *\n     * @param _shape - The physics shape to calculate the bounding box for.\n     * @returns The calculated bounding box.\n     *\n     * This method is useful for physics engines as it allows to calculate the\n     * boundaries of a given shape. Knowing the boundaries of a shape is important\n     * for collision detection and other physics calculations.\n     */\n    getBoundingBox(_shape) {\n        // get local AABB\n        const aabb = this._hknp.HP_Shape_GetBoundingBox(_shape._pluginData, [\n            [0, 0, 0],\n            [0, 0, 0, 1],\n        ])[1];\n        TmpVectors.Vector3[0].set(aabb[0][0], aabb[0][1], aabb[0][2]); // min\n        TmpVectors.Vector3[1].set(aabb[1][0], aabb[1][1], aabb[1][2]); // max\n        const boundingbox = new BoundingBox(TmpVectors.Vector3[0], TmpVectors.Vector3[1], Matrix.IdentityReadOnly);\n        return boundingbox;\n    }\n    /**\n     * Calculates the world bounding box of a given physics body.\n     *\n     * @param body - The physics body to calculate the bounding box for.\n     * @returns The calculated bounding box.\n     *\n     * This method is useful for physics engines as it allows to calculate the\n     * boundaries of a given body.\n     */\n    getBodyBoundingBox(body) {\n        // get local AABB\n        const aabb = this.getBoundingBox(body.shape);\n        const boundingbox = new BoundingBox(aabb.minimum, aabb.maximum, body.transformNode.getWorldMatrix());\n        return boundingbox;\n    }\n    /**\n     * Gets the geometry of a physics body.\n     *\n     * @param body - The physics body.\n     * @returns An object containing the positions and indices of the body's geometry.\n     *\n     */\n    getBodyGeometry(body) {\n        const dataInfo = body._pluginDataInstances?.length > 0 ? body._pluginDataInstances[0] : body._pluginData;\n        const shape = this._hknp.HP_Body_GetShape(dataInfo.hpBodyId)[1];\n        const geometryRes = this._hknp.HP_Shape_CreateDebugDisplayGeometry(shape);\n        if (geometryRes[0] != this._hknp.Result.RESULT_OK) {\n            return { positions: [], indices: [] };\n        }\n        const geometryInfo = this._hknp.HP_DebugGeometry_GetInfo(geometryRes[1])[1];\n        const positionsInPlugin = new Float32Array(this._hknp.HEAPU8.buffer, geometryInfo[0], geometryInfo[1] * 3); // 3 floats per position\n        const indicesInPlugin = new Uint32Array(this._hknp.HEAPU8.buffer, geometryInfo[2], geometryInfo[3] * 3); // 3 indices per triangle\n        // HP_DebugGeometry_Release will free the buffer in the plugin. To avoid a\n        // use-after-free, we need  to make a copy of the data here.\n        const positions = positionsInPlugin.slice(0);\n        const indices = indicesInPlugin.slice(0);\n        this._hknp.HP_DebugGeometry_Release(geometryRes[1]);\n        return { positions: positions, indices: indices };\n    }\n    /**\n     * Releases a physics shape from the physics engine.\n     *\n     * @param shape - The physics shape to be released.\n     *\n     * This method is useful for releasing a physics shape from the physics engine, freeing up resources and preventing memory leaks.\n     */\n    disposeShape(shape) {\n        this._shapes.delete(shape._pluginData[0]);\n        this._hknp.HP_Shape_Release(shape._pluginData);\n        shape._pluginData = undefined;\n    }\n    // constraint\n    /**\n     * Initializes a physics constraint with the given parameters.\n     *\n     * @param constraint - The physics constraint to be initialized.\n     * @param body - The main body\n     * @param childBody - The child body.\n     * @param instanceIndex - If this body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\n     * @param childInstanceIndex - If the child body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\n     *\n     * This function is useful for setting up a physics constraint in a physics engine.\n     */\n    initConstraint(constraint, body, childBody, instanceIndex, childInstanceIndex) {\n        const type = constraint.type;\n        const options = constraint.options;\n        if (!type || !options) {\n            Logger.Warn(\"No constraint type or options. Constraint is invalid.\");\n            return;\n        }\n        if ((body._pluginDataInstances.length > 0 && instanceIndex === undefined) || (childBody._pluginDataInstances.length > 0 && childInstanceIndex === undefined)) {\n            Logger.Warn(\"Body is instanced but no instance index was specified. Constraint will not be applied.\");\n            return;\n        }\n        constraint._pluginData = constraint._pluginData ?? [];\n        const jointId = this._hknp.HP_Constraint_Create()[1];\n        constraint._pluginData.push(jointId);\n        // body parenting\n        const bodyA = this._getPluginReference(body, instanceIndex).hpBodyId;\n        const bodyB = this._getPluginReference(childBody, childInstanceIndex).hpBodyId;\n        this._hknp.HP_Constraint_SetParentBody(jointId, bodyA);\n        this._hknp.HP_Constraint_SetChildBody(jointId, bodyB);\n        this._constraintToBodyIdPair.set(jointId[0], [bodyA[0], bodyB[0]]);\n        // anchors\n        const pivotA = options.pivotA ? this._bVecToV3(options.pivotA) : this._bVecToV3(Vector3.Zero());\n        const axisA = options.axisA ?? new Vector3(1, 0, 0);\n        const perpAxisA = this._tmpVec3[0];\n        if (options.perpAxisA) {\n            perpAxisA.copyFrom(options.perpAxisA);\n        }\n        else {\n            axisA.getNormalToRef(perpAxisA);\n        }\n        this._hknp.HP_Constraint_SetAnchorInParent(jointId, pivotA, this._bVecToV3(axisA), this._bVecToV3(perpAxisA));\n        const pivotB = options.pivotB ? this._bVecToV3(options.pivotB) : this._bVecToV3(Vector3.Zero());\n        const axisB = options.axisB ?? new Vector3(1, 0, 0);\n        const perpAxisB = this._tmpVec3[0];\n        if (options.perpAxisB) {\n            perpAxisB.copyFrom(options.perpAxisB);\n        }\n        else {\n            axisB.getNormalToRef(perpAxisB);\n        }\n        this._hknp.HP_Constraint_SetAnchorInChild(jointId, pivotB, this._bVecToV3(axisB), this._bVecToV3(perpAxisB));\n        // Save the options that were used for initializing the constraint for debugging purposes\n        // Check first to avoid copying the same options multiple times\n        if (!constraint._initOptions) {\n            constraint._initOptions = {\n                axisA: axisA.clone(),\n                axisB: axisB.clone(),\n                perpAxisA: perpAxisA.clone(),\n                perpAxisB: perpAxisB.clone(),\n                pivotA: new Vector3(pivotA[0], pivotA[1], pivotA[2]),\n                pivotB: new Vector3(pivotB[0], pivotB[1], pivotB[2]),\n            };\n        }\n        if (type == 5 /* PhysicsConstraintType.LOCK */) {\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_X, this._hknp.ConstraintAxisLimitMode.LOCKED);\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_X, this._hknp.ConstraintAxisLimitMode.LOCKED);\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\n        }\n        else if (type == 2 /* PhysicsConstraintType.DISTANCE */) {\n            const distance = options.maxDistance || 0;\n            const dist3d = this._hknp.ConstraintAxis.LINEAR_DISTANCE;\n            this._hknp.HP_Constraint_SetAxisMode(jointId, dist3d, this._hknp.ConstraintAxisLimitMode.LIMITED);\n            this._hknp.HP_Constraint_SetAxisMinLimit(jointId, dist3d, distance);\n            this._hknp.HP_Constraint_SetAxisMaxLimit(jointId, dist3d, distance);\n        }\n        else if (type == 3 /* PhysicsConstraintType.HINGE */) {\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_X, this._hknp.ConstraintAxisLimitMode.LOCKED);\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\n        }\n        else if (type == 6 /* PhysicsConstraintType.PRISMATIC */) {\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_X, this._hknp.ConstraintAxisLimitMode.LOCKED);\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\n        }\n        else if (type == 4 /* PhysicsConstraintType.SLIDER */) {\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\n        }\n        else if (type == 1 /* PhysicsConstraintType.BALL_AND_SOCKET */) {\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_X, this._hknp.ConstraintAxisLimitMode.LOCKED);\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\n        }\n        else if (type == 7 /* PhysicsConstraintType.SIX_DOF */) {\n            const sixdofData = constraint;\n            for (const l of sixdofData.limits) {\n                const axId = this._constraintAxisToNative(l.axis);\n                if ((l.minLimit ?? -1) == 0 && (l.maxLimit ?? -1) == 0) {\n                    this._hknp.HP_Constraint_SetAxisMode(jointId, axId, this._hknp.ConstraintAxisLimitMode.LOCKED);\n                }\n                else {\n                    if (l.minLimit != undefined) {\n                        this._hknp.HP_Constraint_SetAxisMode(jointId, axId, this._hknp.ConstraintAxisLimitMode.LIMITED);\n                        this._hknp.HP_Constraint_SetAxisMinLimit(jointId, axId, l.minLimit);\n                    }\n                    if (l.maxLimit != undefined) {\n                        this._hknp.HP_Constraint_SetAxisMode(jointId, axId, this._hknp.ConstraintAxisLimitMode.LIMITED);\n                        this._hknp.HP_Constraint_SetAxisMaxLimit(jointId, axId, l.maxLimit);\n                    }\n                }\n                if (l.stiffness) {\n                    this._hknp.HP_Constraint_SetAxisStiffness(jointId, axId, l.stiffness);\n                }\n                if (l.damping) {\n                    this._hknp.HP_Constraint_SetAxisDamping(jointId, axId, l.damping);\n                }\n            }\n        }\n        else {\n            throw new Error(\"Unsupported Constraint Type.\");\n        }\n        const collisionEnabled = !!options.collision;\n        this._hknp.HP_Constraint_SetCollisionsEnabled(jointId, collisionEnabled);\n        this._hknp.HP_Constraint_SetEnabled(jointId, true);\n    }\n    /**\n     * Get a list of all the pairs of bodies that are connected by this constraint.\n     * @param constraint the constraint to search from\n     * @returns a list of parent, child pairs\n     */\n    getBodiesUsingConstraint(constraint) {\n        const pairs = [];\n        for (const jointId of constraint._pluginData) {\n            const bodyIds = this._constraintToBodyIdPair.get(jointId[0]);\n            if (bodyIds) {\n                const parentBodyInfo = this._bodies.get(bodyIds[0]);\n                const childBodyInfo = this._bodies.get(bodyIds[1]);\n                if (parentBodyInfo && childBodyInfo) {\n                    pairs.push({ parentBody: parentBodyInfo.body, parentBodyIndex: parentBodyInfo.index, childBody: childBodyInfo.body, childBodyIndex: childBodyInfo.index });\n                }\n            }\n        }\n        return pairs;\n    }\n    /**\n     * Adds a constraint to the physics engine.\n     *\n     * @param body - The main body to which the constraint is applied.\n     * @param childBody - The body to which the constraint is applied.\n     * @param constraint - The constraint to be applied.\n     * @param instanceIndex - If this body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\n     * @param childInstanceIndex - If the child body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\n     */\n    addConstraint(body, childBody, constraint, instanceIndex, childInstanceIndex) {\n        //<todo It's real weird that initConstraint() is called only after adding to a body!\n        this.initConstraint(constraint, body, childBody, instanceIndex, childInstanceIndex);\n    }\n    /**\n     * Enables or disables a constraint in the physics engine.\n     * @param constraint - The constraint to enable or disable.\n     * @param isEnabled - Whether the constraint should be enabled or disabled.\n     *\n     */\n    setEnabled(constraint, isEnabled) {\n        for (const jointId of constraint._pluginData) {\n            this._hknp.HP_Constraint_SetEnabled(jointId, isEnabled);\n        }\n    }\n    /**\n     * Gets the enabled state of the given constraint.\n     * @param constraint - The constraint to get the enabled state from.\n     * @returns The enabled state of the given constraint.\n     *\n     */\n    getEnabled(constraint) {\n        const firstId = constraint._pluginData && constraint._pluginData[0];\n        if (firstId) {\n            return this._hknp.HP_Constraint_GetEnabled(firstId)[1];\n        }\n        return false;\n    }\n    /**\n     * Enables or disables collisions for the given constraint.\n     * @param constraint - The constraint to enable or disable collisions for.\n     * @param isEnabled - Whether collisions should be enabled or disabled.\n     *\n     */\n    setCollisionsEnabled(constraint, isEnabled) {\n        for (const jointId of constraint._pluginData) {\n            this._hknp.HP_Constraint_SetCollisionsEnabled(jointId, isEnabled);\n        }\n    }\n    /**\n     * Gets whether collisions are enabled for the given constraint.\n     * @param constraint - The constraint to get collisions enabled for.\n     * @returns Whether collisions are enabled for the given constraint.\n     *\n     */\n    getCollisionsEnabled(constraint) {\n        const firstId = constraint._pluginData && constraint._pluginData[0];\n        if (firstId) {\n            return this._hknp.HP_Constraint_GetCollisionsEnabled(firstId)[1];\n        }\n        return false;\n    }\n    /**\n     * Sets the friction of the given axis of the given constraint.\n     *\n     * @param constraint - The constraint to set the friction of.\n     * @param axis - The axis of the constraint to set the friction of.\n     * @param friction - The friction to set.\n     *\n     */\n    setAxisFriction(constraint, axis, friction) {\n        for (const jointId of constraint._pluginData) {\n            this._hknp.HP_Constraint_SetAxisFriction(jointId, this._constraintAxisToNative(axis), friction);\n        }\n    }\n    /**\n     * Gets the friction value of the specified axis of the given constraint.\n     *\n     * @param constraint - The constraint to get the axis friction from.\n     * @param axis - The axis to get the friction from.\n     * @returns The friction value of the specified axis.\n     *\n     */\n    getAxisFriction(constraint, axis) {\n        const firstId = constraint._pluginData && constraint._pluginData[0];\n        if (firstId) {\n            return this._hknp.HP_Constraint_GetAxisFriction(firstId, this._constraintAxisToNative(axis))[1];\n        }\n        return null;\n    }\n    /**\n     * Sets the limit mode of the specified axis of the given constraint.\n     * @param constraint - The constraint to set the axis mode of.\n     * @param axis - The axis to set the limit mode of.\n     * @param limitMode - The limit mode to set.\n     */\n    setAxisMode(constraint, axis, limitMode) {\n        for (const jointId of constraint._pluginData) {\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._constraintAxisToNative(axis), this._limitModeToNative(limitMode));\n        }\n    }\n    /**\n     * Gets the axis limit mode of the given constraint.\n     *\n     * @param constraint - The constraint to get the axis limit mode from.\n     * @param axis - The axis to get the limit mode from.\n     * @returns The axis limit mode of the given constraint.\n     *\n     */\n    getAxisMode(constraint, axis) {\n        const firstId = constraint._pluginData && constraint._pluginData[0];\n        if (firstId) {\n            const mode = this._hknp.HP_Constraint_GetAxisMode(firstId, this._constraintAxisToNative(axis))[1];\n            return this._nativeToLimitMode(mode);\n        }\n        return null;\n    }\n    /**\n     * Sets the minimum limit of the given axis of the given constraint.\n     * @param constraint - The constraint to set the minimum limit of.\n     * @param axis - The axis to set the minimum limit of.\n     * @param limit - The minimum limit to set.\n     *\n     */\n    setAxisMinLimit(constraint, axis, limit) {\n        for (const jointId of constraint._pluginData) {\n            this._hknp.HP_Constraint_SetAxisMinLimit(jointId, this._constraintAxisToNative(axis), limit);\n        }\n    }\n    /**\n     * Gets the minimum limit of the specified axis of the given constraint.\n     * @param constraint - The constraint to get the minimum limit from.\n     * @param axis - The axis to get the minimum limit from.\n     * @returns The minimum limit of the specified axis of the given constraint.\n     *\n     */\n    getAxisMinLimit(constraint, axis) {\n        const firstId = constraint._pluginData && constraint._pluginData[0];\n        if (firstId) {\n            return this._hknp.HP_Constraint_GetAxisMinLimit(firstId, this._constraintAxisToNative(axis))[1];\n        }\n        return null;\n    }\n    /**\n     * Sets the maximum limit of the given axis of the given constraint.\n     * @param constraint - The constraint to set the maximum limit of the given axis.\n     * @param axis - The axis to set the maximum limit of.\n     * @param limit - The maximum limit to set.\n     *\n     */\n    setAxisMaxLimit(constraint, axis, limit) {\n        for (const jointId of constraint._pluginData) {\n            this._hknp.HP_Constraint_SetAxisMaxLimit(jointId, this._constraintAxisToNative(axis), limit);\n        }\n    }\n    /**\n     * Gets the maximum limit of the given axis of the given constraint.\n     *\n     * @param constraint - The constraint to get the maximum limit from.\n     * @param axis - The axis to get the maximum limit from.\n     * @returns The maximum limit of the given axis of the given constraint.\n     *\n     */\n    getAxisMaxLimit(constraint, axis) {\n        const firstId = constraint._pluginData && constraint._pluginData[0];\n        if (firstId) {\n            return this._hknp.HP_Constraint_GetAxisMaxLimit(firstId, this._constraintAxisToNative(axis))[1];\n        }\n        return null;\n    }\n    /**\n     * Sets the motor type of the given axis of the given constraint.\n     * @param constraint - The constraint to set the motor type of.\n     * @param axis - The axis of the constraint to set the motor type of.\n     * @param motorType - The motor type to set.\n     *\n     */\n    setAxisMotorType(constraint, axis, motorType) {\n        for (const jointId of constraint._pluginData) {\n            this._hknp.HP_Constraint_SetAxisMotorType(jointId, this._constraintAxisToNative(axis), this._constraintMotorTypeToNative(motorType));\n        }\n    }\n    /**\n     * Gets the motor type of the specified axis of the given constraint.\n     * @param constraint - The constraint to get the motor type from.\n     * @param axis - The axis of the constraint to get the motor type from.\n     * @returns The motor type of the specified axis of the given constraint.\n     *\n     */\n    getAxisMotorType(constraint, axis) {\n        const firstId = constraint._pluginData && constraint._pluginData[0];\n        if (firstId) {\n            return this._nativeToMotorType(this._hknp.HP_Constraint_GetAxisMotorType(firstId, this._constraintAxisToNative(axis))[1]);\n        }\n        return null;\n    }\n    /**\n     * Sets the target of an axis motor of a constraint.\n     *\n     * @param constraint - The constraint to set the axis motor target of.\n     * @param axis - The axis of the constraint to set the motor target of.\n     * @param target - The target of the axis motor.\n     *\n     */\n    setAxisMotorTarget(constraint, axis, target) {\n        for (const jointId of constraint._pluginData) {\n            this._hknp.HP_Constraint_SetAxisMotorTarget(jointId, this._constraintAxisToNative(axis), target);\n        }\n    }\n    /**\n     * Gets the target of the motor of the given axis of the given constraint.\n     *\n     * @param constraint - The constraint to get the motor target from.\n     * @param axis - The axis of the constraint to get the motor target from.\n     * @returns The target of the motor of the given axis of the given constraint.\n     *\n     */\n    getAxisMotorTarget(constraint, axis) {\n        const firstId = constraint._pluginData && constraint._pluginData[0];\n        if (firstId) {\n            return this._hknp.HP_Constraint_GetAxisMotorTarget(constraint._pluginData, this._constraintAxisToNative(axis))[1];\n        }\n        return null;\n    }\n    /**\n     * Sets the maximum force that can be applied by the motor of the given constraint axis.\n     * @param constraint - The constraint to set the motor max force for.\n     * @param axis - The axis of the constraint to set the motor max force for.\n     * @param maxForce - The maximum force that can be applied by the motor.\n     *\n     */\n    setAxisMotorMaxForce(constraint, axis, maxForce) {\n        for (const jointId of constraint._pluginData) {\n            this._hknp.HP_Constraint_SetAxisMotorMaxForce(jointId, this._constraintAxisToNative(axis), maxForce);\n        }\n    }\n    /**\n     * Gets the maximum force of the motor of the given constraint axis.\n     *\n     * @param constraint - The constraint to get the motor maximum force from.\n     * @param axis - The axis of the constraint to get the motor maximum force from.\n     * @returns The maximum force of the motor of the given constraint axis.\n     *\n     */\n    getAxisMotorMaxForce(constraint, axis) {\n        const firstId = constraint._pluginData && constraint._pluginData[0];\n        if (firstId) {\n            return this._hknp.HP_Constraint_GetAxisMotorMaxForce(firstId, this._constraintAxisToNative(axis))[1];\n        }\n        return null;\n    }\n    /**\n     * Disposes a physics constraint.\n     *\n     * @param constraint - The physics constraint to dispose.\n     *\n     * This method is useful for releasing the resources associated with a physics constraint, such as\n     * the Havok constraint, when it is no longer needed. This is important for avoiding memory leaks.\n     */\n    disposeConstraint(constraint) {\n        for (const jointId of constraint._pluginData) {\n            this._hknp.HP_Constraint_SetEnabled(jointId, false);\n            this._hknp.HP_Constraint_Release(jointId);\n        }\n        constraint._pluginData.length = 0;\n    }\n    _populateHitData(hitData, result) {\n        const hitBody = this._bodies.get(hitData[0][0]);\n        result.body = hitBody?.body;\n        result.bodyIndex = hitBody?.index;\n        const hitShape = this._shapes.get(hitData[1][0]);\n        result.shape = hitShape;\n        const hitPos = hitData[3];\n        const hitNormal = hitData[4];\n        const hitTriangle = hitData[5];\n        result.setHitData({ x: hitNormal[0], y: hitNormal[1], z: hitNormal[2] }, { x: hitPos[0], y: hitPos[1], z: hitPos[2] }, hitTriangle);\n    }\n    /**\n     * Performs a raycast from a given start point to a given end point and stores the result in a given PhysicsRaycastResult object.\n     *\n     * @param from - The start point of the raycast.\n     * @param to - The end point of the raycast.\n     * @param result - The PhysicsRaycastResult object to store the result of the raycast.\n     * @param query - The raycast query options. See [[IRaycastQuery]] for more information.\n     *\n     * Performs a raycast. It takes in two points, from and to, and a PhysicsRaycastResult object to store the result of the raycast.\n     * It then performs the raycast and stores the hit data in the PhysicsRaycastResult object.\n     */\n    raycast(from, to, result, query) {\n        const queryMembership = query?.membership ?? ~0;\n        const queryCollideWith = query?.collideWith ?? ~0;\n        const shouldHitTriggers = query?.shouldHitTriggers ?? false;\n        result.reset(from, to);\n        const bodyToIgnore = [BigInt(0)];\n        const hkQuery = [this._bVecToV3(from), this._bVecToV3(to), [queryMembership, queryCollideWith], shouldHitTriggers, bodyToIgnore];\n        this._hknp.HP_World_CastRayWithCollector(this.world, this._queryCollector, hkQuery);\n        if (this._hknp.HP_QueryCollector_GetNumHits(this._queryCollector)[1] > 0) {\n            const [, hitData] = this._hknp.HP_QueryCollector_GetCastRayResult(this._queryCollector, 0)[1];\n            this._populateHitData(hitData, result);\n            result.calculateHitDistance();\n        }\n    }\n    /**\n     * Given a point, returns the closest physics\n     * body to that point.\n     * @param query the query to perform. @see IPhysicsPointProximityQuery\n     * @param result contact point on the hit shape, in world space\n     */\n    pointProximity(query, result) {\n        const queryMembership = query?.collisionFilter?.membership ?? ~0;\n        const queryCollideWith = query?.collisionFilter?.collideWith ?? ~0;\n        result.reset();\n        const bodyToIgnore = query.ignoreBody ? [BigInt(query.ignoreBody._pluginData.hpBodyId[0])] : [BigInt(0)];\n        const hkQuery = [this._bVecToV3(query.position), query.maxDistance, [queryMembership, queryCollideWith], query.shouldHitTriggers, bodyToIgnore];\n        this._hknp.HP_World_PointProximityWithCollector(this.world, this._queryCollector, hkQuery);\n        if (this._hknp.HP_QueryCollector_GetNumHits(this._queryCollector)[1] > 0) {\n            const [distance, hitData] = this._hknp.HP_QueryCollector_GetPointProximityResult(this._queryCollector, 0)[1];\n            this._populateHitData(hitData, result);\n            result.setHitDistance(distance);\n        }\n    }\n    /**\n     * Given a shape in a specific position and orientation, returns the closest point to that shape.\n     * @param query the query to perform. @see IPhysicsShapeProximityCastQuery\n     * @param inputShapeResult contact point on input shape, in input shape space\n     * @param hitShapeResult contact point on hit shape, in world space\n     */\n    shapeProximity(query, inputShapeResult, hitShapeResult) {\n        inputShapeResult.reset();\n        hitShapeResult.reset();\n        const shapeId = query.shape._pluginData;\n        const bodyToIgnore = query.ignoreBody ? [BigInt(query.ignoreBody._pluginData.hpBodyId[0])] : [BigInt(0)];\n        const hkQuery = [shapeId, this._bVecToV3(query.position), this._bQuatToV4(query.rotation), query.maxDistance, query.shouldHitTriggers, bodyToIgnore];\n        this._hknp.HP_World_ShapeProximityWithCollector(this.world, this._queryCollector, hkQuery);\n        if (this._hknp.HP_QueryCollector_GetNumHits(this._queryCollector)[1] > 0) {\n            const [distance, hitInputData, hitShapeData] = this._hknp.HP_QueryCollector_GetShapeProximityResult(this._queryCollector, 0)[1];\n            this._populateHitData(hitInputData, inputShapeResult);\n            this._populateHitData(hitShapeData, hitShapeResult);\n            inputShapeResult.setHitDistance(distance);\n            hitShapeResult.setHitDistance(distance);\n        }\n    }\n    /**\n     * Given a shape in a specific orientation, cast it from the start to end position specified by the query, and return the first hit.\n     * @param query the query to perform. @see IPhysicsShapeCastQuery\n     * @param inputShapeResult contact point on input shape, in input shape space\n     * @param hitShapeResult contact point on hit shape, in world space\n     */\n    shapeCast(query, inputShapeResult, hitShapeResult) {\n        inputShapeResult.reset();\n        hitShapeResult.reset();\n        const shapeId = query.shape._pluginData;\n        const bodyToIgnore = query.ignoreBody ? [BigInt(query.ignoreBody._pluginData.hpBodyId[0])] : [BigInt(0)];\n        const hkQuery = [shapeId, this._bQuatToV4(query.rotation), this._bVecToV3(query.startPosition), this._bVecToV3(query.endPosition), query.shouldHitTriggers, bodyToIgnore];\n        this._hknp.HP_World_ShapeCastWithCollector(this.world, this._queryCollector, hkQuery);\n        if (this._hknp.HP_QueryCollector_GetNumHits(this._queryCollector)[1] > 0) {\n            const [fractionAlongRay, hitInputData, hitShapeData] = this._hknp.HP_QueryCollector_GetShapeCastResult(this._queryCollector, 0)[1];\n            this._populateHitData(hitInputData, inputShapeResult);\n            this._populateHitData(hitShapeData, hitShapeResult);\n            inputShapeResult.setHitFraction(fractionAlongRay);\n            hitShapeResult.setHitFraction(fractionAlongRay);\n        }\n    }\n    /**\n     * Return the collision observable for a particular physics body.\n     * @param body the physics body\n     * @returns the collision observable for the body\n     */\n    getCollisionObservable(body) {\n        const bodyId = body._pluginData.hpBodyId[0];\n        let observable = this._bodyCollisionObservable.get(bodyId);\n        if (!observable) {\n            observable = new Observable();\n            this._bodyCollisionObservable.set(bodyId, observable);\n        }\n        return observable;\n    }\n    /**\n     * Return the collision ended observable for a particular physics body.\n     * @param body the physics body\n     * @returns\n     */\n    getCollisionEndedObservable(body) {\n        const bodyId = body._pluginData.hpBodyId[0];\n        let observable = this._bodyCollisionEndedObservable.get(bodyId);\n        if (!observable) {\n            observable = new Observable();\n            this._bodyCollisionEndedObservable.set(bodyId, observable);\n        }\n        return observable;\n    }\n    /**\n     * Enable collision to be reported for a body when a callback is setup on the world\n     * @param body the physics body\n     * @param enabled whether to enable or disable collision events\n     */\n    setCollisionCallbackEnabled(body, enabled) {\n        // Register for collide events by default\n        const collideEvents = this._hknp.EventType.COLLISION_STARTED.value | this._hknp.EventType.COLLISION_CONTINUED.value | this._hknp.EventType.COLLISION_FINISHED.value;\n        if (body._pluginDataInstances && body._pluginDataInstances.length) {\n            body._pluginDataInstances.forEach((bodyId) => {\n                this._hknp.HP_Body_SetEventMask(bodyId.hpBodyId, enabled ? collideEvents : 0);\n            });\n        }\n        else if (body._pluginData) {\n            this._hknp.HP_Body_SetEventMask(body._pluginData.hpBodyId, enabled ? collideEvents : 0);\n        }\n    }\n    /**\n     * Enable collision ended to be reported for a body when a callback is setup on the world\n     * @param body the physics body\n     * @param enabled whether to enable or disable collision ended events\n     */\n    setCollisionEndedCallbackEnabled(body, enabled) {\n        // Register to collide ended events\n        const pluginRef = this._getPluginReference(body);\n        let currentCollideEvents = this._hknp.HP_Body_GetEventMask(pluginRef.hpBodyId)[1];\n        // update with the ended mask\n        currentCollideEvents = enabled\n            ? currentCollideEvents | this._hknp.EventType.COLLISION_FINISHED.value\n            : currentCollideEvents & ~this._hknp.EventType.COLLISION_FINISHED.value;\n        if (body._pluginDataInstances && body._pluginDataInstances.length) {\n            body._pluginDataInstances.forEach((bodyId) => {\n                this._hknp.HP_Body_SetEventMask(bodyId.hpBodyId, currentCollideEvents);\n            });\n        }\n        else if (body._pluginData) {\n            this._hknp.HP_Body_SetEventMask(body._pluginData.hpBodyId, currentCollideEvents);\n        }\n    }\n    _notifyTriggers() {\n        let eventAddress = this._hknp.HP_World_GetTriggerEvents(this.world)[1];\n        const event = new TriggerEvent();\n        while (eventAddress) {\n            TriggerEvent.readToRef(this._hknp.HEAPU8.buffer, eventAddress, event);\n            const bodyInfoA = this._bodies.get(event.bodyIdA);\n            const bodyInfoB = this._bodies.get(event.bodyIdB);\n            // Bodies may have been disposed between events. Check both still exist.\n            if (bodyInfoA && bodyInfoB) {\n                const triggerCollisionInfo = {\n                    collider: bodyInfoA.body,\n                    colliderIndex: bodyInfoA.index,\n                    collidedAgainst: bodyInfoB.body,\n                    collidedAgainstIndex: bodyInfoB.index,\n                    type: this._nativeTriggerCollisionValueToCollisionType(event.type),\n                };\n                this.onTriggerCollisionObservable.notifyObservers(triggerCollisionInfo);\n            }\n            eventAddress = this._hknp.HP_World_GetNextTriggerEvent(this.world, eventAddress);\n        }\n    }\n    /**\n     * Runs thru all detected collisions and filter by body\n     */\n    _notifyCollisions() {\n        let eventAddress = this._hknp.HP_World_GetCollisionEvents(this.world)[1];\n        const event = new CollisionEvent();\n        const worldAddr = Number(this.world);\n        while (eventAddress) {\n            CollisionEvent.readToRef(this._hknp.HEAPU8.buffer, eventAddress, event);\n            const bodyInfoA = this._bodies.get(event.contactOnA.bodyId);\n            const bodyInfoB = this._bodies.get(event.contactOnB.bodyId);\n            // Bodies may have been disposed between events. Check both still exist.\n            if (bodyInfoA && bodyInfoB) {\n                const collisionInfo = {\n                    collider: bodyInfoA.body,\n                    colliderIndex: bodyInfoA.index,\n                    collidedAgainst: bodyInfoB.body,\n                    collidedAgainstIndex: bodyInfoB.index,\n                    type: this._nativeCollisionValueToCollisionType(event.type),\n                };\n                if (collisionInfo.type === \"COLLISION_FINISHED\" /* PhysicsEventType.COLLISION_FINISHED */) {\n                    this.onCollisionEndedObservable.notifyObservers(collisionInfo);\n                }\n                else {\n                    event.contactOnB.position.subtractToRef(event.contactOnA.position, this._tmpVec3[0]);\n                    const distance = Vector3.Dot(this._tmpVec3[0], event.contactOnA.normal);\n                    collisionInfo.point = event.contactOnA.position;\n                    collisionInfo.distance = distance;\n                    collisionInfo.impulse = event.impulseApplied;\n                    collisionInfo.normal = event.contactOnA.normal;\n                    this.onCollisionObservable.notifyObservers(collisionInfo);\n                }\n                if (this._bodyCollisionObservable.size && collisionInfo.type !== \"COLLISION_FINISHED\" /* PhysicsEventType.COLLISION_FINISHED */) {\n                    const observableA = this._bodyCollisionObservable.get(event.contactOnA.bodyId);\n                    const observableB = this._bodyCollisionObservable.get(event.contactOnB.bodyId);\n                    event.contactOnA.position.subtractToRef(event.contactOnB.position, this._tmpVec3[0]);\n                    const distance = Vector3.Dot(this._tmpVec3[0], event.contactOnB.normal);\n                    if (observableA) {\n                        observableA.notifyObservers(collisionInfo);\n                    }\n                    if (observableB) {\n                        const collisionInfoB = {\n                            collider: bodyInfoB.body,\n                            colliderIndex: bodyInfoB.index,\n                            collidedAgainst: bodyInfoA.body,\n                            collidedAgainstIndex: bodyInfoA.index,\n                            point: event.contactOnB.position,\n                            distance: distance,\n                            impulse: event.impulseApplied,\n                            normal: event.contactOnB.normal,\n                            type: this._nativeCollisionValueToCollisionType(event.type),\n                        };\n                        observableB.notifyObservers(collisionInfoB);\n                    }\n                }\n                else if (this._bodyCollisionEndedObservable.size) {\n                    const observableA = this._bodyCollisionEndedObservable.get(event.contactOnA.bodyId);\n                    const observableB = this._bodyCollisionEndedObservable.get(event.contactOnB.bodyId);\n                    event.contactOnA.position.subtractToRef(event.contactOnB.position, this._tmpVec3[0]);\n                    const distance = Vector3.Dot(this._tmpVec3[0], event.contactOnB.normal);\n                    if (observableA) {\n                        observableA.notifyObservers(collisionInfo);\n                    }\n                    if (observableB) {\n                        const collisionInfoB = {\n                            collider: bodyInfoB.body,\n                            colliderIndex: bodyInfoB.index,\n                            collidedAgainst: bodyInfoA.body,\n                            collidedAgainstIndex: bodyInfoA.index,\n                            point: event.contactOnB.position,\n                            distance: distance,\n                            impulse: event.impulseApplied,\n                            normal: event.contactOnB.normal,\n                            type: this._nativeCollisionValueToCollisionType(event.type),\n                        };\n                        observableB.notifyObservers(collisionInfoB);\n                    }\n                }\n            }\n            eventAddress = this._hknp.HP_World_GetNextCollisionEvent(worldAddr, eventAddress);\n        }\n    }\n    /**\n     * Gets the number of bodies in the world\n     */\n    get numBodies() {\n        return this._hknp.HP_World_GetNumBodies(this.world)[1];\n    }\n    /**\n     * Dispose the world and free resources\n     */\n    dispose() {\n        if (this._queryCollector) {\n            this._hknp.HP_QueryCollector_Release(this._queryCollector);\n            this._queryCollector = undefined;\n        }\n        if (this.world) {\n            this._hknp.HP_World_Release(this.world);\n            this.world = undefined;\n        }\n    }\n    _v3ToBvecRef(v, vec3) {\n        vec3.set(v[0], v[1], v[2]);\n    }\n    _bVecToV3(v) {\n        return [v._x, v._y, v._z];\n    }\n    _bQuatToV4(q) {\n        return [q._x, q._y, q._z, q._w];\n    }\n    _constraintMotorTypeToNative(motorType) {\n        switch (motorType) {\n            case 2 /* PhysicsConstraintMotorType.POSITION */:\n                return this._hknp.ConstraintMotorType.POSITION;\n            case 1 /* PhysicsConstraintMotorType.VELOCITY */:\n                return this._hknp.ConstraintMotorType.VELOCITY;\n        }\n        return this._hknp.ConstraintMotorType.NONE;\n    }\n    _nativeToMotorType(motorType) {\n        switch (motorType) {\n            case this._hknp.ConstraintMotorType.POSITION:\n                return 2 /* PhysicsConstraintMotorType.POSITION */;\n            case this._hknp.ConstraintMotorType.VELOCITY:\n                return 1 /* PhysicsConstraintMotorType.VELOCITY */;\n        }\n        return 0 /* PhysicsConstraintMotorType.NONE */;\n    }\n    _materialCombineToNative(mat) {\n        switch (mat) {\n            case 0 /* PhysicsMaterialCombineMode.GEOMETRIC_MEAN */:\n                return this._hknp.MaterialCombine.GEOMETRIC_MEAN;\n            case 1 /* PhysicsMaterialCombineMode.MINIMUM */:\n                return this._hknp.MaterialCombine.MINIMUM;\n            case 2 /* PhysicsMaterialCombineMode.MAXIMUM */:\n                return this._hknp.MaterialCombine.MAXIMUM;\n            case 3 /* PhysicsMaterialCombineMode.ARITHMETIC_MEAN */:\n                return this._hknp.MaterialCombine.ARITHMETIC_MEAN;\n            case 4 /* PhysicsMaterialCombineMode.MULTIPLY */:\n                return this._hknp.MaterialCombine.MULTIPLY;\n        }\n    }\n    _nativeToMaterialCombine(mat) {\n        switch (mat) {\n            case this._hknp.MaterialCombine.GEOMETRIC_MEAN:\n                return 0 /* PhysicsMaterialCombineMode.GEOMETRIC_MEAN */;\n            case this._hknp.MaterialCombine.MINIMUM:\n                return 1 /* PhysicsMaterialCombineMode.MINIMUM */;\n            case this._hknp.MaterialCombine.MAXIMUM:\n                return 2 /* PhysicsMaterialCombineMode.MAXIMUM */;\n            case this._hknp.MaterialCombine.ARITHMETIC_MEAN:\n                return 3 /* PhysicsMaterialCombineMode.ARITHMETIC_MEAN */;\n            case this._hknp.MaterialCombine.MULTIPLY:\n                return 4 /* PhysicsMaterialCombineMode.MULTIPLY */;\n            default:\n                return undefined;\n        }\n    }\n    _constraintAxisToNative(axId) {\n        switch (axId) {\n            case 0 /* PhysicsConstraintAxis.LINEAR_X */:\n                return this._hknp.ConstraintAxis.LINEAR_X;\n            case 1 /* PhysicsConstraintAxis.LINEAR_Y */:\n                return this._hknp.ConstraintAxis.LINEAR_Y;\n            case 2 /* PhysicsConstraintAxis.LINEAR_Z */:\n                return this._hknp.ConstraintAxis.LINEAR_Z;\n            case 3 /* PhysicsConstraintAxis.ANGULAR_X */:\n                return this._hknp.ConstraintAxis.ANGULAR_X;\n            case 4 /* PhysicsConstraintAxis.ANGULAR_Y */:\n                return this._hknp.ConstraintAxis.ANGULAR_Y;\n            case 5 /* PhysicsConstraintAxis.ANGULAR_Z */:\n                return this._hknp.ConstraintAxis.ANGULAR_Z;\n            case 6 /* PhysicsConstraintAxis.LINEAR_DISTANCE */:\n                return this._hknp.ConstraintAxis.LINEAR_DISTANCE;\n        }\n    }\n    _nativeToLimitMode(mode) {\n        switch (mode) {\n            case this._hknp.ConstraintAxisLimitMode.FREE:\n                return 0 /* PhysicsConstraintAxisLimitMode.FREE */;\n            case this._hknp.ConstraintAxisLimitMode.LIMITED:\n                return 1 /* PhysicsConstraintAxisLimitMode.LIMITED */;\n            case this._hknp.ConstraintAxisLimitMode.LOCKED:\n                return 2 /* PhysicsConstraintAxisLimitMode.LOCKED */;\n        }\n        return 0 /* PhysicsConstraintAxisLimitMode.FREE */;\n    }\n    _limitModeToNative(mode) {\n        switch (mode) {\n            case 0 /* PhysicsConstraintAxisLimitMode.FREE */:\n                return this._hknp.ConstraintAxisLimitMode.FREE;\n            case 1 /* PhysicsConstraintAxisLimitMode.LIMITED */:\n                return this._hknp.ConstraintAxisLimitMode.LIMITED;\n            case 2 /* PhysicsConstraintAxisLimitMode.LOCKED */:\n                return this._hknp.ConstraintAxisLimitMode.LOCKED;\n        }\n    }\n    _nativeCollisionValueToCollisionType(type) {\n        switch (type) {\n            case this._hknp.EventType.COLLISION_STARTED.value:\n                return \"COLLISION_STARTED\" /* PhysicsEventType.COLLISION_STARTED */;\n            case this._hknp.EventType.COLLISION_FINISHED.value:\n                return \"COLLISION_FINISHED\" /* PhysicsEventType.COLLISION_FINISHED */;\n            case this._hknp.EventType.COLLISION_CONTINUED.value:\n                return \"COLLISION_CONTINUED\" /* PhysicsEventType.COLLISION_CONTINUED */;\n        }\n        return \"COLLISION_STARTED\" /* PhysicsEventType.COLLISION_STARTED */;\n    }\n    _nativeTriggerCollisionValueToCollisionType(type) {\n        switch (type) {\n            case 8:\n                return \"TRIGGER_ENTERED\" /* PhysicsEventType.TRIGGER_ENTERED */;\n            case 16:\n                return \"TRIGGER_EXITED\" /* PhysicsEventType.TRIGGER_EXITED */;\n        }\n        return \"TRIGGER_ENTERED\" /* PhysicsEventType.TRIGGER_ENTERED */;\n    }\n}\n//# sourceMappingURL=havokPlugin.js.map","import { CastingResult } from \"./castingResult.js\";\n/**\n * Class representing a contact point produced in a proximity cast\n */\nexport class ProximityCastResult extends CastingResult {\n    constructor() {\n        super(...arguments);\n        this._hitDistance = 0;\n    }\n    /**\n     * Gets the distance from the hit\n     */\n    get hitDistance() {\n        return this._hitDistance;\n    }\n    /**\n     * Sets the distance from the start point to the hit point\n     * @param distance\n     */\n    setHitDistance(distance) {\n        this._hitDistance = distance;\n    }\n    /**\n     * Resets all the values to default\n     */\n    reset() {\n        super.reset();\n        this._hitDistance = 0;\n    }\n}\n//# sourceMappingURL=proximityCastResult.js.map","import { CastingResult } from \"./castingResult.js\";\n/**\n * Class representing a contact point produced in a shape cast\n */\nexport class ShapeCastResult extends CastingResult {\n    constructor() {\n        super(...arguments);\n        this._hitFraction = 0;\n    }\n    /**\n     * Gets the hit fraction along the casting ray\n     */\n    get hitFraction() {\n        return this._hitFraction;\n    }\n    /**\n     * Sets the hit fraction along the casting ray\n     * @param fraction\n     */\n    setHitFraction(fraction) {\n        this._hitFraction = fraction;\n    }\n}\n//# sourceMappingURL=shapeCastResult.js.map","import { PostProcess } from \"./postProcess.js\";\n\n/**\n * Extracts highlights from the image\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses\n */\nexport class HighlightsPostProcess extends PostProcess {\n    /**\n     * Gets a string identifying the name of the class\n     * @returns \"HighlightsPostProcess\" string\n     */\n    getClassName() {\n        return \"HighlightsPostProcess\";\n    }\n    /**\n     * Extracts highlights from the image\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses\n     * @param name The name of the effect.\n     * @param options The required width/height ratio to downsize to before computing the render pass.\n     * @param camera The camera to apply the render pass to.\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n     * @param engine The engine which the post process will be applied. (default: current engine)\n     * @param reusable If the post process can be reused on the same frame. (default: false)\n     * @param textureType Type of texture for the post process (default: Engine.TEXTURETYPE_UNSIGNED_BYTE)\n     */\n    constructor(name, options, camera, samplingMode, engine, reusable, textureType = 0) {\n        super(name, \"highlights\", null, null, options, camera, samplingMode, engine, reusable, null, textureType);\n    }\n    _gatherImports(useWebGPU, list) {\n        if (useWebGPU) {\n            this._webGPUReady = true;\n            list.push(Promise.all([import(\"../ShadersWGSL/highlights.fragment.js\")]));\n        }\n        else {\n            list.push(Promise.all([import(\"../Shaders/highlights.fragment.js\")]));\n        }\n        super._gatherImports(useWebGPU, list);\n    }\n}\n//# sourceMappingURL=highlightsPostProcess.js.map","import { Texture } from \"../../../Materials/Textures/texture.js\";\nimport { PostProcess } from \"../../../PostProcesses/postProcess.js\";\nimport { PostProcessRenderPipeline } from \"../../../PostProcesses/RenderPipeline/postProcessRenderPipeline.js\";\nimport { PostProcessRenderEffect } from \"../../../PostProcesses/RenderPipeline/postProcessRenderEffect.js\";\nimport { RawTexture } from \"../../../Materials/Textures/rawTexture.js\";\n\nimport \"../../../PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent.js\";\nimport \"../../../Shaders/chromaticAberration.fragment.js\";\nimport \"../../../Shaders/lensHighlights.fragment.js\";\nimport \"../../../Shaders/depthOfField.fragment.js\";\nimport { RandomRange } from \"../../../Maths/math.scalar.functions.js\";\n/**\n * BABYLON.JS Chromatic Aberration GLSL Shader\n * Author: Olivier Guyot\n * Separates very slightly R, G and B colors on the edges of the screen\n * Inspired by Francois Tarlier & Martins Upitis\n */\nexport class LensRenderingPipeline extends PostProcessRenderPipeline {\n    /**\n     * @constructor\n     *\n     * Effect parameters are as follow:\n     * {\n     *      chromatic_aberration: number;       // from 0 to x (1 for realism)\n     *      edge_blur: number;                  // from 0 to x (1 for realism)\n     *      distortion: number;                 // from 0 to x (1 for realism), note that this will effect the pointer position precision\n     *      grain_amount: number;               // from 0 to 1\n     *      grain_texture: BABYLON.Texture;     // texture to use for grain effect; if unset, use random B&W noise\n     *      dof_focus_distance: number;         // depth-of-field: focus distance; unset to disable (disabled by default)\n     *      dof_aperture: number;               // depth-of-field: focus blur bias (default: 1)\n     *      dof_darken: number;                 // depth-of-field: darken that which is out of focus (from 0 to 1, disabled by default)\n     *      dof_pentagon: boolean;              // depth-of-field: makes a pentagon-like \"bokeh\" effect\n     *      dof_gain: number;                   // depth-of-field: highlights gain; unset to disable (disabled by default)\n     *      dof_threshold: number;              // depth-of-field: highlights threshold (default: 1)\n     *      blur_noise: boolean;                // add a little bit of noise to the blur (default: true)\n     * }\n     * Note: if an effect parameter is unset, effect is disabled\n     *\n     * @param name The rendering pipeline name\n     * @param parameters - An object containing all parameters (see above)\n     * @param scene The scene linked to this pipeline\n     * @param ratio The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\n     * @param cameras The array of cameras that the rendering pipeline will be attached to\n     */\n    constructor(name, parameters, scene, ratio = 1.0, cameras) {\n        super(scene.getEngine(), name);\n        // Lens effects can be of the following:\n        // - chromatic aberration (slight shift of RGB colors)\n        // - blur on the edge of the lens\n        // - lens distortion\n        // - depth-of-field blur & highlights enhancing\n        // - depth-of-field 'bokeh' effect (shapes appearing in blurred areas)\n        // - grain effect (noise or custom texture)\n        // Two additional texture samplers are needed:\n        // - depth map (for depth-of-field)\n        // - grain texture\n        /**\n         * @ignore\n         * The chromatic aberration PostProcess id in the pipeline\n         */\n        this.LensChromaticAberrationEffect = \"LensChromaticAberrationEffect\";\n        /**\n         * @ignore\n         * The highlights enhancing PostProcess id in the pipeline\n         */\n        this.HighlightsEnhancingEffect = \"HighlightsEnhancingEffect\";\n        /**\n         * @ignore\n         * The depth-of-field PostProcess id in the pipeline\n         */\n        this.LensDepthOfFieldEffect = \"LensDepthOfFieldEffect\";\n        this._pentagonBokehIsEnabled = false;\n        this._scene = scene;\n        // Fetch texture samplers\n        this._depthTexture = scene.enableDepthRenderer().getDepthMap(); // Force depth renderer \"on\"\n        if (parameters.grain_texture) {\n            this._grainTexture = parameters.grain_texture;\n        }\n        else {\n            this._createGrainTexture();\n        }\n        // save parameters\n        this._edgeBlur = parameters.edge_blur ? parameters.edge_blur : 0;\n        this._grainAmount = parameters.grain_amount ? parameters.grain_amount : 0;\n        this._chromaticAberration = parameters.chromatic_aberration ? parameters.chromatic_aberration : 0;\n        this._distortion = parameters.distortion ? parameters.distortion : 0;\n        this._highlightsGain = parameters.dof_gain !== undefined ? parameters.dof_gain : -1;\n        this._highlightsThreshold = parameters.dof_threshold ? parameters.dof_threshold : 1;\n        this._dofDistance = parameters.dof_focus_distance !== undefined ? parameters.dof_focus_distance : -1;\n        this._dofAperture = parameters.dof_aperture ? parameters.dof_aperture : 1;\n        this._dofDarken = parameters.dof_darken ? parameters.dof_darken : 0;\n        this._dofPentagon = parameters.dof_pentagon !== undefined ? parameters.dof_pentagon : true;\n        this._blurNoise = parameters.blur_noise !== undefined ? parameters.blur_noise : true;\n        // Create effects\n        this._createChromaticAberrationPostProcess(ratio);\n        this._createHighlightsPostProcess(ratio);\n        this._createDepthOfFieldPostProcess(ratio / 4);\n        // Set up pipeline\n        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.LensChromaticAberrationEffect, () => {\n            return this._chromaticAberrationPostProcess;\n        }, true));\n        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.HighlightsEnhancingEffect, () => {\n            return this._highlightsPostProcess;\n        }, true));\n        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), this.LensDepthOfFieldEffect, () => {\n            return this._depthOfFieldPostProcess;\n        }, true));\n        if (this._highlightsGain === -1) {\n            this._disableEffect(this.HighlightsEnhancingEffect, null);\n        }\n        // Finish\n        scene.postProcessRenderPipelineManager.addPipeline(this);\n        if (cameras) {\n            scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(name, cameras);\n        }\n    }\n    /**\n     * Get the class name\n     * @returns \"LensRenderingPipeline\"\n     */\n    getClassName() {\n        return \"LensRenderingPipeline\";\n    }\n    // Properties\n    /**\n     * Gets associated scene\n     */\n    get scene() {\n        return this._scene;\n    }\n    /**\n     * Gets or sets the edge blur\n     */\n    get edgeBlur() {\n        return this._edgeBlur;\n    }\n    set edgeBlur(value) {\n        this.setEdgeBlur(value);\n    }\n    /**\n     * Gets or sets the grain amount\n     */\n    get grainAmount() {\n        return this._grainAmount;\n    }\n    set grainAmount(value) {\n        this.setGrainAmount(value);\n    }\n    /**\n     * Gets or sets the chromatic aberration amount\n     */\n    get chromaticAberration() {\n        return this._chromaticAberration;\n    }\n    set chromaticAberration(value) {\n        this.setChromaticAberration(value);\n    }\n    /**\n     * Gets or sets the depth of field aperture\n     */\n    get dofAperture() {\n        return this._dofAperture;\n    }\n    set dofAperture(value) {\n        this.setAperture(value);\n    }\n    /**\n     * Gets or sets the edge distortion\n     */\n    get edgeDistortion() {\n        return this._distortion;\n    }\n    set edgeDistortion(value) {\n        this.setEdgeDistortion(value);\n    }\n    /**\n     * Gets or sets the depth of field distortion\n     */\n    get dofDistortion() {\n        return this._dofDistance;\n    }\n    set dofDistortion(value) {\n        this.setFocusDistance(value);\n    }\n    /**\n     * Gets or sets the darken out of focus amount\n     */\n    get darkenOutOfFocus() {\n        return this._dofDarken;\n    }\n    set darkenOutOfFocus(value) {\n        this.setDarkenOutOfFocus(value);\n    }\n    /**\n     * Gets or sets a boolean indicating if blur noise is enabled\n     */\n    get blurNoise() {\n        return this._blurNoise;\n    }\n    set blurNoise(value) {\n        this._blurNoise = value;\n    }\n    /**\n     * Gets or sets a boolean indicating if pentagon bokeh is enabled\n     */\n    get pentagonBokeh() {\n        return this._pentagonBokehIsEnabled;\n    }\n    set pentagonBokeh(value) {\n        if (value) {\n            this.enablePentagonBokeh();\n        }\n        else {\n            this.disablePentagonBokeh();\n        }\n    }\n    /**\n     * Gets or sets the highlight grain amount\n     */\n    get highlightsGain() {\n        return this._highlightsGain;\n    }\n    set highlightsGain(value) {\n        this.setHighlightsGain(value);\n    }\n    /**\n     * Gets or sets the highlight threshold\n     */\n    get highlightsThreshold() {\n        return this._highlightsThreshold;\n    }\n    set highlightsThreshold(value) {\n        this.setHighlightsThreshold(value);\n    }\n    // public methods (self explanatory)\n    /**\n     * Sets the amount of blur at the edges\n     * @param amount blur amount\n     */\n    setEdgeBlur(amount) {\n        this._edgeBlur = amount;\n    }\n    /**\n     * Sets edge blur to 0\n     */\n    disableEdgeBlur() {\n        this._edgeBlur = 0;\n    }\n    /**\n     * Sets the amount of grain\n     * @param amount Amount of grain\n     */\n    setGrainAmount(amount) {\n        this._grainAmount = amount;\n    }\n    /**\n     * Set grain amount to 0\n     */\n    disableGrain() {\n        this._grainAmount = 0;\n    }\n    /**\n     * Sets the chromatic aberration amount\n     * @param amount amount of chromatic aberration\n     */\n    setChromaticAberration(amount) {\n        this._chromaticAberration = amount;\n    }\n    /**\n     * Sets chromatic aberration amount to 0\n     */\n    disableChromaticAberration() {\n        this._chromaticAberration = 0;\n    }\n    /**\n     * Sets the EdgeDistortion amount\n     * @param amount amount of EdgeDistortion\n     */\n    setEdgeDistortion(amount) {\n        this._distortion = amount;\n    }\n    /**\n     * Sets edge distortion to 0\n     */\n    disableEdgeDistortion() {\n        this._distortion = 0;\n    }\n    /**\n     * Sets the FocusDistance amount\n     * @param amount amount of FocusDistance\n     */\n    setFocusDistance(amount) {\n        this._dofDistance = amount;\n    }\n    /**\n     * Disables depth of field\n     */\n    disableDepthOfField() {\n        this._dofDistance = -1;\n    }\n    /**\n     * Sets the Aperture amount\n     * @param amount amount of Aperture\n     */\n    setAperture(amount) {\n        this._dofAperture = amount;\n    }\n    /**\n     * Sets the DarkenOutOfFocus amount\n     * @param amount amount of DarkenOutOfFocus\n     */\n    setDarkenOutOfFocus(amount) {\n        this._dofDarken = amount;\n    }\n    /**\n     * Creates a pentagon bokeh effect\n     */\n    enablePentagonBokeh() {\n        this._highlightsPostProcess.updateEffect(\"#define PENTAGON\\n\");\n        this._pentagonBokehIsEnabled = true;\n    }\n    /**\n     * Disables the pentagon bokeh effect\n     */\n    disablePentagonBokeh() {\n        this._pentagonBokehIsEnabled = false;\n        this._highlightsPostProcess.updateEffect();\n    }\n    /**\n     * Enables noise blur\n     */\n    enableNoiseBlur() {\n        this._blurNoise = true;\n    }\n    /**\n     * Disables noise blur\n     */\n    disableNoiseBlur() {\n        this._blurNoise = false;\n    }\n    /**\n     * Sets the HighlightsGain amount\n     * @param amount amount of HighlightsGain\n     */\n    setHighlightsGain(amount) {\n        this._highlightsGain = amount;\n    }\n    /**\n     * Sets the HighlightsThreshold amount\n     * @param amount amount of HighlightsThreshold\n     */\n    setHighlightsThreshold(amount) {\n        if (this._highlightsGain === -1) {\n            this._highlightsGain = 1.0;\n        }\n        this._highlightsThreshold = amount;\n    }\n    /**\n     * Disables highlights\n     */\n    disableHighlights() {\n        this._highlightsGain = -1;\n    }\n    /**\n     * Removes the internal pipeline assets and detaches the pipeline from the scene cameras\n     * @param disableDepthRender If the scene's depth rendering should be disabled (default: false)\n     */\n    dispose(disableDepthRender = false) {\n        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras);\n        this._chromaticAberrationPostProcess = null;\n        this._highlightsPostProcess = null;\n        this._depthOfFieldPostProcess = null;\n        this._grainTexture.dispose();\n        if (disableDepthRender) {\n            this._scene.disableDepthRenderer();\n        }\n    }\n    // colors shifting and distortion\n    _createChromaticAberrationPostProcess(ratio) {\n        this._chromaticAberrationPostProcess = new PostProcess(\"LensChromaticAberration\", \"chromaticAberration\", [\"chromatic_aberration\", \"screen_width\", \"screen_height\", \"direction\", \"radialIntensity\", \"centerPosition\"], // uniforms\n        [], // samplers\n        ratio, null, Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false);\n        this._chromaticAberrationPostProcess.onApply = (effect) => {\n            effect.setFloat(\"chromatic_aberration\", this._chromaticAberration);\n            effect.setFloat(\"screen_width\", this._scene.getEngine().getRenderWidth());\n            effect.setFloat(\"screen_height\", this._scene.getEngine().getRenderHeight());\n            effect.setFloat(\"radialIntensity\", 1);\n            effect.setFloat2(\"direction\", 17, 17);\n            effect.setFloat2(\"centerPosition\", 0.5, 0.5);\n        };\n    }\n    // highlights enhancing\n    _createHighlightsPostProcess(ratio) {\n        this._highlightsPostProcess = new PostProcess(\"LensHighlights\", \"lensHighlights\", [\"gain\", \"threshold\", \"screen_width\", \"screen_height\"], // uniforms\n        [], // samplers\n        ratio, null, Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, this._dofPentagon ? \"#define PENTAGON\\n\" : \"\");\n        this._highlightsPostProcess.externalTextureSamplerBinding = true;\n        this._highlightsPostProcess.onApply = (effect) => {\n            effect.setFloat(\"gain\", this._highlightsGain);\n            effect.setFloat(\"threshold\", this._highlightsThreshold);\n            effect.setTextureFromPostProcess(\"textureSampler\", this._chromaticAberrationPostProcess);\n            effect.setFloat(\"screen_width\", this._scene.getEngine().getRenderWidth());\n            effect.setFloat(\"screen_height\", this._scene.getEngine().getRenderHeight());\n        };\n    }\n    // colors shifting and distortion\n    _createDepthOfFieldPostProcess(ratio) {\n        this._depthOfFieldPostProcess = new PostProcess(\"LensDepthOfField\", \"depthOfField\", [\n            \"grain_amount\",\n            \"blur_noise\",\n            \"screen_width\",\n            \"screen_height\",\n            \"distortion\",\n            \"dof_enabled\",\n            \"screen_distance\",\n            \"aperture\",\n            \"darken\",\n            \"edge_blur\",\n            \"highlights\",\n            \"near\",\n            \"far\",\n        ], [\"depthSampler\", \"grainSampler\", \"highlightsSampler\"], ratio, null, Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false);\n        this._depthOfFieldPostProcess.externalTextureSamplerBinding = true;\n        this._depthOfFieldPostProcess.onApply = (effect) => {\n            effect.setTexture(\"depthSampler\", this._depthTexture);\n            effect.setTexture(\"grainSampler\", this._grainTexture);\n            effect.setTextureFromPostProcess(\"textureSampler\", this._highlightsPostProcess);\n            effect.setTextureFromPostProcess(\"highlightsSampler\", this._depthOfFieldPostProcess);\n            effect.setFloat(\"grain_amount\", this._grainAmount);\n            effect.setBool(\"blur_noise\", this._blurNoise);\n            effect.setFloat(\"screen_width\", this._scene.getEngine().getRenderWidth());\n            effect.setFloat(\"screen_height\", this._scene.getEngine().getRenderHeight());\n            effect.setFloat(\"distortion\", this._distortion);\n            effect.setBool(\"dof_enabled\", this._dofDistance !== -1);\n            effect.setFloat(\"screen_distance\", 1.0 / (0.1 - 1.0 / this._dofDistance));\n            effect.setFloat(\"aperture\", this._dofAperture);\n            effect.setFloat(\"darken\", this._dofDarken);\n            effect.setFloat(\"edge_blur\", this._edgeBlur);\n            effect.setBool(\"highlights\", this._highlightsGain !== -1);\n            if (this._scene.activeCamera) {\n                effect.setFloat(\"near\", this._scene.activeCamera.minZ);\n                effect.setFloat(\"far\", this._scene.activeCamera.maxZ);\n            }\n        };\n    }\n    // creates a black and white random noise texture, 512x512\n    _createGrainTexture() {\n        const size = 512;\n        const data = new Uint8Array(size * size * 4);\n        for (let index = 0; index < data.length;) {\n            const value = Math.floor(RandomRange(0.42, 0.58) * 255);\n            data[index++] = value;\n            data[index++] = value;\n            data[index++] = value;\n            data[index++] = 255;\n        }\n        const texture = RawTexture.CreateRGBATexture(data, size, size, this._scene, false, false, 2);\n        texture.name = \"LensNoiseTexture\";\n        texture.wrapU = Texture.WRAP_ADDRESSMODE;\n        texture.wrapV = Texture.WRAP_ADDRESSMODE;\n        this._grainTexture = texture;\n    }\n}\n//# sourceMappingURL=lensRenderingPipeline.js.map","\nimport { Engine } from \"../../Engines/engine.js\";\nimport { ShaderMaterial } from \"../../Materials/shaderMaterial.js\";\nimport { MultiRenderTarget } from \"../../Materials/Textures/multiRenderTarget.js\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Matrix, Vector3, Vector4 } from \"../../Maths/math.vector.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\nimport { ProceduralTexture } from \"../../Materials/Textures/Procedurals/proceduralTexture.js\";\nimport { EffectRenderer, EffectWrapper } from \"../../Materials/effectRenderer.js\";\n/**\n * Voxel-based shadow rendering for IBL's.\n * This should not be instanciated directly, as it is part of a scene component\n * @internal\n * @see https://playground.babylonjs.com/#8R5SSE#222\n */\nexport class _IblShadowsVoxelRenderer {\n    /**\n     * Return the voxel grid texture.\n     * @returns The voxel grid texture.\n     */\n    getVoxelGrid() {\n        if (this._triPlanarVoxelization) {\n            return this._voxelGridRT;\n        }\n        else {\n            return this._voxelGridZaxis;\n        }\n    }\n    /**\n     * The debug pass post process\n     * @returns The debug pass post process\n     */\n    getDebugPassPP() {\n        if (!this._voxelDebugPass) {\n            this._createDebugPass();\n        }\n        return this._voxelDebugPass;\n    }\n    /**\n     * Whether to use tri-planar voxelization. More expensive, but can help with artifacts.\n     */\n    get triPlanarVoxelization() {\n        return this._triPlanarVoxelization;\n    }\n    /**\n     * Whether to use tri-planar voxelization. More expensive, but can help with artifacts.\n     */\n    set triPlanarVoxelization(enabled) {\n        if (this._triPlanarVoxelization === enabled) {\n            return;\n        }\n        this._triPlanarVoxelization = enabled;\n        this._disposeVoxelTextures();\n        this._createTextures();\n    }\n    /**\n     * Set the matrix to use for scaling the world space to voxel space\n     * @param matrix The matrix to use for scaling the world space to voxel space\n     */\n    setWorldScaleMatrix(matrix) {\n        this._invWorldScaleMatrix = matrix;\n    }\n    /**\n     * @returns Whether voxelization is currently happening.\n     */\n    isVoxelizationInProgress() {\n        return this._voxelizationInProgress;\n    }\n    /**\n     * Resolution of the voxel grid. The final resolution will be 2^resolutionExp.\n     */\n    get voxelResolutionExp() {\n        return this._voxelResolutionExp;\n    }\n    /**\n     * Resolution of the voxel grid. The final resolution will be 2^resolutionExp.\n     */\n    set voxelResolutionExp(resolutionExp) {\n        if (this._voxelResolutionExp === resolutionExp && this._voxelGridZaxis) {\n            return;\n        }\n        this._voxelResolutionExp = Math.round(Math.min(Math.max(resolutionExp, 3), 9));\n        this._voxelResolution = Math.pow(2.0, this._voxelResolutionExp);\n        this._disposeVoxelTextures();\n        this._createTextures();\n    }\n    /**\n     * Shows only the voxels that were rendered along a particular axis (while using triPlanarVoxelization).\n     * If not set, the combined voxel grid will be shown.\n     * Note: This only works when the debugMipNumber is set to 0 because we don't generate mips for each axis.\n     * @param axis The axis to show (0 = x, 1 = y, 2 = z)\n     */\n    set voxelDebugAxis(axis) {\n        this._voxelDebugAxis = axis;\n    }\n    get voxelDebugAxis() {\n        return this._voxelDebugAxis;\n    }\n    /**\n     * Sets params that control the position and scaling of the debug display on the screen.\n     * @param x Screen X offset of the debug display (0-1)\n     * @param y Screen Y offset of the debug display (0-1)\n     * @param widthScale X scale of the debug display (0-1)\n     * @param heightScale Y scale of the debug display (0-1)\n     */\n    setDebugDisplayParams(x, y, widthScale, heightScale) {\n        this._debugSizeParams.set(x, y, widthScale, heightScale);\n    }\n    /**\n     * The mip level to show in the debug display\n     * @param mipNum The mip level to show in the debug display\n     */\n    setDebugMipNumber(mipNum) {\n        this._debugMipNumber = mipNum;\n    }\n    /**\n     * Sets the name of the debug pass\n     */\n    get debugPassName() {\n        return this._debugPassName;\n    }\n    /**\n     * Enable or disable the debug view for this pass\n     */\n    get voxelDebugEnabled() {\n        return this._voxelDebugEnabled;\n    }\n    set voxelDebugEnabled(enabled) {\n        if (this._voxelDebugEnabled === enabled) {\n            return;\n        }\n        this._voxelDebugEnabled = enabled;\n        if (enabled) {\n            this._voxelSlabDebugRT = new RenderTargetTexture(\"voxelSlabDebug\", { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, this._scene, {\n                generateDepthBuffer: true,\n                generateMipMaps: false,\n                type: 0,\n                format: 5,\n                samplingMode: 1,\n            });\n            this._voxelSlabDebugRT.noPrePassRenderer = true;\n        }\n        if (this._voxelSlabDebugRT) {\n            this._removeVoxelRTs([this._voxelSlabDebugRT]);\n        }\n        // Add the slab debug RT if needed.\n        if (this._voxelDebugEnabled) {\n            this._addRTsForRender([this._voxelSlabDebugRT], this._includedMeshes, this._voxelDebugAxis, 1, true);\n            this._setDebugBindingsBound = this._setDebugBindings.bind(this);\n            this._scene.onBeforeRenderObservable.add(this._setDebugBindingsBound);\n        }\n        else {\n            this._scene.onBeforeRenderObservable.removeCallback(this._setDebugBindingsBound);\n        }\n    }\n    /**\n     * Creates the debug post process effect for this pass\n     */\n    _createDebugPass() {\n        const isWebGPU = this._engine.isWebGPU;\n        if (!this._voxelDebugPass) {\n            const debugOptions = {\n                width: this._engine.getRenderWidth(),\n                height: this._engine.getRenderHeight(),\n                textureFormat: 5,\n                textureType: 0,\n                samplingMode: 1,\n                uniforms: [\"sizeParams\", \"mipNumber\"],\n                samplers: [\"voxelTexture\", \"voxelSlabTexture\"],\n                engine: this._engine,\n                reusable: false,\n                shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n                extraInitializations: (useWebGPU, list) => {\n                    if (this._isVoxelGrid3D) {\n                        if (useWebGPU) {\n                            list.push(import(\"../../ShadersWGSL/iblVoxelGrid3dDebug.fragment.js\"));\n                        }\n                        else {\n                            list.push(import(\"../../Shaders/iblVoxelGrid3dDebug.fragment.js\"));\n                        }\n                        return;\n                    }\n                    if (useWebGPU) {\n                        list.push(import(\"../../ShadersWGSL/iblVoxelGrid2dArrayDebug.fragment.js\"));\n                    }\n                    else {\n                        list.push(import(\"../../Shaders/iblVoxelGrid2dArrayDebug.fragment.js\"));\n                    }\n                },\n            };\n            this._voxelDebugPass = new PostProcess(this.debugPassName, this._isVoxelGrid3D ? \"iblVoxelGrid3dDebug\" : \"iblVoxelGrid2dArrayDebug\", debugOptions);\n            this._voxelDebugPass.onApplyObservable.add((effect) => {\n                if (this._voxelDebugAxis === 0) {\n                    effect.setTexture(\"voxelTexture\", this._voxelGridXaxis);\n                }\n                else if (this._voxelDebugAxis === 1) {\n                    effect.setTexture(\"voxelTexture\", this._voxelGridYaxis);\n                }\n                else if (this._voxelDebugAxis === 2) {\n                    effect.setTexture(\"voxelTexture\", this._voxelGridZaxis);\n                }\n                else {\n                    effect.setTexture(\"voxelTexture\", this.getVoxelGrid());\n                }\n                effect.setTexture(\"voxelSlabTexture\", this._voxelSlabDebugRT);\n                effect.setVector4(\"sizeParams\", this._debugSizeParams);\n                effect.setFloat(\"mipNumber\", this._debugMipNumber);\n            });\n        }\n    }\n    /**\n     * Instanciates the voxel renderer\n     * @param scene Scene to attach to\n     * @param iblShadowsRenderPipeline The render pipeline this pass is associated with\n     * @param resolutionExp Resolution of the voxel grid. The final resolution will be 2^resolutionExp.\n     * @param triPlanarVoxelization Whether to use tri-planar voxelization. More expensive, but can help with artifacts.\n     * @returns The voxel renderer\n     */\n    constructor(scene, iblShadowsRenderPipeline, resolutionExp = 6, triPlanarVoxelization = true) {\n        this._voxelMrtsXaxis = [];\n        this._voxelMrtsYaxis = [];\n        this._voxelMrtsZaxis = [];\n        this._isVoxelGrid3D = true;\n        /**\n         * Observable that triggers when the voxelization is complete\n         */\n        this.onVoxelizationCompleteObservable = new Observable();\n        this._renderTargets = [];\n        this._triPlanarVoxelization = true;\n        this._voxelizationInProgress = false;\n        this._invWorldScaleMatrix = Matrix.Identity();\n        this._voxelResolution = 64;\n        this._voxelResolutionExp = 6;\n        this._mipArray = [];\n        this._voxelDebugEnabled = false;\n        this._voxelDebugAxis = -1;\n        this._debugSizeParams = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._includedMeshes = [];\n        this._debugMipNumber = 0;\n        this._debugPassName = \"Voxelization Debug Pass\";\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        this._triPlanarVoxelization = triPlanarVoxelization;\n        if (!this._engine.getCaps().drawBuffersExtension) {\n            Logger.Error(\"Can't do voxel rendering without the draw buffers extension.\");\n        }\n        const isWebGPU = this._engine.isWebGPU;\n        this._maxDrawBuffers = this._engine.getCaps().maxDrawBuffers || 0;\n        this._copyMipEffectRenderer = new EffectRenderer(this._engine);\n        this._copyMipEffectWrapper = new EffectWrapper({\n            engine: this._engine,\n            fragmentShader: \"copyTexture3DLayerToTexture\",\n            useShaderStore: true,\n            uniformNames: [\"layerNum\"],\n            samplerNames: [\"textureSampler\"],\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await import(\"../../ShadersWGSL/copyTexture3DLayerToTexture.fragment.js\");\n                }\n                else {\n                    await import(\"../../Shaders/copyTexture3DLayerToTexture.fragment.js\");\n                }\n            },\n        });\n        this.voxelResolutionExp = resolutionExp;\n    }\n    _generateMipMaps() {\n        const iterations = Math.ceil(Math.log2(this._voxelResolution));\n        for (let i = 1; i < iterations + 1; i++) {\n            this._generateMipMap(i);\n        }\n    }\n    _generateMipMap(lodLevel) {\n        // Generate a mip map for the given level by triggering the render of the procedural mip texture.\n        const mipTarget = this._mipArray[lodLevel - 1];\n        if (!mipTarget) {\n            return;\n        }\n        mipTarget.setTexture(\"srcMip\", lodLevel === 1 ? this.getVoxelGrid() : this._mipArray[lodLevel - 2]);\n        mipTarget.render();\n    }\n    _copyMipMaps() {\n        const iterations = Math.ceil(Math.log2(this._voxelResolution));\n        for (let i = 1; i < iterations + 1; i++) {\n            this._copyMipMap(i);\n        }\n    }\n    _copyMipMap(lodLevel) {\n        // Now, copy this mip into the mip chain of the voxel grid.\n        // TODO - this currently isn't working. \"textureSampler\" isn't being properly set to mipTarget.\n        const mipTarget = this._mipArray[lodLevel - 1];\n        if (!mipTarget) {\n            return;\n        }\n        const voxelGrid = this.getVoxelGrid();\n        let rt;\n        if (voxelGrid instanceof RenderTargetTexture && voxelGrid.renderTarget) {\n            rt = voxelGrid.renderTarget;\n        }\n        else {\n            rt = voxelGrid._rtWrapper;\n        }\n        if (rt) {\n            this._copyMipEffectRenderer.saveStates();\n            const bindSize = mipTarget.getSize().width;\n            // Render to each layer of the voxel grid.\n            for (let layer = 0; layer < bindSize; layer++) {\n                this._engine.bindFramebuffer(rt, 0, bindSize, bindSize, true, lodLevel, layer);\n                this._copyMipEffectRenderer.applyEffectWrapper(this._copyMipEffectWrapper);\n                this._copyMipEffectWrapper.effect.setTexture(\"textureSampler\", mipTarget);\n                this._copyMipEffectWrapper.effect.setInt(\"layerNum\", layer);\n                this._copyMipEffectRenderer.draw();\n                this._engine.unBindFramebuffer(rt, true);\n            }\n            this._copyMipEffectRenderer.restoreStates();\n        }\n    }\n    _computeNumberOfSlabs() {\n        return Math.ceil(this._voxelResolution / this._maxDrawBuffers);\n    }\n    _createTextures() {\n        const isWebGPU = this._engine.isWebGPU;\n        const size = {\n            width: this._voxelResolution,\n            height: this._voxelResolution,\n            layers: this._isVoxelGrid3D ? undefined : this._voxelResolution,\n            depth: this._isVoxelGrid3D ? this._voxelResolution : undefined,\n        };\n        const voxelAxisOptions = {\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            type: 0,\n            format: 6,\n            samplingMode: 1,\n        };\n        // We can render up to maxDrawBuffers voxel slices of the grid per render.\n        // We call this a slab.\n        const numSlabs = this._computeNumberOfSlabs();\n        const voxelCombinedOptions = {\n            generateDepthBuffer: false,\n            generateMipMaps: true,\n            type: 0,\n            format: 6,\n            samplingMode: 4,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await import(\"../../ShadersWGSL/iblCombineVoxelGrids.fragment.js\");\n                }\n                else {\n                    await import(\"../../Shaders/iblCombineVoxelGrids.fragment.js\");\n                }\n            },\n        };\n        if (this._triPlanarVoxelization) {\n            this._voxelGridXaxis = new RenderTargetTexture(\"voxelGridXaxis\", size, this._scene, voxelAxisOptions);\n            this._voxelGridYaxis = new RenderTargetTexture(\"voxelGridYaxis\", size, this._scene, voxelAxisOptions);\n            this._voxelGridZaxis = new RenderTargetTexture(\"voxelGridZaxis\", size, this._scene, voxelAxisOptions);\n            this._voxelMrtsXaxis = this._createVoxelMRTs(\"x_axis_\", this._voxelGridXaxis, numSlabs);\n            this._voxelMrtsYaxis = this._createVoxelMRTs(\"y_axis_\", this._voxelGridYaxis, numSlabs);\n            this._voxelMrtsZaxis = this._createVoxelMRTs(\"z_axis_\", this._voxelGridZaxis, numSlabs);\n            this._voxelGridRT = new ProceduralTexture(\"combinedVoxelGrid\", size, \"iblCombineVoxelGrids\", this._scene, voxelCombinedOptions, false);\n            this._scene.proceduralTextures.splice(this._scene.proceduralTextures.indexOf(this._voxelGridRT), 1);\n            this._voxelGridRT.setFloat(\"layer\", 0.0);\n            this._voxelGridRT.setTexture(\"voxelXaxisSampler\", this._voxelGridXaxis);\n            this._voxelGridRT.setTexture(\"voxelYaxisSampler\", this._voxelGridYaxis);\n            this._voxelGridRT.setTexture(\"voxelZaxisSampler\", this._voxelGridZaxis);\n            // We will render this only after voxelization is completed for the 3 axes.\n            this._voxelGridRT.autoClear = false;\n            this._voxelGridRT.wrapU = Texture.CLAMP_ADDRESSMODE;\n            this._voxelGridRT.wrapV = Texture.CLAMP_ADDRESSMODE;\n        }\n        else {\n            this._voxelGridZaxis = new RenderTargetTexture(\"voxelGridZaxis\", size, this._scene, voxelCombinedOptions);\n            this._voxelMrtsZaxis = this._createVoxelMRTs(\"z_axis_\", this._voxelGridZaxis, numSlabs);\n        }\n        const generateVoxelMipOptions = {\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            type: 0,\n            format: 6,\n            samplingMode: 1,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await import(\"../../ShadersWGSL/iblGenerateVoxelMip.fragment.js\");\n                }\n                else {\n                    await import(\"../../Shaders/iblGenerateVoxelMip.fragment.js\");\n                }\n            },\n        };\n        this._mipArray = new Array(Math.ceil(Math.log2(this._voxelResolution)));\n        for (let mipIdx = 1; mipIdx <= this._mipArray.length; mipIdx++) {\n            const mipDim = this._voxelResolution >> mipIdx;\n            const mipSize = { width: mipDim, height: mipDim, depth: mipDim };\n            this._mipArray[mipIdx - 1] = new ProceduralTexture(\"voxelMip\" + mipIdx, mipSize, \"iblGenerateVoxelMip\", this._scene, generateVoxelMipOptions, false);\n            this._scene.proceduralTextures.splice(this._scene.proceduralTextures.indexOf(this._mipArray[mipIdx - 1]), 1);\n            const mipTarget = this._mipArray[mipIdx - 1];\n            mipTarget.autoClear = false;\n            mipTarget.wrapU = Texture.CLAMP_ADDRESSMODE;\n            mipTarget.wrapV = Texture.CLAMP_ADDRESSMODE;\n            mipTarget.setTexture(\"srcMip\", mipIdx > 1 ? this._mipArray[mipIdx - 2] : this.getVoxelGrid());\n            mipTarget.setInt(\"layerNum\", 0);\n        }\n        this._createVoxelMaterials();\n    }\n    _createVoxelMRTs(name, voxelRT, numSlabs) {\n        voxelRT.wrapU = Texture.CLAMP_ADDRESSMODE;\n        voxelRT.wrapV = Texture.CLAMP_ADDRESSMODE;\n        voxelRT.noPrePassRenderer = true;\n        const mrtArray = [];\n        const targetTypes = new Array(this._maxDrawBuffers).fill(this._isVoxelGrid3D ? 32879 : 35866);\n        for (let mrt_index = 0; mrt_index < numSlabs; mrt_index++) {\n            let layerIndices = new Array(this._maxDrawBuffers).fill(0);\n            layerIndices = layerIndices.map((value, index) => mrt_index * this._maxDrawBuffers + index);\n            let textureNames = new Array(this._maxDrawBuffers).fill(\"\");\n            textureNames = textureNames.map((value, index) => \"voxel_grid_\" + name + (mrt_index * this._maxDrawBuffers + index));\n            const mrt = new MultiRenderTarget(\"mrt_\" + name + mrt_index, { width: this._voxelResolution, height: this._voxelResolution, depth: this._isVoxelGrid3D ? this._voxelResolution : undefined }, this._maxDrawBuffers, // number of draw buffers\n            this._scene, {\n                types: new Array(this._maxDrawBuffers).fill(0),\n                samplingModes: new Array(this._maxDrawBuffers).fill(3),\n                generateMipMaps: false,\n                targetTypes,\n                formats: new Array(this._maxDrawBuffers).fill(6),\n                faceIndex: new Array(this._maxDrawBuffers).fill(0),\n                layerIndex: layerIndices,\n                layerCounts: new Array(this._maxDrawBuffers).fill(this._voxelResolution),\n                generateDepthBuffer: false,\n                generateStencilBuffer: false,\n            }, textureNames);\n            mrt.clearColor = new Color4(0, 0, 0, 1);\n            mrt.noPrePassRenderer = true;\n            for (let i = 0; i < this._maxDrawBuffers; i++) {\n                mrt.setInternalTexture(voxelRT.getInternalTexture(), i);\n            }\n            mrtArray.push(mrt);\n        }\n        return mrtArray;\n    }\n    _disposeVoxelTextures() {\n        this._stopVoxelization();\n        for (let i = 0; i < this._voxelMrtsZaxis.length; i++) {\n            if (this._triPlanarVoxelization) {\n                this._voxelMrtsXaxis[i].dispose(true);\n                this._voxelMrtsYaxis[i].dispose(true);\n            }\n            this._voxelMrtsZaxis[i].dispose(true);\n        }\n        if (this._triPlanarVoxelization) {\n            this._voxelGridXaxis?.dispose();\n            this._voxelGridYaxis?.dispose();\n            this._voxelGridRT?.dispose();\n        }\n        this._voxelGridZaxis?.dispose();\n        this._mipArray.forEach((mip) => {\n            mip.dispose();\n        });\n        this._voxelMaterial?.dispose();\n        this._voxelSlabDebugMaterial?.dispose();\n        this._mipArray = [];\n        this._voxelMrtsXaxis = [];\n        this._voxelMrtsYaxis = [];\n        this._voxelMrtsZaxis = [];\n    }\n    _createVoxelMaterials() {\n        const isWebGPU = this._engine.isWebGPU;\n        this._voxelMaterial = new ShaderMaterial(\"voxelization\", this._scene, \"iblVoxelGrid\", {\n            uniforms: [\"world\", \"viewMatrix\", \"invWorldScale\", \"nearPlane\", \"farPlane\", \"stepSize\"],\n            defines: [\"MAX_DRAW_BUFFERS \" + this._maxDrawBuffers],\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/iblVoxelGrid.fragment.js\"), import(\"../../ShadersWGSL/iblVoxelGrid.vertex.js\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/iblVoxelGrid.fragment.js\"), import(\"../../Shaders/iblVoxelGrid.vertex.js\")]);\n                }\n            },\n        });\n        this._voxelMaterial.cullBackFaces = false;\n        this._voxelMaterial.backFaceCulling = false;\n        this._voxelMaterial.depthFunction = Engine.ALWAYS;\n        this._voxelSlabDebugMaterial = new ShaderMaterial(\"voxelSlabDebug\", this._scene, \"iblVoxelSlabDebug\", {\n            uniforms: [\"world\", \"viewMatrix\", \"cameraViewMatrix\", \"projection\", \"invWorldScale\", \"nearPlane\", \"farPlane\", \"stepSize\"],\n            defines: [\"MAX_DRAW_BUFFERS \" + this._maxDrawBuffers],\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/iblVoxelSlabDebug.fragment.js\"), import(\"../../ShadersWGSL/iblVoxelSlabDebug.vertex.js\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/iblVoxelSlabDebug.fragment.js\"), import(\"../../Shaders/iblVoxelSlabDebug.vertex.js\")]);\n                }\n            },\n        });\n    }\n    _setDebugBindings() {\n        this._voxelSlabDebugMaterial.setMatrix(\"projection\", this._scene.activeCamera.getProjectionMatrix());\n        this._voxelSlabDebugMaterial.setMatrix(\"cameraViewMatrix\", this._scene.activeCamera.getViewMatrix());\n    }\n    /**\n     * Checks if the voxel renderer is ready to voxelize scene\n     * @returns true if the voxel renderer is ready to voxelize scene\n     */\n    isReady() {\n        let allReady = this.getVoxelGrid().isReady();\n        for (let i = 0; i < this._mipArray.length; i++) {\n            const mipReady = this._mipArray[i].isReady();\n            allReady && (allReady = mipReady);\n        }\n        if (!allReady || this._voxelizationInProgress) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * If the MRT's are already in the list of render targets, this will\n     * remove them so that they don't get rendered again.\n     */\n    _stopVoxelization() {\n        // If the MRT's are already in the list of render targets, remove them.\n        this._removeVoxelRTs(this._voxelMrtsXaxis);\n        this._removeVoxelRTs(this._voxelMrtsYaxis);\n        this._removeVoxelRTs(this._voxelMrtsZaxis);\n    }\n    _removeVoxelRTs(rts) {\n        // const currentRTs = this._scene.customRenderTargets;\n        const rtIdx = this._renderTargets.findIndex((rt) => {\n            if (rt === rts[0])\n                return true;\n            return false;\n        });\n        if (rtIdx >= 0) {\n            this._renderTargets.splice(rtIdx, rts.length);\n        }\n        else {\n            const rtIdx = this._scene.customRenderTargets.findIndex((rt) => {\n                if (rt === rts[0])\n                    return true;\n                return false;\n            });\n            if (rtIdx >= 0) {\n                this._scene.customRenderTargets.splice(rtIdx, rts.length);\n            }\n        }\n    }\n    /**\n     * Renders voxel grid of scene for IBL shadows\n     * @param includedMeshes\n     */\n    updateVoxelGrid(includedMeshes) {\n        this._stopVoxelization();\n        this._includedMeshes = includedMeshes;\n        this._voxelizationInProgress = true;\n        if (this._triPlanarVoxelization) {\n            this._addRTsForRender(this._voxelMrtsXaxis, includedMeshes, 0);\n            this._addRTsForRender(this._voxelMrtsYaxis, includedMeshes, 1);\n            this._addRTsForRender(this._voxelMrtsZaxis, includedMeshes, 2);\n        }\n        else {\n            this._addRTsForRender(this._voxelMrtsZaxis, includedMeshes, 2);\n        }\n        if (this._voxelDebugEnabled) {\n            this._addRTsForRender([this._voxelSlabDebugRT], includedMeshes, this._voxelDebugAxis, 1, true);\n        }\n        this._renderVoxelGridBound = this._renderVoxelGrid.bind(this);\n        this._scene.onAfterRenderObservable.add(this._renderVoxelGridBound);\n    }\n    _renderVoxelGrid() {\n        if (this._voxelizationInProgress) {\n            let allReady = this.getVoxelGrid().isReady();\n            for (let i = 0; i < this._mipArray.length; i++) {\n                const mipReady = this._mipArray[i].isReady();\n                allReady && (allReady = mipReady);\n            }\n            for (let i = 0; i < this._renderTargets.length; i++) {\n                const rttReady = this._renderTargets[i].isReadyForRendering();\n                allReady && (allReady = rttReady);\n            }\n            if (allReady) {\n                this._renderTargets.forEach((rt) => {\n                    rt.render();\n                });\n                this._stopVoxelization();\n                if (this._triPlanarVoxelization) {\n                    this._voxelGridRT.render();\n                }\n                this._generateMipMaps();\n                this._copyMipEffectWrapper.effect.whenCompiledAsync().then(() => {\n                    this._copyMipMaps();\n                    this._scene.onAfterRenderObservable.removeCallback(this._renderVoxelGridBound);\n                    this._voxelizationInProgress = false;\n                    this.onVoxelizationCompleteObservable.notifyObservers();\n                });\n            }\n        }\n    }\n    _addRTsForRender(mrts, includedMeshes, axis, shaderType = 0, continuousRender = false) {\n        const slabSize = 1.0 / this._computeNumberOfSlabs();\n        let voxelMaterial;\n        if (shaderType === 0) {\n            voxelMaterial = this._voxelMaterial;\n        }\n        else {\n            voxelMaterial = this._voxelSlabDebugMaterial;\n        }\n        // We need to update the world scale uniform for every mesh being rendered to the voxel grid.\n        mrts.forEach((mrt, mrtIndex) => {\n            mrt.renderList = [];\n            const nearPlane = mrtIndex * slabSize;\n            const farPlane = (mrtIndex + 1) * slabSize;\n            const stepSize = slabSize / this._maxDrawBuffers;\n            const cameraPosition = new Vector3(0, 0, 0);\n            let targetPosition = new Vector3(0, 0, 1);\n            if (axis === 0) {\n                targetPosition = new Vector3(1, 0, 0);\n            }\n            else if (axis === 1) {\n                targetPosition = new Vector3(0, 1, 0);\n            }\n            let upDirection = new Vector3(0, 1, 0);\n            if (axis === 1) {\n                upDirection = new Vector3(1, 0, 0);\n            }\n            mrt.onBeforeRenderObservable.add(() => {\n                voxelMaterial.setMatrix(\"viewMatrix\", Matrix.LookAtLH(cameraPosition, targetPosition, upDirection));\n                voxelMaterial.setMatrix(\"invWorldScale\", this._invWorldScaleMatrix);\n                voxelMaterial.setFloat(\"nearPlane\", nearPlane);\n                voxelMaterial.setFloat(\"farPlane\", farPlane);\n                voxelMaterial.setFloat(\"stepSize\", stepSize);\n            });\n            // Set this material on every mesh in the scene (for this RT)\n            if (includedMeshes.length === 0) {\n                return;\n            }\n            includedMeshes.forEach((mesh) => {\n                if (mesh) {\n                    if (mesh.subMeshes && mesh.subMeshes.length > 0) {\n                        mrt.renderList?.push(mesh);\n                        mrt.setMaterialForRendering(mesh, voxelMaterial);\n                    }\n                    mesh.getChildMeshes().forEach((childMesh) => {\n                        if (childMesh.subMeshes && childMesh.subMeshes.length > 0) {\n                            mrt.renderList?.push(childMesh);\n                            mrt.setMaterialForRendering(childMesh, voxelMaterial);\n                        }\n                    });\n                }\n            });\n        });\n        // Add the MRT's to render.\n        if (continuousRender) {\n            mrts.forEach((mrt) => {\n                if (this._scene.customRenderTargets.indexOf(mrt) === -1) {\n                    this._scene.customRenderTargets.push(mrt);\n                }\n            });\n        }\n        else {\n            this._renderTargets = this._renderTargets.concat(mrts);\n        }\n    }\n    /**\n     * Called by the pipeline to resize resources.\n     */\n    resize() {\n        this._voxelSlabDebugRT?.resize({ width: this._scene.getEngine().getRenderWidth(), height: this._scene.getEngine().getRenderHeight() });\n    }\n    /**\n     * Disposes the voxel renderer and associated resources\n     */\n    dispose() {\n        this._disposeVoxelTextures();\n        if (this._voxelSlabDebugRT) {\n            this._removeVoxelRTs([this._voxelSlabDebugRT]);\n            this._voxelSlabDebugRT.dispose();\n        }\n        if (this._voxelDebugPass) {\n            this._voxelDebugPass.dispose();\n        }\n        // TODO - dispose all created voxel materials.\n    }\n}\n//# sourceMappingURL=iblShadowsVoxelRenderer.js.map","\nimport { Matrix, Vector4 } from \"../../Maths/math.vector.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\nimport { GeometryBufferRenderer } from \"../../Rendering/geometryBufferRenderer.js\";\nimport { ProceduralTexture } from \"../../Materials/Textures/Procedurals/proceduralTexture.js\";\n/**\n * Build cdf maps for IBL importance sampling during IBL shadow computation.\n * This should not be instanciated directly, as it is part of a scene component\n * @internal\n */\nexport class _IblShadowsVoxelTracingPass {\n    /**\n     * The opacity of the shadow cast from the voxel grid\n     */\n    get voxelShadowOpacity() {\n        return this._voxelShadowOpacity;\n    }\n    /**\n     * The opacity of the shadow cast from the voxel grid\n     */\n    set voxelShadowOpacity(value) {\n        this._voxelShadowOpacity = value;\n    }\n    /**\n     * The opacity of the screen-space shadow\n     */\n    get ssShadowOpacity() {\n        return this._ssShadowOpacity;\n    }\n    /**\n     * The opacity of the screen-space shadow\n     */\n    set ssShadowOpacity(value) {\n        this._ssShadowOpacity = value;\n    }\n    /**\n     * The number of samples used in the screen space shadow pass.\n     */\n    get sssSamples() {\n        return this._sssSamples;\n    }\n    /**\n     * The number of samples used in the screen space shadow pass.\n     */\n    set sssSamples(value) {\n        this._sssSamples = value;\n    }\n    /**\n     * The stride used in the screen space shadow pass. This controls the distance between samples.\n     */\n    get sssStride() {\n        return this._sssStride;\n    }\n    /**\n     * The stride used in the screen space shadow pass. This controls the distance between samples.\n     */\n    set sssStride(value) {\n        this._sssStride = value;\n    }\n    /**\n     * The maximum distance that the screen-space shadow will be able to occlude.\n     */\n    get sssMaxDist() {\n        return this._sssMaxDist;\n    }\n    /**\n     * The maximum distance that the screen-space shadow will be able to occlude.\n     */\n    set sssMaxDist(value) {\n        this._sssMaxDist = value;\n    }\n    /**\n     * The thickness of the screen-space shadow\n     */\n    get sssThickness() {\n        return this._sssThickness;\n    }\n    /**\n     * The thickness of the screen-space shadow\n     */\n    set sssThickness(value) {\n        this._sssThickness = value;\n    }\n    /**\n     * The bias to apply to the voxel sampling in the direction of the surface normal of the geometry.\n     */\n    get voxelNormalBias() {\n        return this._voxelNormalBias;\n    }\n    set voxelNormalBias(value) {\n        this._voxelNormalBias = value;\n    }\n    /**\n     * The bias to apply to the voxel sampling in the direction of the light.\n     */\n    get voxelDirectionBias() {\n        return this._voxelDirectionBias;\n    }\n    set voxelDirectionBias(value) {\n        this._voxelDirectionBias = value;\n    }\n    /**\n     * The number of directions to sample for the voxel tracing.\n     */\n    get sampleDirections() {\n        return this._sampleDirections;\n    }\n    /**\n     * The number of directions to sample for the voxel tracing.\n     */\n    set sampleDirections(value) {\n        this._sampleDirections = value;\n    }\n    /**\n     * The current rotation of the environment map, in radians.\n     */\n    get envRotation() {\n        return this._envRotation;\n    }\n    /**\n     * The current rotation of the environment map, in radians.\n     */\n    set envRotation(value) {\n        this._envRotation = value;\n    }\n    /**\n     * Returns the output texture of the pass.\n     * @returns The output texture.\n     */\n    getOutputTexture() {\n        return this._outputTexture;\n    }\n    /**\n     * Gets the debug pass post process. This will create the resources for the pass\n     * if they don't already exist.\n     * @returns The post process\n     */\n    getDebugPassPP() {\n        if (!this._debugPassPP) {\n            this._createDebugPass();\n        }\n        return this._debugPassPP;\n    }\n    /**\n     * The name of the debug pass\n     */\n    get debugPassName() {\n        return this._debugPassName;\n    }\n    /**\n     * Set the matrix to use for scaling the world space to voxel space\n     * @param matrix The matrix to use for scaling the world space to voxel space\n     */\n    setWorldScaleMatrix(matrix) {\n        this._invWorldScaleMatrix = matrix;\n    }\n    /**\n     * Render the shadows in color rather than black and white.\n     * This is slightly more expensive than black and white shadows but can be much\n     * more accurate when the strongest lights in the IBL are non-white.\n     */\n    set coloredShadows(value) {\n        this._coloredShadows = value;\n    }\n    get coloredShadows() {\n        return this._coloredShadows;\n    }\n    /**\n     * Sets params that control the position and scaling of the debug display on the screen.\n     * @param x Screen X offset of the debug display (0-1)\n     * @param y Screen Y offset of the debug display (0-1)\n     * @param widthScale X scale of the debug display (0-1)\n     * @param heightScale Y scale of the debug display (0-1)\n     */\n    setDebugDisplayParams(x, y, widthScale, heightScale) {\n        this._debugSizeParams.set(x, y, widthScale, heightScale);\n    }\n    /**\n     * Creates the debug post process effect for this pass\n     */\n    _createDebugPass() {\n        const isWebGPU = this._engine.isWebGPU;\n        if (!this._debugPassPP) {\n            const debugOptions = {\n                width: this._engine.getRenderWidth(),\n                height: this._engine.getRenderHeight(),\n                uniforms: [\"sizeParams\"],\n                samplers: [\"debugSampler\"],\n                engine: this._engine,\n                reusable: true,\n                shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n                extraInitializations: (useWebGPU, list) => {\n                    if (useWebGPU) {\n                        list.push(import(\"../../ShadersWGSL/iblShadowDebug.fragment.js\"));\n                    }\n                    else {\n                        list.push(import(\"../../Shaders/iblShadowDebug.fragment.js\"));\n                    }\n                },\n            };\n            this._debugPassPP = new PostProcess(this.debugPassName, \"iblShadowDebug\", debugOptions);\n            this._debugPassPP.autoClear = false;\n            this._debugPassPP.onApplyObservable.add((effect) => {\n                // update the caustic texture with what we just rendered.\n                effect.setTexture(\"debugSampler\", this._outputTexture);\n                effect.setVector4(\"sizeParams\", this._debugSizeParams);\n            });\n        }\n    }\n    /**\n     * Instantiates the shadow voxel-tracing pass\n     * @param scene Scene to attach to\n     * @param iblShadowsRenderPipeline The IBL shadows render pipeline\n     * @returns The shadow voxel-tracing pass\n     */\n    constructor(scene, iblShadowsRenderPipeline) {\n        this._voxelShadowOpacity = 1.0;\n        this._sssSamples = 16;\n        this._sssStride = 8;\n        this._sssMaxDist = 0.05;\n        this._sssThickness = 0.5;\n        this._ssShadowOpacity = 1.0;\n        this._cameraInvView = Matrix.Identity();\n        this._cameraInvProj = Matrix.Identity();\n        this._invWorldScaleMatrix = Matrix.Identity();\n        this._frameId = 0;\n        this._sampleDirections = 4;\n        this._shadowParameters = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._sssParameters = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._opacityParameters = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._voxelBiasParameters = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._voxelNormalBias = 1.4;\n        this._voxelDirectionBias = 1.75;\n        /**\n         * Is the effect enabled\n         */\n        this.enabled = true;\n        /** Enable the debug view for this pass */\n        this.debugEnabled = false;\n        this._debugPassName = \"Voxel Tracing Debug Pass\";\n        /** The default rotation of the environment map will align the shadows with the default lighting orientation */\n        this._envRotation = 0.0;\n        this._coloredShadows = false;\n        this._debugVoxelMarchEnabled = false;\n        this._debugSizeParams = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        this._renderPipeline = iblShadowsRenderPipeline;\n        this._createTextures();\n    }\n    _createTextures() {\n        const defines = this._createDefines();\n        const isWebGPU = this._engine.isWebGPU;\n        const textureOptions = {\n            type: 0,\n            format: 5,\n            samplingMode: 1,\n            generateDepthBuffer: false,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/iblShadowVoxelTracing.fragment.js\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/iblShadowVoxelTracing.fragment.js\")]);\n                }\n            },\n        };\n        this._outputTexture = new ProceduralTexture(\"voxelTracingPass\", {\n            width: this._engine.getRenderWidth(),\n            height: this._engine.getRenderHeight(),\n        }, \"iblShadowVoxelTracing\", this._scene, textureOptions);\n        this._outputTexture.refreshRate = -1;\n        this._outputTexture.autoClear = false;\n        this._outputTexture.defines = defines;\n        // Need to set all the textures first so that the effect gets created with the proper uniforms.\n        this._setBindings(this._scene.activeCamera);\n        let counter = 0;\n        this._scene.onBeforeRenderObservable.add(() => {\n            counter = 0;\n        });\n        this._scene.onAfterRenderTargetsRenderObservable.add(() => {\n            if (++counter == 2) {\n                if (this.enabled && this._outputTexture.isReady()) {\n                    this._setBindings(this._scene.activeCamera);\n                    this._outputTexture.render();\n                }\n            }\n        });\n    }\n    _createDefines() {\n        let defines = \"\";\n        if (this._scene.useRightHandedSystem) {\n            defines += \"#define RIGHT_HANDED\\n\";\n        }\n        if (this._debugVoxelMarchEnabled) {\n            defines += \"#define VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION 1u\\n\";\n        }\n        if (this._coloredShadows) {\n            defines += \"#define COLOR_SHADOWS 1u\\n\";\n        }\n        return defines;\n    }\n    _setBindings(camera) {\n        this._outputTexture.defines = this._createDefines();\n        this._outputTexture.setMatrix(\"viewMtx\", camera.getViewMatrix());\n        this._outputTexture.setMatrix(\"projMtx\", camera.getProjectionMatrix());\n        camera.getProjectionMatrix().invertToRef(this._cameraInvProj);\n        camera.getViewMatrix().invertToRef(this._cameraInvView);\n        this._outputTexture.setMatrix(\"invProjMtx\", this._cameraInvProj);\n        this._outputTexture.setMatrix(\"invViewMtx\", this._cameraInvView);\n        this._outputTexture.setMatrix(\"wsNormalizationMtx\", this._invWorldScaleMatrix);\n        this._frameId++;\n        let rotation = 0.0;\n        if (this._scene.environmentTexture) {\n            rotation = this._scene.environmentTexture.rotationY ?? 0;\n        }\n        rotation = this._scene.useRightHandedSystem ? -(rotation + 0.5 * Math.PI) : rotation - 0.5 * Math.PI;\n        rotation = rotation % (2.0 * Math.PI);\n        this._shadowParameters.set(this._sampleDirections, this._frameId, 1.0, rotation);\n        this._outputTexture.setVector4(\"shadowParameters\", this._shadowParameters);\n        const voxelGrid = this._renderPipeline._getVoxelGridTexture();\n        const highestMip = Math.floor(Math.log2(voxelGrid.getSize().width));\n        this._voxelBiasParameters.set(this._voxelNormalBias, this._voxelDirectionBias, highestMip, 0.0);\n        this._outputTexture.setVector4(\"voxelBiasParameters\", this._voxelBiasParameters);\n        // SSS Options.\n        this._sssParameters.set(this._sssSamples, this._sssStride, this._sssMaxDist, this._sssThickness);\n        this._outputTexture.setVector4(\"sssParameters\", this._sssParameters);\n        this._opacityParameters.set(this._voxelShadowOpacity, this._ssShadowOpacity, 0.0, 0.0);\n        this._outputTexture.setVector4(\"shadowOpacity\", this._opacityParameters);\n        this._outputTexture.setTexture(\"voxelGridSampler\", voxelGrid);\n        this._outputTexture.setTexture(\"blueNoiseSampler\", this._renderPipeline._getNoiseTexture());\n        const cdfGenerator = this._scene.iblCdfGenerator;\n        if (cdfGenerator) {\n            this._outputTexture.setTexture(\"icdfSampler\", cdfGenerator.getIcdfTexture());\n        }\n        if (this._coloredShadows && this._scene.environmentTexture) {\n            this._outputTexture.setTexture(\"iblSampler\", this._scene.environmentTexture);\n        }\n        const geometryBufferRenderer = this._scene.geometryBufferRenderer;\n        if (!geometryBufferRenderer) {\n            return;\n        }\n        const depthIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE);\n        this._outputTexture.setTexture(\"depthSampler\", geometryBufferRenderer.getGBuffer().textures[depthIndex]);\n        const wnormalIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.NORMAL_TEXTURE_TYPE);\n        this._outputTexture.setTexture(\"worldNormalSampler\", geometryBufferRenderer.getGBuffer().textures[wnormalIndex]);\n    }\n    /**\n     * Called by render pipeline when canvas resized.\n     * @param scaleFactor The factor by which to scale the canvas size.\n     */\n    resize(scaleFactor = 1.0) {\n        const newSize = {\n            width: Math.max(1.0, Math.floor(this._engine.getRenderWidth() * scaleFactor)),\n            height: Math.max(1.0, Math.floor(this._engine.getRenderHeight() * scaleFactor)),\n        };\n        this._outputTexture.resize(newSize, false);\n    }\n    /**\n     * Checks if the pass is ready\n     * @returns true if the pass is ready\n     */\n    isReady() {\n        return (this._outputTexture.isReady() &&\n            !(this._debugPassPP && !this._debugPassPP.isReady()) &&\n            this._scene.iblCdfGenerator &&\n            this._scene.iblCdfGenerator.getIcdfTexture().isReady() &&\n            this._renderPipeline._getVoxelGridTexture().isReady());\n    }\n    /**\n     * Disposes the associated resources\n     */\n    dispose() {\n        this._outputTexture.dispose();\n        if (this._debugPassPP) {\n            this._debugPassPP.dispose();\n        }\n    }\n}\n//# sourceMappingURL=iblShadowsVoxelTracingPass.js.map","\nimport { Vector4 } from \"../../Maths/math.vector.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\nimport { GeometryBufferRenderer } from \"../../Rendering/geometryBufferRenderer.js\";\nimport { ProceduralTexture } from \"../../Materials/Textures/Procedurals/proceduralTexture.js\";\n/**\n * This should not be instanciated directly, as it is part of a scene component\n * @internal\n */\nexport class _IblShadowsSpatialBlurPass {\n    /**\n     * Returns the output texture of the pass.\n     * @returns The output texture.\n     */\n    getOutputTexture() {\n        return this._outputTexture;\n    }\n    /**\n     * Gets the debug pass post process\n     * @returns The post process\n     */\n    getDebugPassPP() {\n        if (!this._debugPassPP) {\n            this._createDebugPass();\n        }\n        return this._debugPassPP;\n    }\n    /**\n     * Sets the name of the debug pass\n     */\n    get debugPassName() {\n        return this._debugPassName;\n    }\n    /**\n     * The scale of the voxel grid in world space. This is used to scale the blur radius in world space.\n     * @param scale The scale of the voxel grid in world space.\n     */\n    setWorldScale(scale) {\n        this._worldScale = scale;\n    }\n    /**\n     * Sets params that control the position and scaling of the debug display on the screen.\n     * @param x Screen X offset of the debug display (0-1)\n     * @param y Screen Y offset of the debug display (0-1)\n     * @param widthScale X scale of the debug display (0-1)\n     * @param heightScale Y scale of the debug display (0-1)\n     */\n    setDebugDisplayParams(x, y, widthScale, heightScale) {\n        this._debugSizeParams.set(x, y, widthScale, heightScale);\n    }\n    /**\n     * Creates the debug post process effect for this pass\n     */\n    _createDebugPass() {\n        if (!this._debugPassPP) {\n            const isWebGPU = this._engine.isWebGPU;\n            const debugOptions = {\n                width: this._engine.getRenderWidth(),\n                height: this._engine.getRenderHeight(),\n                textureFormat: 6,\n                textureType: 0,\n                samplingMode: 1,\n                uniforms: [\"sizeParams\"],\n                samplers: [\"debugSampler\"],\n                engine: this._engine,\n                reusable: false,\n                shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n                extraInitializations: (useWebGPU, list) => {\n                    if (useWebGPU) {\n                        list.push(import(\"../../ShadersWGSL/iblShadowDebug.fragment.js\"));\n                    }\n                    else {\n                        list.push(import(\"../../Shaders/iblShadowDebug.fragment.js\"));\n                    }\n                },\n            };\n            this._debugPassPP = new PostProcess(this.debugPassName, \"iblShadowDebug\", debugOptions);\n            this._debugPassPP.autoClear = false;\n            this._debugPassPP.onApplyObservable.add((effect) => {\n                // update the caustic texture with what we just rendered.\n                effect.setTexture(\"debugSampler\", this._outputTexture);\n                effect.setVector4(\"sizeParams\", this._debugSizeParams);\n            });\n        }\n    }\n    /**\n     * Instanciates the importance sampling renderer\n     * @param scene Scene to attach to\n     * @param iblShadowsRenderPipeline The IBL shadows render pipeline\n     * @returns The importance sampling renderer\n     */\n    constructor(scene, iblShadowsRenderPipeline) {\n        this._worldScale = 1.0;\n        this._blurParameters = new Vector4(0.0, 0.0, 0.0, 0.0);\n        /**\n         * Is the effect enabled\n         */\n        this.enabled = true;\n        this._debugPassName = \"Spatial Blur Debug Pass\";\n        /** Enable the debug view for this pass */\n        this.debugEnabled = false;\n        this._debugSizeParams = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        this._renderPipeline = iblShadowsRenderPipeline;\n        this._createTextures();\n    }\n    _createTextures() {\n        const isWebGPU = this._engine.isWebGPU;\n        const textureOptions = {\n            type: 0,\n            format: 5,\n            samplingMode: 1,\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/iblShadowSpatialBlur.fragment.js\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/iblShadowSpatialBlur.fragment.js\")]);\n                }\n            },\n        };\n        this._outputTexture = new ProceduralTexture(\"spatialBlurPass\", {\n            width: this._engine.getRenderWidth(),\n            height: this._engine.getRenderHeight(),\n        }, \"iblShadowSpatialBlur\", this._scene, textureOptions, false, false, 0);\n        this._outputTexture.refreshRate = -1;\n        this._outputTexture.autoClear = false;\n        // Need to set all the textures first so that the effect gets created with the proper uniforms.\n        this._setBindings();\n        let counter = 0;\n        this._scene.onBeforeRenderObservable.add(() => {\n            counter = 0;\n        });\n        this._scene.onAfterRenderTargetsRenderObservable.add(() => {\n            if (++counter == 2) {\n                if (this.enabled && this._outputTexture.isReady()) {\n                    this._setBindings();\n                    this._outputTexture.render();\n                }\n            }\n        });\n    }\n    _setBindings() {\n        this._outputTexture.setTexture(\"voxelTracingSampler\", this._renderPipeline._getVoxelTracingTexture());\n        const iterationCount = 1;\n        this._blurParameters.set(iterationCount, this._worldScale, 0.0, 0.0);\n        this._outputTexture.setVector4(\"blurParameters\", this._blurParameters);\n        const geometryBufferRenderer = this._scene.geometryBufferRenderer;\n        if (!geometryBufferRenderer) {\n            return;\n        }\n        const depthIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE);\n        this._outputTexture.setTexture(\"depthSampler\", geometryBufferRenderer.getGBuffer().textures[depthIndex]);\n        const wnormalIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.NORMAL_TEXTURE_TYPE);\n        this._outputTexture.setTexture(\"worldNormalSampler\", geometryBufferRenderer.getGBuffer().textures[wnormalIndex]);\n    }\n    /**\n     * Called by render pipeline when canvas resized.\n     * @param scaleFactor The factor by which to scale the canvas size.\n     */\n    resize(scaleFactor = 1.0) {\n        const newSize = {\n            width: Math.max(1.0, Math.floor(this._engine.getRenderWidth() * scaleFactor)),\n            height: Math.max(1.0, Math.floor(this._engine.getRenderHeight() * scaleFactor)),\n        };\n        this._outputTexture.resize(newSize, false);\n    }\n    /**\n     * Checks if the pass is ready\n     * @returns true if the pass is ready\n     */\n    isReady() {\n        return this._outputTexture.isReady() && !(this._debugPassPP && !this._debugPassPP.isReady());\n    }\n    /**\n     * Disposes the associated resources\n     */\n    dispose() {\n        this._outputTexture.dispose();\n        if (this._debugPassPP) {\n            this._debugPassPP.dispose();\n        }\n    }\n}\n//# sourceMappingURL=iblShadowsSpatialBlurPass.js.map","\nimport { Vector4 } from \"../../Maths/math.vector.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\nimport { GeometryBufferRenderer } from \"../../Rendering/geometryBufferRenderer.js\";\nimport { ProceduralTexture } from \"../../Materials/Textures/Procedurals/proceduralTexture.js\";\nimport { Observable } from \"../../Misc/observable.js\";\n/**\n * This should not be instanciated directly, as it is part of a scene component\n * @internal\n */\nexport class _IblShadowsAccumulationPass {\n    /**\n     * Returns the output texture of the pass.\n     * @returns The output texture.\n     */\n    getOutputTexture() {\n        return this._outputTexture;\n    }\n    /**\n     * Gets the debug pass post process\n     * @returns The post process\n     */\n    getDebugPassPP() {\n        if (!this._debugPassPP) {\n            this._createDebugPass();\n        }\n        return this._debugPassPP;\n    }\n    /**\n     * Gets the name of the debug pass\n     * @returns The name of the debug pass\n     */\n    get debugPassName() {\n        return this._debugPassName;\n    }\n    /**\n     * A value that controls how much of the previous frame's accumulation to keep.\n     * The higher the value, the faster the shadows accumulate but the more potential ghosting you'll see.\n     */\n    get remanence() {\n        return this._remanence;\n    }\n    /**\n     * A value that controls how much of the previous frame's accumulation to keep.\n     * The higher the value, the faster the shadows accumulate but the more potential ghosting you'll see.\n     */\n    set remanence(value) {\n        this._remanence = value;\n    }\n    /**\n     * Reset the accumulation.\n     */\n    get reset() {\n        return this._reset;\n    }\n    /**\n     * Reset the accumulation.\n     */\n    set reset(value) {\n        this._reset = value;\n    }\n    /**\n     * Tell the pass that the camera is moving. This will cause the accumulation\n     * rate to change.\n     */\n    set isMoving(value) {\n        this._isMoving = value;\n    }\n    /**\n     * Sets params that control the position and scaling of the debug display on the screen.\n     * @param x Screen X offset of the debug display (0-1)\n     * @param y Screen Y offset of the debug display (0-1)\n     * @param widthScale X scale of the debug display (0-1)\n     * @param heightScale Y scale of the debug display (0-1)\n     */\n    setDebugDisplayParams(x, y, widthScale, heightScale) {\n        this._debugSizeParams.set(x, y, widthScale, heightScale);\n    }\n    /**\n     * Creates the debug post process effect for this pass\n     */\n    _createDebugPass() {\n        if (!this._debugPassPP) {\n            const isWebGPU = this._engine.isWebGPU;\n            const debugOptions = {\n                width: this._engine.getRenderWidth(),\n                height: this._engine.getRenderHeight(),\n                textureFormat: 5,\n                textureType: 0,\n                samplingMode: 1,\n                uniforms: [\"sizeParams\"],\n                samplers: [\"debugSampler\"],\n                engine: this._engine,\n                reusable: false,\n                shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n                extraInitializations: (useWebGPU, list) => {\n                    if (useWebGPU) {\n                        list.push(import(\"../../ShadersWGSL/iblShadowDebug.fragment.js\"));\n                    }\n                    else {\n                        list.push(import(\"../../Shaders/iblShadowDebug.fragment.js\"));\n                    }\n                },\n            };\n            this._debugPassPP = new PostProcess(this.debugPassName, \"iblShadowDebug\", debugOptions);\n            this._debugPassPP.autoClear = false;\n            this._debugPassPP.onApplyObservable.add((effect) => {\n                // update the caustic texture with what we just rendered.\n                effect.setTexture(\"debugSampler\", this._outputTexture);\n                effect.setVector4(\"sizeParams\", this._debugSizeParams);\n            });\n        }\n    }\n    /**\n     * Instantiates the accumulation pass\n     * @param scene Scene to attach to\n     * @param iblShadowsRenderPipeline The IBL shadows render pipeline\n     * @returns The accumulation pass\n     */\n    constructor(scene, iblShadowsRenderPipeline) {\n        this._accumulationParams = new Vector4(0.0, 0.0, 0.0, 0.0);\n        /** Enable the debug view for this pass */\n        this.debugEnabled = false;\n        /**\n         * Is the effect enabled\n         */\n        this.enabled = true;\n        /**\n         * Observable that triggers when the accumulation texture is ready\n         */\n        this.onReadyObservable = new Observable();\n        this._debugPassName = \"Shadow Accumulation Debug Pass\";\n        this._remanence = 0.9;\n        this._reset = true;\n        this._isMoving = false;\n        this._debugSizeParams = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        this._renderPipeline = iblShadowsRenderPipeline;\n        this._createTextures();\n    }\n    _createTextures() {\n        const isWebGPU = this._engine.isWebGPU;\n        const outputTextureOptions = {\n            type: 2,\n            format: 5,\n            samplingMode: 1,\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/iblShadowAccumulation.fragment.js\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/iblShadowAccumulation.fragment.js\")]);\n                }\n            },\n        };\n        this._outputTexture = new ProceduralTexture(\"shadowAccumulationPass\", {\n            width: this._engine.getRenderWidth(),\n            height: this._engine.getRenderHeight(),\n        }, \"iblShadowAccumulation\", this._scene, outputTextureOptions);\n        this._outputTexture.refreshRate = -1;\n        this._outputTexture.autoClear = false;\n        this._outputTexture.onGeneratedObservable.addOnce(() => {\n            this.onReadyObservable.notifyObservers();\n        });\n        // Need to set all the textures first so that the effect gets created with the proper uniforms.\n        this._setOutputTextureBindings();\n        let counter = 0;\n        this._scene.onBeforeRenderObservable.add(() => {\n            counter = 0;\n        });\n        this._scene.onAfterRenderTargetsRenderObservable.add(() => {\n            if (++counter == 2) {\n                if (this.enabled && this._outputTexture.isReady()) {\n                    this._setOutputTextureBindings();\n                    this._outputTexture.render();\n                }\n            }\n        });\n        // Create the accumulation texture for the previous frame.\n        // We'll copy the output of the accumulation pass to this texture at the start of every frame.\n        const accumulationOptions = {\n            type: 2,\n            format: 5,\n            samplingMode: 1,\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/pass.fragment.js\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/pass.fragment.js\")]);\n                }\n            },\n        };\n        this._oldAccumulationCopy = new ProceduralTexture(\"oldAccumulationRT\", { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, \"pass\", this._scene, accumulationOptions, false);\n        this._oldAccumulationCopy.autoClear = false;\n        this._oldAccumulationCopy.refreshRate = 1;\n        this._oldAccumulationCopy.onBeforeGenerationObservable.add(this._setAccumulationCopyBindings.bind(this));\n        this._setAccumulationCopyBindings();\n        // Create the local position texture for the previous frame.\n        // We'll copy the previous local position texture to this texture at the start of every frame.\n        const localPositionOptions = {\n            type: 2,\n            format: 5,\n            samplingMode: 1,\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/pass.fragment.js\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/pass.fragment.js\")]);\n                }\n            },\n        };\n        this._oldPositionCopy = new ProceduralTexture(\"oldLocalPositionRT\", { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, \"pass\", this._scene, localPositionOptions, false);\n        this._updatePositionCopy();\n        this._oldPositionCopy.autoClear = false;\n        this._oldPositionCopy.refreshRate = 1;\n        this._oldPositionCopy.onBeforeGenerationObservable.add(this._updatePositionCopy.bind(this));\n    }\n    _setOutputTextureBindings() {\n        const remanence = this._isMoving ? this.remanence : 0.99;\n        this._accumulationParams.set(remanence, this.reset ? 1.0 : 0.0, this._renderPipeline.voxelGridSize, 0.0);\n        this._outputTexture.setTexture(\"spatialBlurSampler\", this._renderPipeline._getSpatialBlurTexture());\n        this._outputTexture.setVector4(\"accumulationParameters\", this._accumulationParams);\n        this._outputTexture.setTexture(\"oldAccumulationSampler\", this._oldAccumulationCopy ? this._oldAccumulationCopy : this._renderPipeline._dummyTexture2d);\n        this._outputTexture.setTexture(\"prevPositionSampler\", this._oldPositionCopy ? this._oldPositionCopy : this._renderPipeline._dummyTexture2d);\n        const geometryBufferRenderer = this._scene.geometryBufferRenderer;\n        if (!geometryBufferRenderer) {\n            return;\n        }\n        const velocityIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE);\n        this._outputTexture.setTexture(\"motionSampler\", geometryBufferRenderer.getGBuffer().textures[velocityIndex]);\n        const wPositionIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\n        this._outputTexture.setTexture(\"positionSampler\", geometryBufferRenderer.getGBuffer().textures[wPositionIndex]);\n        this.reset = false;\n        this._isMoving = false;\n    }\n    _updatePositionCopy() {\n        const geometryBufferRenderer = this._scene.geometryBufferRenderer;\n        const index = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\n        this._oldPositionCopy.setTexture(\"textureSampler\", geometryBufferRenderer.getGBuffer().textures[index]);\n    }\n    _setAccumulationCopyBindings() {\n        this._oldAccumulationCopy.setTexture(\"textureSampler\", this._outputTexture);\n    }\n    /**\n     * Called by render pipeline when canvas resized.\n     * @param scaleFactor The factor by which to scale the canvas size.\n     */\n    resize(scaleFactor = 1.0) {\n        const newSize = {\n            width: Math.max(1.0, Math.floor(this._engine.getRenderWidth() * scaleFactor)),\n            height: Math.max(1.0, Math.floor(this._engine.getRenderHeight() * scaleFactor)),\n        };\n        this._outputTexture.resize(newSize, false);\n        this._oldAccumulationCopy.resize(newSize, false);\n        this._oldPositionCopy.resize({ width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, false);\n        this.reset = true;\n    }\n    _disposeTextures() {\n        this._oldAccumulationCopy.dispose();\n        this._oldPositionCopy.dispose();\n        this._outputTexture.dispose();\n    }\n    /**\n     * Checks if the pass is ready\n     * @returns true if the pass is ready\n     */\n    isReady() {\n        return (this._oldAccumulationCopy &&\n            this._oldAccumulationCopy.isReady() &&\n            this._oldPositionCopy &&\n            this._oldPositionCopy.isReady() &&\n            this._outputTexture.isReady() &&\n            !(this._debugPassPP && !this._debugPassPP.isReady()));\n    }\n    /**\n     * Disposes the associated resources\n     */\n    dispose() {\n        this._disposeTextures();\n        if (this._debugPassPP) {\n            this._debugPassPP.dispose();\n        }\n        this.onReadyObservable.clear();\n    }\n}\n//# sourceMappingURL=iblShadowsAccumulationPass.js.map","\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nimport { Matrix, Vector3, Vector4, Quaternion } from \"../../Maths/math.vector.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { _IblShadowsVoxelRenderer } from \"./iblShadowsVoxelRenderer.js\";\nimport { _IblShadowsVoxelTracingPass } from \"./iblShadowsVoxelTracingPass.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\nimport { _IblShadowsSpatialBlurPass } from \"./iblShadowsSpatialBlurPass.js\";\nimport { _IblShadowsAccumulationPass } from \"./iblShadowsAccumulationPass.js\";\nimport { PostProcessRenderPipeline } from \"../../PostProcesses/RenderPipeline/postProcessRenderPipeline.js\";\nimport { PostProcessRenderEffect } from \"../../PostProcesses/RenderPipeline/postProcessRenderEffect.js\";\nimport { GeometryBufferRenderer } from \"../geometryBufferRenderer.js\";\nimport { RawTexture } from \"../../Materials/Textures/rawTexture.js\";\nimport { RawTexture3D } from \"../../Materials/Textures/rawTexture3D.js\";\nimport { Engine } from \"../../Engines/engine.js\";\nimport { IBLShadowsPluginMaterial } from \"./iblShadowsPluginMaterial.js\";\nimport { PBRBaseMaterial } from \"../../Materials/PBR/pbrBaseMaterial.js\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport \"../geometryBufferRendererSceneComponent.js\";\nimport \"../iblCdfGeneratorSceneComponent.js\";\n/**\n * Voxel-based shadow rendering for IBL's.\n * This should not be instanciated directly, as it is part of a scene component\n */\nexport class IblShadowsRenderPipeline extends PostProcessRenderPipeline {\n    /**\n     * Reset the shadow accumulation. This has a similar affect to lowering the remanence for a single frame.\n     * This is useful when making a sudden change to the IBL.\n     */\n    resetAccumulation() {\n        this._accumulationPass.reset = true;\n    }\n    /**\n     * How dark the shadows appear. 1.0 is full opacity, 0.0 is no shadows.\n     */\n    get shadowOpacity() {\n        return this._shadowOpacity;\n    }\n    set shadowOpacity(value) {\n        this._shadowOpacity = value;\n        this._setPluginParameters();\n    }\n    /**\n     * Render the shadows in color rather than black and white.\n     * This is slightly more expensive than black and white shadows but can be much\n     * more accurate when the strongest lights in the IBL are non-white.\n     */\n    get coloredShadows() {\n        return this._coloredShadows;\n    }\n    set coloredShadows(value) {\n        this._coloredShadows = value;\n        this._voxelTracingPass.coloredShadows = value;\n        this._setPluginParameters();\n    }\n    /**\n     * A multiplier for the render size of the shadows. Used for rendering lower-resolution shadows.\n     */\n    get shadowRenderSizeFactor() {\n        return this._renderSizeFactor;\n    }\n    set shadowRenderSizeFactor(value) {\n        this._renderSizeFactor = Math.max(Math.min(value, 1.0), 0.0);\n        this._voxelTracingPass.resize(value);\n        this._spatialBlurPass.resize(value);\n        this._accumulationPass.resize(value);\n        this._setPluginParameters();\n    }\n    /**\n     * How dark the voxel shadows appear. 1.0 is full opacity, 0.0 is no shadows.\n     */\n    get voxelShadowOpacity() {\n        return this._voxelTracingPass?.voxelShadowOpacity;\n    }\n    set voxelShadowOpacity(value) {\n        if (!this._voxelTracingPass)\n            return;\n        this._voxelTracingPass.voxelShadowOpacity = value;\n    }\n    /**\n     * How dark the screen-space shadows appear. 1.0 is full opacity, 0.0 is no shadows.\n     */\n    get ssShadowOpacity() {\n        return this._voxelTracingPass?.ssShadowOpacity;\n    }\n    set ssShadowOpacity(value) {\n        if (!this._voxelTracingPass)\n            return;\n        this._voxelTracingPass.ssShadowOpacity = value;\n    }\n    /**\n     * The number of samples used in the screen space shadow pass.\n     */\n    get ssShadowSampleCount() {\n        return this._voxelTracingPass?.sssSamples;\n    }\n    set ssShadowSampleCount(value) {\n        if (!this._voxelTracingPass)\n            return;\n        this._voxelTracingPass.sssSamples = value;\n    }\n    /**\n     * The stride of the screen-space shadow pass. This controls the distance between samples\n     * in pixels.\n     */\n    get ssShadowStride() {\n        return this._voxelTracingPass?.sssStride;\n    }\n    set ssShadowStride(value) {\n        if (!this._voxelTracingPass)\n            return;\n        this._voxelTracingPass.sssStride = value;\n    }\n    /**\n     * A scale for the maximum distance a screen-space shadow can be cast in world-space.\n     * The maximum distance that screen-space shadows cast is derived from the voxel size\n     * and this value so shouldn't need to change if you scale your scene\n     */\n    get ssShadowDistanceScale() {\n        return this._sssMaxDistScale;\n    }\n    set ssShadowDistanceScale(value) {\n        this._sssMaxDistScale = value;\n        this._updateSSShadowParams();\n    }\n    /**\n     * Screen-space shadow thickness scale. This value controls the assumed thickness of\n     * on-screen surfaces in world-space. It scales with the size of the shadow-casting\n     * region so shouldn't need to change if you scale your scene.\n     */\n    get ssShadowThicknessScale() {\n        return this._sssThicknessScale;\n    }\n    set ssShadowThicknessScale(value) {\n        this._sssThicknessScale = value;\n        this._updateSSShadowParams();\n    }\n    /**\n     * Returns the texture containing the voxel grid data\n     * @returns The texture containing the voxel grid data\n     * @internal\n     */\n    _getVoxelGridTexture() {\n        const tex = this._voxelRenderer?.getVoxelGrid();\n        if (tex && tex.isReady()) {\n            return tex;\n        }\n        return this._dummyTexture3d;\n    }\n    /**\n     * Returns the noise texture.\n     * @returns The noise texture.\n     * @internal\n     */\n    _getNoiseTexture() {\n        const tex = this._noiseTexture;\n        if (tex && tex.isReady()) {\n            return tex;\n        }\n        return this._dummyTexture2d;\n    }\n    /**\n     * Returns the voxel-tracing texture.\n     * @returns The voxel-tracing texture.\n     * @internal\n     */\n    _getVoxelTracingTexture() {\n        const tex = this._voxelTracingPass?.getOutputTexture();\n        if (tex && tex.isReady()) {\n            return tex;\n        }\n        return this._dummyTexture2d;\n    }\n    /**\n     * Returns the spatial blur texture.\n     * @returns The spatial blur texture.\n     * @internal\n     */\n    _getSpatialBlurTexture() {\n        const tex = this._spatialBlurPass.getOutputTexture();\n        if (tex && tex.isReady()) {\n            return tex;\n        }\n        return this._dummyTexture2d;\n    }\n    /**\n     * Returns the accumulated shadow texture.\n     * @returns The accumulated shadow texture.\n     * @internal\n     */\n    _getAccumulatedTexture() {\n        const tex = this._accumulationPass?.getOutputTexture();\n        if (tex && tex.isReady()) {\n            return tex;\n        }\n        return this._dummyTexture2d;\n    }\n    /**\n     * Turn on or off the debug view of the G-Buffer. This will display only the targets\n     * of the g-buffer that are used by the shadow pipeline.\n     */\n    get gbufferDebugEnabled() {\n        return this._gbufferDebugEnabled;\n    }\n    set gbufferDebugEnabled(enabled) {\n        if (enabled && !this.allowDebugPasses) {\n            Logger.Warn(\"Can't enable G-Buffer debug view without setting allowDebugPasses to true.\");\n            return;\n        }\n        this._gbufferDebugEnabled = enabled;\n        if (enabled) {\n            this._enableEffect(this._getGBufferDebugPass().name, this.cameras);\n        }\n        else {\n            this._disableEffect(this._getGBufferDebugPass().name, this.cameras);\n        }\n    }\n    /**\n     * Turn on or off the debug view of the CDF importance sampling data\n     */\n    get cdfDebugEnabled() {\n        return this.scene.iblCdfGenerator ? this.scene.iblCdfGenerator.debugEnabled : false;\n    }\n    /**\n     * Turn on or off the debug view of the CDF importance sampling data\n     */\n    set cdfDebugEnabled(enabled) {\n        if (!this.scene.iblCdfGenerator)\n            return;\n        if (enabled && !this.allowDebugPasses) {\n            Logger.Warn(\"Can't enable importance sampling debug view without setting allowDebugPasses to true.\");\n            return;\n        }\n        if (enabled === this.scene.iblCdfGenerator.debugEnabled)\n            return;\n        this.scene.iblCdfGenerator.debugEnabled = enabled;\n        if (enabled) {\n            this._enableEffect(this.scene.iblCdfGenerator.debugPassName, this.cameras);\n        }\n        else {\n            this._disableEffect(this.scene.iblCdfGenerator.debugPassName, this.cameras);\n        }\n    }\n    /**\n     * This displays the voxel grid in slices spread across the screen.\n     * It also displays what slices of the model are stored in each layer\n     * of the voxel grid. Each red stripe represents one layer while each gradient\n     * (from bright red to black) represents the layers rendered in a single draw call.\n     */\n    get voxelDebugEnabled() {\n        return this._voxelRenderer?.voxelDebugEnabled;\n    }\n    set voxelDebugEnabled(enabled) {\n        if (!this._voxelRenderer)\n            return;\n        if (enabled && !this.allowDebugPasses) {\n            Logger.Warn(\"Can't enable voxel debug view without setting allowDebugPasses to true.\");\n            return;\n        }\n        this._voxelRenderer.voxelDebugEnabled = enabled;\n        if (enabled) {\n            this._enableEffect(this._voxelRenderer.debugPassName, this.cameras);\n        }\n        else {\n            this._disableEffect(this._voxelRenderer.debugPassName, this.cameras);\n        }\n    }\n    /**\n     * When using tri-planar voxelization (the default), this value can be used to\n     * display only the voxelization result for that axis. z-axis = 0, y-axis = 1, x-axis = 2\n     */\n    get voxelDebugAxis() {\n        return this._voxelRenderer?.voxelDebugAxis;\n    }\n    set voxelDebugAxis(axisNum) {\n        if (!this._voxelRenderer)\n            return;\n        this._voxelRenderer.voxelDebugAxis = axisNum;\n    }\n    /**\n     * Displays a given mip of the voxel grid. `voxelDebugAxis` must be undefined in this\n     * case because we only generate mips for the combined voxel grid.\n     */\n    set voxelDebugDisplayMip(mipNum) {\n        if (!this._voxelRenderer)\n            return;\n        this._voxelRenderer.setDebugMipNumber(mipNum);\n    }\n    /**\n     * Display the debug view for just the shadow samples taken this frame.\n     */\n    get voxelTracingDebugEnabled() {\n        return this._voxelTracingPass?.debugEnabled;\n    }\n    set voxelTracingDebugEnabled(enabled) {\n        if (!this._voxelTracingPass)\n            return;\n        if (enabled && !this.allowDebugPasses) {\n            Logger.Warn(\"Can't enable voxel tracing debug view without setting allowDebugPasses to true.\");\n            return;\n        }\n        if (enabled === this._voxelTracingPass.debugEnabled)\n            return;\n        this._voxelTracingPass.debugEnabled = enabled;\n        if (enabled) {\n            this._enableEffect(this._voxelTracingPass.debugPassName, this.cameras);\n        }\n        else {\n            this._disableEffect(this._voxelTracingPass.debugPassName, this.cameras);\n        }\n    }\n    /**\n     * Display the debug view for the spatial blur pass\n     */\n    get spatialBlurPassDebugEnabled() {\n        return this._spatialBlurPass.debugEnabled;\n    }\n    set spatialBlurPassDebugEnabled(enabled) {\n        if (!this._spatialBlurPass)\n            return;\n        if (enabled && !this.allowDebugPasses) {\n            Logger.Warn(\"Can't enable spatial blur debug view without setting allowDebugPasses to true.\");\n            return;\n        }\n        if (enabled === this._spatialBlurPass.debugEnabled)\n            return;\n        this._spatialBlurPass.debugEnabled = enabled;\n        if (enabled) {\n            this._enableEffect(this._spatialBlurPass.debugPassName, this.cameras);\n        }\n        else {\n            this._disableEffect(this._spatialBlurPass.debugPassName, this.cameras);\n        }\n    }\n    /**\n     * Display the debug view for the shadows accumulated over time.\n     */\n    get accumulationPassDebugEnabled() {\n        return this._accumulationPass?.debugEnabled;\n    }\n    set accumulationPassDebugEnabled(enabled) {\n        if (!this._accumulationPass)\n            return;\n        if (enabled && !this.allowDebugPasses) {\n            Logger.Warn(\"Can't enable accumulation pass debug view without setting allowDebugPasses to true.\");\n            return;\n        }\n        if (enabled === this._accumulationPass.debugEnabled)\n            return;\n        this._accumulationPass.debugEnabled = enabled;\n        if (enabled) {\n            this._enableEffect(this._accumulationPass.debugPassName, this.cameras);\n        }\n        else {\n            this._disableEffect(this._accumulationPass.debugPassName, this.cameras);\n        }\n    }\n    /**\n     * Add a mesh to be used for shadow-casting in the IBL shadow pipeline.\n     * These meshes will be written to the voxel grid.\n     * @param mesh A mesh or list of meshes that you want to cast shadows\n     */\n    addShadowCastingMesh(mesh) {\n        if (Array.isArray(mesh)) {\n            for (const m of mesh) {\n                if (m && this._shadowCastingMeshes.indexOf(m) === -1) {\n                    this._shadowCastingMeshes.push(m);\n                }\n            }\n        }\n        else {\n            if (mesh && this._shadowCastingMeshes.indexOf(mesh) === -1) {\n                this._shadowCastingMeshes.push(mesh);\n            }\n        }\n    }\n    /**\n     * Remove a mesh from the shadow-casting list. The mesh will no longer be written\n     * to the voxel grid and will not cast shadows.\n     * @param mesh The mesh or list of meshes that you don't want to cast shadows.\n     */\n    removeShadowCastingMesh(mesh) {\n        if (Array.isArray(mesh)) {\n            for (const m of mesh) {\n                const index = this._shadowCastingMeshes.indexOf(m);\n                if (index !== -1) {\n                    this._shadowCastingMeshes.splice(index, 1);\n                }\n            }\n        }\n        else {\n            const index = this._shadowCastingMeshes.indexOf(mesh);\n            if (index !== -1) {\n                this._shadowCastingMeshes.splice(index, 1);\n            }\n        }\n    }\n    /**\n     * The exponent of the resolution of the voxel shadow grid. Higher resolutions will result in sharper\n     * shadows but are more expensive to compute and require more memory.\n     * The resolution is calculated as 2 to the power of this number.\n     */\n    get resolutionExp() {\n        return this._voxelRenderer.voxelResolutionExp;\n    }\n    set resolutionExp(newResolution) {\n        if (newResolution === this._voxelRenderer.voxelResolutionExp)\n            return;\n        if (this._voxelRenderer.isVoxelizationInProgress()) {\n            Logger.Warn(\"Can't change the resolution of the voxel grid while voxelization is in progress.\");\n            return;\n        }\n        this._voxelRenderer.voxelResolutionExp = Math.max(1, Math.min(newResolution, 8));\n        this._accumulationPass.reset = true;\n    }\n    /**\n     * The number of different directions to sample during the voxel tracing pass\n     */\n    get sampleDirections() {\n        return this._voxelTracingPass?.sampleDirections;\n    }\n    /**\n     * The number of different directions to sample during the voxel tracing pass\n     */\n    set sampleDirections(value) {\n        if (!this._voxelTracingPass)\n            return;\n        this._voxelTracingPass.sampleDirections = value;\n    }\n    /**\n     * The decree to which the shadows persist between frames. 0.0 is no persistence, 1.0 is full persistence.\n     **/\n    get shadowRemanence() {\n        return this._accumulationPass?.remanence;\n    }\n    /**\n     * The decree to which the shadows persist between frames. 0.0 is no persistence, 1.0 is full persistence.\n     **/\n    set shadowRemanence(value) {\n        if (!this._accumulationPass)\n            return;\n        this._accumulationPass.remanence = value;\n    }\n    /**\n     * The global Y-axis rotation of the IBL for shadows. This should match the Y-rotation of the environment map applied to materials, skybox, etc.\n     */\n    get envRotation() {\n        return this._voxelTracingPass?.envRotation;\n    }\n    /**\n     * The global Y-axis rotation of the IBL for shadows. This should match the Y-rotation of the environment map applied to materials, skybox, etc.\n     */\n    set envRotation(value) {\n        if (!this._voxelTracingPass)\n            return;\n        this._voxelTracingPass.envRotation = value;\n        this._accumulationPass.reset = true;\n    }\n    /**\n     * Allow debug passes to be enabled. Default is false.\n     */\n    get allowDebugPasses() {\n        return this._allowDebugPasses;\n    }\n    /**\n     * Allow debug passes to be enabled. Default is false.\n     */\n    set allowDebugPasses(value) {\n        if (this._allowDebugPasses === value)\n            return;\n        this._allowDebugPasses = value;\n        if (value && this.scene.iblCdfGenerator) {\n            if (this.scene.iblCdfGenerator.isReady()) {\n                this._createDebugPasses();\n            }\n            else {\n                this.scene.iblCdfGenerator.onGeneratedObservable.addOnce(() => {\n                    this._createDebugPasses();\n                });\n            }\n        }\n        else {\n            this._disposeDebugPasses();\n        }\n    }\n    /**\n     *  Support test.\n     */\n    static get IsSupported() {\n        const engine = EngineStore.LastCreatedEngine;\n        if (!engine) {\n            return false;\n        }\n        return engine._features.supportIBLShadows;\n    }\n    /**\n     * Toggle the shadow tracing on or off\n     * @param enabled Toggle the shadow tracing on or off\n     */\n    toggleShadow(enabled) {\n        this._enabled = enabled;\n        this._voxelTracingPass.enabled = enabled;\n        this._spatialBlurPass.enabled = enabled;\n        this._accumulationPass.enabled = enabled;\n        this._materialsWithRenderPlugin.forEach((mat) => {\n            if (mat.pluginManager) {\n                const plugin = mat.pluginManager.getPlugin(IBLShadowsPluginMaterial.Name);\n                plugin.isEnabled = enabled;\n            }\n        });\n        this._setPluginParameters();\n    }\n    /**\n     * Trigger the scene to be re-voxelized. This should be run when any shadow-casters have been added, removed or moved.\n     */\n    updateVoxelization() {\n        if (this._shadowCastingMeshes.length === 0) {\n            Logger.Warn(\"IBL Shadows: updateVoxelization called with no shadow-casting meshes to voxelize.\");\n            return;\n        }\n        this._voxelRenderer.updateVoxelGrid(this._shadowCastingMeshes);\n        this._voxelRenderer.onVoxelizationCompleteObservable.addOnce(() => {\n            this.onVoxelizationCompleteObservable.notifyObservers();\n        });\n        this._updateSSShadowParams();\n    }\n    /**\n     * Trigger the scene bounds of shadow-casters to be calculated. This is the world size that the voxel grid will cover and will always be a cube.\n     */\n    updateSceneBounds() {\n        const bounds = {\n            min: new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE),\n            max: new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE),\n        };\n        this._shadowCastingMeshes.forEach((mesh) => {\n            const localBounds = mesh.getHierarchyBoundingVectors(true);\n            bounds.min = Vector3.Minimize(bounds.min, localBounds.min);\n            bounds.max = Vector3.Maximize(bounds.max, localBounds.max);\n        });\n        const size = bounds.max.subtract(bounds.min);\n        this.voxelGridSize = Math.max(size.x, size.y, size.z);\n        if (this._shadowCastingMeshes.length === 0 || !isFinite(this.voxelGridSize) || this.voxelGridSize === 0) {\n            Logger.Warn(\"IBL Shadows: Scene size is invalid. Can't update bounds.\");\n            this.voxelGridSize = 1.0;\n            return;\n        }\n        const halfSize = this.voxelGridSize / 2.0;\n        const centre = bounds.max.add(bounds.min).multiplyByFloats(-0.5, -0.5, -0.5);\n        const invWorldScaleMatrix = Matrix.Compose(new Vector3(1.0 / halfSize, 1.0 / halfSize, 1.0 / halfSize), new Quaternion(), new Vector3(0, 0, 0));\n        const invTranslationMatrix = Matrix.Compose(new Vector3(1.0, 1.0, 1.0), new Quaternion(), centre);\n        invTranslationMatrix.multiplyToRef(invWorldScaleMatrix, invWorldScaleMatrix);\n        this._voxelTracingPass.setWorldScaleMatrix(invWorldScaleMatrix);\n        this._voxelRenderer.setWorldScaleMatrix(invWorldScaleMatrix);\n        // Set world scale for spatial blur.\n        this._spatialBlurPass.setWorldScale(halfSize * 2.0);\n        this._updateSSShadowParams();\n    }\n    /**\n     * @param name The rendering pipeline name\n     * @param scene The scene linked to this pipeline\n     * @param options Options to configure the pipeline\n     * @param cameras Cameras to apply the pipeline to.\n     */\n    constructor(name, scene, options = {}, cameras) {\n        super(scene.getEngine(), name);\n        this._allowDebugPasses = false;\n        this._debugPasses = [];\n        this._shadowCastingMeshes = [];\n        this._shadowOpacity = 0.8;\n        this._enabled = true;\n        this._coloredShadows = false;\n        this._materialsWithRenderPlugin = [];\n        /**\n         * Observable that triggers when the shadow renderer is ready\n         */\n        this.onShadowTextureReadyObservable = new Observable();\n        /**\n         * Observable that triggers when a new IBL is set and the importance sampling is ready\n         */\n        this.onNewIblReadyObservable = new Observable();\n        /**\n         * Observable that triggers when the voxelization is complete\n         */\n        this.onVoxelizationCompleteObservable = new Observable();\n        /**\n         * The current world-space size of that the voxel grid covers in the scene.\n         */\n        this.voxelGridSize = 1.0;\n        this._renderSizeFactor = 1.0;\n        this._gbufferDebugEnabled = false;\n        this._gBufferDebugSizeParams = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this.scene = scene;\n        this._cameras = cameras || [scene.activeCamera];\n        // Create the dummy textures to be used when the pipeline is not ready\n        const blackPixels = new Uint8Array([0, 0, 0, 255]);\n        this._dummyTexture2d = new RawTexture(blackPixels, 1, 1, Engine.TEXTUREFORMAT_RGBA, scene, false);\n        this._dummyTexture3d = new RawTexture3D(blackPixels, 1, 1, 1, Engine.TEXTUREFORMAT_RGBA, scene, false);\n        // Setup the geometry buffer target formats\n        const textureTypesAndFormats = {};\n        textureTypesAndFormats[GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE] = { textureFormat: 6, textureType: 1 };\n        textureTypesAndFormats[GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE] = { textureFormat: 7, textureType: 2 };\n        textureTypesAndFormats[GeometryBufferRenderer.POSITION_TEXTURE_TYPE] = { textureFormat: 5, textureType: 2 };\n        textureTypesAndFormats[GeometryBufferRenderer.NORMAL_TEXTURE_TYPE] = { textureFormat: 5, textureType: 2 };\n        const geometryBufferRenderer = scene.enableGeometryBufferRenderer(undefined, 14, textureTypesAndFormats);\n        if (!geometryBufferRenderer) {\n            Logger.Error(\"Geometry buffer renderer is required for IBL shadows to work.\");\n            return;\n        }\n        this._geometryBufferRenderer = geometryBufferRenderer;\n        this._geometryBufferRenderer.enableScreenspaceDepth = true;\n        this._geometryBufferRenderer.enableVelocityLinear = true;\n        this._geometryBufferRenderer.enablePosition = true;\n        this._geometryBufferRenderer.enableNormal = true;\n        this._geometryBufferRenderer.generateNormalsInWorldSpace = true;\n        this.scene.enableIblCdfGenerator();\n        this.shadowOpacity = options.shadowOpacity || 0.8;\n        this._voxelRenderer = new _IblShadowsVoxelRenderer(this.scene, this, options ? options.resolutionExp : 6, options.triPlanarVoxelization !== undefined ? options.triPlanarVoxelization : true);\n        this._voxelTracingPass = new _IblShadowsVoxelTracingPass(this.scene, this);\n        this._spatialBlurPass = new _IblShadowsSpatialBlurPass(this.scene, this);\n        this._accumulationPass = new _IblShadowsAccumulationPass(this.scene, this);\n        this._accumulationPass.onReadyObservable.addOnce(() => {\n            this.onShadowTextureReadyObservable.notifyObservers();\n        });\n        this.sampleDirections = options.sampleDirections || 2;\n        this.voxelShadowOpacity = options.voxelShadowOpacity ?? 1.0;\n        this.envRotation = options.envRotation ?? 0.0;\n        this.shadowRenderSizeFactor = options.shadowRenderSizeFactor || 1.0;\n        this.ssShadowOpacity = options.ssShadowsEnabled === undefined || options.ssShadowsEnabled ? 1.0 : 0.0;\n        this.ssShadowDistanceScale = options.ssShadowDistanceScale || 1.25;\n        this.ssShadowSampleCount = options.ssShadowSampleCount || 16;\n        this.ssShadowStride = options.ssShadowStride || 8;\n        this.ssShadowThicknessScale = options.ssShadowThicknessScale || 1.0;\n        this.shadowRemanence = options.shadowRemanence ?? 0.75;\n        this._noiseTexture = new Texture(\"https://assets.babylonjs.com/textures/blue_noise/blue_noise_rgb.png\", this.scene, false, true, 1);\n        scene.postProcessRenderPipelineManager.addPipeline(this);\n        this.scene.onActiveCameraChanged.add(this._listenForCameraChanges.bind(this));\n        this.scene.onBeforeRenderObservable.add(this._updateBeforeRender.bind(this));\n        this._listenForCameraChanges();\n        this.scene.getEngine().onResizeObservable.add(this._handleResize.bind(this));\n        // Assigning the shadow texture to the materials needs to be done after the RT's are created.\n        if (this.scene.iblCdfGenerator) {\n            this.scene.iblCdfGenerator.onGeneratedObservable.add(() => {\n                this._setPluginParameters();\n                this.onNewIblReadyObservable.notifyObservers();\n            });\n        }\n    }\n    _handleResize() {\n        this._voxelRenderer.resize();\n        this._voxelTracingPass.resize(this.shadowRenderSizeFactor);\n        this._spatialBlurPass.resize(this.shadowRenderSizeFactor);\n        this._accumulationPass.resize(this.shadowRenderSizeFactor);\n        this._setPluginParameters();\n    }\n    _getGBufferDebugPass() {\n        if (this._gbufferDebugPass) {\n            return this._gbufferDebugPass;\n        }\n        const isWebGPU = this.engine.isWebGPU;\n        const textureNames = [\"depthSampler\", \"normalSampler\", \"positionSampler\", \"velocitySampler\"];\n        const options = {\n            width: this.scene.getEngine().getRenderWidth(),\n            height: this.scene.getEngine().getRenderHeight(),\n            samplingMode: 1,\n            engine: this.scene.getEngine(),\n            textureType: 0,\n            textureFormat: 5,\n            uniforms: [\"sizeParams\"],\n            samplers: textureNames,\n            reusable: false,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializations: (useWebGPU, list) => {\n                if (useWebGPU) {\n                    list.push(import(\"../../ShadersWGSL/iblShadowGBufferDebug.fragment.js\"));\n                }\n                else {\n                    list.push(import(\"../../Shaders/iblShadowGBufferDebug.fragment.js\"));\n                }\n            },\n        };\n        this._gbufferDebugPass = new PostProcess(\"iblShadowGBufferDebug\", \"iblShadowGBufferDebug\", options);\n        this._gbufferDebugPass.autoClear = false;\n        this._gbufferDebugPass.onApplyObservable.add((effect) => {\n            const depthIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE);\n            effect.setTexture(\"depthSampler\", this._geometryBufferRenderer.getGBuffer().textures[depthIndex]);\n            const normalIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.NORMAL_TEXTURE_TYPE);\n            effect.setTexture(\"normalSampler\", this._geometryBufferRenderer.getGBuffer().textures[normalIndex]);\n            const positionIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\n            effect.setTexture(\"positionSampler\", this._geometryBufferRenderer.getGBuffer().textures[positionIndex]);\n            const velocityIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE);\n            effect.setTexture(\"velocitySampler\", this._geometryBufferRenderer.getGBuffer().textures[velocityIndex]);\n            effect.setVector4(\"sizeParams\", this._gBufferDebugSizeParams);\n            if (this.scene.activeCamera) {\n                effect.setFloat(\"maxDepth\", this.scene.activeCamera.maxZ);\n            }\n        });\n        return this._gbufferDebugPass;\n    }\n    _createDebugPasses() {\n        if (this.scene.iblCdfGenerator) {\n            this._debugPasses = [{ pass: this.scene.iblCdfGenerator.getDebugPassPP(), enabled: this.cdfDebugEnabled }];\n        }\n        else {\n            this._debugPasses = [];\n        }\n        this._debugPasses.push({ pass: this._voxelRenderer.getDebugPassPP(), enabled: this.voxelDebugEnabled }, { pass: this._voxelTracingPass.getDebugPassPP(), enabled: this.voxelTracingDebugEnabled }, { pass: this._spatialBlurPass.getDebugPassPP(), enabled: this.spatialBlurPassDebugEnabled }, { pass: this._accumulationPass.getDebugPassPP(), enabled: this.accumulationPassDebugEnabled }, { pass: this._getGBufferDebugPass(), enabled: this.gbufferDebugEnabled });\n        for (let i = 0; i < this._debugPasses.length; i++) {\n            if (!this._debugPasses[i].pass)\n                continue;\n            this.addEffect(new PostProcessRenderEffect(this.scene.getEngine(), this._debugPasses[i].pass.name, () => {\n                return this._debugPasses[i].pass;\n            }, true));\n        }\n        const cameras = this.cameras.slice();\n        this.scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this.name, this.cameras);\n        this.scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this.name, cameras);\n        for (let i = 0; i < this._debugPasses.length; i++) {\n            if (!this._debugPasses[i].pass)\n                continue;\n            if (this._debugPasses[i].enabled) {\n                this._enableEffect(this._debugPasses[i].pass.name, this.cameras);\n            }\n            else {\n                this._disableEffect(this._debugPasses[i].pass.name, this.cameras);\n            }\n        }\n    }\n    _disposeEffectPasses() {\n        this.scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this.name, this.cameras);\n        this._disposeDebugPasses();\n        this._reset();\n    }\n    _disposeDebugPasses() {\n        for (let i = 0; i < this._debugPasses.length; i++) {\n            this._disableEffect(this._debugPasses[i].pass.name, this.cameras);\n            this._debugPasses[i].pass.dispose();\n        }\n        this._debugPasses = [];\n    }\n    _updateDebugPasses() {\n        let count = 0;\n        if (this._gbufferDebugEnabled)\n            count++;\n        if (this.cdfDebugEnabled)\n            count++;\n        if (this.voxelDebugEnabled)\n            count++;\n        if (this.voxelTracingDebugEnabled)\n            count++;\n        if (this.spatialBlurPassDebugEnabled)\n            count++;\n        if (this.accumulationPassDebugEnabled)\n            count++;\n        const rows = Math.ceil(Math.sqrt(count));\n        const cols = Math.ceil(count / rows);\n        const width = 1.0 / cols;\n        const height = 1.0 / rows;\n        let x = 0;\n        let y = 0;\n        if (this.gbufferDebugEnabled) {\n            this._gBufferDebugSizeParams.set(x, y, cols, rows);\n            x -= width;\n            if (x <= -1) {\n                x = 0;\n                y -= height;\n            }\n        }\n        if (this.cdfDebugEnabled && this.scene.iblCdfGenerator) {\n            this.scene.iblCdfGenerator.setDebugDisplayParams(x, y, cols, rows);\n            x -= width;\n            if (x <= -1) {\n                x = 0;\n                y -= height;\n            }\n        }\n        if (this.voxelDebugEnabled) {\n            this._voxelRenderer.setDebugDisplayParams(x, y, cols, rows);\n            x -= width;\n            if (x <= -1) {\n                x = 0;\n                y -= height;\n            }\n        }\n        if (this.voxelTracingDebugEnabled) {\n            this._voxelTracingPass.setDebugDisplayParams(x, y, cols, rows);\n            x -= width;\n            if (x <= -1) {\n                x = 0;\n                y -= height;\n            }\n        }\n        if (this.spatialBlurPassDebugEnabled) {\n            this._spatialBlurPass.setDebugDisplayParams(x, y, cols, rows);\n            x -= width;\n            if (x <= -1) {\n                x = 0;\n                y -= height;\n            }\n        }\n        if (this.accumulationPassDebugEnabled) {\n            this._accumulationPass.setDebugDisplayParams(x, y, cols, rows);\n            x -= width;\n            if (x <= -1) {\n                x = 0;\n                y -= height;\n            }\n        }\n    }\n    /**\n     * Update the SS shadow max distance and thickness based on the voxel grid size and resolution.\n     * The max distance should be just a little larger than the world size of a single voxel.\n     */\n    _updateSSShadowParams() {\n        this._voxelTracingPass.sssMaxDist = (this._sssMaxDistScale * this.voxelGridSize) / (1 << this.resolutionExp);\n        this._voxelTracingPass.sssThickness = this._sssThicknessScale * 0.005 * this.voxelGridSize;\n    }\n    /**\n     * Apply the shadows to a material or array of materials. If no material is provided, all\n     * materials in the scene will be added.\n     * @param material Material that will be affected by the shadows. If not provided, all materials of the scene will be affected.\n     */\n    addShadowReceivingMaterial(material) {\n        if (material) {\n            if (Array.isArray(material)) {\n                material.forEach((m) => {\n                    this._addShadowSupportToMaterial(m);\n                });\n            }\n            else {\n                this._addShadowSupportToMaterial(material);\n            }\n        }\n        else {\n            this.scene.materials.forEach((mat) => {\n                this._addShadowSupportToMaterial(mat);\n            });\n        }\n    }\n    /**\n     * Remove a material from the list of materials that receive shadows. If no material\n     * is provided, all materials in the scene will be removed.\n     * @param material The material or array of materials that will no longer receive shadows\n     */\n    removeShadowReceivingMaterial(material) {\n        if (Array.isArray(material)) {\n            material.forEach((m) => {\n                const matIndex = this._materialsWithRenderPlugin.indexOf(m);\n                if (matIndex !== -1) {\n                    this._materialsWithRenderPlugin.splice(matIndex, 1);\n                    const plugin = m.pluginManager?.getPlugin(IBLShadowsPluginMaterial.Name);\n                    plugin.isEnabled = false;\n                }\n            });\n        }\n        else {\n            const matIndex = this._materialsWithRenderPlugin.indexOf(material);\n            if (matIndex !== -1) {\n                this._materialsWithRenderPlugin.splice(matIndex, 1);\n                const plugin = material.pluginManager.getPlugin(IBLShadowsPluginMaterial.Name);\n                plugin.isEnabled = false;\n            }\n        }\n    }\n    _addShadowSupportToMaterial(material) {\n        if (!(material instanceof PBRBaseMaterial) && !(material instanceof StandardMaterial)) {\n            return;\n        }\n        let plugin = material.pluginManager?.getPlugin(IBLShadowsPluginMaterial.Name);\n        if (!plugin) {\n            plugin = new IBLShadowsPluginMaterial(material);\n        }\n        if (this._materialsWithRenderPlugin.indexOf(material) !== -1) {\n            return;\n        }\n        if (this._enabled) {\n            plugin.iblShadowsTexture = this._getAccumulatedTexture().getInternalTexture();\n            plugin.shadowOpacity = this.shadowOpacity;\n        }\n        plugin.isEnabled = this._enabled;\n        plugin.isColored = this._coloredShadows;\n        this._materialsWithRenderPlugin.push(material);\n    }\n    _setPluginParameters() {\n        if (!this._enabled) {\n            return;\n        }\n        this._materialsWithRenderPlugin.forEach((mat) => {\n            if (mat.pluginManager) {\n                const plugin = mat.pluginManager.getPlugin(IBLShadowsPluginMaterial.Name);\n                plugin.iblShadowsTexture = this._getAccumulatedTexture().getInternalTexture();\n                plugin.shadowOpacity = this.shadowOpacity;\n                plugin.isColored = this._coloredShadows;\n            }\n        });\n    }\n    _updateBeforeRender() {\n        this._updateDebugPasses();\n    }\n    _listenForCameraChanges() {\n        // We want to listen for camera changes and change settings while the camera is moving.\n        this.scene.activeCamera?.onViewMatrixChangedObservable.add(() => {\n            this._accumulationPass.isMoving = true;\n        });\n    }\n    /**\n     * Checks if the IBL shadow pipeline is ready to render shadows\n     * @returns true if the IBL shadow pipeline is ready to render the shadows\n     */\n    isReady() {\n        return (this._noiseTexture.isReady() &&\n            this._voxelRenderer.isReady() &&\n            this.scene.iblCdfGenerator &&\n            this.scene.iblCdfGenerator.isReady() &&\n            (!this._voxelTracingPass || this._voxelTracingPass.isReady()) &&\n            (!this._spatialBlurPass || this._spatialBlurPass.isReady()) &&\n            (!this._accumulationPass || this._accumulationPass.isReady()));\n    }\n    /**\n     * Get the class name\n     * @returns \"IBLShadowsRenderPipeline\"\n     */\n    getClassName() {\n        return \"IBLShadowsRenderPipeline\";\n    }\n    /**\n     * Disposes the IBL shadow pipeline and associated resources\n     */\n    dispose() {\n        const materials = this._materialsWithRenderPlugin.splice(0);\n        materials.forEach((mat) => {\n            this.removeShadowReceivingMaterial(mat);\n        });\n        this._disposeEffectPasses();\n        this._noiseTexture.dispose();\n        this._voxelRenderer.dispose();\n        this._voxelTracingPass.dispose();\n        this._spatialBlurPass.dispose();\n        this._accumulationPass.dispose();\n        this._dummyTexture2d.dispose();\n        this._dummyTexture3d.dispose();\n        this.onNewIblReadyObservable.clear();\n        this.onShadowTextureReadyObservable.clear();\n        super.dispose();\n    }\n}\n//# sourceMappingURL=iblShadowsRenderPipeline.js.map","/**\n * Class used to store the global illumination parameters for a reflective shadow map.\n * Instances of this class are used by the GIRSMManager class to generate global illumination for a scene.\n */\nexport class GIRSM {\n    /**\n     * Creates a new GIRSM instance\n     * @param rsm The reflective shadow map\n     */\n    constructor(rsm) {\n        /**\n         * The number of samples to use to generate the global illumination. Default value is 400.\n         */\n        this.numSamples = 400;\n        /**\n         * Radius of the circle in the RSM flux texture to read samples from. Default value is 0.1.\n         * Valid values are between 0 and 1.\n         */\n        this.radius = 0.1;\n        /**\n         * Intensity of the global illumination effect. Default value is 0.1.\n         */\n        this.intensity = 0.1;\n        /**\n         * value used to correct for edge artifacts when calculating the global illumination effect. Default value is 0.1.\n         * Will depend on your scene.\n         */\n        this.edgeArtifactCorrection = 0.1;\n        /**\n         * Defines if samples should be rotated when generating the global illumination effect. Default value is true.\n         * Rotating samples will improve the quality of the global illumination effect by trading banding for noise, at the cost of a bit of performance.\n         */\n        this.rotateSample = true;\n        /**\n         * Noise scale factor, only used if rotateSample is true. Default value is 100.\n         * Will depend on your scene.\n         */\n        this.noiseFactor = 100;\n        /**\n         * Defines if the full texture should be used when generating the global illumination effect. Default value is false.\n         * If true, values for numSamples, radius, rotateSample and noiseFactor will be ignored and the full texture will be used to generate the global illumination effect.\n         * Be careful to use a RSM texture size small enough to limit the number of samples! For eg. a 32x32 texture will generate 1024 samples per pixel!\n         */\n        this.useFullTexture = false;\n        this.rsm = rsm;\n    }\n    /**\n     * Disposes the GIRSM\n     */\n    dispose() {\n        this.rsm.dispose();\n    }\n}\n//# sourceMappingURL=giRSM.js.map","import { SpriteManager } from \"./spriteManager.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\n/**\n * Class used to manage multiple sprites of different sizes on the same spritesheet\n * @see https://doc.babylonjs.com/features/featuresDeepDive/sprites\n */\n/**\n *\n */\nexport class SpritePackedManager extends SpriteManager {\n    /**\n     * Creates a new sprite manager from a packed sprite sheet\n     * @param name defines the manager's name\n     * @param imgUrl defines the sprite sheet url\n     * @param capacity defines the maximum allowed number of sprites\n     * @param scene defines the hosting scene\n     * @param spriteJSON null otherwise a JSON object defining sprite sheet data\n     * @param epsilon defines the epsilon value to align texture (0.01 by default)\n     * @param samplingMode defines the sampling mode to use with spritesheet\n     * @param fromPacked set to true; do not alter\n     * @param options options for the sprite manager\n     */\n    constructor(\n    /** defines the packed manager's name */\n    name, imgUrl, capacity, scene, spriteJSON = null, epsilon = 0.01, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, options) {\n        //the cellSize parameter is not used when built from JSON which provides individual cell data, defaults to 64 if JSON load fails\n        super(name, imgUrl, capacity, 64, scene, epsilon, samplingMode, true, spriteJSON, options);\n        this.name = name;\n    }\n}\n//# sourceMappingURL=spritePackedManager.js.map"],"file":"assets/index-Cbh_XOmO.js"}