const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/vertexColorMixing-CmRbdHdF.js","assets/pointsCloudSystem-2vcS-S4d.js","assets/index-rhFFGTpy.js","assets/motion-3WHHzQTP.js","assets/vendor-CIP6LD3P.js","assets/index-DdXHf9oj.css","assets/bumpVertex-CO1be_N_.js","assets/helperFunctions-Dt8Ez0m5.js","assets/oitFragment-COwarqmx.js","assets/oitFragment-C1qnXpVq.js","assets/default.fragment-B-kdUbSd.js","assets/defaultUboDeclaration-C5WGJzzr.js","assets/mainUVVaryingDeclaration-kAMx1wwy.js","assets/default.fragment-CtvPXGlm.js","assets/defaultUboDeclaration-mfzMqo_r.js","assets/mainUVVaryingDeclaration-BftUusui.js","assets/pbr.vertex-C6clv1jW.js","assets/harmonicsFunctions-C2rlzhtf.js","assets/pbr.fragment-jox_Wzt1.js","assets/pbr.vertex-C_PHP_eE.js","assets/harmonicsFunctions-BiMv5FUV.js","assets/pbr.fragment-CxtSokwZ.js","assets/pass.fragment-B8b0gssu.js","assets/pass.fragment-D7l-dmRx.js"])))=>i.map(i=>d[i]);
import{O as j,m as Q,V as m,C as ne,a as xe,ff as B,L,aq as RR,E as ze,fi as Ci,af as Ve,fg as oi,A as Le,M as $,Q as re,ac as Li,c as ae,a7 as Me,gs as C,eA as Mi,ey as Ue,ez as F,j as Be,l as He,q as z,s as he,b1 as ot,b5 as Zt,i as Te,h as V,r as qi,al as uu,p as N,aI as fi,aW as dr,bI as Mm,bP as MR,G as ko,k as Si,aX as Am,aZ as Dm,f3 as AR,aY as Ms,g6 as li,n as Xa,g as Ze,eE as Hn,eF as cu,eD as qb,b as st,fP as Om,gm as ge,ap as Qt,t as mt,P as Ce,gb as Za,by as P,o as pn,T as Y,F as Kt,w as Dt,ec as DR,U as tn,bt as it,gt as ds,bw as hu,cQ as ts,S as Ut,B as Wr,gu as OR,gv as Qb,_ as du,fS as wR,gw as Kb,z as fu,gx as pu,db as Jb,dy as jn,dF as ey,dG as Yn,ad as Ns,e4 as zo,aj as Zc,f2 as NR,y as Rt,cs as wm,bN as Tc,a_ as Qi,ab as rs,eq as ty,aa as ft,am as FR,eh as Nm,ei as qc,gy as mi,eb as wt,gz as ug,f as Bi,N as _i,x as iy,g2 as LR,g1 as BR,d9 as VR,eN as kR,eV as zR,eQ as UR,v as ry,gA as Uo,gB as cg,f8 as GR,bu as hg,gr as WR,gp as $R,gC as Fm,gD as sy,bB as HR,e$ as jR,bz as YR,bD as XR,bC as ZR,bE as qR,bF as QR,bG as KR,bH as JR,I as eM,gE as tM,bA as iM,em as ny,ao as il,gF as rM,e8 as _t,gj as dg,J as vi,cV as Fs,dC as Lm,cP as Xn,cT as Zn,dB as qn,cS as _n,gG as Cr,gd as sM,ag as nM,cr as Bm,gk as Vm,W as ss,ge as km,e9 as Bl,gf as ay,e1 as Ui,cu as aM,d2 as oy,f1 as Go,dP as mu,dW as zm,dc as vr,dD as Um,dO as ly,dR as uy,dV as cy,dM as hy,dK as dy,dL as fy,d$ as py,dE as Gm,dJ as _u,dx as gu,dw as qa,cR as ps,eB as ir,eI as oM,d4 as Vr,d5 as rn,a6 as At,dY as my,gH as fg,dZ as _y,ai as zn,ah as pg,ej as gy,c$ as xy,eH as lM,eL as uM,cv as rl,R as qt,eY as cM,f7 as Cc,ak as Fn,ar as jr,b9 as Sy,b8 as hM,ep as vy,a9 as xu,d as by,a8 as yy,cy as Ty,aC as dM,cz as fM,dN as Cy,dS as Py,dT as Ey,dU as pM,dX as mM,dQ as Wm,d_ as $m,dz as _M,dA as gM,dH as xM,dI as Hm,X as hr,fu as SM,fR as vM,dv as bM,ct as yM,$ as mg,a0 as _g,fk as TM,a4 as Qn,eo as Cn,gI as Iy,gJ as CM,gK as PM,gL as gg,gM as EM,fj as IM,aP as RM,aN as MM,fc as Hs,gN as Pc,e2 as AM,e5 as DM,es as OM,fa as wM,ae as NM,f6 as FM,an as Ne,gO as LM,gP as BM,eZ as VM,fY as kM,fU as zM,cx as UM,eK as GM,H as Tl,el as WM,gQ as $M,dr as HM}from"./pointsCloudSystem-2vcS-S4d.js";import{_ as k}from"./index-rhFFGTpy.js";import"./bumpVertex-CO1be_N_.js";import"./vertexColorMixing-CmRbdHdF.js";import"./helperFunctions-Dt8Ez0m5.js";import"./default.fragment-B-kdUbSd.js";import"./oitFragment-COwarqmx.js";import{B as Pn,E as Ma,d as En,C as In,S as vs,Q as Rn,c as oa,f as la,e as ua,b as ca}from"./easing-CYNgw8CS.js";import{c as jM}from"./animationGroup-CmNY7dur.js";import"./dds-C64e2J1b.js";import"./khronosTextureContainer2-DKf4UHYP.js";import{s as Cl}from"./flowGraphSetDelayBlock-BBfSTBoS.js";import"./oitFragment-C1qnXpVq.js";import"./default.fragment-CtvPXGlm.js";import"./pbr.fragment-CxtSokwZ.js";import"./pbr.fragment-jox_Wzt1.js";import{G as YM,P as XM}from"./hdr-6elhj4O4.js";import{G as ZM}from"./tga-BWmadVoa.js";import"./default.vertex-kA04vKVP.js";import"./postprocess.vertex-DIr9NoBj.js";class pt{constructor(e,t){this.triggerOptions=e,this.onBeforeExecuteObservable=new j,e.parameter?(this.trigger=e.trigger,this._triggerParameter=e.parameter):e.trigger?this.trigger=e.trigger:this.trigger=e,this._nextActiveAction=this,this._condition=t}_prepare(){}getTriggerParameter(){return this._triggerParameter}setTriggerParameter(e){this._triggerParameter=e}_evaluateConditionForCurrentFrame(){const e=this._condition;if(!e)return!0;const t=this._actionManager.getScene().getRenderId();return e._evaluationId!==t&&(e._evaluationId=t,e._currentResult=e.isValid()),e._currentResult}_executeCurrent(e){this._evaluateConditionForCurrentFrame()&&(this.onBeforeExecuteObservable.notifyObservers(this),this._nextActiveAction.execute(e),this.skipToNextActiveAction())}execute(e){}skipToNextActiveAction(){this._nextActiveAction._child?(this._nextActiveAction._child._actionManager||(this._nextActiveAction._child._actionManager=this._actionManager),this._nextActiveAction=this._nextActiveAction._child):this._nextActiveAction=this}then(e){return this._child=e,e._actionManager=this._actionManager,e._prepare(),e}_getProperty(e){return this._actionManager._getProperty(e)}_getEffectiveTarget(e,t){return this._actionManager._getEffectiveTarget(e,t)}serialize(e){return null}_serialize(e,t){const i={type:1,children:[],name:e.name,properties:e.properties||[]};if(this._child&&this._child.serialize(i),this._condition){const r=this._condition.serialize();return r.children.push(i),t&&t.children.push(r),r}return t&&t.children.push(i),i}}pt._SerializeValueAsString=a=>typeof a=="number"?a.toString():typeof a=="boolean"?a?"true":"false":a instanceof Q?a.x+", "+a.y:a instanceof m?a.x+", "+a.y+", "+a.z:a instanceof ne?a.r+", "+a.g+", "+a.b:a instanceof xe?a.r+", "+a.g+", "+a.b+", "+a.a:a;pt._GetTargetProperty=a=>({name:"target",targetType:a._isMesh?"MeshProperties":a._isLight?"LightProperties":a._isCamera?"CameraProperties":a._isMaterial?"MaterialProperties":"SceneProperties",value:a._isScene?"Scene":a.name});B("BABYLON.Action",pt);class Wo{constructor(e){this._actionManager=e}isValid(){return!0}_getProperty(e){return this._actionManager._getProperty(e)}_getEffectiveTarget(e,t){return this._actionManager._getEffectiveTarget(e,t)}serialize(){}_serialize(e){return{type:2,children:[],name:e.name,properties:e.properties}}}class $t extends Wo{static get IsEqual(){return $t._IsEqual}static get IsDifferent(){return $t._IsDifferent}static get IsGreater(){return $t._IsGreater}static get IsLesser(){return $t._IsLesser}constructor(e,t,i,r,s=$t.IsEqual){super(e),this.propertyPath=i,this.value=r,this.operator=s,this._target=t,this._effectiveTarget=this._getEffectiveTarget(t,this.propertyPath),this._property=this._getProperty(this.propertyPath)}isValid(){switch(this.operator){case $t.IsGreater:return this._effectiveTarget[this._property]>this.value;case $t.IsLesser:return this._effectiveTarget[this._property]<this.value;case $t.IsEqual:case $t.IsDifferent:{let e;return this.value.equals?e=this.value.equals(this._effectiveTarget[this._property]):e=this.value===this._effectiveTarget[this._property],this.operator===$t.IsEqual?e:!e}}return!1}serialize(){return this._serialize({name:"ValueCondition",properties:[pt._GetTargetProperty(this._target),{name:"propertyPath",value:this.propertyPath},{name:"value",value:pt._SerializeValueAsString(this.value)},{name:"operator",value:$t.GetOperatorName(this.operator)}]})}static GetOperatorName(e){switch(e){case $t._IsEqual:return"IsEqual";case $t._IsDifferent:return"IsDifferent";case $t._IsGreater:return"IsGreater";case $t._IsLesser:return"IsLesser";default:return""}}}$t._IsEqual=0;$t._IsDifferent=1;$t._IsGreater=2;$t._IsLesser=3;class qM extends Wo{constructor(e,t){super(e),this.predicate=t}isValid(){return this.predicate()}}class QM extends Wo{constructor(e,t,i){super(e),this.value=i,this._target=t}isValid(){return this._target.state===this.value}serialize(){return this._serialize({name:"StateCondition",properties:[pt._GetTargetProperty(this._target),{name:"value",value:this.value}]})}}B("BABYLON.ValueCondition",$t);B("BABYLON.PredicateCondition",qM);B("BABYLON.StateCondition",QM);class KM extends pt{constructor(e,t,i,r){super(e,r),this.propertyPath=i,this._target=this._effectiveTarget=t}_prepare(){this._effectiveTarget=this._getEffectiveTarget(this._effectiveTarget,this.propertyPath),this._property=this._getProperty(this.propertyPath)}execute(){this._effectiveTarget[this._property]=!this._effectiveTarget[this._property]}serialize(e){return super._serialize({name:"SwitchBooleanAction",properties:[pt._GetTargetProperty(this._target),{name:"propertyPath",value:this.propertyPath}]},e)}}class JM extends pt{constructor(e,t,i,r){super(e,r),this.value=i,this._target=t}execute(){this._target.state=this.value}serialize(e){return super._serialize({name:"SetStateAction",properties:[pt._GetTargetProperty(this._target),{name:"value",value:this.value}]},e)}}class eA extends pt{constructor(e,t,i,r,s){super(e,s),this.propertyPath=i,this.value=r,this._target=this._effectiveTarget=t}_prepare(){this._effectiveTarget=this._getEffectiveTarget(this._effectiveTarget,this.propertyPath),this._property=this._getProperty(this.propertyPath)}execute(){this._effectiveTarget[this._property]=this.value,this._target.markAsDirty&&this._target.markAsDirty(this._property)}serialize(e){return super._serialize({name:"SetValueAction",properties:[pt._GetTargetProperty(this._target),{name:"propertyPath",value:this.propertyPath},{name:"value",value:pt._SerializeValueAsString(this.value)}]},e)}}class tA extends pt{constructor(e,t,i,r,s){super(e,s),this.propertyPath=i,this.value=r,this._target=this._effectiveTarget=t}_prepare(){this._effectiveTarget=this._getEffectiveTarget(this._effectiveTarget,this.propertyPath),this._property=this._getProperty(this.propertyPath),typeof this._effectiveTarget[this._property]!="number"&&L.Warn("Warning: IncrementValueAction can only be used with number values")}execute(){this._effectiveTarget[this._property]+=this.value,this._target.markAsDirty&&this._target.markAsDirty(this._property)}serialize(e){return super._serialize({name:"IncrementValueAction",properties:[pt._GetTargetProperty(this._target),{name:"propertyPath",value:this.propertyPath},{name:"value",value:pt._SerializeValueAsString(this.value)}]},e)}}class iA extends pt{constructor(e,t,i,r,s,n){super(e,n),this.from=i,this.to=r,this.loop=s,this._target=t}_prepare(){}execute(){this._actionManager.getScene().beginAnimation(this._target,this.from,this.to,this.loop)}serialize(e){return super._serialize({name:"PlayAnimationAction",properties:[pt._GetTargetProperty(this._target),{name:"from",value:String(this.from)},{name:"to",value:String(this.to)},{name:"loop",value:pt._SerializeValueAsString(this.loop)||!1}]},e)}}class rA extends pt{constructor(e,t,i){super(e,i),this._target=t}_prepare(){}execute(){this._actionManager.getScene().stopAnimation(this._target)}serialize(e){return super._serialize({name:"StopAnimationAction",properties:[pt._GetTargetProperty(this._target)]},e)}}class Ry extends pt{constructor(e=0,t){super(e,t)}execute(){}serialize(e){return super._serialize({name:"DoNothingAction",properties:[]},e)}}class sA extends pt{constructor(e,t,i,r=!0){super(e,i),this.children=t,this.enableChildrenConditions=r}_prepare(){for(let e=0;e<this.children.length;e++)this.children[e]._actionManager=this._actionManager,this.children[e]._prepare()}execute(e){for(const t of this.children)(!this.enableChildrenConditions||t._evaluateConditionForCurrentFrame())&&t.execute(e)}serialize(e){const t=super._serialize({name:"CombineAction",properties:[],combine:[]},e);for(let i=0;i<this.children.length;i++)t.combine.push(this.children[i].serialize(null));return t}}class nA extends pt{constructor(e,t,i){super(e,i),this.func=t}execute(e){this.func(e)}}class My extends pt{constructor(e,t,i,r){super(e,r),this._target=t,this._parent=i}_prepare(){}execute(){if(this._target.parent===this._parent)return;const e=this._parent.getWorldMatrix().clone();e.invert(),this._target.position=m.TransformCoordinates(this._target.position,e),this._target.parent=this._parent}serialize(e){return super._serialize({name:"SetParentAction",properties:[pt._GetTargetProperty(this._target),pt._GetTargetProperty(this._parent)]},e)}}B("BABYLON.SetParentAction",My);B("BABYLON.ExecuteCodeAction",nA);B("BABYLON.DoNothingAction",Ry);B("BABYLON.StopAnimationAction",rA);B("BABYLON.PlayAnimationAction",iA);B("BABYLON.IncrementValueAction",tA);B("BABYLON.SetValueAction",eA);B("BABYLON.SetStateAction",JM);B("BABYLON.SetParentAction",My);B("BABYLON.SwitchBooleanAction",KM);B("BABYLON.CombineAction",sA);class Qe extends RR{constructor(e){super(),e=e||ze.LastCreatedScene,e&&(this._scene=e,e.actionManagers.push(this))}dispose(){const e=this._scene.actionManagers.indexOf(this);for(let i=0;i<this.actions.length;i++){const r=this.actions[i];Qe.Triggers[r.trigger]--,Qe.Triggers[r.trigger]===0&&delete Qe.Triggers[r.trigger]}this.actions.length=0,e>-1&&this._scene.actionManagers.splice(e,1);const t=this._scene.meshes.filter(i=>i.actionManager===this);for(const i of t)i.actionManager=null}getScene(){return this._scene}hasSpecificTriggers(e){for(let t=0;t<this.actions.length;t++){const i=this.actions[t];if(e.indexOf(i.trigger)>-1)return!0}return!1}hasSpecificTriggers2(e,t){for(let i=0;i<this.actions.length;i++){const r=this.actions[i];if(e==r.trigger||t==r.trigger)return!0}return!1}hasSpecificTrigger(e,t){for(let i=0;i<this.actions.length;i++){const r=this.actions[i];if(r.trigger===e)if(t){if(t(r.getTriggerParameter()))return!0}else return!0}return!1}get hasPointerTriggers(){for(let e=0;e<this.actions.length;e++){const t=this.actions[e];if(t.trigger>=Qe.OnPickTrigger&&t.trigger<=Qe.OnPointerOutTrigger)return!0}return!1}get hasPickTriggers(){for(let e=0;e<this.actions.length;e++){const t=this.actions[e];if(t.trigger>=Qe.OnPickTrigger&&t.trigger<=Qe.OnPickUpTrigger)return!0}return!1}registerAction(e){return e.trigger===Qe.OnEveryFrameTrigger&&this.getScene().actionManager!==this?(L.Warn("OnEveryFrameTrigger can only be used with scene.actionManager"),null):(this.actions.push(e),this.getScene()._registeredActions++,Qe.Triggers[e.trigger]?Qe.Triggers[e.trigger]++:Qe.Triggers[e.trigger]=1,e._actionManager=this,e._prepare(),e)}unregisterAction(e){const t=this.actions.indexOf(e);return t!==-1?(this.actions.splice(t,1),Qe.Triggers[e.trigger]-=1,Qe.Triggers[e.trigger]===0&&delete Qe.Triggers[e.trigger],e._actionManager=null,this.getScene()._registeredActions--,!0):!1}processTrigger(e,t){for(let i=0;i<this.actions.length;i++){const r=this.actions[i];if(r.trigger===e){if(t&&(e===Qe.OnKeyUpTrigger||e===Qe.OnKeyDownTrigger)){const s=r.getTriggerParameter();if(typeof s=="function"){if(!s(t))continue}else if(s&&s!==t.sourceEvent.keyCode){if(!s.toLowerCase)continue;const n=s.toLowerCase();if(n!==t.sourceEvent.key){const o=t.sourceEvent.charCode?t.sourceEvent.charCode:t.sourceEvent.keyCode;if(String.fromCharCode(o).toLowerCase()!==n)continue}}}r._executeCurrent(t)}}}_getEffectiveTarget(e,t){const i=t.split(".");for(let r=0;r<i.length-1;r++)e=e[i[r]];return e}_getProperty(e){const t=e.split(".");return t[t.length-1]}serialize(e){const t={children:new Array,name:e,type:3,properties:new Array};for(let i=0;i<this.actions.length;i++){const r={type:0,children:new Array,name:Qe.GetTriggerName(this.actions[i].trigger),properties:new Array},s=this.actions[i].triggerOptions;if(s&&typeof s!="number")if(s.parameter instanceof Node)r.properties.push(pt._GetTargetProperty(s.parameter));else if(typeof s.parameter=="object"){const n={};Ci.DeepCopy(s.parameter,n,["mesh"]),s.parameter&&s.parameter.mesh&&(n._meshId=s.parameter.mesh.id),r.properties.push({name:"parameter",targetType:null,value:n})}else r.properties.push({name:"parameter",targetType:null,value:s.parameter});this.actions[i].serialize(r),t.children.push(r)}return t}static Parse(e,t,i){const r=new Qe(i);t===null?i.actionManager=r:t.actionManager=r;const s=(l,u)=>{const c=oi("BABYLON."+l);return c&&new c(...u)},n=(l,u,c,h)=>{if(h===null){const g=parseFloat(u);return u==="true"||u==="false"?u==="true":isNaN(g)?u:g}const d=h.split("."),f=u.split(",");for(let g=0;g<d.length;g++)c=c[d[g]];if(typeof c=="boolean")return f[0]==="true";if(typeof c=="string")return f[0];const p=[];for(let g=0;g<f.length;g++)p.push(parseFloat(f[g]));return c instanceof m?m.FromArray(p):c instanceof Ve?Ve.FromArray(p):c instanceof ne?ne.FromArray(p):c instanceof xe?xe.FromArray(p):parseFloat(f[0])},o=(l,u,c,h,d=null)=>{if(l.detached)return;const f=[];let p=null,g=null;const _=l.combine&&l.combine.length>0;if(l.type===2?f.push(r):f.push(u),_){const b=[];for(let y=0;y<l.combine.length;y++)o(l.combine[y],Qe.NothingTrigger,c,h,b);f.push(b)}else for(let b=0;b<l.properties.length;b++){let y=l.properties[b].value;const T=l.properties[b].name,v=l.properties[b].targetType;T==="target"?v==="SceneProperties"?y=p=i:v==="MaterialProperties"?y=p=i.getMaterialByName(y):y=p=i.getNodeByName(y):T==="parent"?y=i.getNodeByName(y):T==="sound"?i.getSoundByName&&(y=i.getSoundByName(y)):T!=="propertyPath"?l.type===2&&T==="operator"?y=$t[y]:y=n(T,y,p,T==="value"?g:null):g=y,f.push(y)}if(d===null?f.push(c):f.push(null),l.name==="InterpolateValueAction"){const b=f[f.length-2];f[f.length-1]=b,f[f.length-2]=c}let S=s(l.name,f);if(S instanceof Wo&&c!==null){const b=new Ry(u,c);h?h.then(b):r.registerAction(b),h=b}d===null?S instanceof Wo?(c=S,S=h):(c=null,h?h.then(S):r.registerAction(S)):d.push(S);for(let b=0;b<l.children.length;b++)o(l.children[b],u,c,S,null)};for(let l=0;l<e.children.length;l++){let u;const c=e.children[l];if(c.properties.length>0){const h=c.properties[0].value,d=c.properties[0].targetType===null?h:i.getMeshByName(h);d._meshId&&(d.mesh=i.getMeshById(d._meshId)),u={trigger:Qe[c.name],parameter:d}}else u=Qe[c.name];for(let h=0;h<c.children.length;h++)c.detached||o(c.children[h],u,null,null)}}static GetTriggerName(e){switch(e){case 0:return"NothingTrigger";case 1:return"OnPickTrigger";case 2:return"OnLeftPickTrigger";case 3:return"OnRightPickTrigger";case 4:return"OnCenterPickTrigger";case 5:return"OnPickDownTrigger";case 6:return"OnDoublePickTrigger";case 7:return"OnPickUpTrigger";case 8:return"OnLongPressTrigger";case 9:return"OnPointerOverTrigger";case 10:return"OnPointerOutTrigger";case 11:return"OnEveryFrameTrigger";case 12:return"OnIntersectionEnterTrigger";case 13:return"OnIntersectionExitTrigger";case 14:return"OnKeyDownTrigger";case 15:return"OnKeyUpTrigger";case 16:return"OnPickOutTrigger";default:return""}}}Qe.NothingTrigger=0;Qe.OnPickTrigger=1;Qe.OnLeftPickTrigger=2;Qe.OnRightPickTrigger=3;Qe.OnCenterPickTrigger=4;Qe.OnPickDownTrigger=5;Qe.OnDoublePickTrigger=6;Qe.OnPickUpTrigger=7;Qe.OnPickOutTrigger=16;Qe.OnLongPressTrigger=8;Qe.OnPointerOverTrigger=9;Qe.OnPointerOutTrigger=10;Qe.OnEveryFrameTrigger=11;Qe.OnIntersectionEnterTrigger=12;Qe.OnIntersectionExitTrigger=13;Qe.OnKeyDownTrigger=14;Qe.OnKeyUpTrigger=15;class aA extends pt{constructor(e,t,i){super(e,i),this._sound=t}_prepare(){}execute(){this._sound!==void 0&&this._sound.play()}serialize(e){return super._serialize({name:"PlaySoundAction",properties:[{name:"sound",value:this._sound.name}]},e)}}class oA extends pt{constructor(e,t,i){super(e,i),this._sound=t}_prepare(){}execute(){this._sound!==void 0&&this._sound.stop()}serialize(e){return super._serialize({name:"StopSoundAction",properties:[{name:"sound",value:this._sound.name}]},e)}}B("BABYLON.PlaySoundAction",aA);B("BABYLON.StopSoundAction",oA);class lA extends pt{constructor(e,t,i,r,s=1e3,n,o,l){super(e,n),this.duration=1e3,this.onInterpolationDoneObservable=new j,this.propertyPath=i,this.value=r,this.duration=s,this.stopOtherAnimations=o,this.onInterpolationDone=l,this._target=this._effectiveTarget=t}_prepare(){this._effectiveTarget=this._getEffectiveTarget(this._effectiveTarget,this.propertyPath),this._property=this._getProperty(this.propertyPath)}execute(){const e=this._actionManager.getScene(),t=[{frame:0,value:this._effectiveTarget[this._property]},{frame:100,value:this.value}];let i;if(typeof this.value=="number")i=Le.ANIMATIONTYPE_FLOAT;else if(this.value instanceof ne)i=Le.ANIMATIONTYPE_COLOR3;else if(this.value instanceof m)i=Le.ANIMATIONTYPE_VECTOR3;else if(this.value instanceof $)i=Le.ANIMATIONTYPE_MATRIX;else if(this.value instanceof re)i=Le.ANIMATIONTYPE_QUATERNION;else{L.Warn("InterpolateValueAction: Unsupported type ("+typeof this.value+")");return}const r=new Le("InterpolateValueAction",this._property,100*(1e3/this.duration),i,Le.ANIMATIONLOOPMODE_CONSTANT);r.setKeys(t),this.stopOtherAnimations&&e.stopAnimation(this._effectiveTarget);const s=()=>{this.onInterpolationDoneObservable.notifyObservers(this),this.onInterpolationDone&&this.onInterpolationDone()};e.beginDirectAnimation(this._effectiveTarget,[r],0,100,!1,1,s)}serialize(e){return super._serialize({name:"InterpolateValueAction",properties:[pt._GetTargetProperty(this._target),{name:"propertyPath",value:this.propertyPath},{name:"value",value:pt._SerializeValueAsString(this.value)},{name:"duration",value:pt._SerializeValueAsString(this.duration)},{name:"stopOtherAnimations",value:pt._SerializeValueAsString(this.stopOtherAnimations)||!1}]},e)}}B("BABYLON.InterpolateValueAction",lA);var xg;(function(a){a[a.NONE=0]="NONE",a[a.STEP=1]="STEP"})(xg||(xg={}));var Sg;(function(a){a[a.Include=0]="Include",a[a.Exclude=1]="Exclude"})(Sg||(Sg={}));class Y4{constructor(e,t=0){this.mode=t,this.disabled=!1,this._targetNames=new Set,e&&this.addTargetName(e)}addTargetName(e){if(Array.isArray(e)){for(const t of e)this._targetNames.add(t);return}this._targetNames.add(e)}removeTargetName(e){if(Array.isArray(e)){for(const t of e)this._targetNames.delete(t);return}this._targetNames.delete(e)}hasTarget(e){return this._targetNames.has(e)}retainsTarget(e){return this._targetNames.has(e)===(this.mode===0)}}var vg;(function(a){a[a.HAS_INPUTS=1]="HAS_INPUTS",a[a.HAS_OUTPUTS=2]="HAS_OUTPUTS",a[a.HAS_INPUTS_AND_OUTPUTS=3]="HAS_INPUTS_AND_OUTPUTS"})(vg||(vg={}));class Ay{constructor(e,t){this.onDisposeObservable=new j,this.engine=e,t&1&&(this._upstreamNodes=new Set),t&2&&(this._downstreamNodes=new Set)}dispose(){if(this._downstreamNodes){for(const e of Array.from(this._downstreamNodes))if(!this._disconnect(e))throw new Error("Disconnect failed");this._downstreamNodes.clear()}if(this._upstreamNodes){for(const e of Array.from(this._upstreamNodes))if(!e._disconnect(this))throw new Error("Disconnect failed");this._upstreamNodes.clear()}this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear()}_connect(e){return!this._downstreamNodes||this._downstreamNodes.has(e)||!e._onConnect(this)?!1:(this._downstreamNodes.add(e),!0)}_disconnect(e){return!this._downstreamNodes||!this._downstreamNodes.delete(e)?!1:e._onDisconnect(this)}_onConnect(e){return!this._upstreamNodes||this._upstreamNodes.has(e)?!1:(this._upstreamNodes.add(e),!0)}_onDisconnect(e){var t;return((t=this._upstreamNodes)==null?void 0:t.delete(e))??!1}}class jm extends Ay{constructor(e,t,i){super(t,i),this.onNameChangedObservable=new j,this._name=e}get name(){return this._name}set name(e){if(this._name===e)return;const t=this._name;this._name=e,this.onNameChangedObservable.notifyObservers({newName:e,oldName:t,node:this})}dispose(){super.dispose(),this.onNameChangedObservable.clear()}}class Su extends jm{constructor(e,t){super(e,t,3)}connect(e){if(!this._connect(e))throw new Error("Connect failed")}disconnect(e){if(!this._disconnect(e))throw new Error("Disconnect failed")}disconnectAll(){if(!this._downstreamNodes)throw new Error("Disconnect failed");const e=this._downstreamNodes.values();for(let t=e.next();!t.done;t=e.next())if(!this._disconnect(t.value))throw new Error("Disconnect failed")}}const Dy={volume:1};class uA extends Su{constructor(e){super("Volume",e)}setOptions(e){this.volume=e.volume??Dy.volume}}function Aa(a){return a.getSubNode("Volume")}function Oy(a,e){var t;return((t=Aa(a))==null?void 0:t[e])??Dy[e]}const go={fftSize:2048,minDecibels:-100,maxDecibels:-30,smoothing:.8};function cA(a){return a.analyzerEnabled||a.analyzerFFTSize!==void 0||a.analyzerMinDecibels!==void 0||a.analyzerMaxDecibels!==void 0||a.analyzerSmoothing!==void 0}class hA{get frequencyBinCount(){return this.fftSize/2}}class dA extends Su{constructor(e){super("Analyzer",e)}setOptions(e){this.fftSize=e.analyzerFFTSize??go.fftSize,this.minDecibels=e.analyzerMinDecibels??go.minDecibels,this.maxDecibels=e.analyzerMaxDecibels??go.maxDecibels,this.smoothing=e.analyzerSmoothing??go.smoothing}}function Xs(a){return a.getSubNode("Analyzer")}function Pl(a,e){var t;return((t=Xs(a))==null?void 0:t[e])??go[e]}function El(a,e,t){a.callOnSubNode("Analyzer",i=>{i[e]=t})}let Ec=null,Ic=null;function wy(){return Ec||(Ec=new Uint8Array),Ec}function Ny(){return Ic||(Ic=new Float32Array),Ic}class Fy extends hA{constructor(e){super(),this._subGraph=e}get fftSize(){return Pl(this._subGraph,"fftSize")}set fftSize(e){El(this._subGraph,"fftSize",e)}get isEnabled(){return Xs(this._subGraph)!==null}get minDecibels(){return Pl(this._subGraph,"minDecibels")}set minDecibels(e){El(this._subGraph,"minDecibels",e)}get maxDecibels(){return Pl(this._subGraph,"maxDecibels")}set maxDecibels(e){El(this._subGraph,"maxDecibels",e)}get smoothing(){return Pl(this._subGraph,"smoothing")}set smoothing(e){El(this._subGraph,"smoothing",e)}dispose(){const e=Xs(this._subGraph);e&&(this._subGraph.removeSubNode(e),e.dispose())}async enableAsync(){return Xs(this._subGraph)||await this._subGraph.createAndAddSubNode("Analyzer"),Promise.resolve()}getByteFrequencyData(){const e=Xs(this._subGraph);return e?e.getByteFrequencyData():(L.Warn("AudioAnalyzer not enabled"),this.enableAsync(),wy())}getFloatFrequencyData(){const e=Xs(this._subGraph);return e?e.getFloatFrequencyData():(L.Warn("AudioAnalyzer not enabled"),this.enableAsync(),Ny())}}class Ly extends jm{constructor(e,t){super(e,t,3),this._analyzer=null}get analyzer(){return this._analyzer??(this._analyzer=new Fy(this._subGraph))}get volume(){return Oy(this._subGraph,"volume")}set volume(e){const t=Aa(this._subGraph);if(!t)throw new Error("No volume subnode");t.volume=e}dispose(){var e;super.dispose(),(e=this._analyzer)==null||e.dispose(),this._analyzer=null,this._subGraph.dispose()}}class By extends jm{constructor(e,t){super(e,t,3),this._analyzer=null,this._newestInstance=null,this._outBus=null,this._privateInstances=new Set,this._state=1,this._instances=this._privateInstances,this.onEndedObservable=new j,this._onInstanceEnded=i=>{this._newestInstance===i&&(this._newestInstance=null),this._privateInstances.delete(i),this._instances.size===0&&(this._state=1,this.onEndedObservable.notifyObservers(this))},this._onOutBusDisposed=()=>{this.outBus=null}}get analyzer(){return this._analyzer??(this._analyzer=new Fy(this._subGraph))}get autoplay(){return this._options.autoplay}get currentTime(){const e=this._getNewestInstance();return e?e.currentTime:0}set currentTime(e){this.startOffset=e;const t=this._getNewestInstance();t&&(t.currentTime=e)}get loop(){return this._options.loop}set loop(e){this._options.loop=e}get maxInstances(){return this._options.maxInstances}set maxInstances(e){this._options.maxInstances=e}get outBus(){return this._outBus}set outBus(e){if(this._outBus!==e){if(this._outBus&&(this._outBus.onDisposeObservable.removeCallback(this._onOutBusDisposed),!this._disconnect(this._outBus)))throw new Error("Disconnect failed");if(this._outBus=e,this._outBus&&(this._outBus.onDisposeObservable.add(this._onOutBusDisposed),!this._connect(this._outBus)))throw new Error("Connect failed")}}get startOffset(){return this._options.startOffset}set startOffset(e){this._options.startOffset=e}get state(){return this._state}get volume(){return Oy(this._subGraph,"volume")}set volume(e){const t=Aa(this._subGraph);if(!t)throw new Error("No volume subnode");t.volume=e}dispose(){var e;super.dispose(),this.stop(),(e=this._analyzer)==null||e.dispose(),this._analyzer=null,this._newestInstance=null,this._outBus=null,this._privateInstances.clear(),this.onEndedObservable.clear()}pause(){const e=this._instances.values();for(let t=e.next();!t.done;t=e.next())t.value.pause();this._state=5}resume(){if(this._state!==5)return;const e=this._instances.values();for(let t=e.next();!t.done;t=e.next())t.value.resume();this._state=3}_beforePlay(e){if(this.state===5&&this._instances.size>0){this.resume();return}e.onEndedObservable.addOnce(this._onInstanceEnded),this._privateInstances.add(e),this._newestInstance=e}_afterPlay(e){this._state=e.state}_getNewestInstance(){if(this._instances.size===0)return null;if(!this._newestInstance){const e=this._instances.values();for(let t=e.next();!t.done;t=e.next())this._newestInstance=t.value}return this._newestInstance}_setState(e){this._state=e}_stopExcessInstances(){if(this.maxInstances<1/0){const e=Array.from(this._instances).filter(i=>i.state===3).length-this.maxInstances,t=this._instances.values();for(let i=0;i<e;i++)t.next().value.stop()}}}class fA extends Ly{constructor(e,t){super(e,t),this._outBus=null,this._onOutBusDisposed=()=>{this.outBus=this.engine.defaultMainBus}}get outBus(){return this._outBus}set outBus(e){if(this._outBus!==e){if(this._outBus&&(this._outBus.onDisposeObservable.removeCallback(this._onOutBusDisposed),!this._disconnect(this._outBus)))throw new Error("Disconnect failed");if(this._outBus=e,this._outBus&&(this._outBus.onDisposeObservable.add(this._onOutBusDisposed),!this._connect(this._outBus)))throw new Error("Connect failed")}}dispose(){super.dispose(),this._outBus=null}}class pA extends Ly{constructor(e,t){super(e,t)}}class mA extends By{constructor(e,t){super(e,t)}get duration(){return this._options.duration}set duration(e){this._options.duration=e}get loopStart(){return this._options.loopStart}set loopStart(e){this._options.loopStart=e}get loopEnd(){return this._options.loopEnd}set loopEnd(e){this._options.loopEnd=e}get pitch(){return this._options.pitch}set pitch(e){this._options.pitch=e;const t=this._instances.values();for(let i=t.next();!i.done;i=t.next())i.value.pitch=e}get playbackRate(){return this._options.playbackRate}set playbackRate(e){this._options.playbackRate=e;const t=this._instances.values();for(let i=t.next();!i.done;i=t.next())i.value.playbackRate=e}play(e={}){if(this.state===5){this.resume();return}e.duration??(e.duration=this.duration),e.loop??(e.loop=this.loop),e.loopStart??(e.loopStart=this.loopStart),e.loopEnd??(e.loopEnd=this.loopEnd),e.startOffset??(e.startOffset=this.startOffset),e.volume??(e.volume=1),e.waitTime??(e.waitTime=0);const t=this._createInstance();this._beforePlay(t),t.play(e),this._afterPlay(t),this._stopExcessInstances()}stop(e={}){if(e.waitTime&&0<e.waitTime?this._setState(0):this._setState(1),!!this._instances)for(const t of Array.from(this._instances))t.stop(e)}}class _A{constructor(e){this.engine=e}}class gA extends By{constructor(e,t){super(e,t),this._preloadedInstances=new Array}get preloadCount(){return this._options.preloadCount??1}get preloadCompletedCount(){return this._preloadedInstances.length}preloadInstanceAsync(){const e=this._createInstance();return this._addPreloadedInstance(e),e.preloadedPromise}async preloadInstancesAsync(e){for(let t=0;t<e;t++)this.preloadInstanceAsync();await Promise.all(this._preloadedInstances.map(t=>t.preloadedPromise))}play(e={}){if(this.state===5){this.resume();return}let t;this.preloadCompletedCount>0?(t=this._preloadedInstances[0],t.startOffset=this.startOffset,this._removePreloadedInstance(t)):t=this._createInstance();const i=()=>{t.state===3&&(this._stopExcessInstances(),t.onStateChangedObservable.removeCallback(i))};t.onStateChangedObservable.add(i),e.startOffset??(e.startOffset=this.startOffset),e.loop??(e.loop=this.loop),e.volume??(e.volume=1),this._beforePlay(t),t.play(e),this._afterPlay(t)}stop(){if(this._setState(1),!!this._instances)for(const e of Array.from(this._instances))e.stop()}_addPreloadedInstance(e){this._preloadedInstances.includes(e)||this._preloadedInstances.push(e)}_removePreloadedInstance(e){const t=this._preloadedInstances.indexOf(e);t!==-1&&this._preloadedInstances.splice(t,1)}}const xi={coneInnerAngle:6.28318530718,coneOuterAngle:6.28318530718,coneOuterVolume:0,distanceModel:"linear",maxDistance:1e4,minDistance:1,panningModel:"equalpower",position:m.Zero(),rolloffFactor:1,rotation:m.Zero(),rotationQuaternion:new re};function vu(a){return a.spatialEnabled||a.spatialAutoUpdate!==void 0||a.spatialConeInnerAngle!==void 0||a.spatialConeOuterAngle!==void 0||a.spatialConeOuterVolume!==void 0||a.spatialDistanceModel!==void 0||a.spatialMaxDistance!==void 0||a.spatialMinDistance!==void 0||a.spatialMinUpdateTime!==void 0||a.spatialPanningModel!==void 0||a.spatialPosition!==void 0||a.spatialRolloffFactor!==void 0||a.spatialRotation!==void 0||a.spatialRotationQuaternion!==void 0}class xA{}const SA={position:m.Zero(),rotation:m.Zero(),rotationQuaternion:new re};function X4(a){return a.listenerEnabled||a.listenerMinUpdateTime!==void 0||a.listenerPosition!==void 0||a.listenerRotation!==void 0||a.listenerRotationQuaternion!==void 0}class vA{}const Vy={pan:0};function bA(a){return a.stereoEnabled||a.stereoPan!==void 0}class yA{}var bg;(function(a){a[a.Stopping=0]="Stopping",a[a.Stopped=1]="Stopped",a[a.Starting=2]="Starting",a[a.Started=3]="Started",a[a.FailedToStart=4]="FailedToStart",a[a.Paused=5]="Paused"})(bg||(bg={}));var yg;(function(a){a[a.Position=1]="Position",a[a.Rotation=2]="Rotation",a[a.PositionAndRotation=3]="PositionAndRotation"})(yg||(yg={}));class TA extends Su{constructor(e){super("Stereo",e)}setOptions(e){this.pan=e.stereoPan??Vy.pan}}function Qc(a){return a.getSubNode("Stereo")}function CA(a,e){var t;return((t=Qc(a))==null?void 0:t[e])??Vy[e]}function PA(a,e,t){a.callOnSubNode("Stereo",i=>{i[e]=t})}class Ym extends yA{constructor(e){super(),this._subGraph=e}get pan(){return CA(this._subGraph,"pan")}set pan(e){PA(this._subGraph,"pan",e)}}class Kc{constructor(e){this._attachmentType=3,this._position=new m,this._rotationQuaternion=new re,this._sceneNode=null,this._useBoundingBox=!1,this.dispose=()=>{this.detach()},this._spatialAudioNode=e}get isAttached(){return this._sceneNode!==null}attach(e,t,i){this._sceneNode!==e&&(this.detach(),e&&(this._attachmentType=i,this._sceneNode=e,this._sceneNode.onDisposeObservable.add(this.dispose),this._useBoundingBox=t))}detach(){var e;(e=this._sceneNode)==null||e.onDisposeObservable.removeCallback(this.dispose),this._sceneNode=null}update(){var e,t;this._attachmentType&1&&(this._useBoundingBox&&this._sceneNode.getBoundingInfo?this._position.copyFrom(this._sceneNode.getBoundingInfo().boundingBox.centerWorld):(e=this._sceneNode)==null||e.getWorldMatrix().getTranslationToRef(this._position),this._spatialAudioNode.position.copyFrom(this._position),this._spatialAudioNode._updatePosition()),this._attachmentType&2&&((t=this._sceneNode)==null||t.getWorldMatrix().decompose(void 0,this._rotationQuaternion),this._spatialAudioNode.rotationQuaternion.copyFrom(this._rotationQuaternion),this._spatialAudioNode._updateRotation())}}class EA extends Su{constructor(e){super("Spatial",e),this._attacherComponent=null}get isAttached(){return this._attacherComponent!==null&&this._attacherComponent.isAttached}attach(e,t,i){this.detach(),this._attacherComponent||(this._attacherComponent=new Kc(this)),this._attacherComponent.attach(e,t,i)}detach(){var e;(e=this._attacherComponent)==null||e.detach()}dispose(){var e;super.dispose(),(e=this._attacherComponent)==null||e.dispose(),this._attacherComponent=null}setOptions(e){this.coneInnerAngle=e.spatialConeInnerAngle??xi.coneInnerAngle,this.coneOuterAngle=e.spatialConeOuterAngle??xi.coneOuterAngle,this.coneOuterVolume=e.spatialConeOuterVolume??xi.coneOuterVolume,this.distanceModel=e.spatialDistanceModel??xi.distanceModel,this.maxDistance=e.spatialMaxDistance??xi.maxDistance,this.minDistance=e.spatialMinDistance??xi.minDistance,this.panningModel=e.spatialPanningModel??xi.panningModel,this.rolloffFactor=e.spatialRolloffFactor??xi.rolloffFactor,e.spatialPosition&&(this.position=e.spatialPosition.clone()),e.spatialRotationQuaternion?this.rotationQuaternion=e.spatialRotationQuaternion.clone():e.spatialRotation?this.rotation=e.spatialRotation.clone():this.rotationQuaternion=xi.rotationQuaternion.clone(),this.update()}update(){var e;this.isAttached?(e=this._attacherComponent)==null||e.update():(this._updatePosition(),this._updateRotation())}}function bs(a){return a.getSubNode("Spatial")}function zs(a,e){var t;return((t=bs(a))==null?void 0:t[e])??xi[e]}function Us(a,e,t){a.callOnSubNode("Spatial",i=>{i[e]=t})}const Tg=$.Zero(),Rc=new re,Il=m.Zero();function Cg(a){return a*Math.PI/180}function Pg(a){return a*180/Math.PI}async function IA(a){return new RA(a)}class RA extends EA{constructor(e){super(e),this._lastPosition=m.Zero(),this._lastRotation=m.Zero(),this._lastRotationQuaternion=new re,this.position=xi.position.clone(),this.rotation=xi.rotation.clone(),this.rotationQuaternion=xi.rotationQuaternion.clone(),this.node=new PannerNode(e._audioContext)}get coneInnerAngle(){return Cg(this.node.coneInnerAngle)}set coneInnerAngle(e){this.node.coneInnerAngle=Pg(e)}get coneOuterAngle(){return Cg(this.node.coneOuterAngle)}set coneOuterAngle(e){this.node.coneOuterAngle=Pg(e)}get coneOuterVolume(){return this.node.coneOuterGain}set coneOuterVolume(e){this.node.coneOuterGain=e}get distanceModel(){return this.node.distanceModel}set distanceModel(e){this.node.distanceModel=e;const t=this.node.maxDistance;this.node.maxDistance=t+.001,this.node.maxDistance=t}get minDistance(){return this.node.refDistance}set minDistance(e){this.node.refDistance=e}get maxDistance(){return this.node.maxDistance}set maxDistance(e){this.node.maxDistance=e}get panningModel(){return this.node.panningModel}set panningModel(e){this.node.panningModel=e}get rolloffFactor(){return this.node.rolloffFactor}set rolloffFactor(e){this.node.rolloffFactor=e}get _inNode(){return this.node}get _outNode(){return this.node}_updatePosition(){this._lastPosition.equalsWithEpsilon(this.position)||(this.engine._setAudioParam(this.node.positionX,this.position.x),this.engine._setAudioParam(this.node.positionY,this.position.y),this.engine._setAudioParam(this.node.positionZ,this.position.z),this._lastPosition.copyFrom(this.position))}_updateRotation(){if(!this._lastRotationQuaternion.equalsWithEpsilon(this.rotationQuaternion))Rc.copyFrom(this.rotationQuaternion),this._lastRotationQuaternion.copyFrom(this.rotationQuaternion);else if(!this._lastRotation.equalsWithEpsilon(this.rotation))re.FromEulerAnglesToRef(this.rotation.x,this.rotation.y,this.rotation.z,Rc),this._lastRotation.copyFrom(this.rotation);else return;$.FromQuaternionToRef(Rc,Tg),m.TransformNormalToRef(m.RightReadOnly,Tg,Il),this.engine._setAudioParam(this.node.orientationX,Il.x),this.engine._setAudioParam(this.node.orientationY,Il.y),this.engine._setAudioParam(this.node.orientationZ,Il.z)}_connect(e){return super._connect(e)?(e._inNode&&this.node.connect(e._inNode),!0):!1}_disconnect(e){return super._disconnect(e)?(e._inNode&&this.node.disconnect(e._inNode),!0):!1}getClassName(){return"_SpatialWebAudioSubNode"}}async function MA(a){return new AA(a)}class AA extends TA{constructor(e){super(e),this._pan=0,this.node=new StereoPannerNode(e._audioContext)}get pan(){return this._pan}set pan(e){this._pan=e,this.engine._setAudioParam(this.node.pan,e)}get _inNode(){return this.node}get _outNode(){return this.node}getClassName(){return"_StereoWebAudioSubNode"}_connect(e){return super._connect(e)?(e._inNode&&this.node.connect(e._inNode),!0):!1}_disconnect(e){return super._disconnect(e)?(e._inNode&&this.node.disconnect(e._inNode),!0):!1}}class DA{constructor(){this._createSubNodePromises={},this._isDisposed=!1,this._subNodes={},this._onSubNodeDisposed=e=>{const t=e;delete this._subNodes[t.name],this._onSubNodesChanged()}}callOnSubNode(e,t){const i=this.getSubNode(e);if(i){t(i);return}this._createSubNodePromisesResolved().then(()=>{const r=this.getSubNode(e);if(r){t(r);return}this.createAndAddSubNode(e).then(s=>{t(s)})})}createAndAddSubNode(e){var t;return(t=this._createSubNodePromises)[e]||(t[e]=this._createSubNode(e).then(i=>(this._addSubNode(i),i))),this._createSubNodePromises[e]}dispose(){this._isDisposed=!0;const e=Object.values(this._subNodes);for(const t of e)t.dispose();this._subNodes={},this._createSubNodePromises={}}getSubNode(e){return this._subNodes[e]??null}async removeSubNode(e){await this._createSubNodePromisesResolved();const t=e.name;this._subNodes[t]&&delete this._subNodes[t],delete this._createSubNodePromises[t],this._onSubNodesChanged()}_createSubNodePromisesResolved(){return Promise.all(Object.values(this._createSubNodePromises))}_addSubNode(e){if(this._isDisposed){e.dispose();return}this._subNodes[e.name]=e,e.onDisposeObservable.addOnce(this._onSubNodeDisposed),this._onSubNodesChanged()}}async function OA(a){return new wA(a)}class wA extends uA{constructor(e){super(e),this._volume=1,this.node=new GainNode(e._audioContext)}get volume(){return this._volume}set volume(e){this._volume=e,this.engine._setAudioParam(this.node.gain,e)}get _inNode(){return this.node}get _outNode(){return this.node}_connect(e){return super._connect(e)?(e._inNode&&this.node.connect(e._inNode),!0):!1}_disconnect(e){return super._disconnect(e)?(e._inNode&&this.node.disconnect(e._inNode),!0):!1}getClassName(){return"_VolumeWebAudioSubNode"}}async function NA(a){return new FA(a)}class FA extends dA{constructor(e){super(e),this._byteFrequencyData=null,this._floatFrequencyData=null,this._analyzerNode=new AnalyserNode(e._audioContext)}get fftSize(){return this._analyzerNode.fftSize}set fftSize(e){e!==this._analyzerNode.fftSize&&(this._analyzerNode.fftSize=e,this._clearArrays())}get _inNode(){return this._analyzerNode}get minDecibels(){return this._analyzerNode.minDecibels}set minDecibels(e){this._analyzerNode.minDecibels=e}get maxDecibels(){return this._analyzerNode.maxDecibels}set maxDecibels(e){this._analyzerNode.maxDecibels=e}get smoothing(){return this._analyzerNode.smoothingTimeConstant}set smoothing(e){this._analyzerNode.smoothingTimeConstant=e}dispose(){super.dispose(),this._clearArrays(),this._byteFrequencyData=null,this._floatFrequencyData=null,this._analyzerNode.disconnect()}getClassName(){return"_WebAudioAnalyzerSubNode"}getByteFrequencyData(){return(!this._byteFrequencyData||this._byteFrequencyData.length===0)&&(this._byteFrequencyData=new Uint8Array(this._analyzerNode.frequencyBinCount)),this._analyzerNode.getByteFrequencyData(this._byteFrequencyData),this._byteFrequencyData}getFloatFrequencyData(){return(!this._floatFrequencyData||this._floatFrequencyData.length===0)&&(this._floatFrequencyData=new Float32Array(this._analyzerNode.frequencyBinCount)),this._analyzerNode.getFloatFrequencyData(this._floatFrequencyData),this._floatFrequencyData}_clearArrays(){var e,t;(e=this._byteFrequencyData)==null||e.set(wy()),(t=this._floatFrequencyData)==null||t.set(Ny())}}class ky extends DA{constructor(e){super(),this._outputNode=null,this._owner=e}async init(e){const t=cA(e);if(t&&await this.createAndAddSubNode("Analyzer"),await this.createAndAddSubNode("Volume"),await this._createSubNodePromisesResolved(),t){const r=Xs(this);if(!r)throw new Error("No analyzer subnode.");r.setOptions(e)}const i=Aa(this);if(!i)throw new Error("No volume subnode.");if(i.setOptions(e),i.getClassName()!=="_VolumeWebAudioSubNode")throw new Error("Not a WebAudio subnode.");if(this._outputNode=i.node,this._outputNode&&this._downstreamNodes){const r=this._downstreamNodes.values();for(let s=r.next();!s.done;s=r.next()){const n=s.value._inNode;n&&this._outputNode.connect(n)}}}get _inNode(){return this._outputNode}get _outNode(){return this._outputNode}_createSubNode(e){switch(e){case"Analyzer":return NA(this._owner.engine);case"Volume":return OA(this._owner.engine);default:throw new Error(`Unknown subnode name: ${e}`)}}_onSubNodesChanged(){const e=Xs(this),t=Aa(this);e&&t&&t.connect(e)}}class Xm extends ky{constructor(){super(...arguments),this._rootNode=null,this._inputNode=null}async init(e){var r,s;await super.init(e);let t=!1,i=!1;(t=vu(e))&&await this.createAndAddSubNode("Spatial"),(i=bA(e))&&await this.createAndAddSubNode("Stereo"),await this._createSubNodePromisesResolved(),t&&((r=bs(this))==null||r.setOptions(e)),i&&((s=Qc(this))==null||s.setOptions(e))}get _inNode(){return this._inputNode}_createSubNode(e){try{return super._createSubNode(e)}catch{}switch(e){case"Spatial":return IA(this._owner.engine);case"Stereo":return MA(this._owner.engine);default:throw new Error(`Unknown subnode name: ${e}`)}}_onSubNodesChanged(){var n,o,l;super._onSubNodesChanged();const e=bs(this),t=Qc(this),i=Aa(this);if(e&&e.getClassName()!=="_SpatialWebAudioSubNode")throw new Error("Not a WebAudio subnode.");if(t&&t.getClassName()!=="_StereoWebAudioSubNode")throw new Error("Not a WebAudio subnode.");if(i&&i.getClassName()!=="_VolumeWebAudioSubNode")throw new Error("Not a WebAudio subnode.");e&&(e.disconnectAll(),i&&e.connect(i)),t&&(t.disconnectAll(),i&&t.connect(i)),e&&t?(this._rootNode=new GainNode(this._owner.engine._audioContext),this._rootNode.connect(e._outNode),this._rootNode.connect(t._outNode)):((n=this._rootNode)==null||n.disconnect(),this._rootNode=null);let r=null,s=null;if(this._rootNode?s=this._rootNode:(e?r=e:t?r=t:i&&(r=i),s=(r==null?void 0:r.node)??null),this._inputNode!==s){if(this._inputNode&&this._upstreamNodes){const u=this._upstreamNodes.values();for(let c=u.next();!c.done;c=u.next())(o=c.value._outNode)==null||o.disconnect(this._inputNode)}if(this._inputNode=s,s&&this._upstreamNodes){const u=this._upstreamNodes.values();for(let c=u.next();!c.done;c=u.next())(l=c.value._outNode)==null||l.connect(s)}}}}class LA extends xA{constructor(e){super();const t=bs(e);t?(this._position=t.position.clone(),this._rotation=t.rotation.clone(),this._rotationQuaternion=t.rotationQuaternion.clone()):(this._position=xi.position.clone(),this._rotation=xi.rotation.clone(),this._rotationQuaternion=xi.rotationQuaternion.clone(),e.createAndAddSubNode("Spatial")),this._subGraph=e}get coneInnerAngle(){return zs(this._subGraph,"coneInnerAngle")??xi.coneInnerAngle}set coneInnerAngle(e){Us(this._subGraph,"coneInnerAngle",e)}get coneOuterAngle(){return zs(this._subGraph,"coneOuterAngle")}set coneOuterAngle(e){Us(this._subGraph,"coneOuterAngle",e)}get coneOuterVolume(){return zs(this._subGraph,"coneOuterVolume")}set coneOuterVolume(e){Us(this._subGraph,"coneOuterVolume",e)}get distanceModel(){return zs(this._subGraph,"distanceModel")}set distanceModel(e){Us(this._subGraph,"distanceModel",e)}get isAttached(){var e;return((e=this._subGraph.getSubNode("Spatial"))==null?void 0:e.isAttached)??!1}get maxDistance(){return zs(this._subGraph,"maxDistance")??xi.maxDistance}set maxDistance(e){e<=0&&(e=1e-6),Us(this._subGraph,"maxDistance",e)}get minDistance(){return zs(this._subGraph,"minDistance")}set minDistance(e){Us(this._subGraph,"minDistance",e)}get panningModel(){return zs(this._subGraph,"panningModel")}set panningModel(e){Us(this._subGraph,"panningModel",e)}get position(){return this._position}set position(e){this._position=e,this._updatePosition()}get rolloffFactor(){return zs(this._subGraph,"rolloffFactor")}set rolloffFactor(e){Us(this._subGraph,"rolloffFactor",e)}get rotation(){return this._rotation}set rotation(e){this._rotation=e,this._updateRotation()}get rotationQuaternion(){return this._rotationQuaternion}set rotationQuaternion(e){this._rotationQuaternion=e,this._updateRotation()}attach(e,t=!1,i=3){var r;(r=bs(this._subGraph))==null||r.attach(e,t,i)}detach(){var e;(e=bs(this._subGraph))==null||e.detach()}update(){const e=bs(this._subGraph);e&&(e.isAttached?e.update():(this._updatePosition(e),this._updateRotation(e)))}_updatePosition(e=null){if(!e&&(e=bs(this._subGraph),!e))return;e.position.equalsWithEpsilon(this._position)||(e.position.copyFrom(this._position),e._updatePosition())}_updateRotation(e=null){!e&&(e=bs(this._subGraph),!e)||(e.rotationQuaternion.equalsWithEpsilon(this._rotationQuaternion)?e.rotation.equalsWithEpsilon(this._rotation)||(e.rotation.copyFrom(this._rotation),e._updateRotation()):(e.rotationQuaternion.copyFrom(this._rotationQuaternion),e._updateRotation()))}}class zy{constructor(e,t,i){if(this._autoUpdate=!0,this._lastUpdateTime=0,this.minUpdateTime=0,!t)return;this.minUpdateTime=i;const r=()=>{if(!this._autoUpdate)return;let s=!1;if(0<this.minUpdateTime){const n=Li.Now;this._lastUpdateTime&&n-this._lastUpdateTime<this.minUpdateTime&&(s=!0),this._lastUpdateTime=n}s||e.update(),requestAnimationFrame(r)};requestAnimationFrame(r)}dispose(){this._autoUpdate=!1}}class Zm extends LA{constructor(e,t,i){super(e),this._updaterComponent=new zy(this,t,i)}get minUpdateTime(){return this._updaterComponent.minUpdateTime}set minUpdateTime(e){this._updaterComponent.minUpdateTime=e}dispose(){this._updaterComponent.dispose(),this._updaterComponent=null}}class bu extends fA{constructor(e,t,i){super(e,t),this._spatial=null,this._spatialAutoUpdate=!0,this._spatialMinUpdateTime=0,this._stereo=null,typeof i.spatialAutoUpdate=="boolean"&&(this._spatialAutoUpdate=i.spatialAutoUpdate),typeof i.spatialMinUpdateTime=="number"&&(this._spatialMinUpdateTime=i.spatialMinUpdateTime),this._subGraph=new bu._SubGraph(this)}async _init(e){e.outBus?this.outBus=e.outBus:(await this.engine.isReadyPromise,this.outBus=this.engine.defaultMainBus),await this._subGraph.init(e),vu(e)&&this._initSpatialProperty(),this.engine._addNode(this)}dispose(){super.dispose(),this._spatial=null,this._stereo=null,this.engine._removeNode(this)}get _inNode(){return this._subGraph._inNode}get _outNode(){return this._subGraph._outNode}get spatial(){return this._spatial?this._spatial:this._initSpatialProperty()}get stereo(){return this._stereo??(this._stereo=new Ym(this._subGraph))}getClassName(){return"_WebAudioBus"}_connect(e){var i;return super._connect(e)?(e._inNode&&((i=this._outNode)==null||i.connect(e._inNode)),!0):!1}_disconnect(e){var i;return super._disconnect(e)?(e._inNode&&((i=this._outNode)==null||i.disconnect(e._inNode)),!0):!1}_initSpatialProperty(){return this._spatial||(this._spatial=new Zm(this._subGraph,this._spatialAutoUpdate,this._spatialMinUpdateTime)),this._spatial}}bu._SubGraph=class extends Xm{get _downstreamNodes(){return this._owner._downstreamNodes??null}get _upstreamNodes(){return this._owner._upstreamNodes??null}};const Z4=Object.freeze(Object.defineProperty({__proto__:null,_WebAudioBus:bu},Symbol.toStringTag,{value:"Module"}));class BA extends vA{constructor(){super(),this._attacherComponent=null,this._attacherComponent=new Kc(this)}get isAttached(){return this._attacherComponent!==null&&this._attacherComponent.isAttached}attach(e,t=!1,i=3){this._attacherComponent||(this._attacherComponent=new Kc(this)),this._attacherComponent.attach(e,t,i)}detach(){var e;(e=this._attacherComponent)==null||e.detach()}dispose(){var e;(e=this._attacherComponent)==null||e.dispose(),this._attacherComponent=null}setOptions(e){e.listenerMinUpdateTime!==void 0&&(this.minUpdateTime=e.listenerMinUpdateTime),e.listenerPosition&&(this.position=e.listenerPosition.clone()),e.listenerRotationQuaternion?this.rotationQuaternion=e.listenerRotationQuaternion.clone():e.listenerRotation?this.rotation=e.listenerRotation.clone():this.rotationQuaternion=SA.rotationQuaternion.clone(),this.update()}}const Mc=$.Zero(),Ac=new re,Gs=m.Zero();function q4(a,e,t){return new VA(a,e,t)}class VA extends BA{constructor(e,t,i){super(),this._lastPosition=m.Zero(),this._lastRotation=m.Zero(),this._lastRotationQuaternion=new re,this.position=m.Zero(),this.rotation=m.Zero(),this.rotationQuaternion=new re,this.engine=e,this._audioContext=e._audioContext,this._updaterComponent=new zy(this,t,i)}get minUpdateTime(){return this._updaterComponent.minUpdateTime}set minUpdateTime(e){this._updaterComponent.minUpdateTime=e}dispose(){super.dispose(),this._updaterComponent.dispose(),this._updaterComponent=null}update(){var e;this.isAttached?(e=this._attacherComponent)==null||e.update():(this._updatePosition(),this._updateRotation())}_updatePosition(){if(this._lastPosition.equalsWithEpsilon(this.position))return;const e=this._audioContext.listener;this.engine._setAudioParam(e.positionX,this.position.x),this.engine._setAudioParam(e.positionY,this.position.y),this.engine._setAudioParam(e.positionZ,this.position.z),this._lastPosition.copyFrom(this.position)}_updateRotation(){if(!this._lastRotationQuaternion.equalsWithEpsilon(this.rotationQuaternion))Ac.copyFrom(this.rotationQuaternion),this._lastRotationQuaternion.copyFrom(this.rotationQuaternion);else if(!this._lastRotation.equalsWithEpsilon(this.rotation))re.FromEulerAnglesToRef(this.rotation.x,this.rotation.y,this.rotation.z,Ac),this._lastRotation.copyFrom(this.rotation);else return;$.FromQuaternionToRef(Ac,Mc);const e=this._audioContext.listener;m.TransformNormalToRef(m.RightHandedForwardReadOnly,Mc,Gs),this.engine._setAudioParam(e.forwardX,Gs.x),this.engine._setAudioParam(e.forwardY,Gs.y),this.engine._setAudioParam(e.forwardZ,Gs.z),m.TransformNormalToRef(m.Up(),Mc,Gs),this.engine._setAudioParam(e.upX,Gs.x),this.engine._setAudioParam(e.upY,Gs.y),this.engine._setAudioParam(e.upZ,Gs.z)}}class yu extends pA{constructor(e,t){super(e,t),this._subGraph=new yu._SubGraph(this)}async _init(e){if(await this._subGraph.init(e),this.engine.mainOut&&!this._connect(this.engine.mainOut))throw new Error("Connect failed");this.engine._addMainBus(this)}dispose(){super.dispose(),this.engine._removeMainBus(this)}get _inNode(){return this._subGraph._inNode}get _outNode(){return this._subGraph._outNode}_connect(e){var i;return super._connect(e)?(e._inNode&&((i=this._outNode)==null||i.connect(e._inNode)),!0):!1}_disconnect(e){var i;return super._disconnect(e)?(e._inNode&&((i=this._outNode)==null||i.disconnect(e._inNode)),!0):!1}getClassName(){return"_WebAudioMainBus"}}yu._SubGraph=class extends ky{get _downstreamNodes(){return this._owner._downstreamNodes??null}};const Q4=Object.freeze(Object.defineProperty({__proto__:null,_WebAudioMainBus:yu},Symbol.toStringTag,{value:"Module"}));class Uy extends Ay{constructor(e){super(e.engine,2),this._state=1,this.onEndedObservable=new j,this.onErrorObservable=new j,this.onStateChangedObservable=new j,this._sound=e}get state(){return this._state}dispose(){super.dispose(),this.stop(),this.onEndedObservable.clear(),this.onStateChangedObservable.clear()}_setState(e){this._state!==e&&(this._state=e,this.onStateChangedObservable.notifyObservers(this))}}class kA extends Uy{}const zA=new RegExp("\\.(\\w{3,4})($|\\?)");function Jc(a){return a.replace(/#/gm,"%23")}class Da extends mA{constructor(e,t,i){super(e,t),this._spatial=null,this._spatialAutoUpdate=!0,this._spatialMinUpdateTime=0,this._stereo=null,typeof i.spatialAutoUpdate=="boolean"&&(this._spatialAutoUpdate=i.spatialAutoUpdate),typeof i.spatialMinUpdateTime=="number"&&(this._spatialMinUpdateTime=i.spatialMinUpdateTime),this._options={autoplay:i.autoplay??!1,duration:i.duration??0,loop:i.loop??!1,loopEnd:i.loopEnd??0,loopStart:i.loopStart??0,maxInstances:i.maxInstances??1/0,pitch:i.pitch??0,playbackRate:i.playbackRate??1,startOffset:i.startOffset??0},this._subGraph=new Da._SubGraph(this)}async _init(e,t){this._audioContext=this.engine._audioContext,e instanceof Gy?this._buffer=e:(typeof e=="string"||Array.isArray(e)||e instanceof ArrayBuffer||e instanceof AudioBuffer)&&(this._buffer=await this.engine.createSoundBufferAsync(e,t)),t.outBus?this.outBus=t.outBus:(await this.engine.isReadyPromise,this.outBus=this.engine.defaultMainBus),await this._subGraph.init(t),vu(t)&&this._initSpatialProperty(),t.autoplay&&this.play(),this.engine._addNode(this)}get buffer(){return this._buffer}get _inNode(){return this._subGraph._inNode}get _outNode(){return this._subGraph._outNode}get spatial(){return this._spatial?this._spatial:this._initSpatialProperty()}get stereo(){return this._stereo??(this._stereo=new Ym(this._subGraph))}dispose(){var e;super.dispose(),(e=this._spatial)==null||e.dispose(),this._spatial=null,this._stereo=null,this._subGraph.dispose(),this.engine._removeNode(this)}getClassName(){return"_WebAudioStaticSound"}_createInstance(){return new UA(this,this._options)}_connect(e){var i;return super._connect(e)?(e._inNode&&((i=this._outNode)==null||i.connect(e._inNode)),!0):!1}_disconnect(e){var i;return super._disconnect(e)?(e._inNode&&((i=this._outNode)==null||i.disconnect(e._inNode)),!0):!1}_initSpatialProperty(){return this._spatial||(this._spatial=new Zm(this._subGraph,this._spatialAutoUpdate,this._spatialMinUpdateTime)),this._spatial}}Da._SubGraph=class extends Xm{get _downstreamNodes(){return this._owner._downstreamNodes??null}get _upstreamNodes(){return this._owner._upstreamNodes??null}};class Gy extends _A{constructor(e){super(e)}async _init(e,t){e instanceof AudioBuffer?this._audioBuffer=e:typeof e=="string"?await this._initFromUrl(e):Array.isArray(e)?await this._initFromUrls(e,t.skipCodecCheck??!1):e instanceof ArrayBuffer&&await this._initFromArrayBuffer(e)}get channelCount(){return this._audioBuffer.numberOfChannels}get duration(){return this._audioBuffer.duration}get length(){return this._audioBuffer.length}get sampleRate(){return this._audioBuffer.sampleRate}async _initFromArrayBuffer(e){this._audioBuffer=await this.engine._audioContext.decodeAudioData(e)}async _initFromUrl(e){e=Jc(e),await this._initFromArrayBuffer(await(await fetch(e)).arrayBuffer())}async _initFromUrls(e,t){for(const i of e){if(t)await this._initFromUrl(i);else{const r=i.match(zA),s=r==null?void 0:r.at(1);if(s&&this.engine.isFormatValid(s))try{await this._initFromUrl(i)}catch{s&&0<s.length&&this.engine.flagInvalidFormat(s)}}if(this._audioBuffer)break}}}class UA extends kA{constructor(e,t){super(e),this._enginePlayTime=0,this._enginePauseTime=0,this._sourceNode=null,this._onEnded=()=>{this._enginePlayTime=0,this.onEndedObservable.notifyObservers(this),this._deinitSourceNode()},this._onEngineStateChanged=()=>{this.engine.state==="running"&&(this._options.loop&&this.state===2&&this.play(),this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged))},this._options=t,this._volumeNode=new GainNode(e._audioContext),this._initSourceNode()}get currentTime(){if(this._state===1)return 0;const e=this._state===5?0:this.engine.currentTime-this._enginePlayTime;return this._enginePauseTime+e+this._options.startOffset}set currentTime(e){const t=this._state===2||this._state===3;t&&(this.stop(),this._deinitSourceNode()),this._options.startOffset=e,t&&this.play()}get _outNode(){return this._volumeNode}set pitch(e){this._sourceNode&&this.engine._setAudioParam(this._sourceNode.detune,e)}set playbackRate(e){this._sourceNode&&this.engine._setAudioParam(this._sourceNode.playbackRate,e)}get startTime(){return this._state===1?0:this._enginePlayTime}dispose(){super.dispose(),this._sourceNode=null,this.stop(),this._deinitSourceNode(),this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged)}getClassName(){return"_WebAudioStaticSoundInstance"}play(e={}){var i;if(this._state===3)return;e.duration!==void 0&&(this._options.duration=e.duration),e.loop!==void 0&&(this._options.loop=e.loop),e.loopStart!==void 0&&(this._options.loopStart=e.loopStart),e.loopEnd!==void 0&&(this._options.loopEnd=e.loopEnd),e.startOffset!==void 0&&(this._options.startOffset=e.startOffset);let t=this._options.startOffset;this._state===5&&(t+=this.currentTime,t%=this._sound.buffer.duration),this._enginePlayTime=this.engine.currentTime+(e.waitTime??0),this._volumeNode.gain.value=e.volume??1,this._initSourceNode(),this.engine.state==="running"?(this._setState(3),(i=this._sourceNode)==null||i.start(this._enginePlayTime,t,this._options.duration>0?this._options.duration:void 0)):this._options.loop&&(this._setState(2),this.engine.stateChangedObservable.add(this._onEngineStateChanged))}pause(){var e;this._state!==5&&(this._setState(5),this._enginePauseTime+=this.engine.currentTime-this._enginePlayTime,(e=this._sourceNode)==null||e.stop(),this._deinitSourceNode())}resume(){this._state===5&&this.play()}stop(e={}){var i;if(this._state===1)return;this._setState(1);const t=this.engine.currentTime+(e.waitTime??0);(i=this._sourceNode)==null||i.stop(t),this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged)}_connect(e){var i;return super._connect(e)?(e instanceof Da&&e._inNode&&((i=this._outNode)==null||i.connect(e._inNode)),!0):!1}_disconnect(e){var i;return super._disconnect(e)?(e instanceof Da&&e._inNode&&((i=this._outNode)==null||i.disconnect(e._inNode)),!0):!1}_deinitSourceNode(){if(this._sourceNode){if(!this._disconnect(this._sound))throw new Error("Disconnect failed");this._sourceNode.disconnect(this._volumeNode),this._sourceNode.removeEventListener("ended",this._onEnded),this._sourceNode=null}}_initSourceNode(){if(!this._sourceNode&&(this._sourceNode=new AudioBufferSourceNode(this._sound._audioContext,{buffer:this._sound.buffer._audioBuffer}),this._sourceNode.addEventListener("ended",this._onEnded,{once:!0}),this._sourceNode.connect(this._volumeNode),!this._connect(this._sound)))throw new Error("Connect failed");const e=this._sourceNode;e.detune.value=this._sound.pitch,e.loop=this._options.loop,e.loopEnd=this._options.loopEnd,e.loopStart=this._options.loopStart,e.playbackRate.value=this._sound.playbackRate}}const K4=Object.freeze(Object.defineProperty({__proto__:null,_WebAudioStaticSound:Da,_WebAudioStaticSoundBuffer:Gy},Symbol.toStringTag,{value:"Module"}));class GA extends Uy{constructor(e){super(e),this.onReadyObservable=new j,this.preloadedPromise=new Promise((t,i)=>{this._rejectPreloadedProimse=i,this._resolvePreloadedPromise=t}),this.onErrorObservable.add(this._rejectPreloadedProimse),this.onReadyObservable.add(this._resolvePreloadedPromise)}set startOffset(e){this._options.startOffset=e}dispose(){super.dispose(),this.onErrorObservable.clear(),this.onReadyObservable.clear(),this._resolvePreloadedPromise()}}class Oa extends gA{constructor(e,t,i){super(e,t),this._spatial=null,this._spatialAutoUpdate=!0,this._spatialMinUpdateTime=0,this._stereo=null,typeof i.spatialAutoUpdate=="boolean"&&(this._spatialAutoUpdate=i.spatialAutoUpdate),typeof i.spatialMinUpdateTime=="number"&&(this._spatialMinUpdateTime=i.spatialMinUpdateTime),this._options={autoplay:i.autoplay??!1,loop:i.loop??!1,maxInstances:i.maxInstances??1/0,preloadCount:i.preloadCount??1,startOffset:i.startOffset??0},this._subGraph=new Oa._SubGraph(this)}async _init(e,t){const i=this.engine._audioContext;if(!(i instanceof AudioContext))throw new Error("Unsupported audio context type.");this._audioContext=i,this._source=e,t.outBus?this.outBus=t.outBus:(await this.engine.isReadyPromise,this.outBus=this.engine.defaultMainBus),await this._subGraph.init(t),vu(t)&&this._initSpatialProperty(),this.preloadCount&&await this.preloadInstancesAsync(this.preloadCount),t.autoplay&&this.play(t),this.engine._addNode(this)}get _inNode(){return this._subGraph._inNode}get _outNode(){return this._subGraph._outNode}get spatial(){return this._spatial?this._spatial:this._initSpatialProperty()}get stereo(){return this._stereo??(this._stereo=new Ym(this._subGraph))}dispose(){super.dispose(),this._spatial=null,this._stereo=null,this._subGraph.dispose(),this.engine._removeNode(this)}getClassName(){return"_WebAudioStreamingSound"}_createInstance(){return new WA(this,this._options)}_connect(e){var i;return super._connect(e)?(e._inNode&&((i=this._outNode)==null||i.connect(e._inNode)),!0):!1}_disconnect(e){var i;return super._disconnect(e)?(e._inNode&&((i=this._outNode)==null||i.disconnect(e._inNode)),!0):!1}_initSpatialProperty(){return this._spatial||(this._spatial=new Zm(this._subGraph,this._spatialAutoUpdate,this._spatialMinUpdateTime)),this._spatial}}Oa._SubGraph=class extends Xm{get _downstreamNodes(){return this._owner._downstreamNodes??null}get _upstreamNodes(){return this._owner._upstreamNodes??null}};class WA extends GA{constructor(e,t){super(e),this._currentTimeChangedWhilePaused=!1,this._enginePlayTime=1/0,this._enginePauseTime=0,this._isReady=!1,this._isReadyPromise=new Promise((i,r)=>{this._resolveIsReadyPromise=i,this._rejectIsReadyPromise=r}),this._onCanPlayThrough=()=>{this._isReady=!0,this._resolveIsReadyPromise(this._mediaElement),this.onReadyObservable.notifyObservers(this)},this._onEnded=()=>{this.onEndedObservable.notifyObservers(this),this.dispose()},this._onError=i=>{this._setState(4),this.onErrorObservable.notifyObservers(i),this._rejectIsReadyPromise(i),this.dispose()},this._onEngineStateChanged=()=>{this.engine.state==="running"&&(this._options.loop&&this.state===2&&this.play(),this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged))},this._onUserGesture=()=>{this.play()},this._options=t,this._volumeNode=new GainNode(e._audioContext),typeof e._source=="string"?this._initFromUrl(e._source):Array.isArray(e._source)?this._initFromUrls(e._source):e._source instanceof HTMLMediaElement&&this._initFromMediaElement(e._source)}get currentTime(){if(this._state===1)return 0;const e=this._state===5?0:this.engine.currentTime-this._enginePlayTime;return this._enginePauseTime+e+this._options.startOffset}set currentTime(e){const t=this._state===2||this._state===3;t&&(this._mediaElement.pause(),this._setState(1)),this._options.startOffset=e,t?this.play({startOffset:e}):this._state===5&&(this._currentTimeChangedWhilePaused=!0)}get _outNode(){return this._volumeNode}get startTime(){return this._state===1?0:this._enginePlayTime}dispose(){var e;super.dispose(),this.stop(),(e=this._sourceNode)==null||e.disconnect(this._volumeNode),this._sourceNode=null,this._mediaElement.removeEventListener("error",this._onError),this._mediaElement.removeEventListener("ended",this._onEnded),this._mediaElement.removeEventListener("canplaythrough",this._onCanPlayThrough);for(const t of Array.from(this._mediaElement.children))this._mediaElement.removeChild(t);this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged),this.engine.userGestureObservable.removeCallback(this._onUserGesture)}play(e={}){if(this._state===3)return;e.loop!==void 0&&(this._options.loop=e.loop),this._mediaElement.loop=this._options.loop;let t=e.startOffset;this._currentTimeChangedWhilePaused?(t=this._options.startOffset,this._currentTimeChangedWhilePaused=!1):this._state===5&&(t=this.currentTime+this._options.startOffset),t&&t>0&&(this._mediaElement.currentTime=t),this._volumeNode.gain.value=e.volume??1,this._play()}pause(){this._state!==2&&this._state!==3||(this._setState(5),this._enginePauseTime+=this.engine.currentTime-this._enginePlayTime,this._mediaElement.pause())}resume(){this._state===5?this.play():this._currentTimeChangedWhilePaused&&this.play()}stop(){this._state!==1&&this._stop()}getClassName(){return"_WebAudioStreamingSoundInstance"}_connect(e){var i;return super._connect(e)?(e instanceof Oa&&e._inNode&&((i=this._outNode)==null||i.connect(e._inNode)),!0):!1}_disconnect(e){var i;return super._disconnect(e)?(e instanceof Oa&&e._inNode&&((i=this._outNode)==null||i.disconnect(e._inNode)),!0):!1}_initFromMediaElement(e){if(ae.SetCorsBehavior(e.currentSrc,e),e.controls=!1,e.loop=this._options.loop,e.preload="auto",e.addEventListener("canplaythrough",this._onCanPlayThrough,{once:!0}),e.addEventListener("ended",this._onEnded,{once:!0}),e.addEventListener("error",this._onError,{once:!0}),e.load(),this._sourceNode=new MediaElementAudioSourceNode(this._sound._audioContext,{mediaElement:e}),this._sourceNode.connect(this._volumeNode),!this._connect(this._sound))throw new Error("Connect failed");this._mediaElement=e}_initFromUrl(e){const t=new Audio(Jc(e));this._initFromMediaElement(t)}_initFromUrls(e){const t=new Audio;for(const i of e){const r=document.createElement("source");r.src=Jc(i),t.appendChild(r)}this._initFromMediaElement(t)}_play(){if(this._setState(2),!this._isReady){this._playWhenReady();return}if(this._state===2)if(this.engine.state==="running"){const e=this._mediaElement.play();this._enginePlayTime=this.engine.currentTime,this._setState(3),e.catch(()=>{this._setState(4),this._options.loop&&this.engine.userGestureObservable.addOnce(this._onUserGesture)})}else this._options.loop?this.engine.stateChangedObservable.add(this._onEngineStateChanged):(this.stop(),this._setState(4))}_playWhenReady(){this._isReadyPromise.then(()=>{this._play()}).catch(()=>{L.Error("Streaming sound instance failed to play"),this._setState(4)})}_stop(){this._mediaElement.pause(),this._setState(1),this._onEnded(),this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged)}}const J4=Object.freeze(Object.defineProperty({__proto__:null,_WebAudioStreamingSound:Oa},Symbol.toStringTag,{value:"Module"}));class Qa{constructor(e){this._texture=null,this._isEnabled=!0,this.isEnabled=!0,this.time=0,e=e||ze.LastCreatedScene,e&&(this._scene=e,this.animationParameters=new Ve(0,0,0,30))}_markSubMeshesAsAttributesDirty(){for(const e of this._scene.meshes)e.bakedVertexAnimationManager===this&&e._markSubMeshesAsAttributesDirty()}bind(e,t=!1){if(!this._texture||!this._isEnabled)return;const i=this._texture.getSize();e.setFloat2("bakedVertexAnimationTextureSizeInverted",1/i.width,1/i.height),e.setFloat("bakedVertexAnimationTime",this.time),t||e.setVector4("bakedVertexAnimationSettings",this.animationParameters),e.setTexture("bakedVertexAnimationTexture",this._texture)}clone(){const e=new Qa(this._scene);return this.copyTo(e),e}setAnimationParameters(e,t,i=0,r=30){this.animationParameters=new Ve(e,t,i,r)}dispose(e){var t;e&&((t=this._texture)==null||t.dispose())}getClassName(){return"BakedVertexAnimationManager"}copyTo(e){Me.Clone(()=>e,this)}serialize(){return Me.Serialize(this)}parse(e,t,i){Me.Parse(()=>this,e,t,i)}}C([Mi(),Ue("_markSubMeshesAsAttributesDirty")],Qa.prototype,"texture",void 0);C([F(),Ue("_markSubMeshesAsAttributesDirty")],Qa.prototype,"isEnabled",void 0);C([F()],Qa.prototype,"animationParameters",void 0);C([F()],Qa.prototype,"time",void 0);class $A{constructor(){this._zoomStopsAnimation=!1,this._idleRotationSpeed=.05,this._idleRotationWaitTime=2e3,this._idleRotationSpinupTime=2e3,this.targetAlpha=null,this._isPointerDown=!1,this._lastFrameTime=null,this._lastInteractionTime=-1/0,this._cameraRotationSpeed=0,this._lastFrameRadius=0}get name(){return"AutoRotation"}set zoomStopsAnimation(e){this._zoomStopsAnimation=e}get zoomStopsAnimation(){return this._zoomStopsAnimation}set idleRotationSpeed(e){this._idleRotationSpeed=e}get idleRotationSpeed(){return this._idleRotationSpeed}set idleRotationWaitTime(e){this._idleRotationWaitTime=e}get idleRotationWaitTime(){return this._idleRotationWaitTime}set idleRotationSpinupTime(e){this._idleRotationSpinupTime=e}get idleRotationSpinupTime(){return this._idleRotationSpinupTime}get rotationInProgress(){return Math.abs(this._cameraRotationSpeed)>0}init(){}attach(e){this._attachedCamera=e;const t=this._attachedCamera.getScene();this._onPrePointerObservableObserver=t.onPrePointerObservable.add(i=>{if(i.type===Be.POINTERDOWN){this._isPointerDown=!0;return}i.type===Be.POINTERUP&&(this._isPointerDown=!1)}),this._onAfterCheckInputsObserver=e.onAfterCheckInputsObservable.add(()=>{if(this._reachTargetAlpha())return;const i=Li.Now;let r=0;this._lastFrameTime!=null&&(r=i-this._lastFrameTime),this._lastFrameTime=i,this._applyUserInteraction();const s=i-this._lastInteractionTime-this._idleRotationWaitTime,n=Math.max(Math.min(s/this._idleRotationSpinupTime,1),0);this._cameraRotationSpeed=this._idleRotationSpeed*n,this._attachedCamera&&(this._attachedCamera.alpha-=this._cameraRotationSpeed*(r/1e3))})}detach(){if(!this._attachedCamera)return;const e=this._attachedCamera.getScene();this._onPrePointerObservableObserver&&e.onPrePointerObservable.remove(this._onPrePointerObservableObserver),this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver),this._attachedCamera=null,this._lastFrameTime=null}resetLastInteractionTime(e){this._lastInteractionTime=e??Li.Now}_reachTargetAlpha(){return this._attachedCamera&&this.targetAlpha?Math.abs(this._attachedCamera.alpha-this.targetAlpha)<He:!1}_userIsZooming(){return this._attachedCamera?this._attachedCamera.inertialRadiusOffset!==0:!1}_shouldAnimationStopForInteraction(){if(!this._attachedCamera)return!1;let e=!1;return this._lastFrameRadius===this._attachedCamera.radius&&this._attachedCamera.inertialRadiusOffset!==0&&(e=!0),this._lastFrameRadius=this._attachedCamera.radius,this._zoomStopsAnimation?e:this._userIsZooming()}_applyUserInteraction(){this._userIsMoving()&&!this._shouldAnimationStopForInteraction()&&(this._lastInteractionTime=Li.Now)}_userIsMoving(){return this._attachedCamera?this._attachedCamera.inertialAlphaOffset!==0||this._attachedCamera.inertialBetaOffset!==0||this._attachedCamera.inertialRadiusOffset!==0||this._attachedCamera.inertialPanningX!==0||this._attachedCamera.inertialPanningY!==0||this._isPointerDown:!1}}class Ln{constructor(){this.transitionDuration=450,this.lowerRadiusTransitionRange=2,this.upperRadiusTransitionRange=-2,this._autoTransitionRange=!1,this._radiusIsAnimating=!1,this._radiusBounceTransition=null,this._animatables=new Array}get name(){return"Bouncing"}get autoTransitionRange(){return this._autoTransitionRange}set autoTransitionRange(e){if(this._autoTransitionRange===e)return;this._autoTransitionRange=e;const t=this._attachedCamera;t&&(e?this._onMeshTargetChangedObserver=t.onMeshTargetChangedObservable.add(i=>{if(i&&(i.computeWorldMatrix(!0),i.getBoundingInfo)){const r=i.getBoundingInfo().diagonalLength;this.lowerRadiusTransitionRange=r*.05,this.upperRadiusTransitionRange=r*.05}}):this._onMeshTargetChangedObserver&&t.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver))}init(){}attach(e){this._attachedCamera=e,this._onAfterCheckInputsObserver=e.onAfterCheckInputsObservable.add(()=>{this._attachedCamera&&(this._isRadiusAtLimit(this._attachedCamera.lowerRadiusLimit)&&this._applyBoundRadiusAnimation(this.lowerRadiusTransitionRange),this._isRadiusAtLimit(this._attachedCamera.upperRadiusLimit)&&this._applyBoundRadiusAnimation(this.upperRadiusTransitionRange))})}detach(){this._attachedCamera&&(this._onAfterCheckInputsObserver&&this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver),this._onMeshTargetChangedObserver&&this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver),this._attachedCamera=null)}_isRadiusAtLimit(e){return this._attachedCamera?this._attachedCamera.radius===e&&!this._radiusIsAnimating:!1}_applyBoundRadiusAnimation(e){if(!this._attachedCamera)return;this._radiusBounceTransition||(Ln.EasingFunction.setEasingMode(Ln.EasingMode),this._radiusBounceTransition=Le.CreateAnimation("radius",Le.ANIMATIONTYPE_FLOAT,60,Ln.EasingFunction)),this._cachedWheelPrecision=this._attachedCamera.wheelPrecision,this._attachedCamera.wheelPrecision=1/0,this._attachedCamera.inertialRadiusOffset=0,this.stopAllAnimations(),this._radiusIsAnimating=!0;const t=Le.TransitionTo("radius",this._attachedCamera.radius+e,this._attachedCamera,this._attachedCamera.getScene(),60,this._radiusBounceTransition,this.transitionDuration,()=>this._clearAnimationLocks());t&&this._animatables.push(t)}_clearAnimationLocks(){this._radiusIsAnimating=!1,this._attachedCamera&&(this._attachedCamera.wheelPrecision=this._cachedWheelPrecision)}stopAllAnimations(){for(this._attachedCamera&&(this._attachedCamera.animations=[]);this._animatables.length;)this._animatables[0].onAnimationEnd=null,this._animatables[0].stop(),this._animatables.shift()}}Ln.EasingFunction=new Pn(.3);Ln.EasingMode=Ma.EASINGMODE_EASEOUT;class Fi{constructor(){this.onTargetFramingAnimationEndObservable=new j,this._mode=Fi.FitFrustumSidesMode,this._radiusScale=1,this._positionScale=.5,this._defaultElevation=.3,this._elevationReturnTime=1500,this._elevationReturnWaitTime=1e3,this._zoomStopsAnimation=!1,this._framingTime=1500,this.autoCorrectCameraLimitsAndSensibility=!0,this._isPointerDown=!1,this._lastInteractionTime=-1/0,this._animatables=new Array,this._betaIsAnimating=!1}get name(){return"Framing"}set mode(e){this._mode=e}get mode(){return this._mode}set radiusScale(e){this._radiusScale=e}get radiusScale(){return this._radiusScale}set positionScale(e){this._positionScale=e}get positionScale(){return this._positionScale}set defaultElevation(e){this._defaultElevation=e}get defaultElevation(){return this._defaultElevation}set elevationReturnTime(e){this._elevationReturnTime=e}get elevationReturnTime(){return this._elevationReturnTime}set elevationReturnWaitTime(e){this._elevationReturnWaitTime=e}get elevationReturnWaitTime(){return this._elevationReturnWaitTime}set zoomStopsAnimation(e){this._zoomStopsAnimation=e}get zoomStopsAnimation(){return this._zoomStopsAnimation}set framingTime(e){this._framingTime=e}get framingTime(){return this._framingTime}init(){}attach(e){this._attachedCamera=e;const t=this._attachedCamera.getScene();Fi.EasingFunction.setEasingMode(Fi.EasingMode),this._onPrePointerObservableObserver=t.onPrePointerObservable.add(i=>{if(i.type===Be.POINTERDOWN){this._isPointerDown=!0;return}i.type===Be.POINTERUP&&(this._isPointerDown=!1)}),this._onMeshTargetChangedObserver=e.onMeshTargetChangedObservable.add(i=>{i&&i.getBoundingInfo&&this.zoomOnMesh(i,void 0,()=>{this.onTargetFramingAnimationEndObservable.notifyObservers()})}),this._onAfterCheckInputsObserver=e.onAfterCheckInputsObservable.add(()=>{this._applyUserInteraction(),this._maintainCameraAboveGround()})}detach(){if(!this._attachedCamera)return;const e=this._attachedCamera.getScene();this._onPrePointerObservableObserver&&e.onPrePointerObservable.remove(this._onPrePointerObservableObserver),this._onAfterCheckInputsObserver&&this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver),this._onMeshTargetChangedObserver&&this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver),this._attachedCamera=null}zoomOnMesh(e,t=!1,i=null){e.computeWorldMatrix(!0);const r=e.getBoundingInfo().boundingBox;this.zoomOnBoundingInfo(r.minimumWorld,r.maximumWorld,t,i)}zoomOnMeshHierarchy(e,t=!1,i=null){e.computeWorldMatrix(!0);const r=e.getHierarchyBoundingVectors(!0);this.zoomOnBoundingInfo(r.min,r.max,t,i)}zoomOnMeshesHierarchy(e,t=!1,i=null){const r=new m(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),s=new m(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let n=0;n<e.length;n++){const o=e[n].getHierarchyBoundingVectors(!0);m.CheckExtends(o.min,r,s),m.CheckExtends(o.max,r,s)}this.zoomOnBoundingInfo(r,s,t,i)}zoomOnBoundingInfo(e,t,i=!1,r=null){let s;if(!this._attachedCamera)return!1;const n=e.y,o=t.y,l=n+(o-n)*this._positionScale,u=t.subtract(e).scale(.5);if(!isFinite(l))return!1;if(i)s=new m(0,l,0);else{const d=e.add(u);s=new m(d.x,l,d.z)}this._vectorTransition||(this._vectorTransition=Le.CreateAnimation("target",Le.ANIMATIONTYPE_VECTOR3,60,Fi.EasingFunction)),this._betaIsAnimating=!0;let c=Le.TransitionTo("target",s,this._attachedCamera,this._attachedCamera.getScene(),60,this._vectorTransition,this._framingTime);c&&this._animatables.push(c);let h=0;if(this._mode===Fi.FitFrustumSidesMode){const d=this._calculateLowerRadiusFromModelBoundingSphere(e,t);this.autoCorrectCameraLimitsAndSensibility&&(this._attachedCamera.lowerRadiusLimit=u.length()+this._attachedCamera.minZ),h=d}else this._mode===Fi.IgnoreBoundsSizeMode&&(h=this._calculateLowerRadiusFromModelBoundingSphere(e,t),this.autoCorrectCameraLimitsAndSensibility&&this._attachedCamera.lowerRadiusLimit===null&&(this._attachedCamera.lowerRadiusLimit=this._attachedCamera.minZ));if(this.autoCorrectCameraLimitsAndSensibility){const d=t.subtract(e).length();this._attachedCamera.panningSensibility=5e3/d,this._attachedCamera.wheelPrecision=100/h}return this._radiusTransition||(this._radiusTransition=Le.CreateAnimation("radius",Le.ANIMATIONTYPE_FLOAT,60,Fi.EasingFunction)),c=Le.TransitionTo("radius",h,this._attachedCamera,this._attachedCamera.getScene(),60,this._radiusTransition,this._framingTime,()=>{this.stopAllAnimations(),r&&r(),this._attachedCamera&&this._attachedCamera.useInputToRestoreState&&this._attachedCamera.storeState()}),c&&this._animatables.push(c),!0}_calculateLowerRadiusFromModelBoundingSphere(e,t){const i=this._attachedCamera;if(!i)return 0;let r=i._calculateLowerRadiusFromModelBoundingSphere(e,t,this._radiusScale);return i.lowerRadiusLimit&&this._mode===Fi.IgnoreBoundsSizeMode&&(r=r<i.lowerRadiusLimit?i.lowerRadiusLimit:r),i.upperRadiusLimit&&(r=r>i.upperRadiusLimit?i.upperRadiusLimit:r),r}_maintainCameraAboveGround(){if(this._elevationReturnTime<0)return;const e=Li.Now-this._lastInteractionTime,t=Math.PI*.5-this._defaultElevation,i=Math.PI*.5;if(this._attachedCamera&&!this._betaIsAnimating&&this._attachedCamera.beta>i&&e>=this._elevationReturnWaitTime){this._betaIsAnimating=!0,this.stopAllAnimations(),this._betaTransition||(this._betaTransition=Le.CreateAnimation("beta",Le.ANIMATIONTYPE_FLOAT,60,Fi.EasingFunction));const r=Le.TransitionTo("beta",t,this._attachedCamera,this._attachedCamera.getScene(),60,this._betaTransition,this._elevationReturnTime,()=>{this._clearAnimationLocks(),this.stopAllAnimations()});r&&this._animatables.push(r)}}_clearAnimationLocks(){this._betaIsAnimating=!1}_applyUserInteraction(){this.isUserIsMoving&&(this._lastInteractionTime=Li.Now,this.stopAllAnimations(),this._clearAnimationLocks())}stopAllAnimations(){for(this._attachedCamera&&(this._attachedCamera.animations=[]);this._animatables.length;)this._animatables[0]&&(this._animatables[0].onAnimationEnd=null,this._animatables[0].stop()),this._animatables.shift()}get isUserIsMoving(){return this._attachedCamera?this._attachedCamera.inertialAlphaOffset!==0||this._attachedCamera.inertialBetaOffset!==0||this._attachedCamera.inertialRadiusOffset!==0||this._attachedCamera.inertialPanningX!==0||this._attachedCamera.inertialPanningY!==0||this._isPointerDown:!1}}Fi.EasingFunction=new En;Fi.EasingMode=Ma.EASINGMODE_EASEINOUT;Fi.IgnoreBoundsSizeMode=0;Fi.FitFrustumSidesMode=1;class Ke{static _RemoveAndStorePivotPoint(e){e&&Ke._PivotCached===0&&(e.getPivotPointToRef(Ke._OldPivotPoint),Ke._PivotPostMultiplyPivotMatrix=e._postMultiplyPivotMatrix,Ke._OldPivotPoint.equalsToFloats(0,0,0)||(e.setPivotMatrix($.IdentityReadOnly),Ke._OldPivotPoint.subtractToRef(e.getPivotPoint(),Ke._PivotTranslation),Ke._PivotTmpVector.copyFromFloats(1,1,1),Ke._PivotTmpVector.subtractInPlace(e.scaling),Ke._PivotTmpVector.multiplyInPlace(Ke._PivotTranslation),e.position.addInPlace(Ke._PivotTmpVector))),Ke._PivotCached++}static _RestorePivotPoint(e){e&&!Ke._OldPivotPoint.equalsToFloats(0,0,0)&&Ke._PivotCached===1&&(e.setPivotPoint(Ke._OldPivotPoint),e._postMultiplyPivotMatrix=Ke._PivotPostMultiplyPivotMatrix,Ke._PivotTmpVector.copyFromFloats(1,1,1),Ke._PivotTmpVector.subtractInPlace(e.scaling),Ke._PivotTmpVector.multiplyInPlace(Ke._PivotTranslation),e.position.subtractInPlace(Ke._PivotTmpVector)),this._PivotCached--}}Ke._PivotCached=0;Ke._OldPivotPoint=new m;Ke._PivotTranslation=new m;Ke._PivotTmpVector=new m;Ke._PivotPostMultiplyPivotMatrix=!1;function Wy(a){const e=[],t=[],i=[],r=[],s=a.width!==void 0?a.width:a.size!==void 0?a.size:1,n=a.height!==void 0?a.height:a.size!==void 0?a.size:1,o=a.sideOrientation===0?0:a.sideOrientation||he.DEFAULTSIDE,l=s/2,u=n/2;t.push(-l,-u,0),i.push(0,0,-1),r.push(0,ot?1:0),t.push(l,-u,0),i.push(0,0,-1),r.push(1,ot?1:0),t.push(l,u,0),i.push(0,0,-1),r.push(1,ot?0:1),t.push(-l,u,0),i.push(0,0,-1),r.push(0,ot?0:1),e.push(0),e.push(1),e.push(2),e.push(0),e.push(2),e.push(3),he._ComputeSides(o,t,e,i,r,a.frontUVs,a.backUVs);const c=new he;return c.indices=e,c.positions=t,c.normals=i,c.uvs=r,c}function gn(a,e={},t=null){const i=new z(a,t);return e.sideOrientation=z._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,Wy(e).applyToMesh(i,e.updatable),e.sourcePlane&&(i.translate(e.sourcePlane.normal,-e.sourcePlane.d),i.setDirection(e.sourcePlane.normal.scale(-1))),i}const eW={CreatePlane:gn};he.CreatePlane=Wy;z.CreatePlane=(a,e,t,i,r)=>gn(a,{size:e,width:e,height:e,sideOrientation:r,updatable:i},t);class gi{get currentDraggingPointerID(){return this.currentDraggingPointerId}set currentDraggingPointerID(e){this.currentDraggingPointerId=e}set enabled(e){e!=this._enabled&&this.onEnabledObservable.notifyObservers(e),this._enabled=e}get enabled(){return this._enabled}get options(){return this._options}set options(e){this._options=e}constructor(e){this._useAlternatePickedPointAboveMaxDragAngleDragSpeed=-1.1,this._activeDragButton=-1,this.maxDragAngle=0,this.dragButtons=[0,1,2],this._useAlternatePickedPointAboveMaxDragAngle=!1,this.currentDraggingPointerId=-1,this.dragging=!1,this.dragDeltaRatio=.2,this.updateDragPlane=!0,this._debugMode=!1,this._moving=!1,this.onDragObservable=new j,this.onDragStartObservable=new j,this.onDragEndObservable=new j,this.onEnabledObservable=new j,this.moveAttached=!0,this._enabled=!0,this.startAndReleaseDragOnPointerEvents=!0,this.detachCameraControls=!0,this.useObjectOrientationForDragging=!0,this.validateDrag=i=>!0,this._tmpVector=new m(0,0,0),this._alternatePickedPoint=new m(0,0,0),this._worldDragAxis=new m(0,0,0),this._targetPosition=new m(0,0,0),this._attachedToElement=!1,this._startDragRay=new Zt(new m,new m),this._lastPointerRay={},this._dragDelta=new m,this._pointA=new m(0,0,0),this._pointC=new m(0,0,0),this._localAxis=new m(0,0,0),this._lookAt=new m(0,0,0),this._options=e||{};let t=0;if(this._options.dragAxis&&t++,this._options.dragPlaneNormal&&t++,t>1)throw"Multiple drag modes specified in dragBehavior options. Only one expected"}get name(){return"PointerDrag"}init(){}attach(e,t){this._scene=e.getScene(),e.isNearGrabbable=!0,this.attachedNode=e,gi._PlaneScene||(this._debugMode?gi._PlaneScene=this._scene:(gi._PlaneScene=new Te(this._scene.getEngine(),{virtual:!0}),gi._PlaneScene.detachControl(),this._scene.onDisposeObservable.addOnce(()=>{gi._PlaneScene.dispose(),gi._PlaneScene=null}))),this._dragPlane=gn("pointerDragPlane",{size:this._debugMode?1:1e4,updatable:!1,sideOrientation:z.DOUBLESIDE},gi._PlaneScene),this.lastDragPosition=new m(0,0,0);const i=t||(r=>this.attachedNode==r||r.isDescendantOf(this.attachedNode));this._pointerObserver=this._scene.onPointerObservable.add(r=>{if(!this.enabled){this._attachedToElement&&this.releaseDrag();return}if(this.dragging&&this.currentDraggingPointerId==r.event.pointerId&&r.event.button!==-1&&r.event.button!==this._activeDragButton){this.releaseDrag();return}if(r.type==Be.POINTERDOWN)this.startAndReleaseDragOnPointerEvents&&!this.dragging&&r.pickInfo&&r.pickInfo.hit&&r.pickInfo.pickedMesh&&r.pickInfo.pickedPoint&&r.pickInfo.ray&&i(r.pickInfo.pickedMesh)&&this._activeDragButton===-1&&this.dragButtons.indexOf(r.event.button)!==-1&&(this._activeDragButton=r.event.button,this._activePointerInfo=r,this._startDrag(r.event.pointerId,r.pickInfo.ray,r.pickInfo.pickedPoint));else if(r.type==Be.POINTERUP)this.startAndReleaseDragOnPointerEvents&&this.currentDraggingPointerId==r.event.pointerId&&(this._activeDragButton===r.event.button||this._activeDragButton===-1)&&this.releaseDrag();else if(r.type==Be.POINTERMOVE){const s=r.event.pointerId;if(this.currentDraggingPointerId===gi._AnyMouseId&&s!==gi._AnyMouseId){const n=r.event;(n.pointerType==="mouse"||!this._scene.getEngine().hostInformation.isMobile&&n instanceof MouseEvent)&&(this._lastPointerRay[this.currentDraggingPointerId]&&(this._lastPointerRay[s]=this._lastPointerRay[this.currentDraggingPointerId],delete this._lastPointerRay[this.currentDraggingPointerId]),this.currentDraggingPointerId=s)}this._lastPointerRay[s]||(this._lastPointerRay[s]=new Zt(new m,new m)),r.pickInfo&&r.pickInfo.ray&&(this._lastPointerRay[s].origin.copyFrom(r.pickInfo.ray.origin),this._lastPointerRay[s].direction.copyFrom(r.pickInfo.ray.direction),this.currentDraggingPointerId==s&&this.dragging&&this._moveDrag(r.pickInfo.ray))}}),this._beforeRenderObserver=this._scene.onBeforeRenderObservable.add(()=>{if(this._moving&&this.moveAttached){let r=!1;Ke._RemoveAndStorePivotPoint(this.attachedNode),this._targetPosition.subtractToRef(this.attachedNode.absolutePosition,this._tmpVector),this._tmpVector.scaleInPlace(this.dragDeltaRatio),this.attachedNode.getAbsolutePosition().addToRef(this._tmpVector,this._tmpVector),this.validateDrag(this._tmpVector)&&(this.attachedNode.setAbsolutePosition(this._tmpVector),r=!0),Ke._RestorePivotPoint(this.attachedNode),r&&this.attachedNode.computeWorldMatrix()}})}releaseDrag(){if(this.dragging&&(this.dragging=!1,this.onDragEndObservable.notifyObservers({dragPlanePoint:this.lastDragPosition,pointerId:this.currentDraggingPointerId,pointerInfo:this._activePointerInfo})),this.currentDraggingPointerId=-1,this._activeDragButton=-1,this._activePointerInfo=null,this._moving=!1,this.detachCameraControls&&this._attachedToElement&&this._scene.activeCamera&&!this._scene.activeCamera.leftCamera){if(this._scene.activeCamera.getClassName()==="ArcRotateCamera"){const e=this._scene.activeCamera;e.attachControl(e.inputs?e.inputs.noPreventDefault:!0,e._useCtrlForPanning,e._panningMouseButton)}else this._scene.activeCamera.attachControl(this._scene.activeCamera.inputs?this._scene.activeCamera.inputs.noPreventDefault:!0);this._attachedToElement=!1}}startDrag(e=gi._AnyMouseId,t,i){this._startDrag(e,t,i);let r=this._lastPointerRay[e];e===gi._AnyMouseId&&(r=this._lastPointerRay[Object.keys(this._lastPointerRay)[0]]),r&&this._moveDrag(r)}_startDrag(e,t,i){if(!this._scene.activeCamera||this.dragging||!this.attachedNode)return;Ke._RemoveAndStorePivotPoint(this.attachedNode),t?(this._startDragRay.direction.copyFrom(t.direction),this._startDragRay.origin.copyFrom(t.origin)):(this._startDragRay.origin.copyFrom(this._scene.activeCamera.position),this.attachedNode.getWorldMatrix().getTranslationToRef(this._tmpVector),this._tmpVector.subtractToRef(this._scene.activeCamera.position,this._startDragRay.direction)),this._updateDragPlanePosition(this._startDragRay,i||this._tmpVector);const r=this._pickWithRayOnDragPlane(this._startDragRay);r?(this.dragging=!0,this.currentDraggingPointerId=e,this.lastDragPosition.copyFrom(r),this.onDragStartObservable.notifyObservers({dragPlanePoint:r,pointerId:this.currentDraggingPointerId,pointerInfo:this._activePointerInfo}),this._targetPosition.copyFrom(this.attachedNode.getAbsolutePosition()),this.detachCameraControls&&this._scene.activeCamera&&this._scene.activeCamera.inputs&&!this._scene.activeCamera.leftCamera&&(this._scene.activeCamera.inputs.attachedToElement?(this._scene.activeCamera.detachControl(),this._attachedToElement=!0):this._attachedToElement=!1)):this.releaseDrag(),Ke._RestorePivotPoint(this.attachedNode)}_moveDrag(e){this._moving=!0;const t=this._pickWithRayOnDragPlane(e);if(t){Ke._RemoveAndStorePivotPoint(this.attachedNode),this.updateDragPlane&&this._updateDragPlanePosition(e,t);let i=0;this._options.dragAxis?(this.useObjectOrientationForDragging?m.TransformCoordinatesToRef(this._options.dragAxis,this.attachedNode.getWorldMatrix().getRotationMatrix(),this._worldDragAxis):this._worldDragAxis.copyFrom(this._options.dragAxis),t.subtractToRef(this.lastDragPosition,this._tmpVector),this._worldDragAxis.normalize(),i=m.Dot(this._tmpVector,this._worldDragAxis),this._worldDragAxis.scaleToRef(i,this._dragDelta)):(i=this._dragDelta.length(),t.subtractToRef(this.lastDragPosition,this._dragDelta)),this._targetPosition.addInPlace(this._dragDelta),this.onDragObservable.notifyObservers({dragDistance:i,delta:this._dragDelta,dragPlanePoint:t,dragPlaneNormal:this._dragPlane.forward,pointerId:this.currentDraggingPointerId,pointerInfo:this._activePointerInfo}),this.lastDragPosition.copyFrom(t),Ke._RestorePivotPoint(this.attachedNode)}}_pickWithRayOnDragPlane(e){if(!e)return null;let t=Math.acos(m.Dot(this._dragPlane.forward,e.direction));if(t>Math.PI/2&&(t=Math.PI-t),this.maxDragAngle>0&&t>this.maxDragAngle)if(this._useAlternatePickedPointAboveMaxDragAngle){this._tmpVector.copyFrom(e.direction),this.attachedNode.absolutePosition.subtractToRef(e.origin,this._alternatePickedPoint),this._alternatePickedPoint.normalize(),this._alternatePickedPoint.scaleInPlace(this._useAlternatePickedPointAboveMaxDragAngleDragSpeed*m.Dot(this._alternatePickedPoint,this._tmpVector)),this._tmpVector.addInPlace(this._alternatePickedPoint);const l=m.Dot(this._dragPlane.forward,this._tmpVector);return this._dragPlane.forward.scaleToRef(-l,this._alternatePickedPoint),this._alternatePickedPoint.addInPlace(this._tmpVector),this._alternatePickedPoint.addInPlace(this.attachedNode.absolutePosition),this._alternatePickedPoint}else return null;const i=this._dragPlane.forward,r=this._dragPlane.position,s=e.direction.dot(i);if(Math.abs(s)<He)return null;r.subtractToRef(e.origin,V.Vector3[0]);const n=V.Vector3[0].dot(i)/s;return n<0?null:(e.direction.scaleToRef(n,V.Vector3[0]),e.origin.add(V.Vector3[0]))}_updateDragPlanePosition(e,t){this._pointA.copyFrom(t),this._options.dragAxis?(this.useObjectOrientationForDragging?m.TransformCoordinatesToRef(this._options.dragAxis,this.attachedNode.getWorldMatrix().getRotationMatrix(),this._localAxis):this._localAxis.copyFrom(this._options.dragAxis),e.origin.subtractToRef(this._pointA,this._pointC),this._pointC.normalize(),Math.abs(m.Dot(this._localAxis,this._pointC))>.999?Math.abs(m.Dot(m.UpReadOnly,this._pointC))>.999?this._lookAt.copyFrom(m.Right()):this._lookAt.copyFrom(m.UpReadOnly):(m.CrossToRef(this._localAxis,this._pointC,this._lookAt),m.CrossToRef(this._localAxis,this._lookAt,this._lookAt),this._lookAt.normalize()),this._dragPlane.position.copyFrom(this._pointA),this._pointA.addToRef(this._lookAt,this._lookAt),this._dragPlane.lookAt(this._lookAt)):this._options.dragPlaneNormal?(this.useObjectOrientationForDragging?m.TransformCoordinatesToRef(this._options.dragPlaneNormal,this.attachedNode.getWorldMatrix().getRotationMatrix(),this._localAxis):this._localAxis.copyFrom(this._options.dragPlaneNormal),this._dragPlane.position.copyFrom(this._pointA),this._pointA.addToRef(this._localAxis,this._lookAt),this._dragPlane.lookAt(this._lookAt)):(this._scene.activeCamera&&this._scene.activeCamera.getForwardRay().direction.normalizeToRef(this._localAxis),this._dragPlane.position.copyFrom(this._pointA),this._dragPlane.lookAt(this._pointA.add(this._localAxis))),this._dragPlane.position.copyFrom(this.attachedNode.getAbsolutePosition()),this._dragPlane.computeWorldMatrix(!0)}detach(){this._lastPointerRay={},this.attachedNode&&(this.attachedNode.isNearGrabbable=!1),this._pointerObserver&&this._scene.onPointerObservable.remove(this._pointerObserver),this._beforeRenderObserver&&this._scene.onBeforeRenderObservable.remove(this._beforeRenderObserver),this._dragPlane&&this._dragPlane.dispose(),this.releaseDrag()}}gi._AnyMouseId=-2;class ke{}ke.ANCHOR_SYSTEM="xr-anchor-system";ke.BACKGROUND_REMOVER="xr-background-remover";ke.HIT_TEST="xr-hit-test";ke.MESH_DETECTION="xr-mesh-detection";ke.PHYSICS_CONTROLLERS="xr-physics-controller";ke.PLANE_DETECTION="xr-plane-detection";ke.POINTER_SELECTION="xr-controller-pointer-selection";ke.TELEPORTATION="xr-controller-teleportation";ke.FEATURE_POINTS="xr-feature-points";ke.HAND_TRACKING="xr-hand-tracking";ke.IMAGE_TRACKING="xr-image-tracking";ke.NEAR_INTERACTION="xr-near-interaction";ke.DOM_OVERLAY="xr-dom-overlay";ke.MOVEMENT="xr-controller-movement";ke.LIGHT_ESTIMATION="xr-light-estimation";ke.EYE_TRACKING="xr-eye-tracking";ke.WALKING_LOCOMOTION="xr-walking-locomotion";ke.LAYERS="xr-layers";ke.DEPTH_SENSING="xr-depth-sensing";ke.SPACE_WARP="xr-space-warp";ke.RAW_CAMERA_ACCESS="xr-raw-camera-access";class Tt{constructor(e){this._xrSessionManager=e,this._features={},this._xrSessionManager.onXRSessionInit.add(()=>{this.getEnabledFeatures().forEach(t=>{const i=this._features[t];i.enabled&&!i.featureImplementation.attached&&!i.featureImplementation.disableAutoAttach&&this.attachFeature(t)})}),this._xrSessionManager.onXRSessionEnded.add(()=>{this.getEnabledFeatures().forEach(t=>{const i=this._features[t];i.enabled&&i.featureImplementation.attached&&this.detachFeature(t)})})}static AddWebXRFeature(e,t,i=1,r=!1){this._AvailableFeatures[e]=this._AvailableFeatures[e]||{latest:i},i>this._AvailableFeatures[e].latest&&(this._AvailableFeatures[e].latest=i),r&&(this._AvailableFeatures[e].stable=i),this._AvailableFeatures[e][i]=t}static ConstructFeature(e,t=1,i,r){const s=this._AvailableFeatures[e][t];if(!s)throw new Error("feature not found");return s(i,r)}static GetAvailableFeatures(){return Object.keys(this._AvailableFeatures)}static GetAvailableVersions(e){return Object.keys(this._AvailableFeatures[e])}static GetLatestVersionOfFeature(e){return this._AvailableFeatures[e]&&this._AvailableFeatures[e].latest||-1}static GetStableVersionOfFeature(e){return this._AvailableFeatures[e]&&this._AvailableFeatures[e].stable||-1}attachFeature(e){const t=this._features[e];t&&t.enabled&&!t.featureImplementation.attached&&(t.featureImplementation.attach()||ae.Warn(`Feature ${e} failed to attach`))}detachFeature(e){const t=this._features[e];t&&t.featureImplementation.attached&&(t.featureImplementation.detach()||ae.Warn(`Feature ${e} failed to detach`))}disableFeature(e){const t=typeof e=="string"?e:e.Name,i=this._features[t];return i&&i.enabled?(i.enabled=!1,this.detachFeature(t),i.featureImplementation.dispose(),delete this._features[t],!0):!1}dispose(){this.getEnabledFeatures().forEach(e=>{this.disableFeature(e)})}enableFeature(e,t="latest",i={},r=!0,s=!0){const n=typeof e=="string"?e:e.Name;let o=0;if(typeof t=="string"){if(!t)throw new Error(`Error in provided version - ${n} (${t})`);if(t==="stable"?o=Tt.GetStableVersionOfFeature(n):t==="latest"?o=Tt.GetLatestVersionOfFeature(n):o=+t,o===-1||isNaN(o))throw new Error(`feature not found - ${n} (${t})`)}else o=t;const l=Tt._ConflictingFeatures[n];if(l!==void 0&&this.getEnabledFeatures().indexOf(l)!==-1)throw new Error(`Feature ${n} cannot be enabled while ${l} is enabled.`);const u=this._features[n],c=Tt.ConstructFeature(n,o,this._xrSessionManager,i);if(!c)throw new Error(`feature not found - ${n}`);u&&this.disableFeature(n);const h=c();if(h.dependsOn&&!h.dependsOn.every(f=>!!this._features[f]))throw new Error(`Dependant features missing. Make sure the following features are enabled - ${h.dependsOn.join(", ")}`);if(h.isCompatible())return this._features[n]={featureImplementation:h,enabled:!0,version:o,required:s},r?this._xrSessionManager.session&&!this._features[n].featureImplementation.attached&&this.attachFeature(n):this._features[n].featureImplementation.disableAutoAttach=!0,this._features[n].featureImplementation;if(s)throw new Error("required feature not compatible");return ae.Warn(`Feature ${n} not compatible with the current environment/browser and was not enabled.`),h}getEnabledFeature(e){return this._features[e]&&this._features[e].featureImplementation}getEnabledFeatures(){return Object.keys(this._features)}async _extendXRSessionInitObject(e){const t=this.getEnabledFeatures();for(const i of t){const r=this._features[i],s=r.featureImplementation.xrNativeFeatureName;if(s&&(r.required?(e.requiredFeatures=e.requiredFeatures||[],e.requiredFeatures.indexOf(s)===-1&&e.requiredFeatures.push(s)):(e.optionalFeatures=e.optionalFeatures||[],e.optionalFeatures.indexOf(s)===-1&&e.optionalFeatures.push(s))),r.featureImplementation.getXRSessionInitExtension){const n=await r.featureImplementation.getXRSessionInitExtension();e={...e,...n}}}return e}}Tt._AvailableFeatures={};Tt._ConflictingFeatures={[ke.TELEPORTATION]:ke.MOVEMENT,[ke.MOVEMENT]:ke.TELEPORTATION};var Eg;(function(a){a[a.ABOVE_FINGER_TIPS=0]="ABOVE_FINGER_TIPS",a[a.RADIAL_SIDE=1]="RADIAL_SIDE",a[a.ULNAR_SIDE=2]="ULNAR_SIDE",a[a.BELOW_WRIST=3]="BELOW_WRIST"})(Eg||(Eg={}));var Ig;(function(a){a[a.LOOK_AT_CAMERA=0]="LOOK_AT_CAMERA",a[a.HAND_ROTATION=1]="HAND_ROTATION"})(Ig||(Ig={}));var Rg;(function(a){a[a.ALWAYS_VISIBLE=0]="ALWAYS_VISIBLE",a[a.PALM_UP=1]="PALM_UP",a[a.GAZE_FOCUS=2]="GAZE_FOCUS",a[a.PALM_AND_GAZE=3]="PALM_AND_GAZE"})(Rg||(Rg={}));class tW{constructor(){this._sceneRenderObserver=null,this._zoneAxis={},this.handConstraintVisibility=3,this.palmUpStrictness=.95,this.gazeProximityRadius=.15,this.targetOffset=.1,this.targetZone=2,this.zoneOrientationMode=1,this.nodeOrientationMode=1,this.handedness="none",this.lerpTime=100,this._zoneAxis[0]=new m(0,1,0),this._zoneAxis[1]=new m(-1,0,0),this._zoneAxis[2]=new m(1,0,0),this._zoneAxis[3]=new m(0,-1,0)}get name(){return"HandConstraint"}enable(){this._node.setEnabled(!0)}disable(){this._node.setEnabled(!1)}_getHandPose(){if(!this._handTracking)return null;let e;if(this.handedness==="none"?e=this._handTracking.getHandByHandedness("left")||this._handTracking.getHandByHandedness("right"):e=this._handTracking.getHandByHandedness(this.handedness),e){const t=e.getJointMesh("pinky-finger-metacarpal"),i=e.getJointMesh("middle-finger-metacarpal"),r=e.getJointMesh("wrist");if(r&&i&&t){const s={position:i.absolutePosition,quaternion:new re,id:e.xrController.uniqueId},n=V.Vector3[0],o=V.Vector3[1],l=V.Vector3[2];return n.copyFrom(i.absolutePosition).subtractInPlace(r.absolutePosition).normalize(),o.copyFrom(t.absolutePosition).subtractInPlace(i.absolutePosition).normalize(),m.CrossToRef(n,o,o),m.CrossToRef(o,n,l),re.FromLookDirectionLHToRef(o,n,s.quaternion),s}}return null}init(){}attach(e){this._node=e,this._scene=e.getScene(),this._node.rotationQuaternion||(this._node.rotationQuaternion=re.RotationYawPitchRoll(this._node.rotation.y,this._node.rotation.x,this._node.rotation.z));let t=Date.now();this._sceneRenderObserver=this._scene.onBeforeRenderObservable.add(()=>{const i=this._getHandPose();if(this._node.reservedDataStore=this._node.reservedDataStore||{},this._node.reservedDataStore.nearInteraction=this._node.reservedDataStore.nearInteraction||{},this._node.reservedDataStore.nearInteraction.excludedControllerId=null,i){const r=V.Vector3[0],s=this._scene.activeCamera;r.copyFrom(this._zoneAxis[this.targetZone]);const n=V.Quaternion[0];if(s&&(this.zoneOrientationMode===0||this.nodeOrientationMode===0)){const c=V.Vector3[1];c.copyFrom(s.position).subtractInPlace(i.position).normalize(),this._scene.useRightHandedSystem?re.FromLookDirectionRHToRef(c,m.UpReadOnly,n):re.FromLookDirectionLHToRef(c,m.UpReadOnly,n)}this.zoneOrientationMode===1?i.quaternion.toRotationMatrix(V.Matrix[0]):n.toRotationMatrix(V.Matrix[0]),m.TransformNormalToRef(r,V.Matrix[0],r),r.scaleInPlace(this.targetOffset);const o=V.Vector3[2],l=V.Quaternion[1];o.copyFrom(i.position).addInPlace(r),this.nodeOrientationMode===1?l.copyFrom(i.quaternion):l.copyFrom(n);const u=Date.now()-t;m.SmoothToRef(this._node.position,o,u,this.lerpTime,this._node.position),re.SmoothToRef(this._node.rotationQuaternion,l,u,this.lerpTime,this._node.rotationQuaternion),this._node.reservedDataStore.nearInteraction.excludedControllerId=i.id}this._setVisibility(i),t=Date.now()})}_setVisibility(e){let t=!0,i=!0;const r=this._scene.activeCamera;if(r){const s=r.getForwardRay();if(this.handConstraintVisibility===2||this.handConstraintVisibility===3){i=!1;let n;this._eyeTracking&&(n=this._eyeTracking.getEyeGaze()),n=n||s;const o=V.Vector3[0];e?e.position.subtractToRef(n.origin,o):this._node.getAbsolutePosition().subtractToRef(n.origin,o);const l=m.Dot(o,n.direction),u=l*l;l>0&&o.lengthSquared()-u<this.gazeProximityRadius*this.gazeProximityRadius&&(i=!0)}if((this.handConstraintVisibility===1||this.handConstraintVisibility===3)&&(t=!1,e)){const n=V.Vector3[0];m.LeftHandedForwardReadOnly.rotateByQuaternionToRef(e.quaternion,n),m.Dot(n,s.direction)>this.palmUpStrictness*2-1&&(t=!0)}}this._node.setEnabled(t&&i)}detach(){this._scene.onBeforeRenderObservable.remove(this._sceneRenderObserver)}linkToXRExperience(e){const t=e.featuresManager?e.featuresManager:e;if(!t)ae.Error("XR features manager must be available or provided directly for the Hand Menu to work");else{try{this._eyeTracking=t.getEnabledFeature(ke.EYE_TRACKING)}catch{}try{this._handTracking=t.getEnabledFeature(ke.HAND_TRACKING)}catch{ae.Error("Hand tracking must be enabled for the Hand Menu to work")}}}}class nr{get maxAngle(){return this._maxAngle}set maxAngle(e){this._setMaxAngle(e)}constructor(e,t,i){this.targetPosition=m.Zero(),this.poleTargetPosition=m.Zero(),this.poleTargetLocalOffset=m.Zero(),this.poleAngle=0,this.slerpAmount=1,this._bone1Quat=re.Identity(),this._bone1Mat=$.Identity(),this._bone2Ang=Math.PI,this._maxAngle=Math.PI,this._rightHandedSystem=!1,this._bendAxis=m.Right(),this._slerping=!1,this._adjustRoll=0,this._notEnoughInformation=!1,this._bone2=t;const r=t.getParent();if(!r){this._notEnoughInformation=!0,L.Error("BoneIKController: bone must have a parent for IK to work.");return}if(this._bone1=r,this._bone2.children.length===0&&!this._bone2.length){this._notEnoughInformation=!0,L.Error("BoneIKController: bone must not be a leaf or it should have a length for IK to work.");return}this.mesh=e,t.getSkeleton().computeAbsoluteMatrices();const s=t.getPosition();if(t.getAbsoluteMatrix().determinant()>0&&(this._rightHandedSystem=!0,this._bendAxis.x=0,this._bendAxis.y=0,this._bendAxis.z=-1,s.x>s.y&&s.x>s.z&&(this._adjustRoll=Math.PI*.5,this._bendAxis.z=1)),this._bone1.length&&this._bone2.length){const n=this._bone1.getScale(),o=this._bone2.getScale();this._bone1Length=this._bone1.length*n.y*this.mesh.scaling.y,this._bone2Length=this._bone2.length*o.y*this.mesh.scaling.y}else if(this._bone2.children[0]){e.computeWorldMatrix(!0);const n=this._bone2.children[0].getAbsolutePosition(e),o=this._bone2.getAbsolutePosition(e),l=this._bone1.getAbsolutePosition(e);this._bone2Length=m.Distance(n,o),this._bone1Length=m.Distance(o,l)}else{e.computeWorldMatrix(!0);const n=this._bone2.getScale();this._bone2Length=this._bone2.length*n.y*this.mesh.scaling.y;const o=this._bone2.getAbsolutePosition(e),l=this._bone1.getAbsolutePosition(e);this._bone1Length=m.Distance(o,l)}this._bone1.getRotationMatrixToRef(1,e,this._bone1Mat),this.maxAngle=Math.PI,i&&(i.targetMesh&&(this.targetMesh=i.targetMesh,this.targetMesh.computeWorldMatrix(!0)),i.poleTargetMesh?(this.poleTargetMesh=i.poleTargetMesh,this.poleTargetMesh.computeWorldMatrix(!0)):i.poleTargetBone?this.poleTargetBone=i.poleTargetBone:this._bone1.getParent()&&(this.poleTargetBone=this._bone1.getParent()),i.poleTargetLocalOffset&&this.poleTargetLocalOffset.copyFrom(i.poleTargetLocalOffset),i.poleAngle&&(this.poleAngle=i.poleAngle),i.bendAxis&&this._bendAxis.copyFrom(i.bendAxis),i.maxAngle&&(this.maxAngle=i.maxAngle),i.slerpAmount&&(this.slerpAmount=i.slerpAmount))}_setMaxAngle(e){e<0&&(e=0),(e>Math.PI||e==null)&&(e=Math.PI),this._maxAngle=e;const t=this._bone1Length,i=this._bone2Length;this._maxReach=Math.sqrt(t*t+i*i-2*t*i*Math.cos(e))}update(){if(this._notEnoughInformation)return;const e=this.targetPosition,t=this.poleTargetPosition,i=nr._TmpMats[0],r=nr._TmpMats[1];this.targetMesh&&e.copyFrom(this.targetMesh.getAbsolutePosition()),this.poleTargetBone?this.poleTargetBone.getAbsolutePositionFromLocalToRef(this.poleTargetLocalOffset,this.mesh,t):this.poleTargetMesh&&m.TransformCoordinatesToRef(this.poleTargetLocalOffset,this.poleTargetMesh.getWorldMatrix(),t);const s=nr._TmpVecs[0],n=nr._TmpVecs[1],o=nr._TmpVecs[2],l=nr._TmpVecs[3],u=nr._TmpVecs[4],c=nr._TmpQuat;this._bone1.getAbsolutePositionToRef(this.mesh,s),t.subtractToRef(s,u),u.x==0&&u.y==0&&u.z==0?u.y=1:u.normalize(),e.subtractToRef(s,l),l.normalize(),m.CrossToRef(l,u,n),n.normalize(),m.CrossToRef(l,n,o),o.normalize(),$.FromXYZAxesToRef(o,l,n,i);const h=this._bone1Length,d=this._bone2Length;let f=m.Distance(s,e);this._maxReach>0&&(f=Math.min(this._maxReach,f));let p=(d*d+f*f-h*h)/(2*d*f),g=(f*f+h*h-d*d)/(2*f*h);p>1&&(p=1),g>1&&(g=1),p<-1&&(p=-1),g<-1&&(g=-1);const _=Math.acos(p),S=Math.acos(g);let b=-_-S;if(this._rightHandedSystem)$.RotationYawPitchRollToRef(0,0,this._adjustRoll,r),r.multiplyToRef(i,i),$.RotationAxisToRef(this._bendAxis,S,r),r.multiplyToRef(i,i);else{const y=nr._TmpVecs[5];y.copyFrom(this._bendAxis),y.x*=-1,$.RotationAxisToRef(y,-S,r),r.multiplyToRef(i,i)}this.poleAngle&&($.RotationAxisToRef(l,this.poleAngle,r),i.multiplyToRef(r,i)),this._bone1&&(this.slerpAmount<1?(this._slerping||re.FromRotationMatrixToRef(this._bone1Mat,this._bone1Quat),re.FromRotationMatrixToRef(i,c),re.SlerpToRef(this._bone1Quat,c,this.slerpAmount,this._bone1Quat),b=this._bone2Ang*(1-this.slerpAmount)+b*this.slerpAmount,this._bone1.setRotationQuaternion(this._bone1Quat,1,this.mesh),this._slerping=!0):(this._bone1.setRotationMatrix(i,1,this.mesh),this._bone1Mat.copyFrom(i),this._slerping=!1),this._updateLinkedTransformRotation(this._bone1)),this._bone2.setAxisAngle(this._bendAxis,b,0),this._updateLinkedTransformRotation(this._bone2),this._bone2Ang=b}_updateLinkedTransformRotation(e){e._linkedTransformNode&&(e._linkedTransformNode.rotationQuaternion||(e._linkedTransformNode.rotationQuaternion=new re),e.getRotationQuaternionToRef(0,null,e._linkedTransformNode.rotationQuaternion))}}nr._TmpVecs=[m.Zero(),m.Zero(),m.Zero(),m.Zero(),m.Zero(),m.Zero()];nr._TmpQuat=re.Identity();nr._TmpMats=[$.Identity(),$.Identity()];class ni{get minYaw(){return this._minYaw}set minYaw(e){this._minYaw=e,this._minYawSin=Math.sin(e),this._minYawCos=Math.cos(e),this._maxYaw!=null&&(this._midYawConstraint=this._getAngleDiff(this._minYaw,this._maxYaw)*.5+this._minYaw,this._yawRange=this._maxYaw-this._minYaw)}get maxYaw(){return this._maxYaw}set maxYaw(e){this._maxYaw=e,this._maxYawSin=Math.sin(e),this._maxYawCos=Math.cos(e),this._minYaw!=null&&(this._midYawConstraint=this._getAngleDiff(this._minYaw,this._maxYaw)*.5+this._minYaw,this._yawRange=this._maxYaw-this._minYaw)}get minPitch(){return this._minPitch}set minPitch(e){this._minPitch=e,this._minPitchTan=Math.tan(e)}get maxPitch(){return this._maxPitch}set maxPitch(e){this._maxPitch=e,this._maxPitchTan=Math.tan(e)}constructor(e,t,i,r){if(this.upAxis=m.Up(),this.upAxisSpace=0,this.adjustYaw=0,this.adjustPitch=0,this.adjustRoll=0,this.slerpAmount=1,this._boneQuat=re.Identity(),this._slerping=!1,this._firstFrameSkipped=!1,this._fowardAxis=m.Forward(),this.useAbsoluteValueForYaw=!1,this.mesh=e,this.bone=t,this.target=i,r){if(r.adjustYaw&&(this.adjustYaw=r.adjustYaw),r.adjustPitch&&(this.adjustPitch=r.adjustPitch),r.adjustRoll&&(this.adjustRoll=r.adjustRoll),r.maxYaw!=null?this.maxYaw=r.maxYaw:this.maxYaw=Math.PI,r.minYaw!=null?this.minYaw=r.minYaw:this.minYaw=-Math.PI,r.maxPitch!=null?this.maxPitch=r.maxPitch:this.maxPitch=Math.PI,r.minPitch!=null?this.minPitch=r.minPitch:this.minPitch=-Math.PI,r.slerpAmount!=null&&(this.slerpAmount=r.slerpAmount),r.upAxis!=null&&(this.upAxis=r.upAxis),r.upAxisSpace!=null&&(this.upAxisSpace=r.upAxisSpace),r.yawAxis!=null||r.pitchAxis!=null){let s=qi.Y,n=qi.X;r.yawAxis!=null&&(s=r.yawAxis.clone(),s.normalize()),r.pitchAxis!=null&&(n=r.pitchAxis.clone(),n.normalize());const o=m.Cross(n,s);this._transformYawPitch=$.Identity(),$.FromXYZAxesToRef(n,s,o,this._transformYawPitch),this._transformYawPitchInv=this._transformYawPitch.clone(),this._transformYawPitch.invert()}r.useAbsoluteValueForYaw!==void 0&&(this.useAbsoluteValueForYaw=r.useAbsoluteValueForYaw)}!t.getParent()&&this.upAxisSpace==2&&(this.upAxisSpace=0)}update(){if(this.slerpAmount<1&&!this._firstFrameSkipped){this._firstFrameSkipped=!0;return}const e=this.bone,t=ni._TmpVecs[0];e.getAbsolutePositionToRef(this.mesh,t);let i=this.target;const r=ni._TmpMats[0],s=ni._TmpMats[1],n=this.mesh,o=e.getParent(),l=ni._TmpVecs[1];l.copyFrom(this.upAxis),this.upAxisSpace==2&&o?(this._transformYawPitch&&m.TransformCoordinatesToRef(l,this._transformYawPitchInv,l),o.getDirectionToRef(l,this.mesh,l)):this.upAxisSpace==0&&(n.getDirectionToRef(l,l),(n.scaling.x!=1||n.scaling.y!=1||n.scaling.z!=1)&&l.normalize());let u=!1,c=!1;if((this._maxYaw!=Math.PI||this._minYaw!=-Math.PI)&&(u=!0),(this._maxPitch!=Math.PI||this._minPitch!=-Math.PI)&&(c=!0),u||c){const _=ni._TmpMats[2],S=ni._TmpMats[3];if(this.upAxisSpace==2&&l.y==1&&o)o.getRotationMatrixToRef(1,this.mesh,_);else if(this.upAxisSpace==0&&l.y==1&&!o)_.copyFrom(n.getWorldMatrix());else{let y=ni._TmpVecs[2];y.copyFrom(this._fowardAxis),this._transformYawPitch&&m.TransformCoordinatesToRef(y,this._transformYawPitchInv,y),o?o.getDirectionToRef(y,this.mesh,y):n.getDirectionToRef(y,y);const T=m.Cross(l,y);T.normalize(),y=m.Cross(T,l),$.FromXYZAxesToRef(T,l,y,_)}_.invertToRef(S);let b=null;if(c){const y=ni._TmpVecs[3];i.subtractToRef(t,y),m.TransformCoordinatesToRef(y,S,y),b=Math.sqrt(y.x*y.x+y.z*y.z);const T=Math.atan2(y.y,b);let v=T;T>this._maxPitch?(y.y=this._maxPitchTan*b,v=this._maxPitch):T<this._minPitch&&(y.y=this._minPitchTan*b,v=this._minPitch),T!=v&&(m.TransformCoordinatesToRef(y,_,y),y.addInPlace(t),i=y)}if(u){const y=ni._TmpVecs[4];i.subtractToRef(t,y),m.TransformCoordinatesToRef(y,S,y);const T=Math.atan2(y.x,y.z),v=this.useAbsoluteValueForYaw?Math.abs(T):T;let E=T;if((v>this._maxYaw||v<this._minYaw)&&(b==null&&(b=Math.sqrt(y.x*y.x+y.z*y.z)),this._yawRange>Math.PI?this._isAngleBetween(T,this._maxYaw,this._midYawConstraint)?(y.z=this._maxYawCos*b,y.x=this._maxYawSin*b,E=this._maxYaw):this._isAngleBetween(T,this._midYawConstraint,this._minYaw)&&(y.z=this._minYawCos*b,y.x=this._minYawSin*b,E=this._minYaw):v>this._maxYaw?(y.z=this._maxYawCos*b,y.x=this._maxYawSin*b,T<0&&this.useAbsoluteValueForYaw&&(y.x*=-1),E=this._maxYaw):v<this._minYaw&&(y.z=this._minYawCos*b,y.x=this._minYawSin*b,T<0&&this.useAbsoluteValueForYaw&&(y.x*=-1),E=this._minYaw)),this._slerping&&this._yawRange>Math.PI){const R=ni._TmpVecs[8];R.copyFrom(qi.Z),this._transformYawPitch&&m.TransformCoordinatesToRef(R,this._transformYawPitchInv,R);const O=ni._TmpMats[4];this._boneQuat.toRotationMatrix(O),this.mesh.getWorldMatrix().multiplyToRef(O,O),m.TransformCoordinatesToRef(R,O,R),m.TransformCoordinatesToRef(R,S,R);const w=Math.atan2(R.x,R.z),M=this._getAngleBetween(w,T),G=this._getAngleBetween(w,this._midYawConstraint);if(M>G){b==null&&(b=Math.sqrt(y.x*y.x+y.z*y.z));const H=this._getAngleBetween(w,this._maxYaw);this._getAngleBetween(w,this._minYaw)<H?(E=w+Math.PI*.75,y.z=Math.cos(E)*b,y.x=Math.sin(E)*b):(E=w-Math.PI*.75,y.z=Math.cos(E)*b,y.x=Math.sin(E)*b)}}T!=E&&(m.TransformCoordinatesToRef(y,_,y),y.addInPlace(t),i=y)}}const h=ni._TmpVecs[5],d=ni._TmpVecs[6],f=ni._TmpVecs[7],p=ni._TmpQuat,g=ni._TmpVecs[9];i.subtractToRef(t,h),h.normalize(),m.CrossToRef(l,h,d),d.normalize(),m.CrossToRef(h,d,f),f.normalize(),$.FromXYZAxesToRef(d,f,h,r),!(d.x===0&&d.y===0&&d.z===0)&&(f.x===0&&f.y===0&&f.z===0||h.x===0&&h.y===0&&h.z===0||((this.adjustYaw||this.adjustPitch||this.adjustRoll)&&($.RotationYawPitchRollToRef(this.adjustYaw,this.adjustPitch,this.adjustRoll,s),s.multiplyToRef(r,r)),g.copyFrom(this.bone.getScale()),this.slerpAmount<1?(this._slerping||this.bone.getRotationQuaternionToRef(1,this.mesh,this._boneQuat),this._transformYawPitch&&this._transformYawPitch.multiplyToRef(r,r),re.FromRotationMatrixToRef(r,p),re.SlerpToRef(this._boneQuat,p,this.slerpAmount,this._boneQuat),this.bone.setRotationQuaternion(this._boneQuat,1,this.mesh),this._slerping=!0):(this._transformYawPitch&&this._transformYawPitch.multiplyToRef(r,r),this.bone.setRotationMatrix(r,1,this.mesh),this._slerping=!1),this.bone.setScale(g),this._updateLinkedTransformRotation()))}_getAngleDiff(e,t){let i=t-e;return i%=Math.PI*2,i>Math.PI?i-=Math.PI*2:i<-Math.PI&&(i+=Math.PI*2),i}_getAngleBetween(e,t){e%=2*Math.PI,e=e<0?e+2*Math.PI:e,t%=2*Math.PI,t=t<0?t+2*Math.PI:t;let i=0;return e<t?i=t-e:i=e-t,i>Math.PI&&(i=Math.PI*2-i),i}_isAngleBetween(e,t,i){if(e%=2*Math.PI,e=e<0?e+2*Math.PI:e,t%=2*Math.PI,t=t<0?t+2*Math.PI:t,i%=2*Math.PI,i=i<0?i+2*Math.PI:i,t<i){if(e>t&&e<i)return!0}else if(e>i&&e<t)return!0;return!1}_updateLinkedTransformRotation(){const e=this.bone;e._linkedTransformNode&&(e._linkedTransformNode.rotationQuaternion||(e._linkedTransformNode.rotationQuaternion=new re),e.getRotationQuaternionToRef(0,null,e._linkedTransformNode.rotationQuaternion))}}ni._TmpVecs=uu(10,m.Zero);ni._TmpQuat=re.Identity();ni._TmpMats=uu(5,$.Identity);class HA{constructor(e,t,i=3,r){this._engine=e,this._label=r,this._engine._storageBuffers.push(this),this._create(t,i)}_create(e,t){this._bufferSize=e,this._creationFlags=t,this._buffer=this._engine.createStorageBuffer(e,t,this._label)}_rebuild(){this._create(this._bufferSize,this._creationFlags)}getBuffer(){return this._buffer}update(e,t,i){this._buffer&&this._engine.updateStorageBuffer(this._buffer,e,t,i)}read(e,t,i,r){return this._engine.readFromStorageBuffer(this._buffer,e,t,i,r)}dispose(){const e=this._engine._storageBuffers,t=e.indexOf(this);t!==-1&&(e[t]=e[e.length-1],e.pop()),this._engine._releaseBuffer(this._buffer),this._buffer=null}}const mo=(()=>{const a=new Uint8Array(4),e=new Uint32Array(a.buffer);return!!((e[0]=1)&a[0])})();Object.defineProperty(N.prototype,"effectiveByteStride",{get:function(){return this._alignedBuffer&&this._alignedBuffer.byteStride||this.byteStride},enumerable:!0,configurable:!0});Object.defineProperty(N.prototype,"effectiveByteOffset",{get:function(){return this._alignedBuffer?0:this.byteOffset},enumerable:!0,configurable:!0});Object.defineProperty(N.prototype,"effectiveBuffer",{get:function(){return this._alignedBuffer&&this._alignedBuffer.getBuffer()||this._buffer.getBuffer()},enumerable:!0,configurable:!0});N.prototype._rebuild=function(){var a,e;(a=this._buffer)==null||a._rebuild(),(e=this._alignedBuffer)==null||e._rebuild()};N.prototype.dispose=function(){var a;this._ownsBuffer&&this._buffer.dispose(),(a=this._alignedBuffer)==null||a.dispose(),this._alignedBuffer=void 0,this._isDisposed=!0};N.prototype.getWrapperBuffer=function(){return this._alignedBuffer||this._buffer};N.prototype._alignBuffer=function(){var h;const a=this._buffer.getData();if(!this.engine._features.forceVertexBufferStrideAndOffsetMultiple4Bytes||this.byteStride%4===0&&this.byteOffset%4===0||!a)return;const e=N.GetTypeByteLength(this.type),t=this.byteStride+3&-4,i=t/e,r=this._maxVerticesCount,n=r*t/e;let o;if(Array.isArray(a)){const d=new Float32Array(a);o=new DataView(d.buffer,d.byteOffset,d.byteLength)}else a instanceof ArrayBuffer?o=new DataView(a,0,a.byteLength):o=new DataView(a.buffer,a.byteOffset,a.byteLength);let l;this.type===N.BYTE?l=new Int8Array(n):this.type===N.UNSIGNED_BYTE?l=new Uint8Array(n):this.type===N.SHORT?l=new Int16Array(n):this.type===N.UNSIGNED_SHORT?l=new Uint16Array(n):this.type===N.INT?l=new Int32Array(n):this.type===N.UNSIGNED_INT?l=new Uint32Array(n):l=new Float32Array(n);const u=this.getSize();let c=this.byteOffset;for(let d=0;d<r;++d){for(let f=0;f<u;++f)switch(this.type){case N.BYTE:l[d*i+f]=o.getInt8(c+f);break;case N.UNSIGNED_BYTE:l[d*i+f]=o.getUint8(c+f);break;case N.SHORT:l[d*i+f]=o.getInt16(c+f*2,mo);break;case N.UNSIGNED_SHORT:l[d*i+f]=o.getUint16(c+f*2,mo);break;case N.INT:l[d*i+f]=o.getInt32(c+f*4,mo);break;case N.UNSIGNED_INT:l[d*i+f]=o.getUint32(c+f*4,mo);break;case N.FLOAT:l[d*i+f]=o.getFloat32(c+f*4,mo);break}c+=this.byteStride}(h=this._alignedBuffer)==null||h.dispose(),this._alignedBuffer=new fi(this.engine,l,!1,t,!1,this.getIsInstanced(),!0,this.instanceDivisor,(this._label??"VertexBuffer")+"_aligned")};class qm{constructor(){this._currentMousePointerIdDown=-1,this.buttons=[0,1,2]}attachControl(e){e=ae.BackCompatCameraNoPreventDefault(arguments);const t=this.camera.getEngine(),i=t.getInputElement();let r=0,s=null;this._pointA=null,this._pointB=null,this._altKey=!1,this._ctrlKey=!1,this._metaKey=!1,this._shiftKey=!1,this._buttonsPressed=0,this._pointerInput=o=>{var h,d;const l=o.event,u=l.pointerType==="touch";if(o.type!==Be.POINTERMOVE&&this.buttons.indexOf(l.button)===-1)return;const c=l.target;if(this._altKey=l.altKey,this._ctrlKey=l.ctrlKey,this._metaKey=l.metaKey,this._shiftKey=l.shiftKey,this._buttonsPressed=l.buttons,t.isPointerLock){const f=l.movementX,p=l.movementY;this.onTouch(null,f,p),this._pointA=null,this._pointB=null}else{if(o.type!==Be.POINTERDOWN&&o.type!==Be.POINTERDOUBLETAP&&u&&((h=this._pointA)==null?void 0:h.pointerId)!==l.pointerId&&((d=this._pointB)==null?void 0:d.pointerId)!==l.pointerId)return;if(o.type===Be.POINTERDOWN&&(this._currentMousePointerIdDown===-1||u)){try{c==null||c.setPointerCapture(l.pointerId)}catch{}if(this._pointA===null)this._pointA={x:l.clientX,y:l.clientY,pointerId:l.pointerId,type:l.pointerType};else if(this._pointB===null)this._pointB={x:l.clientX,y:l.clientY,pointerId:l.pointerId,type:l.pointerType};else return;this._currentMousePointerIdDown===-1&&!u&&(this._currentMousePointerIdDown=l.pointerId),this.onButtonDown(l),e||(l.preventDefault(),i&&i.focus())}else if(o.type===Be.POINTERDOUBLETAP)this.onDoubleTap(l.pointerType);else if(o.type===Be.POINTERUP&&(this._currentMousePointerIdDown===l.pointerId||u)){try{c==null||c.releasePointerCapture(l.pointerId)}catch{}u||(this._pointB=null),t._badOS?this._pointA=this._pointB=null:this._pointB&&this._pointA&&this._pointA.pointerId==l.pointerId?(this._pointA=this._pointB,this._pointB=null):this._pointA&&this._pointB&&this._pointB.pointerId==l.pointerId?this._pointB=null:this._pointA=this._pointB=null,(r!==0||s)&&(this.onMultiTouch(this._pointA,this._pointB,r,0,s,null),r=0,s=null),this._currentMousePointerIdDown=-1,this.onButtonUp(l),e||l.preventDefault()}else if(o.type===Be.POINTERMOVE){if(e||l.preventDefault(),this._pointA&&this._pointB===null){const f=l.clientX-this._pointA.x,p=l.clientY-this._pointA.y;this._pointA.x=l.clientX,this._pointA.y=l.clientY,this.onTouch(this._pointA,f,p)}else if(this._pointA&&this._pointB){const f=this._pointA.pointerId===l.pointerId?this._pointA:this._pointB;f.x=l.clientX,f.y=l.clientY;const p=this._pointA.x-this._pointB.x,g=this._pointA.y-this._pointB.y,_=p*p+g*g,S={x:(this._pointA.x+this._pointB.x)/2,y:(this._pointA.y+this._pointB.y)/2,pointerId:l.pointerId,type:o.type};this.onMultiTouch(this._pointA,this._pointB,r,_,s,S),s=S,r=_}}}},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput,Be.POINTERDOWN|Be.POINTERUP|Be.POINTERMOVE|Be.POINTERDOUBLETAP),this._onLostFocus=()=>{this._pointA=this._pointB=null,r=0,s=null,this.onLostFocus()},this._contextMenuBind=o=>this.onContextMenu(o),i&&i.addEventListener("contextmenu",this._contextMenuBind,!1);const n=this.camera.getScene().getEngine().getHostWindow();n&&ae.RegisterTopRootEvents(n,[{name:"blur",handler:this._onLostFocus}])}detachControl(){if(this._onLostFocus){const e=this.camera.getScene().getEngine().getHostWindow();e&&ae.UnregisterTopRootEvents(e,[{name:"blur",handler:this._onLostFocus}])}if(this._observer){if(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null,this._contextMenuBind){const e=this.camera.getScene().getEngine().getInputElement();e&&e.removeEventListener("contextmenu",this._contextMenuBind)}this._onLostFocus=null}this._altKey=!1,this._ctrlKey=!1,this._metaKey=!1,this._shiftKey=!1,this._buttonsPressed=0,this._currentMousePointerIdDown=-1}getClassName(){return"BaseCameraPointersInput"}getSimpleName(){return"pointers"}onDoubleTap(e){}onTouch(e,t,i){}onMultiTouch(e,t,i,r,s,n){}onContextMenu(e){e.preventDefault()}onButtonDown(e){}onButtonUp(e){}onLostFocus(){}}C([F()],qm.prototype,"buttons",void 0);class iW{constructor(e,t){this.x=e,this.y=t}}class Jt{get isConnected(){return this._isConnected}constructor(e,t,i,r=0,s=1,n=2,o=3){this.id=e,this.index=t,this.browserGamepad=i,this._leftStick={x:0,y:0},this._rightStick={x:0,y:0},this._isConnected=!0,this._invertLeftStickY=!1,this.type=Jt.GAMEPAD,this._leftStickAxisX=r,this._leftStickAxisY=s,this._rightStickAxisX=n,this._rightStickAxisY=o,this.browserGamepad.axes.length>=2&&(this._leftStick={x:this.browserGamepad.axes[this._leftStickAxisX],y:this.browserGamepad.axes[this._leftStickAxisY]}),this.browserGamepad.axes.length>=4&&(this._rightStick={x:this.browserGamepad.axes[this._rightStickAxisX],y:this.browserGamepad.axes[this._rightStickAxisY]})}onleftstickchanged(e){this._onleftstickchanged=e}onrightstickchanged(e){this._onrightstickchanged=e}get leftStick(){return this._leftStick}set leftStick(e){this._onleftstickchanged&&(this._leftStick.x!==e.x||this._leftStick.y!==e.y)&&this._onleftstickchanged(e),this._leftStick=e}get rightStick(){return this._rightStick}set rightStick(e){this._onrightstickchanged&&(this._rightStick.x!==e.x||this._rightStick.y!==e.y)&&this._onrightstickchanged(e),this._rightStick=e}update(){this._leftStick&&(this.leftStick={x:this.browserGamepad.axes[this._leftStickAxisX],y:this.browserGamepad.axes[this._leftStickAxisY]},this._invertLeftStickY&&(this.leftStick.y*=-1)),this._rightStick&&(this.rightStick={x:this.browserGamepad.axes[this._rightStickAxisX],y:this.browserGamepad.axes[this._rightStickAxisY]})}dispose(){}}Jt.GAMEPAD=0;Jt.GENERIC=1;Jt.XBOX=2;Jt.POSE_ENABLED=3;Jt.DUALSHOCK=4;class jA extends Jt{onbuttondown(e){this._onbuttondown=e}onbuttonup(e){this._onbuttonup=e}constructor(e,t,i){super(e,t,i),this.onButtonDownObservable=new j,this.onButtonUpObservable=new j,this.type=Jt.GENERIC,this._buttons=new Array(i.buttons.length)}_setButtonValue(e,t,i){return e!==t&&(e===1&&(this._onbuttondown&&this._onbuttondown(i),this.onButtonDownObservable.notifyObservers(i)),e===0&&(this._onbuttonup&&this._onbuttonup(i),this.onButtonUpObservable.notifyObservers(i))),e}update(){super.update();for(let e=0;e<this._buttons.length;e++)this._buttons[e]=this._setButtonValue(this.browserGamepad.buttons[e].value,this._buttons[e],e)}dispose(){super.dispose(),this.onButtonDownObservable.clear(),this.onButtonUpObservable.clear()}}class Tu{constructor(){this.gamepadRotationSensibility=80,this.gamepadMoveSensibility=40,this._yAxisScale=1}get invertYAxis(){return this._yAxisScale!==1}set invertYAxis(e){this._yAxisScale=e?-1:1}attachControl(){const e=this.camera.getScene().gamepadManager;this._onGamepadConnectedObserver=e.onGamepadConnectedObservable.add(t=>{t.type!==Jt.POSE_ENABLED&&(!this.gamepad||t.type===Jt.XBOX)&&(this.gamepad=t)}),this._onGamepadDisconnectedObserver=e.onGamepadDisconnectedObservable.add(t=>{this.gamepad===t&&(this.gamepad=null)}),this.gamepad=e.getGamepadByType(Jt.XBOX),!this.gamepad&&e.gamepads.length&&(this.gamepad=e.gamepads[0])}detachControl(){this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver),this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver),this.gamepad=null}checkInputs(){if(this.gamepad){const e=this.camera,t=this.gamepad.rightStick;if(t){if(t.x!=0){const r=t.x/this.gamepadRotationSensibility;r!=0&&Math.abs(r)>.005&&(e.inertialAlphaOffset+=r)}if(t.y!=0){const r=t.y/this.gamepadRotationSensibility*this._yAxisScale;r!=0&&Math.abs(r)>.005&&(e.inertialBetaOffset+=r)}}const i=this.gamepad.leftStick;if(i&&i.y!=0){const r=i.y/this.gamepadMoveSensibility;r!=0&&Math.abs(r)>.005&&(this.camera.inertialRadiusOffset-=r)}}}getClassName(){return"ArcRotateCameraGamepadInput"}getSimpleName(){return"gamepad"}}C([F()],Tu.prototype,"gamepadRotationSensibility",void 0);C([F()],Tu.prototype,"gamepadMoveSensibility",void 0);dr.ArcRotateCameraGamepadInput=Tu;class Hr{constructor(){this.keysUp=[38],this.keysDown=[40],this.keysLeft=[37],this.keysRight=[39],this.keysReset=[220],this.panningSensibility=50,this.zoomingSensibility=25,this.useAltToZoom=!0,this.angularSpeed=.01,this._keys=new Array}attachControl(e){e=ae.BackCompatCameraNoPreventDefault(arguments),!this._onCanvasBlurObserver&&(this._scene=this.camera.getScene(),this._engine=this._scene.getEngine(),this._onCanvasBlurObserver=this._engine.onCanvasBlurObservable.add(()=>{this._keys.length=0}),this._onKeyboardObserver=this._scene.onKeyboardObservable.add(t=>{const i=t.event;if(!i.metaKey){if(t.type===Mm.KEYDOWN)this._ctrlPressed=i.ctrlKey,this._altPressed=i.altKey,(this.keysUp.indexOf(i.keyCode)!==-1||this.keysDown.indexOf(i.keyCode)!==-1||this.keysLeft.indexOf(i.keyCode)!==-1||this.keysRight.indexOf(i.keyCode)!==-1||this.keysReset.indexOf(i.keyCode)!==-1)&&(this._keys.indexOf(i.keyCode)===-1&&this._keys.push(i.keyCode),i.preventDefault&&(e||i.preventDefault()));else if(this.keysUp.indexOf(i.keyCode)!==-1||this.keysDown.indexOf(i.keyCode)!==-1||this.keysLeft.indexOf(i.keyCode)!==-1||this.keysRight.indexOf(i.keyCode)!==-1||this.keysReset.indexOf(i.keyCode)!==-1){const r=this._keys.indexOf(i.keyCode);r>=0&&this._keys.splice(r,1),i.preventDefault&&(e||i.preventDefault())}}}))}detachControl(){this._scene&&(this._onKeyboardObserver&&this._scene.onKeyboardObservable.remove(this._onKeyboardObserver),this._onCanvasBlurObserver&&this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver),this._onKeyboardObserver=null,this._onCanvasBlurObserver=null),this._keys.length=0}checkInputs(){if(this._onKeyboardObserver){const e=this.camera;for(let t=0;t<this._keys.length;t++){const i=this._keys[t];this.keysLeft.indexOf(i)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?e.inertialPanningX-=1/this.panningSensibility:e.inertialAlphaOffset-=this.angularSpeed:this.keysUp.indexOf(i)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?e.inertialPanningY+=1/this.panningSensibility:this._altPressed&&this.useAltToZoom?e.inertialRadiusOffset+=1/this.zoomingSensibility:e.inertialBetaOffset-=this.angularSpeed:this.keysRight.indexOf(i)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?e.inertialPanningX+=1/this.panningSensibility:e.inertialAlphaOffset+=this.angularSpeed:this.keysDown.indexOf(i)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?e.inertialPanningY-=1/this.panningSensibility:this._altPressed&&this.useAltToZoom?e.inertialRadiusOffset-=1/this.zoomingSensibility:e.inertialBetaOffset+=this.angularSpeed:this.keysReset.indexOf(i)!==-1&&e.useInputToRestoreState&&e.restoreState()}}}getClassName(){return"ArcRotateCameraKeyboardMoveInput"}getSimpleName(){return"keyboard"}}C([F()],Hr.prototype,"keysUp",void 0);C([F()],Hr.prototype,"keysDown",void 0);C([F()],Hr.prototype,"keysLeft",void 0);C([F()],Hr.prototype,"keysRight",void 0);C([F()],Hr.prototype,"keysReset",void 0);C([F()],Hr.prototype,"panningSensibility",void 0);C([F()],Hr.prototype,"zoomingSensibility",void 0);C([F()],Hr.prototype,"useAltToZoom",void 0);C([F()],Hr.prototype,"angularSpeed",void 0);dr.ArcRotateCameraKeyboardMoveInput=Hr;const YA=40;class sl{constructor(){this.wheelPrecision=3,this.zoomToMouseLocation=!1,this.wheelDeltaPercentage=0,this.customComputeDeltaFromMouseWheel=null,this._viewOffset=new m(0,0,0),this._globalOffset=new m(0,0,0),this._inertialPanning=m.Zero()}_computeDeltaFromMouseWheelLegacyEvent(e,t){let i=0;const r=e*.01*this.wheelDeltaPercentage*t;return e>0?i=r/(1+this.wheelDeltaPercentage):i=r*(1+this.wheelDeltaPercentage),i}attachControl(e){e=ae.BackCompatCameraNoPreventDefault(arguments),this._wheel=t=>{if(t.type!==Be.POINTERWHEEL)return;const i=t.event;let r=0;const s=i.deltaMode===MR.DOM_DELTA_LINE?YA:1,n=-(i.deltaY*s);if(this.customComputeDeltaFromMouseWheel)r=this.customComputeDeltaFromMouseWheel(n,this,i);else if(this.wheelDeltaPercentage){if(r=this._computeDeltaFromMouseWheelLegacyEvent(n,this.camera.radius),r>0){let o=this.camera.radius,l=this.camera.inertialRadiusOffset+r;for(let u=0;u<20&&Math.abs(l)>.001;u++)o-=l,l*=this.camera.inertia;o=Si(o,0,Number.MAX_VALUE),r=this._computeDeltaFromMouseWheelLegacyEvent(n,o)}}else r=n/(this.wheelPrecision*40);r&&(this.zoomToMouseLocation?(this._hitPlane||this._updateHitPlane(),this._zoomToMouse(r)):this.camera.inertialRadiusOffset+=r),i.preventDefault&&(e||i.preventDefault())},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel,Be.POINTERWHEEL),this.zoomToMouseLocation&&this._inertialPanning.setAll(0)}detachControl(){this._observer&&(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null,this._wheel=null)}checkInputs(){if(!this.zoomToMouseLocation)return;const e=this.camera;0+e.inertialAlphaOffset+e.inertialBetaOffset+e.inertialRadiusOffset&&(this._updateHitPlane(),e.target.addInPlace(this._inertialPanning),this._inertialPanning.scaleInPlace(e.inertia),this._zeroIfClose(this._inertialPanning))}getClassName(){return"ArcRotateCameraMouseWheelInput"}getSimpleName(){return"mousewheel"}_updateHitPlane(){const e=this.camera,t=e.target.subtract(e.position);this._hitPlane=ko.FromPositionAndNormal(e.target,t)}_getPosition(){const e=this.camera,t=e.getScene(),i=t.createPickingRay(t.pointerX,t.pointerY,$.Identity(),e,!1);(e.targetScreenOffset.x!==0||e.targetScreenOffset.y!==0)&&(this._viewOffset.set(e.targetScreenOffset.x,e.targetScreenOffset.y,0),e.getViewMatrix().invertToRef(e._cameraTransformMatrix),this._globalOffset=m.TransformNormal(this._viewOffset,e._cameraTransformMatrix),i.origin.addInPlace(this._globalOffset));let r=0;return this._hitPlane&&(r=i.intersectsPlane(this._hitPlane)??0),i.origin.addInPlace(i.direction.scaleInPlace(r))}_zoomToMouse(e){const t=this.camera,i=1-t.inertia;if(t.lowerRadiusLimit){const l=t.lowerRadiusLimit??0;t.radius-(t.inertialRadiusOffset+e)/i<l&&(e=(t.radius-l)*i-t.inertialRadiusOffset)}if(t.upperRadiusLimit){const l=t.upperRadiusLimit??0;t.radius-(t.inertialRadiusOffset+e)/i>l&&(e=(t.radius-l)*i-t.inertialRadiusOffset)}const s=e/i/t.radius,n=this._getPosition(),o=V.Vector3[6];n.subtractToRef(t.target,o),o.scaleInPlace(s),o.scaleInPlace(i),this._inertialPanning.addInPlace(o),t.inertialRadiusOffset+=e}_zeroIfClose(e){Math.abs(e.x)<He&&(e.x=0),Math.abs(e.y)<He&&(e.y=0),Math.abs(e.z)<He&&(e.z=0)}}C([F()],sl.prototype,"wheelPrecision",void 0);C([F()],sl.prototype,"zoomToMouseLocation",void 0);C([F()],sl.prototype,"wheelDeltaPercentage",void 0);dr.ArcRotateCameraMouseWheelInput=sl;class Vi extends qm{constructor(){super(...arguments),this.buttons=[0,1,2],this.angularSensibilityX=1e3,this.angularSensibilityY=1e3,this.pinchPrecision=12,this.pinchDeltaPercentage=0,this.useNaturalPinchZoom=!1,this.pinchZoom=!0,this.panningSensibility=1e3,this.multiTouchPanning=!0,this.multiTouchPanAndZoom=!0,this.pinchInwards=!0,this._isPanClick=!1,this._twoFingerActivityCount=0,this._isPinching=!1}getClassName(){return"ArcRotateCameraPointersInput"}_computeMultiTouchPanning(e,t){if(this.panningSensibility!==0&&e&&t){const i=t.x-e.x,r=t.y-e.y;this.camera.inertialPanningX+=-i/this.panningSensibility,this.camera.inertialPanningY+=r/this.panningSensibility}}_computePinchZoom(e,t){const i=this.camera.radius||Vi.MinimumRadiusForPinch;this.useNaturalPinchZoom?this.camera.radius=i*Math.sqrt(e)/Math.sqrt(t):this.pinchDeltaPercentage?this.camera.inertialRadiusOffset+=(t-e)*.001*i*this.pinchDeltaPercentage:this.camera.inertialRadiusOffset+=(t-e)/(this.pinchPrecision*(this.pinchInwards?1:-1)*(this.angularSensibilityX+this.angularSensibilityY)/2)}onTouch(e,t,i){this.panningSensibility!==0&&(this._ctrlKey&&this.camera._useCtrlForPanning||this._isPanClick)?(this.camera.inertialPanningX+=-t/this.panningSensibility,this.camera.inertialPanningY+=i/this.panningSensibility):(this.camera.inertialAlphaOffset-=t/this.angularSensibilityX,this.camera.inertialBetaOffset-=i/this.angularSensibilityY)}onDoubleTap(){this.camera.useInputToRestoreState&&this.camera.restoreState()}onMultiTouch(e,t,i,r,s,n){i===0&&s===null||r===0&&n===null||(this.multiTouchPanAndZoom?(this._computePinchZoom(i,r),this._computeMultiTouchPanning(s,n)):this.multiTouchPanning&&this.pinchZoom?(this._twoFingerActivityCount++,this._isPinching||this._twoFingerActivityCount<20&&Math.abs(Math.sqrt(r)-Math.sqrt(i))>this.camera.pinchToPanMaxDistance?(this._computePinchZoom(i,r),this._isPinching=!0):this._computeMultiTouchPanning(s,n)):this.multiTouchPanning?this._computeMultiTouchPanning(s,n):this.pinchZoom&&this._computePinchZoom(i,r))}onButtonDown(e){this._isPanClick=e.button===this.camera._panningMouseButton}onButtonUp(e){this._twoFingerActivityCount=0,this._isPinching=!1}onLostFocus(){this._isPanClick=!1,this._twoFingerActivityCount=0,this._isPinching=!1}}Vi.MinimumRadiusForPinch=.001;C([F()],Vi.prototype,"buttons",void 0);C([F()],Vi.prototype,"angularSensibilityX",void 0);C([F()],Vi.prototype,"angularSensibilityY",void 0);C([F()],Vi.prototype,"pinchPrecision",void 0);C([F()],Vi.prototype,"pinchDeltaPercentage",void 0);C([F()],Vi.prototype,"useNaturalPinchZoom",void 0);C([F()],Vi.prototype,"pinchZoom",void 0);C([F()],Vi.prototype,"panningSensibility",void 0);C([F()],Vi.prototype,"multiTouchPanning",void 0);C([F()],Vi.prototype,"multiTouchPanAndZoom",void 0);dr.ArcRotateCameraPointersInput=Vi;class Qm extends Am{constructor(e){super(e)}addMouseWheel(){return this.add(new sl),this}addPointers(){return this.add(new Vi),this}addKeyboard(){return this.add(new Hr),this}}Qm.prototype.addVRDeviceOrientation=function(){return this.add(new $y),this};class $y{constructor(){this.alphaCorrection=1,this.gammaCorrection=1,this._alpha=0,this._gamma=0,this._dirty=!1,this._deviceOrientationHandler=e=>this._onOrientationEvent(e)}attachControl(e){e=ae.BackCompatCameraNoPreventDefault(arguments),this.camera.attachControl(e);const t=this.camera.getScene().getEngine().getHostWindow();t&&(typeof DeviceOrientationEvent<"u"&&typeof DeviceOrientationEvent.requestPermission=="function"?DeviceOrientationEvent.requestPermission().then(i=>{i==="granted"?t.addEventListener("deviceorientation",this._deviceOrientationHandler):ae.Warn("Permission not granted.")}).catch(i=>{ae.Error(i)}):t.addEventListener("deviceorientation",this._deviceOrientationHandler))}_onOrientationEvent(e){e.alpha!==null&&(this._alpha=(+e.alpha|0)*this.alphaCorrection),e.gamma!==null&&(this._gamma=(+e.gamma|0)*this.gammaCorrection),this._dirty=!0}checkInputs(){this._dirty&&(this._dirty=!1,this._gamma<0&&(this._gamma=180+this._gamma),this.camera.alpha=-this._alpha/180*Math.PI%Math.PI*2,this.camera.beta=this._gamma/180*Math.PI)}detachControl(){window.removeEventListener("deviceorientation",this._deviceOrientationHandler)}getClassName(){return"ArcRotateCameraVRDeviceOrientationInput"}getSimpleName(){return"VRDeviceOrientation"}}dr.ArcRotateCameraVRDeviceOrientationInput=$y;class xn{constructor(){this.keysForward=[87],this.keysBackward=[83],this.keysUp=[69],this.keysDown=[81],this.keysRight=[68],this.keysLeft=[65],this._keys=new Array}attachControl(e){e=ae.BackCompatCameraNoPreventDefault(arguments),!this._onCanvasBlurObserver&&(this._scene=this.camera.getScene(),this._engine=this._scene.getEngine(),this._onCanvasBlurObserver=this._engine.onCanvasBlurObservable.add(()=>{this._keys.length=0}),this._onKeyboardObserver=this._scene.onKeyboardObservable.add(t=>{const i=t.event;if(t.type===Mm.KEYDOWN)(this.keysForward.indexOf(i.keyCode)!==-1||this.keysBackward.indexOf(i.keyCode)!==-1||this.keysUp.indexOf(i.keyCode)!==-1||this.keysDown.indexOf(i.keyCode)!==-1||this.keysLeft.indexOf(i.keyCode)!==-1||this.keysRight.indexOf(i.keyCode)!==-1)&&(this._keys.indexOf(i.keyCode)===-1&&this._keys.push(i.keyCode),e||i.preventDefault());else if(this.keysForward.indexOf(i.keyCode)!==-1||this.keysBackward.indexOf(i.keyCode)!==-1||this.keysUp.indexOf(i.keyCode)!==-1||this.keysDown.indexOf(i.keyCode)!==-1||this.keysLeft.indexOf(i.keyCode)!==-1||this.keysRight.indexOf(i.keyCode)!==-1){const r=this._keys.indexOf(i.keyCode);r>=0&&this._keys.splice(r,1),e||i.preventDefault()}}))}detachControl(){this._scene&&(this._onKeyboardObserver&&this._scene.onKeyboardObservable.remove(this._onKeyboardObserver),this._onCanvasBlurObserver&&this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver),this._onKeyboardObserver=null,this._onCanvasBlurObserver=null),this._keys.length=0}getClassName(){return"FlyCameraKeyboardInput"}_onLostFocus(){this._keys.length=0}getSimpleName(){return"keyboard"}checkInputs(){if(this._onKeyboardObserver){const e=this.camera;for(let t=0;t<this._keys.length;t++){const i=this._keys[t],r=e._computeLocalCameraSpeed();this.keysForward.indexOf(i)!==-1?e._localDirection.copyFromFloats(0,0,r):this.keysBackward.indexOf(i)!==-1?e._localDirection.copyFromFloats(0,0,-r):this.keysUp.indexOf(i)!==-1?e._localDirection.copyFromFloats(0,r,0):this.keysDown.indexOf(i)!==-1?e._localDirection.copyFromFloats(0,-r,0):this.keysRight.indexOf(i)!==-1?e._localDirection.copyFromFloats(r,0,0):this.keysLeft.indexOf(i)!==-1&&e._localDirection.copyFromFloats(-r,0,0),e.getScene().useRightHandedSystem&&(e._localDirection.z*=-1),e.getViewMatrix().invertToRef(e._cameraTransformMatrix),m.TransformNormalToRef(e._localDirection,e._cameraTransformMatrix,e._transformedDirection),e.cameraDirection.addInPlace(e._transformedDirection)}}}}C([F()],xn.prototype,"keysForward",void 0);C([F()],xn.prototype,"keysBackward",void 0);C([F()],xn.prototype,"keysUp",void 0);C([F()],xn.prototype,"keysDown",void 0);C([F()],xn.prototype,"keysRight",void 0);C([F()],xn.prototype,"keysLeft",void 0);dr.FlyCameraKeyboardInput=xn;class Cu{constructor(){this.buttons=[0,1,2],this.buttonsYaw=[-1,0,1],this.buttonsPitch=[-1,0,1],this.buttonsRoll=[2],this.activeButton=-1,this.angularSensibility=1e3,this._previousPosition=null}attachControl(e){e=ae.BackCompatCameraNoPreventDefault(arguments),this._noPreventDefault=e,this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(t=>{this._pointerInput(t)},Be.POINTERDOWN|Be.POINTERUP|Be.POINTERMOVE),this._rollObserver=this.camera.getScene().onBeforeRenderObservable.add(()=>{this.camera.rollCorrect&&this.camera.restoreRoll(this.camera.rollCorrect)})}detachControl(){this._observer&&(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this.camera.getScene().onBeforeRenderObservable.remove(this._rollObserver),this._observer=null,this._rollObserver=null,this._previousPosition=null,this._noPreventDefault=void 0)}getClassName(){return"FlyCameraMouseInput"}getSimpleName(){return"mouse"}_pointerInput(e){const t=e.event,r=this.camera.getEngine();if(!this.touchEnabled&&t.pointerType==="touch"||e.type!==Be.POINTERMOVE&&this.buttons.indexOf(t.button)===-1)return;const s=t.target;if(e.type===Be.POINTERDOWN){try{s==null||s.setPointerCapture(t.pointerId)}catch{}this._previousPosition={x:t.clientX,y:t.clientY},this.activeButton=t.button,this._noPreventDefault||t.preventDefault(),r.isPointerLock&&this._onMouseMove(e.event)}else if(e.type===Be.POINTERUP){try{s==null||s.releasePointerCapture(t.pointerId)}catch{}this.activeButton=-1,this._previousPosition=null,this._noPreventDefault||t.preventDefault()}else if(e.type===Be.POINTERMOVE){if(!this._previousPosition){r.isPointerLock&&this._onMouseMove(e.event);return}const n=t.clientX-this._previousPosition.x,o=t.clientY-this._previousPosition.y;this._rotateCamera(n,o),this._previousPosition={x:t.clientX,y:t.clientY},this._noPreventDefault||t.preventDefault()}}_onMouseMove(e){if(!this.camera.getEngine().isPointerLock)return;const r=e.movementX,s=e.movementY;this._rotateCamera(r,s),this._previousPosition=null,this._noPreventDefault||e.preventDefault()}_rotateCamera(e,t){const i=this.camera,r=i._calculateHandednessMultiplier();e*=r;const s=e/this.angularSensibility,n=t/this.angularSensibility,o=re.RotationYawPitchRoll(i.rotation.y,i.rotation.x,i.rotation.z);let l;if(this.buttonsPitch.some(u=>u===this.activeButton)&&(l=re.RotationAxis(qi.X,n),o.multiplyInPlace(l)),this.buttonsYaw.some(u=>u===this.activeButton)){l=re.RotationAxis(qi.Y,s),o.multiplyInPlace(l);const u=i.bankedTurnLimit+i._trackRoll;if(i.bankedTurn&&-u<i.rotation.z&&i.rotation.z<u){const c=i.bankedTurnMultiplier*-s;l=re.RotationAxis(qi.Z,c),o.multiplyInPlace(l)}}this.buttonsRoll.some(u=>u===this.activeButton)&&(l=re.RotationAxis(qi.Z,-s),i._trackRoll-=s,o.multiplyInPlace(l)),o.toEulerAnglesToRef(i.rotation)}}C([F()],Cu.prototype,"buttons",void 0);C([F()],Cu.prototype,"angularSensibility",void 0);dr.FlyCameraMouseInput=Cu;class ui{constructor(){this.keysHeightOffsetIncr=[38],this.keysHeightOffsetDecr=[40],this.keysHeightOffsetModifierAlt=!1,this.keysHeightOffsetModifierCtrl=!1,this.keysHeightOffsetModifierShift=!1,this.keysRotationOffsetIncr=[37],this.keysRotationOffsetDecr=[39],this.keysRotationOffsetModifierAlt=!1,this.keysRotationOffsetModifierCtrl=!1,this.keysRotationOffsetModifierShift=!1,this.keysRadiusIncr=[40],this.keysRadiusDecr=[38],this.keysRadiusModifierAlt=!0,this.keysRadiusModifierCtrl=!1,this.keysRadiusModifierShift=!1,this.heightSensibility=1,this.rotationSensibility=1,this.radiusSensibility=1,this._keys=new Array}attachControl(e){e=ae.BackCompatCameraNoPreventDefault(arguments),!this._onCanvasBlurObserver&&(this._scene=this.camera.getScene(),this._engine=this._scene.getEngine(),this._onCanvasBlurObserver=this._engine.onCanvasBlurObservable.add(()=>{this._keys.length=0}),this._onKeyboardObserver=this._scene.onKeyboardObservable.add(t=>{const i=t.event;if(!i.metaKey){if(t.type===Mm.KEYDOWN)this._ctrlPressed=i.ctrlKey,this._altPressed=i.altKey,this._shiftPressed=i.shiftKey,(this.keysHeightOffsetIncr.indexOf(i.keyCode)!==-1||this.keysHeightOffsetDecr.indexOf(i.keyCode)!==-1||this.keysRotationOffsetIncr.indexOf(i.keyCode)!==-1||this.keysRotationOffsetDecr.indexOf(i.keyCode)!==-1||this.keysRadiusIncr.indexOf(i.keyCode)!==-1||this.keysRadiusDecr.indexOf(i.keyCode)!==-1)&&(this._keys.indexOf(i.keyCode)===-1&&this._keys.push(i.keyCode),i.preventDefault&&(e||i.preventDefault()));else if(this.keysHeightOffsetIncr.indexOf(i.keyCode)!==-1||this.keysHeightOffsetDecr.indexOf(i.keyCode)!==-1||this.keysRotationOffsetIncr.indexOf(i.keyCode)!==-1||this.keysRotationOffsetDecr.indexOf(i.keyCode)!==-1||this.keysRadiusIncr.indexOf(i.keyCode)!==-1||this.keysRadiusDecr.indexOf(i.keyCode)!==-1){const r=this._keys.indexOf(i.keyCode);r>=0&&this._keys.splice(r,1),i.preventDefault&&(e||i.preventDefault())}}}))}detachControl(){this._scene&&(this._onKeyboardObserver&&this._scene.onKeyboardObservable.remove(this._onKeyboardObserver),this._onCanvasBlurObserver&&this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver),this._onKeyboardObserver=null,this._onCanvasBlurObserver=null),this._keys.length=0}checkInputs(){this._onKeyboardObserver&&this._keys.forEach(e=>{this.keysHeightOffsetIncr.indexOf(e)!==-1&&this._modifierHeightOffset()?this.camera.heightOffset+=this.heightSensibility:this.keysHeightOffsetDecr.indexOf(e)!==-1&&this._modifierHeightOffset()?this.camera.heightOffset-=this.heightSensibility:this.keysRotationOffsetIncr.indexOf(e)!==-1&&this._modifierRotationOffset()?(this.camera.rotationOffset+=this.rotationSensibility,this.camera.rotationOffset%=360):this.keysRotationOffsetDecr.indexOf(e)!==-1&&this._modifierRotationOffset()?(this.camera.rotationOffset-=this.rotationSensibility,this.camera.rotationOffset%=360):this.keysRadiusIncr.indexOf(e)!==-1&&this._modifierRadius()?this.camera.radius+=this.radiusSensibility:this.keysRadiusDecr.indexOf(e)!==-1&&this._modifierRadius()&&(this.camera.radius-=this.radiusSensibility)})}getClassName(){return"FollowCameraKeyboardMoveInput"}getSimpleName(){return"keyboard"}_modifierHeightOffset(){return this.keysHeightOffsetModifierAlt===this._altPressed&&this.keysHeightOffsetModifierCtrl===this._ctrlPressed&&this.keysHeightOffsetModifierShift===this._shiftPressed}_modifierRotationOffset(){return this.keysRotationOffsetModifierAlt===this._altPressed&&this.keysRotationOffsetModifierCtrl===this._ctrlPressed&&this.keysRotationOffsetModifierShift===this._shiftPressed}_modifierRadius(){return this.keysRadiusModifierAlt===this._altPressed&&this.keysRadiusModifierCtrl===this._ctrlPressed&&this.keysRadiusModifierShift===this._shiftPressed}}C([F()],ui.prototype,"keysHeightOffsetIncr",void 0);C([F()],ui.prototype,"keysHeightOffsetDecr",void 0);C([F()],ui.prototype,"keysHeightOffsetModifierAlt",void 0);C([F()],ui.prototype,"keysHeightOffsetModifierCtrl",void 0);C([F()],ui.prototype,"keysHeightOffsetModifierShift",void 0);C([F()],ui.prototype,"keysRotationOffsetIncr",void 0);C([F()],ui.prototype,"keysRotationOffsetDecr",void 0);C([F()],ui.prototype,"keysRotationOffsetModifierAlt",void 0);C([F()],ui.prototype,"keysRotationOffsetModifierCtrl",void 0);C([F()],ui.prototype,"keysRotationOffsetModifierShift",void 0);C([F()],ui.prototype,"keysRadiusIncr",void 0);C([F()],ui.prototype,"keysRadiusDecr",void 0);C([F()],ui.prototype,"keysRadiusModifierAlt",void 0);C([F()],ui.prototype,"keysRadiusModifierCtrl",void 0);C([F()],ui.prototype,"keysRadiusModifierShift",void 0);C([F()],ui.prototype,"heightSensibility",void 0);C([F()],ui.prototype,"rotationSensibility",void 0);C([F()],ui.prototype,"radiusSensibility",void 0);dr.FollowCameraKeyboardMoveInput=ui;class Kn{constructor(){this.axisControlRadius=!0,this.axisControlHeight=!1,this.axisControlRotation=!1,this.wheelPrecision=3,this.wheelDeltaPercentage=0}attachControl(e){e=ae.BackCompatCameraNoPreventDefault(arguments),this._wheel=t=>{if(t.type!==Be.POINTERWHEEL)return;const i=t.event;let r=0;const s=Math.max(-1,Math.min(1,i.deltaY));this.wheelDeltaPercentage?(+this.axisControlRadius+ +this.axisControlHeight+ +this.axisControlRotation&&L.Warn("wheelDeltaPercentage only usable when mouse wheel controls ONE axis. Currently enabled: axisControlRadius: "+this.axisControlRadius+", axisControlHeightOffset: "+this.axisControlHeight+", axisControlRotationOffset: "+this.axisControlRotation),this.axisControlRadius?r=s*.01*this.wheelDeltaPercentage*this.camera.radius:this.axisControlHeight?r=s*.01*this.wheelDeltaPercentage*this.camera.heightOffset:this.axisControlRotation&&(r=s*.01*this.wheelDeltaPercentage*this.camera.rotationOffset)):r=s*this.wheelPrecision,r&&(this.axisControlRadius?this.camera.radius+=r:this.axisControlHeight?this.camera.heightOffset-=r:this.axisControlRotation&&(this.camera.rotationOffset-=r)),i.preventDefault&&(e||i.preventDefault())},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel,Be.POINTERWHEEL)}detachControl(){this._observer&&(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null,this._wheel=null)}getClassName(){return"ArcRotateCameraMouseWheelInput"}getSimpleName(){return"mousewheel"}}C([F()],Kn.prototype,"axisControlRadius",void 0);C([F()],Kn.prototype,"axisControlHeight",void 0);C([F()],Kn.prototype,"axisControlRotation",void 0);C([F()],Kn.prototype,"wheelPrecision",void 0);C([F()],Kn.prototype,"wheelDeltaPercentage",void 0);dr.FollowCameraMouseWheelInput=Kn;class ki extends qm{constructor(){super(...arguments),this.angularSensibilityX=1,this.angularSensibilityY=1,this.pinchPrecision=1e4,this.pinchDeltaPercentage=0,this.axisXControlRadius=!1,this.axisXControlHeight=!1,this.axisXControlRotation=!0,this.axisYControlRadius=!1,this.axisYControlHeight=!0,this.axisYControlRotation=!1,this.axisPinchControlRadius=!0,this.axisPinchControlHeight=!1,this.axisPinchControlRotation=!1,this.warningEnable=!0,this._warningCounter=0}getClassName(){return"FollowCameraPointersInput"}onTouch(e,t,i){this._warning(),this.axisXControlRotation?this.camera.rotationOffset+=t/this.angularSensibilityX:this.axisYControlRotation&&(this.camera.rotationOffset+=i/this.angularSensibilityX),this.axisXControlHeight?this.camera.heightOffset+=t/this.angularSensibilityY:this.axisYControlHeight&&(this.camera.heightOffset+=i/this.angularSensibilityY),this.axisXControlRadius?this.camera.radius-=t/this.angularSensibilityY:this.axisYControlRadius&&(this.camera.radius-=i/this.angularSensibilityY)}onMultiTouch(e,t,i,r,s,n){if(i===0&&s===null||r===0&&n===null)return;let o=(r-i)/(this.pinchPrecision*(this.angularSensibilityX+this.angularSensibilityY)/2);this.pinchDeltaPercentage?(o*=.01*this.pinchDeltaPercentage,this.axisPinchControlRotation&&(this.camera.rotationOffset+=o*this.camera.rotationOffset),this.axisPinchControlHeight&&(this.camera.heightOffset+=o*this.camera.heightOffset),this.axisPinchControlRadius&&(this.camera.radius-=o*this.camera.radius)):(this.axisPinchControlRotation&&(this.camera.rotationOffset+=o),this.axisPinchControlHeight&&(this.camera.heightOffset+=o),this.axisPinchControlRadius&&(this.camera.radius-=o))}_warning(){if(!this.warningEnable||this._warningCounter++%100!==0)return;const e="It probably only makes sense to control ONE camera property with each pointer axis. Set 'warningEnable = false' if you are sure. Currently enabled: ";+this.axisXControlRotation+ +this.axisXControlHeight+ +this.axisXControlRadius<=1&&L.Warn(e+"axisXControlRotation: "+this.axisXControlRotation+", axisXControlHeight: "+this.axisXControlHeight+", axisXControlRadius: "+this.axisXControlRadius),+this.axisYControlRotation+ +this.axisYControlHeight+ +this.axisYControlRadius<=1&&L.Warn(e+"axisYControlRotation: "+this.axisYControlRotation+", axisYControlHeight: "+this.axisYControlHeight+", axisYControlRadius: "+this.axisYControlRadius),+this.axisPinchControlRotation+ +this.axisPinchControlHeight+ +this.axisPinchControlRadius<=1&&L.Warn(e+"axisPinchControlRotation: "+this.axisPinchControlRotation+", axisPinchControlHeight: "+this.axisPinchControlHeight+", axisPinchControlRadius: "+this.axisPinchControlRadius)}}C([F()],ki.prototype,"angularSensibilityX",void 0);C([F()],ki.prototype,"angularSensibilityY",void 0);C([F()],ki.prototype,"pinchPrecision",void 0);C([F()],ki.prototype,"pinchDeltaPercentage",void 0);C([F()],ki.prototype,"axisXControlRadius",void 0);C([F()],ki.prototype,"axisXControlHeight",void 0);C([F()],ki.prototype,"axisXControlRotation",void 0);C([F()],ki.prototype,"axisYControlRadius",void 0);C([F()],ki.prototype,"axisYControlHeight",void 0);C([F()],ki.prototype,"axisYControlRotation",void 0);C([F()],ki.prototype,"axisPinchControlRadius",void 0);C([F()],ki.prototype,"axisPinchControlHeight",void 0);C([F()],ki.prototype,"axisPinchControlRotation",void 0);dr.FollowCameraPointersInput=ki;Dm.prototype.addDeviceOrientation=function(a){return this._deviceOrientationInput||(this._deviceOrientationInput=new Hy,a&&(this._deviceOrientationInput.smoothFactor=a),this.add(this._deviceOrientationInput)),this};class Hy{static WaitForOrientationChangeAsync(e){return new Promise((t,i)=>{let r=!1;const s=()=>{window.removeEventListener("deviceorientation",s),r=!0,t()};e&&setTimeout(()=>{r||(window.removeEventListener("deviceorientation",s),i("WaitForOrientationChangeAsync timed out"))},e),typeof DeviceOrientationEvent<"u"&&typeof DeviceOrientationEvent.requestPermission=="function"?DeviceOrientationEvent.requestPermission().then(n=>{n=="granted"?window.addEventListener("deviceorientation",s):ae.Warn("Permission not granted.")}).catch(n=>{ae.Error(n)}):window.addEventListener("deviceorientation",s)})}constructor(){this._screenOrientationAngle=0,this._screenQuaternion=new re,this._alpha=0,this._beta=0,this._gamma=0,this.smoothFactor=0,this._onDeviceOrientationChangedObservable=new j,this._orientationChanged=()=>{this._screenOrientationAngle=window.orientation!==void 0?+window.orientation:window.screen.orientation&&window.screen.orientation.angle?window.screen.orientation.angle:0,this._screenOrientationAngle=-ae.ToRadians(this._screenOrientationAngle/2),this._screenQuaternion.copyFromFloats(0,Math.sin(this._screenOrientationAngle),0,Math.cos(this._screenOrientationAngle))},this._deviceOrientation=e=>{this.smoothFactor?(this._alpha=e.alpha!==null?ae.SmoothAngleChange(this._alpha,e.alpha,this.smoothFactor):0,this._beta=e.beta!==null?ae.SmoothAngleChange(this._beta,e.beta,this.smoothFactor):0,this._gamma=e.gamma!==null?ae.SmoothAngleChange(this._gamma,e.gamma,this.smoothFactor):0):(this._alpha=e.alpha!==null?e.alpha:0,this._beta=e.beta!==null?e.beta:0,this._gamma=e.gamma!==null?e.gamma:0),e.alpha!==null&&this._onDeviceOrientationChangedObservable.notifyObservers()},this._constantTransform=new re(-Math.sqrt(.5),0,0,Math.sqrt(.5)),this._orientationChanged()}get camera(){return this._camera}set camera(e){this._camera=e,this._camera!=null&&!this._camera.rotationQuaternion&&(this._camera.rotationQuaternion=new re),this._camera&&this._camera.onDisposeObservable.add(()=>{this._onDeviceOrientationChangedObservable.clear()})}attachControl(){const e=this.camera.getScene().getEngine().getHostWindow();if(e){const t=()=>{e.addEventListener("orientationchange",this._orientationChanged),e.addEventListener("deviceorientation",this._deviceOrientation),this._orientationChanged()};typeof DeviceOrientationEvent<"u"&&typeof DeviceOrientationEvent.requestPermission=="function"?DeviceOrientationEvent.requestPermission().then(i=>{i==="granted"?t():ae.Warn("Permission not granted.")}).catch(i=>{ae.Error(i)}):t()}}detachControl(){window.removeEventListener("orientationchange",this._orientationChanged),window.removeEventListener("deviceorientation",this._deviceOrientation),this._alpha=0}checkInputs(){this._alpha&&(re.RotationYawPitchRollToRef(ae.ToRadians(this._alpha),ae.ToRadians(this._beta),-ae.ToRadians(this._gamma),this.camera.rotationQuaternion),this._camera.rotationQuaternion.multiplyInPlace(this._screenQuaternion),this._camera.rotationQuaternion.multiplyInPlace(this._constantTransform),this._camera.getScene().useRightHandedSystem?this._camera.rotationQuaternion.y*=-1:this._camera.rotationQuaternion.z*=-1,this._camera.rotationQuaternion.w*=-1)}getClassName(){return"FreeCameraDeviceOrientationInput"}getSimpleName(){return"deviceOrientation"}}dr.FreeCameraDeviceOrientationInput=Hy;class Pu{constructor(){this.gamepadAngularSensibility=200,this.gamepadMoveSensibility=40,this.deadzoneDelta=.1,this._yAxisScale=1,this._cameraTransform=$.Identity(),this._deltaTransform=m.Zero(),this._vector3=m.Zero(),this._vector2=Q.Zero()}get invertYAxis(){return this._yAxisScale!==1}set invertYAxis(e){this._yAxisScale=e?-1:1}attachControl(){const e=this.camera.getScene().gamepadManager;this._onGamepadConnectedObserver=e.onGamepadConnectedObservable.add(t=>{t.type!==Jt.POSE_ENABLED&&(!this.gamepad||t.type===Jt.XBOX)&&(this.gamepad=t)}),this._onGamepadDisconnectedObserver=e.onGamepadDisconnectedObservable.add(t=>{this.gamepad===t&&(this.gamepad=null)}),this.gamepad=e.getGamepadByType(Jt.XBOX),!this.gamepad&&e.gamepads.length&&(this.gamepad=e.gamepads[0])}detachControl(){this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver),this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver),this.gamepad=null}checkInputs(){if(this.gamepad&&this.gamepad.leftStick){const e=this.camera,t=this.gamepad.leftStick;this.gamepadMoveSensibility!==0&&(t.x=Math.abs(t.x)>this.deadzoneDelta?t.x/this.gamepadMoveSensibility:0,t.y=Math.abs(t.y)>this.deadzoneDelta?t.y/this.gamepadMoveSensibility:0);let i=this.gamepad.rightStick;i&&this.gamepadAngularSensibility!==0?(i.x=Math.abs(i.x)>this.deadzoneDelta?i.x/this.gamepadAngularSensibility:0,i.y=(Math.abs(i.y)>this.deadzoneDelta?i.y/this.gamepadAngularSensibility:0)*this._yAxisScale):i={x:0,y:0},e.rotationQuaternion?e.rotationQuaternion.toRotationMatrix(this._cameraTransform):$.RotationYawPitchRollToRef(e.rotation.y,e.rotation.x,0,this._cameraTransform);const r=e._computeLocalCameraSpeed()*50;this._vector3.copyFromFloats(t.x*r,0,-t.y*r),m.TransformCoordinatesToRef(this._vector3,this._cameraTransform,this._deltaTransform),e.cameraDirection.addInPlace(this._deltaTransform),this._vector2.copyFromFloats(i.y,i.x),e.cameraRotation.addInPlace(this._vector2)}}getClassName(){return"FreeCameraGamepadInput"}getSimpleName(){return"gamepad"}}C([F()],Pu.prototype,"gamepadAngularSensibility",void 0);C([F()],Pu.prototype,"gamepadMoveSensibility",void 0);dr.FreeCameraGamepadInput=Pu;var Mg;(function(a){a[a.X=0]="X",a[a.Y=1]="Y",a[a.Z=2]="Z"})(Mg||(Mg={}));class me{static _GetDefaultOptions(){return{puckSize:40,containerSize:60,color:"cyan",puckImage:void 0,containerImage:void 0,position:void 0,alwaysVisible:!1,limitToContainer:!1}}constructor(e,t){this._released=!1;const i={...me._GetDefaultOptions(),...t};if(e?this._leftJoystick=!0:this._leftJoystick=!1,me._GlobalJoystickIndex++,this._axisTargetedByLeftAndRight=0,this._axisTargetedByUpAndDown=1,this.reverseLeftRight=!1,this.reverseUpDown=!1,this._touches=new AR,this.deltaPosition=m.Zero(),this._joystickSensibility=25,this._inversedSensibility=1/(this._joystickSensibility/1e3),this._onResize=()=>{me._VJCanvasWidth=window.innerWidth,me._VJCanvasHeight=window.innerHeight,me.Canvas&&(me.Canvas.width=me._VJCanvasWidth,me.Canvas.height=me._VJCanvasHeight),me._HalfWidth=me._VJCanvasWidth/2},!me.Canvas){window.addEventListener("resize",this._onResize,!1),me.Canvas=document.createElement("canvas"),me._VJCanvasWidth=window.innerWidth,me._VJCanvasHeight=window.innerHeight,me.Canvas.width=window.innerWidth,me.Canvas.height=window.innerHeight,me.Canvas.style.width="100%",me.Canvas.style.height="100%",me.Canvas.style.position="absolute",me.Canvas.style.backgroundColor="transparent",me.Canvas.style.top="0px",me.Canvas.style.left="0px",me.Canvas.style.zIndex="5",me.Canvas.style.touchAction="none",me.Canvas.setAttribute("touch-action","none");const r=me.Canvas.getContext("2d");if(!r)throw new Error("Unable to create canvas for virtual joystick");me._VJCanvasContext=r,me._VJCanvasContext.strokeStyle="#ffffff",me._VJCanvasContext.lineWidth=2,document.body.appendChild(me.Canvas)}me._HalfWidth=me.Canvas.width/2,this.pressed=!1,this.limitToContainer=i.limitToContainer,this._joystickColor=i.color,this.containerSize=i.containerSize,this.puckSize=i.puckSize,i.position&&this.setPosition(i.position.x,i.position.y),i.puckImage&&this.setPuckImage(i.puckImage),i.containerImage&&this.setContainerImage(i.containerImage),i.alwaysVisible&&me._AlwaysVisibleSticks++,this.alwaysVisible=i.alwaysVisible,this._joystickPointerId=-1,this._joystickPointerPos=new Q(0,0),this._joystickPreviousPointerPos=new Q(0,0),this._joystickPointerStartPos=new Q(0,0),this._deltaJoystickVector=new Q(0,0),this._onPointerDownHandlerRef=r=>{this._onPointerDown(r)},this._onPointerMoveHandlerRef=r=>{this._onPointerMove(r)},this._onPointerUpHandlerRef=r=>{this._onPointerUp(r)},me.Canvas.addEventListener("pointerdown",this._onPointerDownHandlerRef,!1),me.Canvas.addEventListener("pointermove",this._onPointerMoveHandlerRef,!1),me.Canvas.addEventListener("pointerup",this._onPointerUpHandlerRef,!1),me.Canvas.addEventListener("pointerout",this._onPointerUpHandlerRef,!1),me.Canvas.addEventListener("pointercancel",this._onPointerUpHandlerRef,!1),me.Canvas.addEventListener("contextmenu",r=>{r.preventDefault()},!1),requestAnimationFrame(()=>{this._drawVirtualJoystick()})}setJoystickSensibility(e){this._joystickSensibility=e,this._inversedSensibility=1/(this._joystickSensibility/1e3)}_onPointerDown(e){let t;e.preventDefault(),this._leftJoystick===!0?t=e.clientX<me._HalfWidth:t=e.clientX>me._HalfWidth,t&&this._joystickPointerId<0?(this._joystickPointerId=e.pointerId,this._joystickPosition?(this._joystickPointerStartPos=this._joystickPosition.clone(),this._joystickPointerPos=this._joystickPosition.clone(),this._joystickPreviousPointerPos=this._joystickPosition.clone(),this._onPointerMove(e)):(this._joystickPointerStartPos.x=e.clientX,this._joystickPointerStartPos.y=e.clientY,this._joystickPointerPos=this._joystickPointerStartPos.clone(),this._joystickPreviousPointerPos=this._joystickPointerStartPos.clone()),this._deltaJoystickVector.x=0,this._deltaJoystickVector.y=0,this.pressed=!0,this._touches.add(e.pointerId.toString(),e)):me._GlobalJoystickIndex<2&&this._action&&(this._action(),this._touches.add(e.pointerId.toString(),{x:e.clientX,y:e.clientY,prevX:e.clientX,prevY:e.clientY}))}_onPointerMove(e){if(this._joystickPointerId==e.pointerId){if(this.limitToContainer){const n=new Q(e.clientX-this._joystickPointerStartPos.x,e.clientY-this._joystickPointerStartPos.y),o=n.length();o>this.containerSize&&n.scaleInPlace(this.containerSize/o),this._joystickPointerPos.x=this._joystickPointerStartPos.x+n.x,this._joystickPointerPos.y=this._joystickPointerStartPos.y+n.y}else this._joystickPointerPos.x=e.clientX,this._joystickPointerPos.y=e.clientY;this._deltaJoystickVector=this._joystickPointerPos.clone(),this._deltaJoystickVector=this._deltaJoystickVector.subtract(this._joystickPointerStartPos),0<me._AlwaysVisibleSticks&&(this._leftJoystick?this._joystickPointerPos.x=Math.min(me._HalfWidth,this._joystickPointerPos.x):this._joystickPointerPos.x=Math.max(me._HalfWidth,this._joystickPointerPos.x));const i=(this.reverseLeftRight?-1:1)*this._deltaJoystickVector.x/this._inversedSensibility;switch(this._axisTargetedByLeftAndRight){case 0:this.deltaPosition.x=Math.min(1,Math.max(-1,i));break;case 1:this.deltaPosition.y=Math.min(1,Math.max(-1,i));break;case 2:this.deltaPosition.z=Math.min(1,Math.max(-1,i));break}const s=(this.reverseUpDown?1:-1)*this._deltaJoystickVector.y/this._inversedSensibility;switch(this._axisTargetedByUpAndDown){case 0:this.deltaPosition.x=Math.min(1,Math.max(-1,s));break;case 1:this.deltaPosition.y=Math.min(1,Math.max(-1,s));break;case 2:this.deltaPosition.z=Math.min(1,Math.max(-1,s));break}}else{const t=this._touches.get(e.pointerId.toString());t&&(t.x=e.clientX,t.y=e.clientY)}}_onPointerUp(e){if(this._joystickPointerId==e.pointerId)this._clearPreviousDraw(),this._joystickPointerId=-1,this.pressed=!1;else{const t=this._touches.get(e.pointerId.toString());t&&me._VJCanvasContext.clearRect(t.prevX-44,t.prevY-44,88,88)}this._deltaJoystickVector.x=0,this._deltaJoystickVector.y=0,this._touches.remove(e.pointerId.toString())}setJoystickColor(e){this._joystickColor=e}set containerSize(e){this._joystickContainerSize=e,this._clearContainerSize=~~(this._joystickContainerSize*2.1),this._clearContainerSizeOffset=~~(this._clearContainerSize/2)}get containerSize(){return this._joystickContainerSize}set puckSize(e){this._joystickPuckSize=e,this._clearPuckSize=~~(this._joystickPuckSize*2.1),this._clearPuckSizeOffset=~~(this._clearPuckSize/2)}get puckSize(){return this._joystickPuckSize}clearPosition(){this.alwaysVisible=!1,this._joystickPosition=null}set alwaysVisible(e){this._alwaysVisible!==e&&(e&&this._joystickPosition?(me._AlwaysVisibleSticks++,this._alwaysVisible=!0):(me._AlwaysVisibleSticks--,this._alwaysVisible=!1))}get alwaysVisible(){return this._alwaysVisible}setPosition(e,t){this._joystickPointerStartPos&&this._clearPreviousDraw(),this._joystickPosition=new Q(e,t)}setActionOnTouch(e){this._action=e}setAxisForLeftRight(e){switch(e){case 0:case 1:case 2:this._axisTargetedByLeftAndRight=e;break;default:this._axisTargetedByLeftAndRight=0;break}}setAxisForUpDown(e){switch(e){case 0:case 1:case 2:this._axisTargetedByUpAndDown=e;break;default:this._axisTargetedByUpAndDown=1;break}}_clearPreviousDraw(){const e=this._joystickPosition||this._joystickPointerStartPos;me._VJCanvasContext.clearRect(e.x-this._clearContainerSizeOffset,e.y-this._clearContainerSizeOffset,this._clearContainerSize,this._clearContainerSize),me._VJCanvasContext.clearRect(this._joystickPreviousPointerPos.x-this._clearPuckSizeOffset-1,this._joystickPreviousPointerPos.y-this._clearPuckSizeOffset-1,this._clearPuckSize+2,this._clearPuckSize+2)}setContainerImage(e){const t=new Image;t.src=e,t.onload=()=>this._containerImage=t}setPuckImage(e){const t=new Image;t.src=e,t.onload=()=>this._puckImage=t}_drawContainer(){const e=this._joystickPosition||this._joystickPointerStartPos;this._clearPreviousDraw(),this._containerImage?me._VJCanvasContext.drawImage(this._containerImage,e.x-this.containerSize,e.y-this.containerSize,this.containerSize*2,this.containerSize*2):(me._VJCanvasContext.beginPath(),me._VJCanvasContext.strokeStyle=this._joystickColor,me._VJCanvasContext.lineWidth=2,me._VJCanvasContext.arc(e.x,e.y,this.containerSize,0,Math.PI*2,!0),me._VJCanvasContext.stroke(),me._VJCanvasContext.closePath(),me._VJCanvasContext.beginPath(),me._VJCanvasContext.lineWidth=6,me._VJCanvasContext.strokeStyle=this._joystickColor,me._VJCanvasContext.arc(e.x,e.y,this.puckSize,0,Math.PI*2,!0),me._VJCanvasContext.stroke(),me._VJCanvasContext.closePath())}_drawPuck(){this._puckImage?me._VJCanvasContext.drawImage(this._puckImage,this._joystickPointerPos.x-this.puckSize,this._joystickPointerPos.y-this.puckSize,this.puckSize*2,this.puckSize*2):(me._VJCanvasContext.beginPath(),me._VJCanvasContext.strokeStyle=this._joystickColor,me._VJCanvasContext.lineWidth=2,me._VJCanvasContext.arc(this._joystickPointerPos.x,this._joystickPointerPos.y,this.puckSize,0,Math.PI*2,!0),me._VJCanvasContext.stroke(),me._VJCanvasContext.closePath())}_drawVirtualJoystick(){this._released||(this.alwaysVisible&&this._drawContainer(),this.pressed&&this._touches.forEach((e,t)=>{t.pointerId===this._joystickPointerId?(this.alwaysVisible||this._drawContainer(),this._drawPuck(),this._joystickPreviousPointerPos=this._joystickPointerPos.clone()):(me._VJCanvasContext.clearRect(t.prevX-44,t.prevY-44,88,88),me._VJCanvasContext.beginPath(),me._VJCanvasContext.fillStyle="white",me._VJCanvasContext.beginPath(),me._VJCanvasContext.strokeStyle="red",me._VJCanvasContext.lineWidth=6,me._VJCanvasContext.arc(t.x,t.y,40,0,Math.PI*2,!0),me._VJCanvasContext.stroke(),me._VJCanvasContext.closePath(),t.prevX=t.x,t.prevY=t.y)}),requestAnimationFrame(()=>{this._drawVirtualJoystick()}))}releaseCanvas(){me.Canvas&&(me.Canvas.removeEventListener("pointerdown",this._onPointerDownHandlerRef),me.Canvas.removeEventListener("pointermove",this._onPointerMoveHandlerRef),me.Canvas.removeEventListener("pointerup",this._onPointerUpHandlerRef),me.Canvas.removeEventListener("pointerout",this._onPointerUpHandlerRef),me.Canvas.removeEventListener("pointercancel",this._onPointerUpHandlerRef),window.removeEventListener("resize",this._onResize),document.body.removeChild(me.Canvas),me.Canvas=null),this._released=!0}}me._GlobalJoystickIndex=0;me._AlwaysVisibleSticks=0;Dm.prototype.addVirtualJoystick=function(){return this.add(new jy),this};class jy{getLeftJoystick(){return this._leftjoystick}getRightJoystick(){return this._rightjoystick}checkInputs(){if(this._leftjoystick){const e=this.camera,t=e._computeLocalCameraSpeed()*50,i=$.RotationYawPitchRoll(e.rotation.y,e.rotation.x,0),r=m.TransformCoordinates(new m(this._leftjoystick.deltaPosition.x*t,this._leftjoystick.deltaPosition.y*t,this._leftjoystick.deltaPosition.z*t),i);e.cameraDirection=e.cameraDirection.add(r),e.cameraRotation=e.cameraRotation.addVector3(this._rightjoystick.deltaPosition),this._leftjoystick.pressed||(this._leftjoystick.deltaPosition=this._leftjoystick.deltaPosition.scale(.9)),this._rightjoystick.pressed||(this._rightjoystick.deltaPosition=this._rightjoystick.deltaPosition.scale(.9))}}attachControl(){this._leftjoystick=new me(!0),this._leftjoystick.setAxisForUpDown(2),this._leftjoystick.setAxisForLeftRight(0),this._leftjoystick.setJoystickSensibility(.15),this._rightjoystick=new me(!1),this._rightjoystick.setAxisForUpDown(0),this._rightjoystick.setAxisForLeftRight(1),this._rightjoystick.reverseUpDown=!0,this._rightjoystick.setJoystickSensibility(.05),this._rightjoystick.setJoystickColor("yellow")}detachControl(){this._leftjoystick.releaseCanvas(),this._rightjoystick.releaseCanvas()}getClassName(){return"FreeCameraVirtualJoystickInput"}getSimpleName(){return"virtualJoystick"}}dr.FreeCameraVirtualJoystickInput=jy;li.AddNodeConstructor("TouchCamera",(a,e)=>()=>new Yy(a,m.Zero(),e));class Yy extends Ms{get touchAngularSensibility(){const e=this.inputs.attached.touch;return e?e.touchAngularSensibility:0}set touchAngularSensibility(e){const t=this.inputs.attached.touch;t&&(t.touchAngularSensibility=e)}get touchMoveSensibility(){const e=this.inputs.attached.touch;return e?e.touchMoveSensibility:0}set touchMoveSensibility(e){const t=this.inputs.attached.touch;t&&(t.touchMoveSensibility=e)}constructor(e,t,i){super(e,t,i),this.inputs.addTouch(),this._setupInputs()}getClassName(){return"TouchCamera"}_setupInputs(){const e=this.inputs.attached.touch,t=this.inputs.attached.mouse;t?t.touchEnabled=!e:e.allowMouse=!t}}li.AddNodeConstructor("ArcRotateCamera",(a,e)=>()=>new lt(a,0,0,1,m.Zero(),e));function XA(a){let e=Math.PI/2;return a.x===0&&a.z===0||(e=Math.acos(a.x/Math.sqrt(Math.pow(a.x,2)+Math.pow(a.z,2)))),a.z<0&&(e=2*Math.PI-e),e}function ZA(a,e){return Math.acos(a/e)}class lt extends Xa{get target(){return this._target}set target(e){this.setTarget(e)}get targetHost(){return this._targetHost}set targetHost(e){e&&this.setTarget(e)}getTarget(){return this.target}get position(){return this._position}set position(e){this.setPosition(e)}set upVector(e){this._upToYMatrix||(this._yToUpMatrix=new $,this._upToYMatrix=new $,this._upVector=m.Zero()),e.normalize(),this._upVector.copyFrom(e),this.setMatUp()}get upVector(){return this._upVector}setMatUp(){$.RotationAlignToRef(m.UpReadOnly,this._upVector,this._yToUpMatrix),$.RotationAlignToRef(this._upVector,m.UpReadOnly,this._upToYMatrix)}get angularSensibilityX(){const e=this.inputs.attached.pointers;return e?e.angularSensibilityX:0}set angularSensibilityX(e){const t=this.inputs.attached.pointers;t&&(t.angularSensibilityX=e)}get angularSensibilityY(){const e=this.inputs.attached.pointers;return e?e.angularSensibilityY:0}set angularSensibilityY(e){const t=this.inputs.attached.pointers;t&&(t.angularSensibilityY=e)}get pinchPrecision(){const e=this.inputs.attached.pointers;return e?e.pinchPrecision:0}set pinchPrecision(e){const t=this.inputs.attached.pointers;t&&(t.pinchPrecision=e)}get pinchDeltaPercentage(){const e=this.inputs.attached.pointers;return e?e.pinchDeltaPercentage:0}set pinchDeltaPercentage(e){const t=this.inputs.attached.pointers;t&&(t.pinchDeltaPercentage=e)}get useNaturalPinchZoom(){const e=this.inputs.attached.pointers;return e?e.useNaturalPinchZoom:!1}set useNaturalPinchZoom(e){const t=this.inputs.attached.pointers;t&&(t.useNaturalPinchZoom=e)}get panningSensibility(){const e=this.inputs.attached.pointers;return e?e.panningSensibility:0}set panningSensibility(e){const t=this.inputs.attached.pointers;t&&(t.panningSensibility=e)}get keysUp(){const e=this.inputs.attached.keyboard;return e?e.keysUp:[]}set keysUp(e){const t=this.inputs.attached.keyboard;t&&(t.keysUp=e)}get keysDown(){const e=this.inputs.attached.keyboard;return e?e.keysDown:[]}set keysDown(e){const t=this.inputs.attached.keyboard;t&&(t.keysDown=e)}get keysLeft(){const e=this.inputs.attached.keyboard;return e?e.keysLeft:[]}set keysLeft(e){const t=this.inputs.attached.keyboard;t&&(t.keysLeft=e)}get keysRight(){const e=this.inputs.attached.keyboard;return e?e.keysRight:[]}set keysRight(e){const t=this.inputs.attached.keyboard;t&&(t.keysRight=e)}get wheelPrecision(){const e=this.inputs.attached.mousewheel;return e?e.wheelPrecision:0}set wheelPrecision(e){const t=this.inputs.attached.mousewheel;t&&(t.wheelPrecision=e)}get zoomToMouseLocation(){const e=this.inputs.attached.mousewheel;return e?e.zoomToMouseLocation:!1}set zoomToMouseLocation(e){const t=this.inputs.attached.mousewheel;t&&(t.zoomToMouseLocation=e)}get wheelDeltaPercentage(){const e=this.inputs.attached.mousewheel;return e?e.wheelDeltaPercentage:0}set wheelDeltaPercentage(e){const t=this.inputs.attached.mousewheel;t&&(t.wheelDeltaPercentage=e)}get bouncingBehavior(){return this._bouncingBehavior}get useBouncingBehavior(){return this._bouncingBehavior!=null}set useBouncingBehavior(e){e!==this.useBouncingBehavior&&(e?(this._bouncingBehavior=new Ln,this.addBehavior(this._bouncingBehavior)):this._bouncingBehavior&&(this.removeBehavior(this._bouncingBehavior),this._bouncingBehavior=null))}get framingBehavior(){return this._framingBehavior}get useFramingBehavior(){return this._framingBehavior!=null}set useFramingBehavior(e){e!==this.useFramingBehavior&&(e?(this._framingBehavior=new Fi,this.addBehavior(this._framingBehavior)):this._framingBehavior&&(this.removeBehavior(this._framingBehavior),this._framingBehavior=null))}get autoRotationBehavior(){return this._autoRotationBehavior}get useAutoRotationBehavior(){return this._autoRotationBehavior!=null}set useAutoRotationBehavior(e){e!==this.useAutoRotationBehavior&&(e?(this._autoRotationBehavior=new $A,this.addBehavior(this._autoRotationBehavior)):this._autoRotationBehavior&&(this.removeBehavior(this._autoRotationBehavior),this._autoRotationBehavior=null))}constructor(e,t,i,r,s,n,o=!0){super(e,m.Zero(),n,o),this.inertialAlphaOffset=0,this.inertialBetaOffset=0,this.inertialRadiusOffset=0,this.lowerAlphaLimit=null,this.upperAlphaLimit=null,this.lowerBetaLimit=.01,this.upperBetaLimit=Math.PI-.01,this.lowerRadiusLimit=null,this.upperRadiusLimit=null,this.lowerTargetYLimit=-1/0,this.inertialPanningX=0,this.inertialPanningY=0,this.pinchToPanMaxDistance=20,this.panningDistanceLimit=null,this.panningOriginTarget=m.Zero(),this.panningInertia=.9,this.zoomOnFactor=1,this.targetScreenOffset=Q.Zero(),this.allowUpsideDown=!0,this.useInputToRestoreState=!0,this.restoreStateInterpolationFactor=0,this._currentInterpolationFactor=0,this._viewMatrix=new $,this.panningAxis=new m(1,1,0),this._transformedDirection=new m,this.mapPanning=!1,this._progressiveRestore=!1,this.onMeshTargetChangedObservable=new j,this.checkCollisions=!1,this.collisionRadius=new m(.5,.5,.5),this._previousPosition=m.Zero(),this._collisionVelocity=m.Zero(),this._newPosition=m.Zero(),this._computationVector=m.Zero(),this._onCollisionPositionChange=(l,u,c=null)=>{c?(this.setPosition(u),this.onCollide&&this.onCollide(c)):this._previousPosition.copyFrom(this._position);const h=Math.cos(this.alpha),d=Math.sin(this.alpha),f=Math.cos(this.beta);let p=Math.sin(this.beta);p===0&&(p=1e-4);const g=this._getTargetPosition();this._computationVector.copyFromFloats(this.radius*h*p,this.radius*f,this.radius*d*p),g.addToRef(this._computationVector,this._newPosition),this._position.copyFrom(this._newPosition);let _=this.upVector;this.allowUpsideDown&&this.beta<0&&(_=_.clone(),_=_.negate()),this._computeViewMatrix(this._position,g,_),this._viewMatrix.addAtIndex(12,this.targetScreenOffset.x),this._viewMatrix.addAtIndex(13,this.targetScreenOffset.y),this._collisionTriggered=!1},this._target=m.Zero(),s&&this.setTarget(s),this.alpha=t,this.beta=i,this.radius=r,this.getViewMatrix(),this.inputs=new Qm(this),this.inputs.addKeyboard().addMouseWheel().addPointers()}_initCache(){super._initCache(),this._cache._target=new m(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.alpha=void 0,this._cache.beta=void 0,this._cache.radius=void 0,this._cache.targetScreenOffset=Q.Zero()}_updateCache(e){e||super._updateCache(),this._cache._target.copyFrom(this._getTargetPosition()),this._cache.alpha=this.alpha,this._cache.beta=this.beta,this._cache.radius=this.radius,this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset)}_getTargetPosition(){if(this._targetHost&&this._targetHost.getAbsolutePosition){const t=this._targetHost.getAbsolutePosition();this._targetBoundingCenter?t.addToRef(this._targetBoundingCenter,this._target):this._target.copyFrom(t)}const e=this._getLockedTargetPosition();return e||this._target}storeState(){return this._storedAlpha=this._goalAlpha=this.alpha,this._storedBeta=this._goalBeta=this.beta,this._storedRadius=this._goalRadius=this.radius,this._storedTarget=this._goalTarget=this._getTargetPosition().clone(),this._storedTargetScreenOffset=this._goalTargetScreenOffset=this.targetScreenOffset.clone(),super.storeState()}_restoreStateValues(){return this.hasStateStored()&&this.restoreStateInterpolationFactor>He&&this.restoreStateInterpolationFactor<1?(this.interpolateTo(this._storedAlpha,this._storedBeta,this._storedRadius,this._storedTarget,this._storedTargetScreenOffset,this.restoreStateInterpolationFactor),!0):super._restoreStateValues()?(this.setTarget(this._storedTarget.clone()),this.alpha=this._storedAlpha,this.beta=this._storedBeta,this.radius=this._storedRadius,this.targetScreenOffset=this._storedTargetScreenOffset.clone(),this.inertialAlphaOffset=0,this.inertialBetaOffset=0,this.inertialRadiusOffset=0,this.inertialPanningX=0,this.inertialPanningY=0,!0):!1}interpolateTo(e=this.alpha,t=this.beta,i=this.radius,r=this.target,s=this.targetScreenOffset,n){this._progressiveRestore=!0,this.inertialAlphaOffset=0,this.inertialBetaOffset=0,this.inertialRadiusOffset=0,this.inertialPanningX=0,this.inertialPanningY=0,n!=null?this._currentInterpolationFactor=n:this.restoreStateInterpolationFactor!==0?this._currentInterpolationFactor=this.restoreStateInterpolationFactor:this._currentInterpolationFactor=.1,e=Si(e,this.lowerAlphaLimit??-1/0,this.upperAlphaLimit??1/0),t=Si(t,this.lowerBetaLimit??-1/0,this.upperBetaLimit??1/0),i=Si(i,this.lowerRadiusLimit??-1/0,this.upperRadiusLimit??1/0),r.y=Si(r.y,this.lowerTargetYLimit??-1/0,1/0),this._goalAlpha=e,this._goalBeta=t,this._goalRadius=i,this._goalTarget=r,this._goalTargetScreenOffset=s}_isSynchronizedViewMatrix(){return super._isSynchronizedViewMatrix()?this._cache._target.equals(this._getTargetPosition())&&this._cache.alpha===this.alpha&&this._cache.beta===this.beta&&this._cache.radius===this.radius&&this._cache.targetScreenOffset.equals(this.targetScreenOffset):!1}attachControl(e,t,i=!0,r=2){const s=arguments;t=ae.BackCompatCameraNoPreventDefault(s),this._useCtrlForPanning=i,this._panningMouseButton=r,typeof s[0]=="boolean"&&(s.length>1&&(this._useCtrlForPanning=s[1]),s.length>2&&(this._panningMouseButton=s[2])),this.inputs.attachElement(t),this._reset=()=>{this.inertialAlphaOffset=0,this.inertialBetaOffset=0,this.inertialRadiusOffset=0,this.inertialPanningX=0,this.inertialPanningY=0}}detachControl(){this.inputs.detachElement(),this._reset&&this._reset()}_checkInputs(){if(!this._collisionTriggered){if(this.inputs.checkInputs(),this._progressiveRestore){const e=this._scene.getEngine().getDeltaTime()/1e3,t=1-Math.pow(2,-e/this._currentInterpolationFactor);this.setTarget(m.Lerp(this.getTarget(),this._goalTarget,t)),re.RotationAlphaBetaGammaToRef(this._goalAlpha,this._goalBeta,0,V.Quaternion[0]),re.RotationAlphaBetaGammaToRef(this.alpha,this.beta,0,V.Quaternion[1]),re.SlerpToRef(V.Quaternion[1],V.Quaternion[0],t,V.Quaternion[2]),V.Quaternion[2].normalize(),V.Quaternion[2].toAlphaBetaGammaToRef(V.Vector3[0]),this.alpha=V.Vector3[0].x,this.beta=V.Vector3[0].y,this.radius+=(this._goalRadius-this.radius)*t,Q.LerpToRef(this.targetScreenOffset,this._goalTargetScreenOffset,t,this.targetScreenOffset),(m.DistanceSquared(this.getTarget(),this._goalTarget)<He&&V.Quaternion[2].isApprox(V.Quaternion[0])&&Math.pow(this._goalRadius-this.radius,2)<He&&Q.Distance(this.targetScreenOffset,this._goalTargetScreenOffset)<He||this.inertialAlphaOffset!==0||this.inertialBetaOffset!==0||this.inertialRadiusOffset!==0||this.inertialPanningX!==0||this.inertialPanningY!==0)&&(this._progressiveRestore=!1)}if(this.inertialAlphaOffset!==0||this.inertialBetaOffset!==0||this.inertialRadiusOffset!==0){const e=this.invertRotation?-1:1,t=this._calculateHandednessMultiplier();let i=this.inertialAlphaOffset*t;this.beta<0&&(i*=-1),this.alpha+=i*e,this.beta+=this.inertialBetaOffset*e,this.radius-=this.inertialRadiusOffset,this.inertialAlphaOffset*=this.inertia,this.inertialBetaOffset*=this.inertia,this.inertialRadiusOffset*=this.inertia,Math.abs(this.inertialAlphaOffset)<He&&(this.inertialAlphaOffset=0),Math.abs(this.inertialBetaOffset)<He&&(this.inertialBetaOffset=0),Math.abs(this.inertialRadiusOffset)<this.speed*He&&(this.inertialRadiusOffset=0)}if(this.inertialPanningX!==0||this.inertialPanningY!==0){const e=new m(this.inertialPanningX,this.inertialPanningY,this.inertialPanningY);if(this._viewMatrix.invertToRef(this._cameraTransformMatrix),e.multiplyInPlace(this.panningAxis),m.TransformNormalToRef(e,this._cameraTransformMatrix,this._transformedDirection),this.mapPanning){const t=this.upVector,i=m.CrossToRef(this._transformedDirection,t,this._transformedDirection);m.CrossToRef(t,i,this._transformedDirection)}else this.panningAxis.y||(this._transformedDirection.y=0);if(!this._targetHost)if(this.panningDistanceLimit)this._transformedDirection.addInPlace(this._target),m.DistanceSquared(this._transformedDirection,this.panningOriginTarget)<=this.panningDistanceLimit*this.panningDistanceLimit&&this._target.copyFrom(this._transformedDirection);else{if(this.parent){const t=V.Matrix[0];this.parent.getWorldMatrix().getRotationMatrixToRef(t),t.transposeToRef(t),m.TransformCoordinatesToRef(this._transformedDirection,t,this._transformedDirection)}this._target.addInPlace(this._transformedDirection)}this.inertialPanningX*=this.panningInertia,this.inertialPanningY*=this.panningInertia,Math.abs(this.inertialPanningX)<this.speed*He&&(this.inertialPanningX=0),Math.abs(this.inertialPanningY)<this.speed*He&&(this.inertialPanningY=0)}this._checkLimits(),super._checkInputs()}}_checkLimits(){this.lowerBetaLimit===null||this.lowerBetaLimit===void 0?this.allowUpsideDown&&this.beta>Math.PI&&(this.beta=this.beta-2*Math.PI):this.beta<this.lowerBetaLimit&&(this.beta=this.lowerBetaLimit),this.upperBetaLimit===null||this.upperBetaLimit===void 0?this.allowUpsideDown&&this.beta<-Math.PI&&(this.beta=this.beta+2*Math.PI):this.beta>this.upperBetaLimit&&(this.beta=this.upperBetaLimit),this.lowerAlphaLimit!==null&&this.alpha<this.lowerAlphaLimit&&(this.alpha=this.lowerAlphaLimit),this.upperAlphaLimit!==null&&this.alpha>this.upperAlphaLimit&&(this.alpha=this.upperAlphaLimit),this.lowerRadiusLimit!==null&&this.radius<this.lowerRadiusLimit&&(this.radius=this.lowerRadiusLimit,this.inertialRadiusOffset=0),this.upperRadiusLimit!==null&&this.radius>this.upperRadiusLimit&&(this.radius=this.upperRadiusLimit,this.inertialRadiusOffset=0),this.target.y=Math.max(this.target.y,this.lowerTargetYLimit)}rebuildAnglesAndRadius(){this._position.subtractToRef(this._getTargetPosition(),this._computationVector),(this._upVector.x!==0||this._upVector.y!==1||this._upVector.z!==0)&&m.TransformCoordinatesToRef(this._computationVector,this._upToYMatrix,this._computationVector),this.radius=this._computationVector.length(),this.radius===0&&(this.radius=1e-4);const e=this.alpha;this.alpha=XA(this._computationVector),this.beta=ZA(this._computationVector.y,this.radius);const t=Math.round((e-this.alpha)/(2*Math.PI));this.alpha+=t*2*Math.PI,this._checkLimits()}setPosition(e){this._position.equals(e)||(this._position.copyFrom(e),this.rebuildAnglesAndRadius())}setTarget(e,t=!1,i=!1,r=!1){if(r=this.overrideCloneAlphaBetaRadius??r,e.computeWorldMatrix)t&&e.getBoundingInfo?this._targetBoundingCenter=e.getBoundingInfo().boundingBox.centerWorld.clone():this._targetBoundingCenter=null,e.computeWorldMatrix(),this._targetHost=e,this._target=this._getTargetPosition(),this.onMeshTargetChangedObservable.notifyObservers(this._targetHost);else{const s=e,n=this._getTargetPosition();if(n&&!i&&n.equals(s))return;this._targetHost=null,this._target=s,this._targetBoundingCenter=null,this.onMeshTargetChangedObservable.notifyObservers(null)}r||this.rebuildAnglesAndRadius()}_getViewMatrix(){const e=Math.cos(this.alpha),t=Math.sin(this.alpha),i=Math.cos(this.beta);let r=Math.sin(this.beta);r===0&&(r=1e-4),this.radius===0&&(this.radius=1e-4);const s=this._getTargetPosition();if(this._computationVector.copyFromFloats(this.radius*e*r,this.radius*i,this.radius*t*r),(this._upVector.x!==0||this._upVector.y!==1||this._upVector.z!==0)&&m.TransformCoordinatesToRef(this._computationVector,this._yToUpMatrix,this._computationVector),s.addToRef(this._computationVector,this._newPosition),this.getScene().collisionsEnabled&&this.checkCollisions){const n=this.getScene().collisionCoordinator;this._collider||(this._collider=n.createCollider()),this._collider._radius=this.collisionRadius,this._newPosition.subtractToRef(this._position,this._collisionVelocity),this._collisionTriggered=!0,n.getNewPosition(this._position,this._collisionVelocity,this._collider,3,null,this._onCollisionPositionChange,this.uniqueId)}else{this._position.copyFrom(this._newPosition);let n=this.upVector;this.allowUpsideDown&&r<0&&(n=n.negate()),this._computeViewMatrix(this._position,s,n),this._viewMatrix.addAtIndex(12,this.targetScreenOffset.x),this._viewMatrix.addAtIndex(13,this.targetScreenOffset.y)}return this._currentTarget=s,this._viewMatrix}zoomOn(e,t=!1){e=e||this.getScene().meshes;const i=z.MinMax(e);let r=this._calculateLowerRadiusFromModelBoundingSphere(i.min,i.max);r=Math.max(Math.min(r,this.upperRadiusLimit||Number.MAX_VALUE),this.lowerRadiusLimit||0),this.radius=r*this.zoomOnFactor,this.focusOn({min:i.min,max:i.max,distance:r},t)}focusOn(e,t=!1){let i,r;if(e.min===void 0){const s=e||this.getScene().meshes;i=z.MinMax(s),r=m.Distance(i.min,i.max)}else{const s=e;i=s,r=s.distance}this._target=z.Center(i),t||(this.maxZ=r*2)}createRigCamera(e,t){let i=0;switch(this.cameraRigMode){case Ze.RIG_MODE_STEREOSCOPIC_ANAGLYPH:case Ze.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:case Ze.RIG_MODE_STEREOSCOPIC_OVERUNDER:case Ze.RIG_MODE_STEREOSCOPIC_INTERLACED:case Ze.RIG_MODE_VR:i=this._cameraRigParams.stereoHalfAngle*(t===0?1:-1);break;case Ze.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:i=this._cameraRigParams.stereoHalfAngle*(t===0?-1:1);break}const r=new lt(e,this.alpha+i,this.beta,this.radius,this._target,this.getScene());return r._cameraRigParams={},r.isRigCamera=!0,r.rigParent=this,r.upVector=this.upVector,r.mode=this.mode,r.orthoLeft=this.orthoLeft,r.orthoRight=this.orthoRight,r.orthoBottom=this.orthoBottom,r.orthoTop=this.orthoTop,r}_updateRigCameras(){const e=this._rigCameras[0],t=this._rigCameras[1];switch(e.beta=t.beta=this.beta,this.cameraRigMode){case Ze.RIG_MODE_STEREOSCOPIC_ANAGLYPH:case Ze.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:case Ze.RIG_MODE_STEREOSCOPIC_OVERUNDER:case Ze.RIG_MODE_STEREOSCOPIC_INTERLACED:case Ze.RIG_MODE_VR:e.alpha=this.alpha-this._cameraRigParams.stereoHalfAngle,t.alpha=this.alpha+this._cameraRigParams.stereoHalfAngle;break;case Ze.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:e.alpha=this.alpha+this._cameraRigParams.stereoHalfAngle,t.alpha=this.alpha-this._cameraRigParams.stereoHalfAngle;break}super._updateRigCameras()}_calculateLowerRadiusFromModelBoundingSphere(e,t,i=1){const r=m.Distance(e,t),n=this.getScene().getEngine().getAspectRatio(this),o=Math.tan(this.fov/2),l=o*n,c=r*.5*i,h=c*Math.sqrt(1+1/(l*l)),d=c*Math.sqrt(1+1/(o*o));return Math.max(h,d)}dispose(){this.inputs.clear(),super.dispose()}getClassName(){return"ArcRotateCamera"}}C([F()],lt.prototype,"alpha",void 0);C([F()],lt.prototype,"beta",void 0);C([F()],lt.prototype,"radius",void 0);C([F()],lt.prototype,"overrideCloneAlphaBetaRadius",void 0);C([Hn("target")],lt.prototype,"_target",void 0);C([cu("targetHost")],lt.prototype,"_targetHost",void 0);C([F()],lt.prototype,"inertialAlphaOffset",void 0);C([F()],lt.prototype,"inertialBetaOffset",void 0);C([F()],lt.prototype,"inertialRadiusOffset",void 0);C([F()],lt.prototype,"lowerAlphaLimit",void 0);C([F()],lt.prototype,"upperAlphaLimit",void 0);C([F()],lt.prototype,"lowerBetaLimit",void 0);C([F()],lt.prototype,"upperBetaLimit",void 0);C([F()],lt.prototype,"lowerRadiusLimit",void 0);C([F()],lt.prototype,"upperRadiusLimit",void 0);C([F()],lt.prototype,"lowerTargetYLimit",void 0);C([F()],lt.prototype,"inertialPanningX",void 0);C([F()],lt.prototype,"inertialPanningY",void 0);C([F()],lt.prototype,"pinchToPanMaxDistance",void 0);C([F()],lt.prototype,"panningDistanceLimit",void 0);C([Hn()],lt.prototype,"panningOriginTarget",void 0);C([F()],lt.prototype,"panningInertia",void 0);C([F()],lt.prototype,"zoomToMouseLocation",null);C([F()],lt.prototype,"zoomOnFactor",void 0);C([qb()],lt.prototype,"targetScreenOffset",void 0);C([F()],lt.prototype,"allowUpsideDown",void 0);C([F()],lt.prototype,"useInputToRestoreState",void 0);C([F()],lt.prototype,"restoreStateInterpolationFactor",void 0);B("BABYLON.ArcRotateCamera",lt);li.AddNodeConstructor("DeviceOrientationCamera",(a,e)=>()=>new Km(a,m.Zero(),e));class Km extends Ms{constructor(e,t,i){super(e,t,i),this._tmpDragQuaternion=new re,this._disablePointerInputWhenUsingDeviceOrientation=!0,this._dragFactor=0,this._quaternionCache=new re,this.inputs.addDeviceOrientation(),this.inputs._deviceOrientationInput&&this.inputs._deviceOrientationInput._onDeviceOrientationChangedObservable.addOnce(()=>{this._disablePointerInputWhenUsingDeviceOrientation&&this.inputs._mouseInput&&(this.inputs._mouseInput._allowCameraRotation=!1,this.inputs._mouseInput.onPointerMovedObservable.add(r=>{this._dragFactor!=0&&(this._initialQuaternion||(this._initialQuaternion=new re),re.FromEulerAnglesToRef(0,r.offsetX*this._dragFactor,0,this._tmpDragQuaternion),this._initialQuaternion.multiplyToRef(this._tmpDragQuaternion,this._initialQuaternion))}))})}get disablePointerInputWhenUsingDeviceOrientation(){return this._disablePointerInputWhenUsingDeviceOrientation}set disablePointerInputWhenUsingDeviceOrientation(e){this._disablePointerInputWhenUsingDeviceOrientation=e}enableHorizontalDragging(e=1/300){this._dragFactor=e}getClassName(){return"DeviceOrientationCamera"}_checkInputs(){super._checkInputs(),this._quaternionCache.copyFrom(this.rotationQuaternion),this._initialQuaternion&&this._initialQuaternion.multiplyToRef(this.rotationQuaternion,this.rotationQuaternion)}resetToCurrentRotation(e=qi.Y){this.rotationQuaternion&&(this._initialQuaternion||(this._initialQuaternion=new re),this._initialQuaternion.copyFrom(this._quaternionCache||this.rotationQuaternion),["x","y","z"].forEach(t=>{e[t]?this._initialQuaternion[t]*=-1:this._initialQuaternion[t]=0}),this._initialQuaternion.normalize(),this._initialQuaternion.multiplyToRef(this.rotationQuaternion,this.rotationQuaternion))}}class qA extends Am{constructor(e){super(e)}addKeyboard(){return this.add(new xn),this}addMouse(){return this.add(new Cu),this}}class nl extends Xa{get angularSensibility(){const e=this.inputs.attached.mouse;return e?e.angularSensibility:0}set angularSensibility(e){const t=this.inputs.attached.mouse;t&&(t.angularSensibility=e)}get keysForward(){const e=this.inputs.attached.keyboard;return e?e.keysForward:[]}set keysForward(e){const t=this.inputs.attached.keyboard;t&&(t.keysForward=e)}get keysBackward(){const e=this.inputs.attached.keyboard;return e?e.keysBackward:[]}set keysBackward(e){const t=this.inputs.attached.keyboard;t&&(t.keysBackward=e)}get keysUp(){const e=this.inputs.attached.keyboard;return e?e.keysUp:[]}set keysUp(e){const t=this.inputs.attached.keyboard;t&&(t.keysUp=e)}get keysDown(){const e=this.inputs.attached.keyboard;return e?e.keysDown:[]}set keysDown(e){const t=this.inputs.attached.keyboard;t&&(t.keysDown=e)}get keysLeft(){const e=this.inputs.attached.keyboard;return e?e.keysLeft:[]}set keysLeft(e){const t=this.inputs.attached.keyboard;t&&(t.keysLeft=e)}get keysRight(){const e=this.inputs.attached.keyboard;return e?e.keysRight:[]}set keysRight(e){const t=this.inputs.attached.keyboard;t&&(t.keysRight=e)}constructor(e,t,i,r=!0){super(e,t,i,r),this.ellipsoid=new m(1,1,1),this.ellipsoidOffset=new m(0,0,0),this.checkCollisions=!1,this.applyGravity=!1,this.cameraDirection=m.Zero(),this._trackRoll=0,this.rollCorrect=100,this.bankedTurn=!1,this.bankedTurnLimit=Math.PI/2,this.bankedTurnMultiplier=1,this._needMoveForGravity=!1,this._oldPosition=m.Zero(),this._diffPosition=m.Zero(),this._newPosition=m.Zero(),this._collisionMask=-1,this._onCollisionPositionChange=(s,n,o=null)=>{(u=>{this._newPosition.copyFrom(u),this._newPosition.subtractToRef(this._oldPosition,this._diffPosition),this._diffPosition.length()>st.CollisionsEpsilon&&(this.position.addInPlace(this._diffPosition),this.onCollide&&o&&this.onCollide(o))})(n)},this.inputs=new qA(this),this.inputs.addKeyboard().addMouse()}attachControl(e,t){t=ae.BackCompatCameraNoPreventDefault(arguments),this.inputs.attachElement(t)}detachControl(){this.inputs.detachElement(),this.cameraDirection=new m(0,0,0)}get collisionMask(){return this._collisionMask}set collisionMask(e){this._collisionMask=isNaN(e)?-1:e}_collideWithWorld(e){let t;this.parent?t=m.TransformCoordinates(this.position,this.parent.getWorldMatrix()):t=this.position,t.subtractFromFloatsToRef(0,this.ellipsoid.y,0,this._oldPosition),this._oldPosition.addInPlace(this.ellipsoidOffset);const i=this.getScene().collisionCoordinator;this._collider||(this._collider=i.createCollider()),this._collider._radius=this.ellipsoid,this._collider.collisionMask=this._collisionMask;let r=e;this.applyGravity&&(r=e.add(this.getScene().gravity)),i.getNewPosition(this._oldPosition,r,this._collider,3,null,this._onCollisionPositionChange,this.uniqueId)}_checkInputs(){this._localDirection||(this._localDirection=m.Zero(),this._transformedDirection=m.Zero()),this.inputs.checkInputs(),super._checkInputs()}set needMoveForGravity(e){this._needMoveForGravity=e}get needMoveForGravity(){return this._needMoveForGravity}_decideIfNeedsToMove(){return this._needMoveForGravity||Math.abs(this.cameraDirection.x)>0||Math.abs(this.cameraDirection.y)>0||Math.abs(this.cameraDirection.z)>0}_updatePosition(){this.checkCollisions&&this.getScene().collisionsEnabled?this._collideWithWorld(this.cameraDirection):super._updatePosition()}restoreRoll(e){const t=this._trackRoll,i=this.rotation.z,r=t-i,s=.001;Math.abs(r)>=s&&(this.rotation.z+=r/e,Math.abs(t-this.rotation.z)<=s&&(this.rotation.z=t))}dispose(){this.inputs.clear(),super.dispose()}getClassName(){return"FlyCamera"}}C([Hn()],nl.prototype,"ellipsoid",void 0);C([Hn()],nl.prototype,"ellipsoidOffset",void 0);C([F()],nl.prototype,"checkCollisions",void 0);C([F()],nl.prototype,"applyGravity",void 0);B("BABYLON.FlyCamera",nl);class QA extends Am{constructor(e){super(e)}addKeyboard(){return this.add(new ui),this}addMouseWheel(){return this.add(new Kn),this}addPointers(){return this.add(new ki),this}addVRDeviceOrientation(){return L.Warn("DeviceOrientation support not yet implemented for FollowCamera."),this}}li.AddNodeConstructor("FollowCamera",(a,e)=>()=>new rr(a,m.Zero(),e));li.AddNodeConstructor("ArcFollowCamera",(a,e)=>()=>new Xy(a,0,0,1,null,e));class rr extends Xa{constructor(e,t,i,r=null){super(e,t,i),this.radius=12,this.lowerRadiusLimit=null,this.upperRadiusLimit=null,this.rotationOffset=0,this.lowerRotationOffsetLimit=null,this.upperRotationOffsetLimit=null,this.heightOffset=4,this.lowerHeightOffsetLimit=null,this.upperHeightOffsetLimit=null,this.cameraAcceleration=.05,this.maxCameraSpeed=20,this.lockedTarget=r,this.inputs=new QA(this),this.inputs.addKeyboard().addMouseWheel().addPointers()}_follow(e){if(!e)return;const t=V.Matrix[0];e.absoluteRotationQuaternion.toRotationMatrix(t);const i=Math.atan2(t.m[8],t.m[10]),r=ae.ToRadians(this.rotationOffset)+i,s=e.getAbsolutePosition(),n=s.x+Math.sin(r)*this.radius,o=s.z+Math.cos(r)*this.radius,l=n-this.position.x,u=s.y+this.heightOffset-this.position.y,c=o-this.position.z;let h=l*this.cameraAcceleration*2,d=u*this.cameraAcceleration,f=c*this.cameraAcceleration*2;(h>this.maxCameraSpeed||h<-this.maxCameraSpeed)&&(h=h<1?-this.maxCameraSpeed:this.maxCameraSpeed),(d>this.maxCameraSpeed||d<-this.maxCameraSpeed)&&(d=d<1?-this.maxCameraSpeed:this.maxCameraSpeed),(f>this.maxCameraSpeed||f<-this.maxCameraSpeed)&&(f=f<1?-this.maxCameraSpeed:this.maxCameraSpeed),this.position=new m(this.position.x+h,this.position.y+d,this.position.z+f),this.setTarget(s)}attachControl(e,t){t=ae.BackCompatCameraNoPreventDefault(arguments),this.inputs.attachElement(t),this._reset=()=>{}}detachControl(){this.inputs.detachElement(),this._reset&&this._reset()}_checkInputs(){this.inputs.checkInputs(),this._checkLimits(),super._checkInputs(),this.lockedTarget&&this._follow(this.lockedTarget)}_checkLimits(){this.lowerRadiusLimit!==null&&this.radius<this.lowerRadiusLimit&&(this.radius=this.lowerRadiusLimit),this.upperRadiusLimit!==null&&this.radius>this.upperRadiusLimit&&(this.radius=this.upperRadiusLimit),this.lowerHeightOffsetLimit!==null&&this.heightOffset<this.lowerHeightOffsetLimit&&(this.heightOffset=this.lowerHeightOffsetLimit),this.upperHeightOffsetLimit!==null&&this.heightOffset>this.upperHeightOffsetLimit&&(this.heightOffset=this.upperHeightOffsetLimit),this.lowerRotationOffsetLimit!==null&&this.rotationOffset<this.lowerRotationOffsetLimit&&(this.rotationOffset=this.lowerRotationOffsetLimit),this.upperRotationOffsetLimit!==null&&this.rotationOffset>this.upperRotationOffsetLimit&&(this.rotationOffset=this.upperRotationOffsetLimit)}getClassName(){return"FollowCamera"}}C([F()],rr.prototype,"radius",void 0);C([F()],rr.prototype,"lowerRadiusLimit",void 0);C([F()],rr.prototype,"upperRadiusLimit",void 0);C([F()],rr.prototype,"rotationOffset",void 0);C([F()],rr.prototype,"lowerRotationOffsetLimit",void 0);C([F()],rr.prototype,"upperRotationOffsetLimit",void 0);C([F()],rr.prototype,"heightOffset",void 0);C([F()],rr.prototype,"lowerHeightOffsetLimit",void 0);C([F()],rr.prototype,"upperHeightOffsetLimit",void 0);C([F()],rr.prototype,"cameraAcceleration",void 0);C([F()],rr.prototype,"maxCameraSpeed",void 0);C([cu("lockedTargetId")],rr.prototype,"lockedTarget",void 0);class Xy extends Xa{constructor(e,t,i,r,s,n){super(e,m.Zero(),n),this.alpha=t,this.beta=i,this.radius=r,this._cartesianCoordinates=m.Zero(),this.setMeshTarget(s)}setMeshTarget(e){this._meshTarget=e,this._follow()}_follow(){if(!this._meshTarget)return;this._cartesianCoordinates.x=this.radius*Math.cos(this.alpha)*Math.cos(this.beta),this._cartesianCoordinates.y=this.radius*Math.sin(this.beta),this._cartesianCoordinates.z=this.radius*Math.sin(this.alpha)*Math.cos(this.beta);const e=this._meshTarget.getAbsolutePosition();this.position=e.add(this._cartesianCoordinates),this.setTarget(e)}_checkInputs(){super._checkInputs(),this._follow()}getClassName(){return"ArcFollowCamera"}}B("BABYLON.FollowCamera",rr);B("BABYLON.ArcFollowCamera",Xy);var Ag;(function(a){a[a.A=0]="A",a[a.B=1]="B",a[a.X=2]="X",a[a.Y=3]="Y",a[a.LB=4]="LB",a[a.RB=5]="RB",a[a.Back=8]="Back",a[a.Start=9]="Start",a[a.LeftStick=10]="LeftStick",a[a.RightStick=11]="RightStick"})(Ag||(Ag={}));var Dg;(function(a){a[a.Up=12]="Up",a[a.Down=13]="Down",a[a.Left=14]="Left",a[a.Right=15]="Right"})(Dg||(Dg={}));class KA extends Jt{constructor(e,t,i,r=!1){super(e,t,i,0,1,2,3),this._leftTrigger=0,this._rightTrigger=0,this.onButtonDownObservable=new j,this.onButtonUpObservable=new j,this.onPadDownObservable=new j,this.onPadUpObservable=new j,this._buttonA=0,this._buttonB=0,this._buttonX=0,this._buttonY=0,this._buttonBack=0,this._buttonStart=0,this._buttonLB=0,this._buttonRB=0,this._buttonLeftStick=0,this._buttonRightStick=0,this._dPadUp=0,this._dPadDown=0,this._dPadLeft=0,this._dPadRight=0,this._isXboxOnePad=!1,this.type=Jt.XBOX,this._isXboxOnePad=r}onlefttriggerchanged(e){this._onlefttriggerchanged=e}onrighttriggerchanged(e){this._onrighttriggerchanged=e}get leftTrigger(){return this._leftTrigger}set leftTrigger(e){this._onlefttriggerchanged&&this._leftTrigger!==e&&this._onlefttriggerchanged(e),this._leftTrigger=e}get rightTrigger(){return this._rightTrigger}set rightTrigger(e){this._onrighttriggerchanged&&this._rightTrigger!==e&&this._onrighttriggerchanged(e),this._rightTrigger=e}onbuttondown(e){this._onbuttondown=e}onbuttonup(e){this._onbuttonup=e}ondpaddown(e){this._ondpaddown=e}ondpadup(e){this._ondpadup=e}_setButtonValue(e,t,i){return e!==t&&(e===1&&(this._onbuttondown&&this._onbuttondown(i),this.onButtonDownObservable.notifyObservers(i)),e===0&&(this._onbuttonup&&this._onbuttonup(i),this.onButtonUpObservable.notifyObservers(i))),e}_setDPadValue(e,t,i){return e!==t&&(e===1&&(this._ondpaddown&&this._ondpaddown(i),this.onPadDownObservable.notifyObservers(i)),e===0&&(this._ondpadup&&this._ondpadup(i),this.onPadUpObservable.notifyObservers(i))),e}get buttonA(){return this._buttonA}set buttonA(e){this._buttonA=this._setButtonValue(e,this._buttonA,0)}get buttonB(){return this._buttonB}set buttonB(e){this._buttonB=this._setButtonValue(e,this._buttonB,1)}get buttonX(){return this._buttonX}set buttonX(e){this._buttonX=this._setButtonValue(e,this._buttonX,2)}get buttonY(){return this._buttonY}set buttonY(e){this._buttonY=this._setButtonValue(e,this._buttonY,3)}get buttonStart(){return this._buttonStart}set buttonStart(e){this._buttonStart=this._setButtonValue(e,this._buttonStart,9)}get buttonBack(){return this._buttonBack}set buttonBack(e){this._buttonBack=this._setButtonValue(e,this._buttonBack,8)}get buttonLB(){return this._buttonLB}set buttonLB(e){this._buttonLB=this._setButtonValue(e,this._buttonLB,4)}get buttonRB(){return this._buttonRB}set buttonRB(e){this._buttonRB=this._setButtonValue(e,this._buttonRB,5)}get buttonLeftStick(){return this._buttonLeftStick}set buttonLeftStick(e){this._buttonLeftStick=this._setButtonValue(e,this._buttonLeftStick,10)}get buttonRightStick(){return this._buttonRightStick}set buttonRightStick(e){this._buttonRightStick=this._setButtonValue(e,this._buttonRightStick,11)}get dPadUp(){return this._dPadUp}set dPadUp(e){this._dPadUp=this._setDPadValue(e,this._dPadUp,12)}get dPadDown(){return this._dPadDown}set dPadDown(e){this._dPadDown=this._setDPadValue(e,this._dPadDown,13)}get dPadLeft(){return this._dPadLeft}set dPadLeft(e){this._dPadLeft=this._setDPadValue(e,this._dPadLeft,14)}get dPadRight(){return this._dPadRight}set dPadRight(e){this._dPadRight=this._setDPadValue(e,this._dPadRight,15)}update(){super.update(),this._isXboxOnePad?(this.buttonA=this.browserGamepad.buttons[0].value,this.buttonB=this.browserGamepad.buttons[1].value,this.buttonX=this.browserGamepad.buttons[2].value,this.buttonY=this.browserGamepad.buttons[3].value,this.buttonLB=this.browserGamepad.buttons[4].value,this.buttonRB=this.browserGamepad.buttons[5].value,this.leftTrigger=this.browserGamepad.buttons[6].value,this.rightTrigger=this.browserGamepad.buttons[7].value,this.buttonBack=this.browserGamepad.buttons[8].value,this.buttonStart=this.browserGamepad.buttons[9].value,this.buttonLeftStick=this.browserGamepad.buttons[10].value,this.buttonRightStick=this.browserGamepad.buttons[11].value,this.dPadUp=this.browserGamepad.buttons[12].value,this.dPadDown=this.browserGamepad.buttons[13].value,this.dPadLeft=this.browserGamepad.buttons[14].value,this.dPadRight=this.browserGamepad.buttons[15].value):(this.buttonA=this.browserGamepad.buttons[0].value,this.buttonB=this.browserGamepad.buttons[1].value,this.buttonX=this.browserGamepad.buttons[2].value,this.buttonY=this.browserGamepad.buttons[3].value,this.buttonLB=this.browserGamepad.buttons[4].value,this.buttonRB=this.browserGamepad.buttons[5].value,this.leftTrigger=this.browserGamepad.buttons[6].value,this.rightTrigger=this.browserGamepad.buttons[7].value,this.buttonBack=this.browserGamepad.buttons[8].value,this.buttonStart=this.browserGamepad.buttons[9].value,this.buttonLeftStick=this.browserGamepad.buttons[10].value,this.buttonRightStick=this.browserGamepad.buttons[11].value,this.dPadUp=this.browserGamepad.buttons[12].value,this.dPadDown=this.browserGamepad.buttons[13].value,this.dPadLeft=this.browserGamepad.buttons[14].value,this.dPadRight=this.browserGamepad.buttons[15].value)}dispose(){super.dispose(),this.onButtonDownObservable.clear(),this.onButtonUpObservable.clear(),this.onPadDownObservable.clear(),this.onPadUpObservable.clear()}}var Og;(function(a){a[a.Cross=0]="Cross",a[a.Circle=1]="Circle",a[a.Square=2]="Square",a[a.Triangle=3]="Triangle",a[a.L1=4]="L1",a[a.R1=5]="R1",a[a.Share=8]="Share",a[a.Options=9]="Options",a[a.LeftStick=10]="LeftStick",a[a.RightStick=11]="RightStick"})(Og||(Og={}));var wg;(function(a){a[a.Up=12]="Up",a[a.Down=13]="Down",a[a.Left=14]="Left",a[a.Right=15]="Right"})(wg||(wg={}));class JA extends Jt{constructor(e,t,i){super(e.replace("STANDARD GAMEPAD","SONY PLAYSTATION DUALSHOCK"),t,i,0,1,2,3),this._leftTrigger=0,this._rightTrigger=0,this.onButtonDownObservable=new j,this.onButtonUpObservable=new j,this.onPadDownObservable=new j,this.onPadUpObservable=new j,this._buttonCross=0,this._buttonCircle=0,this._buttonSquare=0,this._buttonTriangle=0,this._buttonShare=0,this._buttonOptions=0,this._buttonL1=0,this._buttonR1=0,this._buttonLeftStick=0,this._buttonRightStick=0,this._dPadUp=0,this._dPadDown=0,this._dPadLeft=0,this._dPadRight=0,this.type=Jt.DUALSHOCK}onlefttriggerchanged(e){this._onlefttriggerchanged=e}onrighttriggerchanged(e){this._onrighttriggerchanged=e}get leftTrigger(){return this._leftTrigger}set leftTrigger(e){this._onlefttriggerchanged&&this._leftTrigger!==e&&this._onlefttriggerchanged(e),this._leftTrigger=e}get rightTrigger(){return this._rightTrigger}set rightTrigger(e){this._onrighttriggerchanged&&this._rightTrigger!==e&&this._onrighttriggerchanged(e),this._rightTrigger=e}onbuttondown(e){this._onbuttondown=e}onbuttonup(e){this._onbuttonup=e}ondpaddown(e){this._ondpaddown=e}ondpadup(e){this._ondpadup=e}_setButtonValue(e,t,i){return e!==t&&(e===1&&(this._onbuttondown&&this._onbuttondown(i),this.onButtonDownObservable.notifyObservers(i)),e===0&&(this._onbuttonup&&this._onbuttonup(i),this.onButtonUpObservable.notifyObservers(i))),e}_setDPadValue(e,t,i){return e!==t&&(e===1&&(this._ondpaddown&&this._ondpaddown(i),this.onPadDownObservable.notifyObservers(i)),e===0&&(this._ondpadup&&this._ondpadup(i),this.onPadUpObservable.notifyObservers(i))),e}get buttonCross(){return this._buttonCross}set buttonCross(e){this._buttonCross=this._setButtonValue(e,this._buttonCross,0)}get buttonCircle(){return this._buttonCircle}set buttonCircle(e){this._buttonCircle=this._setButtonValue(e,this._buttonCircle,1)}get buttonSquare(){return this._buttonSquare}set buttonSquare(e){this._buttonSquare=this._setButtonValue(e,this._buttonSquare,2)}get buttonTriangle(){return this._buttonTriangle}set buttonTriangle(e){this._buttonTriangle=this._setButtonValue(e,this._buttonTriangle,3)}get buttonOptions(){return this._buttonOptions}set buttonOptions(e){this._buttonOptions=this._setButtonValue(e,this._buttonOptions,9)}get buttonShare(){return this._buttonShare}set buttonShare(e){this._buttonShare=this._setButtonValue(e,this._buttonShare,8)}get buttonL1(){return this._buttonL1}set buttonL1(e){this._buttonL1=this._setButtonValue(e,this._buttonL1,4)}get buttonR1(){return this._buttonR1}set buttonR1(e){this._buttonR1=this._setButtonValue(e,this._buttonR1,5)}get buttonLeftStick(){return this._buttonLeftStick}set buttonLeftStick(e){this._buttonLeftStick=this._setButtonValue(e,this._buttonLeftStick,10)}get buttonRightStick(){return this._buttonRightStick}set buttonRightStick(e){this._buttonRightStick=this._setButtonValue(e,this._buttonRightStick,11)}get dPadUp(){return this._dPadUp}set dPadUp(e){this._dPadUp=this._setDPadValue(e,this._dPadUp,12)}get dPadDown(){return this._dPadDown}set dPadDown(e){this._dPadDown=this._setDPadValue(e,this._dPadDown,13)}get dPadLeft(){return this._dPadLeft}set dPadLeft(e){this._dPadLeft=this._setDPadValue(e,this._dPadLeft,14)}get dPadRight(){return this._dPadRight}set dPadRight(e){this._dPadRight=this._setDPadValue(e,this._dPadRight,15)}update(){super.update(),this.buttonCross=this.browserGamepad.buttons[0].value,this.buttonCircle=this.browserGamepad.buttons[1].value,this.buttonSquare=this.browserGamepad.buttons[2].value,this.buttonTriangle=this.browserGamepad.buttons[3].value,this.buttonL1=this.browserGamepad.buttons[4].value,this.buttonR1=this.browserGamepad.buttons[5].value,this.leftTrigger=this.browserGamepad.buttons[6].value,this.rightTrigger=this.browserGamepad.buttons[7].value,this.buttonShare=this.browserGamepad.buttons[8].value,this.buttonOptions=this.browserGamepad.buttons[9].value,this.buttonLeftStick=this.browserGamepad.buttons[10].value,this.buttonRightStick=this.browserGamepad.buttons[11].value,this.dPadUp=this.browserGamepad.buttons[12].value,this.dPadDown=this.browserGamepad.buttons[13].value,this.dPadLeft=this.browserGamepad.buttons[14].value,this.dPadRight=this.browserGamepad.buttons[15].value}dispose(){super.dispose(),this.onButtonDownObservable.clear(),this.onButtonUpObservable.clear(),this.onPadDownObservable.clear(),this.onPadUpObservable.clear()}}class eD{constructor(e){if(this._scene=e,this._babylonGamepads=[],this._oneGamepadConnected=!1,this._isMonitoring=!1,this.onGamepadDisconnectedObservable=new j,Om()?(this._gamepadEventSupported="GamepadEvent"in window,this._gamepadSupport=navigator&&navigator.getGamepads):this._gamepadEventSupported=!1,this.onGamepadConnectedObservable=new j(t=>{for(const i in this._babylonGamepads){const r=this._babylonGamepads[i];r&&r._isConnected&&this.onGamepadConnectedObservable.notifyObserver(t,r)}}),this._onGamepadConnectedEvent=t=>{const i=t.gamepad;if(i.index in this._babylonGamepads&&this._babylonGamepads[i.index].isConnected)return;let r;this._babylonGamepads[i.index]?(r=this._babylonGamepads[i.index],r.browserGamepad=i,r._isConnected=!0):r=this._addNewGamepad(i),this.onGamepadConnectedObservable.notifyObservers(r),this._startMonitoringGamepads()},this._onGamepadDisconnectedEvent=t=>{const i=t.gamepad;for(const r in this._babylonGamepads)if(this._babylonGamepads[r].index===i.index){const s=this._babylonGamepads[r];s._isConnected=!1,this.onGamepadDisconnectedObservable.notifyObservers(s),s.dispose&&s.dispose();break}},this._gamepadSupport)if(this._updateGamepadObjects(),this._babylonGamepads.length&&this._startMonitoringGamepads(),this._gamepadEventSupported){const t=this._scene?this._scene.getEngine().getHostWindow():window;t&&(t.addEventListener("gamepadconnected",this._onGamepadConnectedEvent,!1),t.addEventListener("gamepaddisconnected",this._onGamepadDisconnectedEvent,!1))}else this._startMonitoringGamepads()}get gamepads(){return this._babylonGamepads}getGamepadByType(e=Jt.XBOX){for(const t of this._babylonGamepads)if(t&&t.type===e)return t;return null}dispose(){this._gamepadEventSupported&&(this._onGamepadConnectedEvent&&window.removeEventListener("gamepadconnected",this._onGamepadConnectedEvent),this._onGamepadDisconnectedEvent&&window.removeEventListener("gamepaddisconnected",this._onGamepadDisconnectedEvent),this._onGamepadConnectedEvent=null,this._onGamepadDisconnectedEvent=null),this._babylonGamepads.forEach(e=>{e.dispose()}),this.onGamepadConnectedObservable.clear(),this.onGamepadDisconnectedObservable.clear(),this._oneGamepadConnected=!1,this._stopMonitoringGamepads(),this._babylonGamepads=[]}_addNewGamepad(e){this._oneGamepadConnected||(this._oneGamepadConnected=!0);let t;const i=e.id.search("054c")!==-1&&e.id.search("0ce6")===-1,r=e.id.search("Xbox One")!==-1;return r||e.id.search("Xbox 360")!==-1||e.id.search("xinput")!==-1||e.id.search("045e")!==-1&&e.id.search("Surface Dock")===-1?t=new KA(e.id,e.index,e,r):i?t=new JA(e.id,e.index,e):t=new jA(e.id,e.index,e),this._babylonGamepads[t.index]=t,t}_startMonitoringGamepads(){this._isMonitoring||(this._isMonitoring=!0,this._checkGamepadsStatus())}_stopMonitoringGamepads(){this._isMonitoring=!1}_checkGamepadsStatus(){this._updateGamepadObjects();for(const e in this._babylonGamepads){const t=this._babylonGamepads[e];if(!(!t||!t.isConnected))try{t.update()}catch{this._loggedErrors.indexOf(t.index)===-1&&(ae.Warn(`Error updating gamepad ${t.id}`),this._loggedErrors.push(t.index))}}this._isMonitoring&&st.QueueNewFrame(()=>{this._checkGamepadsStatus()})}_updateGamepadObjects(){const e=navigator.getGamepads?navigator.getGamepads():[];for(let t=0;t<e.length;t++){const i=e[t];if(i)if(this._babylonGamepads[i.index])this._babylonGamepads[t].browserGamepad=i,this._babylonGamepads[t].isConnected||(this._babylonGamepads[t]._isConnected=!0,this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[t]));else{const r=this._addNewGamepad(i);this.onGamepadConnectedObservable.notifyObservers(r)}}}}Object.defineProperty(Te.prototype,"gamepadManager",{get:function(){if(!this._gamepadManager){this._gamepadManager=new eD(this);let a=this._getComponent(ge.NAME_GAMEPAD);a||(a=new tD(this),this._addComponent(a))}return this._gamepadManager},enumerable:!0,configurable:!0});Dm.prototype.addGamepad=function(){return this.add(new Pu),this};Qm.prototype.addGamepad=function(){return this.add(new Tu),this};class tD{constructor(e){this.name=ge.NAME_GAMEPAD,this.scene=e}register(){}rebuild(){}dispose(){const e=this.scene._gamepadManager;e&&(e.dispose(),this.scene._gamepadManager=null)}}li.AddNodeConstructor("FreeCamera",(a,e)=>()=>new Ka(a,m.Zero(),e));class Ka extends Yy{get gamepadAngularSensibility(){const e=this.inputs.attached.gamepad;return e?e.gamepadAngularSensibility:0}set gamepadAngularSensibility(e){const t=this.inputs.attached.gamepad;t&&(t.gamepadAngularSensibility=e)}get gamepadMoveSensibility(){const e=this.inputs.attached.gamepad;return e?e.gamepadMoveSensibility:0}set gamepadMoveSensibility(e){const t=this.inputs.attached.gamepad;t&&(t.gamepadMoveSensibility=e)}constructor(e,t,i){super(e,t,i),this.inputs.addGamepad()}getClassName(){return"UniversalCamera"}}Ze._CreateDefaultParsedCamera=(a,e)=>new Ka(a,m.Zero(),e);li.AddNodeConstructor("GamepadCamera",(a,e)=>()=>new Jm(a,m.Zero(),e));class Jm extends Ka{constructor(e,t,i){super(e,t,i)}getClassName(){return"GamepadCamera"}}class ns extends Qt{_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(k(()=>Promise.resolve().then(()=>Ck),void 0))):t.push(k(()=>Promise.resolve().then(()=>yk),void 0))}constructor(e,t=null,i){super({...i,name:e,engine:t||mt.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:ns.FragmentUrl,samplers:ns.Samplers})}}ns.FragmentUrl="anaglyph";ns.Samplers=["leftSampler"];class Zy extends Ce{getClassName(){return"AnaglyphPostProcess"}constructor(e,t,i,r,s,n){const o={samplers:ns.Samplers,size:typeof t=="number"?t:void 0,camera:i[1],samplingMode:r,engine:s,reusable:n,...t};super(e,ns.FragmentUrl,{effectWrapper:typeof t=="number"||!t.effectWrapper?new ns(e,s,o):void 0,...o}),this._passedProcess=i[0]._rigPostProcess,this.onApplyObservable.add(l=>{l.setTextureFromPostProcess("leftSampler",this._passedProcess)})}}B("BABYLON.AnaglyphPostProcess",Zy);function Eu(a){a._rigCameras[0]._rigPostProcess=new Za(a.name+"_passthru",1,a._rigCameras[0]),a._rigCameras[1]._rigPostProcess=new Zy(a.name+"_anaglyph",1,a._rigCameras)}li.AddNodeConstructor("AnaglyphArcRotateCamera",(a,e,t)=>()=>new iD(a,0,0,1,m.Zero(),t.interaxial_distance,e));class iD extends lt{constructor(e,t,i,r,s,n,o){super(e,t,i,r,s,o),this._setRigMode=()=>Eu(this),this.interaxialDistance=n,this.setCameraRigMode(Ze.RIG_MODE_STEREOSCOPIC_ANAGLYPH,{interaxialDistance:n})}getClassName(){return"AnaglyphArcRotateCamera"}}li.AddNodeConstructor("AnaglyphFreeCamera",(a,e,t)=>()=>new rD(a,m.Zero(),t.interaxial_distance,e));class rD extends Ms{constructor(e,t,i,r){super(e,t,r),this._setRigMode=()=>Eu(this),this.interaxialDistance=i,this.setCameraRigMode(Ze.RIG_MODE_STEREOSCOPIC_ANAGLYPH,{interaxialDistance:i})}getClassName(){return"AnaglyphFreeCamera"}}li.AddNodeConstructor("AnaglyphGamepadCamera",(a,e,t)=>()=>new sD(a,m.Zero(),t.interaxial_distance,e));class sD extends Jm{constructor(e,t,i,r){super(e,t,r),this._setRigMode=()=>Eu(this),this.interaxialDistance=i,this.setCameraRigMode(Ze.RIG_MODE_STEREOSCOPIC_ANAGLYPH,{interaxialDistance:i})}getClassName(){return"AnaglyphGamepadCamera"}}li.AddNodeConstructor("AnaglyphUniversalCamera",(a,e,t)=>()=>new nD(a,m.Zero(),t.interaxial_distance,e));class nD extends Ka{constructor(e,t,i,r){super(e,t,r),this._setRigMode=()=>Eu(this),this.interaxialDistance=i,this.setCameraRigMode(Ze.RIG_MODE_STEREOSCOPIC_ANAGLYPH,{interaxialDistance:i})}getClassName(){return"AnaglyphUniversalCamera"}}const Ng="stereoscopicInterlacePixelShader",aD=`const vec3 TWO=vec3(2.0,2.0,2.0);varying vec2 vUV;uniform sampler2D camASampler;uniform sampler2D textureSampler;uniform vec2 stepSize;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{bool useCamA;bool useCamB;vec2 texCoord1;vec2 texCoord2;vec3 frag1;vec3 frag2;
#ifdef IS_STEREOSCOPIC_HORIZ
useCamB=vUV.x>0.5;useCamA=!useCamB;texCoord1=vec2(useCamB ? (vUV.x-0.5)*2.0 : vUV.x*2.0,vUV.y);texCoord2=vec2(texCoord1.x+stepSize.x,vUV.y);
#else
#ifdef IS_STEREOSCOPIC_INTERLACED
float rowNum=floor(vUV.y/stepSize.y);useCamA=mod(rowNum,2.0)==1.0;useCamB=mod(rowNum,2.0)==0.0;texCoord1=vec2(vUV.x,vUV.y);texCoord2=vec2(vUV.x,vUV.y);
#else
useCamB=vUV.y>0.5;useCamA=!useCamB;texCoord1=vec2(vUV.x,useCamB ? (vUV.y-0.5)*2.0 : vUV.y*2.0);texCoord2=vec2(vUV.x,texCoord1.y+stepSize.y);
#endif
#endif
if (useCamB){frag1=texture2D(textureSampler,texCoord1).rgb;frag2=texture2D(textureSampler,texCoord2).rgb;}else if (useCamA){frag1=texture2D(camASampler ,texCoord1).rgb;frag2=texture2D(camASampler ,texCoord2).rgb;}else {discard;}
gl_FragColor=vec4((frag1+frag2)/TWO,1.0);}
`;P.ShadersStore[Ng]||(P.ShadersStore[Ng]=aD);class oD extends Ce{getClassName(){return"StereoscopicInterlacePostProcessI"}constructor(e,t,i,r,s,n,o){super(e,"stereoscopicInterlace",["stepSize"],["camASampler"],1,t[1],s,n,o,r?"#define IS_STEREOSCOPIC_INTERLACED 1":i?"#define IS_STEREOSCOPIC_HORIZ 1":void 0),this._passedProcess=t[0]._rigPostProcess,this._stepSize=new Q(1/this.width,1/this.height),this.onSizeChangedObservable.add(()=>{this._stepSize=new Q(1/this.width,1/this.height)}),this.onApplyObservable.add(l=>{l.setTextureFromPostProcess("camASampler",this._passedProcess),l.setFloat2("stepSize",this._stepSize.x,this._stepSize.y)})}}class rW extends Ce{getClassName(){return"StereoscopicInterlacePostProcess"}constructor(e,t,i,r,s,n){super(e,"stereoscopicInterlace",["stepSize"],["camASampler"],1,t[1],r,s,n,i?"#define IS_STEREOSCOPIC_HORIZ 1":void 0),this._passedProcess=t[0]._rigPostProcess,this._stepSize=new Q(1/this.width,1/this.height),this.onSizeChangedObservable.add(()=>{this._stepSize=new Q(1/this.width,1/this.height)}),this.onApplyObservable.add(o=>{o.setTextureFromPostProcess("camASampler",this._passedProcess),o.setFloat2("stepSize",this._stepSize.x,this._stepSize.y)})}}function Iu(a){const e=a.cameraRigMode===Ze.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL||a.cameraRigMode===Ze.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED,t=a.cameraRigMode===Ze.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;a.cameraRigMode===Ze.RIG_MODE_STEREOSCOPIC_INTERLACED?(a._rigCameras[0]._rigPostProcess=new Za(a.name+"_passthru",1,a._rigCameras[0]),a._rigCameras[1]._rigPostProcess=new oD(a.name+"_stereoInterlace",a._rigCameras,!1,!0)):(a._rigCameras[t?1:0].viewport=new pn(0,0,e?.5:1,e?1:.5),a._rigCameras[t?0:1].viewport=new pn(e?.5:0,e?0:.5,e?.5:1,e?1:.5))}li.AddNodeConstructor("StereoscopicArcRotateCamera",(a,e,t)=>()=>new lD(a,0,0,1,m.Zero(),t.interaxial_distance,t.isStereoscopicSideBySide,e));class lD extends lt{constructor(e,t,i,r,s,n,o,l){super(e,t,i,r,s,l),this._setRigMode=()=>Iu(this),this.interaxialDistance=n,this.isStereoscopicSideBySide=o,this.setCameraRigMode(o?Ze.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:Ze.RIG_MODE_STEREOSCOPIC_OVERUNDER,{interaxialDistance:n})}getClassName(){return"StereoscopicArcRotateCamera"}}li.AddNodeConstructor("StereoscopicFreeCamera",(a,e,t)=>()=>new uD(a,m.Zero(),t.interaxial_distance,t.isStereoscopicSideBySide,e));class uD extends Ms{constructor(e,t,i,r,s){super(e,t,s),this._setRigMode=()=>Iu(this),this.interaxialDistance=i,this.isStereoscopicSideBySide=r,this.setCameraRigMode(r?Ze.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:Ze.RIG_MODE_STEREOSCOPIC_OVERUNDER,{interaxialDistance:i})}getClassName(){return"StereoscopicFreeCamera"}}li.AddNodeConstructor("StereoscopicGamepadCamera",(a,e,t)=>()=>new cD(a,m.Zero(),t.interaxial_distance,t.isStereoscopicSideBySide,e));class cD extends Jm{constructor(e,t,i,r,s){super(e,t,s),this._setRigMode=()=>Iu(this),this.interaxialDistance=i,this.isStereoscopicSideBySide=r,this.setCameraRigMode(r?Ze.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:Ze.RIG_MODE_STEREOSCOPIC_OVERUNDER,{interaxialDistance:i})}getClassName(){return"StereoscopicGamepadCamera"}}li.AddNodeConstructor("StereoscopicFreeCamera",(a,e,t)=>()=>new hD(a,m.Zero(),t.interaxial_distance,t.isStereoscopicSideBySide,e));class hD extends Ka{constructor(e,t,i,r,s){super(e,t,s),this._setRigMode=()=>Iu(this),this.interaxialDistance=i,this.isStereoscopicSideBySide=r,this.setCameraRigMode(r?Ze.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:Ze.RIG_MODE_STEREOSCOPIC_OVERUNDER,{interaxialDistance:i})}getClassName(){return"StereoscopicUniversalCamera"}}li.AddNodeConstructor("VirtualJoysticksCamera",(a,e)=>()=>new dD(a,m.Zero(),e));class dD extends Ms{constructor(e,t,i){super(e,t,i),this.inputs.addVirtualJoystick()}getClassName(){return"VirtualJoysticksCamera"}}class Ja{constructor(){this.compensateDistortion=!0,this.multiviewEnabled=!1}get aspectRatio(){return this.hResolution/(2*this.vResolution)}get aspectRatioFov(){return 2*Math.atan(this.postProcessScaleFactor*this.vScreenSize/(2*this.eyeToScreenDistance))}get leftHMatrix(){const t=4*(this.hScreenSize/4-this.lensSeparationDistance/2)/this.hScreenSize;return $.Translation(t,0,0)}get rightHMatrix(){const t=4*(this.hScreenSize/4-this.lensSeparationDistance/2)/this.hScreenSize;return $.Translation(-t,0,0)}get leftPreViewMatrix(){return $.Translation(.5*this.interpupillaryDistance,0,0)}get rightPreViewMatrix(){return $.Translation(-.5*this.interpupillaryDistance,0,0)}static GetDefault(){const e=new Ja;return e.hResolution=1280,e.vResolution=800,e.hScreenSize=.149759993,e.vScreenSize=.0935999975,e.vScreenCenter=.0467999987,e.eyeToScreenDistance=.0410000011,e.lensSeparationDistance=.063500002,e.interpupillaryDistance=.064000003,e.distortionK=[1,.219999999,.239999995,0],e.chromaAbCorrection=[.995999992,-.00400000019,1.01400006,0],e.postProcessScaleFactor=1.714605507808412,e.lensCenterOffset=.151976421,e}}class Fg extends Ce{getClassName(){return"VRDistortionCorrectionPostProcess"}constructor(e,t,i,r){super(e,"vrDistortionCorrection",["LensCenter","Scale","ScaleIn","HmdWarpParam"],null,r.postProcessScaleFactor,t,Y.BILINEAR_SAMPLINGMODE),this._isRightEye=i,this._distortionFactors=r.distortionK,this._postProcessScaleFactor=r.postProcessScaleFactor,this._lensCenterOffset=r.lensCenterOffset,this.adaptScaleToCurrentViewport=!0,this.onSizeChangedObservable.add(()=>{this._scaleIn=new Q(2,2/this.aspectRatio),this._scaleFactor=new Q(.5*(1/this._postProcessScaleFactor),.5*(1/this._postProcessScaleFactor)*this.aspectRatio),this._lensCenter=new Q(this._isRightEye?.5-this._lensCenterOffset*.5:.5+this._lensCenterOffset*.5,.5)}),this.onApplyObservable.add(s=>{s.setFloat2("LensCenter",this._lensCenter.x,this._lensCenter.y),s.setFloat2("Scale",this._scaleFactor.x,this._scaleFactor.y),s.setFloat2("ScaleIn",this._scaleIn.x,this._scaleIn.y),s.setFloat4("HmdWarpParam",this._distortionFactors[0],this._distortionFactors[1],this._distortionFactors[2],this._distortionFactors[3])})}_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(k(()=>Promise.resolve().then(()=>N3),void 0))):t.push(k(()=>Promise.resolve().then(()=>O3),void 0)),super._gatherImports(e,t)}}const Lg="vrMultiviewToSingleviewPixelShader",fD=`precision mediump sampler2DArray;varying vec2 vUV;uniform sampler2DArray multiviewSampler;uniform int imageIndex;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{gl_FragColor=texture2D(multiviewSampler,vec3(vUV,imageIndex));}`;P.ShadersStore[Lg]||(P.ShadersStore[Lg]=fD);class eh extends Kt{set samples(e){this._samples=e}get samples(){return this._samples}constructor(e,t=512){super("multiview rtt",t,e,!1,!0,0,!1,void 0,!1,!1,!0,void 0,!0),this._renderTarget=this.getScene().getEngine().createMultiviewRenderTargetTexture(this.getRenderWidth(),this.getRenderHeight()),this._texture=this._renderTarget.texture,this._texture.isMultiview=!0,this._texture.format=5,this.samples=this._getEngine().getCaps().maxSamples||this.samples,this._texture.samples=this._samples}_bindFrameBuffer(){this._renderTarget&&this.getScene().getEngine().bindMultiviewFramebuffer(this._renderTarget)}getViewCount(){return 2}}mt.prototype.createMultiviewRenderTargetTexture=function(a,e,t,i){const r=this._gl;if(!this.getCaps().multiview)throw"Multiview is not supported";const s=this._createHardwareRenderTargetWrapper(!1,!1,{width:a,height:e});s._framebuffer=r.createFramebuffer();const n=new Dt(this,0,!0);return n.width=a,n.height=e,n.isMultiview=!0,t||(t=r.createTexture(),r.bindTexture(r.TEXTURE_2D_ARRAY,t),r.texStorage3D(r.TEXTURE_2D_ARRAY,1,r.RGBA8,a,e,2)),s._colorTextureArray=t,i||(i=r.createTexture(),r.bindTexture(r.TEXTURE_2D_ARRAY,i),r.texStorage3D(r.TEXTURE_2D_ARRAY,1,r.DEPTH24_STENCIL8,a,e,2)),s._depthStencilTextureArray=i,n.isReady=!0,s.setTextures(n),s._depthStencilTexture=n,s};mt.prototype.bindMultiviewFramebuffer=function(a){const e=a,t=this._gl,i=this.getCaps().oculusMultiview||this.getCaps().multiview;if(this.bindFramebuffer(e,void 0,void 0,void 0,!0),t.bindFramebuffer(t.DRAW_FRAMEBUFFER,e._framebuffer),e._colorTextureArray&&e._depthStencilTextureArray)this.getCaps().oculusMultiview?(i.framebufferTextureMultisampleMultiviewOVR(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0,e._colorTextureArray,0,e.samples,0,2),i.framebufferTextureMultisampleMultiviewOVR(t.DRAW_FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,e._depthStencilTextureArray,0,e.samples,0,2)):(i.framebufferTextureMultiviewOVR(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0,e._colorTextureArray,0,0,2),i.framebufferTextureMultiviewOVR(t.DRAW_FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,e._depthStencilTextureArray,0,0,2));else throw"Invalid multiview frame buffer"};mt.prototype.bindSpaceWarpFramebuffer=function(a){const e=a,t=this._gl,i=this.getCaps().oculusMultiview||this.getCaps().multiview;if(this.bindFramebuffer(e,void 0,void 0,void 0,!0),t.bindFramebuffer(t.DRAW_FRAMEBUFFER,e._framebuffer),e._colorTextureArray&&e._depthStencilTextureArray)i.framebufferTextureMultiviewOVR(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0,e._colorTextureArray,0,0,2),i.framebufferTextureMultiviewOVR(t.DRAW_FRAMEBUFFER,t.DEPTH_ATTACHMENT,e._depthStencilTextureArray,0,0,2);else throw new Error("Invalid Space Warp framebuffer")};Ze.prototype._useMultiviewToSingleView=!1;Ze.prototype._multiviewTexture=null;Ze.prototype._resizeOrCreateMultiviewTexture=function(a,e){this._multiviewTexture?(this._multiviewTexture.getRenderWidth()!=a||this._multiviewTexture.getRenderHeight()!=e)&&(this._multiviewTexture.dispose(),this._multiviewTexture=new eh(this.getScene(),{width:a,height:e})):this._multiviewTexture=new eh(this.getScene(),{width:a,height:e})};function qy(a,e){const t=new tn(a,void 0,!0,e);return t.addUniform("viewProjection",16),t.addUniform("viewProjectionR",16),t.addUniform("view",16),t.addUniform("projection",16),t.addUniform("vEyePosition",4),t}const pD=Te.prototype.createSceneUniformBuffer;Te.prototype._transformMatrixR=$.Zero();Te.prototype._multiviewSceneUbo=null;Te.prototype._createMultiviewUbo=function(){this._multiviewSceneUbo=qy(this.getEngine(),"scene_multiview")};Te.prototype.createSceneUniformBuffer=function(a){return this._multiviewSceneUbo?qy(this.getEngine(),a):pD.bind(this)(a)};Te.prototype._updateMultiviewUbo=function(a,e){a&&e&&a.multiplyToRef(e,this._transformMatrixR),a&&e&&(a.multiplyToRef(e,V.Matrix[0]),DR.GetRightPlaneToRef(V.Matrix[0],this._frustumPlanes[3])),this._multiviewSceneUbo&&(this._multiviewSceneUbo.updateMatrix("viewProjection",this.getTransformMatrix()),this._multiviewSceneUbo.updateMatrix("viewProjectionR",this._transformMatrixR),this._multiviewSceneUbo.updateMatrix("view",this._viewMatrix),this._multiviewSceneUbo.updateMatrix("projection",this._projectionMatrix))};Te.prototype._renderMultiviewToSingleView=function(a){a._resizeOrCreateMultiviewTexture(a._rigPostProcess&&a._rigPostProcess&&a._rigPostProcess.width>0?a._rigPostProcess.width:this.getEngine().getRenderWidth(!0),a._rigPostProcess&&a._rigPostProcess&&a._rigPostProcess.height>0?a._rigPostProcess.height:this.getEngine().getRenderHeight(!0)),this._multiviewSceneUbo||this._createMultiviewUbo(),a.outputRenderTarget=a._multiviewTexture,this._renderForCamera(a),a.outputRenderTarget=null;for(let e=0;e<a._rigCameras.length;e++){const t=this.getEngine();this._activeCamera=a._rigCameras[e],t.setViewport(this._activeCamera.viewport),this.postProcessManager&&(this.postProcessManager._prepareFrame(),this.postProcessManager._finalizeFrame(this._activeCamera.isIntermediate))}};class mD extends Ce{getClassName(){return"VRMultiviewToSingleviewPostProcess"}constructor(e,t,i){super(e,"vrMultiviewToSingleview",["imageIndex"],["multiviewSampler"],i,t,Y.BILINEAR_SAMPLINGMODE);const r=t??this.getCamera();this.onSizeChangedObservable.add(()=>{}),this.onApplyObservable.add(s=>{r._scene.activeCamera&&r._scene.activeCamera.isLeftCamera?s.setInt("imageIndex",0):s.setInt("imageIndex",1),s.setTexture("multiviewSampler",r._multiviewTexture)})}}function e_(a,e){const t=e.vrCameraMetrics||Ja.GetDefault();a._rigCameras[0]._cameraRigParams.vrMetrics=t,a._rigCameras[0].viewport=new pn(0,0,.5,1),a._rigCameras[0]._cameraRigParams.vrWorkMatrix=new $,a._rigCameras[0]._cameraRigParams.vrHMatrix=t.leftHMatrix,a._rigCameras[0]._cameraRigParams.vrPreViewMatrix=t.leftPreViewMatrix,a._rigCameras[0].getProjectionMatrix=a._rigCameras[0]._getVRProjectionMatrix,a._rigCameras[1]._cameraRigParams.vrMetrics=t,a._rigCameras[1].viewport=new pn(.5,0,.5,1),a._rigCameras[1]._cameraRigParams.vrWorkMatrix=new $,a._rigCameras[1]._cameraRigParams.vrHMatrix=t.rightHMatrix,a._rigCameras[1]._cameraRigParams.vrPreViewMatrix=t.rightPreViewMatrix,a._rigCameras[1].getProjectionMatrix=a._rigCameras[1]._getVRProjectionMatrix,t.multiviewEnabled&&(a.getScene().getEngine().getCaps().multiview?(a._useMultiviewToSingleView=!0,a._rigPostProcess=new mD("VRMultiviewToSingleview",a,t.postProcessScaleFactor)):(L.Warn("Multiview is not supported, falling back to standard rendering"),t.multiviewEnabled=!1)),t.compensateDistortion&&(a._rigCameras[0]._rigPostProcess=new Fg("VR_Distort_Compensation_Left",a._rigCameras[0],!1,t),a._rigCameras[1]._rigPostProcess=new Fg("VR_Distort_Compensation_Right",a._rigCameras[1],!0,t))}li.AddNodeConstructor("VRDeviceOrientationArcRotateCamera",(a,e)=>()=>new _D(a,0,0,1,m.Zero(),e));class _D extends lt{constructor(e,t,i,r,s,n,o=!0,l=Ja.GetDefault()){super(e,t,i,r,s,n),this._setRigMode=u=>e_(this,u),l.compensateDistortion=o,this.setCameraRigMode(Ze.RIG_MODE_VR,{vrCameraMetrics:l}),this.inputs.addVRDeviceOrientation()}getClassName(){return"VRDeviceOrientationArcRotateCamera"}}li.AddNodeConstructor("VRDeviceOrientationFreeCamera",(a,e)=>()=>new t_(a,m.Zero(),e));class t_ extends Km{constructor(e,t,i,r=!0,s=Ja.GetDefault()){super(e,t,i),this._setRigMode=n=>e_(this,n),s.compensateDistortion=r,this.setCameraRigMode(Ze.RIG_MODE_VR,{vrCameraMetrics:s})}getClassName(){return"VRDeviceOrientationFreeCamera"}}li.AddNodeConstructor("VRDeviceOrientationGamepadCamera",(a,e)=>()=>new gD(a,m.Zero(),e));class gD extends t_{constructor(e,t,i,r=!0,s=Ja.GetDefault()){super(e,t,i,r,s),this._setRigMode=n=>e_(this,n),this.inputs.addGamepad()}getClassName(){return"VRDeviceOrientationGamepadCamera"}}it.prototype.createDynamicTexture=function(a,e,t,i){const r=new Dt(this,4);return r.baseWidth=a,r.baseHeight=e,t&&(a=this.needPOTTextures?ds(a,this._caps.maxTextureSize):a,e=this.needPOTTextures?ds(e,this._caps.maxTextureSize):e),r.width=a,r.height=e,r.isReady=!1,r.generateMipMaps=t,r.samplingMode=i,this.updateTextureSamplingMode(i,r),this._internalTexturesCache.push(r),r};it.prototype.updateDynamicTexture=function(a,e,t,i=!1,r,s=!1,n=!1){if(!a)return;const o=this._gl,l=o.TEXTURE_2D,u=this._bindTextureDirectly(l,a,!0,s);this._unpackFlipY(t===void 0?a.invertY:t),i&&o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL,1);const c=this._getWebGLTextureType(a.type),h=this._getInternalFormat(r||a.format),d=this._getRGBABufferInternalSizedFormat(a.type,h);o.texImage2D(l,0,d,h,c,e),a.generateMipMaps&&o.generateMipmap(l),u||this._bindTextureDirectly(l,null),i&&o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL,0),r&&(a.format=r),a._dynamicTextureSource=e,a._premulAlpha=i,a.invertY=t||!1,a.isReady=!0};class Is extends Y{constructor(e,t,i,r=!1,s=3,n=5,o){const l=!i||i._isScene,u=l?i:i==null?void 0:i.scene,c=l?!r:i;super(null,u,c,o,s,void 0,void 0,void 0,void 0,n),this.name=e,this.wrapU=Y.CLAMP_ADDRESSMODE,this.wrapV=Y.CLAMP_ADDRESSMODE,this._generateMipMaps=r;const h=this._getEngine();if(!h)return;if(t.getContext)this._canvas=t,this._ownCanvas=!1,this._texture=h.createDynamicTexture(this._canvas.width,this._canvas.height,r,s);else{this._canvas=h.createCanvas(1,1),this._ownCanvas=!0;const f=t;f.width||f.width===0?this._texture=h.createDynamicTexture(f.width,f.height,r,s):this._texture=h.createDynamicTexture(t,t,r,s)}const d=this.getSize();this._canvas.width!==d.width&&(this._canvas.width=d.width),this._canvas.height!==d.height&&(this._canvas.height=d.height),this._context=this._canvas.getContext("2d")}getClassName(){return"DynamicTexture"}get canRescale(){return!0}_recreate(e){this._canvas.width=e.width,this._canvas.height=e.height,this.releaseInternalTexture(),this._texture=this._getEngine().createDynamicTexture(e.width,e.height,this._generateMipMaps,this.samplingMode)}scale(e){const t=this.getSize();t.width*=e,t.height*=e,this._recreate(t)}scaleTo(e,t){const i=this.getSize();i.width=e,i.height=t,this._recreate(i)}getContext(){return this._context}clear(e){const t=this.getSize();e&&(this._context.fillStyle=e),this._context.clearRect(0,0,t.width,t.height)}update(e,t=!1,i=!1){this._getEngine().updateDynamicTexture(this._texture,this._canvas,e===void 0?!0:e,t,this._format||void 0,void 0,i)}drawText(e,t,i,r,s,n,o,l=!0){const u=this.getSize();if(n&&(this._context.fillStyle=n,this._context.fillRect(0,0,u.width,u.height)),this._context.font=r,t==null){const c=this._context.measureText(e);t=(u.width-c.width)/2}if(i==null){const c=parseInt(r.replace(/\D/g,""));i=u.height/2+c/3.65}this._context.fillStyle=s||"",this._context.fillText(e,t,i),l&&this.update(o)}dispose(){var e,t;super.dispose(),this._ownCanvas&&((t=(e=this._canvas)==null?void 0:e.remove)==null||t.call(e)),this._canvas=null,this._context=null}clone(){const e=this.getScene();if(!e)return this;const t=this.getSize(),i=new Is(this.name,t,e,this._generateMipMaps);return i.hasAlpha=this.hasAlpha,i.level=this.level,i.wrapU=this.wrapU,i.wrapV=this.wrapV,i}serialize(){const e=this.getScene();e&&!e.isReady()&&L.Warn("The scene must be ready before serializing the dynamic texture");const t=super.serialize();return Is._IsCanvasElement(this._canvas)&&(t.base64String=this._canvas.toDataURL()),t.invertY=this._invertY,t.samplingMode=this.samplingMode,t}static _IsCanvasElement(e){return e.toDataURL!==void 0}_rebuild(){this.update()}}class i_{get isFixedFoveationSupported(){return this.layerType=="XRWebGLLayer"&&typeof this.layer.fixedFoveation=="number"}get fixedFoveation(){return this.isFixedFoveationSupported?this.layer.fixedFoveation:null}set fixedFoveation(e){if(this.isFixedFoveationSupported){const t=Math.max(0,Math.min(1,e||0));this.layer.fixedFoveation=t}}createRenderTargetTextureProvider(e){return this._rttWrapper=this._createRenderTargetTextureProvider(e),this._rttWrapper}dispose(){this._rttWrapper&&(this._rttWrapper.dispose(),this._rttWrapper=null)}constructor(e,t,i,r,s){this.getWidth=e,this.getHeight=t,this.layer=i,this.layerType=r,this._createRenderTargetTextureProvider=s,this._rttWrapper=null}}class r_{constructor(e,t){this._scene=e,this.layerWrapper=t,this._renderTargetTextures=new Array,this._engine=e.getEngine()}_createInternalTexture(e,t){const i=new Dt(this._engine,0,!0);return i.width=e.width,i.height=e.height,i._hardwareTexture=new hu(t,this._engine._gl),i.isReady=!0,i}_createRenderTargetTexture(e,t,i,r,s,n){if(!this._engine)throw new Error("Engine is disposed");const o={width:e,height:t},l=n?new eh(this._scene,o):new Kt("XR renderTargetTexture",o,this._scene),u=l.renderTarget;if(u._samples=l.samples,(i||!r)&&(u._framebuffer=i),r)if(n)u._colorTextureArray=r;else{const c=this._createInternalTexture(o,r);u.setTexture(c,0),l._texture=c}return s&&(n?u._depthStencilTextureArray=s:u._depthStencilTexture=this._createInternalTexture(o,s)),l.disableRescaling(),this._renderTargetTextures.push(l),l}_destroyRenderTargetTexture(e){this._renderTargetTextures.splice(this._renderTargetTextures.indexOf(e),1),e.dispose()}getFramebufferDimensions(){return this._framebufferDimensions}dispose(){this._renderTargetTextures.forEach(e=>e.dispose()),this._renderTargetTextures.length=0}}class s_ extends i_{constructor(e){super(()=>e.framebufferWidth,()=>e.framebufferHeight,e,"XRWebGLLayer",t=>new xD(t.scene,this)),this.layer=e}}class xD extends r_{constructor(e,t){super(e,t),this.layerWrapper=t,this._layer=t.layer,this._framebufferDimensions={framebufferWidth:this._layer.framebufferWidth,framebufferHeight:this._layer.framebufferHeight}}trySetViewportForView(e,t){const i=this._layer.getViewport(t);if(!i)return!1;const r=this._framebufferDimensions.framebufferWidth,s=this._framebufferDimensions.framebufferHeight;return e.x=i.x/r,e.y=i.y/s,e.width=i.width/r,e.height=i.height/s,!0}getRenderTargetTextureForEye(e){const t=this._layer.framebufferWidth,i=this._layer.framebufferHeight,r=this._layer.framebuffer;return(!this._rtt||t!==this._framebufferDimensions.framebufferWidth||i!==this._framebufferDimensions.framebufferHeight||r!==this._framebuffer)&&(this._rtt=this._createRenderTargetTexture(t,i,r),this._framebufferDimensions.framebufferWidth=t,this._framebufferDimensions.framebufferHeight=i,this._framebuffer=r),this._rtt}getRenderTargetTextureForView(e){return this.getRenderTargetTextureForEye(e.eye)}}class Ru{static GetDefaults(e){const t=new Ru;return t.canvasOptions={antialias:!0,depth:!0,stencil:e?e.isStencilEnable:!0,alpha:!0,framebufferScaleFactor:1},t.newCanvasCssStyle="position:absolute; bottom:0px;right:0px;z-index:10;width:90%;height:100%;background-color: #000000;",t}}class SD{constructor(e,t=Ru.GetDefaults()){if(this._options=t,this._canvas=null,this._engine=null,this.xrLayer=null,this._xrLayerWrapper=null,this.onXRLayerInitObservable=new j,this._engine=e.scene.getEngine(),this._engine.onDisposeObservable.addOnce(()=>{this._engine=null}),t.canvasElement)this._setManagedOutputCanvas(t.canvasElement);else{const i=document.createElement("canvas");i.style.cssText=this._options.newCanvasCssStyle||"position:absolute; bottom:0px;right:0px;",this._setManagedOutputCanvas(i)}e.onXRSessionInit.add(()=>{this._addCanvas()}),e.onXRSessionEnded.add(()=>{this._removeCanvas()}),this._makeCanvasCompatibleAsync()}dispose(){this._removeCanvas(),this._setManagedOutputCanvas(null),this.onXRLayerInitObservable.clear()}_makeCanvasCompatibleAsync(){this._canvasCompatiblePromise=new Promise((e,t)=>{try{this.canvasContext&&this.canvasContext.makeXRCompatible?this.canvasContext.makeXRCompatible().then(()=>{e()},()=>{ae.Warn("Error executing makeXRCompatible. This does not mean that the session will work incorrectly."),e()}):e()}catch(i){t(i)}})}async initializeXRLayerAsync(e){const t=()=>(this.xrLayer=new XRWebGLLayer(e,this.canvasContext,this._options.canvasOptions),this._xrLayerWrapper=new s_(this.xrLayer),this.onXRLayerInitObservable.notifyObservers(this.xrLayer),this.xrLayer);return this._canvasCompatiblePromise.then(()=>{},()=>{}).then(()=>t())}_addCanvas(){this._canvas&&this._engine&&this._canvas!==this._engine.getRenderingCanvas()&&document.body.appendChild(this._canvas),this.xrLayer?this._setCanvasSize(!0):this.onXRLayerInitObservable.addOnce(()=>{this._setCanvasSize(!0)})}_removeCanvas(){this._canvas&&this._engine&&document.body.contains(this._canvas)&&this._canvas!==this._engine.getRenderingCanvas()&&document.body.removeChild(this._canvas),this._setCanvasSize(!1)}_setCanvasSize(e=!0,t=this._xrLayerWrapper){!this._canvas||!this._engine||(e?t&&(this._canvas!==this._engine.getRenderingCanvas()?(this._canvas.style.width=t.getWidth()+"px",this._canvas.style.height=t.getHeight()+"px"):this._engine.setSize(t.getWidth(),t.getHeight())):this._originalCanvasSize&&(this._canvas!==this._engine.getRenderingCanvas()?(this._canvas.style.width=this._originalCanvasSize.width+"px",this._canvas.style.height=this._originalCanvasSize.height+"px"):this._engine.setSize(this._originalCanvasSize.width,this._originalCanvasSize.height)))}_setManagedOutputCanvas(e){this._removeCanvas(),e?(this._originalCanvasSize={width:e.offsetWidth,height:e.offsetHeight},this._canvas=e,this.canvasContext=this._canvas.getContext("webgl2"),this.canvasContext||(this.canvasContext=this._canvas.getContext("webgl"))):(this._canvas=null,this.canvasContext=null)}}class vD extends i_{constructor(e){super(()=>e.framebufferWidth,()=>e.framebufferHeight,e,"XRWebGLLayer",t=>new bD(t,this)),this.layer=e}}class bD extends r_{constructor(e,t){super(e.scene,t),this.layerWrapper=t,this._nativeRTTProvider=navigator.xr.getNativeRenderTargetProvider(e.session,this._createRenderTargetTexture.bind(this),this._destroyRenderTargetTexture.bind(this)),this._nativeLayer=t.layer}trySetViewportForView(e){return e.x=0,e.y=0,e.width=1,e.height=1,!0}getRenderTargetTextureForEye(e){return this._nativeRTTProvider.getRenderTargetForEye(e)}getRenderTargetTextureForView(e){return this._nativeRTTProvider.getRenderTargetForEye(e.eye)}getFramebufferDimensions(){return{framebufferWidth:this._nativeLayer.framebufferWidth,framebufferHeight:this._nativeLayer.framebufferHeight}}}class yD{constructor(e){this._nativeRenderTarget=navigator.xr.getWebXRRenderTarget(e.scene.getEngine())}async initializeXRLayerAsync(e){return await this._nativeRenderTarget.initializeXRLayerAsync(e),this.xrLayer=this._nativeRenderTarget.xrLayer,this.xrLayer}dispose(){}}class Mu{get worldScalingFactor(){return this._worldScalingFactor}set worldScalingFactor(e){const t=this._worldScalingFactor;this._worldScalingFactor=e,this.onWorldScaleFactorChangedObservable.notifyObservers({previousScaleFactor:t,newScaleFactor:e})}constructor(e){this.scene=e,this.currentTimestamp=-1,this.defaultHeightCompensation=1.7,this.onXRFrameObservable=new j,this.onXRReferenceSpaceChanged=new j,this.onXRSessionEnded=new j,this.onXRSessionInit=new j,this.onXRReferenceSpaceInitialized=new j,this.onXRReady=new j,this.inXRFrameLoop=!1,this.inXRSession=!1,this._worldScalingFactor=1,this.onWorldScaleFactorChangedObservable=new j(void 0,!0),this._engine=e.getEngine(),this._onEngineDisposedObserver=this._engine.onDisposeObservable.addOnce(()=>{this._engine=null}),e.onDisposeObservable.addOnce(()=>{this.dispose()})}get referenceSpace(){return this._referenceSpace}set referenceSpace(e){this._referenceSpace=e,this.onXRReferenceSpaceChanged.notifyObservers(this._referenceSpace)}get sessionMode(){return this._sessionMode}dispose(){var e;this.inXRSession&&this.exitXRAsync(),this.onXRReady.clear(),this.onXRFrameObservable.clear(),this.onXRSessionEnded.clear(),this.onXRReferenceSpaceChanged.clear(),this.onXRSessionInit.clear(),this.onWorldScaleFactorChangedObservable.clear(),(e=this._engine)==null||e.onDisposeObservable.remove(this._onEngineDisposedObserver),this._engine=null}async exitXRAsync(){if(this.session&&this.inXRSession){this.inXRSession=!1;try{return await this.session.end()}catch{L.Warn("Could not end XR session.")}}return Promise.resolve()}trySetViewportForView(e,t){var i;return((i=this._baseLayerRTTProvider)==null?void 0:i.trySetViewportForView(e,t))||!1}getRenderTargetTextureForEye(e){var t;return((t=this._baseLayerRTTProvider)==null?void 0:t.getRenderTargetTextureForEye(e))||null}getRenderTargetTextureForView(e){var t;return((t=this._baseLayerRTTProvider)==null?void 0:t.getRenderTargetTextureForView(e))||null}getWebXRRenderTarget(e){const t=this.scene.getEngine();return this._xrNavigator.xr.native?new yD(this):(e=e||Ru.GetDefaults(t),e.canvasElement=e.canvasElement||t.getRenderingCanvas()||void 0,new SD(this,e))}initializeAsync(){return this._xrNavigator=navigator,this._xrNavigator.xr?Promise.resolve():Promise.reject("WebXR not available")}initializeSessionAsync(e="immersive-vr",t={}){return this._xrNavigator.xr.requestSession(e,t).then(i=>(this.session=i,this._sessionMode=e,this.inXRSession=!0,this.onXRSessionInit.notifyObservers(i),this.session.addEventListener("end",()=>{var r;this.inXRSession=!1,this.onXRSessionEnded.notifyObservers(null),this._engine&&(this._engine.framebufferDimensionsObject=null,this._engine.restoreDefaultFramebuffer(),this._engine.customAnimationFrameRequester=null,this._engine._renderLoop()),this.isNative&&((r=this._baseLayerRTTProvider)==null||r.dispose()),this._baseLayerRTTProvider=null,this._baseLayerWrapper=null},{once:!0}),this.session))}isSessionSupportedAsync(e){return Mu.IsSessionSupportedAsync(e)}resetReferenceSpace(){this.referenceSpace=this.baseReferenceSpace}runXRRenderLoop(){var e;!this.inXRSession||!this._engine||(this._engine.customAnimationFrameRequester={requestAnimationFrame:t=>this.session.requestAnimationFrame(t),renderFunction:(t,i)=>{var r;if(!(!this.inXRSession||!this._engine)&&(this.currentFrame=i,this.currentTimestamp=t,i)){this.inXRFrameLoop=!0;const s=((r=this._baseLayerRTTProvider)==null?void 0:r.getFramebufferDimensions())||null;this._engine.framebufferDimensionsObject!==s&&(this._engine.framebufferDimensionsObject=s),this.onXRFrameObservable.notifyObservers(i),this._engine._renderLoop(),this._engine.framebufferDimensionsObject=null,this.inXRFrameLoop=!1}}},this._engine.framebufferDimensionsObject=((e=this._baseLayerRTTProvider)==null?void 0:e.getFramebufferDimensions())||null,this.onXRFrameObservable.addOnce(()=>{this.onXRReady.notifyObservers(this)}),typeof window<"u"&&window.cancelAnimationFrame&&window.cancelAnimationFrame(this._engine._frameHandler),this._engine._renderLoop())}setReferenceSpaceTypeAsync(e="local-floor"){return this.session.requestReferenceSpace(e).then(t=>t,t=>(L.Error("XR.requestReferenceSpace failed for the following reason: "),L.Error(t),L.Log('Defaulting to universally-supported "viewer" reference space type.'),this.session.requestReferenceSpace("viewer").then(i=>{const r=new XRRigidTransform({x:0,y:-this.defaultHeightCompensation,z:0});return i.getOffsetReferenceSpace(r)},i=>{throw L.Error(i),'XR initialization failed: required "viewer" reference space type not supported.'}))).then(t=>this.session.requestReferenceSpace("viewer").then(i=>(this.viewerReferenceSpace=i,t))).then(t=>(this.referenceSpace=this.baseReferenceSpace=t,this.onXRReferenceSpaceInitialized.notifyObservers(t),this.referenceSpace))}updateRenderStateAsync(e){return Promise.resolve(this.session.updateRenderState(e))}_setBaseLayerWrapper(e){var t,i;this.isNative&&((t=this._baseLayerRTTProvider)==null||t.dispose()),this._baseLayerWrapper=e,this._baseLayerRTTProvider=((i=this._baseLayerWrapper)==null?void 0:i.createRenderTargetTextureProvider(this))||null}_getBaseLayerWrapper(){return this._baseLayerWrapper}updateRenderState(e){e.baseLayer&&this._setBaseLayerWrapper(this.isNative?new vD(e.baseLayer):new s_(e.baseLayer)),this.session.updateRenderState(e)}static IsSessionSupportedAsync(e){if(!navigator.xr)return Promise.resolve(!1);const t=navigator.xr.isSessionSupported||navigator.xr.supportsSession;return t?t.call(navigator.xr,e).then(i=>{const r=typeof i>"u"?!0:i;return Promise.resolve(r)}).catch(i=>(L.Warn(i),Promise.resolve(!1))):Promise.resolve(!1)}get isNative(){return this._xrNavigator.xr.native??!1}get currentFrameRate(){var e;return(e=this.session)==null?void 0:e.frameRate}get supportedFrameRates(){var e;return(e=this.session)==null?void 0:e.supportedFrameRates}updateTargetFrameRate(e){return this.session.updateTargetFrameRate(e)}runInXRFrame(e,t=!0){this.inXRFrameLoop?e():(this.inXRSession||!t)&&this.onXRFrameObservable.addOnce(e)}get isFixedFoveationSupported(){var e;return((e=this._baseLayerWrapper)==null?void 0:e.isFixedFoveationSupported)||!1}get fixedFoveation(){var e;return((e=this._baseLayerWrapper)==null?void 0:e.fixedFoveation)||null}set fixedFoveation(e){const t=Math.max(0,Math.min(1,e||0));this._baseLayerWrapper&&(this._baseLayerWrapper.fixedFoveation=t)}get enabledFeatures(){var e;return((e=this.session)==null?void 0:e.enabledFeatures)??null}}z._GroundMeshParser=(a,e)=>al.Parse(a,e);class al extends z{constructor(e,t){super(e,t),this.generateOctree=!1}getClassName(){return"GroundMesh"}get subdivisions(){return Math.min(this._subdivisionsX,this._subdivisionsY)}get subdivisionsX(){return this._subdivisionsX}get subdivisionsY(){return this._subdivisionsY}optimize(e,t=32){this._subdivisionsX=e,this._subdivisionsY=e,this.subdivide(e);const i=this;i.createOrUpdateSubmeshesOctree&&i.createOrUpdateSubmeshesOctree(t)}getHeightAtCoordinates(e,t){const i=this.getWorldMatrix(),r=V.Matrix[5];i.invertToRef(r);const s=V.Vector3[8];if(m.TransformCoordinatesFromFloatsToRef(e,0,t,r,s),e=s.x,t=s.z,e<this._minX||e>=this._maxX||t<=this._minZ||t>this._maxZ)return this.position.y;(!this._heightQuads||this._heightQuads.length==0)&&(this._initHeightQuads(),this._computeHeightQuads());const n=this._getFacetAt(e,t),o=-(n.x*e+n.z*t+n.w)/n.y;return m.TransformCoordinatesFromFloatsToRef(0,o,0,i,s),s.y}getNormalAtCoordinates(e,t){const i=new m(0,1,0);return this.getNormalAtCoordinatesToRef(e,t,i),i}getNormalAtCoordinatesToRef(e,t,i){const r=this.getWorldMatrix(),s=V.Matrix[5];r.invertToRef(s);const n=V.Vector3[8];if(m.TransformCoordinatesFromFloatsToRef(e,0,t,s,n),e=n.x,t=n.z,e<this._minX||e>this._maxX||t<this._minZ||t>this._maxZ)return this;(!this._heightQuads||this._heightQuads.length==0)&&(this._initHeightQuads(),this._computeHeightQuads());const o=this._getFacetAt(e,t);return m.TransformNormalFromFloatsToRef(o.x,o.y,o.z,r,i),this}updateCoordinateHeights(){return(!this._heightQuads||this._heightQuads.length==0)&&this._initHeightQuads(),this._computeHeightQuads(),this}_getFacetAt(e,t){const i=Math.floor((e+this._maxX)*this._subdivisionsX/this._width),r=Math.floor(-(t+this._maxZ)*this._subdivisionsY/this._height+this._subdivisionsY),s=this._heightQuads[r*this._subdivisionsX+i];let n;return t<s.slope.x*e+s.slope.y?n=s.facet1:n=s.facet2,n}_initHeightQuads(){const e=this._subdivisionsX,t=this._subdivisionsY;this._heightQuads=new Array;for(let i=0;i<t;i++)for(let r=0;r<e;r++){const s={slope:Q.Zero(),facet1:new Ve(0,0,0,0),facet2:new Ve(0,0,0,0)};this._heightQuads[i*e+r]=s}return this}_computeHeightQuads(){const e=this.getVerticesData(N.PositionKind);if(!e)return this;const t=V.Vector3[3],i=V.Vector3[2],r=V.Vector3[1],s=V.Vector3[0],n=V.Vector3[4],o=V.Vector3[5],l=V.Vector3[6],u=V.Vector3[7],c=V.Vector3[8];let h=0,d=0,f=0,p=0,g=0,_=0,S=0;const b=this._subdivisionsX,y=this._subdivisionsY;for(let T=0;T<y;T++)for(let v=0;v<b;v++){h=v*3,d=T*(b+1)*3,f=(T+1)*(b+1)*3,t.x=e[d+h],t.y=e[d+h+1],t.z=e[d+h+2],i.x=e[d+h+3],i.y=e[d+h+4],i.z=e[d+h+5],r.x=e[f+h],r.y=e[f+h+1],r.z=e[f+h+2],s.x=e[f+h+3],s.y=e[f+h+4],s.z=e[f+h+5],p=(s.z-t.z)/(s.x-t.x),g=t.z-p*t.x,i.subtractToRef(t,n),r.subtractToRef(t,o),s.subtractToRef(t,l),m.CrossToRef(l,o,u),m.CrossToRef(n,l,c),u.normalize(),c.normalize(),_=-(u.x*t.x+u.y*t.y+u.z*t.z),S=-(c.x*i.x+c.y*i.y+c.z*i.z);const E=this._heightQuads[T*b+v];E.slope.copyFromFloats(p,g),E.facet1.copyFromFloats(u.x,u.y,u.z,_),E.facet2.copyFromFloats(c.x,c.y,c.z,S)}return this}serialize(e){super.serialize(e),e.subdivisionsX=this._subdivisionsX,e.subdivisionsY=this._subdivisionsY,e.minX=this._minX,e.maxX=this._maxX,e.minZ=this._minZ,e.maxZ=this._maxZ,e.width=this._width,e.height=this._height}static Parse(e,t){const i=new al(e.name,t);return i._subdivisionsX=e.subdivisionsX||1,i._subdivisionsY=e.subdivisionsY||1,i._minX=e.minX,i._maxX=e.maxX,i._minZ=e.minZ,i._maxZ=e.maxZ,i._width=e.width,i._height=e.height,i}}function Zr(a){const e=[],t=[],i=[],r=[];let s,n;const o=a.width||a.size||1,l=a.height||a.size||1,u=(a.subdivisionsX||a.subdivisions||1)|0,c=(a.subdivisionsY||a.subdivisions||1)|0;for(s=0;s<=c;s++)for(n=0;n<=u;n++){const d=new m(n*o/u-o/2,0,(c-s)*l/c-l/2),f=new m(0,1,0);t.push(d.x,d.y,d.z),i.push(f.x,f.y,f.z),r.push(n/u,ot?s/c:1-s/c)}for(s=0;s<c;s++)for(n=0;n<u;n++)e.push(n+1+(s+1)*(u+1)),e.push(n+1+s*(u+1)),e.push(n+s*(u+1)),e.push(n+(s+1)*(u+1)),e.push(n+1+(s+1)*(u+1)),e.push(n+s*(u+1));const h=new he;return h.indices=e,h.positions=t,h.normals=i,h.uvs=r,h}function Qy(a){const e=a.xmin!==void 0&&a.xmin!==null?a.xmin:-1,t=a.zmin!==void 0&&a.zmin!==null?a.zmin:-1,i=a.xmax!==void 0&&a.xmax!==null?a.xmax:1,r=a.zmax!==void 0&&a.zmax!==null?a.zmax:1,s=a.subdivisions||{w:1,h:1},n=a.precision||{w:1,h:1},o=[],l=[],u=[],c=[];let h,d,f,p;s.h=s.h<1?1:s.h,s.w=s.w<1?1:s.w,n.w=n.w<1?1:n.w,n.h=n.h<1?1:n.h;const g={w:(i-e)/s.w,h:(r-t)/s.h};function _(b,y,T,v){const E=l.length/3,R=n.w+1;for(h=0;h<n.h;h++)for(d=0;d<n.w;d++){const M=[E+d+h*R,E+(d+1)+h*R,E+(d+1)+(h+1)*R,E+d+(h+1)*R];o.push(M[1]),o.push(M[2]),o.push(M[3]),o.push(M[0]),o.push(M[1]),o.push(M[3])}const O=m.Zero(),w=new m(0,1,0);for(h=0;h<=n.h;h++)for(O.z=h*(v-y)/n.h+y,d=0;d<=n.w;d++)O.x=d*(T-b)/n.w+b,O.y=0,l.push(O.x,O.y,O.z),u.push(w.x,w.y,w.z),c.push(d/n.w,h/n.h)}for(f=0;f<s.h;f++)for(p=0;p<s.w;p++)_(e+p*g.w,t+f*g.h,e+(p+1)*g.w,t+(f+1)*g.h);const S=new he;return S.indices=o,S.positions=l,S.normals=u,S.uvs=c,S}function Ky(a){const e=[],t=[],i=[],r=[];let s,n;const o=a.colorFilter||new ne(.3,.59,.11),l=a.alphaFilter||0;let u=!1;if(a.minHeight>a.maxHeight){u=!0;const h=a.maxHeight;a.maxHeight=a.minHeight,a.minHeight=h}for(s=0;s<=a.subdivisions;s++)for(n=0;n<=a.subdivisions;n++){const h=new m(n*a.width/a.subdivisions-a.width/2,0,(a.subdivisions-s)*a.height/a.subdivisions-a.height/2),d=(h.x+a.width/2)/a.width*(a.bufferWidth-1)|0,f=(1-(h.z+a.height/2)/a.height)*(a.bufferHeight-1)|0,p=(d+f*a.bufferWidth)*4;let g=a.buffer[p]/255,_=a.buffer[p+1]/255,S=a.buffer[p+2]/255;const b=a.buffer[p+3]/255;u&&(g=1-g,_=1-_,S=1-S);const y=g*o.r+_*o.g+S*o.b;b>=l?h.y=a.minHeight+(a.maxHeight-a.minHeight)*y:h.y=a.minHeight-He,a.heightBuffer&&(a.heightBuffer[s*(a.subdivisions+1)+n]=h.y),t.push(h.x,h.y,h.z),i.push(0,0,0),r.push(n/a.subdivisions,1-s/a.subdivisions)}for(s=0;s<a.subdivisions;s++)for(n=0;n<a.subdivisions;n++){const h=n+1+(s+1)*(a.subdivisions+1),d=n+1+s*(a.subdivisions+1),f=n+s*(a.subdivisions+1),p=n+(s+1)*(a.subdivisions+1),g=t[h*3+1]>=a.minHeight,_=t[d*3+1]>=a.minHeight,S=t[f*3+1]>=a.minHeight;g&&_&&S&&(e.push(h),e.push(d),e.push(f)),t[p*3+1]>=a.minHeight&&g&&S&&(e.push(p),e.push(h),e.push(f))}he.ComputeNormals(t,e,i);const c=new he;return c.indices=e,c.positions=t,c.normals=i,c.uvs=r,c}function ol(a,e={},t){const i=new al(a,t);return i._setReady(!1),i._subdivisionsX=e.subdivisionsX||e.subdivisions||1,i._subdivisionsY=e.subdivisionsY||e.subdivisions||1,i._width=e.width||1,i._height=e.height||1,i._maxX=i._width/2,i._maxZ=i._height/2,i._minX=-i._maxX,i._minZ=-i._maxZ,Zr(e).applyToMesh(i,e.updatable),i._setReady(!0),i}function n_(a,e,t=null){const i=new z(a,t);return Qy(e).applyToMesh(i,e.updatable),i}function a_(a,e,t={},i=null){const r=t.width||10,s=t.height||10,n=t.subdivisions||1,o=t.minHeight||0,l=t.maxHeight||1,u=t.colorFilter||new ne(.3,.59,.11),c=t.alphaFilter||0,h=t.updatable,d=t.onReady;i=i||ze.LastCreatedScene;const f=new al(a,i);f._subdivisionsX=n,f._subdivisionsY=n,f._width=r,f._height=s,f._maxX=f._width/2,f._maxZ=f._height/2,f._minX=-f._maxX,f._minZ=-f._maxZ,f._setReady(!1);let p;t.passHeightBufferInCallback&&(p=new Float32Array((n+1)*(n+1)));const g=(_,S,b)=>{Ky({width:r,height:s,subdivisions:n,minHeight:o,maxHeight:l,colorFilter:u,buffer:_,bufferWidth:S,bufferHeight:b,alphaFilter:c,heightBuffer:p}).applyToMesh(f,h),d&&d(f,p),f._setReady(!0)};if(typeof e=="string"){const _=S=>{const b=S.width,y=S.height;if(i.isDisposed)return;const T=i==null?void 0:i.getEngine().resizeImageBitmap(S,b,y);g(T,b,y)};ae.LoadImage(e,_,t.onError?t.onError:()=>{},i.offlineProvider)}else g(e.data,e.width,e.height);return f}const sW={CreateGround:ol,CreateGroundFromHeightMap:a_,CreateTiledGround:n_};he.CreateGround=Zr;he.CreateTiledGround=Qy;he.CreateGroundFromHeightMap=Ky;z.CreateGround=(a,e,t,i,r,s)=>ol(a,{width:e,height:t,subdivisions:i,updatable:s},r);z.CreateTiledGround=(a,e,t,i,r,s,n,o,l)=>n_(a,{xmin:e,zmin:t,xmax:i,zmax:r,subdivisions:s,precision:n,updatable:l},o);z.CreateGroundFromHeightMap=(a,e,t,i,r,s,n,o,l,u,c)=>a_(a,e,{width:t,height:i,subdivisions:r,minHeight:s,maxHeight:n,updatable:l,onReady:u,alphaFilter:c},o);function o_(a){const e=[],t=[],i=[],r=[],s=a.diameter||1,n=a.thickness||.5,o=(a.tessellation||16)|0,l=a.sideOrientation===0?0:a.sideOrientation||he.DEFAULTSIDE,u=o+1;for(let h=0;h<=o;h++){const d=h/o,f=h*Math.PI*2/o-Math.PI/2,p=$.Translation(s/2,0,0).multiply($.RotationY(f));for(let g=0;g<=o;g++){const _=1-g/o,S=g*Math.PI*2/o+Math.PI,b=Math.cos(S),y=Math.sin(S);let T=new m(b,y,0),v=T.scale(n/2);const E=new Q(d,_);v=m.TransformCoordinates(v,p),T=m.TransformNormal(T,p),t.push(v.x,v.y,v.z),i.push(T.x,T.y,T.z),r.push(E.x,ot?1-E.y:E.y);const R=(h+1)%u,O=(g+1)%u;e.push(h*u+g),e.push(h*u+O),e.push(R*u+g),e.push(h*u+O),e.push(R*u+O),e.push(R*u+g)}}he._ComputeSides(l,t,e,i,r,a.frontUVs,a.backUVs);const c=new he;return c.indices=e,c.positions=t,c.normals=i,c.uvs=r,c}function fs(a,e={},t){const i=new z(a,t);return e.sideOrientation=z._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,o_(e).applyToMesh(i,e.updatable),i}const nW={CreateTorus:fs};he.CreateTorus=o_;z.CreateTorus=(a,e,t,i,r,s,n)=>fs(a,{diameter:e,thickness:t,tessellation:i,sideOrientation:n,updatable:s},r);class Au{constructor(e,t=null){if(this.scene=e,this._pointerDownOnMeshAsked=!1,this._isActionableMesh=!1,this._teleportationRequestInitiated=!1,this._teleportationBackRequestInitiated=!1,this._rotationRightAsked=!1,this._rotationLeftAsked=!1,this._dpadPressed=!0,this._activePointer=!1,this._id=Au._IdCounter++,t)this._gazeTracker=t.clone("gazeTracker");else{this._gazeTracker=fs("gazeTracker",{diameter:.0035,thickness:.0025,tessellation:20,updatable:!1},e),this._gazeTracker.bakeCurrentTransformIntoVertices(),this._gazeTracker.isPickable=!1,this._gazeTracker.isVisible=!1;const i=new Ut("targetMat",e);i.specularColor=ne.Black(),i.emissiveColor=new ne(.7,.7,.7),i.backFaceCulling=!1,this._gazeTracker.material=i}}_getForwardRay(e){return new Zt(m.Zero(),new m(0,0,e))}_selectionPointerDown(){this._pointerDownOnMeshAsked=!0,this._currentHit&&this.scene.simulatePointerDown(this._currentHit,{pointerId:this._id})}_selectionPointerUp(){this._currentHit&&this.scene.simulatePointerUp(this._currentHit,{pointerId:this._id}),this._pointerDownOnMeshAsked=!1}_activatePointer(){this._activePointer=!0}_deactivatePointer(){this._activePointer=!1}_updatePointerDistance(e=100){}dispose(){this._interactionsEnabled=!1,this._teleportationEnabled=!1,this._gazeTracker&&this._gazeTracker.dispose()}}Au._IdCounter=0;class Bg extends Au{constructor(e,t){super(t),this._getCamera=e}_getForwardRay(e){const t=this._getCamera();return t?t.getForwardRay(e):new Zt(m.Zero(),m.Forward())}}class aW{}class wa{get onEnteringVR(){return this.onEnteringVRObservable}get onExitingVR(){return this.onExitingVRObservable}get teleportationTarget(){return this._teleportationTarget}set teleportationTarget(e){e&&(e.name="teleportationTarget",this._isDefaultTeleportationTarget=!1,this._teleportationTarget=e)}get gazeTrackerMesh(){return this._cameraGazer._gazeTracker}set gazeTrackerMesh(e){e&&(this._cameraGazer._gazeTracker&&this._cameraGazer._gazeTracker.dispose(),this._cameraGazer._gazeTracker=e,this._cameraGazer._gazeTracker.bakeCurrentTransformIntoVertices(),this._cameraGazer._gazeTracker.isPickable=!1,this._cameraGazer._gazeTracker.isVisible=!1,this._cameraGazer._gazeTracker.name="gazeTracker")}get displayGaze(){return this._displayGaze}set displayGaze(e){this._displayGaze=e,e||(this._cameraGazer._gazeTracker.isVisible=!1)}get displayLaserPointer(){return this._displayLaserPointer}set displayLaserPointer(e){this._displayLaserPointer=e}get deviceOrientationCamera(){return this._deviceOrientationCamera}get currentVRCamera(){return this._scene.activeCamera}get vrDeviceOrientationCamera(){return this._vrDeviceOrientationCamera}get vrButton(){return this._btnVR}get _teleportationRequestInitiated(){return this._cameraGazer._teleportationRequestInitiated}constructor(e,t={}){if(this.webVROptions=t,this._fullscreenVRpresenting=!1,this.enableGazeEvenWhenNoPointerLock=!1,this.exitVROnDoubleTap=!0,this.onEnteringVRObservable=new j,this.onAfterEnteringVRObservable=new j,this.onExitingVRObservable=new j,this._useCustomVRButton=!1,this._teleportActive=!1,this._floorMeshesCollection=[],this._teleportationMode=wa.TELEPORTATIONMODE_CONSTANTTIME,this._teleportationTime=122,this._teleportationSpeed=20,this._rotationAllowed=!0,this._teleportBackwardsVector=new m(0,-1,-1),this._isDefaultTeleportationTarget=!0,this._teleportationFillColor="#444444",this._teleportationBorderColor="#FFFFFF",this._rotationAngle=0,this._haloCenter=new m(0,0,0),this._padSensibilityUp=.65,this._padSensibilityDown=.35,this._pickedLaserColor=new ne(.2,.2,1),this._pickedGazeColor=new ne(0,0,1),this.onNewMeshSelected=new j,this.onNewMeshPicked=new j,this.onBeforeCameraTeleport=new j,this.onAfterCameraTeleport=new j,this.onSelectedMeshUnselected=new j,this.teleportationEnabled=!0,this._teleportationInitialized=!1,this._interactionsEnabled=!1,this._displayGaze=!0,this._displayLaserPointer=!0,this.updateGazeTrackerScale=!0,this.updateGazeTrackerColor=!0,this.updateControllerLaserColor=!0,this.requestPointerLockOnFullScreen=!0,this.xrTestDone=!1,this._onResize=()=>{this._moveButtonToBottomRight()},this._onFullscreenChange=()=>{this._fullscreenVRpresenting=!!document.fullscreenElement,!this._fullscreenVRpresenting&&this._inputElement&&(this.exitVR(),!this._useCustomVRButton&&this._btnVR&&(this._btnVR.style.top=this._inputElement.offsetTop+this._inputElement.offsetHeight-70+"px",this._btnVR.style.left=this._inputElement.offsetLeft+this._inputElement.offsetWidth-100+"px",this._updateButtonVisibility()))},this._cachedAngularSensibility={angularSensibilityX:null,angularSensibilityY:null,angularSensibility:null},this._beforeRender=()=>{this._scene.getEngine().isPointerLock||this.enableGazeEvenWhenNoPointerLock||(this._cameraGazer._gazeTracker.isVisible=!1)},this._onNewGamepadConnected=r=>{r.type!==Jt.POSE_ENABLED&&(r.leftStick&&r.onleftstickchanged(s=>{this._teleportationInitialized&&this.teleportationEnabled&&(this._checkTeleportWithRay(s,this._cameraGazer),this._checkTeleportBackwards(s,this._cameraGazer))}),r.rightStick&&r.onrightstickchanged(s=>{this._teleportationInitialized&&this._checkRotate(s,this._cameraGazer)}),r.type===Jt.XBOX&&(r.onbuttondown(s=>{this._interactionsEnabled&&s===0&&this._cameraGazer._selectionPointerDown()}),r.onbuttonup(s=>{this._interactionsEnabled&&s===0&&this._cameraGazer._selectionPointerUp()})))},this._workingVector=m.Zero(),this._workingQuaternion=re.Identity(),this._workingMatrix=$.Identity(),L.Warn("WebVR is deprecated. Please avoid using this experience helper and use the WebXR experience helper instead"),this._scene=e,this._inputElement=e.getEngine().getInputElement(),!("getVRDisplays"in navigator)&&t.useXR===void 0&&(t.useXR=!0),t.createFallbackVRDeviceOrientationFreeCamera===void 0&&(t.createFallbackVRDeviceOrientationFreeCamera=!0),t.createDeviceOrientationCamera===void 0&&(t.createDeviceOrientationCamera=!0),t.laserToggle===void 0&&(t.laserToggle=!0),this._hasEnteredVR=!1,this._scene.activeCamera?this._position=this._scene.activeCamera.position.clone():this._position=new m(0,this._defaultHeight,0),t.createDeviceOrientationCamera||!this._scene.activeCamera){if(this._deviceOrientationCamera=new Km("deviceOrientationVRHelper",this._position.clone(),e),this._scene.activeCamera&&(this._deviceOrientationCamera.minZ=this._scene.activeCamera.minZ,this._deviceOrientationCamera.maxZ=this._scene.activeCamera.maxZ,this._scene.activeCamera instanceof Xa&&this._scene.activeCamera.rotation)){const r=this._scene.activeCamera;r.rotationQuaternion?this._deviceOrientationCamera.rotationQuaternion.copyFrom(r.rotationQuaternion):this._deviceOrientationCamera.rotationQuaternion.copyFrom(re.RotationYawPitchRoll(r.rotation.y,r.rotation.x,r.rotation.z)),this._deviceOrientationCamera.rotation=r.rotation.clone()}this._scene.activeCamera=this._deviceOrientationCamera,this._inputElement&&this._scene.activeCamera.attachControl()}else this._existingCamera=this._scene.activeCamera;this.webVROptions.useXR&&navigator.xr?Mu.IsSessionSupportedAsync("immersive-vr").then(r=>{r?(L.Log("Using WebXR. It is recommended to use the WebXRDefaultExperience directly"),e.createDefaultXRExperienceAsync({floorMeshes:t.floorMeshes||[]}).then(s=>{this.xr=s,this.xrTestDone=!0,this._cameraGazer=new Bg(()=>this.xr.baseExperience.camera,e),this.xr.baseExperience.onStateChangedObservable.add(n=>{switch(n){case 0:this.onEnteringVRObservable.notifyObservers(this),this._interactionsEnabled||this.xr.pointerSelection.detach(),this.xr.pointerSelection.displayLaserPointer=this._displayLaserPointer;break;case 1:this.onExitingVRObservable.notifyObservers(this),this._scene.getEngine().resize();break;case 2:this._hasEnteredVR=!0;break;case 3:this._hasEnteredVR=!1;break}})})):this._completeVRInit(e,t)}):this._completeVRInit(e,t)}_completeVRInit(e,t){if(this.xrTestDone=!0,t.createFallbackVRDeviceOrientationFreeCamera&&(this._vrDeviceOrientationCamera=new t_("VRDeviceOrientationVRHelper",this._position,this._scene,!0,t.vrDeviceOrientationCameraMetrics),this._vrDeviceOrientationCamera.angularSensibility=Number.MAX_VALUE),this._cameraGazer=new Bg(()=>this.currentVRCamera,e),!this._useCustomVRButton){this._btnVR=document.createElement("BUTTON"),this._btnVR.className="babylonVRicon",this._btnVR.id="babylonVRiconbtn",this._btnVR.title="Click to switch to VR";let s=".babylonVRicon { position: absolute; right: 20px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-image: url("+(window.SVGSVGElement?"data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%222048%22%20height%3D%221152%22%20viewBox%3D%220%200%202048%201152%22%20version%3D%221.1%22%3E%3Cpath%20transform%3D%22rotate%28180%201024%2C576.0000000000001%29%22%20d%3D%22m1109%2C896q17%2C0%2030%2C-12t13%2C-30t-12.5%2C-30.5t-30.5%2C-12.5l-170%2C0q-18%2C0%20-30.5%2C12.5t-12.5%2C30.5t13%2C30t30%2C12l170%2C0zm-85%2C256q59%2C0%20132.5%2C-1.5t154.5%2C-5.5t164.5%2C-11.5t163%2C-20t150%2C-30t124.5%2C-41.5q23%2C-11%2042%2C-24t38%2C-30q27%2C-25%2041%2C-61.5t14%2C-72.5l0%2C-257q0%2C-123%20-47%2C-232t-128%2C-190t-190%2C-128t-232%2C-47l-81%2C0q-37%2C0%20-68.5%2C14t-60.5%2C34.5t-55.5%2C45t-53%2C45t-53%2C34.5t-55.5%2C14t-55.5%2C-14t-53%2C-34.5t-53%2C-45t-55.5%2C-45t-60.5%2C-34.5t-68.5%2C-14l-81%2C0q-123%2C0%20-232%2C47t-190%2C128t-128%2C190t-47%2C232l0%2C257q0%2C68%2038%2C115t97%2C73q54%2C24%20124.5%2C41.5t150%2C30t163%2C20t164.5%2C11.5t154.5%2C5.5t132.5%2C1.5zm939%2C-298q0%2C39%20-24.5%2C67t-58.5%2C42q-54%2C23%20-122%2C39.5t-143.5%2C28t-155.5%2C19t-157%2C11t-148.5%2C5t-129.5%2C1.5q-59%2C0%20-130%2C-1.5t-148%2C-5t-157%2C-11t-155.5%2C-19t-143.5%2C-28t-122%2C-39.5q-34%2C-14%20-58.5%2C-42t-24.5%2C-67l0%2C-257q0%2C-106%2040.5%2C-199t110%2C-162.5t162.5%2C-109.5t199%2C-40l81%2C0q27%2C0%2052%2C14t50%2C34.5t51%2C44.5t55.5%2C44.5t63.5%2C34.5t74%2C14t74%2C-14t63.5%2C-34.5t55.5%2C-44.5t51%2C-44.5t50%2C-34.5t52%2C-14l14%2C0q37%2C0%2070%2C0.5t64.5%2C4.5t63.5%2C12t68%2C23q71%2C30%20128.5%2C78.5t98.5%2C110t63.5%2C133.5t22.5%2C149l0%2C257z%22%20fill%3D%22white%22%20/%3E%3C/svg%3E%0A":"https://cdn.babylonjs.com/Assets/vrButton.png")+"); background-size: 80%; background-repeat:no-repeat; background-position: center; border: none; outline: none; transition: transform 0.125s ease-out } .babylonVRicon:hover { transform: scale(1.05) } .babylonVRicon:active {background-color: rgba(51,51,51,1) } .babylonVRicon:focus {background-color: rgba(51,51,51,1) }";s+=".babylonVRicon.vrdisplaypresenting { display: none; }";const n=document.createElement("style");n.appendChild(document.createTextNode(s)),document.getElementsByTagName("head")[0].appendChild(n),this._moveButtonToBottomRight()}this._btnVR&&this._btnVR.addEventListener("click",()=>{this.isInVRMode||this.enterVR()});const i=this._scene.getEngine().getHostWindow();i&&(i.addEventListener("resize",this._onResize),document.addEventListener("fullscreenchange",this._onFullscreenChange,!1),t.createFallbackVRDeviceOrientationFreeCamera&&this._displayVRButton(),this._onKeyDown=r=>{r.keyCode===27&&this.isInVRMode&&this.exitVR()},document.addEventListener("keydown",this._onKeyDown),this._scene.onPrePointerObservable.add(()=>{this._hasEnteredVR&&this.exitVROnDoubleTap&&(this.exitVR(),this._fullscreenVRpresenting&&this._scene.getEngine().exitFullscreen())},Be.POINTERDOUBLETAP,!1),e.onDisposeObservable.add(()=>{this.dispose()}),this._updateButtonVisibility(),this._circleEase=new In,this._circleEase.setEasingMode(Ma.EASINGMODE_EASEINOUT),this._teleportationEasing=this._circleEase,e.onPointerObservable.add(r=>{this._interactionsEnabled&&e.activeCamera===this.vrDeviceOrientationCamera&&r.event.pointerType==="mouse"&&(r.type===Be.POINTERDOWN?this._cameraGazer._selectionPointerDown():r.type===Be.POINTERUP&&this._cameraGazer._selectionPointerUp())}),this.webVROptions.floorMeshes&&this.enableTeleportation({floorMeshes:this.webVROptions.floorMeshes}))}get isInVRMode(){return this.xr&&this.webVROptions.useXR&&this.xr.baseExperience.state===2||this._fullscreenVRpresenting}_moveButtonToBottomRight(){if(this._inputElement&&!this._useCustomVRButton&&this._btnVR){const e=this._inputElement.getBoundingClientRect();this._btnVR.style.top=e.top+e.height-70+"px",this._btnVR.style.left=e.left+e.width-100+"px"}}_displayVRButton(){!this._useCustomVRButton&&!this._btnVRDisplayed&&this._btnVR&&(document.body.appendChild(this._btnVR),this._btnVRDisplayed=!0)}_updateButtonVisibility(){!this._btnVR||this._useCustomVRButton||(this._btnVR.className="babylonVRicon",this.isInVRMode&&(this._btnVR.className+=" vrdisplaypresenting"))}enterVR(){if(this.xr){this.xr.baseExperience.enterXRAsync("immersive-vr","local-floor",this.xr.renderTarget);return}if(this.onEnteringVRObservable)try{this.onEnteringVRObservable.notifyObservers(this)}catch(e){L.Warn("Error in your custom logic onEnteringVR: "+e)}this._scene.activeCamera&&(this._position=this._scene.activeCamera.position.clone(),this.vrDeviceOrientationCamera&&(this.vrDeviceOrientationCamera.rotation=re.FromRotationMatrix(this._scene.activeCamera.getWorldMatrix().getRotationMatrix()).toEulerAngles(),this.vrDeviceOrientationCamera.angularSensibility=2e3),this._existingCamera=this._scene.activeCamera,this._existingCamera.angularSensibilityX&&(this._cachedAngularSensibility.angularSensibilityX=this._existingCamera.angularSensibilityX,this._existingCamera.angularSensibilityX=Number.MAX_VALUE),this._existingCamera.angularSensibilityY&&(this._cachedAngularSensibility.angularSensibilityY=this._existingCamera.angularSensibilityY,this._existingCamera.angularSensibilityY=Number.MAX_VALUE),this._existingCamera.angularSensibility&&(this._cachedAngularSensibility.angularSensibility=this._existingCamera.angularSensibility,this._existingCamera.angularSensibility=Number.MAX_VALUE)),this._vrDeviceOrientationCamera&&(this._vrDeviceOrientationCamera.position=this._position,this._scene.activeCamera&&(this._vrDeviceOrientationCamera.minZ=this._scene.activeCamera.minZ),this._scene.activeCamera=this._vrDeviceOrientationCamera,this._scene.getEngine().enterFullscreen(this.requestPointerLockOnFullScreen),this._updateButtonVisibility(),this._vrDeviceOrientationCamera.onViewMatrixChangedObservable.addOnce(()=>{this.onAfterEnteringVRObservable.notifyObservers({success:!0})})),this._scene.activeCamera&&this._inputElement&&this._scene.activeCamera.attachControl(),this._interactionsEnabled&&this._scene.registerBeforeRender(this._beforeRender),this._hasEnteredVR=!0}exitVR(){if(this.xr){this.xr.baseExperience.exitXRAsync();return}if(this._hasEnteredVR){if(this.onExitingVRObservable)try{this.onExitingVRObservable.notifyObservers(this)}catch(e){L.Warn("Error in your custom logic onExitingVR: "+e)}this._scene.activeCamera&&(this._position=this._scene.activeCamera.position.clone()),this.vrDeviceOrientationCamera&&(this.vrDeviceOrientationCamera.angularSensibility=Number.MAX_VALUE),this._deviceOrientationCamera?(this._deviceOrientationCamera.position=this._position,this._scene.activeCamera=this._deviceOrientationCamera,this._cachedAngularSensibility.angularSensibilityX&&(this._deviceOrientationCamera.angularSensibilityX=this._cachedAngularSensibility.angularSensibilityX,this._cachedAngularSensibility.angularSensibilityX=null),this._cachedAngularSensibility.angularSensibilityY&&(this._deviceOrientationCamera.angularSensibilityY=this._cachedAngularSensibility.angularSensibilityY,this._cachedAngularSensibility.angularSensibilityY=null),this._cachedAngularSensibility.angularSensibility&&(this._deviceOrientationCamera.angularSensibility=this._cachedAngularSensibility.angularSensibility,this._cachedAngularSensibility.angularSensibility=null)):this._existingCamera&&(this._existingCamera.position=this._position,this._scene.activeCamera=this._existingCamera,this._inputElement&&this._scene.activeCamera.attachControl(),this._cachedAngularSensibility.angularSensibilityX&&(this._existingCamera.angularSensibilityX=this._cachedAngularSensibility.angularSensibilityX,this._cachedAngularSensibility.angularSensibilityX=null),this._cachedAngularSensibility.angularSensibilityY&&(this._existingCamera.angularSensibilityY=this._cachedAngularSensibility.angularSensibilityY,this._cachedAngularSensibility.angularSensibilityY=null),this._cachedAngularSensibility.angularSensibility&&(this._existingCamera.angularSensibility=this._cachedAngularSensibility.angularSensibility,this._cachedAngularSensibility.angularSensibility=null)),this._updateButtonVisibility(),this._interactionsEnabled&&(this._scene.unregisterBeforeRender(this._beforeRender),this._cameraGazer._gazeTracker.isVisible=!1),this._scene.getEngine().resize(),this._hasEnteredVR=!1}}get position(){return this._position}set position(e){this._position=e,this._scene.activeCamera&&(this._scene.activeCamera.position=e)}enableInteractions(){if(!this._interactionsEnabled){if(this.xr){this.xr.baseExperience.state===2&&this.xr.pointerSelection.attach();return}this.raySelectionPredicate=e=>e.isVisible&&(e.isPickable||e.name===this._floorMeshName),this.meshSelectionPredicate=()=>!0,this._raySelectionPredicate=e=>this._isTeleportationFloor(e)||e.name.indexOf("gazeTracker")===-1&&e.name.indexOf("teleportationTarget")===-1&&e.name.indexOf("torusTeleportation")===-1?this.raySelectionPredicate(e):!1,this._interactionsEnabled=!0}}_isTeleportationFloor(e){for(let t=0;t<this._floorMeshesCollection.length;t++)if(this._floorMeshesCollection[t].id===e.id)return!0;return!!(this._floorMeshName&&e.name===this._floorMeshName)}addFloorMesh(e){this._floorMeshesCollection&&(this._floorMeshesCollection.indexOf(e)>-1||this._floorMeshesCollection.push(e))}removeFloorMesh(e){if(!this._floorMeshesCollection)return;const t=this._floorMeshesCollection.indexOf(e);t!==-1&&this._floorMeshesCollection.splice(t,1)}enableTeleportation(e={}){if(!this._teleportationInitialized){if(this.enableInteractions(),this.webVROptions.useXR&&(e.floorMeshes||e.floorMeshName)){const i=e.floorMeshes||[];if(!i.length){const r=this._scene.getMeshByName(e.floorMeshName);r&&i.push(r)}if(this.xr){i.forEach(r=>{this.xr.teleportation.addFloorMesh(r)}),this.xr.teleportation.attached||this.xr.teleportation.attach();return}else if(!this.xrTestDone){const r=()=>{this.xrTestDone&&(this._scene.unregisterBeforeRender(r),this.xr?this.xr.teleportation.attached||this.xr.teleportation.attach():this.enableTeleportation(e))};this._scene.registerBeforeRender(r);return}}e.floorMeshName&&(this._floorMeshName=e.floorMeshName),e.floorMeshes&&(this._floorMeshesCollection=e.floorMeshes),e.teleportationMode&&(this._teleportationMode=e.teleportationMode),e.teleportationTime&&e.teleportationTime>0&&(this._teleportationTime=e.teleportationTime),e.teleportationSpeed&&e.teleportationSpeed>0&&(this._teleportationSpeed=e.teleportationSpeed),e.easingFunction!==void 0&&(this._teleportationEasing=e.easingFunction);const t=new ts;t.vignetteColor=new xe(0,0,0,0),t.vignetteEnabled=!0,this._teleportationInitialized=!0,this._isDefaultTeleportationTarget&&this._createTeleportationCircles()}}_checkTeleportWithRay(e,t){this._teleportationRequestInitiated&&!t._teleportationRequestInitiated||(t._teleportationRequestInitiated?Math.sqrt(e.y*e.y+e.x*e.x)<this._padSensibilityDown&&(this._teleportActive&&this.teleportCamera(this._haloCenter),t._teleportationRequestInitiated=!1):e.y<-this._padSensibilityUp&&t._dpadPressed&&(t._activatePointer(),t._teleportationRequestInitiated=!0))}_checkRotate(e,t){t._teleportationRequestInitiated||(t._rotationLeftAsked?e.x>-this._padSensibilityDown&&(t._rotationLeftAsked=!1):e.x<-this._padSensibilityUp&&t._dpadPressed&&(t._rotationLeftAsked=!0,this._rotationAllowed&&this._rotateCamera(!1)),t._rotationRightAsked?e.x<this._padSensibilityDown&&(t._rotationRightAsked=!1):e.x>this._padSensibilityUp&&t._dpadPressed&&(t._rotationRightAsked=!0,this._rotationAllowed&&this._rotateCamera(!0)))}_checkTeleportBackwards(e,t){if(!t._teleportationRequestInitiated)if(e.y>this._padSensibilityUp&&t._dpadPressed){if(!t._teleportationBackRequestInitiated){if(!this.currentVRCamera)return;const i=re.FromRotationMatrix(this.currentVRCamera.getWorldMatrix().getRotationMatrix()),r=this.currentVRCamera.position;i.toEulerAnglesToRef(this._workingVector),this._workingVector.z=0,this._workingVector.x=0,re.RotationYawPitchRollToRef(this._workingVector.y,this._workingVector.x,this._workingVector.z,this._workingQuaternion),this._workingQuaternion.toRotationMatrix(this._workingMatrix),m.TransformCoordinatesToRef(this._teleportBackwardsVector,this._workingMatrix,this._workingVector);const s=new Zt(r,this._workingVector),n=this._scene.pickWithRay(s,this._raySelectionPredicate);n&&n.pickedPoint&&n.pickedMesh&&this._isTeleportationFloor(n.pickedMesh)&&n.distance<5&&this.teleportCamera(n.pickedPoint),t._teleportationBackRequestInitiated=!0}}else t._teleportationBackRequestInitiated=!1}_createTeleportationCircles(){this._teleportationTarget=ol("teleportationTarget",{width:2,height:2,subdivisions:2},this._scene),this._teleportationTarget.isPickable=!1;const e=512,t=new Is("DynamicTexture",e,this._scene,!0);t.hasAlpha=!0;const i=t.getContext(),r=e/2,s=e/2,n=200;i.beginPath(),i.arc(r,s,n,0,2*Math.PI,!1),i.fillStyle=this._teleportationFillColor,i.fill(),i.lineWidth=10,i.strokeStyle=this._teleportationBorderColor,i.stroke(),i.closePath(),t.update();const o=new Ut("TextPlaneMaterial",this._scene);o.diffuseTexture=t,this._teleportationTarget.material=o;const l=fs("torusTeleportation",{diameter:.75,thickness:.1,tessellation:25,updatable:!1},this._scene);l.isPickable=!1,l.parent=this._teleportationTarget;const u=new Le("animationInnerCircle","position.y",30,Le.ANIMATIONTYPE_FLOAT,Le.ANIMATIONLOOPMODE_CYCLE),c=[];c.push({frame:0,value:0}),c.push({frame:30,value:.4}),c.push({frame:60,value:0}),u.setKeys(c);const h=new vs;h.setEasingMode(Ma.EASINGMODE_EASEINOUT),u.setEasingFunction(h),l.animations=[],l.animations.push(u),this._scene.beginAnimation(l,0,60,!0),this._hideTeleportationTarget()}_hideTeleportationTarget(){this._teleportActive=!1,this._teleportationInitialized&&(this._teleportationTarget.isVisible=!1,this._isDefaultTeleportationTarget&&(this._teleportationTarget.getChildren()[0].isVisible=!1))}_rotateCamera(e){if(!(this.currentVRCamera instanceof Ms))return;e?this._rotationAngle++:this._rotationAngle--,this.currentVRCamera.animations=[];const t=re.FromRotationMatrix($.RotationY(Math.PI/4*this._rotationAngle)),i=new Le("animationRotation","rotationQuaternion",90,Le.ANIMATIONTYPE_QUATERNION,Le.ANIMATIONLOOPMODE_CONSTANT),r=[];r.push({frame:0,value:this.currentVRCamera.rotationQuaternion}),r.push({frame:6,value:t}),i.setKeys(r),i.setEasingFunction(this._circleEase),this.currentVRCamera.animations.push(i),this._postProcessMove.animations=[];const s=new Le("animationPP","vignetteWeight",90,Le.ANIMATIONTYPE_FLOAT,Le.ANIMATIONLOOPMODE_CONSTANT),n=[];n.push({frame:0,value:0}),n.push({frame:3,value:4}),n.push({frame:6,value:0}),s.setKeys(n),s.setEasingFunction(this._circleEase),this._postProcessMove.animations.push(s);const o=new Le("animationPP2","vignetteStretch",90,Le.ANIMATIONTYPE_FLOAT,Le.ANIMATIONLOOPMODE_CONSTANT),l=[];l.push({frame:0,value:0}),l.push({frame:3,value:10}),l.push({frame:6,value:0}),o.setKeys(l),o.setEasingFunction(this._circleEase),this._postProcessMove.animations.push(o),this._postProcessMove.imageProcessingConfiguration.vignetteWeight=0,this._postProcessMove.imageProcessingConfiguration.vignetteStretch=0,this._postProcessMove.samples=4,this._scene.beginAnimation(this.currentVRCamera,0,6,!1,1)}teleportCamera(e){if(!(this.currentVRCamera instanceof Ms))return;this._workingVector.copyFrom(e),this.isInVRMode||(this._workingVector.y+=this._defaultHeight),this.onBeforeCameraTeleport.notifyObservers(this._workingVector);const t=90;let i,r;if(this._teleportationMode==wa.TELEPORTATIONMODE_CONSTANTSPEED){r=t;const d=m.Distance(this.currentVRCamera.position,this._workingVector);i=this._teleportationSpeed/d}else r=Math.round(this._teleportationTime*t/1e3),i=1;this.currentVRCamera.animations=[];const s=new Le("animationCameraTeleportation","position",t,Le.ANIMATIONTYPE_VECTOR3,Le.ANIMATIONLOOPMODE_CONSTANT),n=[{frame:0,value:this.currentVRCamera.position},{frame:r,value:this._workingVector}];s.setKeys(n),s.setEasingFunction(this._teleportationEasing),this.currentVRCamera.animations.push(s),this._postProcessMove.animations=[];const o=Math.round(r/2),l=new Le("animationPP","vignetteWeight",t,Le.ANIMATIONTYPE_FLOAT,Le.ANIMATIONLOOPMODE_CONSTANT),u=[];u.push({frame:0,value:0}),u.push({frame:o,value:8}),u.push({frame:r,value:0}),l.setKeys(u),this._postProcessMove.animations.push(l);const c=new Le("animationPP2","vignetteStretch",t,Le.ANIMATIONTYPE_FLOAT,Le.ANIMATIONLOOPMODE_CONSTANT),h=[];h.push({frame:0,value:0}),h.push({frame:o,value:10}),h.push({frame:r,value:0}),c.setKeys(h),this._postProcessMove.animations.push(c),this._postProcessMove.imageProcessingConfiguration.vignetteWeight=0,this._postProcessMove.imageProcessingConfiguration.vignetteStretch=0,this._scene.beginAnimation(this.currentVRCamera,0,r,!1,i,()=>{this.onAfterCameraTeleport.notifyObservers(this._workingVector)}),this._hideTeleportationTarget()}setLaserColor(e,t=this._pickedLaserColor){this._pickedLaserColor=t}setLaserLightingState(e=!0){}setGazeColor(e,t=this._pickedGazeColor){this._pickedGazeColor=t}changeLaserColor(e){this.updateControllerLaserColor}changeGazeColor(e){this.updateGazeTrackerColor&&this._cameraGazer._gazeTracker.material&&(this._cameraGazer._gazeTracker.material.emissiveColor=e)}dispose(){this.isInVRMode&&this.exitVR(),this._postProcessMove&&this._postProcessMove.dispose(),this._vrDeviceOrientationCamera&&this._vrDeviceOrientationCamera.dispose(),!this._useCustomVRButton&&this._btnVR&&this._btnVR.parentNode&&document.body.removeChild(this._btnVR),this._deviceOrientationCamera&&this._scene.activeCamera!=this._deviceOrientationCamera&&this._deviceOrientationCamera.dispose(),this._cameraGazer&&this._cameraGazer.dispose(),this._teleportationTarget&&this._teleportationTarget.dispose(),this.xr&&this.xr.dispose(),this._floorMeshesCollection.length=0,document.removeEventListener("keydown",this._onKeyDown),window.removeEventListener("vrdisplaypresentchange",this._onVrDisplayPresentChangeBind),window.removeEventListener("resize",this._onResize),document.removeEventListener("fullscreenchange",this._onFullscreenChange),this._scene.gamepadManager.onGamepadConnectedObservable.removeCallback(this._onNewGamepadConnected),this._scene.unregisterBeforeRender(this._beforeRender)}getClassName(){return"VRExperienceHelper"}}wa.TELEPORTATIONMODE_CONSTANTTIME=0;wa.TELEPORTATIONMODE_CONSTANTSPEED=1;const TD=(a,e,t,i)=>!(a.x>t.x+i||t.x-i>e.x||a.y>t.y+i||t.y-i>e.y||a.z>t.z+i||t.z-i>e.z),ha=function(){const a={root:0,found:!1};return function(e,t,i,r){a.root=0,a.found=!1;const s=t*t-4*e*i;if(s<0)return a;const n=Math.sqrt(s);let o=(-t-n)/(2*e),l=(-t+n)/(2*e);if(o>l){const u=l;l=o,o=u}return o>0&&o<r?(a.root=o,a.found=!0,a):(l>0&&l<r&&(a.root=l,a.found=!0),a)}}();class Du{constructor(){this._collisionPoint=m.Zero(),this._planeIntersectionPoint=m.Zero(),this._tempVector=m.Zero(),this._tempVector2=m.Zero(),this._tempVector3=m.Zero(),this._tempVector4=m.Zero(),this._edge=m.Zero(),this._baseToVertex=m.Zero(),this._destinationPoint=m.Zero(),this._slidePlaneNormal=m.Zero(),this._displacementVector=m.Zero(),this._radius=m.One(),this._retry=0,this._basePointWorld=m.Zero(),this._velocityWorld=m.Zero(),this._normalizedVelocity=m.Zero(),this._collisionMask=-1}get collisionMask(){return this._collisionMask}set collisionMask(e){this._collisionMask=isNaN(e)?-1:e}get slidePlaneNormal(){return this._slidePlaneNormal}_initialize(e,t,i){this._velocity=t,this._velocitySquaredLength=this._velocity.lengthSquared();const r=Math.sqrt(this._velocitySquaredLength);r===0||r===1?this._normalizedVelocity.copyFromFloats(t._x,t._y,t._z):t.scaleToRef(1/r,this._normalizedVelocity),this._basePoint=e,e.multiplyToRef(this._radius,this._basePointWorld),t.multiplyToRef(this._radius,this._velocityWorld),this._velocityWorldLength=this._velocityWorld.length(),this._epsilon=i,this.collisionFound=!1}_checkPointInTriangle(e,t,i,r,s){t.subtractToRef(e,this._tempVector),i.subtractToRef(e,this._tempVector2),m.CrossToRef(this._tempVector,this._tempVector2,this._tempVector4);let n=m.Dot(this._tempVector4,s);return n<0||(r.subtractToRef(e,this._tempVector3),m.CrossToRef(this._tempVector2,this._tempVector3,this._tempVector4),n=m.Dot(this._tempVector4,s),n<0)?!1:(m.CrossToRef(this._tempVector3,this._tempVector,this._tempVector4),n=m.Dot(this._tempVector4,s),n>=0)}_canDoCollision(e,t,i,r){const s=m.Distance(this._basePointWorld,e),n=Math.max(this._radius.x,this._radius.y,this._radius.z);return!(s>this._velocityWorldLength+n+t||!TD(i,r,this._basePointWorld,this._velocityWorldLength+n))}_testTriangle(e,t,i,r,s,n,o){let l,u=!1;t||(t=[]),t[e]||(t[e]=new ko(0,0,0,0),t[e].copyFromPoints(i,r,s));const c=t[e];if(!n&&!c.isFrontFacingTo(this._normalizedVelocity,0))return;const h=c.signedDistanceTo(this._basePoint),d=m.Dot(c.normal,this._velocity);if(Du.DoubleSidedCheck&&d>1e-4)return;if(d==0){if(Math.abs(h)>=1)return;u=!0,l=0}else{l=(-1-h)/d;let g=(1-h)/d;if(l>g){const _=g;g=l,l=_}if(l>1||g<0)return;l<0&&(l=0),l>1&&(l=1)}this._collisionPoint.copyFromFloats(0,0,0);let f=!1,p=1;if(u||(this._basePoint.subtractToRef(c.normal,this._planeIntersectionPoint),this._velocity.scaleToRef(l,this._tempVector),this._planeIntersectionPoint.addInPlace(this._tempVector),this._checkPointInTriangle(this._planeIntersectionPoint,i,r,s,c.normal)&&(f=!0,p=l,this._collisionPoint.copyFrom(this._planeIntersectionPoint))),!f){let g=this._velocitySquaredLength;this._basePoint.subtractToRef(i,this._tempVector);let _=2*m.Dot(this._velocity,this._tempVector),S=this._tempVector.lengthSquared()-1,b=ha(g,_,S,p);b.found&&(p=b.root,f=!0,this._collisionPoint.copyFrom(i)),this._basePoint.subtractToRef(r,this._tempVector),_=2*m.Dot(this._velocity,this._tempVector),S=this._tempVector.lengthSquared()-1,b=ha(g,_,S,p),b.found&&(p=b.root,f=!0,this._collisionPoint.copyFrom(r)),this._basePoint.subtractToRef(s,this._tempVector),_=2*m.Dot(this._velocity,this._tempVector),S=this._tempVector.lengthSquared()-1,b=ha(g,_,S,p),b.found&&(p=b.root,f=!0,this._collisionPoint.copyFrom(s)),r.subtractToRef(i,this._edge),i.subtractToRef(this._basePoint,this._baseToVertex);let y=this._edge.lengthSquared(),T=m.Dot(this._edge,this._velocity),v=m.Dot(this._edge,this._baseToVertex);if(g=y*-this._velocitySquaredLength+T*T,_=2*(y*m.Dot(this._velocity,this._baseToVertex)-T*v),S=y*(1-this._baseToVertex.lengthSquared())+v*v,b=ha(g,_,S,p),b.found){const E=(T*b.root-v)/y;E>=0&&E<=1&&(p=b.root,f=!0,this._edge.scaleInPlace(E),i.addToRef(this._edge,this._collisionPoint))}if(s.subtractToRef(r,this._edge),r.subtractToRef(this._basePoint,this._baseToVertex),y=this._edge.lengthSquared(),T=m.Dot(this._edge,this._velocity),v=m.Dot(this._edge,this._baseToVertex),g=y*-this._velocitySquaredLength+T*T,_=2*(y*m.Dot(this._velocity,this._baseToVertex)-T*v),S=y*(1-this._baseToVertex.lengthSquared())+v*v,b=ha(g,_,S,p),b.found){const E=(T*b.root-v)/y;E>=0&&E<=1&&(p=b.root,f=!0,this._edge.scaleInPlace(E),r.addToRef(this._edge,this._collisionPoint))}if(i.subtractToRef(s,this._edge),s.subtractToRef(this._basePoint,this._baseToVertex),y=this._edge.lengthSquared(),T=m.Dot(this._edge,this._velocity),v=m.Dot(this._edge,this._baseToVertex),g=y*-this._velocitySquaredLength+T*T,_=2*(y*m.Dot(this._velocity,this._baseToVertex)-T*v),S=y*(1-this._baseToVertex.lengthSquared())+v*v,b=ha(g,_,S,p),b.found){const E=(T*b.root-v)/y;E>=0&&E<=1&&(p=b.root,f=!0,this._edge.scaleInPlace(E),s.addToRef(this._edge,this._collisionPoint))}}if(f){const g=p*p*this._velocitySquaredLength;(!this.collisionFound||g<this._nearestDistanceSquared)&&(o.collisionResponse&&(this.intersectionPoint?this.intersectionPoint.copyFrom(this._collisionPoint):this.intersectionPoint=this._collisionPoint.clone(),this._nearestDistanceSquared=g,this._nearestDistance=Math.sqrt(g),this.collisionFound=!0),this.collidedMesh=o)}}_collide(e,t,i,r,s,n,o,l,u,c=!1){if(c)if(!i||i.length===0)for(let h=0;h<t.length-2;h+=1){const d=t[h],f=t[h+1],p=t[h+2];!d||!f||!p||((u?1:0)^h%2?this._testTriangle(h,e,d,f,p,o,l):this._testTriangle(h,e,f,d,p,o,l))}else for(let h=r;h<s-2;h+=1){const d=i[h],f=i[h+1],p=i[h+2];if(p===4294967295){h+=2;continue}const g=t[d],_=t[f],S=t[p];!g||!_||!S||((u?1:0)^h%2?this._testTriangle(h,e,g,_,S,o,l):this._testTriangle(h,e,_,g,S,o,l))}else if(!i||i.length===0)for(let h=0;h<t.length;h+=3){const d=t[h],f=t[h+1],p=t[h+2];u?this._testTriangle(h,e,d,f,p,o,l):this._testTriangle(h,e,p,f,d,o,l)}else for(let h=r;h<s;h+=3){const d=t[i[h]-n],f=t[i[h+1]-n],p=t[i[h+2]-n];u?this._testTriangle(h,e,d,f,p,o,l):this._testTriangle(h,e,p,f,d,o,l)}}_getResponse(e,t){e.addToRef(t,this._destinationPoint),t.scaleInPlace(this._nearestDistance/t.length()),this._basePoint.addToRef(t,e),e.subtractToRef(this.intersectionPoint,this._slidePlaneNormal),this._slidePlaneNormal.normalize(),this._slidePlaneNormal.scaleToRef(this._epsilon,this._displacementVector),e.addInPlace(this._displacementVector),this.intersectionPoint.addInPlace(this._displacementVector),this._slidePlaneNormal.scaleInPlace(ko.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint,this._slidePlaneNormal,this._destinationPoint)),this._destinationPoint.subtractInPlace(this._slidePlaneNormal),this._destinationPoint.subtractToRef(this.intersectionPoint,t)}}Du.DoubleSidedCheck=!1;class CD{constructor(){this._scaledPosition=m.Zero(),this._scaledVelocity=m.Zero(),this._finalPosition=m.Zero()}getNewPosition(e,t,i,r,s,n,o){e.divideToRef(i._radius,this._scaledPosition),t.divideToRef(i._radius,this._scaledVelocity),i.collidedMesh=null,i._retry=0,i._initialVelocity=this._scaledVelocity,i._initialPosition=this._scaledPosition,this._collideWithWorld(this._scaledPosition,this._scaledVelocity,i,r,this._finalPosition,s),this._finalPosition.multiplyInPlace(i._radius),n(o,this._finalPosition,i.collidedMesh)}createCollider(){return new Du}init(e){this._scene=e}_collideWithWorld(e,t,i,r,s,n=null){const o=st.CollisionsEpsilon*10;if(i._retry>=r){s.copyFrom(e);return}const l=n?n.collisionMask:i.collisionMask;i._initialize(e,t,o);const u=n&&n.surroundingMeshes||this._scene.meshes;for(let c=0;c<u.length;c++){const h=u[c];h.isEnabled()&&h.checkCollisions&&h.subMeshes&&h!==n&&l&h.collisionGroup&&h._checkCollision(i)}if(!i.collisionFound){e.addToRef(t,s);return}if((t.x!==0||t.y!==0||t.z!==0)&&i._getResponse(e,t),t.length()<=o){s.copyFrom(e);return}i._retry++,this._collideWithWorld(e,t,i,r,s,n)}}Te.CollisionCoordinatorFactory=()=>new CD;class Bt{constructor(){this._pickingTexture=null,this._idMap=[],this._thinIdMap=[],this._idColors=[],this._meshMaterialMap=new Map,this._meshRenderingCount=0,this._attributeName="instanceMeshID",this._shaderLanguage=0,this._pickingInProgress=!1}get shaderLanguage(){return this._shaderLanguage}get pickingInProgress(){return this._pickingInProgress}static _IdToRgb(e){Bt._TempColor.r=(e&16711680)>>16,Bt._TempColor.g=(e&65280)>>8,Bt._TempColor.b=(e&255)>>0}_getColorIdFromReadBuffer(e){const t=this._readbuffer[e],i=this._readbuffer[e+1],r=this._readbuffer[e+2];return(t<<16)+(i<<8)+r}static _SetColorData(e,t,i,r,s){e[t]=i/255,e[t+1]=r/255,e[t+2]=s/255,e[t+3]=1}_createRenderTarget(e,t,i){this._pickingTexture&&this._pickingTexture.dispose(),this._pickingTexture=new Kt("pickingTexure",{width:t,height:i},e,!1,void 0,0,!1,1)}async _createColorMaterialAsync(e){this._defaultRenderMaterial&&this._defaultRenderMaterial.dispose(),this._defaultRenderMaterial=null,e.getEngine().isWebGPU&&(this._shaderLanguage=1);const i=[],r={attributes:[N.PositionKind,this._attributeName,"bakedVertexAnimationSettingsInstanced"],uniforms:["world","viewProjection","meshID"],needAlphaBlending:!1,defines:i,useClipPlane:null,shaderLanguage:this._shaderLanguage,extraInitializationsAsync:async()=>{this.shaderLanguage===1?await Promise.all([k(()=>Promise.resolve().then(()=>AD),void 0),k(()=>Promise.resolve().then(()=>OD),void 0)]):await Promise.all([k(()=>Promise.resolve().then(()=>ED),void 0),k(()=>Promise.resolve().then(()=>RD),void 0)])}};this._defaultRenderMaterial=new Wr("pickingShader",e,"picking",r,!1),this._defaultRenderMaterial.onBindObservable.add(this._materialBindCallback,void 0,void 0,this)}_materialBindCallback(e){if(!e)return;const i=this._meshMaterialMap.get(e).getEffect();!e.hasInstances&&!e.isAnInstance&&!e.hasThinInstances&&i.setColor4("meshID",this._idColors[e.uniqueId],1),this._meshRenderingCount++}_generateColorData(e,t,i,r,s,n,o){const l=new Float32Array(4*(e+1));Bt._SetColorData(l,0,r,s,n);for(let u=0;u<e;u++)Bt._IdToRgb(t),o(u,t),Bt._SetColorData(l,(u+1)*4,Bt._TempColor.r,Bt._TempColor.g,Bt._TempColor.b),t++;return l}_generateThinInstanceColorData(e,t,i){const r=new Float32Array(4*e);for(let s=0;s<e;s++)Bt._IdToRgb(t),i(s,t),Bt._SetColorData(r,s*4,Bt._TempColor.r,Bt._TempColor.g,Bt._TempColor.b),t++;return r}setPickingList(e){if(this._pickableMeshes){for(let o=0;o<this._pickableMeshes.length;o++){const l=this._pickableMeshes[o];l.hasInstances&&l.removeVerticesData(this._attributeName),l.hasThinInstances&&l.thinInstanceSetBuffer(this._attributeName,null),this._pickingTexture&&this._pickingTexture.setMaterialForRendering(l,void 0);const u=this._meshMaterialMap.get(l);u!==this._defaultRenderMaterial&&u.onBindObservable.removeCallback(this._materialBindCallback)}this._pickableMeshes.length=0,this._meshMaterialMap.clear(),this._idMap.length=0,this._thinIdMap.length=0,this._idColors.length=0,this._pickingTexture&&(this._pickingTexture.renderList=[])}if(!e||e.length===0)return;this._pickableMeshes=e;const t=("mesh"in e[0]?e[0].mesh:e[0]).getScene(),i=t.getEngine(),r=i.getRenderWidth(),s=i.getRenderHeight();if(!this._pickingTexture)this._createRenderTarget(t,r,s);else{const o=this._pickingTexture.getSize();(o.width!==r||o.height!==s||this._cachedScene!==t)&&this._createRenderTarget(t,r,s)}(!this._cachedScene||this._cachedScene!==t)&&this._createColorMaterialAsync(t),this._cachedScene=t,this._engine=t.getEngine();for(let o=0;o<e.length;o++){const l=e[o];"mesh"in l?(this._meshMaterialMap.set(l.mesh,l.material),e[o]=l.mesh):this._meshMaterialMap.set(l,this._defaultRenderMaterial)}this._pickingTexture.renderList=[];let n=1;for(let o=0;o<this._pickableMeshes.length;o++){const l=this._pickableMeshes[o],u=this._meshMaterialMap.get(l);if(u!==this._defaultRenderMaterial&&u.onBindObservable.add(this._materialBindCallback,void 0,void 0,this),this._pickingTexture.setMaterialForRendering(l,u),this._pickingTexture.renderList.push(l),!l.isAnInstance)if(Bt._IdToRgb(n),l.hasThinInstances){const c=this._generateThinInstanceColorData(l.thinInstanceCount,n,(h,d)=>{this._thinIdMap[d]={meshId:o,thinId:h}});n+=l.thinInstanceCount,l.thinInstanceSetBuffer(this._attributeName,c,4)}else if(this._idMap[n]=o,n++,l.hasInstances){const c=l.instances,h=this._generateColorData(c.length,n,o,Bt._TempColor.r,Bt._TempColor.g,Bt._TempColor.b,(p,g)=>{const _=c[p];this._idMap[g]=this._pickableMeshes.indexOf(_)});n+=c.length;const d=l.getEngine(),f=new N(d,h,this._attributeName,!1,!1,4,!0);l.setVerticesBuffer(f,!0)}else this._idColors[l.uniqueId]=ne.FromInts(Bt._TempColor.r,Bt._TempColor.g,Bt._TempColor.b)}}async pickAsync(e,t,i=!1){if(this._pickingInProgress||!this._pickableMeshes||this._pickableMeshes.length===0)return null;const{x:r,y:s,rttSizeW:n,rttSizeH:o}=this._prepareForPicking(e,t);if(r<0||s<0||r>=n||s>=o)return null;this._pickingInProgress=!0;const l=o-s-1;return this._preparePickingBuffer(this._engine,n,o,r,l),this._executePicking(r,l,i)}async multiPickAsync(e,t=!1){if(this._pickingInProgress||!this._pickableMeshes||this._pickableMeshes.length===0||e.length===0)return null;if(e.length===1){const d=await this.pickAsync(e[0].x,e[0].y,t);return{meshes:[(d==null?void 0:d.mesh)??null],thinInstanceIndexes:d!=null&&d.thinInstanceIndex?[d.thinInstanceIndex]:void 0}}this._pickingInProgress=!0;let i=e[0].x,r=e[0].x,s=e[0].y,n=e[0].y;for(let d=1;d<e.length;d++){const{x:f,y:p}=e[d];i=Math.min(i,f),r=Math.max(r,f),s=Math.min(s,p),n=Math.max(n,p)}const{rttSizeW:o,rttSizeH:l}=this._prepareForPicking(i,s),u=Math.max(r-i,1),c=Math.max(n-s,1),h=l-n-1;return this._preparePickingBuffer(this._engine,o,l,i,h,u,c),this._executeMultiPicking(e,i,n,l,u,c,t)}_prepareForPicking(e,t){const r=this._cachedScene.getEngine(),s=r.getRenderWidth(),n=r.getRenderHeight(),o=1/r._hardwareScalingLevel,l=o*e>>0,u=o*t>>0;return{x:l,y:u,rttSizeW:s,rttSizeH:n}}_preparePickingBuffer(e,t,i,r,s,n=1,o=1){this._meshRenderingCount=0;const l=e.isWebGPU?4*n*o+255&-256:4*n*o;(!this._readbuffer||this._readbuffer.length<l)&&(this._readbuffer=new Uint8Array(l));const u=this._pickingTexture.getSize();(u.width!==t||u.height!==i)&&(this._createRenderTarget(this._cachedScene,t,i),this._updateRenderList()),this._pickingTexture.clearColor=new xe(0,0,0,0),this._pickingTexture.onBeforeRender=()=>{this._enableScissor(r,s,n,o)},this._cachedScene.customRenderTargets.push(this._pickingTexture)}_executePicking(e,t,i){return new Promise((r,s)=>{if(!this._pickingTexture){this._pickingInProgress=!1,s();return}this._pickingTexture.onAfterRender=async()=>{if(this._disableScissor(),this._checkRenderStatus()){this._pickingTexture.onAfterRender=null;let n=null,o;const l=this._cachedScene.customRenderTargets.indexOf(this._pickingTexture);if(l>-1&&this._cachedScene.customRenderTargets.splice(l,1),await this._readTexturePixelsAsync(e,t)){const u=this._getColorIdFromReadBuffer(0);this._thinIdMap[u]?(n=this._pickableMeshes[this._thinIdMap[u].meshId],o=this._thinIdMap[u].thinId):n=this._pickableMeshes[this._idMap[u]]}i&&this.dispose(),this._pickingInProgress=!1,r(n?{mesh:n,thinInstanceIndex:o}:null)}}})}_executeMultiPicking(e,t,i,r,s,n,o){return new Promise((l,u)=>{if(!this._pickingTexture){this._pickingInProgress=!1,u();return}this._pickingTexture.onAfterRender=async()=>{if(this._disableScissor(),this._checkRenderStatus()){this._pickingTexture.onAfterRender=null;const c=[],h=[];if(await this._readTexturePixelsAsync(t,r-i-1,s,n))for(let d=0;d<e.length;d++){const{pickedMesh:f,thinInstanceIndex:p}=this._getMeshFromMultiplePoints(e[d].x,e[d].y,t,i,s);c.push(f),h.push(p??0)}o&&this.dispose(),this._pickingInProgress=!1,l({meshes:c,thinInstanceIndexes:h})}}})}_enableScissor(e,t,i=1,r=1){this._engine.enableScissor&&this._engine.enableScissor(e,t,i,r)}_disableScissor(){this._engine.disableScissor&&this._engine.disableScissor()}_checkRenderStatus(){if(this._meshRenderingCount>0){const t=this._cachedScene.customRenderTargets.indexOf(this._pickingTexture);return t>-1&&this._cachedScene.customRenderTargets.splice(t,1),!0}return this._meshRenderingCount=0,!1}_getMeshFromMultiplePoints(e,t,i,r,s){let n=(e-i-1)*4,o=(r-t-1)*s*4;n=Math.max(n,0),o=Math.max(o,0);const l=this._getColorIdFromReadBuffer(n+o);let u=null,c;return l>0&&(this._thinIdMap[l]?(u=this._pickableMeshes[this._thinIdMap[l].meshId],c=this._thinIdMap[l].thinId):u=this._pickableMeshes[this._idMap[l]]),{pickedMesh:u,thinInstanceIndex:c}}_updateRenderList(){this._pickingTexture.renderList=[];for(const e of this._pickableMeshes)this._pickingTexture.setMaterialForRendering(e,this._meshMaterialMap.get(e)),this._pickingTexture.renderList.push(e)}async _readTexturePixelsAsync(e,t,i=1,r=1){var n;return!this._cachedScene||!((n=this._pickingTexture)!=null&&n._texture)?!1:(await this._cachedScene.getEngine()._readTexturePixels(this._pickingTexture._texture,i,r,-1,0,this._readbuffer,!0,!0,e,t),!0)}dispose(){var e,t;this.setPickingList(null),this._cachedScene=null,(e=this._pickingTexture)==null||e.dispose(),this._pickingTexture=null,(t=this._defaultRenderMaterial)==null||t.dispose(),this._defaultRenderMaterial=null}}Bt._TempColor={r:0,g:0,b:0};const th="pickingPixelShader",Jy=`#if defined(INSTANCES)
varying vec4 vMeshID;
#else
uniform vec4 meshID;
#endif
void main(void) {
#if defined(INSTANCES)
gl_FragColor=vMeshID;
#else
gl_FragColor=meshID;
#endif
}`;P.ShadersStore[th]||(P.ShadersStore[th]=Jy);const PD={name:th,shader:Jy},ED=Object.freeze(Object.defineProperty({__proto__:null,pickingPixelShader:PD},Symbol.toStringTag,{value:"Module"})),ih="pickingVertexShader",e0=`attribute vec3 position;
#if defined(INSTANCES)
attribute vec4 instanceMeshID;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<instancesDeclaration>
uniform mat4 viewProjection;
#if defined(INSTANCES)
varying vec4 vMeshID;
#endif
void main(void) {
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);gl_Position=viewProjection*worldPos;
#if defined(INSTANCES)
vMeshID=instanceMeshID;
#endif
}`;P.ShadersStore[ih]||(P.ShadersStore[ih]=e0);const ID={name:ih,shader:e0},RD=Object.freeze(Object.defineProperty({__proto__:null,pickingVertexShader:ID},Symbol.toStringTag,{value:"Module"})),rh="pickingPixelShader",t0=`#if defined(INSTANCES)
varying vMeshID: vec4f;
#else
uniform meshID: vec4f;
#endif
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#if defined(INSTANCES)
fragmentOutputs.color=input.vMeshID;
#else
fragmentOutputs.color=uniforms.meshID;
#endif
}`;P.ShadersStoreWGSL[rh]||(P.ShadersStoreWGSL[rh]=t0);const MD={name:rh,shader:t0},AD=Object.freeze(Object.defineProperty({__proto__:null,pickingPixelShaderWGSL:MD},Symbol.toStringTag,{value:"Module"})),sh="pickingVertexShader",i0=`attribute position: vec3f;
#if defined(INSTANCES)
attribute instanceMeshID: vec4f;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<instancesDeclaration>
uniform viewProjection: mat4x4f;
#if defined(INSTANCES)
varying vMeshID: vec4f;
#endif
@vertex
fn main(input : VertexInputs)->FragmentInputs {
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
var worldPos: vec4f=finalWorld*vec4f(input.position,1.0);vertexOutputs.position=uniforms.viewProjection*worldPos;
#if defined(INSTANCES)
vertexOutputs.vMeshID=input.instanceMeshID;
#endif
}`;P.ShadersStoreWGSL[sh]||(P.ShadersStoreWGSL[sh]=i0);const DD={name:sh,shader:i0},OD=Object.freeze(Object.defineProperty({__proto__:null,pickingVertexShaderWGSL:DD},Symbol.toStringTag,{value:"Module"}));class Na{constructor(e,t,i,r=""){this.defines="",this.onCompiled=null,this.onError=null,this.uniqueId=0,this.onCompileObservable=new j,this.onErrorObservable=new j,this.onBindObservable=new j,this._wasPreviouslyReady=!1,this._isReady=!1,this._compilationError="",this._key="",this._computeSourceCodeOverride="",this._pipelineContext=null,this._computeSourceCode="",this._rawComputeSourceCode="",this._shaderLanguage=1,this.name=e,this._key=r,this._engine=i,this.uniqueId=Na._UniqueIdSeed++,this.defines=t.defines??"",this.onError=t.onError,this.onCompiled=t.onCompiled,this._entryPoint=t.entryPoint??"main",this._shaderStore=P.GetShadersStore(this._shaderLanguage),this._shaderRepository=P.GetShadersRepository(this._shaderLanguage),this._includeShaderStore=P.GetIncludesShadersStore(this._shaderLanguage);let s;const n=Om()?this._engine.getHostDocument():null;typeof e=="string"?s=e:e.computeSource?s="source:"+e.computeSource:e.computeElement?s=(n==null?void 0:n.getElementById(e.computeElement))||e.computeElement:s=e.compute||e;const o={defines:this.defines.split(`
`),indexParameters:void 0,isFragment:!1,shouldUseHighPrecisionShader:!1,processor:null,supportsUniformBuffers:this._engine.supportsUniformBuffers,shadersRepository:this._shaderRepository,includesShadersStore:this._includeShaderStore,version:(this._engine.version*100).toString(),platformName:this._engine.shaderPlatformName,processingContext:null,isNDCHalfZRange:this._engine.isNDCHalfZRange,useReverseDepthBuffer:this._engine.useReverseDepthBuffer,processCodeAfterIncludes:(l,u,c)=>{if(!c)return u;for(const h of c){const f=h.replace("#define","").replace(";","").trim().split(" ");if(f.length===2){const p=f[0],g=f[1];(!isNaN(parseInt(g))||!isNaN(parseFloat(g)))&&(u=`const ${p} = ${g};
`+u)}}return u}};this._loadShader(s,"Compute","",l=>{Kb(o),OR(l,o,u=>{this._rawComputeSourceCode=l,t.processFinalCode&&(u=t.processFinalCode(u));const c=Qb(u,"",o);this._useFinalCode(c.vertexCode,e)},this._engine)})}_useFinalCode(e,t){if(t){const i=t.computeElement||t.compute||t.spectorName||t;this._computeSourceCode="//#define SHADER_NAME compute:"+i+`
`+e}else this._computeSourceCode=e;this._prepareEffect()}get key(){return this._key}isReady(){try{return this._isReadyInternal()}catch{return!1}}_isReadyInternal(){return this._isReady?!0:this._pipelineContext?this._pipelineContext.isReady:!1}getEngine(){return this._engine}getPipelineContext(){return this._pipelineContext}getCompilationError(){return this._compilationError}executeWhenCompiled(e){if(this.isReady()){e(this);return}this.onCompileObservable.add(t=>{e(t)}),(!this._pipelineContext||this._pipelineContext.isAsync)&&this._checkIsReady(null)}_checkIsReady(e){du(()=>this._isReadyInternal(),()=>{},t=>{this._processCompilationErrors(t,e)},void 0,void 0,!1)}_loadShader(e,t,i,r){if(typeof HTMLElement<"u"&&e instanceof HTMLElement){const n=wR(e);r(n);return}if(e.substring(0,7)==="source:"){r(e.substring(7));return}if(e.substring(0,7)==="base64:"){const n=window.atob(e.substring(7));r(n);return}if(this._shaderStore[e+t+"Shader"]){r(this._shaderStore[e+t+"Shader"]);return}if(i&&this._shaderStore[e+i+"Shader"]){r(this._shaderStore[e+i+"Shader"]);return}let s;e[0]==="."||e[0]==="/"||e.indexOf("http")>-1?s=e:s=this._shaderRepository+e,this._engine._loadFile(s+"."+t.toLowerCase()+".fx",r)}get computeSourceCode(){var e;return this._computeSourceCodeOverride?this._computeSourceCodeOverride:((e=this._pipelineContext)==null?void 0:e._getComputeShaderCode())??this._computeSourceCode}get rawComputeSourceCode(){return this._rawComputeSourceCode}_prepareEffect(){const e=this.defines,t=this._pipelineContext;this._isReady=!1;try{const i=this._engine;this._pipelineContext=i.createComputePipelineContext(),this._pipelineContext._name=this._key,i._prepareComputePipelineContext(this._pipelineContext,this._computeSourceCodeOverride?this._computeSourceCodeOverride:this._computeSourceCode,this._rawComputeSourceCode,this._computeSourceCodeOverride?null:e,this._entryPoint),i._executeWhenComputeStateIsCompiled(this._pipelineContext,r=>{if(r&&r.numErrors>0){this._processCompilationErrors(r,t);return}this._compilationError="",this._isReady=!0,this.onCompiled&&this.onCompiled(this),this.onCompileObservable.notifyObservers(this),this.onCompileObservable.clear(),t&&this.getEngine()._deleteComputePipelineContext(t)}),this._pipelineContext.isAsync&&this._checkIsReady(t)}catch(i){this._processCompilationErrors(i,t)}}_processCompilationErrors(e,t=null){var i;if(this._compilationError="",L.Error("Unable to compile compute effect:"),this.defines&&L.Error(`Defines:
`+this.defines),Na.LogShaderCodeOnCompilationError){const r=(i=this._pipelineContext)==null?void 0:i._getComputeShaderCode();r&&(L.Error("Compute code:"),L.Error(r))}if(typeof e=="string")this._compilationError=e,L.Error("Error: "+this._compilationError);else for(const r of e.messages){let s="";r.line!==void 0&&(s+="Line "+r.line+", "),r.offset!==void 0&&(s+="Offset "+r.offset+", "),r.length!==void 0&&(s+="Length "+r.length+", "),s+=r.type+": "+r.text,this._compilationError&&(this._compilationError+=`
`),this._compilationError+=s,L.Error(s)}t&&(this._pipelineContext=t,this._isReady=!0),this.onError&&this.onError(this,this._compilationError),this.onErrorObservable.notifyObservers(this)}dispose(){this._pipelineContext&&this._pipelineContext.dispose(),this._engine._releaseComputeEffect(this)}static RegisterShader(e,t){P.GetShadersStore(1)[`${e}ComputeShader`]=t}}Na._UniqueIdSeed=0;Na.LogShaderCodeOnCompilationError=!0;class l_{constructor(){this._gpuTimeInFrameId=-1,this.counter=new fu}_addDuration(e,t){e<this._gpuTimeInFrameId||(this._gpuTimeInFrameId!==e?(this.counter._fetchResult(),this.counter.fetchNewFrame(),this.counter.addCount(t,!1),this._gpuTimeInFrameId=e):this.counter.addCount(t,!1))}}class Cs{get options(){return this._options}get shaderPath(){return this._shaderPath}constructor(e,t,i,r={}){if(this._bindings={},this._samplers={},this._contextIsDirty=!1,this.fastMode=!1,this.onCompiled=null,this.onError=null,this.name=e,this._engine=t,this.uniqueId=pu.UniqueId,t.enableGPUTimingMeasurements&&(this.gpuTimeInFrame=new l_),!this._engine.getCaps().supportComputeShaders){L.Error("This engine does not support compute shaders!");return}if(!r.bindingsMapping){L.Error("You must provide the binding mappings as browsers don't support reflection for wgsl shaders yet!");return}this._context=t.createComputeContext(),this._shaderPath=i,this._options={bindingsMapping:{},defines:[],...r}}getClassName(){return"ComputeShader"}setTexture(e,t,i=!0){const r=this._bindings[e];this._bindings[e]={type:i?0:4,object:t,indexInGroupEntries:r==null?void 0:r.indexInGroupEntries},this._contextIsDirty||(this._contextIsDirty=!r||r.object!==t||r.type!==this._bindings[e].type)}setStorageTexture(e,t){const i=this._bindings[e];this._contextIsDirty||(this._contextIsDirty=!i||i.object!==t),this._bindings[e]={type:1,object:t,indexInGroupEntries:i==null?void 0:i.indexInGroupEntries}}setExternalTexture(e,t){const i=this._bindings[e];this._contextIsDirty||(this._contextIsDirty=!i||i.object!==t),this._bindings[e]={type:6,object:t,indexInGroupEntries:i==null?void 0:i.indexInGroupEntries}}setVideoTexture(e,t){return t.externalTexture?(this.setExternalTexture(e,t.externalTexture),!0):!1}setUniformBuffer(e,t){const i=this._bindings[e];this._contextIsDirty||(this._contextIsDirty=!i||i.object!==t),this._bindings[e]={type:Cs._BufferIsDataBuffer(t)?7:2,object:t,indexInGroupEntries:i==null?void 0:i.indexInGroupEntries}}setStorageBuffer(e,t){const i=this._bindings[e];this._contextIsDirty||(this._contextIsDirty=!i||i.object!==t),this._bindings[e]={type:Cs._BufferIsDataBuffer(t)?7:3,object:t,indexInGroupEntries:i==null?void 0:i.indexInGroupEntries}}setTextureSampler(e,t){const i=this._bindings[e];this._contextIsDirty||(this._contextIsDirty=!i||!t.compareSampler(i.object)),this._bindings[e]={type:5,object:t,indexInGroupEntries:i==null?void 0:i.indexInGroupEntries}}isReady(){let e=this._effect;for(const s in this._bindings){const n=this._bindings[s],o=n.type,l=n.object;switch(o){case 0:case 4:case 1:{if(!l.isReady())return!1;break}case 6:{if(!l.isReady())return!1;break}}}const t=[],i=this._shaderPath;if(this._options.defines)for(let s=0;s<this._options.defines.length;s++)t.push(this._options.defines[s]);const r=t.join(`
`);return this._cachedDefines!==r&&(this._cachedDefines=r,e=this._engine.createComputeEffect(i,{defines:r,entryPoint:this._options.entryPoint,onCompiled:this.onCompiled,onError:this.onError}),this._effect=e),!!e.isReady()}dispatch(e,t,i){return!this.fastMode&&!this._checkContext()?!1:(this._engine.computeDispatch(this._effect,this._context,this._bindings,e,t,i,this._options.bindingsMapping,this.gpuTimeInFrame),!0)}dispatchIndirect(e,t=0){if(!this.fastMode&&!this._checkContext())return!1;const i=Cs._BufferIsDataBuffer(e)?e:e.getBuffer();return this._engine.computeDispatchIndirect(this._effect,this._context,this._bindings,i,t,this._options.bindingsMapping,this.gpuTimeInFrame),!0}_checkContext(){var e;if(!this.isReady())return!1;for(const t in this._bindings){const i=this._bindings[t];if(!this._options.bindingsMapping[t])throw new Error("ComputeShader ('"+this.name+"'): No binding mapping has been provided for the property '"+t+"'");switch(i.type){case 0:{const r=this._samplers[t],s=i.object;(!r||!s._texture||!r.compareSampler(s._texture))&&(this._samplers[t]=new Jb().setParameters(s.wrapU,s.wrapV,s.wrapR,s.anisotropicFilteringLevel,s._texture.samplingMode,(e=s._texture)==null?void 0:e._comparisonFunction),this._contextIsDirty=!0);break}case 6:{this._contextIsDirty=!0;break}case 2:{const r=i.object;r.getBuffer()!==i.buffer&&(i.buffer=r.getBuffer(),this._contextIsDirty=!0);break}}}return this._contextIsDirty&&(this._contextIsDirty=!1,this._context.clear()),!0}dispatchWhenReady(e,t,i,r=10){return new Promise(s=>{du(()=>this.dispatch(e,t,i),s,void 0,r)})}serialize(){const e=Me.Serialize(this);e.options=this._options,e.shaderPath=this._shaderPath,e.bindings={},e.textures={};for(const t in this._bindings){const i=this._bindings[t],r=i.object;switch(i.type){case 0:case 4:case 1:{const s=r.serialize();s&&(e.textures[t]=s,e.bindings[t]={type:i.type});break}}}return e}static Parse(e,t,i){const r=Me.Parse(()=>new Cs(e.name,t.getEngine(),e.shaderPath,e.options),e,t,i);for(const s in e.textures){const n=e.bindings[s],o=Y.Parse(e.textures[s],t,i);n.type===0?r.setTexture(s,o):n.type===4?r.setTexture(s,o,!1):r.setStorageTexture(s,o)}return r}static _BufferIsDataBuffer(e){return e.underlyingResource!==void 0}}C([F()],Cs.prototype,"name",void 0);C([F()],Cs.prototype,"fastMode",void 0);B("BABYLON.ComputeShader",Cs);const Vg="gpuTransformVertexShader",wD=`attribute vec3 position;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
out vec3 outPosition;const mat4 identity=mat4(
vec4(1.0,0.0,0.0,0.0),
vec4(0.0,1.0,0.0,0.0),
vec4(0.0,0.0,1.0,0.0),
vec4(0.0,0.0,0.0,1.0)
);void main(void) {vec3 positionUpdated=position;
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
mat4 finalWorld=identity;
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);outPosition=worldPos.xyz;}`;P.ShadersStore[Vg]||(P.ShadersStore[Vg]=wD);const kg="gpuTransformPixelShader",ND=`#version 300 es
void main() {discard;}
`;P.ShadersStore[kg]||(P.ShadersStore[kg]=ND);class qs{constructor(e){this._buffers={},this._effects={},this._meshListCounter=0,this._engine=e}processAsync(e){return Array.isArray(e)||(e=[e]),this._meshListCounter=0,this._processMeshList(e),Promise.resolve()}_processMeshList(e){const t=this._engine.getCaps().parallelShaderCompile;this._engine.getCaps().parallelShaderCompile=void 0;for(let i=0;i<e.length;++i){const r=e[i];if(r.getTotalVertices()===0||!r.getVertexBuffer||!r.getVertexBuffer(N.PositionKind))continue;let n;const o=[],l=[N.PositionKind];r&&r.useBones&&r.computeBonesUsingShaders&&r.skeleton?(l.push(N.MatricesIndicesKind),l.push(N.MatricesWeightsKind),r.numBoneInfluencers>4&&(l.push(N.MatricesIndicesExtraKind),l.push(N.MatricesWeightsExtraKind)),o.push("#define NUM_BONE_INFLUENCERS "+r.numBoneInfluencers),o.push("#define BONETEXTURE "+r.skeleton.isUsingTextureForMatrices),o.push("#define BonesPerMesh "+(r.skeleton.bones.length+1))):o.push("#define NUM_BONE_INFLUENCERS 0");const u=r.morphTargetManager?jn(r.morphTargetManager,o,l,r,!0,!1,!1,!1,!1,!1):0,c=r.bakedVertexAnimationManager;c&&c.isEnabled&&(o.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),ey(l,r,o));const h=o.join(`
`);if(this._effects[h])n=this._effects[h];else{const p={attributes:l,uniformsNames:["boneTextureWidth","mBones","morphTargetInfluences","morphTargetCount","morphTargetTextureInfo","morphTargetTextureIndices","bakedVertexAnimationSettings","bakedVertexAnimationTextureSizeInverted","bakedVertexAnimationTime"],uniformBuffersNames:[],samplers:["boneSampler","morphTargets","bakedVertexAnimationTexture"],defines:h,fallbacks:null,onCompiled:null,onError:null,indexParameters:{maxSimultaneousMorphTargets:u},maxSimultaneousLights:0,transformFeedbackVaryings:["outPosition"]};n=this._engine.createEffect("gpuTransform",p,this._engine),this._effects[h]=n}this._compute(r,n)}this._engine.getCaps().parallelShaderCompile=t}_compute(e,t){var l;const i=this._engine;let r;const s=e.getTotalVertices();if(this._buffers[e.uniqueId])r=this._buffers[e.uniqueId];else{const u=new Float32Array(s*3);r=new fi(e.getEngine(),u,!0,3),this._buffers[e.uniqueId]=r}t.getEngine().enableEffect(t),e._bindDirect(t,null,!0),Yn(e,t),Ns(e,t),e.morphTargetManager&&e.morphTargetManager.isUsingTextureForTargets&&e.morphTargetManager._bind(t);const n=e.bakedVertexAnimationManager;n&&n.isEnabled&&((l=e.bakedVertexAnimationManager)==null||l.bind(t,!1));const o=r.getData();if(i.bindTransformFeedbackBuffer(r.getBuffer()),i.setRasterizerState(!1),i.beginTransformFeedback(!0),i.drawArraysType(2,0,s),i.endTransformFeedback(),i.setRasterizerState(!0),i.readTransformFeedbackBuffer(o),i.bindTransformFeedbackBuffer(null),this._meshListCounter===0)e._refreshBoundingInfo(o,null);else{const u=e.getBoundingInfo().boundingBox,c=zo(o,0,s);qs._Min.copyFrom(u.minimum).minimizeInPlace(c.minimum),qs._Max.copyFrom(u.maximum).maximizeInPlace(c.maximum),e._refreshBoundingInfoDirect({minimum:qs._Min,maximum:qs._Max})}}registerMeshListAsync(e){return Array.isArray(e)||(e=[e]),this._meshList=e,this._meshListCounter=0,Promise.resolve()}processMeshList(){this._meshList.length!==0&&(this._processMeshList(this._meshList),this._meshListCounter++)}fetchResultsForMeshListAsync(){return this._meshListCounter=0,Promise.resolve()}dispose(){for(const e in this._buffers)this._buffers[e].dispose();this._buffers={},this._effects={},this._engine=null}}qs._Min=new m;qs._Max=new m;const oW=Object.freeze(Object.defineProperty({__proto__:null,TransformFeedbackBoundingHelper:qs},Symbol.toStringTag,{value:"Module"})),zg="boundingInfoComputeShader",FD=`struct Results {minX : atomic<i32>,
minY : atomic<i32>,
minZ : atomic<i32>,
maxX : atomic<i32>,
maxY : atomic<i32>,
maxZ : atomic<i32>,
dummy1 : i32,
dummy2 : i32,};fn floatToBits(value: f32)->i32 {return bitcast<i32>(value);}
fn bitsToFloat(value: i32)->f32 {return bitcast<f32>(value);}
fn atomicMinFloat(atomicVar: ptr<storage,atomic<i32>,read_write>,value: f32) {let intValue=floatToBits(value);loop {let oldIntValue=atomicLoad(atomicVar);let oldValue=bitsToFloat(oldIntValue);if (value>=oldValue) {break;}
if (atomicCompareExchangeWeak(atomicVar,oldIntValue,intValue).old_value==oldIntValue) {break;}}}
fn atomicMaxFloat(atomicVar: ptr<storage,atomic<i32>,read_write>,value: f32) {let intValue=floatToBits(value);loop {let oldIntValue=atomicLoad(atomicVar);let oldValue=bitsToFloat(oldIntValue);if (value<=oldValue) {break;}
if (atomicCompareExchangeWeak(atomicVar,oldIntValue,intValue).old_value==oldIntValue) {break;}}}
fn readMatrixFromRawSampler(smp : texture_2d<f32>,index : f32)->mat4x4<f32>
{let offset=i32(index) *4; 
let m0=textureLoad(smp,vec2<i32>(offset+0,0),0);let m1=textureLoad(smp,vec2<i32>(offset+1,0),0);let m2=textureLoad(smp,vec2<i32>(offset+2,0),0);let m3=textureLoad(smp,vec2<i32>(offset+3,0),0);return mat4x4<f32>(m0,m1,m2,m3);}
const identity=mat4x4f(
vec4f(1.0,0.0,0.0,0.0),
vec4f(0.0,1.0,0.0,0.0),
vec4f(0.0,0.0,1.0,0.0),
vec4f(0.0,0.0,0.0,1.0)
);struct Settings {morphTargetTextureInfo: vec3f,
morphTargetCount: i32,
indexResult : u32,};@group(0) @binding(0) var<storage,read> positionBuffer : array<f32>;@group(0) @binding(1) var<storage,read_write> resultBuffer : array<Results>;@group(0) @binding(7) var<uniform> settings : Settings;
#if NUM_BONE_INFLUENCERS>0
@group(0) @binding(2) var boneSampler : texture_2d<f32>;@group(0) @binding(3) var<storage,read> indexBuffer : array<vec4f>;@group(0) @binding(4) var<storage,read> weightBuffer : array<vec4f>;
#if NUM_BONE_INFLUENCERS>4
@group(0) @binding(5) var<storage,read> indexExtraBuffer : array<vec4f>;@group(0) @binding(6) var<storage,read> weightExtraBuffer : array<vec4f>;
#endif
#endif
#ifdef MORPHTARGETS
@group(0) @binding(8) var morphTargets : texture_2d_array<f32>;@group(0) @binding(9) var<storage,read> morphTargetInfluences : array<f32>;@group(0) @binding(10) var<storage,read> morphTargetTextureIndices : array<f32>;
#endif
#ifdef MORPHTARGETS
fn readVector3FromRawSampler(targetIndex : i32,vertexIndex : u32)->vec3f
{ 
let vertexID=f32(vertexIndex)*settings.morphTargetTextureInfo.x;let y=floor(vertexID/settings.morphTargetTextureInfo.y);let x=vertexID-y*settings.morphTargetTextureInfo.y;let textureUV=vec2<i32>(i32(x),i32(y));return textureLoad(morphTargets,textureUV,i32(morphTargetTextureIndices[targetIndex]),0).xyz;}
fn readVector4FromRawSampler(targetIndex : i32,vertexIndex : u32)->vec4f
{ 
let vertexID=f32(vertexIndex)*settings.morphTargetTextureInfo.x;let y=floor(vertexID/settings.morphTargetTextureInfo.y);let x=vertexID-y*settings.morphTargetTextureInfo.y;let textureUV=vec2<i32>(i32(x),i32(y));return textureLoad(morphTargets,textureUV,i32(morphTargetTextureIndices[targetIndex]),0);}
#endif
@compute @workgroup_size(256,1,1)
fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {let index=global_id.x;if (index>=arrayLength(&positionBuffer)/3) {return;}
let position=vec3f(positionBuffer[index*3],positionBuffer[index*3+1],positionBuffer[index*3+2]);var finalWorld=identity;var positionUpdated=position;
#if NUM_BONE_INFLUENCERS>0
var influence : mat4x4<f32>;let matricesIndices=indexBuffer[index];let matricesWeights=weightBuffer[index];influence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];
#endif 
#if NUM_BONE_INFLUENCERS>4
let matricesIndicesExtra=indexExtraBuffer[index];let matricesWeightsExtra=weightExtraBuffer[index];influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.x)*matricesWeightsExtra.x;
#if NUM_BONE_INFLUENCERS>5
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.y)*matricesWeightsExtra.y;
#endif 
#if NUM_BONE_INFLUENCERS>6
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.z)*matricesWeightsExtra.z;
#endif 
#if NUM_BONE_INFLUENCERS>7
influence=influence+readMatrixFromRawSampler(boneSampler,matricesIndicesExtra.w)*matricesWeightsExtra.w;
#endif 
#endif 
finalWorld=finalWorld*influence;
#endif
#ifdef MORPHTARGETS
for (var i=0; i<NUM_MORPH_INFLUENCERS; i=i+1) {if (i>=settings.morphTargetCount) {break;}
positionUpdated=positionUpdated+(readVector3FromRawSampler(i,index)-position)*morphTargetInfluences[i];}
#endif
var worldPos=finalWorld*vec4f(positionUpdated.x,positionUpdated.y,positionUpdated.z,1.0);atomicMinFloat(&resultBuffer[settings.indexResult].minX,worldPos.x);atomicMinFloat(&resultBuffer[settings.indexResult].minY,worldPos.y);atomicMinFloat(&resultBuffer[settings.indexResult].minZ,worldPos.z);atomicMaxFloat(&resultBuffer[settings.indexResult].maxX,worldPos.x);atomicMaxFloat(&resultBuffer[settings.indexResult].maxY,worldPos.y);atomicMaxFloat(&resultBuffer[settings.indexResult].maxZ,worldPos.z);}
`;P.ShadersStoreWGSL[zg]||(P.ShadersStoreWGSL[zg]=FD);class $l{constructor(e,t,i,r,s,n){this.entries=[],this._boundingVectors=new Array,this._capacity=i,this._depth=r,this._maxDepth=s,this._creationFunc=n,this._minPoint=e,this._maxPoint=t,this._boundingVectors.push(e.clone()),this._boundingVectors.push(t.clone()),this._boundingVectors.push(e.clone()),this._boundingVectors[2].x=t.x,this._boundingVectors.push(e.clone()),this._boundingVectors[3].y=t.y,this._boundingVectors.push(e.clone()),this._boundingVectors[4].z=t.z,this._boundingVectors.push(t.clone()),this._boundingVectors[5].z=e.z,this._boundingVectors.push(t.clone()),this._boundingVectors[6].x=e.x,this._boundingVectors.push(t.clone()),this._boundingVectors[7].y=e.y}get capacity(){return this._capacity}get minPoint(){return this._minPoint}get maxPoint(){return this._maxPoint}addEntry(e){if(this.blocks){for(let t=0;t<this.blocks.length;t++)this.blocks[t].addEntry(e);return}this._creationFunc(e,this),this.entries.length>this.capacity&&this._depth<this._maxDepth&&this.createInnerBlocks()}removeEntry(e){if(this.blocks){for(let i=0;i<this.blocks.length;i++)this.blocks[i].removeEntry(e);return}const t=this.entries.indexOf(e);t>-1&&this.entries.splice(t,1)}addEntries(e){for(let t=0;t<e.length;t++){const i=e[t];this.addEntry(i)}}select(e,t,i){if(Zc.IsInFrustum(this._boundingVectors,e)){if(this.blocks){for(let r=0;r<this.blocks.length;r++)this.blocks[r].select(e,t,i);return}i?t.concat(this.entries):t.concatWithNoDuplicate(this.entries)}}intersects(e,t,i,r){if(Zc.IntersectsSphere(this._minPoint,this._maxPoint,e,t)){if(this.blocks){for(let s=0;s<this.blocks.length;s++)this.blocks[s].intersects(e,t,i,r);return}r?i.concat(this.entries):i.concatWithNoDuplicate(this.entries)}}intersectsRay(e,t){if(e.intersectsBoxMinMax(this._minPoint,this._maxPoint)){if(this.blocks){for(let i=0;i<this.blocks.length;i++)this.blocks[i].intersectsRay(e,t);return}t.concatWithNoDuplicate(this.entries)}}createInnerBlocks(){$l._CreateBlocks(this._minPoint,this._maxPoint,this.entries,this._capacity,this._depth,this._maxDepth,this,this._creationFunc),this.entries.splice(0)}static _CreateBlocks(e,t,i,r,s,n,o,l){o.blocks=new Array;const u=new m((t.x-e.x)/2,(t.y-e.y)/2,(t.z-e.z)/2);for(let c=0;c<2;c++)for(let h=0;h<2;h++)for(let d=0;d<2;d++){const f=e.add(u.multiplyByFloats(c,h,d)),p=e.add(u.multiplyByFloats(c+1,h+1,d+1)),g=new $l(f,p,r,s+1,n,l);g.addEntries(i),o.blocks.push(g)}}}class Fa{constructor(e,t,i=2){this.maxDepth=i,this.dynamicContent=[],this._maxBlockCapacity=t||64,this._selectionContent=new NR(1024),this._creationFunc=e}update(e,t,i){$l._CreateBlocks(e,t,i,this._maxBlockCapacity,0,this.maxDepth,this,this._creationFunc)}addMesh(e){for(let t=0;t<this.blocks.length;t++)this.blocks[t].addEntry(e)}removeMesh(e){for(let t=0;t<this.blocks.length;t++)this.blocks[t].removeEntry(e)}select(e,t){this._selectionContent.reset();for(let i=0;i<this.blocks.length;i++)this.blocks[i].select(e,this._selectionContent,t);return t?this._selectionContent.concat(this.dynamicContent):this._selectionContent.concatWithNoDuplicate(this.dynamicContent),this._selectionContent}intersects(e,t,i){this._selectionContent.reset();for(let r=0;r<this.blocks.length;r++)this.blocks[r].intersects(e,t,this._selectionContent,i);return i?this._selectionContent.concat(this.dynamicContent):this._selectionContent.concatWithNoDuplicate(this.dynamicContent),this._selectionContent}intersectsRay(e){this._selectionContent.reset();for(let t=0;t<this.blocks.length;t++)this.blocks[t].intersectsRay(e,this._selectionContent);return this._selectionContent.concatWithNoDuplicate(this.dynamicContent),this._selectionContent}}Fa.CreationFuncForMeshes=(a,e)=>{const t=a.getBoundingInfo();!a.isBlocked&&t.boundingBox.intersectsMinMax(e.minPoint,e.maxPoint)&&e.entries.push(a)};Fa.CreationFuncForSubMeshes=(a,e)=>{a.getBoundingInfo().boundingBox.intersectsMinMax(e.minPoint,e.maxPoint)&&e.entries.push(a)};Te.prototype.createOrUpdateSelectionOctree=function(a=64,e=2){let t=this._getComponent(ge.NAME_OCTREE);t||(t=new r0(this),this._addComponent(t)),this._selectionOctree||(this._selectionOctree=new Fa(Fa.CreationFuncForMeshes,a,e));const i=this.getWorldExtends();return this._selectionOctree.update(i.min,i.max,this.meshes),this._selectionOctree};Object.defineProperty(Te.prototype,"selectionOctree",{get:function(){return this._selectionOctree},enumerable:!0,configurable:!0});Rt.prototype.createOrUpdateSubmeshesOctree=function(a=64,e=2){const t=this.getScene();let i=t._getComponent(ge.NAME_OCTREE);i||(i=new r0(t),t._addComponent(i)),this._submeshesOctree||(this._submeshesOctree=new Fa(Fa.CreationFuncForSubMeshes,a,e)),this.computeWorldMatrix(!0);const s=this.getBoundingInfo().boundingBox;return this._submeshesOctree.update(s.minimumWorld,s.maximumWorld,this.subMeshes),this._submeshesOctree};class r0{constructor(e){this.name=ge.NAME_OCTREE,this.checksIsEnabled=!0,this._tempRay=new Zt(m.Zero(),new m(1,1,1)),e=e||ze.LastCreatedScene,e&&(this.scene=e,this.scene.getActiveMeshCandidates=()=>this.getActiveMeshCandidates(),this.scene.getActiveSubMeshCandidates=t=>this.getActiveSubMeshCandidates(t),this.scene.getCollidingSubMeshCandidates=(t,i)=>this.getCollidingSubMeshCandidates(t,i),this.scene.getIntersectingSubMeshCandidates=(t,i)=>this.getIntersectingSubMeshCandidates(t,i))}register(){this.scene.onMeshRemovedObservable.add(e=>{const t=this.scene.selectionOctree;if(t!=null){const i=t.dynamicContent.indexOf(e);i!==-1&&t.dynamicContent.splice(i,1)}}),this.scene.onMeshImportedObservable.add(e=>{const t=this.scene.selectionOctree;t!=null&&t.addMesh(e)})}getActiveMeshCandidates(){var e;return((e=this.scene._selectionOctree)==null?void 0:e.select(this.scene.frustumPlanes))||this.scene._getDefaultMeshCandidates()}getActiveSubMeshCandidates(e){return e._submeshesOctree&&e.useOctreeForRenderingSelection?e._submeshesOctree.select(this.scene.frustumPlanes):this.scene._getDefaultSubMeshCandidates(e)}getIntersectingSubMeshCandidates(e,t){return e._submeshesOctree&&e.useOctreeForPicking?(Zt.TransformToRef(t,e.getWorldMatrix(),this._tempRay),e._submeshesOctree.intersectsRay(this._tempRay)):this.scene._getDefaultSubMeshCandidates(e)}getCollidingSubMeshCandidates(e,t){if(e._submeshesOctree&&e.useOctreeForCollisions){const i=t._velocityWorldLength+Math.max(t._radius.x,t._radius.y,t._radius.z);return e._submeshesOctree.intersects(t._basePointWorld,i)}return this.scene._getDefaultSubMeshCandidates(e)}rebuild(){}dispose(){}}function u_(a){const e=a.height||2;let t=a.diameterTop===0?0:a.diameterTop||a.diameter||1,i=a.diameterBottom===0?0:a.diameterBottom||a.diameter||1;t=t||1e-5,i=i||1e-5;const r=(a.tessellation||24)|0,s=(a.subdivisions||1)|0,n=!!a.hasRings,o=!!a.enclose,l=a.cap===0?0:a.cap||z.CAP_ALL,u=a.arc&&(a.arc<=0||a.arc>1)?1:a.arc||1,c=a.sideOrientation===0?0:a.sideOrientation||he.DEFAULTSIDE,h=a.faceUV||new Array(3),d=a.faceColors,f=u!==1&&o?2:0,p=n?s:1,g=2+(1+f)*p;let _;for(_=0;_<g;_++)d&&d[_]===void 0&&(d[_]=new xe(1,1,1,1));for(_=0;_<g;_++)h&&h[_]===void 0&&(h[_]=new Ve(0,0,1,1));const S=[],b=[],y=[],T=[],v=[],E=Math.PI*2*u/r;let R,O,w;const M=(i-t)/2/e,G=m.Zero(),H=m.Zero(),q=m.Zero(),X=m.Zero(),ee=m.Zero(),oe=qi.Y;let _e,te,ie,Z=1,D=1,W=0,K=0;for(_e=0;_e<=s;_e++)for(O=_e/s,w=(O*(t-i)+i)/2,Z=n&&_e!==0&&_e!==s?2:1,ie=0;ie<Z;ie++){for(n&&(D+=ie),o&&(D+=2*ie),te=0;te<=r;te++)R=te*E,G.x=Math.cos(-R)*w,G.y=-e/2+O*e,G.z=Math.sin(-R)*w,t===0&&_e===s?(H.x=y[y.length-(r+1)*3],H.y=y[y.length-(r+1)*3+1],H.z=y[y.length-(r+1)*3+2]):(H.x=G.x,H.z=G.z,H.y=Math.sqrt(H.x*H.x+H.z*H.z)*M,H.normalize()),te===0&&(q.copyFrom(G),X.copyFrom(H)),b.push(G.x,G.y,G.z),y.push(H.x,H.y,H.z),n?K=W!==D?h[D].y:h[D].w:K=h[D].y+(h[D].w-h[D].y)*O,T.push(h[D].x+(h[D].z-h[D].x)*te/r,ot?1-K:K),d&&v.push(d[D].r,d[D].g,d[D].b,d[D].a);u!==1&&o&&(b.push(G.x,G.y,G.z),b.push(0,G.y,0),b.push(0,G.y,0),b.push(q.x,q.y,q.z),m.CrossToRef(oe,H,ee),ee.normalize(),y.push(ee.x,ee.y,ee.z,ee.x,ee.y,ee.z),m.CrossToRef(X,oe,ee),ee.normalize(),y.push(ee.x,ee.y,ee.z,ee.x,ee.y,ee.z),n?K=W!==D?h[D+1].y:h[D+1].w:K=h[D+1].y+(h[D+1].w-h[D+1].y)*O,T.push(h[D+1].x,ot?1-K:K),T.push(h[D+1].z,ot?1-K:K),n?K=W!==D?h[D+2].y:h[D+2].w:K=h[D+2].y+(h[D+2].w-h[D+2].y)*O,T.push(h[D+2].x,ot?1-K:K),T.push(h[D+2].z,ot?1-K:K),d&&(v.push(d[D+1].r,d[D+1].g,d[D+1].b,d[D+1].a),v.push(d[D+1].r,d[D+1].g,d[D+1].b,d[D+1].a),v.push(d[D+2].r,d[D+2].g,d[D+2].b,d[D+2].a),v.push(d[D+2].r,d[D+2].g,d[D+2].b,d[D+2].a))),W!==D&&(W=D)}const ue=u!==1&&o?r+4:r;for(_e=0,D=0;D<s;D++){let ce=0,fe=0,pe=0,Ie=0;for(te=0;te<r;te++)ce=_e*(ue+1)+te,fe=(_e+1)*(ue+1)+te,pe=_e*(ue+1)+(te+1),Ie=(_e+1)*(ue+1)+(te+1),S.push(ce,fe,pe),S.push(Ie,pe,fe);u!==1&&o&&(S.push(ce+2,fe+2,pe+2),S.push(Ie+2,pe+2,fe+2),S.push(ce+4,fe+4,pe+4),S.push(Ie+4,pe+4,fe+4)),_e=n?_e+2:_e+1}const ye=ce=>{const fe=ce?t/2:i/2;if(fe===0)return;let pe,Ie,vt;const Se=ce?h[g-1]:h[0];let Ge=null;d&&(Ge=ce?d[g-1]:d[0]);const Pe=b.length/3,si=ce?e/2:-e/2,Di=new m(0,si,0);b.push(Di.x,Di.y,Di.z),y.push(0,ce?1:-1,0);const hi=Se.y+(Se.w-Se.y)*.5;T.push(Se.x+(Se.z-Se.x)*.5,ot?1-hi:hi),Ge&&v.push(Ge.r,Ge.g,Ge.b,Ge.a);const _r=new Q(.5,.5);for(vt=0;vt<=r;vt++){pe=Math.PI*2*vt*u/r;const yn=Math.cos(-pe),ks=Math.sin(-pe);Ie=new m(yn*fe,si,ks*fe);const vl=new Q(yn*_r.x+.5,ks*_r.y+.5);b.push(Ie.x,Ie.y,Ie.z),y.push(0,ce?1:-1,0);const bl=Se.y+(Se.w-Se.y)*vl.y;T.push(Se.x+(Se.z-Se.x)*vl.x,ot?1-bl:bl),Ge&&v.push(Ge.r,Ge.g,Ge.b,Ge.a)}for(vt=0;vt<r;vt++)ce?(S.push(Pe),S.push(Pe+(vt+2)),S.push(Pe+(vt+1))):(S.push(Pe),S.push(Pe+(vt+1)),S.push(Pe+(vt+2)))};(l===z.CAP_START||l===z.CAP_ALL)&&ye(!1),(l===z.CAP_END||l===z.CAP_ALL)&&ye(!0),he._ComputeSides(c,b,S,y,T,a.frontUVs,a.backUVs);const se=new he;return se.indices=S,se.positions=b,se.normals=y,se.uvs=T,d&&(se.colors=v),se}function tr(a,e={},t){const i=new z(a,t);return e.sideOrientation=z._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,u_(e).applyToMesh(i,e.updatable),i}const lW={CreateCylinder:tr};he.CreateCylinder=u_;z.CreateCylinder=(a,e,t,i,r,s,n,o,l)=>((n===void 0||!(n instanceof Te))&&(n!==void 0&&(l=o||z.DEFAULTSIDE,o=n),n=s,s=1),tr(a,{height:e,diameterTop:t,diameterBottom:i,tessellation:r,subdivisions:s,sideOrientation:l,updatable:o},n));class gt{getRenderCamera(e){if(this._renderCamera)return this._renderCamera;{let t;return this.originalScene.activeCameras&&this.originalScene.activeCameras.length>1?t=this.originalScene.activeCameras[this.originalScene.activeCameras.length-1]:t=this.originalScene.activeCamera,e&&t&&t.isRigCamera?t.rigParent:t}}setRenderCamera(e){this._renderCamera=e}_getSharedGizmoLight(){return this._sharedGizmoLight||(this._sharedGizmoLight=new wm("shared gizmo light",new m(0,1,0),this.utilityLayerScene),this._sharedGizmoLight.intensity=2,this._sharedGizmoLight.groundColor=ne.Gray()),this._sharedGizmoLight}static get DefaultUtilityLayer(){return gt._DefaultUtilityLayer==null?gt._CreateDefaultUtilityLayerFromScene(ze.LastCreatedScene):gt._DefaultUtilityLayer}static _CreateDefaultUtilityLayerFromScene(e){return gt._DefaultUtilityLayer=new gt(e),gt._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(()=>{gt._DefaultUtilityLayer=null}),gt._DefaultUtilityLayer}static get DefaultKeepDepthUtilityLayer(){return gt._DefaultKeepDepthUtilityLayer==null&&(gt._DefaultKeepDepthUtilityLayer=new gt(ze.LastCreatedScene),gt._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil=!1,gt._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(()=>{gt._DefaultKeepDepthUtilityLayer=null})),gt._DefaultKeepDepthUtilityLayer}constructor(e,t=!0,i=!1){this.originalScene=e,this.handleEvents=t,this._pointerCaptures={},this._lastPointerEvents={},this._sharedGizmoLight=null,this._renderCamera=null,this.pickUtilitySceneFirst=!0,this.shouldRender=!0,this.onlyCheckPointerDownEvents=!0,this.processAllEvents=!1,this.pickingEnabled=!0,this.onPointerOutObservable=new j,this.utilityLayerScene=new Te(e.getEngine(),{virtual:!0}),this.utilityLayerScene.useRightHandedSystem=e.useRightHandedSystem,this.utilityLayerScene._allowPostProcessClearColor=!1,this.utilityLayerScene.postProcessesEnabled=!1,this.utilityLayerScene.detachControl(),t&&(this._originalPointerObserver=e.onPrePointerObservable.add(r=>{var l;if(!this.utilityLayerScene.activeCamera||!this.pickingEnabled||!this.processAllEvents&&r.type!==Be.POINTERMOVE&&r.type!==Be.POINTERUP&&r.type!==Be.POINTERDOWN&&r.type!==Be.POINTERDOUBLETAP)return;this.utilityLayerScene.pointerX=e.pointerX,this.utilityLayerScene.pointerY=e.pointerY;const s=r.event;if(e.isPointerCaptured(s.pointerId)){this._pointerCaptures[s.pointerId]=!1;return}const n=u=>{let c=null;if(r.nearInteractionPickingInfo)r.nearInteractionPickingInfo.pickedMesh.getScene()==u?c=r.nearInteractionPickingInfo:c=new Qi;else if(u!==this.utilityLayerScene&&r.originalPickingInfo)c=r.originalPickingInfo;else{let h=null;this._renderCamera&&(h=u._activeCamera,u._activeCamera=this._renderCamera,r.ray=null),c=r.ray?u.pickWithRay(r.ray):u.pick(e.pointerX,e.pointerY),h&&(u._activeCamera=h)}return c},o=n(this.utilityLayerScene);if(!r.ray&&o&&(r.ray=o.ray),(l=r.originalPickingInfo)!=null&&l.aimTransform&&o&&(o.aimTransform=r.originalPickingInfo.aimTransform,o.gripTransform=r.originalPickingInfo.gripTransform),this.utilityLayerScene.onPrePointerObservable.notifyObservers(r),this.onlyCheckPointerDownEvents&&r.type!=Be.POINTERDOWN){r.skipOnPointerObservable||this.utilityLayerScene.onPointerObservable.notifyObservers(new Tc(r.type,r.event,o),r.type),r.type===Be.POINTERUP&&this._pointerCaptures[s.pointerId]&&(this._pointerCaptures[s.pointerId]=!1);return}if(this.utilityLayerScene.autoClearDepthAndStencil||this.pickUtilitySceneFirst)o&&o.hit&&(r.skipOnPointerObservable||this.utilityLayerScene.onPointerObservable.notifyObservers(new Tc(r.type,r.event,o),r.type),r.skipOnPointerObservable=!0);else{const u=n(e),c=r.event;u&&o&&(o.distance===0&&u.pickedMesh?this.mainSceneTrackerPredicate&&this.mainSceneTrackerPredicate(u.pickedMesh)?(this._notifyObservers(r,u,c),r.skipOnPointerObservable=!0):r.type===Be.POINTERDOWN?(this._pointerCaptures[c.pointerId]=!0,this._notifyObservers(r,u,c)):(r.type===Be.POINTERMOVE||r.type===Be.POINTERUP)&&(this._lastPointerEvents[c.pointerId]&&(this.onPointerOutObservable.notifyObservers(c.pointerId),delete this._lastPointerEvents[c.pointerId]),this._notifyObservers(r,u,c)):!this._pointerCaptures[c.pointerId]&&(o.distance<u.distance||u.distance===0)?(this._notifyObservers(r,o,c),r.skipOnPointerObservable||(r.skipOnPointerObservable=o.distance>0)):!this._pointerCaptures[c.pointerId]&&o.distance>=u.distance&&(this.mainSceneTrackerPredicate&&this.mainSceneTrackerPredicate(u.pickedMesh)?(this._notifyObservers(r,u,c),r.skipOnPointerObservable=!0):((r.type===Be.POINTERMOVE||r.type===Be.POINTERUP)&&this._lastPointerEvents[c.pointerId]&&(this.onPointerOutObservable.notifyObservers(c.pointerId),delete this._lastPointerEvents[c.pointerId]),this._notifyObservers(r,o,c))),r.type===Be.POINTERUP&&this._pointerCaptures[c.pointerId]&&(this._pointerCaptures[c.pointerId]=!1))}}),this._originalPointerObserver&&e.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver)),this.utilityLayerScene.autoClear=!1,i||(this._afterRenderObserver=this.originalScene.onAfterRenderCameraObservable.add(r=>{this.shouldRender&&r==this.getRenderCamera()&&this.render()})),this._sceneDisposeObserver=this.originalScene.onDisposeObservable.add(()=>{this.dispose()}),this._updateCamera()}_notifyObservers(e,t,i){e.skipOnPointerObservable||(this.utilityLayerScene.onPointerObservable.notifyObservers(new Tc(e.type,e.event,t),e.type),this._lastPointerEvents[i.pointerId]=!0)}render(){if(this._updateCamera(),this.utilityLayerScene.activeCamera){const e=this.utilityLayerScene.activeCamera.getScene(),t=this.utilityLayerScene.activeCamera;t._scene=this.utilityLayerScene,t.leftCamera&&(t.leftCamera._scene=this.utilityLayerScene),t.rightCamera&&(t.rightCamera._scene=this.utilityLayerScene),this.utilityLayerScene.render(!1),t._scene=e,t.leftCamera&&(t.leftCamera._scene=e),t.rightCamera&&(t.rightCamera._scene=e)}}dispose(){this.onPointerOutObservable.clear(),this._afterRenderObserver&&this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver),this._sceneDisposeObserver&&this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver),this._originalPointerObserver&&this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver),this.utilityLayerScene.dispose()}_updateCamera(){this.utilityLayerScene.cameraToUseForPointers=this.getRenderCamera(),this.utilityLayerScene.activeCamera=this.getRenderCamera()}}gt._DefaultUtilityLayer=null;gt._DefaultKeepDepthUtilityLayer=null;var Ug;(function(a){a[a.Origin=0]="Origin",a[a.Pivot=1]="Pivot"})(Ug||(Ug={}));var Gg;(function(a){a[a.World=0]="World",a[a.Local=1]="Local"})(Gg||(Gg={}));class ri{set scaleRatio(e){this._scaleRatio=e}get scaleRatio(){return this._scaleRatio}get isHovered(){return this._isHovered}get attachedMesh(){return this._attachedMesh}set attachedMesh(e){this._attachedMesh=e,e&&(this._attachedNode=e),this._rootMesh.setEnabled(!!e),this._attachedNodeChanged(e)}get attachedNode(){return this._attachedNode}set attachedNode(e){this._attachedNode=e,this._attachedMesh=null,this._rootMesh.setEnabled(!!e),this._attachedNodeChanged(e)}setCustomMesh(e){if(e.getScene()!=this.gizmoLayer.utilityLayerScene)throw"When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)";this._rootMesh.getChildMeshes().forEach(t=>{t.dispose()}),e.parent=this._rootMesh,this._customMeshSet=!0}get additionalTransformNode(){return this._additionalTransformNode}set additionalTransformNode(e){this._additionalTransformNode=e}set updateGizmoRotationToMatchAttachedMesh(e){this._updateGizmoRotationToMatchAttachedMesh=e}get updateGizmoRotationToMatchAttachedMesh(){return this._updateGizmoRotationToMatchAttachedMesh}set updateGizmoPositionToMatchAttachedMesh(e){this._updateGizmoPositionToMatchAttachedMesh=e}get updateGizmoPositionToMatchAttachedMesh(){return this._updateGizmoPositionToMatchAttachedMesh}set anchorPoint(e){this._anchorPoint=e}get anchorPoint(){return this._anchorPoint}set coordinatesMode(e){this._coordinatesMode=e;const t=e==1;this.updateGizmoRotationToMatchAttachedMesh=t,this.updateGizmoPositionToMatchAttachedMesh=!0}get coordinatesMode(){return this._coordinatesMode}set updateScale(e){this._updateScale=e}get updateScale(){return this._updateScale}_attachedNodeChanged(e){}constructor(e=gt.DefaultUtilityLayer){this.gizmoLayer=e,this._attachedMesh=null,this._attachedNode=null,this._customRotationQuaternion=null,this._scaleRatio=1,this._isHovered=!1,this._customMeshSet=!1,this._updateGizmoRotationToMatchAttachedMesh=!0,this._updateGizmoPositionToMatchAttachedMesh=!0,this._anchorPoint=0,this._updateScale=!0,this._coordinatesMode=1,this._interactionsEnabled=!0,this._rightHandtoLeftHandMatrix=$.RotationY(Math.PI),this._rootMesh=new z("gizmoRootNode",e.utilityLayerScene),this._rootMesh.rotationQuaternion=re.Identity(),this._beforeRenderObserver=this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(()=>{this._update()})}get customRotationQuaternion(){return this._customRotationQuaternion}set customRotationQuaternion(e){this._customRotationQuaternion=e}_update(){if(this.attachedNode){let e=this.attachedNode;if(this.attachedMesh&&(e=this.attachedMesh||this.attachedNode),this.updateGizmoPositionToMatchAttachedMesh)if(this.anchorPoint==1&&e.getAbsolutePivotPoint){const t=e.getAbsolutePivotPoint();this._rootMesh.position.copyFrom(t)}else{const t=e.getWorldMatrix().getRow(3),i=t?t.toVector3():new m(0,0,0);this._rootMesh.position.copyFrom(i)}if(this.updateGizmoRotationToMatchAttachedMesh){const i=e._isMesh||e.getClassName()==="AbstractMesh"||e.getClassName()==="TransformNode"||e.getClassName()==="InstancedMesh"?e:void 0;e.getWorldMatrix().decompose(void 0,this._rootMesh.rotationQuaternion,void 0,ri.PreserveScaling?i:void 0),this._rootMesh.rotationQuaternion.normalize()}else this._customRotationQuaternion?this._rootMesh.rotationQuaternion.copyFrom(this._customRotationQuaternion):this._rootMesh.rotationQuaternion.set(0,0,0,1);if(this.updateScale){const t=this.gizmoLayer.utilityLayerScene.activeCamera,i=t.globalPosition;this._rootMesh.position.subtractToRef(i,V.Vector3[0]);let r=this.scaleRatio;if(t.mode==Ze.ORTHOGRAPHIC_CAMERA){if(t.orthoTop&&t.orthoBottom){const s=t.orthoTop-t.orthoBottom;r*=s}}else{const s=t.getScene().useRightHandedSystem?m.RightHandedForwardReadOnly:m.LeftHandedForwardReadOnly,n=t.getDirection(s);r*=m.Dot(V.Vector3[0],n)}this._rootMesh.scaling.setAll(r),e._getWorldMatrixDeterminant()<0&&!ri.PreserveScaling&&(this._rootMesh.scaling.y*=-1)}else this._rootMesh.scaling.setAll(this.scaleRatio)}this.additionalTransformNode&&(this._rootMesh.computeWorldMatrix(!0),this._rootMesh.getWorldMatrix().multiplyToRef(this.additionalTransformNode.getWorldMatrix(),V.Matrix[0]),V.Matrix[0].decompose(this._rootMesh.scaling,this._rootMesh.rotationQuaternion,this._rootMesh.position))}_handlePivotMatrixInverse(e,t,i){if(e.isUsingPivotMatrix()&&!e.isUsingPostMultiplyPivotMatrix()){e.getPivotMatrix().invertToRef(V.Matrix[5]),V.Matrix[5].multiplyToRef(t,i);return}i.copyFrom(t)}_matrixChanged(){if(this._attachedNode)if(this._attachedNode._isCamera){const e=this._attachedNode;let t,i;if(e.parent){const s=V.Matrix[1];e.parent._worldMatrix.invertToRef(s),this._attachedNode._worldMatrix.multiplyToRef(s,V.Matrix[0]),t=V.Matrix[0]}else t=this._attachedNode._worldMatrix;if(e.getScene().useRightHandedSystem?(this._rightHandtoLeftHandMatrix.multiplyToRef(t,V.Matrix[1]),i=V.Matrix[1]):i=t,i.decompose(V.Vector3[1],V.Quaternion[0],V.Vector3[0]),this._attachedNode.getClassName()==="FreeCamera"||this._attachedNode.getClassName()==="FlyCamera"||this._attachedNode.getClassName()==="ArcFollowCamera"||this._attachedNode.getClassName()==="TargetCamera"||this._attachedNode.getClassName()==="TouchCamera"||this._attachedNode.getClassName()==="UniversalCamera"){const s=this._attachedNode;s.rotation=V.Quaternion[0].toEulerAngles(),s.rotationQuaternion&&(s.rotationQuaternion.copyFrom(V.Quaternion[0]),s.rotationQuaternion.normalize())}e.position.copyFrom(V.Vector3[0])}else if(this._attachedNode._isMesh||this._attachedNode.getClassName()==="AbstractMesh"||this._attachedNode.getClassName()==="TransformNode"||this._attachedNode.getClassName()==="InstancedMesh"){const e=this._attachedNode;if(e.parent){const t=V.Matrix[0],i=V.Matrix[1];e.parent.getWorldMatrix().invertToRef(t),this._attachedNode.getWorldMatrix().multiplyToRef(t,i);const r=V.Matrix[4];if(this._handlePivotMatrixInverse(e,i,r),r.decompose(V.Vector3[0],V.Quaternion[0],e.position,ri.PreserveScaling?e:void 0,ri.UseAbsoluteScaling),V.Quaternion[0].normalize(),e.isUsingPivotMatrix()){const s=V.Quaternion[1];re.RotationYawPitchRollToRef(e.rotation.y,e.rotation.x,e.rotation.z,s);const n=V.Matrix[2];$.ScalingToRef(e.scaling.x,e.scaling.y,e.scaling.z,n);const o=V.Matrix[2];s.toRotationMatrix(o);const l=e.getPivotMatrix(),u=V.Matrix[3];l.invertToRef(u),l.multiplyToRef(n,V.Matrix[4]),V.Matrix[4].multiplyToRef(o,V.Matrix[5]),V.Matrix[5].multiplyToRef(u,V.Matrix[6]),V.Matrix[6].getTranslationToRef(V.Vector3[1]),e.position.subtractInPlace(V.Vector3[1])}}else{const t=V.Matrix[4];this._handlePivotMatrixInverse(e,this._attachedNode._worldMatrix,t),t.decompose(V.Vector3[0],V.Quaternion[0],e.position,ri.PreserveScaling?e:void 0,ri.UseAbsoluteScaling)}V.Vector3[0].scaleInPlace(1/e.scalingDeterminant),e.scaling.copyFrom(V.Vector3[0]),e.billboardMode||(e.rotationQuaternion?(e.rotationQuaternion.copyFrom(V.Quaternion[0]),e.rotationQuaternion.normalize()):e.rotation=V.Quaternion[0].toEulerAngles())}else if(this._attachedNode.getClassName()==="Bone"){const e=this._attachedNode,t=e.getParent();if(t){const i=V.Matrix[0],r=V.Matrix[1];t.getFinalMatrix().invertToRef(i),e.getFinalMatrix().multiplyToRef(i,r),e.getLocalMatrix().copyFrom(r)}else e.getLocalMatrix().copyFrom(e.getFinalMatrix());e.markAsDirty()}else{const e=this._attachedNode;if(e.getTypeID){const t=e.getTypeID();if(t===rs.LIGHTTYPEID_DIRECTIONALLIGHT||t===rs.LIGHTTYPEID_SPOTLIGHT||t===rs.LIGHTTYPEID_POINTLIGHT){const i=e.parent;if(i){const r=V.Matrix[0],s=V.Matrix[1];i.getWorldMatrix().invertToRef(r),e.getWorldMatrix().multiplyToRef(r,s),s.decompose(void 0,V.Quaternion[0],V.Vector3[0])}else this._attachedNode._worldMatrix.decompose(void 0,V.Quaternion[0],V.Vector3[0]);e.position=new m(V.Vector3[0].x,V.Vector3[0].y,V.Vector3[0].z),e.direction&&(e.direction=new m(e.direction.x,e.direction.y,e.direction.z))}}}}_setGizmoMeshMaterial(e,t){e&&e.forEach(i=>{i.material=t,i.color&&(i.color=t.diffuseColor)})}static GizmoAxisPointerObserver(e,t){let i=!1,r=-1,s=!1;return e.utilityLayerScene.onPointerObservable.add(o=>{var l,u;if(o.pickInfo){if(s=i&&o.event.button!==-1&&o.event.button!==r,s||o.type===Be.POINTERUP)t.forEach(c=>{c.active=!1,i=!1,r=-1,c.gizmoMeshes.forEach(h=>{h.material=c.dragBehavior.enabled?c.material:c.disableMaterial,h.color&&(h.color=c.material.diffuseColor)})});else if(o.type===Be.POINTERMOVE){if(i)return;t.forEach(c=>{var h,d;if(c.colliderMeshes&&c.gizmoMeshes){const f=((d=c.colliderMeshes)==null?void 0:d.indexOf((h=o==null?void 0:o.pickInfo)==null?void 0:h.pickedMesh))!=-1,p=c.dragBehavior.enabled?f||c.active?c.hoverMaterial:c.material:c.disableMaterial;c.gizmoMeshes.forEach(g=>{g.material=p,g.color&&(g.color=p.diffuseColor)})}})}else if(o.type===Be.POINTERDOWN&&t.has((l=o.pickInfo.pickedMesh)==null?void 0:l.parent)){i=!0,r=o.event.button;const c=t.get((u=o.pickInfo.pickedMesh)==null?void 0:u.parent);c.active=!0,t.forEach(h=>{var p,g;const f=(((g=h.colliderMeshes)==null?void 0:g.indexOf((p=o==null?void 0:o.pickInfo)==null?void 0:p.pickedMesh))!=-1||h.active)&&h.dragBehavior.enabled?h.hoverMaterial:h.disableMaterial;h.gizmoMeshes.forEach(_=>{_.material=f,_.color&&(_.color=f.diffuseColor)})})}}})}dispose(){this._rootMesh.dispose(),this._beforeRenderObserver&&this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver)}}ri.PreserveScaling=!1;ri.UseAbsoluteScaling=!0;Object.defineProperty(Te.prototype,"debugLayer",{get:function(){return this._debugLayer||(this._debugLayer=new La(this)),this._debugLayer},enumerable:!0,configurable:!0});var Wg;(function(a){a[a.Properties=0]="Properties",a[a.Debug=1]="Debug",a[a.Statistics=2]="Statistics",a[a.Tools=3]="Tools",a[a.Settings=4]="Settings"})(Wg||(Wg={}));class La{get onPropertyChangedObservable(){return this.BJSINSPECTOR&&this.BJSINSPECTOR.Inspector?this.BJSINSPECTOR.Inspector.OnPropertyChangedObservable:(this._onPropertyChangedObservable||(this._onPropertyChangedObservable=new j),this._onPropertyChangedObservable)}get onSelectionChangedObservable(){return this.BJSINSPECTOR&&this.BJSINSPECTOR.Inspector?this.BJSINSPECTOR.Inspector.OnSelectionChangeObservable:(this._onSelectionChangedObservable||(this._onSelectionChangedObservable=new j),this._onSelectionChangedObservable)}constructor(e){this.BJSINSPECTOR=this._getGlobalInspector(),this._scene=e||ze.LastCreatedScene,this._scene&&this._scene.onDisposeObservable.add(()=>{this._scene._debugLayer&&this._scene._debugLayer.hide()})}_createInspector(e){if(this.isVisible())return;if(this._onPropertyChangedObservable){for(const i of this._onPropertyChangedObservable.observers)this.BJSINSPECTOR.Inspector.OnPropertyChangedObservable.add(i);this._onPropertyChangedObservable.clear(),this._onPropertyChangedObservable=void 0}if(this._onSelectionChangedObservable){for(const i of this._onSelectionChangedObservable.observers)this.BJSINSPECTOR.Inspector.OnSelectionChangedObservable.add(i);this._onSelectionChangedObservable.clear(),this._onSelectionChangedObservable=void 0}const t={...La.Config,...e};this.BJSINSPECTOR=this.BJSINSPECTOR||this._getGlobalInspector(),this.BJSINSPECTOR.Inspector.Show(this._scene,t)}select(e,t){this.BJSINSPECTOR&&(t&&(Object.prototype.toString.call(t)=="[object String]"?this.BJSINSPECTOR.Inspector.MarkLineContainerTitleForHighlighting(t):this.BJSINSPECTOR.Inspector.MarkMultipleLineContainerTitlesForHighlighting(t)),this.BJSINSPECTOR.Inspector.OnSelectionChangeObservable.notifyObservers(e))}_getGlobalInspector(){if(typeof INSPECTOR<"u")return INSPECTOR;if(typeof BABYLON<"u"&&typeof BABYLON.Inspector<"u")return BABYLON}isVisible(){return this.BJSINSPECTOR&&this.BJSINSPECTOR.Inspector.IsVisible}hide(){this.BJSINSPECTOR&&this.BJSINSPECTOR.Inspector.Hide()}get openedPanes(){return this.BJSINSPECTOR?this.BJSINSPECTOR.Inspector._OpenedPane:0}setAsActiveScene(){this.BJSINSPECTOR&&this.BJSINSPECTOR.Inspector._SetNewScene(this._scene)}popupSceneExplorer(){this.BJSINSPECTOR&&this.BJSINSPECTOR.Inspector.PopupSceneExplorer()}popupInspector(){this.BJSINSPECTOR&&this.BJSINSPECTOR.Inspector.PopupInspector()}popupEmbed(){this.BJSINSPECTOR&&this.BJSINSPECTOR.Inspector.PopupEmbed()}show(e){return new Promise(t=>{if(typeof this.BJSINSPECTOR>"u"){const i=e&&e.inspectorURL?e.inspectorURL:La.InspectorURL;ae.LoadBabylonScript(i,()=>{this._createInspector(e),t(this)})}else this._createInspector(e),t(this)})}}La.InspectorURL=`${ae._DefaultCdnUrl}/v${st.Version}/inspector/babylon.inspector.bundle.js`;La.Config={overlay:!1,showExplorer:!0,showInspector:!0,embedMode:!1,handleResize:!0,enablePopup:!0};function c_(a){let t=[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23];const i=[0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0],r=[];let s=[];const n=a.width||a.size||1,o=a.height||a.size||1,l=a.depth||a.size||1,u=a.wrap||!1;let c=a.topBaseAt===void 0?1:a.topBaseAt,h=a.bottomBaseAt===void 0?0:a.bottomBaseAt;c=(c+4)%4,h=(h+4)%4;const d=[2,0,3,1],f=[2,0,1,3];let p=d[c],g=f[h],_=[1,-1,1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,1];if(u){t=[2,3,0,2,0,1,4,5,6,4,6,7,9,10,11,9,11,8,12,14,15,12,13,14],_=[-1,1,1,1,1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,1,1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1];let R=[[1,1,1],[-1,1,1],[-1,1,-1],[1,1,-1]],O=[[-1,-1,1],[1,-1,1],[1,-1,-1],[-1,-1,-1]];const w=[17,18,19,16],M=[22,23,20,21];for(;p>0;)R.unshift(R.pop()),w.unshift(w.pop()),p--;for(;g>0;)O.unshift(O.pop()),M.unshift(M.pop()),g--;R=R.flat(),O=O.flat(),_=_.concat(R).concat(O),t.push(w[0],w[2],w[3],w[0],w[1],w[2]),t.push(M[0],M[2],M[3],M[0],M[1],M[2])}const S=[n/2,o/2,l/2];s=_.reduce((R,O,w)=>R.concat(O*S[w%3]),[]);const b=a.sideOrientation===0?0:a.sideOrientation||he.DEFAULTSIDE,y=a.faceUV||new Array(6),T=a.faceColors,v=[];for(let R=0;R<6;R++)y[R]===void 0&&(y[R]=new Ve(0,0,1,1)),T&&T[R]===void 0&&(T[R]=new xe(1,1,1,1));for(let R=0;R<6;R++)if(r.push(y[R].z,ot?1-y[R].w:y[R].w),r.push(y[R].x,ot?1-y[R].w:y[R].w),r.push(y[R].x,ot?1-y[R].y:y[R].y),r.push(y[R].z,ot?1-y[R].y:y[R].y),T)for(let O=0;O<4;O++)v.push(T[R].r,T[R].g,T[R].b,T[R].a);he._ComputeSides(b,s,t,i,r,a.frontUVs,a.backUVs);const E=new he;if(E.indices=t,E.positions=s,E.normals=i,E.uvs=r,T){const R=b===he.DOUBLESIDE?v.concat(v):v;E.colors=R}return E}function LD(a){const e=a.width||a.size||1,t=a.height||a.size||1,i=a.depth||a.size||1,r=(a.widthSegments||a.segments||1)|0,s=(a.heightSegments||a.segments||1)|0,n=(a.depthSegments||a.segments||1)|0,o=new $,l=new $,u=new $,c=Zr({width:e,height:i,subdivisionsX:r,subdivisionsY:n});$.TranslationToRef(0,-t/2,0,l),$.RotationZToRef(Math.PI,o),o.multiplyToRef(l,u),c.transform(u);const h=Zr({width:e,height:i,subdivisionsX:r,subdivisionsY:n});$.TranslationToRef(0,t/2,0,u),h.transform(u);const d=Zr({width:t,height:i,subdivisionsX:s,subdivisionsY:n});$.TranslationToRef(-e/2,0,0,l),$.RotationZToRef(Math.PI/2,o),o.multiplyToRef(l,u),d.transform(u);const f=Zr({width:t,height:i,subdivisionsX:s,subdivisionsY:n});$.TranslationToRef(e/2,0,0,l),$.RotationZToRef(-Math.PI/2,o),o.multiplyToRef(l,u),f.transform(u);const p=Zr({width:e,height:t,subdivisionsX:r,subdivisionsY:s});$.TranslationToRef(0,0,-i/2,l),$.RotationXToRef(-Math.PI/2,o),o.multiplyToRef(l,u),p.transform(u);const g=Zr({width:e,height:t,subdivisionsX:r,subdivisionsY:s});return $.TranslationToRef(0,0,i/2,l),$.RotationXToRef(Math.PI/2,o),o.multiplyToRef(l,u),g.transform(u),c.merge([h,f,d,p,g],!0),c}function Xi(a,e={},t=null){const i=new z(a,t);return e.sideOrientation=z._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,c_(e).applyToMesh(i,e.updatable),i}const uW={CreateBox:Xi};he.CreateBox=c_;z.CreateBox=(a,e,t=null,i,r)=>Xi(a,{size:e,sideOrientation:r,updatable:i},t);function h_(a){const e=(a.segments||32)|0,t=a.diameterX||a.diameter||1,i=a.diameterY||a.diameter||1,r=a.diameterZ||a.diameter||1,s=a.arc&&(a.arc<=0||a.arc>1)?1:a.arc||1,n=a.slice&&a.slice<=0?1:a.slice||1,o=a.sideOrientation===0?0:a.sideOrientation||he.DEFAULTSIDE,l=!!a.dedupTopBottomIndices,u=new m(t/2,i/2,r/2),c=2+e,h=2*c,d=[],f=[],p=[],g=[];for(let S=0;S<=c;S++){const b=S/c,y=b*Math.PI*n;for(let T=0;T<=h;T++){const v=T/h,E=v*Math.PI*2*s,R=$.RotationZ(-y),O=$.RotationY(E),w=m.TransformCoordinates(m.Up(),R),M=m.TransformCoordinates(w,O),G=M.multiply(u),H=M.divide(u).normalize();f.push(G.x,G.y,G.z),p.push(H.x,H.y,H.z),g.push(v,ot?1-b:b)}if(S>0){const T=f.length/3;for(let v=T-2*(h+1);v+h+2<T;v++)l?(S>1&&(d.push(v),d.push(v+1),d.push(v+h+1)),(S<c||n<1)&&(d.push(v+h+1),d.push(v+1),d.push(v+h+2))):(d.push(v),d.push(v+1),d.push(v+h+1),d.push(v+h+1),d.push(v+1),d.push(v+h+2))}}he._ComputeSides(o,f,d,p,g,a.frontUVs,a.backUVs);const _=new he;return _.indices=d,_.positions=f,_.normals=p,_.uvs=g,_}function Ti(a,e={},t=null){const i=new z(a,t);return e.sideOrientation=z._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,h_(e).applyToMesh(i,e.updatable),i}const cW={CreateSphere:Ti};he.CreateSphere=h_;z.CreateSphere=(a,e,t,i,r,s)=>Ti(a,{segments:e,diameterX:t,diameterY:t,diameterZ:t,sideOrientation:s,updatable:r},i);class rt{constructor(e,t){this.type=e,this.jointData=t,t.nativeParams=t.nativeParams||{}}get physicsJoint(){return this._physicsJoint}set physicsJoint(e){this._physicsJoint=e}set physicsPlugin(e){this._physicsPlugin=e}executeNativeFunction(e){e(this._physicsPlugin.world,this._physicsJoint)}}rt.DistanceJoint=0;rt.HingeJoint=1;rt.BallAndSocketJoint=2;rt.WheelJoint=3;rt.SliderJoint=4;rt.PrismaticJoint=5;rt.UniversalJoint=6;rt.Hinge2Joint=rt.WheelJoint;rt.PointToPointJoint=8;rt.SpringJoint=9;rt.LockJoint=10;class hW extends rt{constructor(e){super(rt.DistanceJoint,e)}updateDistance(e,t){this._physicsPlugin.updateDistanceJoint(this,e,t)}}class s0 extends rt{constructor(e,t){super(e,t)}setMotor(e,t){this._physicsPlugin.setMotor(this,e||0,t)}setLimit(e,t){this._physicsPlugin.setLimit(this,e,t)}}class dW extends s0{constructor(e){super(rt.HingeJoint,e)}setMotor(e,t){this._physicsPlugin.setMotor(this,e||0,t)}setLimit(e,t){this._physicsPlugin.setLimit(this,e,t)}}class fW extends s0{constructor(e){super(rt.Hinge2Joint,e)}setMotor(e,t,i=0){this._physicsPlugin.setMotor(this,e||0,t,i)}setLimit(e,t,i=0){this._physicsPlugin.setLimit(this,e,t,i)}}z._PhysicsImpostorParser=function(a,e,t){return new ve(e,t.physicsImpostor,{mass:t.physicsMass,friction:t.physicsFriction,restitution:t.physicsRestitution},a)};class ve{get isDisposed(){return this._isDisposed}get mass(){return this._physicsEngine?this._physicsEngine.getPhysicsPlugin().getBodyMass(this):0}set mass(e){this.setMass(e)}get friction(){return this._physicsEngine?this._physicsEngine.getPhysicsPlugin().getBodyFriction(this):0}set friction(e){this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().setBodyFriction(this,e)}get restitution(){return this._physicsEngine?this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this):0}set restitution(e){this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this,e)}get pressure(){if(!this._physicsEngine)return 0;const e=this._physicsEngine.getPhysicsPlugin();return e.setBodyPressure?e.getBodyPressure(this):0}set pressure(e){if(!this._physicsEngine)return;const t=this._physicsEngine.getPhysicsPlugin();t.setBodyPressure&&t.setBodyPressure(this,e)}get stiffness(){if(!this._physicsEngine)return 0;const e=this._physicsEngine.getPhysicsPlugin();return e.getBodyStiffness?e.getBodyStiffness(this):0}set stiffness(e){if(!this._physicsEngine)return;const t=this._physicsEngine.getPhysicsPlugin();t.setBodyStiffness&&t.setBodyStiffness(this,e)}get velocityIterations(){if(!this._physicsEngine)return 0;const e=this._physicsEngine.getPhysicsPlugin();return e.getBodyVelocityIterations?e.getBodyVelocityIterations(this):0}set velocityIterations(e){if(!this._physicsEngine)return;const t=this._physicsEngine.getPhysicsPlugin();t.setBodyVelocityIterations&&t.setBodyVelocityIterations(this,e)}get positionIterations(){if(!this._physicsEngine)return 0;const e=this._physicsEngine.getPhysicsPlugin();return e.getBodyPositionIterations?e.getBodyPositionIterations(this):0}set positionIterations(e){if(!this._physicsEngine)return;const t=this._physicsEngine.getPhysicsPlugin();t.setBodyPositionIterations&&t.setBodyPositionIterations(this,e)}constructor(e,t,i={mass:0},r){if(this.object=e,this.type=t,this._options=i,this._scene=r,this._pluginData={},this._bodyUpdateRequired=!1,this._onBeforePhysicsStepCallbacks=new Array,this._onAfterPhysicsStepCallbacks=new Array,this._onPhysicsCollideCallbacks=[],this._deltaPosition=m.Zero(),this._isDisposed=!1,this.soft=!1,this.segments=0,this._tmpQuat=new re,this._tmpQuat2=new re,this.beforeStep=()=>{this._physicsEngine&&(this.object.translate(this._deltaPosition,-1),this._deltaRotationConjugated&&this.object.rotationQuaternion&&this.object.rotationQuaternion.multiplyToRef(this._deltaRotationConjugated,this.object.rotationQuaternion),this.object.computeWorldMatrix(!1),this.object.parent&&this.object.rotationQuaternion?(this.getParentsRotation(),this._tmpQuat.multiplyToRef(this.object.rotationQuaternion,this._tmpQuat)):this._tmpQuat.copyFrom(this.object.rotationQuaternion||new re),this._options.disableBidirectionalTransformation||this.object.rotationQuaternion&&this._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(this,this.object.getAbsolutePosition(),this._tmpQuat),this._onBeforePhysicsStepCallbacks.forEach(s=>{s(this)}))},this.afterStep=()=>{this._physicsEngine&&(this._onAfterPhysicsStepCallbacks.forEach(s=>{s(this)}),this._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(this),this.object.parent&&this.object.rotationQuaternion&&(this.getParentsRotation(),this._tmpQuat.conjugateInPlace(),this._tmpQuat.multiplyToRef(this.object.rotationQuaternion,this.object.rotationQuaternion)),this.object.setAbsolutePosition(this.object.position),this._deltaRotation?(this.object.rotationQuaternion&&this.object.rotationQuaternion.multiplyToRef(this._deltaRotation,this.object.rotationQuaternion),this._deltaPosition.applyRotationQuaternionToRef(this._deltaRotation,ve._TmpVecs[0]),this.object.translate(ve._TmpVecs[0],1)):this.object.translate(this._deltaPosition,1),this.object.computeWorldMatrix(!0))},this.onCollideEvent=null,this.onCollide=s=>{if(!this._onPhysicsCollideCallbacks.length&&!this.onCollideEvent||!this._physicsEngine)return;const n=this._physicsEngine.getImpostorWithPhysicsBody(s.body);n&&(this.onCollideEvent&&this.onCollideEvent(this,n),this._onPhysicsCollideCallbacks.filter(o=>o.otherImpostors.indexOf(n)!==-1).forEach(o=>{o.callback(this,n,s.point,s.distance,s.impulse,s.normal)}))},!this.object){L.Error("No object was provided. A physics object is obligatory");return}this.object.parent&&i.mass!==0&&L.Warn("A physics impostor has been created for an object which has a parent. Babylon physics currently works in local space so unexpected issues may occur."),!this._scene&&e.getScene&&(this._scene=e.getScene()),this._scene&&(this.type>100&&(this.soft=!0),this._physicsEngine=this._scene.getPhysicsEngine(),this._physicsEngine?(this.object.rotationQuaternion||(this.object.rotation?this.object.rotationQuaternion=re.RotationYawPitchRoll(this.object.rotation.y,this.object.rotation.x,this.object.rotation.z):this.object.rotationQuaternion=new re),this._options.mass=i.mass===void 0?0:i.mass,this._options.friction=i.friction===void 0?.2:i.friction,this._options.restitution=i.restitution===void 0?.2:i.restitution,this.soft&&(this._options.mass=this._options.mass>0?this._options.mass:1,this._options.pressure=i.pressure===void 0?200:i.pressure,this._options.stiffness=i.stiffness===void 0?1:i.stiffness,this._options.velocityIterations=i.velocityIterations===void 0?20:i.velocityIterations,this._options.positionIterations=i.positionIterations===void 0?20:i.positionIterations,this._options.fixedPoints=i.fixedPoints===void 0?0:i.fixedPoints,this._options.margin=i.margin===void 0?0:i.margin,this._options.damping=i.damping===void 0?0:i.damping,this._options.path=i.path===void 0?null:i.path,this._options.shape=i.shape===void 0?null:i.shape),this._joints=[],!this.object.parent||this._options.ignoreParent?this._init():this.object.parent.physicsImpostor&&L.Warn("You must affect impostors to children before affecting impostor to parent.")):L.Error("Physics not enabled. Please use scene.enablePhysics(...) before creating impostors."))}_init(){this._physicsEngine&&(this._physicsEngine.removeImpostor(this),this.physicsBody=null,this._parent=this._parent||this._getPhysicsParent(),!this._isDisposed&&(!this.parent||this._options.ignoreParent)&&this._physicsEngine.addImpostor(this))}_getPhysicsParent(){return this.object.parent instanceof Rt?this.object.parent.physicsImpostor:null}isBodyInitRequired(){return this._bodyUpdateRequired||!this._physicsBody&&(!this._parent||!!this._options.ignoreParent)}setScalingUpdated(){this.forceUpdate()}forceUpdate(){this._init(),this.parent&&!this._options.ignoreParent&&this.parent.forceUpdate()}get physicsBody(){return this._parent&&!this._options.ignoreParent?this._parent.physicsBody:this._physicsBody}get parent(){return!this._options.ignoreParent&&this._parent?this._parent:null}set parent(e){this._parent=e}set physicsBody(e){this._physicsBody&&this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this),this._physicsBody=e,this.resetUpdateFlags()}resetUpdateFlags(){this._bodyUpdateRequired=!1}getObjectExtents(){if(this.object.getBoundingInfo){const e=this.object.rotationQuaternion,t=this.object.scaling.clone();this.object.rotationQuaternion=ve.IDENTITY_QUATERNION;const i=this.object.computeWorldMatrix&&this.object.computeWorldMatrix(!0);i&&i.decompose(t,void 0,void 0);const s=this.object.getBoundingInfo().boundingBox.extendSize.scale(2).multiplyInPlace(t);return s.x=Math.abs(s.x),s.y=Math.abs(s.y),s.z=Math.abs(s.z),this.object.rotationQuaternion=e,this.object.computeWorldMatrix&&this.object.computeWorldMatrix(!0),s}else return ve.DEFAULT_OBJECT_SIZE}getObjectCenter(){return this.object.getBoundingInfo?this.object.getBoundingInfo().boundingBox.centerWorld:this.object.position}getParam(e){return this._options[e]}setParam(e,t){this._options[e]=t,this._bodyUpdateRequired=!0}setMass(e){this.getParam("mass")!==e&&this.setParam("mass",e),this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().setBodyMass(this,e)}getLinearVelocity(){return this._physicsEngine?this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this):m.Zero()}setLinearVelocity(e){this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this,e)}getAngularVelocity(){return this._physicsEngine?this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this):m.Zero()}setAngularVelocity(e){this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this,e)}executeNativeFunction(e){this._physicsEngine&&e(this._physicsEngine.getPhysicsPlugin().world,this.physicsBody)}registerBeforePhysicsStep(e){this._onBeforePhysicsStepCallbacks.push(e)}unregisterBeforePhysicsStep(e){const t=this._onBeforePhysicsStepCallbacks.indexOf(e);t>-1?this._onBeforePhysicsStepCallbacks.splice(t,1):L.Warn("Function to remove was not found")}registerAfterPhysicsStep(e){this._onAfterPhysicsStepCallbacks.push(e)}unregisterAfterPhysicsStep(e){const t=this._onAfterPhysicsStepCallbacks.indexOf(e);t>-1?this._onAfterPhysicsStepCallbacks.splice(t,1):L.Warn("Function to remove was not found")}registerOnPhysicsCollide(e,t){const i=e instanceof Array?e:[e];this._onPhysicsCollideCallbacks.push({callback:t,otherImpostors:i})}unregisterOnPhysicsCollide(e,t){const i=e instanceof Array?e:[e];let r=-1;this._onPhysicsCollideCallbacks.some((n,o)=>{if(n.callback===t&&n.otherImpostors.length===i.length){const l=n.otherImpostors.every(u=>i.indexOf(u)>-1);return l&&(r=o),l}return!1})?this._onPhysicsCollideCallbacks.splice(r,1):L.Warn("Function to remove was not found")}getParentsRotation(){let e=this.object.parent;for(this._tmpQuat.copyFromFloats(0,0,0,1);e;)e.rotationQuaternion?this._tmpQuat2.copyFrom(e.rotationQuaternion):re.RotationYawPitchRollToRef(e.rotation.y,e.rotation.x,e.rotation.z,this._tmpQuat2),this._tmpQuat.multiplyToRef(this._tmpQuat2,this._tmpQuat),e=e.parent;return this._tmpQuat}applyForce(e,t){return this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().applyForce(this,e,t),this}applyImpulse(e,t){return this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().applyImpulse(this,e,t),this}createJoint(e,t,i){const r=new rt(t,i);return this.addJoint(e,r),this}addJoint(e,t){return this._joints.push({otherImpostor:e,joint:t}),this._physicsEngine&&this._physicsEngine.addJoint(this,e,t),this}addAnchor(e,t,i,r,s){if(!this._physicsEngine)return this;const n=this._physicsEngine.getPhysicsPlugin();return n.appendAnchor?(this._physicsEngine&&n.appendAnchor(this,e,t,i,r,s),this):this}addHook(e,t,i,r){if(!this._physicsEngine)return this;const s=this._physicsEngine.getPhysicsPlugin();return s.appendAnchor?(this._physicsEngine&&s.appendHook(this,e,t,i,r),this):this}sleep(){return this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().sleepBody(this),this}wakeUp(){return this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().wakeUpBody(this),this}clone(e){return e?new ve(e,this.type,this._options,this._scene):null}dispose(){this._physicsEngine&&(this._joints.forEach(e=>{this._physicsEngine&&this._physicsEngine.removeJoint(this,e.otherImpostor,e.joint)}),this._physicsEngine.removeImpostor(this),this.parent&&this.parent.forceUpdate(),this._isDisposed=!0)}setDeltaPosition(e){this._deltaPosition.copyFrom(e)}setDeltaRotation(e){this._deltaRotation||(this._deltaRotation=new re),this._deltaRotation.copyFrom(e),this._deltaRotationConjugated=this._deltaRotation.conjugate()}getBoxSizeToRef(e){return this._physicsEngine&&this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this,e),this}getRadius(){return this._physicsEngine?this._physicsEngine.getPhysicsPlugin().getRadius(this):0}syncBoneWithImpostor(e,t,i,r,s){const n=ve._TmpVecs[0],o=this.object;if(o.rotationQuaternion)if(s){const l=ve._TmpQuat;o.rotationQuaternion.multiplyToRef(s,l),e.setRotationQuaternion(l,1,t)}else e.setRotationQuaternion(o.rotationQuaternion,1,t);n.x=0,n.y=0,n.z=0,i&&(n.x=i.x,n.y=i.y,n.z=i.z,e.getDirectionToRef(n,t,n),r==null&&(r=i.length()),n.x*=r,n.y*=r,n.z*=r),e.getParent()?(n.addInPlace(o.getAbsolutePosition()),e.setAbsolutePosition(n,t)):(t.setAbsolutePosition(o.getAbsolutePosition()),t.position.x-=n.x,t.position.y-=n.y,t.position.z-=n.z)}syncImpostorWithBone(e,t,i,r,s,n){const o=this.object;if(o.rotationQuaternion)if(s){const c=ve._TmpQuat;e.getRotationQuaternionToRef(1,t,c),c.multiplyToRef(s,o.rotationQuaternion)}else e.getRotationQuaternionToRef(1,t,o.rotationQuaternion);const l=ve._TmpVecs[0],u=ve._TmpVecs[1];n||(n=ve._TmpVecs[2],n.x=0,n.y=1,n.z=0),e.getDirectionToRef(n,t,u),e.getAbsolutePositionToRef(t,l),r==null&&i&&(r=i.length()),r!=null&&(l.x+=u.x*r,l.y+=u.y*r,l.z+=u.z*r),o.setAbsolutePosition(l)}}ve.DEFAULT_OBJECT_SIZE=new m(1,1,1);ve.IDENTITY_QUATERNION=re.Identity();ve._TmpVecs=uu(3,m.Zero);ve._TmpQuat=re.Identity();ve.NoImpostor=0;ve.SphereImpostor=1;ve.BoxImpostor=2;ve.PlaneImpostor=3;ve.MeshImpostor=4;ve.CapsuleImpostor=6;ve.CylinderImpostor=7;ve.ParticleImpostor=8;ve.HeightmapImpostor=9;ve.ConvexHullImpostor=10;ve.CustomImpostor=100;ve.RopeImpostor=101;ve.ClothImpostor=102;ve.SoftbodyImpostor=103;function d_(a={subdivisions:2,tessellation:16,height:1,radius:.25,capSubdivisions:6}){const e=Math.max(a.subdivisions?a.subdivisions:2,1)|0,t=Math.max(a.tessellation?a.tessellation:16,3)|0,i=Math.max(a.height?a.height:1,0),r=Math.max(a.radius?a.radius:.25,0),s=Math.max(a.capSubdivisions?a.capSubdivisions:6,1)|0,n=t,o=e,l=Math.max(a.radiusTop?a.radiusTop:r,0),u=Math.max(a.radiusBottom?a.radiusBottom:r,0),c=i-(l+u),h=0,d=2*Math.PI,f=Math.max(a.topCapSubdivisions?a.topCapSubdivisions:s,1),p=Math.max(a.bottomCapSubdivisions?a.bottomCapSubdivisions:s,1),g=Math.acos((u-l)/i);let _=[];const S=[],b=[],y=[];let T=0;const v=[],E=c*.5,R=Math.PI*.5;let O,w;const M=m.Zero(),G=m.Zero(),H=Math.cos(g),q=Math.sin(g),X=new Q(l*q,E+l*H).subtract(new Q(u*q,-E+u*H)).length(),ee=l*g+X+u*(R-g);let oe=0;for(w=0;w<=f;w++){const Z=[],D=R-g*(w/f);oe+=l*g/f;const W=Math.cos(D),K=Math.sin(D),ue=W*l;for(O=0;O<=n;O++){const ye=O/n,se=ye*d+h,ce=Math.sin(se),fe=Math.cos(se);G.x=ue*ce,G.y=E+K*l,G.z=ue*fe,S.push(G.x,G.y,G.z),M.set(W*ce,K,W*fe),b.push(M.x,M.y,M.z),y.push(ye,ot?oe/ee:1-oe/ee),Z.push(T),T++}v.push(Z)}const _e=i-l-u+H*l-H*u,te=q*(u-l)/_e;for(w=1;w<=o;w++){const Z=[];oe+=X/o;const D=q*(w*(u-l)/o+l);for(O=0;O<=n;O++){const W=O/n,K=W*d+h,ue=Math.sin(K),ye=Math.cos(K);G.x=D*ue,G.y=E+H*l-w*_e/o,G.z=D*ye,S.push(G.x,G.y,G.z),M.set(ue,te,ye).normalize(),b.push(M.x,M.y,M.z),y.push(W,ot?oe/ee:1-oe/ee),Z.push(T),T++}v.push(Z)}for(w=1;w<=p;w++){const Z=[],D=R-g-(Math.PI-g)*(w/p);oe+=u*g/p;const W=Math.cos(D),K=Math.sin(D),ue=W*u;for(O=0;O<=n;O++){const ye=O/n,se=ye*d+h,ce=Math.sin(se),fe=Math.cos(se);G.x=ue*ce,G.y=-E+K*u,G.z=ue*fe,S.push(G.x,G.y,G.z),M.set(W*ce,K,W*fe),b.push(M.x,M.y,M.z),y.push(ye,ot?oe/ee:1-oe/ee),Z.push(T),T++}v.push(Z)}for(O=0;O<n;O++)for(w=0;w<f+o+p;w++){const Z=v[w][O],D=v[w+1][O],W=v[w+1][O+1],K=v[w][O+1];_.push(Z),_.push(D),_.push(K),_.push(D),_.push(W),_.push(K)}if(_=_.reverse(),a.orientation&&!a.orientation.equals(m.Up())){const Z=new $;a.orientation.clone().scale(Math.PI*.5).cross(m.Up()).toQuaternion().toRotationMatrix(Z);const D=m.Zero();for(let W=0;W<S.length;W+=3)D.set(S[W],S[W+1],S[W+2]),m.TransformCoordinatesToRef(D.clone(),Z,D),S[W]=D.x,S[W+1]=D.y,S[W+2]=D.z}const ie=new he;return ie.positions=S,ie.normals=b,ie.uvs=y,ie.indices=_,ie}function f_(a,e={orientation:m.Up(),subdivisions:2,tessellation:16,height:1,radius:.25,capSubdivisions:6,updatable:!1},t=null){const i=new z(a,t);return d_(e).applyToMesh(i,e.updatable),i}const pW={CreateCapsule:f_};z.CreateCapsule=(a,e,t)=>f_(a,e,t);he.CreateCapsule=d_;function n0(a){let e=a.pathArray;const t=a.closeArray||!1,i=a.closePath||!1,r=a.invertUV||!1,s=Math.floor(e[0].length/2);let n=a.offset||s;n=n>s?s:Math.floor(n);const o=a.sideOrientation===0?0:a.sideOrientation||he.DEFAULTSIDE,l=a.uvs,u=a.colors,c=[],h=[],d=[],f=[],p=[],g=[],_=[],S=[];let b;const y=[],T=[];let v,E,R;if(e.length<2){const Se=[],Ge=[];for(E=0;E<e[0].length-n;E++)Se.push(e[0][E]),Ge.push(e[0][E+n]);e=[Se,Ge]}let O=0;const w=i?1:0,M=t?1:0;let G,H;b=e[0].length;let q,X;for(v=0;v<e.length+M;v++){for(_[v]=0,p[v]=[0],G=v===e.length?e[0]:e[v],H=G.length,b=b<H?b:H,R=0;R<H;)c.push(G[R].x,G[R].y,G[R].z),R>0&&(q=G[R].subtract(G[R-1]).length(),X=q+_[v],p[v].push(X),_[v]=X),R++;i&&(R--,c.push(G[0].x,G[0].y,G[0].z),q=G[R].subtract(G[0]).length(),X=q+_[v],p[v].push(X),_[v]=X),y[v]=H+w,T[v]=O,O+=H+w}let ee,oe,_e=null,te=null;for(E=0;E<b+w;E++)for(S[E]=0,g[E]=[0],v=0;v<e.length-1+M;v++)ee=e[v],oe=v===e.length-1?e[0]:e[v+1],E===b?(_e=ee[0],te=oe[0]):(_e=ee[E],te=oe[E]),q=te.subtract(_e).length(),X=q+S[E],g[E].push(X),S[E]=X;let ie,Z;if(l)for(v=0;v<l.length;v++)f.push(l[v].x,ot?1-l[v].y:l[v].y);else for(v=0;v<e.length+M;v++)for(E=0;E<b+w;E++)ie=_[v]!=0?p[v][E]/_[v]:0,Z=S[E]!=0?g[E][v]/S[E]:0,r?f.push(Z,ie):f.push(ie,ot?1-Z:Z);v=0;let D=0,W=y[v]-1,K=y[v+1]-1,ue=W<K?W:K,ye=T[1]-T[0];const se=y.length-1;for(;D<=ue&&v<se;)h.push(D,D+ye,D+1),h.push(D+ye+1,D+1,D+ye),D+=1,D===ue&&(v++,ye=T[v+1]-T[v],W=y[v]-1,K=y[v+1]-1,D=T[v],ue=W<K?W+D:K+D);if(he.ComputeNormals(c,h,d),i){let Se=0,Ge=0;for(v=0;v<e.length;v++){Se=T[v]*3,v+1<e.length?Ge=(T[v+1]-1)*3:Ge=d.length-3,d[Se]=(d[Se]+d[Ge])*.5,d[Se+1]=(d[Se+1]+d[Ge+1])*.5,d[Se+2]=(d[Se+2]+d[Ge+2])*.5;const Pe=Math.sqrt(d[Se]*d[Se]+d[Se+1]*d[Se+1]+d[Se+2]*d[Se+2]);d[Se]/=Pe,d[Se+1]/=Pe,d[Se+2]/=Pe,d[Ge]=d[Se],d[Ge+1]=d[Se+1],d[Ge+2]=d[Se+2]}}if(t){let Se=T[0]*3,Ge=T[e.length]*3;for(E=0;E<b+w;E++){d[Se]=(d[Se]+d[Ge])*.5,d[Se+1]=(d[Se+1]+d[Ge+1])*.5,d[Se+2]=(d[Se+2]+d[Ge+2])*.5;const Pe=Math.sqrt(d[Se]*d[Se]+d[Se+1]*d[Se+1]+d[Se+2]*d[Se+2]);d[Se]/=Pe,d[Se+1]/=Pe,d[Se+2]/=Pe,d[Ge]=d[Se],d[Ge+1]=d[Se+1],d[Ge+2]=d[Se+2],Se+=3,Ge+=3}}he._ComputeSides(o,c,h,d,f,a.frontUVs,a.backUVs);let ce=null;if(u){ce=new Float32Array(u.length*4);for(let Se=0;Se<u.length;Se++)ce[Se*4]=u[Se].r,ce[Se*4+1]=u[Se].g,ce[Se*4+2]=u[Se].b,ce[Se*4+3]=u[Se].a}const fe=new he,pe=new Float32Array(c),Ie=new Float32Array(d),vt=new Float32Array(f);return fe.indices=h,fe.positions=pe,fe.normals=Ie,fe.uvs=vt,ce&&fe.set(ce,N.ColorKind),i&&(fe._idx=T),fe}function mn(a,e,t=null){const i=e.pathArray,r=e.closeArray,s=e.closePath,n=z._GetDefaultSideOrientation(e.sideOrientation),o=e.instance,l=e.updatable;if(o){const u=V.Vector3[0].setAll(Number.MAX_VALUE),c=V.Vector3[1].setAll(-Number.MAX_VALUE),h=f=>{let p=i[0].length;const g=o;let _=0;const S=g._originalBuilderSideOrientation===z.DOUBLESIDE?2:1;for(let b=1;b<=S;++b)for(let y=0;y<i.length;++y){const T=i[y],v=T.length;p=p<v?p:v;for(let E=0;E<p;++E){const R=T[E];f[_]=R.x,f[_+1]=R.y,f[_+2]=R.z,u.minimizeInPlaceFromFloats(R.x,R.y,R.z),c.maximizeInPlaceFromFloats(R.x,R.y,R.z),_+=3}if(g._creationDataStorage&&g._creationDataStorage.closePath){const E=T[0];f[_]=E.x,f[_+1]=E.y,f[_+2]=E.z,_+=3}}},d=o.getVerticesData(N.PositionKind);if(h(d),o.hasBoundingInfo?o.getBoundingInfo().reConstruct(u,c,o._worldMatrix):o.buildBoundingInfo(u,c,o._worldMatrix),o.updateVerticesData(N.PositionKind,d,!1,!1),e.colors){const f=o.getVerticesData(N.ColorKind);for(let p=0,g=0;p<e.colors.length;p++,g+=4){const _=e.colors[p];f[g]=_.r,f[g+1]=_.g,f[g+2]=_.b,f[g+3]=_.a}o.updateVerticesData(N.ColorKind,f,!1,!1)}if(e.uvs){const f=o.getVerticesData(N.UVKind);for(let p=0;p<e.uvs.length;p++)f[p*2]=e.uvs[p].x,f[p*2+1]=ot?1-e.uvs[p].y:e.uvs[p].y;o.updateVerticesData(N.UVKind,f,!1,!1)}if(!o.areNormalsFrozen||o.isFacetDataEnabled){const f=o.getIndices(),p=o.getVerticesData(N.NormalKind),g=o.isFacetDataEnabled?o.getFacetDataParameters():null;if(he.ComputeNormals(d,f,p,g),o._creationDataStorage&&o._creationDataStorage.closePath){let _=0,S=0;for(let b=0;b<i.length;b++)_=o._creationDataStorage.idx[b]*3,b+1<i.length?S=(o._creationDataStorage.idx[b+1]-1)*3:S=p.length-3,p[_]=(p[_]+p[S])*.5,p[_+1]=(p[_+1]+p[S+1])*.5,p[_+2]=(p[_+2]+p[S+2])*.5,p[S]=p[_],p[S+1]=p[_+1],p[S+2]=p[_+2]}o.areNormalsFrozen||o.updateVerticesData(N.NormalKind,p,!1,!1)}return o}else{const u=new z(a,t);u._originalBuilderSideOrientation=n,u._creationDataStorage=new ty;const c=n0(e);return s&&(u._creationDataStorage.idx=c._idx),u._creationDataStorage.closePath=s,u._creationDataStorage.closeArray=r,c.applyToMesh(u,l),u}}const mW={CreateRibbon:mn};he.CreateRibbon=n0;z.CreateRibbon=(a,e,t=!1,i,r,s,n=!1,o,l)=>mn(a,{pathArray:e,closeArray:t,closePath:i,offset:r,updatable:n,sideOrientation:o,instance:l},s);function p_(a){const e=[],t=[],i=[],r=[],s=a.radius||.5,n=a.tessellation||64,o=a.arc&&(a.arc<=0||a.arc>1)?1:a.arc||1,l=a.sideOrientation===0?0:a.sideOrientation||he.DEFAULTSIDE;e.push(0,0,0),r.push(.5,.5);const u=Math.PI*2*o,c=o===1?u/n:u/(n-1);let h=0;for(let p=0;p<n;p++){const g=Math.cos(h),_=Math.sin(h),S=(g+1)/2,b=(1-_)/2;e.push(s*g,s*_,0),r.push(S,ot?1-b:b),h+=c}o===1&&(e.push(e[3],e[4],e[5]),r.push(r[2],ot?1-r[3]:r[3]));const d=e.length/3;for(let p=1;p<d-1;p++)t.push(p+1,0,p);he.ComputeNormals(e,t,i),he._ComputeSides(l,e,t,i,r,a.frontUVs,a.backUVs);const f=new he;return f.indices=t,f.positions=e,f.normals=i,f.uvs=r,f}function Ou(a,e={},t=null){const i=new z(a,t);return e.sideOrientation=z._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,p_(e).applyToMesh(i,e.updatable),i}const _W={CreateDisc:Ou};he.CreateDisc=p_;z.CreateDisc=(a,e,t,i=null,r,s)=>Ou(a,{radius:e,tessellation:t,sideOrientation:s,updatable:r},i);function So(a){const e=a.pattern||z.NO_FLIP,t=a.tileWidth||a.tileSize||1,i=a.tileHeight||a.tileSize||1,r=a.alignHorizontal||0,s=a.alignVertical||0,n=a.width||a.size||1,o=Math.floor(n/t);let l=n-o*t;const u=a.height||a.size||1,c=Math.floor(u/i);let h=u-c*i;const d=t*o/2,f=i*c/2;let p=0,g=0,_=0,S=0,b=0,y=0;if(l>0||h>0){switch(_=-d,S=-f,b=d,y=f,r){case z.CENTER:l/=2,_-=l,b+=l;break;case z.LEFT:b+=l,p=-l/2;break;case z.RIGHT:_-=l,p=l/2;break}switch(s){case z.CENTER:h/=2,S-=h,y+=h;break;case z.BOTTOM:y+=h,g=-h/2;break;case z.TOP:S-=h,g=h/2;break}}const T=[],v=[],E=[];E[0]=[0,0,1,0,1,1,0,1],E[1]=[0,0,1,0,1,1,0,1],(e===z.ROTATE_TILE||e===z.ROTATE_ROW)&&(E[1]=[1,1,0,1,0,0,1,0]),(e===z.FLIP_TILE||e===z.FLIP_ROW)&&(E[1]=[1,0,0,0,0,1,1,1]),(e===z.FLIP_N_ROTATE_TILE||e===z.FLIP_N_ROTATE_ROW)&&(E[1]=[0,1,1,1,1,0,0,0]);let R=[];const O=[],w=[];let M=0;for(let X=0;X<c;X++)for(let ee=0;ee<o;ee++)T.push(-d+ee*t+p,-f+X*i+g,0),T.push(-d+(ee+1)*t+p,-f+X*i+g,0),T.push(-d+(ee+1)*t+p,-f+(X+1)*i+g,0),T.push(-d+ee*t+p,-f+(X+1)*i+g,0),w.push(M,M+1,M+3,M+1,M+2,M+3),e===z.FLIP_TILE||e===z.ROTATE_TILE||e===z.FLIP_N_ROTATE_TILE?R=R.concat(E[(ee%2+X%2)%2]):e===z.FLIP_ROW||e===z.ROTATE_ROW||e===z.FLIP_N_ROTATE_ROW?R=R.concat(E[X%2]):R=R.concat(E[0]),O.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),v.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1),M+=4;if(l>0||h>0){const X=h>0&&(s===z.CENTER||s===z.TOP),ee=h>0&&(s===z.CENTER||s===z.BOTTOM),oe=l>0&&(r===z.CENTER||r===z.RIGHT),_e=l>0&&(r===z.CENTER||r===z.LEFT);let te=[],ie,Z,D,W;if(X&&oe&&(T.push(_+p,S+g,0),T.push(-d+p,S+g,0),T.push(-d+p,S+h+g,0),T.push(_+p,S+h+g,0),w.push(M,M+1,M+3,M+1,M+2,M+3),M+=4,ie=1-l/t,Z=1-h/i,D=1,W=1,te=[ie,Z,D,Z,D,W,ie,W],e===z.ROTATE_ROW&&(te=[1-ie,1-Z,1-D,1-Z,1-D,1-W,1-ie,1-W]),e===z.FLIP_ROW&&(te=[1-ie,Z,1-D,Z,1-D,W,1-ie,W]),e===z.FLIP_N_ROTATE_ROW&&(te=[ie,1-Z,D,1-Z,D,1-W,ie,1-W]),R=R.concat(te),O.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),v.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),X&&_e&&(T.push(d+p,S+g,0),T.push(b+p,S+g,0),T.push(b+p,S+h+g,0),T.push(d+p,S+h+g,0),w.push(M,M+1,M+3,M+1,M+2,M+3),M+=4,ie=0,Z=1-h/i,D=l/t,W=1,te=[ie,Z,D,Z,D,W,ie,W],(e===z.ROTATE_ROW||e===z.ROTATE_TILE&&o%2===0)&&(te=[1-ie,1-Z,1-D,1-Z,1-D,1-W,1-ie,1-W]),(e===z.FLIP_ROW||e===z.FLIP_TILE&&o%2===0)&&(te=[1-ie,Z,1-D,Z,1-D,W,1-ie,W]),(e===z.FLIP_N_ROTATE_ROW||e===z.FLIP_N_ROTATE_TILE&&o%2===0)&&(te=[ie,1-Z,D,1-Z,D,1-W,ie,1-W]),R=R.concat(te),O.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),v.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),ee&&oe&&(T.push(_+p,f+g,0),T.push(-d+p,f+g,0),T.push(-d+p,y+g,0),T.push(_+p,y+g,0),w.push(M,M+1,M+3,M+1,M+2,M+3),M+=4,ie=1-l/t,Z=0,D=1,W=h/i,te=[ie,Z,D,Z,D,W,ie,W],(e===z.ROTATE_ROW&&c%2===1||e===z.ROTATE_TILE&&c%1===0)&&(te=[1-ie,1-Z,1-D,1-Z,1-D,1-W,1-ie,1-W]),(e===z.FLIP_ROW&&c%2===1||e===z.FLIP_TILE&&c%2===0)&&(te=[1-ie,Z,1-D,Z,1-D,W,1-ie,W]),(e===z.FLIP_N_ROTATE_ROW&&c%2===1||e===z.FLIP_N_ROTATE_TILE&&c%2===0)&&(te=[ie,1-Z,D,1-Z,D,1-W,ie,1-W]),R=R.concat(te),O.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),v.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),ee&&_e&&(T.push(d+p,f+g,0),T.push(b+p,f+g,0),T.push(b+p,y+g,0),T.push(d+p,y+g,0),w.push(M,M+1,M+3,M+1,M+2,M+3),M+=4,ie=0,Z=0,D=l/t,W=h/i,te=[ie,Z,D,Z,D,W,ie,W],(e===z.ROTATE_ROW&&c%2===1||e===z.ROTATE_TILE&&(c+o)%2===1)&&(te=[1-ie,1-Z,1-D,1-Z,1-D,1-W,1-ie,1-W]),(e===z.FLIP_ROW&&c%2===1||e===z.FLIP_TILE&&(c+o)%2===1)&&(te=[1-ie,Z,1-D,Z,1-D,W,1-ie,W]),(e===z.FLIP_N_ROTATE_ROW&&c%2===1||e===z.FLIP_N_ROTATE_TILE&&(c+o)%2===1)&&(te=[ie,1-Z,D,1-Z,D,1-W,ie,1-W]),R=R.concat(te),O.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),v.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),X){const K=[];ie=0,Z=1-h/i,D=1,W=1,K[0]=[ie,Z,D,Z,D,W,ie,W],K[1]=[ie,Z,D,Z,D,W,ie,W],(e===z.ROTATE_TILE||e===z.ROTATE_ROW)&&(K[1]=[1-ie,1-Z,1-D,1-Z,1-D,1-W,1-ie,1-W]),(e===z.FLIP_TILE||e===z.FLIP_ROW)&&(K[1]=[1-ie,Z,1-D,Z,1-D,W,1-ie,W]),(e===z.FLIP_N_ROTATE_TILE||e===z.FLIP_N_ROTATE_ROW)&&(K[1]=[ie,1-Z,D,1-Z,D,1-W,ie,1-W]);for(let ue=0;ue<o;ue++)T.push(-d+ue*t+p,S+g,0),T.push(-d+(ue+1)*t+p,S+g,0),T.push(-d+(ue+1)*t+p,S+h+g,0),T.push(-d+ue*t+p,S+h+g,0),w.push(M,M+1,M+3,M+1,M+2,M+3),M+=4,e===z.FLIP_TILE||e===z.ROTATE_TILE||e===z.FLIP_N_ROTATE_TILE?R=R.concat(K[(ue+1)%2]):e===z.FLIP_ROW||e===z.ROTATE_ROW||e===z.FLIP_N_ROTATE_ROW?R=R.concat(K[1]):R=R.concat(K[0]),O.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),v.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}if(ee){const K=[];ie=0,Z=0,D=1,W=h/i,K[0]=[ie,Z,D,Z,D,W,ie,W],K[1]=[ie,Z,D,Z,D,W,ie,W],(e===z.ROTATE_TILE||e===z.ROTATE_ROW)&&(K[1]=[1-ie,1-Z,1-D,1-Z,1-D,1-W,1-ie,1-W]),(e===z.FLIP_TILE||e===z.FLIP_ROW)&&(K[1]=[1-ie,Z,1-D,Z,1-D,W,1-ie,W]),(e===z.FLIP_N_ROTATE_TILE||e===z.FLIP_N_ROTATE_ROW)&&(K[1]=[ie,1-Z,D,1-Z,D,1-W,ie,1-W]);for(let ue=0;ue<o;ue++)T.push(-d+ue*t+p,y-h+g,0),T.push(-d+(ue+1)*t+p,y-h+g,0),T.push(-d+(ue+1)*t+p,y+g,0),T.push(-d+ue*t+p,y+g,0),w.push(M,M+1,M+3,M+1,M+2,M+3),M+=4,e===z.FLIP_TILE||e===z.ROTATE_TILE||e===z.FLIP_N_ROTATE_TILE?R=R.concat(K[(ue+c)%2]):e===z.FLIP_ROW||e===z.ROTATE_ROW||e===z.FLIP_N_ROTATE_ROW?R=R.concat(K[c%2]):R=R.concat(K[0]),O.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),v.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}if(oe){const K=[];ie=1-l/t,Z=0,D=1,W=1,K[0]=[ie,Z,D,Z,D,W,ie,W],K[1]=[ie,Z,D,Z,D,W,ie,W],(e===z.ROTATE_TILE||e===z.ROTATE_ROW)&&(K[1]=[1-ie,1-Z,1-D,1-Z,1-D,1-W,1-ie,1-W]),(e===z.FLIP_TILE||e===z.FLIP_ROW)&&(K[1]=[1-ie,Z,1-D,Z,1-D,W,1-ie,W]),(e===z.FLIP_N_ROTATE_TILE||e===z.FLIP_N_ROTATE_ROW)&&(K[1]=[ie,1-Z,D,1-Z,D,1-W,ie,1-W]);for(let ue=0;ue<c;ue++)T.push(_+p,-f+ue*i+g,0),T.push(_+l+p,-f+ue*i+g,0),T.push(_+l+p,-f+(ue+1)*i+g,0),T.push(_+p,-f+(ue+1)*i+g,0),w.push(M,M+1,M+3,M+1,M+2,M+3),M+=4,e===z.FLIP_TILE||e===z.ROTATE_TILE||e===z.FLIP_N_ROTATE_TILE?R=R.concat(K[(ue+1)%2]):e===z.FLIP_ROW||e===z.ROTATE_ROW||e===z.FLIP_N_ROTATE_ROW?R=R.concat(K[ue%2]):R=R.concat(K[0]),O.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),v.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}if(_e){const K=[];ie=0,Z=0,D=l/i,W=1,K[0]=[ie,Z,D,Z,D,W,ie,W],K[1]=[ie,Z,D,Z,D,W,ie,W],(e===z.ROTATE_TILE||e===z.ROTATE_ROW)&&(K[1]=[1-ie,1-Z,1-D,1-Z,1-D,1-W,1-ie,1-W]),(e===z.FLIP_TILE||e===z.FLIP_ROW)&&(K[1]=[1-ie,Z,1-D,Z,1-D,W,1-ie,W]),(e===z.FLIP_N_ROTATE_TILE||e===z.FLIP_N_ROTATE_ROW)&&(K[1]=[ie,1-Z,D,1-Z,D,1-W,ie,1-W]);for(let ue=0;ue<c;ue++)T.push(b-l+p,-f+ue*i+g,0),T.push(b+p,-f+ue*i+g,0),T.push(b+p,-f+(ue+1)*i+g,0),T.push(b-l+p,-f+(ue+1)*i+g,0),w.push(M,M+1,M+3,M+1,M+2,M+3),M+=4,e===z.FLIP_TILE||e===z.ROTATE_TILE||e===z.FLIP_N_ROTATE_TILE?R=R.concat(K[(ue+o)%2]):e===z.FLIP_ROW||e===z.ROTATE_ROW||e===z.FLIP_N_ROTATE_ROW?R=R.concat(K[ue%2]):R=R.concat(K[0]),O.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),v.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}}const G=a.sideOrientation===0?0:a.sideOrientation||he.DEFAULTSIDE;he._ComputeSides(G,T,w,v,R,a.frontUVs,a.backUVs);const H=new he;H.indices=w,H.positions=T,H.normals=v,H.uvs=R;const q=G===he.DOUBLESIDE?O.concat(O):O;return H.colors=q,H}function a0(a,e,t=null){const i=new z(a,t);return e.sideOrientation=z._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,So(e).applyToMesh(i,e.updatable),i}const gW={CreateTiledPlane:a0};he.CreateTiledPlane=So;function o0(a){const t=a.faceUV||new Array(6),i=a.faceColors,r=a.pattern||z.NO_FLIP,s=a.width||a.size||1,n=a.height||a.size||1,o=a.depth||a.size||1,l=a.tileWidth||a.tileSize||1,u=a.tileHeight||a.tileSize||1,c=a.alignHorizontal||0,h=a.alignVertical||0,d=a.sideOrientation===0?0:a.sideOrientation||he.DEFAULTSIDE;for(let D=0;D<6;D++)t[D]===void 0&&(t[D]=new Ve(0,0,1,1)),i&&i[D]===void 0&&(i[D]=new xe(1,1,1,1));const f=s/2,p=n/2,g=o/2,_=[];for(let D=0;D<2;D++)_[D]=So({pattern:r,tileWidth:l,tileHeight:u,width:s,height:n,alignVertical:h,alignHorizontal:c,sideOrientation:d});for(let D=2;D<4;D++)_[D]=So({pattern:r,tileWidth:l,tileHeight:u,width:o,height:n,alignVertical:h,alignHorizontal:c,sideOrientation:d});let S=h;h===z.BOTTOM?S=z.TOP:h===z.TOP&&(S=z.BOTTOM);for(let D=4;D<6;D++)_[D]=So({pattern:r,tileWidth:l,tileHeight:u,width:s,height:o,alignVertical:S,alignHorizontal:c,sideOrientation:d});let b=[],y=[],T=[],v=[];const E=[],R=[],O=[],w=[];let M=0,G=0;for(let D=0;D<6;D++){const W=_[D].positions.length;R[D]=[],O[D]=[];for(let K=0;K<W/3;K++)R[D].push(new m(_[D].positions[3*K],_[D].positions[3*K+1],_[D].positions[3*K+2])),O[D].push(new m(_[D].normals[3*K],_[D].normals[3*K+1],_[D].normals[3*K+2]));M=_[D].uvs.length,w[D]=[];for(let K=0;K<M;K+=2)w[D][K]=t[D].x+(t[D].z-t[D].x)*_[D].uvs[K],w[D][K+1]=t[D].y+(t[D].w-t[D].y)*_[D].uvs[K+1],ot&&(w[D][K+1]=1-w[D][K+1]);if(T=T.concat(w[D]),v=v.concat(_[D].indices.map(K=>K+G)),G+=R[D].length,i)for(let K=0;K<4;K++)E.push(i[D].r,i[D].g,i[D].b,i[D].a)}const H=new m(0,0,g),q=$.RotationY(Math.PI);b=R[0].map(D=>m.TransformNormal(D,q).add(H)).map(D=>[D.x,D.y,D.z]).reduce((D,W)=>D.concat(W),[]),y=O[0].map(D=>m.TransformNormal(D,q)).map(D=>[D.x,D.y,D.z]).reduce((D,W)=>D.concat(W),[]),b=b.concat(R[1].map(D=>D.subtract(H)).map(D=>[D.x,D.y,D.z]).reduce((D,W)=>D.concat(W),[])),y=y.concat(O[1].map(D=>[D.x,D.y,D.z]).reduce((D,W)=>D.concat(W),[]));const X=new m(f,0,0),ee=$.RotationY(-Math.PI/2);b=b.concat(R[2].map(D=>m.TransformNormal(D,ee).add(X)).map(D=>[D.x,D.y,D.z]).reduce((D,W)=>D.concat(W),[])),y=y.concat(O[2].map(D=>m.TransformNormal(D,ee)).map(D=>[D.x,D.y,D.z]).reduce((D,W)=>D.concat(W),[]));const oe=$.RotationY(Math.PI/2);b=b.concat(R[3].map(D=>m.TransformNormal(D,oe).subtract(X)).map(D=>[D.x,D.y,D.z]).reduce((D,W)=>D.concat(W),[])),y=y.concat(O[3].map(D=>m.TransformNormal(D,oe)).map(D=>[D.x,D.y,D.z]).reduce((D,W)=>D.concat(W),[]));const _e=new m(0,p,0),te=$.RotationX(Math.PI/2);b=b.concat(R[4].map(D=>m.TransformNormal(D,te).add(_e)).map(D=>[D.x,D.y,D.z]).reduce((D,W)=>D.concat(W),[])),y=y.concat(O[4].map(D=>m.TransformNormal(D,te)).map(D=>[D.x,D.y,D.z]).reduce((D,W)=>D.concat(W),[]));const ie=$.RotationX(-Math.PI/2);b=b.concat(R[5].map(D=>m.TransformNormal(D,ie).subtract(_e)).map(D=>[D.x,D.y,D.z]).reduce((D,W)=>D.concat(W),[])),y=y.concat(O[5].map(D=>m.TransformNormal(D,ie)).map(D=>[D.x,D.y,D.z]).reduce((D,W)=>D.concat(W),[])),he._ComputeSides(d,b,v,y,T);const Z=new he;if(Z.indices=v,Z.positions=b,Z.normals=y,Z.uvs=T,i){const D=d===he.DOUBLESIDE?E.concat(E):E;Z.colors=D}return Z}function l0(a,e,t=null){const i=new z(a,t);return e.sideOrientation=z._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,o0(e).applyToMesh(i,e.updatable),i}const xW={CreateTiledBox:l0};he.CreateTiledBox=o0;function u0(a){const e=[],t=[],i=[],r=[],s=a.radius||2,n=a.tube||.5,o=a.radialSegments||32,l=a.tubularSegments||32,u=a.p||2,c=a.q||3,h=a.sideOrientation===0?0:a.sideOrientation||he.DEFAULTSIDE,d=_=>{const S=Math.cos(_),b=Math.sin(_),y=c/u*_,T=Math.cos(y),v=s*(2+T)*.5*S,E=s*(2+T)*b*.5,R=s*Math.sin(y)*.5;return new m(v,E,R)};let f,p;for(f=0;f<=o;f++){const S=f%o/o*2*u*Math.PI,b=d(S),y=d(S+.01),T=y.subtract(b);let v=y.add(b);const E=m.Cross(T,v);for(v=m.Cross(E,T),E.normalize(),v.normalize(),p=0;p<l;p++){const O=p%l/l*2*Math.PI,w=-n*Math.cos(O),M=n*Math.sin(O);t.push(b.x+w*v.x+M*E.x),t.push(b.y+w*v.y+M*E.y),t.push(b.z+w*v.z+M*E.z),r.push(f/o),r.push(ot?1-p/l:p/l)}}for(f=0;f<o;f++)for(p=0;p<l;p++){const _=(p+1)%l,S=f*l+p,b=(f+1)*l+p,y=(f+1)*l+_,T=f*l+_;e.push(T),e.push(b),e.push(S),e.push(T),e.push(y),e.push(b)}he.ComputeNormals(t,e,i),he._ComputeSides(h,t,e,i,r,a.frontUVs,a.backUVs);const g=new he;return g.indices=e,g.positions=t,g.normals=i,g.uvs=r,g}function m_(a,e={},t){const i=new z(a,t);return e.sideOrientation=z._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,u0(e).applyToMesh(i,e.updatable),i}const SW={CreateTorusKnot:m_};he.CreateTorusKnot=u0;z.CreateTorusKnot=(a,e,t,i,r,s,n,o,l,u)=>m_(a,{radius:e,tube:t,radialSegments:i,tubularSegments:r,p:s,q:n,sideOrientation:u,updatable:l},o);z._LinesMeshParser=(a,e)=>as.Parse(a,e);class as extends z{_isShaderMaterial(e){return e.getClassName()==="ShaderMaterial"}constructor(e,t=null,i=null,r=null,s,n,o,l){super(e,t,i,r,s),this.useVertexColor=n,this.useVertexAlpha=o,this.color=new ne(1,1,1),this.alpha=1,this._shaderLanguage=0,r&&(this.color=r.color.clone(),this.alpha=r.alpha,this.useVertexColor=r.useVertexColor,this.useVertexAlpha=r.useVertexAlpha),this.intersectionThreshold=.1;const u=[],c={attributes:[N.PositionKind],uniforms:["world","viewProjection"],needAlphaBlending:!0,defines:u,useClipPlane:null,shaderLanguage:0};this.useVertexAlpha?c.defines.push("#define VERTEXALPHA"):c.needAlphaBlending=!1,this.useVertexColor?(c.defines.push("#define VERTEXCOLOR"),c.attributes.push(N.ColorKind)):(c.uniforms.push("color"),this._color4=new xe),l?this.material=l:(this.getScene().getEngine().isWebGPU&&!as.ForceGLSL&&(this._shaderLanguage=1),c.shaderLanguage=this._shaderLanguage,c.extraInitializationsAsync=async()=>{this._shaderLanguage===1?await Promise.all([k(()=>Promise.resolve().then(()=>fB),void 0),k(()=>Promise.resolve().then(()=>hB),void 0)]):await Promise.all([k(()=>Promise.resolve().then(()=>XN),void 0),k(()=>Promise.resolve().then(()=>jN),void 0)])},this.material=new Wr("colorShader",this.getScene(),"color",c,!1),this.material.doNotSerialize=!0)}isReady(){return this._lineMaterial.isReady(this,!!this._userInstancedBuffersStorage||this.hasThinInstances)?super.isReady():!1}getClassName(){return"LinesMesh"}get material(){return this._lineMaterial}set material(e){this._lineMaterial=e,this._lineMaterial.fillMode=ft.LineListDrawMode}get checkCollisions(){return!1}set checkCollisions(e){}_bind(e,t){if(!this._geometry)return this;const i=this.isUnIndexed?null:this._geometry.getIndexBuffer();if(!this._userInstancedBuffersStorage||this.hasThinInstances?this._geometry._bind(t,i):this._geometry._bind(t,i,this._userInstancedBuffersStorage.vertexBuffers,this._userInstancedBuffersStorage.vertexArrayObjects),!this.useVertexColor&&this._isShaderMaterial(this._lineMaterial)){const{r,g:s,b:n}=this.color;this._color4.set(r,s,n,this.alpha),this._lineMaterial.setColor4("color",this._color4)}return this}_draw(e,t,i){if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;const r=this.getScene().getEngine();return this._unIndexed?r.drawArraysType(ft.LineListDrawMode,e.verticesStart,e.verticesCount,i):r.drawElementsType(ft.LineListDrawMode,e.indexStart,e.indexCount,i),this}dispose(e,t=!1,i){i||this._lineMaterial.dispose(!1,!1,!0),super.dispose(e)}clone(e,t=null,i){return new as(e,this.getScene(),t,this,i)}createInstance(e){const t=new c0(e,this);if(this.instancedBuffers){t.instancedBuffers={};for(const i in this.instancedBuffers)t.instancedBuffers[i]=this.instancedBuffers[i]}return t}serialize(e){super.serialize(e),e.color=this.color.asArray(),e.alpha=this.alpha}static Parse(e,t){const i=new as(e.name,t);return i.color=ne.FromArray(e.color),i.alpha=e.alpha,i}}as.ForceGLSL=!1;class c0 extends FR{constructor(e,t){super(e,t),this.intersectionThreshold=t.intersectionThreshold}getClassName(){return"InstancedLinesMesh"}}function h0(a){const e=[],t=[],i=a.lines,r=a.colors,s=[];let n=0;for(let l=0;l<i.length;l++){const u=i[l];for(let c=0;c<u.length;c++){const{x:h,y:d,z:f}=u[c];if(t.push(h,d,f),r){const p=r[l],{r:g,g:_,b:S,a:b}=p[c];s.push(g,_,S,b)}c>0&&(e.push(n-1),e.push(n)),n++}}const o=new he;return o.indices=e,o.positions=t,r&&(o.colors=s),o}function d0(a){const e=a.dashSize||3,t=a.gapSize||1,i=a.dashNb||200,r=a.points,s=[],n=[],o=m.Zero();let l=0,u=0,c=0,h=0,d=0,f=0,p=0;for(p=0;p<r.length-1;p++)r[p+1].subtractToRef(r[p],o),l+=o.length();for(c=l/i,h=e*c/(e+t),p=0;p<r.length-1;p++){r[p+1].subtractToRef(r[p],o),u=Math.floor(o.length()/c),o.normalize();for(let _=0;_<u;_++)d=c*_,s.push(r[p].x+d*o.x,r[p].y+d*o.y,r[p].z+d*o.z),s.push(r[p].x+(d+h)*o.x,r[p].y+(d+h)*o.y,r[p].z+(d+h)*o.z),n.push(f,f+1),f+=2}const g=new he;return g.positions=s,g.indices=n,g}function ba(a,e,t=null){const i=e.instance,r=e.lines,s=e.colors;if(i){const u=i.getVerticesData(N.PositionKind);let c,h;s&&(c=i.getVerticesData(N.ColorKind));let d=0,f=0;for(let p=0;p<r.length;p++){const g=r[p];for(let _=0;_<g.length;_++)u[d]=g[_].x,u[d+1]=g[_].y,u[d+2]=g[_].z,s&&c&&(h=s[p],c[f]=h[_].r,c[f+1]=h[_].g,c[f+2]=h[_].b,c[f+3]=h[_].a,f+=4),d+=3}return i.updateVerticesData(N.PositionKind,u,!1,!1),s&&c&&i.updateVerticesData(N.ColorKind,c,!1,!1),i.refreshBoundingInfo(),i}const n=!!s,o=new as(a,t,null,void 0,void 0,n,e.useVertexAlpha,e.material);return h0(e).applyToMesh(o,e.updatable),o}function ai(a,e,t=null){const i=e.colors?[e.colors]:null;return ba(a,{lines:[e.points],updatable:e.updatable,instance:e.instance,colors:i,useVertexAlpha:e.useVertexAlpha,material:e.material},t)}function __(a,e,t=null){const i=e.points,r=e.instance,s=e.gapSize||1,n=e.dashSize||3;if(r){const u=c=>{const h=m.Zero(),d=c.length/6;let f=0,p=0,g=0,_=0,S=0,b=0,y=0,T=0;for(y=0;y<i.length-1;y++)i[y+1].subtractToRef(i[y],h),f+=h.length();g=f/d;const v=r._creationDataStorage.dashSize,E=r._creationDataStorage.gapSize;for(_=v*g/(v+E),y=0;y<i.length-1;y++)for(i[y+1].subtractToRef(i[y],h),p=Math.floor(h.length()/g),h.normalize(),T=0;T<p&&b<c.length;)S=g*T,c[b]=i[y].x+S*h.x,c[b+1]=i[y].y+S*h.y,c[b+2]=i[y].z+S*h.z,c[b+3]=i[y].x+(S+_)*h.x,c[b+4]=i[y].y+(S+_)*h.y,c[b+5]=i[y].z+(S+_)*h.z,b+=6,T++;for(;b<c.length;)c[b]=i[y].x,c[b+1]=i[y].y,c[b+2]=i[y].z,b+=3};return(e.dashNb||e.dashSize||e.gapSize||e.useVertexAlpha||e.material)&&L.Warn("You have used an option other than points with the instance option. Please be aware that these other options will be ignored."),r.updateMeshPositions(u,!1),r}const o=new as(a,t,null,void 0,void 0,void 0,e.useVertexAlpha,e.material);return d0(e).applyToMesh(o,e.updatable),o._creationDataStorage=new ty,o._creationDataStorage.dashSize=n,o._creationDataStorage.gapSize=s,o}const vW={CreateDashedLines:__,CreateLineSystem:ba,CreateLines:ai};he.CreateLineSystem=h0;he.CreateDashedLines=d0;z.CreateLines=(a,e,t=null,i=!1,r=null)=>ai(a,{points:e,updatable:i,instance:r},t);z.CreateDashedLines=(a,e,t,i,r,s=null,n,o)=>__(a,{points:e,dashSize:t,gapSize:i,dashNb:r,updatable:n,instance:o},s);class BD extends Q{constructor(e,t){super(e.x,e.y),this.index=t}}class Dc{constructor(){this.elements=[]}add(e){const t=[];return e.forEach(i=>{const r=new BD(i,this.elements.length);t.push(r),this.elements.push(r)}),t}computeBounds(){const e=new Q(this.elements[0].x,this.elements[0].y),t=new Q(this.elements[0].x,this.elements[0].y);return this.elements.forEach(i=>{i.x<e.x?e.x=i.x:i.x>t.x&&(t.x=i.x),i.y<e.y?e.y=i.y:i.y>t.y&&(t.y=i.y)}),{min:e,max:t,width:t.x-e.x,height:t.y-e.y}}}class bW{static Rectangle(e,t,i,r){return[new Q(e,t),new Q(i,t),new Q(i,r),new Q(e,r)]}static Circle(e,t=0,i=0,r=32){const s=[];let n=0;const o=Math.PI*2/r;for(let l=0;l<r;l++)s.push(new Q(t+Math.cos(n)*e,i+Math.sin(n)*e)),n-=o;return s}static Parse(e){const t=e.split(/[^-+eE.\d]+/).map(parseFloat).filter(s=>!isNaN(s));let i;const r=[];for(i=0;i<(t.length&2147483646);i+=2)r.push(new Q(t[i],t[i+1]));return r}static StartingAt(e,t){return Nm.StartingAt(e,t)}}class VD{_addToepoint(e){for(const t of e)this._epoints.push(t.x,t.y)}constructor(e,t,i,r=earcut){this._points=new Dc,this._outlinepoints=new Dc,this._holes=new Array,this._epoints=new Array,this._eholes=new Array,this.bjsEarcut=r,this._name=e,this._scene=i||ze.LastCreatedScene;let s;t instanceof Nm?s=t.getPoints():s=t,this._addToepoint(s),this._points.add(s),this._outlinepoints.add(s),typeof this.bjsEarcut>"u"&&L.Warn("Earcut was not found, the polygon will not be built.")}addHole(e){this._points.add(e);const t=new Dc;return t.add(e),this._holes.push(t),this._eholes.push(this._epoints.length/2),this._addToepoint(e),this}build(e=!1,t=0,i=2){const r=new z(this._name,this._scene),s=this.buildVertexData(t,i);return r.setVerticesData(N.PositionKind,s.positions,e),r.setVerticesData(N.NormalKind,s.normals,e),r.setVerticesData(N.UVKind,s.uvs,e),r.setIndices(s.indices),r}buildVertexData(e=0,t=2){const i=new he,r=[],s=[],n=[],o=this._points.computeBounds();this._points.elements.forEach(c=>{r.push(0,1,0),s.push(c.x,0,c.y),n.push((c.x-o.min.x)/o.width,(c.y-o.min.y)/o.height)});const l=[],u=this.bjsEarcut(this._epoints,this._eholes,2);for(let c=0;c<u.length;c++)l.push(u[c]);if(e>0){const c=s.length/3;this._points.elements.forEach(d=>{r.push(0,-1,0),s.push(d.x,-e,d.y),n.push(1-(d.x-o.min.x)/o.width,1-(d.y-o.min.y)/o.height)});const h=l.length;for(let d=0;d<h;d+=3){const f=l[d+0],p=l[d+1],g=l[d+2];l.push(g+c),l.push(p+c),l.push(f+c)}this._addSide(s,r,n,l,o,this._outlinepoints,e,!1,t),this._holes.forEach(d=>{this._addSide(s,r,n,l,o,d,e,!0,t)})}return i.indices=l,i.positions=s,i.normals=r,i.uvs=n,i}_addSide(e,t,i,r,s,n,o,l,u){let c=e.length/3,h=0;for(let d=0;d<n.elements.length;d++){const f=n.elements[d],p=n.elements[(d+1)%n.elements.length];e.push(f.x,0,f.y),e.push(f.x,-o,f.y),e.push(p.x,0,p.y),e.push(p.x,-o,p.y);const g=n.elements[(d+n.elements.length-1)%n.elements.length],_=n.elements[(d+2)%n.elements.length];let S=new m(-(p.y-f.y),0,p.x-f.x),b=new m(-(f.y-g.y),0,f.x-g.x),y=new m(-(_.y-p.y),0,_.x-p.x);l||(S=S.scale(-1),b=b.scale(-1),y=y.scale(-1));const T=S.normalizeToNew();let v=b.normalizeToNew(),E=y.normalizeToNew();const R=m.Dot(v,T);R>u?R<He-1?v=new m(f.x,0,f.y).subtract(new m(p.x,0,p.y)).normalize():v=b.add(S).normalize():v=T;const O=m.Dot(y,S);O>u?O<He-1?E=new m(p.x,0,p.y).subtract(new m(f.x,0,f.y)).normalize():E=y.add(S).normalize():E=T,i.push(h/s.width,0),i.push(h/s.width,1),h+=S.length(),i.push(h/s.width,0),i.push(h/s.width,1),t.push(v.x,v.y,v.z),t.push(v.x,v.y,v.z),t.push(E.x,E.y,E.z),t.push(E.x,E.y,E.z),l?(r.push(c),r.push(c+2),r.push(c+1),r.push(c+1),r.push(c+2),r.push(c+3)):(r.push(c),r.push(c+1),r.push(c+2),r.push(c+1),r.push(c+3),r.push(c+2)),c+=4}}}function f0(a,e,t,i,r,s,n){const o=t||new Array(3),l=i,u=[],c=n||!1;for(let w=0;w<3;w++)o[w]===void 0&&(o[w]=new Ve(0,0,1,1)),l&&l[w]===void 0&&(l[w]=new xe(1,1,1,1));const h=a.getVerticesData(N.PositionKind),d=a.getVerticesData(N.NormalKind),f=a.getVerticesData(N.UVKind),p=a.getIndices(),g=h.length/9;let _=0,S=0,b=0,y=0,T=0;const v=[0];if(c)for(let w=g;w<h.length/3;w+=4)S=h[3*(w+2)]-h[3*w],b=h[3*(w+2)+2]-h[3*w+2],y=Math.sqrt(S*S+b*b),T+=y,v.push(T);let E=0,R=0;for(let w=0;w<d.length;w+=3)Math.abs(d[w+1])<.001&&(R=1),Math.abs(d[w+1]-1)<.001&&(R=0),Math.abs(d[w+1]+1)<.001&&(R=2),E=w/3,R===1?(_=E-g,_%4<1.5?c?f[2*E]=o[R].x+(o[R].z-o[R].x)*v[Math.floor(_/4)]/T:f[2*E]=o[R].x:c?f[2*E]=o[R].x+(o[R].z-o[R].x)*v[Math.floor(_/4)+1]/T:f[2*E]=o[R].z,_%2===0?f[2*E+1]=ot?1-o[R].w:o[R].w:f[2*E+1]=ot?1-o[R].y:o[R].y):(f[2*E]=(1-f[2*E])*o[R].x+f[2*E]*o[R].z,f[2*E+1]=(1-f[2*E+1])*o[R].y+f[2*E+1]*o[R].w,ot&&(f[2*E+1]=1-f[2*E+1])),l&&u.push(l[R].r,l[R].g,l[R].b,l[R].a);he._ComputeSides(e,h,p,d,f,r,s);const O=new he;if(O.indices=p,O.positions=h,O.normals=d,O.uvs=f,l){const w=e===he.DOUBLESIDE?u.concat(u):u;O.colors=w}return O}function wu(a,e,t=null,i=earcut){e.sideOrientation=z._GetDefaultSideOrientation(e.sideOrientation);const r=e.shape,s=e.holes||[],n=e.depth||0,o=e.smoothingThreshold||2,l=[];let u=[];for(let p=0;p<r.length;p++)l[p]=new Q(r[p].x,r[p].z);l[0].equalsWithEpsilon(l[l.length-1],1e-8)&&l.pop();const h=new VD(a,l,t||ze.LastCreatedScene,i);for(let p=0;p<s.length;p++){u=[];for(let g=0;g<s[p].length;g++)u.push(new Q(s[p][g].x,s[p][g].z));h.addHole(u)}const d=h.build(!1,n,o);return d._originalBuilderSideOrientation=e.sideOrientation,f0(d,e.sideOrientation,e.faceUV,e.faceColors,e.frontUVs,e.backUVs,e.wrap).applyToMesh(d,e.updatable),d}function Nu(a,e,t=null,i=earcut){return wu(a,e,t,i)}const yW={ExtrudePolygon:Nu,CreatePolygon:wu};he.CreatePolygon=f0;z.CreatePolygon=(a,e,t,i,r,s,n=earcut)=>wu(a,{shape:e,holes:i,updatable:r,sideOrientation:s},t,n);z.ExtrudePolygon=(a,e,t,i,r,s,n,o=earcut)=>Nu(a,{shape:e,holes:r,depth:t,updatable:s,sideOrientation:n},i,o);function Fu(a,e,t=null){const i=e.path,r=e.shape,s=e.scale||1,n=e.rotation||0,o=e.cap===0?0:e.cap||z.NO_CAP,l=e.updatable,u=z._GetDefaultSideOrientation(e.sideOrientation),c=e.instance||null,h=e.invertUV||!1,d=e.closeShape||!1,f=e.closePath||!1,p=e.capFunction||null;return p0(a,r,i,s,n,null,null,f,d,o,!1,t,!!l,u,c,h,e.frontUVs||null,e.backUVs||null,e.firstNormal||null,!!e.adjustFrame,p)}function Lu(a,e,t=null){const i=e.path,r=e.shape,s=e.scaleFunction||(()=>1),n=e.rotationFunction||(()=>0),o=e.closePath||e.ribbonCloseArray||!1,l=e.closeShape||e.ribbonClosePath||!1,u=e.cap===0?0:e.cap||z.NO_CAP,c=e.updatable,h=e.firstNormal||null,d=e.adjustFrame||!1,f=z._GetDefaultSideOrientation(e.sideOrientation),p=e.instance,g=e.invertUV||!1,_=e.capFunction||null;return p0(a,r,i,null,null,s,n,o,l,u,!0,t,!!c,f,p||null,g,e.frontUVs||null,e.backUVs||null,h,d,_||null)}function p0(a,e,t,i,r,s,n,o,l,u,c,h,d,f,p,g,_,S,b,y,T){const v=(M,G,H,q,X,ee,oe,_e,te,ie,Z)=>{const D=H.getTangents(),W=H.getNormals(),K=H.getBinormals(),ue=H.getDistances();if(Z){for(let Pe=0;Pe<D.length;Pe++)if(D[Pe].x==0&&D[Pe].y==0&&D[Pe].z==0&&D[Pe].copyFrom(D[Pe-1]),W[Pe].x==0&&W[Pe].y==0&&W[Pe].z==0&&W[Pe].copyFrom(W[Pe-1]),K[Pe].x==0&&K[Pe].y==0&&K[Pe].z==0&&K[Pe].copyFrom(K[Pe-1]),Pe>0){let si=D[Pe-1];m.Dot(si,D[Pe])<0&&D[Pe].scaleInPlace(-1),si=W[Pe-1],m.Dot(si,W[Pe])<0&&W[Pe].scaleInPlace(-1),si=K[Pe-1],m.Dot(si,K[Pe])<0&&K[Pe].scaleInPlace(-1)}}let ye=0;const se=()=>X!==null?X:1,fe=ie&&_e?_e:()=>ee!==null?ee:0,pe=ie&&oe?oe:se;let Ie=te===z.NO_CAP||te===z.CAP_END?0:2;const vt=V.Matrix[0];for(let Pe=0;Pe<G.length;Pe++){const si=[],Di=fe(Pe,ue[Pe]),hi=pe(Pe,ue[Pe]);$.RotationAxisToRef(D[Pe],ye,vt);for(let _r=0;_r<M.length;_r++){const yn=D[Pe].scale(M[_r].z).add(W[Pe].scale(M[_r].x)).add(K[Pe].scale(M[_r].y)),ks=m.Zero();m.TransformCoordinatesToRef(yn,vt,ks),ks.scaleInPlace(hi).addInPlace(G[Pe]),si[_r]=ks}q[Ie]=si,ye+=Di,Ie++}const Ge=T||(Pe=>{const si=Array(),Di=m.Zero();let hi;for(hi=0;hi<Pe.length;hi++)Di.addInPlace(Pe[hi]);for(Di.scaleInPlace(1/Pe.length),hi=0;hi<Pe.length;hi++)si.push(Di);return si});switch(te){case z.NO_CAP:break;case z.CAP_START:q[0]=Ge(q[2]),q[1]=q[2];break;case z.CAP_END:q[Ie]=q[Ie-1],q[Ie+1]=Ge(q[Ie-1]);break;case z.CAP_ALL:q[0]=Ge(q[2]),q[1]=q[2],q[Ie]=q[Ie-1],q[Ie+1]=Ge(q[Ie-1]);break}return q};let E,R;if(p){const M=p._creationDataStorage;return E=b?M.path3D.update(t,b):M.path3D.update(t),R=v(e,t,M.path3D,M.pathArray,i,r,s,n,M.cap,c,y),p=mn("",{pathArray:R,closeArray:!1,closePath:!1,offset:0,updatable:!1,sideOrientation:0,instance:p},h||void 0),p}E=b?new qc(t,b):new qc(t);const O=new Array;u=u<0||u>3?0:u,R=v(e,t,E,O,i,r,s,n,u,c,y);const w=mn(a,{pathArray:R,closeArray:o,closePath:l,updatable:d,sideOrientation:f,invertUV:g,frontUVs:_||void 0,backUVs:S||void 0},h);return w._creationDataStorage.pathArray=R,w._creationDataStorage.path3D=E,w._creationDataStorage.cap=u,w}const TW={ExtrudeShape:Fu,ExtrudeShapeCustom:Lu};z.ExtrudeShape=(a,e,t,i,r,s,n=null,o,l,u)=>{const c={shape:e,path:t,scale:i,rotation:r,cap:s===0?0:s||z.NO_CAP,sideOrientation:l,instance:u,updatable:o};return Fu(a,c,n)};z.ExtrudeShapeCustom=(a,e,t,i,r,s,n,o,l,u,c,h)=>{const d={shape:e,path:t,scaleFunction:i,rotationFunction:r,ribbonCloseArray:s,ribbonClosePath:n,cap:o===0?0:o||z.NO_CAP,sideOrientation:c,instance:h,updatable:u};return Lu(a,d,l)};function g_(a,e,t=null){const i=e.arc?e.arc<=0||e.arc>1?1:e.arc:1,r=e.closed===void 0?!0:e.closed,s=e.shape,n=e.radius||1,o=e.tessellation||64,l=e.clip||0,u=e.updatable,c=z._GetDefaultSideOrientation(e.sideOrientation),h=e.cap||z.NO_CAP,d=Math.PI*2,f=[],p=e.invertUV||!1;let g=0,_=0;const S=d/o*i;let b,y;for(g=0;g<=o-l;g++){for(y=[],(h==z.CAP_START||h==z.CAP_ALL)&&(y.push(new m(0,s[0].y,0)),y.push(new m(Math.cos(g*S)*s[0].x*n,s[0].y,Math.sin(g*S)*s[0].x*n))),_=0;_<s.length;_++)b=new m(Math.cos(g*S)*s[_].x*n,s[_].y,Math.sin(g*S)*s[_].x*n),y.push(b);(h==z.CAP_END||h==z.CAP_ALL)&&(y.push(new m(Math.cos(g*S)*s[s.length-1].x*n,s[s.length-1].y,Math.sin(g*S)*s[s.length-1].x*n)),y.push(new m(0,s[s.length-1].y,0))),f.push(y)}return mn(a,{pathArray:f,closeArray:r,sideOrientation:c,updatable:u,invertUV:p,frontUVs:e.frontUVs,backUVs:e.backUVs},t)}const CW={CreateLathe:g_};z.CreateLathe=(a,e,t,i,r,s,n)=>g_(a,{shape:e,radius:t,tessellation:i,sideOrientation:n,updatable:s},r);function x_(a,e,t=null){const i=e.path;let r=e.instance,s=1;e.radius!==void 0?s=e.radius:r&&(s=r._creationDataStorage.radius);const n=e.tessellation||64,o=e.radiusFunction||null;let l=e.cap||z.NO_CAP;const u=e.invertUV||!1,c=e.updatable,h=z._GetDefaultSideOrientation(e.sideOrientation);e.arc=e.arc&&(e.arc<=0||e.arc>1)?1:e.arc||1;const d=(S,b,y,T,v,E,R,O)=>{const w=b.getTangents(),M=b.getNormals(),G=b.getDistances(),q=Math.PI*2/v*O,ee=E||(()=>T);let oe,_e,te,ie;const Z=V.Matrix[0];let D=R===z.NO_CAP||R===z.CAP_END?0:2;for(let K=0;K<S.length;K++){_e=ee(K,G[K]),oe=Array(),te=M[K];for(let ue=0;ue<v;ue++)$.RotationAxisToRef(w[K],q*ue,Z),ie=oe[ue]?oe[ue]:m.Zero(),m.TransformCoordinatesToRef(te,Z,ie),ie.scaleInPlace(_e).addInPlace(S[K]),oe[ue]=ie;y[D]=oe,D++}const W=(K,ue)=>{const ye=Array();for(let se=0;se<K;se++)ye.push(S[ue]);return ye};switch(R){case z.NO_CAP:break;case z.CAP_START:y[0]=W(v,0),y[1]=y[2].slice(0);break;case z.CAP_END:y[D]=y[D-1].slice(0),y[D+1]=W(v,S.length-1);break;case z.CAP_ALL:y[0]=W(v,0),y[1]=y[2].slice(0),y[D]=y[D-1].slice(0),y[D+1]=W(v,S.length-1);break}return y};let f,p;if(r){const S=r._creationDataStorage,b=e.arc||S.arc;return f=S.path3D.update(i),p=d(i,f,S.pathArray,s,S.tessellation,o,S.cap,b),r=mn("",{pathArray:p,instance:r}),S.path3D=f,S.pathArray=p,S.arc=b,S.radius=s,r}f=new qc(i);const g=new Array;l=l<0||l>3?0:l,p=d(i,f,g,s,n,o,l,e.arc);const _=mn(a,{pathArray:p,closePath:!0,closeArray:!1,updatable:c,sideOrientation:h,invertUV:u,frontUVs:e.frontUVs,backUVs:e.backUVs},t);return _._creationDataStorage.pathArray=p,_._creationDataStorage.path3D=f,_._creationDataStorage.tessellation=n,_._creationDataStorage.cap=l,_._creationDataStorage.arc=e.arc,_._creationDataStorage.radius=s,_}const PW={CreateTube:x_};z.CreateTube=(a,e,t,i,r,s,n,o,l,u)=>x_(a,{path:e,radius:t,tessellation:i,radiusFunction:r,arc:1,cap:s,updatable:o,sideOrientation:l,instance:u},n);function m0(a){const e=[];e[0]={vertex:[[0,0,1.732051],[1.632993,0,-.5773503],[-.8164966,1.414214,-.5773503],[-.8164966,-1.414214,-.5773503]],face:[[0,1,2],[0,2,3],[0,3,1],[1,3,2]]},e[1]={vertex:[[0,0,1.414214],[1.414214,0,0],[0,1.414214,0],[-1.414214,0,0],[0,-1.414214,0],[0,0,-1.414214]],face:[[0,1,2],[0,2,3],[0,3,4],[0,4,1],[1,4,5],[1,5,2],[2,5,3],[3,5,4]]},e[2]={vertex:[[0,0,1.070466],[.7136442,0,.7978784],[-.3568221,.618034,.7978784],[-.3568221,-.618034,.7978784],[.7978784,.618034,.3568221],[.7978784,-.618034,.3568221],[-.9341724,.381966,.3568221],[.1362939,1,.3568221],[.1362939,-1,.3568221],[-.9341724,-.381966,.3568221],[.9341724,.381966,-.3568221],[.9341724,-.381966,-.3568221],[-.7978784,.618034,-.3568221],[-.1362939,1,-.3568221],[-.1362939,-1,-.3568221],[-.7978784,-.618034,-.3568221],[.3568221,.618034,-.7978784],[.3568221,-.618034,-.7978784],[-.7136442,0,-.7978784],[0,0,-1.070466]],face:[[0,1,4,7,2],[0,2,6,9,3],[0,3,8,5,1],[1,5,11,10,4],[2,7,13,12,6],[3,9,15,14,8],[4,10,16,13,7],[5,8,14,17,11],[6,12,18,15,9],[10,11,17,19,16],[12,13,16,19,18],[14,15,18,19,17]]},e[3]={vertex:[[0,0,1.175571],[1.051462,0,.5257311],[.3249197,1,.5257311],[-.8506508,.618034,.5257311],[-.8506508,-.618034,.5257311],[.3249197,-1,.5257311],[.8506508,.618034,-.5257311],[.8506508,-.618034,-.5257311],[-.3249197,1,-.5257311],[-1.051462,0,-.5257311],[-.3249197,-1,-.5257311],[0,0,-1.175571]],face:[[0,1,2],[0,2,3],[0,3,4],[0,4,5],[0,5,1],[1,5,7],[1,7,6],[1,6,2],[2,6,8],[2,8,3],[3,8,9],[3,9,4],[4,9,10],[4,10,5],[5,10,7],[6,7,11],[6,11,8],[7,10,11],[8,11,9],[9,11,10]]},e[4]={vertex:[[0,0,1.070722],[.7148135,0,.7971752],[-.104682,.7071068,.7971752],[-.6841528,.2071068,.7971752],[-.104682,-.7071068,.7971752],[.6101315,.7071068,.5236279],[1.04156,.2071068,.1367736],[.6101315,-.7071068,.5236279],[-.3574067,1,.1367736],[-.7888348,-.5,.5236279],[-.9368776,.5,.1367736],[-.3574067,-1,.1367736],[.3574067,1,-.1367736],[.9368776,-.5,-.1367736],[.7888348,.5,-.5236279],[.3574067,-1,-.1367736],[-.6101315,.7071068,-.5236279],[-1.04156,-.2071068,-.1367736],[-.6101315,-.7071068,-.5236279],[.104682,.7071068,-.7971752],[.6841528,-.2071068,-.7971752],[.104682,-.7071068,-.7971752],[-.7148135,0,-.7971752],[0,0,-1.070722]],face:[[0,2,3],[1,6,5],[4,9,11],[7,15,13],[8,16,10],[12,14,19],[17,22,18],[20,21,23],[0,1,5,2],[0,3,9,4],[0,4,7,1],[1,7,13,6],[2,5,12,8],[2,8,10,3],[3,10,17,9],[4,11,15,7],[5,6,14,12],[6,13,20,14],[8,12,19,16],[9,17,18,11],[10,16,22,17],[11,18,21,15],[13,15,21,20],[14,20,23,19],[16,19,23,22],[18,22,23,21]]},e[5]={vertex:[[0,0,1.322876],[1.309307,0,.1889822],[-.9819805,.8660254,.1889822],[.1636634,-1.299038,.1889822],[.3273268,.8660254,-.9449112],[-.8183171,-.4330127,-.9449112]],face:[[0,3,1],[2,4,5],[0,1,4,2],[0,2,5,3],[1,3,5,4]]},e[6]={vertex:[[0,0,1.159953],[1.013464,0,.5642542],[-.3501431,.9510565,.5642542],[-.7715208,-.6571639,.5642542],[.6633206,.9510565,-.03144481],[.8682979,-.6571639,-.3996071],[-1.121664,.2938926,-.03144481],[-.2348831,-1.063314,-.3996071],[.5181548,.2938926,-.9953061],[-.5850262,-.112257,-.9953061]],face:[[0,1,4,2],[0,2,6,3],[1,5,8,4],[3,6,9,7],[5,7,9,8],[0,3,7,5,1],[2,4,8,9,6]]},e[7]={vertex:[[0,0,1.118034],[.8944272,0,.6708204],[-.2236068,.8660254,.6708204],[-.7826238,-.4330127,.6708204],[.6708204,.8660254,.2236068],[1.006231,-.4330127,-.2236068],[-1.006231,.4330127,.2236068],[-.6708204,-.8660254,-.2236068],[.7826238,.4330127,-.6708204],[.2236068,-.8660254,-.6708204],[-.8944272,0,-.6708204],[0,0,-1.118034]],face:[[0,1,4,2],[0,2,6,3],[1,5,8,4],[3,6,10,7],[5,9,11,8],[7,10,11,9],[0,3,7,9,5,1],[2,4,8,11,10,6]]},e[8]={vertex:[[-.729665,.670121,.319155],[-.655235,-.29213,-.754096],[-.093922,-.607123,.537818],[.702196,.595691,.485187],[.776626,-.36656,-.588064]],face:[[1,4,2],[0,1,2],[3,0,2],[4,3,2],[4,1,0,3]]},e[9]={vertex:[[-.868849,-.100041,.61257],[-.329458,.976099,.28078],[-.26629,-.013796,-.477654],[-.13392,-1.034115,.229829],[.738834,.707117,-.307018],[.859683,-.535264,-.338508]],face:[[3,0,2],[5,3,2],[4,5,2],[1,4,2],[0,1,2],[0,3,5,4,1]]},e[10]={vertex:[[-.610389,.243975,.531213],[-.187812,-.48795,-.664016],[-.187812,.9759,-.664016],[.187812,-.9759,.664016],[.798201,.243975,.132803]],face:[[1,3,0],[3,4,0],[3,1,4],[0,2,1],[0,4,2],[2,4,1]]},e[11]={vertex:[[-1.028778,.392027,-.048786],[-.640503,-.646161,.621837],[-.125162,-.395663,-.540059],[.004683,.888447,-.651988],[.125161,.395663,.540059],[.632925,-.791376,.433102],[1.031672,.157063,-.354165]],face:[[3,2,0],[2,1,0],[2,5,1],[0,4,3],[0,1,4],[4,1,5],[2,3,6],[3,4,6],[5,2,6],[4,5,6]]},e[12]={vertex:[[-.669867,.334933,-.529576],[-.669867,.334933,.529577],[-.4043,1.212901,0],[-.334933,-.669867,-.529576],[-.334933,-.669867,.529577],[.334933,.669867,-.529576],[.334933,.669867,.529577],[.4043,-1.212901,0],[.669867,-.334933,-.529576],[.669867,-.334933,.529577]],face:[[8,9,7],[6,5,2],[3,8,7],[5,0,2],[4,3,7],[0,1,2],[9,4,7],[1,6,2],[9,8,5,6],[8,3,0,5],[3,4,1,0],[4,9,6,1]]},e[13]={vertex:[[-.931836,.219976,-.264632],[-.636706,.318353,.692816],[-.613483,-.735083,-.264632],[-.326545,.979634,0],[-.318353,-.636706,.692816],[-.159176,.477529,-.856368],[.159176,-.477529,-.856368],[.318353,.636706,.692816],[.326545,-.979634,0],[.613482,.735082,-.264632],[.636706,-.318353,.692816],[.931835,-.219977,-.264632]],face:[[11,10,8],[7,9,3],[6,11,8],[9,5,3],[2,6,8],[5,0,3],[4,2,8],[0,1,3],[10,4,8],[1,7,3],[10,11,9,7],[11,6,5,9],[6,2,0,5],[2,4,1,0],[4,10,7,1]]},e[14]={vertex:[[-.93465,.300459,-.271185],[-.838689,-.260219,-.516017],[-.711319,.717591,.128359],[-.710334,-.156922,.080946],[-.599799,.556003,-.725148],[-.503838,-.004675,-.969981],[-.487004,.26021,.48049],[-.460089,-.750282,-.512622],[-.376468,.973135,-.325605],[-.331735,-.646985,.084342],[-.254001,.831847,.530001],[-.125239,-.494738,-.966586],[.029622,.027949,.730817],[.056536,-.982543,-.262295],[.08085,1.087391,.076037],[.125583,-.532729,.485984],[.262625,.599586,.780328],[.391387,-.726999,-.716259],[.513854,-.868287,.139347],[.597475,.85513,.326364],[.641224,.109523,.783723],[.737185,-.451155,.538891],[.848705,-.612742,-.314616],[.976075,.365067,.32976],[1.072036,-.19561,.084927]],face:[[15,18,21],[12,20,16],[6,10,2],[3,0,1],[9,7,13],[2,8,4,0],[0,4,5,1],[1,5,11,7],[7,11,17,13],[13,17,22,18],[18,22,24,21],[21,24,23,20],[20,23,19,16],[16,19,14,10],[10,14,8,2],[15,9,13,18],[12,15,21,20],[6,12,16,10],[3,6,2,0],[9,3,1,7],[9,15,12,6,3],[22,17,11,5,4,8,14,19,23,24]]};const t=a.type&&(a.type<0||a.type>=e.length)?0:a.type||0,i=a.size,r=a.sizeX||i||1,s=a.sizeY||i||1,n=a.sizeZ||i||1,o=a.custom||e[t],l=o.face.length,u=a.faceUV||new Array(l),c=a.faceColors,h=a.flat===void 0?!0:a.flat,d=a.sideOrientation===0?0:a.sideOrientation||he.DEFAULTSIDE,f=[],p=[],g=[],_=[],S=[];let b=0,y=0;const T=[];let v=0,E=0,R,O,w,M,G,H;if(h)for(E=0;E<l;E++)c&&c[E]===void 0&&(c[E]=new xe(1,1,1,1)),u&&u[E]===void 0&&(u[E]=new Ve(0,0,1,1));if(h)for(E=0;E<l;E++){const X=o.face[E].length;for(w=2*Math.PI/X,M=.5*Math.tan(w/2),G=.5,v=0;v<X;v++)f.push(o.vertex[o.face[E][v]][0]*r,o.vertex[o.face[E][v]][1]*s,o.vertex[o.face[E][v]][2]*n),T.push(b),b++,R=u[E].x+(u[E].z-u[E].x)*(.5+M),O=u[E].y+(u[E].w-u[E].y)*(G-.5),_.push(R,ot?1-O:O),H=M*Math.cos(w)-G*Math.sin(w),G=M*Math.sin(w)+G*Math.cos(w),M=H,c&&S.push(c[E].r,c[E].g,c[E].b,c[E].a);for(v=0;v<X-2;v++)p.push(T[0+y],T[v+2+y],T[v+1+y]);y+=X}else{for(v=0;v<o.vertex.length;v++)f.push(o.vertex[v][0]*r,o.vertex[v][1]*s,o.vertex[v][2]*n),_.push(0,ot?1:0);for(E=0;E<l;E++)for(v=0;v<o.face[E].length-2;v++)p.push(o.face[E][0],o.face[E][v+2],o.face[E][v+1])}he.ComputeNormals(f,p,g),he._ComputeSides(d,f,p,g,_,a.frontUVs,a.backUVs);const q=new he;return q.positions=f,q.indices=p,q.normals=g,q.uvs=_,c&&h&&(q.colors=S),q}function Bu(a,e={},t=null){const i=new z(a,t);return e.sideOrientation=z._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,m0(e).applyToMesh(i,e.updatable),i}const EW={CreatePolyhedron:Bu};he.CreatePolyhedron=m0;z.CreatePolyhedron=(a,e,t)=>Bu(a,e,t);function S_(a){const e=a.sideOrientation||he.DEFAULTSIDE,t=a.radius||1,i=a.flat===void 0?!0:a.flat,r=(a.subdivisions||4)|0,s=a.radiusX||t,n=a.radiusY||t,o=a.radiusZ||t,l=(1+Math.sqrt(5))/2,u=[-1,l,-0,1,l,0,-1,-l,0,1,-l,0,0,-1,-l,0,1,-l,0,-1,l,0,1,l,l,0,1,l,0,-1,-l,0,1,-l,0,-1],c=[0,11,5,0,5,1,0,1,7,0,7,10,12,22,23,1,5,20,5,11,4,23,22,13,22,18,6,7,1,8,14,21,4,14,4,2,16,13,6,15,6,19,3,8,9,4,21,5,13,17,23,6,13,22,19,6,18,9,8,1],h=[0,1,2,3,4,5,6,7,8,9,10,11,0,2,3,3,3,4,7,8,9,9,10,11],d=[5,1,3,1,6,4,0,0,5,3,4,2,2,2,4,0,2,0,1,1,6,0,6,2,0,4,3,3,4,4,3,1,4,2,4,4,0,2,1,1,2,2,3,3,1,3,2,4],f=138/1024,p=239/1024,g=60/1024,_=26/1024,S=-40/1024,b=20/1024,y=[0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0],T=[],v=[],E=[],R=[];let O=0;const w=new Array(3),M=new Array(3);let G;for(G=0;G<3;G++)w[G]=m.Zero(),M[G]=Q.Zero();for(let q=0;q<20;q++){for(G=0;G<3;G++){const ee=c[3*q+G];w[G].copyFromFloats(u[3*h[ee]],u[3*h[ee]+1],u[3*h[ee]+2]),w[G].normalize(),M[G].copyFromFloats(d[2*ee]*f+g+y[q]*S,d[2*ee+1]*p+_+y[q]*b)}const X=(ee,oe,_e,te)=>{const ie=m.Lerp(w[0],w[2],oe/r),Z=m.Lerp(w[1],w[2],oe/r),D=r===oe?w[2]:m.Lerp(ie,Z,ee/(r-oe));D.normalize();let W;if(i){const se=m.Lerp(w[0],w[2],te/r),ce=m.Lerp(w[1],w[2],te/r);W=m.Lerp(se,ce,_e/(r-te))}else W=new m(D.x,D.y,D.z);W.x/=s,W.y/=n,W.z/=o,W.normalize();const K=Q.Lerp(M[0],M[2],oe/r),ue=Q.Lerp(M[1],M[2],oe/r),ye=r===oe?M[2]:Q.Lerp(K,ue,ee/(r-oe));v.push(D.x*s,D.y*n,D.z*o),E.push(W.x,W.y,W.z),R.push(ye.x,ot?1-ye.y:ye.y),T.push(O),O++};for(let ee=0;ee<r;ee++)for(let oe=0;oe+ee<r;oe++)X(oe,ee,oe+1/3,ee+1/3),X(oe+1,ee,oe+1/3,ee+1/3),X(oe,ee+1,oe+1/3,ee+1/3),oe+ee+1<r&&(X(oe+1,ee,oe+2/3,ee+2/3),X(oe+1,ee+1,oe+2/3,ee+2/3),X(oe,ee+1,oe+2/3,ee+2/3))}he._ComputeSides(e,v,T,E,R,a.frontUVs,a.backUVs);const H=new he;return H.indices=T,H.positions=v,H.normals=E,H.uvs=R,H}function $o(a,e={},t=null){const i=new z(a,t);return e.sideOrientation=z._GetDefaultSideOrientation(e.sideOrientation),i._originalBuilderSideOrientation=e.sideOrientation,S_(e).applyToMesh(i,e.updatable),i}const IW={CreateIcoSphere:$o};he.CreateIcoSphere=S_;z.CreateIcoSphere=(a,e,t)=>$o(a,e,t);const kD=new m(1,0,0),zD=new m(-1,0,0),UD=new m(0,1,0),GD=new m(0,-1,0),WD=new m(0,0,1),$D=new m(0,0,-1);class Hl{constructor(e=m.Zero(),t=m.Up(),i=Q.Zero(),r=0,s=0,n=null,o=null,l=null,u=null){this.position=e,this.normal=t,this.uv=i,this.vertexIdx=r,this.vertexIdxForBones=s,this.localPositionOverride=n,this.localNormalOverride=o,this.matrixIndicesOverride=l,this.matrixWeightsOverride=u}clone(){var e,t,i,r;return new Hl(this.position.clone(),this.normal.clone(),this.uv.clone(),this.vertexIdx,this.vertexIdxForBones,(e=this.localPositionOverride)==null?void 0:e.slice(),(t=this.localNormalOverride)==null?void 0:t.slice(),(i=this.matrixIndicesOverride)==null?void 0:i.slice(),(r=this.matrixWeightsOverride)==null?void 0:r.slice())}}function v_(a,e,t){var oe,_e,te,ie;const i=!!e.skeleton,r=t.localMode||i,s=e.getIndices(),n=i?e.getPositionData(!0,!0):e.getVerticesData(N.PositionKind),o=i?e.getNormalsData(!0,!0):e.getVerticesData(N.NormalKind),l=r?i?e.getVerticesData(N.PositionKind):n:null,u=r?i?e.getVerticesData(N.NormalKind):o:null,c=e.getVerticesData(N.UVKind),h=i?e.getVerticesData(N.MatricesIndicesKind):null,d=i?e.getVerticesData(N.MatricesWeightsKind):null,f=i?e.getVerticesData(N.MatricesIndicesExtraKind):null,p=i?e.getVerticesData(N.MatricesWeightsExtraKind):null,g=t.position||m.Zero();let _=t.normal||m.Up();const S=t.size||m.One(),b=t.angle||0;if(!_){const Z=new m(0,0,1),D=e.getScene().activeCamera,W=m.TransformCoordinates(Z,D.getWorldMatrix());_=D.globalPosition.subtract(W)}const y=-Math.atan2(_.z,_.x)-Math.PI/2,T=Math.sqrt(_.x*_.x+_.z*_.z),v=Math.atan2(_.y,T),E=new he;E.indices=[],E.positions=[],E.normals=[],E.uvs=[],E.matricesIndices=i?[]:null,E.matricesWeights=i?[]:null,E.matricesIndicesExtra=f?[]:null,E.matricesWeightsExtra=p?[]:null;let R=0;const O=(Z,D)=>{const W=new Hl;if(!s||!n||!o)return W;const K=s[Z];if(W.vertexIdx=K*3,W.vertexIdxForBones=K*4,W.position=new m(n[K*3],n[K*3+1],n[K*3+2]),m.TransformCoordinatesToRef(W.position,D,W.position),W.normal=new m(o[K*3],o[K*3+1],o[K*3+2]),m.TransformNormalToRef(W.normal,D,W.normal),t.captureUVS&&c){const ue=c[K*2+1];W.uv=new Q(c[K*2],ot?1-ue:ue)}return W},w=[0,0,0,0],M=(Z,D)=>{if(Z.length===0)return Z;const W=.5*Math.abs(m.Dot(S,D)),K=(se,ce,fe,pe)=>{for(let Ie=0;Ie<pe;++Ie)if(se[fe+Ie]===ce)return fe+Ie;return-1},ue=(se,ce)=>{const fe=m.GetClipFactor(se.position,ce.position,D,W);let pe=w,Ie=w;if(h&&d){const fo=se.matrixIndicesOverride?0:se.vertexIdxForBones,bc=se.matrixIndicesOverride??h,ag=se.matrixWeightsOverride??d,yc=ce.matrixIndicesOverride?0:ce.vertexIdxForBones,og=ce.matrixIndicesOverride??h,lg=ce.matrixWeightsOverride??d;pe=[0,0,0,0],Ie=[0,0,0,0];let Tn=0;for(let Ir=0;Ir<4;++Ir)if(ag[fo+Ir]>0){const po=K(og,bc[fo+Ir],yc,4);pe[Tn]=bc[fo+Ir],Ie[Tn]=mi(ag[fo+Ir],po>=0?lg[po]:0,fe),Tn++}for(let Ir=0;Ir<4&&Tn<4;++Ir){const po=og[yc+Ir];K(bc,po,fo,4)===-1&&(pe[Tn]=po,Ie[Tn]=mi(0,lg[yc+Ir],fe),Tn++)}const yl=Ie[0]+Ie[1]+Ie[2]+Ie[3];Ie[0]/=yl,Ie[1]/=yl,Ie[2]/=yl,Ie[3]/=yl}const vt=se.localPositionOverride?se.localPositionOverride[0]:(l==null?void 0:l[se.vertexIdx])??0,Se=se.localPositionOverride?se.localPositionOverride[1]:(l==null?void 0:l[se.vertexIdx+1])??0,Ge=se.localPositionOverride?se.localPositionOverride[2]:(l==null?void 0:l[se.vertexIdx+2])??0,Pe=ce.localPositionOverride?ce.localPositionOverride[0]:(l==null?void 0:l[ce.vertexIdx])??0,si=ce.localPositionOverride?ce.localPositionOverride[1]:(l==null?void 0:l[ce.vertexIdx+1])??0,Di=ce.localPositionOverride?ce.localPositionOverride[2]:(l==null?void 0:l[ce.vertexIdx+2])??0,hi=se.localNormalOverride?se.localNormalOverride[0]:(u==null?void 0:u[se.vertexIdx])??0,_r=se.localNormalOverride?se.localNormalOverride[1]:(u==null?void 0:u[se.vertexIdx+1])??0,yn=se.localNormalOverride?se.localNormalOverride[2]:(u==null?void 0:u[se.vertexIdx+2])??0,ks=ce.localNormalOverride?ce.localNormalOverride[0]:(u==null?void 0:u[ce.vertexIdx])??0,vl=ce.localNormalOverride?ce.localNormalOverride[1]:(u==null?void 0:u[ce.vertexIdx+1])??0,bl=ce.localNormalOverride?ce.localNormalOverride[2]:(u==null?void 0:u[ce.vertexIdx+2])??0,gc=hi+(ks-hi)*fe,xc=_r+(vl-_r)*fe,Sc=yn+(bl-yn)*fe,vc=Math.sqrt(gc*gc+xc*xc+Sc*Sc);return new Hl(m.Lerp(se.position,ce.position,fe),m.Lerp(se.normal,ce.normal,fe).normalize(),Q.Lerp(se.uv,ce.uv,fe),-1,-1,l?[vt+(Pe-vt)*fe,Se+(si-Se)*fe,Ge+(Di-Ge)*fe]:null,u?[gc/vc,xc/vc,Sc/vc]:null,pe,Ie)};let ye=null;Z.length>3&&(ye=[]);for(let se=0;se<Z.length;se+=3){let ce=0,fe=null,pe=null,Ie=null,vt=null;const Se=m.Dot(Z[se].position,D)-W,Ge=m.Dot(Z[se+1].position,D)-W,Pe=m.Dot(Z[se+2].position,D)-W,si=Se>0,Di=Ge>0,hi=Pe>0;switch(ce=(si?1:0)+(Di?1:0)+(hi?1:0),ce){case 0:Z.length>3?(ye.push(Z[se]),ye.push(Z[se+1]),ye.push(Z[se+2])):ye=Z;break;case 1:if(ye=ye??new Array,si&&(fe=Z[se+1],pe=Z[se+2],Ie=ue(Z[se],fe),vt=ue(Z[se],pe)),Di){fe=Z[se],pe=Z[se+2],Ie=ue(Z[se+1],fe),vt=ue(Z[se+1],pe),ye.push(Ie),ye.push(pe.clone()),ye.push(fe.clone()),ye.push(pe.clone()),ye.push(Ie.clone()),ye.push(vt);break}hi&&(fe=Z[se],pe=Z[se+1],Ie=ue(Z[se+2],fe),vt=ue(Z[se+2],pe)),fe&&pe&&Ie&&vt&&(ye.push(fe.clone()),ye.push(pe.clone()),ye.push(Ie),ye.push(vt),ye.push(Ie.clone()),ye.push(pe.clone()));break;case 2:ye=ye??new Array,si||(fe=Z[se].clone(),pe=ue(fe,Z[se+1]),Ie=ue(fe,Z[se+2]),ye.push(fe),ye.push(pe),ye.push(Ie)),Di||(fe=Z[se+1].clone(),pe=ue(fe,Z[se+2]),Ie=ue(fe,Z[se]),ye.push(fe),ye.push(pe),ye.push(Ie)),hi||(fe=Z[se+2].clone(),pe=ue(fe,Z[se]),Ie=ue(fe,Z[se+1]),ye.push(fe),ye.push(pe),ye.push(Ie));break}}return ye},G=e instanceof z?e:null,H=G==null?void 0:G._thinInstanceDataStorage.matrixData,q=(G==null?void 0:G.thinInstanceCount)||1,X=V.Matrix[0];X.copyFrom($.IdentityReadOnly);for(let Z=0;Z<q;++Z){if(G!=null&&G.hasThinInstances&&H){const se=Z*16;X.setRowFromFloats(0,H[se+0],H[se+1],H[se+2],H[se+3]),X.setRowFromFloats(1,H[se+4],H[se+5],H[se+6],H[se+7]),X.setRowFromFloats(2,H[se+8],H[se+9],H[se+10],H[se+11]),X.setRowFromFloats(3,H[se+12],H[se+13],H[se+14],H[se+15])}const D=$.RotationYawPitchRoll(y,v,b).multiply($.Translation(g.x,g.y,g.z)),W=$.Invert(D),K=e.getWorldMatrix(),ue=X.multiply(K).multiply(W),ye=new Array(3);for(let se=0;se<s.length;se+=3){let ce=ye;if(ce[0]=O(se,ue),ce[1]=O(se+1,ue),ce[2]=O(se+2,ue),!(t.cullBackFaces&&-ce[0].normal.z<=0&&-ce[1].normal.z<=0&&-ce[2].normal.z<=0)&&(ce=M(ce,kD),!!ce&&(ce=M(ce,zD),!!ce&&(ce=M(ce,UD),!!ce&&(ce=M(ce,GD),!!ce&&(ce=M(ce,WD),!!ce&&(ce=M(ce,$D),!!ce)))))))for(let fe=0;fe<ce.length;fe++){const pe=ce[fe];if(E.indices.push(R),r?(pe.localPositionOverride?(E.positions[R*3]=pe.localPositionOverride[0],E.positions[R*3+1]=pe.localPositionOverride[1],E.positions[R*3+2]=pe.localPositionOverride[2]):l&&(E.positions[R*3]=l[pe.vertexIdx],E.positions[R*3+1]=l[pe.vertexIdx+1],E.positions[R*3+2]=l[pe.vertexIdx+2]),pe.localNormalOverride?(E.normals[R*3]=pe.localNormalOverride[0],E.normals[R*3+1]=pe.localNormalOverride[1],E.normals[R*3+2]=pe.localNormalOverride[2]):u&&(E.normals[R*3]=u[pe.vertexIdx],E.normals[R*3+1]=u[pe.vertexIdx+1],E.normals[R*3+2]=u[pe.vertexIdx+2])):(pe.position.toArray(E.positions,R*3),pe.normal.toArray(E.normals,R*3)),E.matricesIndices&&E.matricesWeights&&(pe.matrixIndicesOverride?(E.matricesIndices[R*4]=pe.matrixIndicesOverride[0],E.matricesIndices[R*4+1]=pe.matrixIndicesOverride[1],E.matricesIndices[R*4+2]=pe.matrixIndicesOverride[2],E.matricesIndices[R*4+3]=pe.matrixIndicesOverride[3]):(h&&(E.matricesIndices[R*4]=h[pe.vertexIdxForBones],E.matricesIndices[R*4+1]=h[pe.vertexIdxForBones+1],E.matricesIndices[R*4+2]=h[pe.vertexIdxForBones+2],E.matricesIndices[R*4+3]=h[pe.vertexIdxForBones+3]),f&&E.matricesIndicesExtra&&(E.matricesIndicesExtra[R*4]=f[pe.vertexIdxForBones],E.matricesIndicesExtra[R*4+1]=f[pe.vertexIdxForBones+1],E.matricesIndicesExtra[R*4+2]=f[pe.vertexIdxForBones+2],E.matricesIndicesExtra[R*4+3]=f[pe.vertexIdxForBones+3])),pe.matrixWeightsOverride?(E.matricesWeights[R*4]=pe.matrixWeightsOverride[0],E.matricesWeights[R*4+1]=pe.matrixWeightsOverride[1],E.matricesWeights[R*4+2]=pe.matrixWeightsOverride[2],E.matricesWeights[R*4+3]=pe.matrixWeightsOverride[3]):(d&&(E.matricesWeights[R*4]=d[pe.vertexIdxForBones],E.matricesWeights[R*4+1]=d[pe.vertexIdxForBones+1],E.matricesWeights[R*4+2]=d[pe.vertexIdxForBones+2],E.matricesWeights[R*4+3]=d[pe.vertexIdxForBones+3]),p&&E.matricesWeightsExtra&&(E.matricesWeightsExtra[R*4]=p[pe.vertexIdxForBones],E.matricesWeightsExtra[R*4+1]=p[pe.vertexIdxForBones+1],E.matricesWeightsExtra[R*4+2]=p[pe.vertexIdxForBones+2],E.matricesWeightsExtra[R*4+3]=p[pe.vertexIdxForBones+3]))),t.captureUVS)pe.uv.toArray(E.uvs,R*2);else{E.uvs.push(.5+pe.position.x/S.x);const Ie=.5+pe.position.y/S.y;E.uvs.push(ot?1-Ie:Ie)}R++}}}E.indices.length===0&&(E.indices=null),E.positions.length===0&&(E.positions=null),E.normals.length===0&&(E.normals=null),E.uvs.length===0&&(E.uvs=null),((oe=E.matricesIndices)==null?void 0:oe.length)===0&&(E.matricesIndices=null),((_e=E.matricesWeights)==null?void 0:_e.length)===0&&(E.matricesWeights=null),((te=E.matricesIndicesExtra)==null?void 0:te.length)===0&&(E.matricesIndicesExtra=null),((ie=E.matricesWeightsExtra)==null?void 0:ie.length)===0&&(E.matricesWeightsExtra=null);const ee=new z(a,e.getScene());return E.applyToMesh(ee),r?(ee.skeleton=e.skeleton,ee.parent=e):(ee.position=g.clone(),ee.rotation=new m(v,y,b)),ee.computeWorldMatrix(!0),ee.refreshBoundingInfo(!0,!0),ee}const RW={CreateDecal:v_};z.CreateDecal=(a,e,t,i,r,s)=>v_(a,e,{position:t,normal:i,size:r,angle:s});class Pt{constructor(e=0,t=0){this.x=e,this.y=t,e!==Math.floor(e)&&(e=Math.floor(e),L.Warn("x is not an integer, floor(x) used")),t!==Math.floor(t)&&(t=Math.floor(t),L.Warn("y is not an integer, floor(y) used"))}clone(){return new Pt(this.x,this.y)}rotate60About(e){const t=this.x;return this.x=e.x+e.y-this.y,this.y=t+this.y-e.x,this}rotateNeg60About(e){const t=this.x;return this.x=t+this.y-e.y,this.y=e.x+e.y-t,this}rotate120(e,t){e!==Math.floor(e)&&(e=Math.floor(e),L.Warn("m not an integer only floor(m) used")),t!==Math.floor(t)&&(t=Math.floor(t),L.Warn("n not an integer only floor(n) used"));const i=this.x;return this.x=e-i-this.y,this.y=t+i,this}rotateNeg120(e,t){e!==Math.floor(e)&&(e=Math.floor(e),L.Warn("m is not an integer, floor(m) used")),t!==Math.floor(t)&&(t=Math.floor(t),L.Warn("n is not an integer,   floor(n) used"));const i=this.x;return this.x=this.y-t,this.y=e+t-i-this.y,this}toCartesianOrigin(e,t){const i=m.Zero();return i.x=e.x+2*this.x*t+this.y*t,i.y=e.y+Math.sqrt(3)*this.y*t,i}static Zero(){return new Pt(0,0)}}class _0{constructor(){this.cartesian=[],this.vertices=[],this.max=[],this.min=[],this.closestTo=[],this.innerFacets=[],this.isoVecsABOB=[],this.isoVecsOBOA=[],this.isoVecsBAOA=[],this.vertexTypes=[],this.IDATA=new nh("icosahedron","Regular",[[0,wt,-1],[-wt,1,0],[-1,0,-wt],[1,0,-wt],[wt,1,0],[0,wt,1],[-1,0,wt],[-wt,-1,0],[0,-wt,-1],[wt,-1,0],[1,0,wt],[0,-wt,1]],[[0,2,1],[0,3,2],[0,4,3],[0,5,4],[0,1,5],[7,6,1],[8,7,2],[9,8,3],[10,9,4],[6,10,5],[2,7,1],[3,8,2],[4,9,3],[5,10,4],[1,6,5],[11,6,7],[11,7,8],[11,8,9],[11,9,10],[11,10,6]])}setIndices(){let e=12;const t={},i=this.m,r=this.n;let s=i,n=1,o=0;r!==0&&(s=ug(i,r)),n=i/s,o=r/s;let l,u,c,h,d;const f=Pt.Zero(),p=new Pt(i,r),g=new Pt(-r,i+r),_=Pt.Zero(),S=Pt.Zero(),b=Pt.Zero();let y=[],T,v,E,R;const O=[],w=this.vertByDist,M=(G,H,q,X)=>{T=G+"|"+q,v=H+"|"+X,T in t||v in t?T in t&&!(v in t)?t[v]=t[T]:v in t&&!(T in t)&&(t[T]=t[v]):(t[T]=e,t[v]=e,e++),w[q][0]>2?O[t[T]]=[-w[q][0],w[q][1],t[T]]:O[t[T]]=[y[w[q][0]],w[q][1],t[T]]};this.IDATA.edgematch=[[1,"B"],[2,"B"],[3,"B"],[4,"B"],[0,"B"],[10,"O",14,"A"],[11,"O",10,"A"],[12,"O",11,"A"],[13,"O",12,"A"],[14,"O",13,"A"],[0,"O"],[1,"O"],[2,"O"],[3,"O"],[4,"O"],[19,"B",5,"A"],[15,"B",6,"A"],[16,"B",7,"A"],[17,"B",8,"A"],[18,"B",9,"A"]];for(let G=0;G<20;G++){if(y=this.IDATA.face[G],c=y[2],h=y[1],d=y[0],E=f.x+"|"+f.y,T=G+"|"+E,T in t||(t[T]=c,O[c]=[y[w[E][0]],w[E][1]]),E=p.x+"|"+p.y,T=G+"|"+E,T in t||(t[T]=h,O[h]=[y[w[E][0]],w[E][1]]),E=g.x+"|"+g.y,T=G+"|"+E,T in t||(t[T]=d,O[d]=[y[w[E][0]],w[E][1]]),l=this.IDATA.edgematch[G][0],u=this.IDATA.edgematch[G][1],u==="B")for(let H=1;H<s;H++)S.x=i-H*(n+o),S.y=r+H*n,b.x=-H*o,b.y=H*(n+o),E=S.x+"|"+S.y,R=b.x+"|"+b.y,M(G,l,E,R);if(u==="O")for(let H=1;H<s;H++)b.x=-H*o,b.y=H*(n+o),_.x=H*n,_.y=H*o,E=b.x+"|"+b.y,R=_.x+"|"+_.y,M(G,l,E,R);if(l=this.IDATA.edgematch[G][2],u=this.IDATA.edgematch[G][3],u&&u==="A")for(let H=1;H<s;H++)_.x=H*n,_.y=H*o,S.x=i-(s-H)*(n+o),S.y=r+(s-H)*n,E=_.x+"|"+_.y,R=S.x+"|"+S.y,M(G,l,E,R);for(let H=0;H<this.vertices.length;H++)E=this.vertices[H].x+"|"+this.vertices[H].y,T=G+"|"+E,T in t||(t[T]=e++,w[E][0]>2?O[t[T]]=[-w[E][0],w[E][1],t[T]]:O[t[T]]=[y[w[E][0]],w[E][1],t[T]])}this.closestTo=O,this.vecToidx=t}calcCoeffs(){const e=this.m,t=this.n,i=Math.sqrt(3)/3,r=e*e+t*t+e*t;this.coau=(e+t)/r,this.cobu=-t/r,this.coav=-i*(e-t)/r,this.cobv=i*(2*e+t)/r}createInnerFacets(){const e=this.m,t=this.n;for(let i=0;i<t+e+1;i++)for(let r=this.min[i];r<this.max[i]+1;r++)r<this.max[i]&&r<this.max[i+1]+1&&this.innerFacets.push(["|"+r+"|"+i,"|"+r+"|"+(i+1),"|"+(r+1)+"|"+i]),i>0&&r<this.max[i-1]&&r+1<this.max[i]+1&&this.innerFacets.push(["|"+r+"|"+i,"|"+(r+1)+"|"+i,"|"+(r+1)+"|"+(i-1)])}edgeVecsABOB(){const e=this.m,t=this.n,i=new Pt(-t,e+t);for(let r=1;r<e+t;r++){const s=new Pt(this.min[r],r),n=new Pt(this.min[r-1],r-1),o=new Pt(this.min[r+1],r+1),l=s.clone(),u=n.clone(),c=o.clone();l.rotate60About(i),u.rotate60About(i),c.rotate60About(i);const h=new Pt(this.max[l.y],l.y),d=new Pt(this.max[l.y-1],l.y-1),f=new Pt(this.max[l.y-1]-1,l.y-1);(l.x!==h.x||l.y!==h.y)&&(l.x!==d.x?(this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([s,d,f]),this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([s,f,h])):l.y===c.y?(this.vertexTypes.push([1,1,0]),this.isoVecsABOB.push([s,n,d]),this.vertexTypes.push([1,0,1]),this.isoVecsABOB.push([s,d,o])):(this.vertexTypes.push([1,1,0]),this.isoVecsABOB.push([s,n,d]),this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([s,d,h])))}}mapABOBtoOBOA(){const e=new Pt(0,0);for(let t=0;t<this.isoVecsABOB.length;t++){const i=[];for(let r=0;r<3;r++)e.x=this.isoVecsABOB[t][r].x,e.y=this.isoVecsABOB[t][r].y,this.vertexTypes[t][r]===0&&e.rotateNeg120(this.m,this.n),i.push(e.clone());this.isoVecsOBOA.push(i)}}mapABOBtoBAOA(){const e=new Pt(0,0);for(let t=0;t<this.isoVecsABOB.length;t++){const i=[];for(let r=0;r<3;r++)e.x=this.isoVecsABOB[t][r].x,e.y=this.isoVecsABOB[t][r].y,this.vertexTypes[t][r]===1&&e.rotate120(this.m,this.n),i.push(e.clone());this.isoVecsBAOA.push(i)}}MapToFace(e,t){const i=this.IDATA.face[e],r=i[2],s=i[1],n=i[0],o=m.FromArray(this.IDATA.vertex[r]),l=m.FromArray(this.IDATA.vertex[s]),u=m.FromArray(this.IDATA.vertex[n]),c=l.subtract(o),h=u.subtract(o),d=c.scale(this.coau).add(h.scale(this.cobu)),f=c.scale(this.coav).add(h.scale(this.cobv));let p,g=V.Vector3[0];for(let _=0;_<this.cartesian.length;_++)g=d.scale(this.cartesian[_].x).add(f.scale(this.cartesian[_].y)).add(o),g.x,g.y,g.z,p=e+"|"+this.vertices[_].x+"|"+this.vertices[_].y,t.vertex[this.vecToidx[p]]=[g.x,g.y,g.z]}build(e,t){const i=[],r=Pt.Zero(),s=new Pt(e,t),n=new Pt(-t,e+t);i.push(r,s,n);for(let v=t;v<e+1;v++)for(let E=0;E<e+1-v;E++)i.push(new Pt(E,v));if(t>0){const v=ug(e,t),E=e/v,R=t/v;for(let w=1;w<v;w++)i.push(new Pt(w*E,w*R)),i.push(new Pt(-w*R,w*(E+R))),i.push(new Pt(e-w*(E+R),t+w*E));const O=e/t;for(let w=1;w<t;w++)for(let M=0;M<w*O;M++)i.push(new Pt(M,w)),i.push(new Pt(M,w).rotate120(e,t)),i.push(new Pt(M,w).rotateNeg120(e,t))}i.sort((v,E)=>v.x-E.x),i.sort((v,E)=>v.y-E.y);const o=new Array(e+t+1),l=new Array(e+t+1);for(let v=0;v<o.length;v++)o[v]=1/0,l[v]=-1/0;let u=0,c=0;const h=i.length;for(let v=0;v<h;v++)c=i[v].x,u=i[v].y,o[u]=Math.min(c,o[u]),l[u]=Math.max(c,l[u]);const d=(v,E)=>{const R=v.clone();return E==="A"&&R.rotateNeg120(e,t),E==="B"&&R.rotate120(e,t),R.x<0?R.y:R.x+R.y},f=[],p=[],g=[],_=[],S={},b=[];let y=-1,T=-1;for(let v=0;v<h;v++)f[v]=i[v].toCartesianOrigin(new Pt(0,0),.5),p[v]=d(i[v],"O"),g[v]=d(i[v],"A"),_[v]=d(i[v],"B"),p[v]===g[v]&&g[v]===_[v]?(y=3,T=p[v]):p[v]===g[v]?(y=4,T=p[v]):g[v]===_[v]?(y=5,T=g[v]):_[v]===p[v]&&(y=6,T=p[v]),p[v]<g[v]&&p[v]<_[v]&&(y=2,T=p[v]),g[v]<p[v]&&g[v]<_[v]&&(y=1,T=g[v]),_[v]<g[v]&&_[v]<p[v]&&(y=0,T=_[v]),b.push([y,T,i[v].x,i[v].y]);b.sort((v,E)=>v[2]-E[2]),b.sort((v,E)=>v[3]-E[3]),b.sort((v,E)=>v[1]-E[1]),b.sort((v,E)=>v[0]-E[0]);for(let v=0;v<b.length;v++)S[b[v][2]+"|"+b[v][3]]=[b[v][0],b[v][1],v];return this.m=e,this.n=t,this.vertices=i,this.vertByDist=S,this.cartesian=f,this.min=o,this.max=l,this}}class nh{constructor(e,t,i,r){this.name=e,this.category=t,this.vertex=i,this.face=r}}class Vu extends nh{innerToData(e,t){for(let i=0;i<t.innerFacets.length;i++)this.face.push(t.innerFacets[i].map(r=>t.vecToidx[e+r]))}mapABOBtoDATA(e,t){const i=t.IDATA.edgematch[e][0];for(let r=0;r<t.isoVecsABOB.length;r++){const s=[];for(let n=0;n<3;n++)t.vertexTypes[r][n]===0?s.push(e+"|"+t.isoVecsABOB[r][n].x+"|"+t.isoVecsABOB[r][n].y):s.push(i+"|"+t.isoVecsABOB[r][n].x+"|"+t.isoVecsABOB[r][n].y);this.face.push([t.vecToidx[s[0]],t.vecToidx[s[1]],t.vecToidx[s[2]]])}}mapOBOAtoDATA(e,t){const i=t.IDATA.edgematch[e][0];for(let r=0;r<t.isoVecsOBOA.length;r++){const s=[];for(let n=0;n<3;n++)t.vertexTypes[r][n]===1?s.push(e+"|"+t.isoVecsOBOA[r][n].x+"|"+t.isoVecsOBOA[r][n].y):s.push(i+"|"+t.isoVecsOBOA[r][n].x+"|"+t.isoVecsOBOA[r][n].y);this.face.push([t.vecToidx[s[0]],t.vecToidx[s[1]],t.vecToidx[s[2]]])}}mapBAOAtoDATA(e,t){const i=t.IDATA.edgematch[e][2];for(let r=0;r<t.isoVecsBAOA.length;r++){const s=[];for(let n=0;n<3;n++)t.vertexTypes[r][n]===1?s.push(e+"|"+t.isoVecsBAOA[r][n].x+"|"+t.isoVecsBAOA[r][n].y):s.push(i+"|"+t.isoVecsBAOA[r][n].x+"|"+t.isoVecsBAOA[r][n].y);this.face.push([t.vecToidx[s[0]],t.vecToidx[s[1]],t.vecToidx[s[2]]])}}orderData(e){const t=[];for(let n=0;n<13;n++)t[n]=[];const i=e.closestTo;for(let n=0;n<i.length;n++)i[n][0]>-1?i[n][1]>0&&t[i[n][0]].push([n,i[n][1]]):t[12].push([n,i[n][0]]);const r=[];for(let n=0;n<12;n++)r[n]=n;let s=12;for(let n=0;n<12;n++){t[n].sort((o,l)=>o[1]-l[1]);for(let o=0;o<t[n].length;o++)r[t[n][o][0]]=s++}for(let n=0;n<t[12].length;n++)r[t[12][n][0]]=s++;for(let n=0;n<this.vertex.length;n++)this.vertex[n].push(r[n]);this.vertex.sort((n,o)=>n[3]-o[3]);for(let n=0;n<this.vertex.length;n++)this.vertex[n].pop();for(let n=0;n<this.face.length;n++)for(let o=0;o<this.face[n].length;o++)this.face[n][o]=r[this.face[n][o]];this.sharedNodes=t[12].length,this.poleNodes=this.vertex.length-this.sharedNodes}setOrder(e,t){const i=[],r=[];let s=t.pop();r.push(s);let n=this.face[s].indexOf(e);n=(n+2)%3;let o=this.face[s][n];i.push(o);let l=0;for(;t.length>0;)s=t[l],this.face[s].indexOf(o)>-1?(n=(this.face[s].indexOf(o)+1)%3,o=this.face[s][n],i.push(o),r.push(s),t.splice(l,1),l=0):l++;return this.adjacentFaces.push(i),r}toGoldbergPolyhedronData(){const e=new nh("GeoDual","Goldberg",[],[]);e.name="GD dual";const t=this.vertex.length,i=new Array(t);for(let u=0;u<t;u++)i[u]=[];for(let u=0;u<this.face.length;u++)for(let c=0;c<3;c++)i[this.face[u][c]].push(u);let r=0,s=0,n=0,o=[],l=[];this.adjacentFaces=[];for(let u=0;u<i.length;u++)e.face[u]=this.setOrder(u,i[u].concat([])),i[u].forEach(c=>{r=0,s=0,n=0,o=this.face[c];for(let h=0;h<3;h++)l=this.vertex[o[h]],r+=l[0],s+=l[1],n+=l[2];e.vertex[c]=[r/3,s/3,n/3]});return e}static BuildGeodesicData(e){const t=new Vu("Geodesic-m-n","Geodesic",[[0,wt,-1],[-wt,1,0],[-1,0,-wt],[1,0,-wt],[wt,1,0],[0,wt,1],[-1,0,wt],[-wt,-1,0],[0,-wt,-1],[wt,-1,0],[1,0,wt],[0,-wt,1]],[]);e.setIndices(),e.calcCoeffs(),e.createInnerFacets(),e.edgeVecsABOB(),e.mapABOBtoOBOA(),e.mapABOBtoBAOA();for(let r=0;r<e.IDATA.face.length;r++)e.MapToFace(r,t),t.innerToData(r,e),e.IDATA.edgematch[r][1]==="B"&&t.mapABOBtoDATA(r,e),e.IDATA.edgematch[r][1]==="O"&&t.mapOBOAtoDATA(r,e),e.IDATA.edgematch[r][3]==="A"&&t.mapBAOAtoDATA(r,e);t.orderData(e);const i=1;return t.vertex=t.vertex.map(function(r){const s=r[0],n=r[1],o=r[2],l=Math.sqrt(s*s+n*n+o*o);return r[0]*=i/l,r[1]*=i/l,r[2]*=i/l,r}),t}}function HD(a,e,t=null){let i=e.m||1;i!==Math.floor(i)&&(i=Math.floor(i),L.Warn("m not an integer only floor(m) used"));let r=e.n||0;if(r!==Math.floor(r)&&(r=Math.floor(r),L.Warn("n not an integer only floor(n) used")),r>i){const u=r;r=i,i=u,L.Warn("n > m therefore m and n swapped")}const s=new _0;s.build(i,r);const o={custom:Vu.BuildGeodesicData(s),size:e.size,sizeX:e.sizeX,sizeY:e.sizeY,sizeZ:e.sizeZ,faceUV:e.faceUV,faceColors:e.faceColors,flat:e.flat,updatable:e.updatable,sideOrientation:e.sideOrientation,frontUVs:e.frontUVs,backUVs:e.backUVs};return Bu(a,o,t)}z._GoldbergMeshParser=(a,e)=>ku.Parse(a,e);class ku extends z{constructor(){super(...arguments),this.goldbergData={faceColors:[],faceCenters:[],faceZaxis:[],faceXaxis:[],faceYaxis:[],nbSharedFaces:0,nbUnsharedFaces:0,nbFaces:0,nbFacesAtPole:0,adjacentFaces:[]}}relatedGoldbergFace(e,t){return t===void 0?(e>this.goldbergData.nbUnsharedFaces-1&&(L.Warn("Maximum number of unshared faces used"),e=this.goldbergData.nbUnsharedFaces-1),this.goldbergData.nbUnsharedFaces+e):(e>11&&(L.Warn("Last pole used"),e=11),t>this.goldbergData.nbFacesAtPole-1&&(L.Warn("Maximum number of faces at a pole used"),t=this.goldbergData.nbFacesAtPole-1),12+e*this.goldbergData.nbFacesAtPole+t)}_changeGoldbergFaceColors(e){for(let i=0;i<e.length;i++){const r=e[i][0],s=e[i][1],n=e[i][2];for(let o=r;o<s+1;o++)this.goldbergData.faceColors[o]=n}const t=[];for(let i=0;i<12;i++)for(let r=0;r<5;r++)t.push(this.goldbergData.faceColors[i].r,this.goldbergData.faceColors[i].g,this.goldbergData.faceColors[i].b,this.goldbergData.faceColors[i].a);for(let i=12;i<this.goldbergData.faceColors.length;i++)for(let r=0;r<6;r++)t.push(this.goldbergData.faceColors[i].r,this.goldbergData.faceColors[i].g,this.goldbergData.faceColors[i].b,this.goldbergData.faceColors[i].a);return t}setGoldbergFaceColors(e){const t=this._changeGoldbergFaceColors(e);this.setVerticesData(N.ColorKind,t)}updateGoldbergFaceColors(e){const t=this._changeGoldbergFaceColors(e);this.updateVerticesData(N.ColorKind,t)}_changeGoldbergFaceUVs(e){const t=this.getVerticesData(N.UVKind);for(let i=0;i<e.length;i++){const r=e[i][0],s=e[i][1],n=e[i][2],o=e[i][3],l=e[i][4],u=[],c=[];let h,d;for(let f=0;f<5;f++)h=n.x+o*Math.cos(l+f*Math.PI/2.5),d=n.y+o*Math.sin(l+f*Math.PI/2.5),h<0&&(h=0),h>1&&(h=1),u.push(h,d);for(let f=0;f<6;f++)h=n.x+o*Math.cos(l+f*Math.PI/3),d=n.y+o*Math.sin(l+f*Math.PI/3),h<0&&(h=0),h>1&&(h=1),c.push(h,d);for(let f=r;f<Math.min(12,s+1);f++)for(let p=0;p<5;p++)t[10*f+2*p]=u[2*p],t[10*f+2*p+1]=u[2*p+1];for(let f=Math.max(12,r);f<s+1;f++)for(let p=0;p<6;p++)t[12*f-24+2*p]=c[2*p],t[12*f-23+2*p]=c[2*p+1]}return t}setGoldbergFaceUVs(e){const t=this._changeGoldbergFaceUVs(e);this.setVerticesData(N.UVKind,t)}updateGoldbergFaceUVs(e){const t=this._changeGoldbergFaceUVs(e);this.updateVerticesData(N.UVKind,t)}placeOnGoldbergFaceAt(e,t,i){const r=m.RotationFromAxis(this.goldbergData.faceXaxis[t],this.goldbergData.faceYaxis[t],this.goldbergData.faceZaxis[t]);e.rotation=r,e.position=this.goldbergData.faceCenters[t].add(this.goldbergData.faceXaxis[t].scale(i.x)).add(this.goldbergData.faceYaxis[t].scale(i.y)).add(this.goldbergData.faceZaxis[t].scale(i.z))}serialize(e){super.serialize(e),e.type="GoldbergMesh";const t={};if(t.adjacentFaces=this.goldbergData.adjacentFaces,t.nbSharedFaces=this.goldbergData.nbSharedFaces,t.nbUnsharedFaces=this.goldbergData.nbUnsharedFaces,t.nbFaces=this.goldbergData.nbFaces,t.nbFacesAtPole=this.goldbergData.nbFacesAtPole,this.goldbergData.faceColors){t.faceColors=[];for(const i of this.goldbergData.faceColors)t.faceColors.push(i.asArray())}if(this.goldbergData.faceCenters){t.faceCenters=[];for(const i of this.goldbergData.faceCenters)t.faceCenters.push(i.asArray())}if(this.goldbergData.faceZaxis){t.faceZaxis=[];for(const i of this.goldbergData.faceZaxis)t.faceZaxis.push(i.asArray())}if(this.goldbergData.faceYaxis){t.faceYaxis=[];for(const i of this.goldbergData.faceYaxis)t.faceYaxis.push(i.asArray())}if(this.goldbergData.faceXaxis){t.faceXaxis=[];for(const i of this.goldbergData.faceXaxis)t.faceXaxis.push(i.asArray())}e.goldbergData=t}static Parse(e,t){const i=e.goldbergData;i.faceColors=i.faceColors.map(s=>xe.FromArray(s)),i.faceCenters=i.faceCenters.map(s=>m.FromArray(s)),i.faceZaxis=i.faceZaxis.map(s=>m.FromArray(s)),i.faceXaxis=i.faceXaxis.map(s=>m.FromArray(s)),i.faceYaxis=i.faceYaxis.map(s=>m.FromArray(s));const r=new ku(e.name,t);return r.goldbergData=i,r}}function jD(a,e){const t=a.size,i=a.sizeX||t||1,r=a.sizeY||t||1,s=a.sizeZ||t||1,n=a.sideOrientation===0?0:a.sideOrientation||he.DEFAULTSIDE,o=[],l=[],u=[],c=[];let h=1/0,d=-1/0,f=1/0,p=-1/0;for(let S=0;S<e.vertex.length;S++)h=Math.min(h,e.vertex[S][0]*i),d=Math.max(d,e.vertex[S][0]*i),f=Math.min(f,e.vertex[S][1]*r),p=Math.max(p,e.vertex[S][1]*r);let g=0;for(let S=0;S<e.face.length;S++){const b=e.face[S],y=m.FromArray(e.vertex[b[0]]),T=m.FromArray(e.vertex[b[2]]),v=m.FromArray(e.vertex[b[1]]),E=T.subtract(y),R=v.subtract(y),O=m.Cross(R,E).normalize();for(let w=0;w<b.length;w++){u.push(O.x,O.y,O.z);const M=e.vertex[b[w]];o.push(M[0]*i,M[1]*r,M[2]*s);const G=(M[1]*r-f)/(p-f);c.push((M[0]*i-h)/(d-h),ot?1-G:G)}for(let w=0;w<b.length-2;w++)l.push(g,g+w+2,g+w+1);g+=b.length}he._ComputeSides(n,o,l,u,c);const _=new he;return _.positions=o,_.indices=l,_.normals=u,_.uvs=c,_}function YD(a,e,t=null){const i=e.size,r=e.sizeX||i||1,s=e.sizeY||i||1,n=e.sizeZ||i||1;let o=e.m||1;o!==Math.floor(o)&&(o=Math.floor(o),L.Warn("m not an integer only floor(m) used"));let l=e.n||0;if(l!==Math.floor(l)&&(l=Math.floor(l),L.Warn("n not an integer only floor(n) used")),l>o){const p=l;l=o,o=p,L.Warn("n > m therefore m and n swapped")}const u=new _0;u.build(o,l);const c=Vu.BuildGeodesicData(u),h=c.toGoldbergPolyhedronData(),d=new ku(a,t);e.sideOrientation=z._GetDefaultSideOrientation(e.sideOrientation),d._originalBuilderSideOrientation=e.sideOrientation,jD(e,h).applyToMesh(d,e.updatable),d.goldbergData.nbSharedFaces=c.sharedNodes,d.goldbergData.nbUnsharedFaces=c.poleNodes,d.goldbergData.adjacentFaces=c.adjacentFaces,d.goldbergData.nbFaces=d.goldbergData.nbSharedFaces+d.goldbergData.nbUnsharedFaces,d.goldbergData.nbFacesAtPole=(d.goldbergData.nbUnsharedFaces-12)/12;for(let p=0;p<c.vertex.length;p++)d.goldbergData.faceCenters.push(m.FromArray(c.vertex[p])),d.goldbergData.faceCenters[p].x*=r,d.goldbergData.faceCenters[p].y*=s,d.goldbergData.faceCenters[p].z*=n,d.goldbergData.faceColors.push(new xe(1,1,1,1));for(let p=0;p<h.face.length;p++){const g=h.face[p],_=m.FromArray(h.vertex[g[0]]),S=m.FromArray(h.vertex[g[2]]),b=m.FromArray(h.vertex[g[1]]),y=S.subtract(_),T=b.subtract(_),v=m.Cross(T,y).normalize(),E=m.Cross(T,v).normalize();d.goldbergData.faceXaxis.push(T.normalize()),d.goldbergData.faceYaxis.push(v),d.goldbergData.faceZaxis.push(E)}return d}class XD{constructor(e){this._paths=[],this._tempPaths=[],this._holes=[],this._resolution=e}moveTo(e,t){this._currentPath=new Nm(e,t),this._tempPaths.push(this._currentPath)}lineTo(e,t){this._currentPath.addLineTo(e,t)}quadraticCurveTo(e,t,i,r){this._currentPath.addQuadraticCurveTo(e,t,i,r,this._resolution)}bezierCurveTo(e,t,i,r,s,n){this._currentPath.addBezierCurveTo(e,t,i,r,s,n,this._resolution)}extractHoles(){for(const e of this._tempPaths)e.area()>0?this._holes.push(e):this._paths.push(e);if(!this._paths.length&&this._holes.length){const e=this._holes;this._holes=this._paths,this._paths=e}this._tempPaths.length=0}get paths(){return this._paths}get holes(){return this._holes}}function ZD(a,e,t,i,r,s){const n=s.glyphs[a]||s.glyphs["?"];if(!n)return null;const o=new XD(r);if(n.o){const l=n.o.split(" ");for(let u=0,c=l.length;u<c;)switch(l[u++]){case"m":{const d=parseInt(l[u++])*e+t,f=parseInt(l[u++])*e+i;o.moveTo(d,f);break}case"l":{const d=parseInt(l[u++])*e+t,f=parseInt(l[u++])*e+i;o.lineTo(d,f);break}case"q":{const d=parseInt(l[u++])*e+t,f=parseInt(l[u++])*e+i,p=parseInt(l[u++])*e+t,g=parseInt(l[u++])*e+i;o.quadraticCurveTo(p,g,d,f);break}case"b":{const d=parseInt(l[u++])*e+t,f=parseInt(l[u++])*e+i,p=parseInt(l[u++])*e+t,g=parseInt(l[u++])*e+i,_=parseInt(l[u++])*e+t,S=parseInt(l[u++])*e+i;o.bezierCurveTo(p,g,_,S,d,f);break}}}return o.extractHoles(),{offsetX:n.ha*e,shapePath:o}}function g0(a,e,t,i){const r=Array.from(a),s=e/i.resolution,n=(i.boundingBox.yMax-i.boundingBox.yMin+i.underlineThickness)*s,o=[];let l=0,u=0;for(let c=0;c<r.length;c++){const h=r[c];if(h===`
`)l=0,u-=n;else{const d=ZD(h,s,l,u,t,i);d&&(l+=d.offsetX,o.push(d.shapePath))}}return o}function qD(a,e,t,i={size:50,resolution:8,depth:1},r=null,s=earcut){var c,h;const n=g0(e,i.size||50,i.resolution||8,t),o=[];let l=0;for(const d of n){if(!d.paths.length)continue;const f=d.holes.slice();for(const p of d.paths){const g=[],_=[],S=p.getPoints();for(const T of S)_.push(new m(T.x,0,T.y));const b=f.slice();for(const T of b){const v=T.getPoints();let E=!1;for(const O of v)if(p.isPointInside(O)){E=!0;break}if(!E)continue;const R=[];for(const O of v)R.push(new m(O.x,0,O.y));g.push(R),f.splice(f.indexOf(T),1)}if(!g.length&&f.length)for(const T of f){const v=T.getPoints(),E=[];for(const R of v)E.push(new m(R.x,0,R.y));g.push(E)}const y=Nu(a,{shape:_,holes:g.length?g:void 0,depth:i.depth||1,faceUV:i.faceUV||((c=i.perLetterFaceUV)==null?void 0:c.call(i,l)),faceColors:i.faceColors||((h=i.perLetterFaceColors)==null?void 0:h.call(i,l)),sideOrientation:z._GetDefaultSideOrientation(i.sideOrientation||z.DOUBLESIDE)},r,s);o.push(y),l++}}const u=z.MergeMeshes(o,!0,!0);if(u){const d=u.getBoundingInfo().boundingBox;u.position.x+=-(d.minimumWorld.x+d.maximumWorld.x)/2,u.position.y+=-(d.minimumWorld.y+d.maximumWorld.y)/2,u.position.z+=-(d.minimumWorld.z+d.maximumWorld.z)/2+d.extendSize.z,u.name=a;const f=new Bi("pivot",r);f.rotation.x=-Math.PI/2,u.parent=f,u.bakeCurrentTransformIntoVertices(),u.parent=null,f.dispose()}return u}const MW={CreateBox:Xi,CreateTiledBox:l0,CreateSphere:Ti,CreateDisc:Ou,CreateIcoSphere:$o,CreateRibbon:mn,CreateCylinder:tr,CreateTorus:fs,CreateTorusKnot:m_,CreateLineSystem:ba,CreateLines:ai,CreateDashedLines:__,ExtrudeShape:Fu,ExtrudeShapeCustom:Lu,CreateLathe:g_,CreateTiledPlane:a0,CreatePlane:gn,CreateGround:ol,CreateTiledGround:n_,CreateGroundFromHeightMap:a_,CreatePolygon:wu,ExtrudePolygon:Nu,CreateTube:x_,CreatePolyhedron:Bu,CreateGeodesic:HD,CreateGoldberg:YD,CreateDecal:v_,CreateCapsule:f_,CreateText:qD};class Ni{static CreateBoneWeightShader(e,t){const i=e.skeleton,r=e.colorBase??ne.Black(),s=e.colorZero??ne.Blue(),n=e.colorQuarter??ne.Green(),o=e.colorHalf??ne.Yellow(),l=e.colorFull??ne.Red(),u=e.targetBoneIndex??0;_i.ShadersStore["boneWeights:"+i.name+"VertexShader"]=`precision highp float;

        attribute vec3 position;
        attribute vec2 uv;

        uniform mat4 view;
        uniform mat4 projection;
        uniform mat4 worldViewProjection;

        #include<bonesDeclaration>
        #if NUM_BONE_INFLUENCERS == 0
            attribute vec4 matricesIndices;
            attribute vec4 matricesWeights;
        #endif
        #include<bakedVertexAnimationDeclaration>

        #include<instancesDeclaration>

        varying vec3 vColor;

        uniform vec3 colorBase;
        uniform vec3 colorZero;
        uniform vec3 colorQuarter;
        uniform vec3 colorHalf;
        uniform vec3 colorFull;

        uniform float targetBoneIndex;

        void main() {
            vec3 positionUpdated = position;

            #include<instancesVertex>
            #include<bonesVertex>
            #include<bakedVertexAnimation>

            vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);

            vec3 color = colorBase;
            float totalWeight = 0.;
            if(matricesIndices[0] == targetBoneIndex && matricesWeights[0] > 0.){
                totalWeight += matricesWeights[0];
            }
            if(matricesIndices[1] == targetBoneIndex && matricesWeights[1] > 0.){
                totalWeight += matricesWeights[1];
            }
            if(matricesIndices[2] == targetBoneIndex && matricesWeights[2] > 0.){
                totalWeight += matricesWeights[2];
            }
            if(matricesIndices[3] == targetBoneIndex && matricesWeights[3] > 0.){
                totalWeight += matricesWeights[3];
            }

            color = mix(color, colorZero, smoothstep(0., 0.25, totalWeight));
            color = mix(color, colorQuarter, smoothstep(0.25, 0.5, totalWeight));
            color = mix(color, colorHalf, smoothstep(0.5, 0.75, totalWeight));
            color = mix(color, colorFull, smoothstep(0.75, 1.0, totalWeight));
            vColor = color;

        gl_Position = projection * view * worldPos;
        }`,_i.ShadersStore["boneWeights:"+i.name+"FragmentShader"]=`
            precision highp float;
            varying vec3 vPosition;

            varying vec3 vColor;

            void main() {
                vec4 color = vec4(vColor, 1.0);
                gl_FragColor = color;
            }
        `;const c=new Wr("boneWeight:"+i.name,t,{vertex:"boneWeights:"+i.name,fragment:"boneWeights:"+i.name},{attributes:["position","normal","matricesIndices","matricesWeights"],uniforms:["world","worldView","worldViewProjection","view","projection","viewProjection","colorBase","colorZero","colorQuarter","colorHalf","colorFull","targetBoneIndex"]});return c.setColor3("colorBase",r),c.setColor3("colorZero",s),c.setColor3("colorQuarter",n),c.setColor3("colorHalf",o),c.setColor3("colorFull",l),c.setFloat("targetBoneIndex",u),c.getClassName=()=>"BoneWeightShader",c.transparencyMode=ft.MATERIAL_OPAQUE,c}static CreateSkeletonMapShader(e,t){const i=e.skeleton,r=e.colorMap??[{color:new ne(1,.38,.18),location:0},{color:new ne(.59,.18,1),location:.2},{color:new ne(.59,1,.18),location:.4},{color:new ne(1,.87,.17),location:.6},{color:new ne(1,.17,.42),location:.8},{color:new ne(.17,.68,1),location:1}],s=i.bones.length+1,n=Ni._CreateBoneMapColorBuffer(s,r,t),o=new Wr("boneWeights:"+i.name,t,{vertexSource:`precision highp float;

            attribute vec3 position;
            attribute vec2 uv;

            uniform mat4 view;
            uniform mat4 projection;
            uniform mat4 worldViewProjection;
            uniform float colorMap[`+i.bones.length*4+`];

            #include<bonesDeclaration>
            #if NUM_BONE_INFLUENCERS == 0
                attribute vec4 matricesIndices;
                attribute vec4 matricesWeights;
            #endif
            #include<bakedVertexAnimationDeclaration>
            #include<instancesDeclaration>

            varying vec3 vColor;

            void main() {
                vec3 positionUpdated = position;

                #include<instancesVertex>
                #include<bonesVertex>
                #include<bakedVertexAnimation>

                vec3 color = vec3(0.);
                bool first = true;

                for (int i = 0; i < 4; i++) {
                    int boneIdx = int(matricesIndices[i]);
                    float boneWgt = matricesWeights[i];

                    vec3 c = vec3(colorMap[boneIdx * 4 + 0], colorMap[boneIdx * 4 + 1], colorMap[boneIdx * 4 + 2]);

                    if (boneWgt > 0.) {
                        if (first) {
                            first = false;
                            color = c;
                        } else {
                            color = mix(color, c, boneWgt);
                        }
                    }
                }

                vColor = color;

                vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);

                gl_Position = projection * view * worldPos;
            }`,fragmentSource:`
            precision highp float;
            varying vec3 vColor;

            void main() {
                vec4 color = vec4( vColor, 1.0 );
                gl_FragColor = color;
            }
            `},{attributes:["position","normal","matricesIndices","matricesWeights"],uniforms:["world","worldView","worldViewProjection","view","projection","viewProjection","colorMap"]});return o.setFloats("colorMap",n),o.getClassName=()=>"SkeletonMapShader",o.transparencyMode=ft.MATERIAL_OPAQUE,o}static _CreateBoneMapColorBuffer(e,t,i){const r=new Is("temp",{width:e,height:1},i,!1),s=r.getContext(),n=s.createLinearGradient(0,0,e,0);t.forEach(c=>{n.addColorStop(c.location,c.color.toHexString())}),s.fillStyle=n,s.fillRect(0,0,e,1),r.update();const o=[],l=s.getImageData(0,0,e,1).data,u=1/255;for(let c=0;c<l.length;c++)o.push(l[c]*u);return r.dispose(),o}get scene(){return this._scene}get utilityLayer(){return this._utilityLayer}get isReady(){return this._ready}set ready(e){this._ready=e}get debugMesh(){return this._debugMesh}set debugMesh(e){this._debugMesh=e}get displayMode(){return this.options.displayMode||Ni.DISPLAY_LINES}set displayMode(e){e>Ni.DISPLAY_SPHERE_AND_SPURS&&(e=Ni.DISPLAY_LINES),this.options.displayMode=e}constructor(e,t,i,r=!0,s=3,n={}){if(this.skeleton=e,this.mesh=t,this.autoUpdateBonesMatrices=r,this.renderingGroupId=s,this.options=n,this.color=ne.White(),this._debugLines=new Array,this._localAxes=null,this._isEnabled=!0,this._obs=null,this._scene=i,this._ready=!1,n.pauseAnimations=n.pauseAnimations??!0,n.returnToRest=n.returnToRest??!1,n.displayMode=n.displayMode??Ni.DISPLAY_LINES,n.displayOptions=n.displayOptions??{},n.displayOptions.midStep=n.displayOptions.midStep??.235,n.displayOptions.midStepFactor=n.displayOptions.midStepFactor??.155,n.displayOptions.sphereBaseSize=n.displayOptions.sphereBaseSize??.15,n.displayOptions.sphereScaleUnit=n.displayOptions.sphereScaleUnit??2,n.displayOptions.sphereFactor=n.displayOptions.sphereFactor??.865,n.displayOptions.spurFollowsChild=n.displayOptions.spurFollowsChild??!1,n.displayOptions.showLocalAxes=n.displayOptions.showLocalAxes??!1,n.displayOptions.localAxesSize=n.displayOptions.localAxesSize??.075,n.computeBonesUsingShaders=n.computeBonesUsingShaders??!0,n.useAllBones=n.useAllBones??!0,this._boneIndices=new Set,!n.useAllBones){const l=t==null?void 0:t.getVerticesData(N.MatricesIndicesKind),u=t==null?void 0:t.getVerticesData(N.MatricesWeightsKind);if(l&&u)for(let c=0;c<l.length;++c){const h=l[c];u[c]!==0&&this._boneIndices.add(h)}}this._utilityLayer=new gt(this._scene,!1),this._utilityLayer.pickUtilitySceneFirst=!1,this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil=!0;let o=this.options.displayMode||0;o>Ni.DISPLAY_SPHERE_AND_SPURS&&(o=Ni.DISPLAY_LINES),this.displayMode=o,this.update(),this._bindObs()}_bindObs(){switch(this.displayMode){case Ni.DISPLAY_LINES:{this._obs=this.scene.onBeforeRenderObservable.add(()=>{this._displayLinesUpdate()});break}}}update(){switch(this.displayMode){case Ni.DISPLAY_LINES:{this._displayLinesUpdate();break}case Ni.DISPLAY_SPHERES:{this._buildSpheresAndSpurs(!0);break}case Ni.DISPLAY_SPHERE_AND_SPURS:{this._buildSpheresAndSpurs(!1);break}}this._buildLocalAxes()}set isEnabled(e){this.isEnabled!==e&&(this._isEnabled=e,this.debugMesh&&this.debugMesh.setEnabled(e),e&&!this._obs?this._bindObs():!e&&this._obs&&(this.scene.onBeforeRenderObservable.remove(this._obs),this._obs=null))}get isEnabled(){return this._isEnabled}_getBonePosition(e,t,i,r=0,s=0,n=0){const o=V.Matrix[0],l=t.getParent();if(o.copyFrom(t.getLocalMatrix()),r!==0||s!==0||n!==0){const u=V.Matrix[1];$.IdentityToRef(u),u.setTranslationFromFloats(r,s,n),u.multiplyToRef(o,o)}l&&o.multiplyToRef(l.getAbsoluteMatrix(),o),o.multiplyToRef(i,o),e.x=o.m[12],e.y=o.m[13],e.z=o.m[14]}_getLinesForBonesWithLength(e,t){const i=e.length;let r,s;t?(r=t.getWorldMatrix(),s=t.position):(r=new $,s=e[0].position);let n=0;for(let o=0;o<i;o++){const l=e[o];let u=this._debugLines[n];l._index===-1||!this._boneIndices.has(l.getIndex())&&!this.options.useAllBones||(u||(u=[m.Zero(),m.Zero()],this._debugLines[n]=u),this._getBonePosition(u[0],l,r),this._getBonePosition(u[1],l,r,0,l.length,0),u[0].subtractInPlace(s),u[1].subtractInPlace(s),n++)}}_getLinesForBonesNoLength(e){const t=e.length;let i=0;const r=this.mesh;let s,n;r?(s=r,n=r.position):(s=new Bi(""),n=e[0].position);for(let o=t-1;o>=0;o--){const l=e[o],u=l.getParent();if(!u||!this._boneIndices.has(l.getIndex())&&!this.options.useAllBones)continue;let c=this._debugLines[i];c||(c=[m.Zero(),m.Zero()],this._debugLines[i]=c),l.getAbsolutePositionToRef(s,c[0]),u.getAbsolutePositionToRef(s,c[1]),c[0].subtractInPlace(n),c[1].subtractInPlace(n),i++}r||s.dispose()}_revert(e){this.options.pauseAnimations&&(this.scene.animationsEnabled=e,this.utilityLayer.utilityLayerScene.animationsEnabled=e)}_getAbsoluteBindPoseToRef(e,t){if(e===null||e._index===-1){t.copyFrom($.Identity());return}this._getAbsoluteBindPoseToRef(e.getParent(),t),e.getBindMatrix().multiplyToRef(t,t)}_createSpur(e,t,i,r,s,n){const o=i.subtract(e),l=o.length(),u=o.normalize().scale(l),c=s.midStep||.165,h=s.midStepFactor||.215,d=u.scale(c),f=Lu("skeletonViewer",{shape:[new m(1,-1,0),new m(1,1,0),new m(-1,1,0),new m(-1,-1,0),new m(1,-1,0)],path:[m.Zero(),d,u],scaleFunction:S=>{switch(S){case 0:case 2:return 0;case 1:return l*h}return 0},sideOrientation:z.DEFAULTSIDE,updatable:!1},n),p=f.getTotalVertices(),g=[],_=[];for(let S=0;S<p;S++)g.push(1,0,0,0),r&&s.spurFollowsChild&&S>9?_.push(r.getIndex(),0,0,0):_.push(t.getIndex(),0,0,0);return f.position=e.clone(),f.setVerticesData(N.MatricesWeightsKind,g,!1),f.setVerticesData(N.MatricesIndicesKind,_,!1),f.convertToFlatShadedMesh(),f}_getBoundingSphereForBone(e){if(!this.mesh)return null;const t=this.mesh.getVerticesData(N.PositionKind),i=this.mesh.getIndices(),r=this.mesh.getVerticesData(N.MatricesWeightsKind),s=this.mesh.getVerticesData(N.MatricesIndicesKind);if(!t||!i||!r||!s)return null;const n=new m(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),o=new m(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);let l=0;for(let u=0;u<i.length;++u){const c=i[u];for(let h=0;h<4;++h){const d=s[c*4+h],f=r[c*4+h];if(d===e&&f>1e-5){m.FromArrayToRef(t,c*3,V.Vector3[0]),n.minimizeInPlace(V.Vector3[0]),o.maximizeInPlace(V.Vector3[0]),l++;break}}}return l>1?{center:m.Center(n,o),radius:m.Distance(n,o)/2}:null}_buildSpheresAndSpurs(e=!0){var o;this._debugMesh&&(this._debugMesh.dispose(),this._debugMesh=null,this.ready=!1),this._ready=!1;const t=(o=this.utilityLayer)==null?void 0:o.utilityLayerScene,i=this.skeleton.bones,r=[],s=[],n=this.scene.animationsEnabled;try{this.options.pauseAnimations&&(this.scene.animationsEnabled=!1,t.animationsEnabled=!1),this.options.returnToRest&&this.skeleton.returnToRest(),this.autoUpdateBonesMatrices&&this.skeleton.computeAbsoluteMatrices();let l=Number.NEGATIVE_INFINITY;const u=this.options.displayOptions||{};for(let p=0;p<i.length;p++){const g=i[p];if(g._index===-1||!this._boneIndices.has(g.getIndex())&&!this.options.useAllBones)continue;const _=new $;this._getAbsoluteBindPoseToRef(g,_);const S=new m;if(_.decompose(void 0,void 0,S),g.children.length>0)g.children.forEach(R=>{const O=new $;R.getLocalMatrix().multiplyToRef(_,O);const w=new m;O.decompose(void 0,void 0,w);const M=m.Distance(S,w);M>l&&(l=M),!e&&s.push(this._createSpur(S,g,w,R,u,t))});else{const R=this._getBoundingSphereForBone(g.getIndex());if(R&&(R.radius>l&&(l=R.radius),!e)){let O;const w=g.getParent();w?(this._getAbsoluteBindPoseToRef(w,_),_.decompose(void 0,void 0,V.Vector3[0]),O=S.subtract(V.Vector3[0]).normalize().scale(R.radius).add(S)):O=R.center.subtract(S).normalize().scale(R.radius).add(S),s.push(this._createSpur(S,g,O,null,u,t))}}const b=u.sphereBaseSize||.2,y=Ti("skeletonViewer",{segments:6,diameter:b,updatable:!0},t),T=y.getTotalVertices(),v=[],E=[];for(let R=0;R<T;R++)v.push(1,0,0,0),E.push(g.getIndex(),0,0,0);y.setVerticesData(N.MatricesWeightsKind,v,!1),y.setVerticesData(N.MatricesIndicesKind,E,!1),y.position=S.clone(),r.push([y,g])}const c=u.sphereScaleUnit||2,h=u.sphereFactor||.85,d=[];for(let p=0;p<r.length;p++){const[g,_]=r[p],S=1/(c/l);let b=0,y=_;for(;y.getParent()&&y.getParent().getIndex()!==-1;)b++,y=y.getParent();g.scaling.scaleInPlace(S*Math.pow(h,b)),d.push(g)}this.debugMesh=z.MergeMeshes(d.concat(s),!0,!0),this.debugMesh&&(this.debugMesh.renderingGroupId=this.renderingGroupId,this.debugMesh.skeleton=this.skeleton,this.debugMesh.parent=this.mesh,this.debugMesh.computeBonesUsingShaders=this.options.computeBonesUsingShaders??!0,this.debugMesh.alwaysSelectAsActiveMesh=!0);const f=this.utilityLayer._getSharedGizmoLight();f.intensity=.7,this._revert(n),this.ready=!0}catch(l){L.Error(l),this._revert(n),this.dispose()}}_buildLocalAxes(){this._localAxes&&this._localAxes.dispose(),this._localAxes=null;const e=this.options.displayOptions||{};if(!e.showLocalAxes)return;const t=this._utilityLayer.utilityLayerScene,i=e.localAxesSize||.075,r=[],s=[],n=new xe(1,0,0,1),o=new xe(0,1,0,1),l=new xe(0,0,1,1),u=[],c=[],h=6;for(const d in this.skeleton.bones){const f=this.skeleton.bones[d];if(f._index===-1||!this._boneIndices.has(f.getIndex())&&!this.options.useAllBones)continue;const p=new $,g=new m;this._getAbsoluteBindPoseToRef(f,p),p.decompose(void 0,V.Quaternion[0],g);const _=new $;V.Quaternion[0].toRotationMatrix(_);const S=m.TransformCoordinates(new m(0+i,0,0),_),b=m.TransformCoordinates(new m(0,0+i,0),_),y=m.TransformCoordinates(new m(0,0,0+i),_),T=[g,g.add(S)],v=[g,g.add(b)],E=[g,g.add(y)],R=[T,v,E],O=[[n,n],[o,o],[l,l]];r.push(...R),s.push(...O);for(let w=0;w<h;w++)u.push(1,0,0,0),c.push(f.getIndex(),0,0,0)}this._localAxes=ba("localAxes",{lines:r,colors:s,updatable:!0},t),this._localAxes.setVerticesData(N.MatricesWeightsKind,u,!1),this._localAxes.setVerticesData(N.MatricesIndicesKind,c,!1),this._localAxes.skeleton=this.skeleton,this._localAxes.renderingGroupId=this.renderingGroupId+1,this._localAxes.parent=this.mesh,this._localAxes.computeBonesUsingShaders=this.options.computeBonesUsingShaders??!0}_displayLinesUpdate(){if(!this._utilityLayer)return;this.autoUpdateBonesMatrices&&this.skeleton.computeAbsoluteMatrices(),this.skeleton.bones[0].length===void 0?this._getLinesForBonesNoLength(this.skeleton.bones):this._getLinesForBonesWithLength(this.skeleton.bones,this.mesh);const e=this._utilityLayer.utilityLayerScene;e&&(this._debugMesh?ba("",{lines:this._debugLines,updatable:!0,instance:this._debugMesh},e):(this._debugMesh=ba("",{lines:this._debugLines,updatable:!0,instance:null},e),this._debugMesh.renderingGroupId=this.renderingGroupId),this.mesh?this._debugMesh.position.copyFrom(this.mesh.position):this._debugMesh.position.copyFrom(this.skeleton.bones[0].position),this._debugMesh.color=this.color)}changeDisplayMode(e){const t=!!this.isEnabled;this.displayMode!==e&&(this.isEnabled=!1,this._debugMesh&&(this._debugMesh.dispose(),this._debugMesh=null,this.ready=!1),this.displayMode=e,this.update(),this._bindObs(),this.isEnabled=t)}changeDisplayOptions(e,t){const i=!!this.isEnabled;this.options.displayOptions[e]=t,this.isEnabled=!1,this._debugMesh&&(this._debugMesh.dispose(),this._debugMesh=null,this.ready=!1),this.update(),this._bindObs(),this.isEnabled=i}dispose(){this.isEnabled=!1,this._debugMesh&&(this._debugMesh.dispose(),this._debugMesh=null),this._utilityLayer&&(this._utilityLayer.dispose(),this._utilityLayer=null),this.ready=!1}}Ni.DISPLAY_LINES=0;Ni.DISPLAY_SPHERES=1;Ni.DISPLAY_SPHERE_AND_SPURS=2;st.prototype.getGPUFrameTimeCounter=function(){return this._gpuFrameTime||(this._gpuFrameTime=new fu),this._gpuFrameTime};st.prototype.captureGPUFrameTime=function(a){};class QD{constructor(){this.occlusionInternalRetryCounter=0,this.isOcclusionQueryInProgress=!1,this.isOccluded=!1,this.occlusionRetryCount=-1,this.occlusionType=Rt.OCCLUSION_TYPE_NONE,this.occlusionQueryAlgorithmType=Rt.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE,this.forceRenderingWhenOccluded=!1}}st.prototype.createQuery=function(){return null};st.prototype.deleteQuery=function(a){return this};st.prototype.isQueryResultAvailable=function(a){return!1};st.prototype.getQueryResult=function(a){return 0};st.prototype.beginOcclusionQuery=function(a,e){return!1};st.prototype.endOcclusionQuery=function(a){return this};Object.defineProperty(Rt.prototype,"isOcclusionQueryInProgress",{get:function(){return this._occlusionDataStorage.isOcclusionQueryInProgress},set:function(a){this._occlusionDataStorage.isOcclusionQueryInProgress=a},enumerable:!1,configurable:!0});Object.defineProperty(Rt.prototype,"_occlusionDataStorage",{get:function(){return this.__occlusionDataStorage||(this.__occlusionDataStorage=new QD),this.__occlusionDataStorage},enumerable:!1,configurable:!0});Object.defineProperty(Rt.prototype,"isOccluded",{get:function(){return this._occlusionDataStorage.isOccluded},set:function(a){this._occlusionDataStorage.isOccluded=a},enumerable:!0,configurable:!0});Object.defineProperty(Rt.prototype,"occlusionQueryAlgorithmType",{get:function(){return this._occlusionDataStorage.occlusionQueryAlgorithmType},set:function(a){this._occlusionDataStorage.occlusionQueryAlgorithmType=a},enumerable:!0,configurable:!0});Object.defineProperty(Rt.prototype,"occlusionType",{get:function(){return this._occlusionDataStorage.occlusionType},set:function(a){this._occlusionDataStorage.occlusionType=a},enumerable:!0,configurable:!0});Object.defineProperty(Rt.prototype,"occlusionRetryCount",{get:function(){return this._occlusionDataStorage.occlusionRetryCount},set:function(a){this._occlusionDataStorage.occlusionRetryCount=a},enumerable:!0,configurable:!0});Object.defineProperty(Rt.prototype,"forceRenderingWhenOccluded",{get:function(){return this._occlusionDataStorage.forceRenderingWhenOccluded},set:function(a){this._occlusionDataStorage.forceRenderingWhenOccluded=a},enumerable:!0,configurable:!0});Rt.prototype._checkOcclusionQuery=function(){const a=this._occlusionDataStorage;if(a.occlusionType===Rt.OCCLUSION_TYPE_NONE)return a.isOccluded=!1,!1;const e=this.getEngine();if(!e.getCaps().supportOcclusionQuery||!e.isQueryResultAvailable)return a.isOccluded=!1,!1;if(this.isOcclusionQueryInProgress&&this._occlusionQuery!==null&&this._occlusionQuery!==void 0)if(e.isQueryResultAvailable(this._occlusionQuery)){const r=e.getQueryResult(this._occlusionQuery);a.isOcclusionQueryInProgress=!1,a.occlusionInternalRetryCounter=0,a.isOccluded=!(r>0)}else if(a.occlusionInternalRetryCounter++,a.occlusionRetryCount!==-1&&a.occlusionInternalRetryCounter>a.occlusionRetryCount)a.isOcclusionQueryInProgress=!1,a.occlusionInternalRetryCounter=0,a.isOccluded=a.occlusionType===Rt.OCCLUSION_TYPE_OPTIMISTIC?!1:a.isOccluded;else return a.occlusionType===Rt.OCCLUSION_TYPE_OPTIMISTIC?!1:a.isOccluded;const t=this.getScene();if(t.getBoundingBoxRenderer){const i=t.getBoundingBoxRenderer();this._occlusionQuery===null&&(this._occlusionQuery=e.createQuery()),this._occlusionQuery&&e.beginOcclusionQuery(a.occlusionQueryAlgorithmType,this._occlusionQuery)&&(i.renderOcclusionBoundingBox(this),e.endOcclusionQuery(a.occlusionQueryAlgorithmType),this._occlusionDataStorage.isOcclusionQueryInProgress=!0)}return a.isOccluded};class AW{}const x0=new j,S0=new j;Object.defineProperty(st.prototype,"onBeforeViewRenderObservable",{get:function(){return x0}});Object.defineProperty(st.prototype,"onAfterViewRenderObservable",{get:function(){return S0}});Object.defineProperty(st.prototype,"inputElement",{get:function(){return this._inputElement},set:function(a){var e;this._inputElement!==a&&(this._inputElement=a,(e=this._onEngineViewChanged)==null||e.call(this))}});st.prototype.getInputElement=function(){return this.inputElement||this.getRenderingCanvas()};st.prototype.registerView=function(a,e,t){this.views||(this.views=[]);for(const s of this.views)if(s.target===a)return s;const i=this.getRenderingCanvas();i&&(a.width=i.width,a.height=i.height);const r={target:a,camera:e,clearBeforeCopy:t,enabled:!0,id:(Math.random()*1e5).toFixed()};return this.views.push(r),e&&!Array.isArray(e)&&e.onDisposeObservable.add(()=>{this.unRegisterView(a)}),r};st.prototype.unRegisterView=function(a){if(!this.views||this.views.length===0)return this;for(const e of this.views)if(e.target===a){const t=this.views.indexOf(e);t!==-1&&this.views.splice(t,1);break}return this};st.prototype._renderViewStep=function(a){const e=a.target,t=e.getContext("2d");if(!t)return!0;const i=this.getRenderingCanvas();x0.notifyObservers(a);const r=a.camera;let s=null,n=null,o=null;if(r&&(o=Array.isArray(r)?r[0].getScene():r.getScene(),s=o.activeCamera,n=o.activeCameras,Array.isArray(r)?o.activeCameras=r:(o.activeCamera=r,o.activeCameras=null)),this.activeView=a,a.customResize)a.customResize(e);else{const l=Math.floor(e.clientWidth/this._hardwareScalingLevel),u=Math.floor(e.clientHeight/this._hardwareScalingLevel),c=l!==e.width||i.width!==e.width||u!==e.height||i.height!==e.height;e.clientWidth&&e.clientHeight&&c&&(e.width=l,e.height=u,this.setSize(l,u))}return!i.width||!i.height?!1:(this._renderFrame(),this.flushFramebuffer(),a.clearBeforeCopy&&t.clearRect(0,0,i.width,i.height),t.drawImage(i,0,0),o&&(o.activeCameras=n,o.activeCamera=s),S0.notifyObservers(a),!0)};st.prototype._renderViews=function(){if(!this.views||this.views.length===0||!this.getRenderingCanvas())return!1;let e;for(const t of this.views){if(!t.enabled)continue;if(t.target===this.inputElement){e=t;continue}if(!this._renderViewStep(t))return!1}return e&&!this._renderViewStep(e)?!1:(this.activeView=null,!0)};st.prototype._debugPushGroup=function(a,e){};st.prototype._debugPopGroup=function(a){};st.prototype._debugInsertMarker=function(a,e){};st.prototype._debugFlushPendingCommands=function(){};class v0{constructor(){this._timeElapsedQueryEnded=!1}}it.prototype.createQuery=function(){const a=this._gl.createQuery();if(!a)throw new Error("Unable to create Occlusion Query");return a};it.prototype.deleteQuery=function(a){return this._gl.deleteQuery(a),this};it.prototype.isQueryResultAvailable=function(a){return this._gl.getQueryParameter(a,this._gl.QUERY_RESULT_AVAILABLE)};it.prototype.getQueryResult=function(a){return this._gl.getQueryParameter(a,this._gl.QUERY_RESULT)};it.prototype.beginOcclusionQuery=function(a,e){const t=this._getGlAlgorithmType(a);return this._gl.beginQuery(t,e),!0};it.prototype.endOcclusionQuery=function(a){const e=this._getGlAlgorithmType(a);return this._gl.endQuery(e),this};it.prototype._createTimeQuery=function(){const a=this.getCaps().timerQuery;return a.createQueryEXT?a.createQueryEXT():this.createQuery()};it.prototype._deleteTimeQuery=function(a){const e=this.getCaps().timerQuery;if(e.deleteQueryEXT){e.deleteQueryEXT(a);return}this.deleteQuery(a)};it.prototype._getTimeQueryResult=function(a){const e=this.getCaps().timerQuery;return e.getQueryObjectEXT?e.getQueryObjectEXT(a,e.QUERY_RESULT_EXT):this.getQueryResult(a)};it.prototype._getTimeQueryAvailability=function(a){const e=this.getCaps().timerQuery;return e.getQueryObjectEXT?e.getQueryObjectEXT(a,e.QUERY_RESULT_AVAILABLE_EXT):this.isQueryResultAvailable(a)};it.prototype.startTimeQuery=function(){const a=this.getCaps(),e=a.timerQuery;if(!e)return null;const t=new v0;if(this._gl.getParameter(e.GPU_DISJOINT_EXT),a.canUseTimestampForTimerQuery)t._startTimeQuery=this._createTimeQuery(),t._startTimeQuery&&e.queryCounterEXT(t._startTimeQuery,e.TIMESTAMP_EXT);else{if(this._currentNonTimestampToken)return this._currentNonTimestampToken;t._timeElapsedQuery=this._createTimeQuery(),t._timeElapsedQuery&&(e.beginQueryEXT?e.beginQueryEXT(e.TIME_ELAPSED_EXT,t._timeElapsedQuery):this._gl.beginQuery(e.TIME_ELAPSED_EXT,t._timeElapsedQuery)),this._currentNonTimestampToken=t}return t};it.prototype.endTimeQuery=function(a){const e=this.getCaps(),t=e.timerQuery;if(!t||!a)return-1;if(e.canUseTimestampForTimerQuery){if(!a._startTimeQuery)return-1;a._endTimeQuery||(a._endTimeQuery=this._createTimeQuery(),a._endTimeQuery&&t.queryCounterEXT(a._endTimeQuery,t.TIMESTAMP_EXT))}else if(!a._timeElapsedQueryEnded){if(!a._timeElapsedQuery)return-1;t.endQueryEXT?t.endQueryEXT(t.TIME_ELAPSED_EXT):(this._gl.endQuery(t.TIME_ELAPSED_EXT),this._currentNonTimestampToken=null),a._timeElapsedQueryEnded=!0}const i=this._gl.getParameter(t.GPU_DISJOINT_EXT);let r=!1;if(a._endTimeQuery?r=this._getTimeQueryAvailability(a._endTimeQuery):a._timeElapsedQuery&&(r=this._getTimeQueryAvailability(a._timeElapsedQuery)),r&&!i){let s=0;if(e.canUseTimestampForTimerQuery){if(!a._startTimeQuery||!a._endTimeQuery)return-1;const n=this._getTimeQueryResult(a._startTimeQuery);s=this._getTimeQueryResult(a._endTimeQuery)-n,this._deleteTimeQuery(a._startTimeQuery),this._deleteTimeQuery(a._endTimeQuery),a._startTimeQuery=null,a._endTimeQuery=null}else{if(!a._timeElapsedQuery)return-1;s=this._getTimeQueryResult(a._timeElapsedQuery),this._deleteTimeQuery(a._timeElapsedQuery),a._timeElapsedQuery=null,a._timeElapsedQueryEnded=!1}return s}return-1};it.prototype.captureGPUFrameTime=function(a){if(a!==this._captureGPUFrameTime)if(this._captureGPUFrameTime=a,a){const e=this.getGPUFrameTimeCounter();this._onBeginFrameObserver=this.onBeginFrameObservable.add(()=>{this._gpuFrameTimeToken||(this._gpuFrameTimeToken=this.startTimeQuery())}),this._onEndFrameObserver=this.onEndFrameObservable.add(()=>{if(!this._gpuFrameTimeToken)return;const t=this.endTimeQuery(this._gpuFrameTimeToken);t>-1&&(this._gpuFrameTimeToken=null,e.fetchNewFrame(),e.addCount(t,!0))})}else this.onBeginFrameObservable.remove(this._onBeginFrameObserver),this._onBeginFrameObserver=null,this.onEndFrameObservable.remove(this._onEndFrameObserver),this._onEndFrameObserver=null};it.prototype._getGlAlgorithmType=function(a){return a===Rt.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE?this._gl.ANY_SAMPLES_PASSED_CONSERVATIVE:this._gl.ANY_SAMPLES_PASSED};var DW=!0;mt.prototype.createTransformFeedback=function(){const a=this._gl.createTransformFeedback();if(!a)throw new Error("Unable to create Transform Feedback");return a};mt.prototype.deleteTransformFeedback=function(a){this._gl.deleteTransformFeedback(a)};mt.prototype.bindTransformFeedback=function(a){this._gl.bindTransformFeedback(this._gl.TRANSFORM_FEEDBACK,a)};mt.prototype.beginTransformFeedback=function(a=!0){this._gl.beginTransformFeedback(a?this._gl.POINTS:this._gl.TRIANGLES)};mt.prototype.endTransformFeedback=function(){this._gl.endTransformFeedback()};mt.prototype.setTranformFeedbackVaryings=function(a,e){this._gl.transformFeedbackVaryings(a,e,this._gl.INTERLEAVED_ATTRIBS)};mt.prototype.bindTransformFeedbackBuffer=function(a){this._gl.bindBufferBase(this._gl.TRANSFORM_FEEDBACK_BUFFER,0,a?a.underlyingResource:null)};mt.prototype.readTransformFeedbackBuffer=function(a){this._gl.getBufferSubData(this._gl.TRANSFORM_FEEDBACK_BUFFER,0,a)};it.prototype.updateVideoTexture=function(a,e,t){if(!a||a._isDisabled)return;const i=this._getInternalFormat(a.format),r=this._getRGBABufferInternalSizedFormat(0,a.format),s=this._bindTextureDirectly(this._gl.TEXTURE_2D,a,!0);this._unpackFlipY(!t);try{if(this._videoTextureSupported===void 0&&(this._gl.getError(),this._gl.texImage2D(this._gl.TEXTURE_2D,0,r,i,this._gl.UNSIGNED_BYTE,e),this._gl.getError()!==0?this._videoTextureSupported=!1:this._videoTextureSupported=!0),this._videoTextureSupported)this._gl.texImage2D(this._gl.TEXTURE_2D,0,r,i,this._gl.UNSIGNED_BYTE,e);else{if(!a._workingCanvas){a._workingCanvas=this.createCanvas(a.width,a.height);const n=a._workingCanvas.getContext("2d");if(!n)throw new Error("Unable to get 2d context");a._workingContext=n,a._workingCanvas.width=a.width,a._workingCanvas.height=a.height}a._workingContext.clearRect(0,0,a.width,a.height),a._workingContext.drawImage(e,0,0,e.videoWidth,e.videoHeight,0,0,a.width,a.height),this._gl.texImage2D(this._gl.TEXTURE_2D,0,r,i,this._gl.UNSIGNED_BYTE,a._workingCanvas)}a.generateMipMaps&&this._gl.generateMipmap(this._gl.TEXTURE_2D),s||this._bindTextureDirectly(this._gl.TEXTURE_2D,null),a.isReady=!0}catch{a._isDisabled=!0}};it.prototype.restoreSingleAttachment=function(){const a=this._gl;this.bindAttachments([a.BACK])};it.prototype.restoreSingleAttachmentForRenderTarget=function(){const a=this._gl;this.bindAttachments([a.COLOR_ATTACHMENT0])};it.prototype.buildTextureLayout=function(a){const e=this._gl,t=[];for(let i=0;i<a.length;i++)a[i]?t.push(e["COLOR_ATTACHMENT"+i]):t.push(e.NONE);return t};it.prototype.bindAttachments=function(a){this._gl.drawBuffers(a)};it.prototype.unBindMultiColorAttachmentFramebuffer=function(a,e=!1,t){this._currentRenderTarget=null,a.disableAutomaticMSAAResolve||this.resolveMultiFramebuffer(a),e||this.generateMipMapsMultiFramebuffer(a),t&&(a._MSAAFramebuffer&&this._bindUnboundFramebuffer(a._framebuffer),t()),this._bindUnboundFramebuffer(null)};it.prototype.createMultipleRenderTarget=function(a,e,t=!0){let i=!1,r=!0,s=!1,n=!1,o,l=1,u=1;const c=0,h=3,d=!1,f=5,p=3553;let g=[],_=[],S=[],b=[],y=[],T=[],v=[],E=[],R=[],O=!1;const w=this._createHardwareRenderTargetWrapper(!0,!1,a);e!==void 0&&(i=e.generateMipMaps===void 0?!1:e.generateMipMaps,r=e.generateDepthBuffer===void 0?!0:e.generateDepthBuffer,s=e.generateStencilBuffer===void 0?!1:e.generateStencilBuffer,n=e.generateDepthTexture===void 0?!1:e.generateDepthTexture,l=e.textureCount??1,u=e.samples??u,g=e.types||g,_=e.samplingModes||_,S=e.useSRGBBuffers||S,b=e.formats||b,y=e.targetTypes||y,T=e.faceIndex||T,v=e.layerIndex||v,E=e.layerCounts||E,R=e.labels||R,O=e.dontCreateTextures??!1,this.webGLVersion>1&&(e.depthTextureFormat===13||e.depthTextureFormat===17||e.depthTextureFormat===16||e.depthTextureFormat===14||e.depthTextureFormat===18)&&(o=e.depthTextureFormat)),o===void 0&&(o=s?13:14);const M=this._gl,G=this._currentFramebuffer,H=M.createFramebuffer();this._bindUnboundFramebuffer(H);const q=a.width??a,X=a.height??a,ee=[],oe=[],_e=this.webGLVersion>1&&(o===13||o===17||o===18);w.label=(e==null?void 0:e.label)??"MultiRenderTargetWrapper",w._framebuffer=H,w._generateDepthBuffer=n||r,w._generateStencilBuffer=n?_e:s,w._depthStencilBuffer=this._setupFramebufferDepthAttachments(w._generateStencilBuffer,w._generateDepthBuffer,q,X,1,o),w._attachments=oe;for(let te=0;te<l;te++){let ie=_[te]||h,Z=g[te]||c,D=S[te]||d;const W=b[te]||f,K=y[te]||p,ue=E[te]??1;(Z===1&&!this._caps.textureFloatLinearFiltering||Z===2&&!this._caps.textureHalfFloatLinearFiltering)&&(ie=1);const ye=this._getSamplingParameters(ie,i);Z===1&&!this._caps.textureFloat&&(Z=0,L.Warn("Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type")),D=D&&this._caps.supportSRGBBuffers&&(this.webGLVersion>1||this.isWebGPU);const se=this.webGLVersion>1,ce=M[se?"COLOR_ATTACHMENT"+te:"COLOR_ATTACHMENT"+te+"_WEBGL"];if(oe.push(ce),K===-1||O)continue;const fe=new Dt(this,6);ee[te]=fe,M.activeTexture(M["TEXTURE"+te]),M.bindTexture(K,fe._hardwareTexture.underlyingResource),M.texParameteri(K,M.TEXTURE_MAG_FILTER,ye.mag),M.texParameteri(K,M.TEXTURE_MIN_FILTER,ye.min),M.texParameteri(K,M.TEXTURE_WRAP_S,M.CLAMP_TO_EDGE),M.texParameteri(K,M.TEXTURE_WRAP_T,M.CLAMP_TO_EDGE);const pe=this._getRGBABufferInternalSizedFormat(Z,W,D),Ie=this._getInternalFormat(W),vt=this._getWebGLTextureType(Z);if(se&&(K===35866||K===32879))K===35866?fe.is2DArray=!0:fe.is3D=!0,fe.baseDepth=fe.depth=ue,M.texImage3D(K,0,pe,q,X,ue,0,Ie,vt,null);else if(K===34067){for(let Se=0;Se<6;Se++)M.texImage2D(M.TEXTURE_CUBE_MAP_POSITIVE_X+Se,0,pe,q,X,0,Ie,vt,null);fe.isCube=!0}else M.texImage2D(M.TEXTURE_2D,0,pe,q,X,0,Ie,vt,null);i&&M.generateMipmap(K),this._bindTextureDirectly(K,null),fe.baseWidth=q,fe.baseHeight=X,fe.width=q,fe.height=X,fe.isReady=!0,fe.samples=1,fe.generateMipMaps=i,fe.samplingMode=ie,fe.type=Z,fe._useSRGBBuffer=D,fe.format=W,fe.label=R[te]??w.label+"-Texture"+te,this._internalTexturesCache.push(fe)}if(n&&this._caps.depthTextureExtension&&!O){const te=new Dt(this,14);let ie=5,Z=M.DEPTH_COMPONENT16,D=M.DEPTH_COMPONENT,W=M.UNSIGNED_SHORT,K=M.DEPTH_ATTACHMENT;this.webGLVersion<2?Z=M.DEPTH_COMPONENT:o===14?(ie=1,W=M.FLOAT,Z=M.DEPTH_COMPONENT32F):o===18?(ie=0,W=M.FLOAT_32_UNSIGNED_INT_24_8_REV,Z=M.DEPTH32F_STENCIL8,D=M.DEPTH_STENCIL,K=M.DEPTH_STENCIL_ATTACHMENT):o===16?(ie=0,W=M.UNSIGNED_INT,Z=M.DEPTH_COMPONENT24,K=M.DEPTH_ATTACHMENT):(o===13||o===17)&&(ie=12,W=M.UNSIGNED_INT_24_8,Z=M.DEPTH24_STENCIL8,D=M.DEPTH_STENCIL,K=M.DEPTH_STENCIL_ATTACHMENT),this._bindTextureDirectly(M.TEXTURE_2D,te,!0),M.texParameteri(M.TEXTURE_2D,M.TEXTURE_MAG_FILTER,M.NEAREST),M.texParameteri(M.TEXTURE_2D,M.TEXTURE_MIN_FILTER,M.NEAREST),M.texParameteri(M.TEXTURE_2D,M.TEXTURE_WRAP_S,M.CLAMP_TO_EDGE),M.texParameteri(M.TEXTURE_2D,M.TEXTURE_WRAP_T,M.CLAMP_TO_EDGE),M.texImage2D(M.TEXTURE_2D,0,Z,q,X,0,D,W,null),M.framebufferTexture2D(M.FRAMEBUFFER,K,M.TEXTURE_2D,te._hardwareTexture.underlyingResource,0),this._bindTextureDirectly(M.TEXTURE_2D,null),w._depthStencilTexture=te,w._depthStencilTextureWithStencil=_e,te.baseWidth=q,te.baseHeight=X,te.width=q,te.height=X,te.isReady=!0,te.samples=1,te.generateMipMaps=i,te.samplingMode=1,te.format=o,te.type=ie,te.label=w.label+"-DepthStencil",ee[l]=te,this._internalTexturesCache.push(te)}if(w.setTextures(ee),t&&M.drawBuffers(oe),this._bindUnboundFramebuffer(G),w.setLayerAndFaceIndices(v,T),this.resetTextureCache(),!O)this.updateMultipleRenderTargetTextureSampleCount(w,u,t);else if(u>1){const te=M.createFramebuffer();if(!te)throw new Error("Unable to create multi sampled framebuffer");w._samples=u,w._MSAAFramebuffer=te,l>0&&t&&(this._bindUnboundFramebuffer(te),M.drawBuffers(oe),this._bindUnboundFramebuffer(G))}return w};it.prototype.updateMultipleRenderTargetTextureSampleCount=function(a,e,t=!0){if(this.webGLVersion<2||!a)return 1;if(a.samples===e)return e;const i=this._gl;e=Math.min(e,this.getCaps().maxMSAASamples),a._depthStencilBuffer&&(i.deleteRenderbuffer(a._depthStencilBuffer),a._depthStencilBuffer=null),a._MSAAFramebuffer&&(i.deleteFramebuffer(a._MSAAFramebuffer),a._MSAAFramebuffer=null);const r=a._attachments.length;for(let n=0;n<r;n++){const l=a.textures[n]._hardwareTexture;l==null||l.releaseMSAARenderBuffers()}if(e>1&&typeof i.renderbufferStorageMultisample=="function"){const n=i.createFramebuffer();if(!n)throw new Error("Unable to create multi sampled framebuffer");a._MSAAFramebuffer=n,this._bindUnboundFramebuffer(n);const o=[];for(let l=0;l<r;l++){const u=a.textures[l],c=u._hardwareTexture,h=i[this.webGLVersion>1?"COLOR_ATTACHMENT"+l:"COLOR_ATTACHMENT"+l+"_WEBGL"],d=this._createRenderBuffer(u.width,u.height,e,-1,this._getRGBABufferInternalSizedFormat(u.type,u.format,u._useSRGBBuffer),h);if(!d)throw new Error("Unable to create multi sampled framebuffer");c.addMSAARenderBuffer(d),u.samples=e,o.push(h)}t&&i.drawBuffers(o)}else this._bindUnboundFramebuffer(a._framebuffer);const s=a._depthStencilTexture?a._depthStencilTexture.format:void 0;return a._depthStencilBuffer=this._setupFramebufferDepthAttachments(a._generateStencilBuffer,a._generateDepthBuffer,a.width,a.height,e,s),this._bindUnboundFramebuffer(null),a._samples=e,e};it.prototype.generateMipMapsMultiFramebuffer=function(a){const e=a,t=this._gl;if(e.isMulti)for(let i=0;i<e._attachments.length;i++){const r=e.textures[i];r!=null&&r.generateMipMaps&&!(r!=null&&r.isCube)&&!(r!=null&&r.is3D)&&(this._bindTextureDirectly(t.TEXTURE_2D,r,!0),t.generateMipmap(t.TEXTURE_2D),this._bindTextureDirectly(t.TEXTURE_2D,null))}};it.prototype.resolveMultiFramebuffer=function(a){const e=a,t=this._gl;if(!e._MSAAFramebuffer||!e.isMulti)return;let i=e.resolveMSAAColors?t.COLOR_BUFFER_BIT:0;i|=e._generateDepthBuffer&&e.resolveMSAADepth?t.DEPTH_BUFFER_BIT:0,i|=e._generateStencilBuffer&&e.resolveMSAAStencil?t.STENCIL_BUFFER_BIT:0;const r=e._attachments,s=r.length;t.bindFramebuffer(t.READ_FRAMEBUFFER,e._MSAAFramebuffer),t.bindFramebuffer(t.DRAW_FRAMEBUFFER,e._framebuffer);for(let n=0;n<s;n++){const o=e.textures[n];for(let l=0;l<s;l++)r[l]=t.NONE;r[n]=t[this.webGLVersion>1?"COLOR_ATTACHMENT"+n:"COLOR_ATTACHMENT"+n+"_WEBGL"],t.readBuffer(r[n]),t.drawBuffers(r),t.blitFramebuffer(0,0,o.width,o.height,0,0,o.width,o.height,i,t.NEAREST)}for(let n=0;n<s;n++)r[n]=t[this.webGLVersion>1?"COLOR_ATTACHMENT"+n:"COLOR_ATTACHMENT"+n+"_WEBGL"];t.drawBuffers(r),t.bindFramebuffer(this._gl.FRAMEBUFFER,e._MSAAFramebuffer)};var $g;(function(a){a[a.Texture=0]="Texture",a[a.StorageTexture=1]="StorageTexture",a[a.UniformBuffer=2]="UniformBuffer",a[a.StorageBuffer=3]="StorageBuffer",a[a.TextureWithoutSampler=4]="TextureWithoutSampler",a[a.Sampler=5]="Sampler",a[a.ExternalTexture=6]="ExternalTexture",a[a.DataBuffer=7]="DataBuffer"})($g||($g={}));it.prototype.createComputeEffect=function(a,e){throw new Error("createComputeEffect: This engine does not support compute shaders!")};it.prototype.createComputePipelineContext=function(){throw new Error("createComputePipelineContext: This engine does not support compute shaders!")};it.prototype.createComputeContext=function(){};it.prototype.computeDispatch=function(a,e,t,i,r,s,n){throw new Error("computeDispatch: This engine does not support compute shaders!")};it.prototype.computeDispatchIndirect=function(a,e,t,i,r,s){throw new Error("computeDispatchIndirect: This engine does not support compute shaders!")};it.prototype.areAllComputeEffectsReady=function(){return!0};it.prototype.releaseComputeEffects=function(){};it.prototype._prepareComputePipelineContext=function(a,e,t,i,r){};it.prototype._rebuildComputeEffects=function(){};st.prototype._executeWhenComputeStateIsCompiled=function(a,e){e(null)};it.prototype._releaseComputeEffect=function(a){};it.prototype._deleteComputePipelineContext=function(a){};function KD(a){const e=s=>{const n="\\b"+s+"\\b";return a&&(a===s||a.match(new RegExp(n,"g")))};if(this._excludedCompressedTextures&&this._excludedCompressedTextures.some(e))return a;const t=a.lastIndexOf("."),i=a.lastIndexOf("?"),r=i>-1?a.substring(i,a.length):"";return(t>-1?a.substring(0,t):a)+this._textureFormatInUse+r}Object.defineProperty(mt.prototype,"texturesSupported",{get:function(){const a=[];return this._caps.astc&&a.push("-astc.ktx"),this._caps.s3tc&&a.push("-dxt.ktx"),this._caps.pvrtc&&a.push("-pvrtc.ktx"),this._caps.etc2&&a.push("-etc2.ktx"),this._caps.etc1&&a.push("-etc1.ktx"),a},enumerable:!0,configurable:!0});Object.defineProperty(mt.prototype,"textureFormatInUse",{get:function(){return this._textureFormatInUse||null},enumerable:!0,configurable:!0});mt.prototype.setCompressedTextureExclusions=function(a){this._excludedCompressedTextures=a};mt.prototype.setTextureFormatToUse=function(a){const e=this.texturesSupported;for(let t=0,i=e.length;t<i;t++)for(let r=0,s=a.length;r<s;r++)if(e[t]===a[r].toLowerCase())return this._transformTextureUrl=KD.bind(this),this._textureFormatInUse=e[t];return this._textureFormatInUse="",this._transformTextureUrl=null,null};class Un{constructor(){const e=new ArrayBuffer(Un.DEFAULT_BUFFER_SIZE);this._uint32s=new Uint32Array(e),this._int32s=new Int32Array(e),this._float32s=new Float32Array(e),this._length=Un.DEFAULT_BUFFER_SIZE/4,this._position=0,this._nativeDataStream=new _native.NativeDataStream(()=>{this._flush()})}writeUint32(e){this._flushIfNecessary(1),this._uint32s[this._position++]=e}writeInt32(e){this._flushIfNecessary(1),this._int32s[this._position++]=e}writeFloat32(e){this._flushIfNecessary(1),this._float32s[this._position++]=e}writeUint32Array(e){this._flushIfNecessary(1+e.length),this._uint32s[this._position++]=e.length,this._uint32s.set(e,this._position),this._position+=e.length}writeInt32Array(e){this._flushIfNecessary(1+e.length),this._uint32s[this._position++]=e.length,this._int32s.set(e,this._position),this._position+=e.length}writeFloat32Array(e){this._flushIfNecessary(1+e.length),this._uint32s[this._position++]=e.length,this._float32s.set(e,this._position),this._position+=e.length}writeNativeData(e){this._flushIfNecessary(e.length),this._uint32s.set(e,this._position),this._position+=e.length}writeBoolean(e){this.writeUint32(e?1:0)}_flushIfNecessary(e){this._position+e>this._length&&this._flush()}_flush(){this._nativeDataStream.writeBuffer(this._uint32s.buffer,this._position),this._position=0}}Un.DEFAULT_BUFFER_SIZE=65536;function Rl(a,e,t,i){let r=i,s=0,n="";for(;r<t.length;){const o=t.charAt(r);if(n)o===n?n==='"'||n==="'"?t.charAt(r-1)!=="\\"&&(n=""):n="":n==="*/"&&o==="*"&&r+1<t.length&&(t.charAt(r+1)==="/"&&(n=""),n===""&&r++);else switch(o){case a:s++;break;case e:s--;break;case'"':case"'":case"`":n=o;break;case"/":if(r+1<t.length){const l=t.charAt(r+1);l==="/"?n=`
`:l==="*"&&(n="*/")}break}if(r++,s===0)break}return s===0?r-1:-1}function Hg(a,e){for(;e<a.length;){const t=a[e];if(t!==" "&&t!==`
`&&t!=="\r"&&t!=="	"&&t!==`
`&&t!=="")break;e++}return e}function Oc(a){const e=a.charCodeAt(0);return e>=48&&e<=57||e>=65&&e<=90||e>=97&&e<=122||e==95}function ah(a){let e=0,t="",i=!1;const r=[];for(;e<a.length;){const s=a.charAt(e);if(t)s===t?t==='"'||t==="'"?(a.charAt(e-1)!=="\\"&&(t=""),r.push(s)):(t="",i=!1):t==="*/"&&s==="*"&&e+1<a.length?(a.charAt(e+1)==="/"&&(t=""),t===""&&(i=!1,e++)):i||r.push(s);else{switch(s){case'"':case"'":case"`":t=s;break;case"/":if(e+1<a.length){const n=a.charAt(e+1);n==="/"?(t=`
`,i=!0):n==="*"&&(t="*/",i=!0)}break}i||r.push(s)}e++}return r.join("")}function JD(a,e,t,i){for(;e>=0&&a.charAt(e)!==t&&a.charAt(e)!==i;)e--;return e}function eO(a){return a.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function jl(a,e,t,i){let r=a.indexOf(e);if(r<0)return a;if(t){for(;r++<a.length&&a.charAt(r)!="{";);if(r<a.length){const s=a.substring(0,r+1),n=a.substring(r+1);a=s+t+n}}if(i){const s=a.lastIndexOf("}");a=a.substring(0,s),a+=i+`
}`}return a}class Bn{get code(){return this._sourceCode}constructor(e,t=20){this.debug=!1,this._sourceCode=e,this._numMaxIterations=t,this._functionDescr=[],this.inlineToken="#define inline"}processCode(){this.debug&&L.Log(`Start inlining process (code size=${this._sourceCode.length})...`),this._collectFunctions(),this._processInlining(this._numMaxIterations),this.debug&&L.Log("End of inlining process.")}_collectFunctions(){let e=0;for(;e<this._sourceCode.length;){const t=this._sourceCode.indexOf(this.inlineToken,e);if(t<0)break;const i=this._sourceCode.indexOf("(",t+this.inlineToken.length);if(i<0){this.debug&&L.Warn(`Could not find the opening parenthesis after the token. startIndex=${e}`),e=t+this.inlineToken.length;continue}const r=Bn._RegexpFindFunctionNameAndType.exec(this._sourceCode.substring(t+this.inlineToken.length,i));if(!r){this.debug&&L.Warn(`Could not extract the name/type of the function from: ${this._sourceCode.substring(t+this.inlineToken.length,i)}`),e=t+this.inlineToken.length;continue}const[s,n]=[r[3],r[4]],o=Rl("(",")",this._sourceCode,i);if(o<0){this.debug&&L.Warn(`Could not extract the parameters the function '${n}' (type=${s}). funcParamsStartIndex=${i}`),e=t+this.inlineToken.length;continue}const l=this._sourceCode.substring(i+1,o),u=Hg(this._sourceCode,o+1);if(u===this._sourceCode.length){this.debug&&L.Warn(`Could not extract the body of the function '${n}' (type=${s}). funcParamsEndIndex=${o}`),e=t+this.inlineToken.length;continue}const c=Rl("{","}",this._sourceCode,u);if(c<0){this.debug&&L.Warn(`Could not extract the body of the function '${n}' (type=${s}). funcBodyStartIndex=${u}`),e=t+this.inlineToken.length;continue}const h=this._sourceCode.substring(u,c+1),d=ah(l).split(","),f=[];for(let _=0;_<d.length;++_){const S=d[_].trim(),b=S.lastIndexOf(" ");b>=0&&f.push(S.substring(b+1))}s!=="void"&&f.push("return"),this._functionDescr.push({name:n,type:s,parameters:f,body:h,callIndex:0}),e=c+1;const p=t>0?this._sourceCode.substring(0,t):"",g=c+1<this._sourceCode.length-1?this._sourceCode.substring(c+1):"";this._sourceCode=p+g,e-=c+1-t}this.debug&&L.Log(`Collect functions: ${this._functionDescr.length} functions found. functionDescr=${this._functionDescr}`)}_processInlining(e=20){for(;e-->=0&&this._replaceFunctionCallsByCode(););return this.debug&&L.Log(`numMaxIterations is ${e} after inlining process`),e>=0}_replaceFunctionCallsByCode(){let e=!1;for(const t of this._functionDescr){const{name:i,type:r,parameters:s,body:n}=t;let o=0;for(;o<this._sourceCode.length;){const l=this._sourceCode.indexOf(i,o);if(l<0)break;if(l===0||Oc(this._sourceCode.charAt(l-1))){o=l+i.length;continue}const u=Hg(this._sourceCode,l+i.length);if(u===this._sourceCode.length||this._sourceCode.charAt(u)!=="("){o=l+i.length;continue}const c=Rl("(",")",this._sourceCode,u);if(c<0){this.debug&&L.Warn(`Could not extract the parameters of the function call. Function '${i}' (type=${r}). callParamsStartIndex=${u}`),o=l+i.length;continue}const h=this._sourceCode.substring(u+1,c),f=(y=>{const T=[];let v=0,E=0;for(;v<y.length;){if(y.charAt(v)==="("){const R=Rl("(",")",y,v);if(R<0)return null;v=R}else y.charAt(v)===","&&(T.push(y.substring(E,v)),E=v+1);v++}return E<v&&T.push(y.substring(E,v)),T})(ah(h));if(f===null){this.debug&&L.Warn(`Invalid function call: can't extract the parameters of the function call. Function '${i}' (type=${r}). callParamsStartIndex=${u}, callParams=`+h),o=l+i.length;continue}const p=[];for(let y=0;y<f.length;++y){const T=f[y].trim();p.push(T)}const g=r!=="void"?i+"_"+t.callIndex++:null;if(g&&p.push(g+" ="),p.length!==s.length){this.debug&&L.Warn(`Invalid function call: not the same number of parameters for the call than the number expected by the function. Function '${i}' (type=${r}). function parameters=${s}, call parameters=${p}`),o=l+i.length;continue}o=c+1;const _=this._replaceNames(n,s,p);let S=l>0?this._sourceCode.substring(0,l):"";const b=c+1<this._sourceCode.length-1?this._sourceCode.substring(c+1):"";if(g){const y=JD(this._sourceCode,l-1,`
`,"{");S=this._sourceCode.substring(0,y+1);const T=this._sourceCode.substring(y+1,l);this._sourceCode=S+r+" "+g+`;
`+_+`
`+T+g+b,this.debug&&L.Log(`Replace function call by code. Function '${i}' (type=${r}). injectDeclarationIndex=${y}, call parameters=${p}`)}else this._sourceCode=S+_+b,o+=_.length-(c+1-l),this.debug&&L.Log(`Replace function call by code. Function '${i}' (type=${r}). functionCallIndex=${l}, call parameters=${p}`);e=!0}}return e}_replaceNames(e,t,i){for(let r=0;r<t.length;++r){const s=new RegExp(eO(t[r]),"g"),n=t[r].length,o=i[r];e=e.replace(s,(l,...u)=>{const c=u[0];return Oc(e.charAt(c-1))||Oc(e.charAt(c+n))?t[r]:o})}return e}}Bn._RegexpFindFunctionNameAndType=/((\s+?)(\w+)\s+(\w+)\s*?)$/;const tO=/(flat\s)?\s*varying\s*.*/;class iO{constructor(){this.shaderLanguage=0}initializeShaders(e){this._nativeProcessingContext=e,this._nativeProcessingContext&&(this._nativeProcessingContext.remappedAttributeNames={},this._nativeProcessingContext.injectInVertexMain="")}attributeProcessor(e){if(!this._nativeProcessingContext)return e.replace("attribute","in");const i=/\s*(?:attribute|in)\s+(\S+)\s+(\S+)\s*;/gm.exec(e);if(i!==null){const r=i[1],s=i[2],n=this._nativeProcessingContext.vertexBufferKindToNumberOfComponents[s];if(n!==void 0){const o=n<0?n===-1?"int":"ivec"+-n:n===1?"uint":"uvec"+n,l=`_int_${s}_`;e=e.replace(i[0],`in ${o} ${l}; ${r} ${s};`),this._nativeProcessingContext.injectInVertexMain+=`${s} = ${r}(${l});
`,this._nativeProcessingContext.remappedAttributeNames[s]=l}else e=e.replace(i[0],`in ${r} ${s};`)}return e}varyingCheck(e,t){return tO.test(e)}varyingProcessor(e,t){return e.replace("varying",t?"in":"out")}postProcessor(e,t,i){var n;const r=e.search(/#extension.+GL_EXT_draw_buffers.+require/)!==-1,s=/#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;if(e=e.replace(s,""),e=e.replace(/texture2D\s*\(/g,"texture("),i){const o=e.search(/layout *\(location *= *0\) *out/g)!==-1;e=e.replace(/texture2DLodEXT\s*\(/g,"textureLod("),e=e.replace(/textureCubeLodEXT\s*\(/g,"textureLod("),e=e.replace(/textureCube\s*\(/g,"texture("),e=e.replace(/gl_FragDepthEXT/g,"gl_FragDepth"),e=e.replace(/gl_FragColor/g,"glFragColor"),e=e.replace(/gl_FragData/g,"glFragData"),e=e.replace(/void\s+?main\s*\(/g,(r||o?"":`layout(location = 0) out vec4 glFragColor;
`)+"void main(")}else if((n=this._nativeProcessingContext)!=null&&n.injectInVertexMain&&(e=jl(e,"void main",this._nativeProcessingContext.injectInVertexMain)),t.indexOf("#define MULTIVIEW")!==-1)return`#extension GL_OVR_multiview2 : require
layout (num_views = 2) in;
`+e;return e}}class rO{get isReady(){if(this.compilationError){const e=this.compilationError.message;throw new Error("SHADER ERROR"+(typeof e=="string"?`
`+e:""))}return this.isCompiled}_getVertexShaderCode(){return null}_getFragmentShaderCode(){return null}constructor(e,t,i){this.isCompiled=!1,this.vertexBufferKindToType={},this._valueCache={},this._engine=e,this.isAsync=t,this.shaderProcessingContext=i}_fillEffectInformation(e,t,i,r,s,n,o,l){const u=this._engine;if(u.supportsUniformBuffers)for(const d in t)e.bindUniformBlock(d,t[d]);this._engine.getUniforms(this,i).forEach((d,f)=>{r[i[f]]=d}),this._uniforms=r;let h;for(h=0;h<s.length;h++)e.getUniform(s[h])==null&&(s.splice(h,1),h--);s.forEach((d,f)=>{n[d]=f}),l.push(...u.getAttributes(this,o))}setEngine(e){this._engine=e}dispose(){this._uniforms={}}_cacheMatrix(e,t){const i=this._valueCache[e],r=t.updateFlag;return i!==void 0&&i===r?!1:(this._valueCache[e]=r,!0)}_cacheFloat2(e,t,i){let r=this._valueCache[e];if(!r)return r=[t,i],this._valueCache[e]=r,!0;let s=!1;return r[0]!==t&&(r[0]=t,s=!0),r[1]!==i&&(r[1]=i,s=!0),s}_cacheFloat3(e,t,i,r){let s=this._valueCache[e];if(!s)return s=[t,i,r],this._valueCache[e]=s,!0;let n=!1;return s[0]!==t&&(s[0]=t,n=!0),s[1]!==i&&(s[1]=i,n=!0),s[2]!==r&&(s[2]=r,n=!0),n}_cacheFloat4(e,t,i,r,s){let n=this._valueCache[e];if(!n)return n=[t,i,r,s],this._valueCache[e]=n,!0;let o=!1;return n[0]!==t&&(n[0]=t,o=!0),n[1]!==i&&(n[1]=i,o=!0),n[2]!==r&&(n[2]=r,o=!0),n[3]!==s&&(n[3]=s,o=!0),o}setInt(e,t){const i=this._valueCache[e];i!==void 0&&i===t||this._engine.setInt(this._uniforms[e],t)&&(this._valueCache[e]=t)}setInt2(e,t,i){this._cacheFloat2(e,t,i)&&(this._engine.setInt2(this._uniforms[e],t,i)||(this._valueCache[e]=null))}setInt3(e,t,i,r){this._cacheFloat3(e,t,i,r)&&(this._engine.setInt3(this._uniforms[e],t,i,r)||(this._valueCache[e]=null))}setInt4(e,t,i,r,s){this._cacheFloat4(e,t,i,r,s)&&(this._engine.setInt4(this._uniforms[e],t,i,r,s)||(this._valueCache[e]=null))}setIntArray(e,t){this._valueCache[e]=null,this._engine.setIntArray(this._uniforms[e],t)}setIntArray2(e,t){this._valueCache[e]=null,this._engine.setIntArray2(this._uniforms[e],t)}setIntArray3(e,t){this._valueCache[e]=null,this._engine.setIntArray3(this._uniforms[e],t)}setIntArray4(e,t){this._valueCache[e]=null,this._engine.setIntArray4(this._uniforms[e],t)}setUInt(e,t){const i=this._valueCache[e];i!==void 0&&i===t||this._engine.setUInt(this._uniforms[e],t)&&(this._valueCache[e]=t)}setUInt2(e,t,i){this._cacheFloat2(e,t,i)&&(this._engine.setUInt2(this._uniforms[e],t,i)||(this._valueCache[e]=null))}setUInt3(e,t,i,r){this._cacheFloat3(e,t,i,r)&&(this._engine.setUInt3(this._uniforms[e],t,i,r)||(this._valueCache[e]=null))}setUInt4(e,t,i,r,s){this._cacheFloat4(e,t,i,r,s)&&(this._engine.setUInt4(this._uniforms[e],t,i,r,s)||(this._valueCache[e]=null))}setUIntArray(e,t){this._valueCache[e]=null,this._engine.setUIntArray(this._uniforms[e],t)}setUIntArray2(e,t){this._valueCache[e]=null,this._engine.setUIntArray2(this._uniforms[e],t)}setUIntArray3(e,t){this._valueCache[e]=null,this._engine.setUIntArray3(this._uniforms[e],t)}setUIntArray4(e,t){this._valueCache[e]=null,this._engine.setUIntArray4(this._uniforms[e],t)}setFloatArray(e,t){this._valueCache[e]=null,this._engine.setFloatArray(this._uniforms[e],t)}setFloatArray2(e,t){this._valueCache[e]=null,this._engine.setFloatArray2(this._uniforms[e],t)}setFloatArray3(e,t){this._valueCache[e]=null,this._engine.setFloatArray3(this._uniforms[e],t)}setFloatArray4(e,t){this._valueCache[e]=null,this._engine.setFloatArray4(this._uniforms[e],t)}setArray(e,t){this._valueCache[e]=null,this._engine.setArray(this._uniforms[e],t)}setArray2(e,t){this._valueCache[e]=null,this._engine.setArray2(this._uniforms[e],t)}setArray3(e,t){this._valueCache[e]=null,this._engine.setArray3(this._uniforms[e],t)}setArray4(e,t){this._valueCache[e]=null,this._engine.setArray4(this._uniforms[e],t)}setMatrices(e,t){t&&(this._valueCache[e]=null,this._engine.setMatrices(this._uniforms[e],t))}setMatrix(e,t){this._cacheMatrix(e,t)&&(this._engine.setMatrices(this._uniforms[e],t.asArray())||(this._valueCache[e]=null))}setMatrix3x3(e,t){this._valueCache[e]=null,this._engine.setMatrix3x3(this._uniforms[e],t)}setMatrix2x2(e,t){this._valueCache[e]=null,this._engine.setMatrix2x2(this._uniforms[e],t)}setFloat(e,t){const i=this._valueCache[e];i!==void 0&&i===t||this._engine.setFloat(this._uniforms[e],t)&&(this._valueCache[e]=t)}setBool(e,t){const i=this._valueCache[e];i!==void 0&&i===t||this._engine.setInt(this._uniforms[e],t?1:0)&&(this._valueCache[e]=t?1:0)}setVector2(e,t){this._cacheFloat2(e,t.x,t.y)&&(this._engine.setFloat2(this._uniforms[e],t.x,t.y)||(this._valueCache[e]=null))}setFloat2(e,t,i){this._cacheFloat2(e,t,i)&&(this._engine.setFloat2(this._uniforms[e],t,i)||(this._valueCache[e]=null))}setVector3(e,t){this._cacheFloat3(e,t.x,t.y,t.z)&&(this._engine.setFloat3(this._uniforms[e],t.x,t.y,t.z)||(this._valueCache[e]=null))}setFloat3(e,t,i,r){this._cacheFloat3(e,t,i,r)&&(this._engine.setFloat3(this._uniforms[e],t,i,r)||(this._valueCache[e]=null))}setVector4(e,t){this._cacheFloat4(e,t.x,t.y,t.z,t.w)&&(this._engine.setFloat4(this._uniforms[e],t.x,t.y,t.z,t.w)||(this._valueCache[e]=null))}setQuaternion(e,t){this._cacheFloat4(e,t.x,t.y,t.z,t.w)&&(this._engine.setFloat4(this._uniforms[e],t.x,t.y,t.z,t.w)||(this._valueCache[e]=null))}setFloat4(e,t,i,r,s){this._cacheFloat4(e,t,i,r,s)&&(this._engine.setFloat4(this._uniforms[e],t,i,r,s)||(this._valueCache[e]=null))}setColor3(e,t){this._cacheFloat3(e,t.r,t.g,t.b)&&(this._engine.setFloat3(this._uniforms[e],t.r,t.g,t.b)||(this._valueCache[e]=null))}setColor4(e,t,i){this._cacheFloat4(e,t.r,t.g,t.b,i)&&(this._engine.setFloat4(this._uniforms[e],t.r,t.g,t.b,i)||(this._valueCache[e]=null))}setDirectColor4(e,t){this._cacheFloat4(e,t.r,t.g,t.b,t.a)&&(this._engine.setFloat4(this._uniforms[e],t.r,t.g,t.b,t.a)||(this._valueCache[e]=null))}}class sO extends iy{get _framebuffer(){return this.__framebuffer}set _framebuffer(e){this.__framebuffer&&this._engine._releaseFramebufferObjects(this.__framebuffer),this.__framebuffer=e}get _framebufferDepthStencil(){return this.__framebufferDepthStencil}set _framebufferDepthStencil(e){this.__framebufferDepthStencil&&this._engine._releaseFramebufferObjects(this.__framebufferDepthStencil),this.__framebufferDepthStencil=e}constructor(e,t,i,r){super(e,t,i,r),this.__framebuffer=null,this.__framebufferDepthStencil=null,this._engine=r}dispose(e=!1){this._framebuffer=null,this._framebufferDepthStencil=null,super.dispose(e)}}class jg{get underlyingResource(){return this._nativeTexture}constructor(e,t){this._engine=t,this.set(e)}setUsage(){}set(e){this._nativeTexture=e}reset(){this._nativeTexture=null}release(){this._nativeTexture&&this._engine.deleteTexture(this._nativeTexture),this.reset()}}function wc(a,e){switch(a){case 15:return _native.Engine.TEXTURE_FORMAT_D16;case 16:return _native.Engine.TEXTURE_FORMAT_D24;case 13:return _native.Engine.TEXTURE_FORMAT_D24S8;case 14:return _native.Engine.TEXTURE_FORMAT_D32F;case 36492:return _native.Engine.TEXTURE_FORMAT_BC7;case 36494:return _native.Engine.TEXTURE_FORMAT_BC6H;case 33779:return _native.Engine.TEXTURE_FORMAT_BC3;case 33778:return _native.Engine.TEXTURE_FORMAT_BC2;case 33777:return _native.Engine.TEXTURE_FORMAT_BC1;case 33776:return _native.Engine.TEXTURE_FORMAT_BC1;case 37808:return _native.Engine.TEXTURE_FORMAT_ASTC4x4;case 36196:return _native.Engine.TEXTURE_FORMAT_ETC1;case 37492:return _native.Engine.TEXTURE_FORMAT_ETC2;case 37496:return _native.Engine.TEXTURE_FORMAT_ETC2A;case 4:{switch(e){case 0:return _native.Engine.TEXTURE_FORMAT_RGB8;case 3:return _native.Engine.TEXTURE_FORMAT_RGB8S;case 6:return _native.Engine.TEXTURE_FORMAT_RGB8I;case 7:return _native.Engine.TEXTURE_FORMAT_RGB8U}break}case 5:{switch(e){case 0:return _native.Engine.TEXTURE_FORMAT_RGBA8;case 1:return _native.Engine.TEXTURE_FORMAT_RGBA32F;case 2:return _native.Engine.TEXTURE_FORMAT_RGBA16F;case 3:return _native.Engine.TEXTURE_FORMAT_RGBA8S;case 4:return _native.Engine.TEXTURE_FORMAT_RGBA16I;case 5:return _native.Engine.TEXTURE_FORMAT_RGBA16U;case 6:return _native.Engine.TEXTURE_FORMAT_RGBA32I;case 7:return _native.Engine.TEXTURE_FORMAT_RGBA32U}break}case 6:{switch(e){case 0:return _native.Engine.TEXTURE_FORMAT_R8;case 1:return _native.Engine.TEXTURE_FORMAT_R32F;case 2:return _native.Engine.TEXTURE_FORMAT_R16F;case 3:return _native.Engine.TEXTURE_FORMAT_R8S;case 4:return _native.Engine.TEXTURE_FORMAT_R16S;case 5:return _native.Engine.TEXTURE_FORMAT_R16U;case 6:return _native.Engine.TEXTURE_FORMAT_R32I;case 7:return _native.Engine.TEXTURE_FORMAT_R32U}break}case 7:{switch(e){case 0:return _native.Engine.TEXTURE_FORMAT_RG8;case 1:return _native.Engine.TEXTURE_FORMAT_RG32F;case 2:return _native.Engine.TEXTURE_FORMAT_RG16F;case 3:return _native.Engine.TEXTURE_FORMAT_RG8S;case 4:return _native.Engine.TEXTURE_FORMAT_RG16S;case 5:return _native.Engine.TEXTURE_FORMAT_RG16U;case 6:return _native.Engine.TEXTURE_FORMAT_RG32I;case 7:return _native.Engine.TEXTURE_FORMAT_RG32U}break}case 12:{switch(e){case 0:return _native.Engine.TEXTURE_FORMAT_BGRA8}break}}throw new LR(`Unsupported texture format or type: format ${a}, type ${e}.`,BR.UnsupportedTextureError)}function _o(a){switch(a){case 1:return _native.Engine.TEXTURE_NEAREST_NEAREST;case 2:return _native.Engine.TEXTURE_LINEAR_LINEAR;case 3:return _native.Engine.TEXTURE_LINEAR_LINEAR_MIPLINEAR;case 4:return _native.Engine.TEXTURE_NEAREST_NEAREST_MIPNEAREST;case 5:return _native.Engine.TEXTURE_NEAREST_LINEAR_MIPNEAREST;case 6:return _native.Engine.TEXTURE_NEAREST_LINEAR_MIPLINEAR;case 7:return _native.Engine.TEXTURE_NEAREST_LINEAR;case 8:return _native.Engine.TEXTURE_NEAREST_NEAREST_MIPLINEAR;case 9:return _native.Engine.TEXTURE_LINEAR_NEAREST_MIPNEAREST;case 10:return _native.Engine.TEXTURE_LINEAR_NEAREST_MIPLINEAR;case 11:return _native.Engine.TEXTURE_LINEAR_LINEAR_MIPNEAREST;case 12:return _native.Engine.TEXTURE_LINEAR_NEAREST;default:throw new Error(`Unsupported sampling mode: ${a}.`)}}function Nc(a){switch(a){case 1:return _native.Engine.ADDRESS_MODE_WRAP;case 0:return _native.Engine.ADDRESS_MODE_CLAMP;case 2:return _native.Engine.ADDRESS_MODE_MIRROR;default:throw new Error("Unexpected wrap mode: "+a+".")}}function nO(a){switch(a){case 513:return _native.Engine.STENCIL_TEST_LESS;case 515:return _native.Engine.STENCIL_TEST_LEQUAL;case 514:return _native.Engine.STENCIL_TEST_EQUAL;case 518:return _native.Engine.STENCIL_TEST_GEQUAL;case 516:return _native.Engine.STENCIL_TEST_GREATER;case 517:return _native.Engine.STENCIL_TEST_NOTEQUAL;case 512:return _native.Engine.STENCIL_TEST_NEVER;case 519:return _native.Engine.STENCIL_TEST_ALWAYS;default:throw new Error(`Unsupported stencil func mode: ${a}.`)}}function aO(a){switch(a){case 7680:return _native.Engine.STENCIL_OP_FAIL_S_KEEP;case 0:return _native.Engine.STENCIL_OP_FAIL_S_ZERO;case 7681:return _native.Engine.STENCIL_OP_FAIL_S_REPLACE;case 7682:return _native.Engine.STENCIL_OP_FAIL_S_INCR;case 7683:return _native.Engine.STENCIL_OP_FAIL_S_DECR;case 5386:return _native.Engine.STENCIL_OP_FAIL_S_INVERT;case 34055:return _native.Engine.STENCIL_OP_FAIL_S_INCRSAT;case 34056:return _native.Engine.STENCIL_OP_FAIL_S_DECRSAT;default:throw new Error(`Unsupported stencil OpFail mode: ${a}.`)}}function oO(a){switch(a){case 7680:return _native.Engine.STENCIL_OP_FAIL_Z_KEEP;case 0:return _native.Engine.STENCIL_OP_FAIL_Z_ZERO;case 7681:return _native.Engine.STENCIL_OP_FAIL_Z_REPLACE;case 7682:return _native.Engine.STENCIL_OP_FAIL_Z_INCR;case 7683:return _native.Engine.STENCIL_OP_FAIL_Z_DECR;case 5386:return _native.Engine.STENCIL_OP_FAIL_Z_INVERT;case 34055:return _native.Engine.STENCIL_OP_FAIL_Z_INCRSAT;case 34056:return _native.Engine.STENCIL_OP_FAIL_Z_DECRSAT;default:throw new Error(`Unsupported stencil depthFail mode: ${a}.`)}}function lO(a){switch(a){case 7680:return _native.Engine.STENCIL_OP_PASS_Z_KEEP;case 0:return _native.Engine.STENCIL_OP_PASS_Z_ZERO;case 7681:return _native.Engine.STENCIL_OP_PASS_Z_REPLACE;case 7682:return _native.Engine.STENCIL_OP_PASS_Z_INCR;case 7683:return _native.Engine.STENCIL_OP_PASS_Z_DECR;case 5386:return _native.Engine.STENCIL_OP_PASS_Z_INVERT;case 34055:return _native.Engine.STENCIL_OP_PASS_Z_INCRSAT;case 34056:return _native.Engine.STENCIL_OP_PASS_Z_DECRSAT;default:throw new Error(`Unsupported stencil opPass mode: ${a}.`)}}function uO(a){switch(a){case 0:return _native.Engine.ALPHA_DISABLE;case 1:return _native.Engine.ALPHA_ADD;case 2:return _native.Engine.ALPHA_COMBINE;case 3:return _native.Engine.ALPHA_SUBTRACT;case 4:return _native.Engine.ALPHA_MULTIPLY;case 5:return _native.Engine.ALPHA_MAXIMIZED;case 6:return _native.Engine.ALPHA_ONEONE;case 7:return _native.Engine.ALPHA_PREMULTIPLIED;case 8:return _native.Engine.ALPHA_PREMULTIPLIED_PORTERDUFF;case 9:return _native.Engine.ALPHA_INTERPOLATE;case 10:return _native.Engine.ALPHA_SCREENMODE;default:throw new Error(`Unsupported alpha mode: ${a}.`)}}function cO(a){switch(a){case N.BYTE:return _native.Engine.ATTRIB_TYPE_INT8;case N.UNSIGNED_BYTE:return _native.Engine.ATTRIB_TYPE_UINT8;case N.SHORT:return _native.Engine.ATTRIB_TYPE_INT16;case N.UNSIGNED_SHORT:return _native.Engine.ATTRIB_TYPE_UINT16;case N.FLOAT:return _native.Engine.ATTRIB_TYPE_FLOAT;default:throw new Error(`Unsupported attribute type: ${a}.`)}}const hO={[N.PositionKind]:!0,[N.NormalKind]:!0,[N.TangentKind]:!0,[N.UVKind]:!0,[N.UV2Kind]:!0,[N.UV3Kind]:!0,[N.UV4Kind]:!0,[N.UV5Kind]:!0,[N.UV6Kind]:!0,[N.ColorKind]:!0,[N.ColorInstanceKind]:!0,[N.MatricesIndicesKind]:!0,[N.MatricesWeightsKind]:!0,[N.MatricesIndicesExtraKind]:!0,[N.MatricesWeightsExtraKind]:!0};function dO(a){switch(a){case N.BYTE:case N.SHORT:case N.INT:case N.FLOAT:return!0;case N.UNSIGNED_BYTE:case N.UNSIGNED_SHORT:case N.UNSIGNED_INT:return!1;default:throw new Error(`Invalid type '${a}'`)}}function b0(a,e){const t=e.getEngine(),i=e._pipelineContext;if(!(i!=null&&i.vertexBufferKindToType))return;let r=null;for(const s in a){const n=a[s];if(!n||!hO[s])continue;const o=n.normalized?N.FLOAT:n.type,l=i.vertexBufferKindToType[s];(o!==N.FLOAT&&l===void 0||l!==void 0&&l!==o)&&(r||(r=t._getShaderProcessingContext(e.shaderLanguage,!1)),i.vertexBufferKindToType[s]=o,o!==N.FLOAT&&(r.vertexBufferKindToNumberOfComponents[s]=N.DeduceStride(s),dO(o)&&(r.vertexBufferKindToNumberOfComponents[s]*=-1)))}if(r){const s=t._caps.parallelShaderCompile;t._caps.parallelShaderCompile=void 0,e._processShaderCodeAsync(null,t._features._checkNonFloatVertexBuffersDontRecreatePipelineContext,r),t._caps.parallelShaderCompile=s}}class fO{constructor(){this.vertexBufferKindToNumberOfComponents={},this.remappedAttributeNames={},this.injectInVertexMain=""}}const y0=new j;if(typeof self<"u"&&!Object.prototype.hasOwnProperty.call(self,"_native")){let a;Object.defineProperty(self,"_native",{get:()=>a,set:e=>{a=e,a&&y0.notifyObservers(a)}})}function pO(){return new Promise(a=>{typeof _native>"u"?y0.addOnce(e=>a(e)):a(_native)})}async function mO(a,e){(await pO())[a]=e}class Yg extends ry{}class _O{constructor(e){this._engine=e,this._pending=new Array,this._isCommandBufferScopeActive=!1,this._commandStream=Ba._createNativeDataStream(),this._engine.setCommandDataStream(this._commandStream)}beginCommandScope(){if(this._isCommandBufferScopeActive)throw new Error("Command scope already active.");this._isCommandBufferScopeActive=!0}endCommandScope(){if(!this._isCommandBufferScopeActive)throw new Error("Command scope is not active.");this._isCommandBufferScopeActive=!1,this._submit()}startEncodingCommand(e){this._commandStream.writeNativeData(e)}encodeCommandArgAsUInt32(e){this._commandStream.writeUint32(e)}encodeCommandArgAsUInt32s(e){this._commandStream.writeUint32Array(e)}encodeCommandArgAsInt32(e){this._commandStream.writeInt32(e)}encodeCommandArgAsInt32s(e){this._commandStream.writeInt32Array(e)}encodeCommandArgAsFloat32(e){this._commandStream.writeFloat32(e)}encodeCommandArgAsFloat32s(e){this._commandStream.writeFloat32Array(e)}encodeCommandArgAsNativeData(e){this._commandStream.writeNativeData(e),this._pending.push(e)}finishEncodingCommand(){this._isCommandBufferScopeActive||this._submit()}_submit(){this._engine.submitCommands(),this._pending.length=0}}const Fc=[];class Ba extends mt{setHardwareScalingLevel(e){super.setHardwareScalingLevel(e),this._engine.setHardwareScalingLevel(e)}constructor(e={}){if(super(null,!1,void 0,e.adaptToDeviceRatio),this._engine=new _native.Engine({version:mt.Version,nonFloatVertexBuffers:!0}),this._camera=_native.Camera?new _native.Camera:null,this._commandBufferEncoder=new _O(this._engine),this._frameStats={gpuTimeNs:Number.NaN},this._boundBuffersVertexArray=null,this._currentDepthTest=_native.Engine.DEPTH_TEST_LEQUAL,this._stencilTest=!1,this._stencilMask=255,this._stencilFunc=519,this._stencilFuncRef=0,this._stencilFuncMask=255,this._stencilOpStencilFail=7680,this._stencilOpDepthFail=7680,this._stencilOpStencilDepthPass=7681,this._zOffset=0,this._zOffsetUnits=0,this._depthWrite=!0,this._fillModeWarningDisplayed=!1,_native.Engine.PROTOCOL_VERSION!==Ba.PROTOCOL_VERSION)throw new Error(`Protocol version mismatch: ${_native.Engine.PROTOCOL_VERSION} (Native) !== ${Ba.PROTOCOL_VERSION} (JS)`);this._engine.setDeviceLostCallback&&this._engine.setDeviceLostCallback(()=>{this.onContextLostObservable.notifyObservers(this),this._contextWasLost=!0,this._restoreEngineAfterContextLost()}),this._webGLVersion=2,this.disableUniformBuffers=!0,this._shaderPlatformName="NATIVE",this._caps={maxTexturesImageUnits:16,maxVertexTextureImageUnits:16,maxCombinedTexturesImageUnits:32,maxTextureSize:_native.Engine.CAPS_LIMITS_MAX_TEXTURE_SIZE,maxCubemapTextureSize:512,maxRenderTextureSize:512,maxVertexAttribs:16,maxVaryingVectors:16,maxDrawBuffers:8,maxFragmentUniformVectors:16,maxVertexUniformVectors:16,standardDerivatives:!0,astc:null,pvrtc:null,etc1:null,etc2:null,bptc:null,maxAnisotropy:16,uintIndices:!0,fragmentDepthSupported:!1,highPrecisionShaderSupported:!0,colorBufferFloat:!1,supportFloatTexturesResolve:!1,rg11b10ufColorRenderable:!1,textureFloat:!0,textureFloatLinearFiltering:!0,textureFloatRender:!0,textureHalfFloat:!0,textureHalfFloatLinearFiltering:!0,textureHalfFloatRender:!0,textureLOD:!0,texelFetch:!1,drawBuffersExtension:!1,depthTextureExtension:!1,vertexArrayObject:!0,instancedArrays:!0,supportOcclusionQuery:!1,canUseTimestampForTimerQuery:!1,blendMinMax:!1,maxMSAASamples:16,canUseGLInstanceID:!0,canUseGLVertexID:!0,supportComputeShaders:!1,supportSRGBBuffers:!0,supportTransformFeedbacks:!1,textureMaxLevel:!1,texture2DArrayMaxLayerCount:_native.Engine.CAPS_LIMITS_MAX_TEXTURE_LAYERS,disableMorphTargetTexture:!1,parallelShaderCompile:{COMPLETION_STATUS_KHR:0},textureNorm16:!1},this._features={forceBitmapOverHTMLImageElement:!0,supportRenderAndCopyToLodForFloatTextures:!1,supportDepthStencilTexture:!1,supportShadowSamplers:!1,uniformBufferHardCheckMatrix:!1,allowTexturePrefiltering:!1,trackUbosInFrame:!1,checkUbosContentBeforeUpload:!1,supportCSM:!1,basisNeedsPOT:!1,support3DTextures:!1,needTypeSuffixInShaderConstants:!1,supportMSAA:!0,supportSSAO2:!1,supportIBLShadows:!1,supportExtendedTextureFormats:!1,supportSwitchCaseInShader:!1,supportSyncTextureRead:!1,needsInvertingBitmap:!0,useUBOBindingCache:!0,needShaderCodeInlining:!0,needToAlwaysBindUniformBuffers:!1,supportRenderPasses:!0,supportSpriteInstancing:!1,forceVertexBufferStrideAndOffsetMultiple4Bytes:!0,_checkNonFloatVertexBuffersDontRecreatePipelineContext:!1,_collectUbosUpdatedInFrame:!1},ae.Log("Babylon Native (v"+mt.Version+") launched"),ae.LoadScript=function(r,s,n,o){ae.LoadFile(r,l=>{Function(l).apply(null),s&&s()},void 0,void 0,!1,(l,u)=>{n&&n("LoadScript Error",u)})},typeof URL>"u"&&(window.URL={createObjectURL:function(){},revokeObjectURL:function(){}}),typeof Blob>"u"&&(window.Blob=function(r){return r}),Array.prototype.flat||Object.defineProperty(Array.prototype,"flat",{configurable:!0,value:function r(){const s=isNaN(arguments[0])?1:Number(arguments[0]);return s?Array.prototype.reduce.call(this,function(n,o){return Array.isArray(o)?n.push.apply(n,r.call(o,s-1)):n.push(o),n},[]):Array.prototype.slice.call(this)},writable:!0});const t=window&&window.devicePixelRatio||1;this._hardwareScalingLevel=e.adaptToDeviceRatio?1/t:1,this._engine.setHardwareScalingLevel(this._hardwareScalingLevel),this._lastDevicePixelRatio=t,this.resize();const i=this.getDepthFunction();i&&this.setDepthFunction(i),this._shaderProcessor=new iO,this.onNewSceneAddedObservable.add(r=>{const s=r.render;r.render=(...n)=>{this._commandBufferEncoder.beginCommandScope(),s.apply(r,n),this._commandBufferEncoder.endCommandScope()}})}dispose(){super.dispose(),this._boundBuffersVertexArray&&this._deleteVertexArray(this._boundBuffersVertexArray),this._engine.dispose()}static _createNativeDataStream(){return new Un}_queueNewFrame(e,t){return t.requestAnimationFrame&&t!==window?t.requestAnimationFrame(e):this._engine.requestAnimationFrame(e),0}_restoreEngineAfterContextLost(){this._clearEmptyResources();const e=this._depthCullingState.depthTest,t=this._depthCullingState.depthFunc,i=this._depthCullingState.depthMask,r=this._stencilState.stencilTest;this._rebuildGraphicsResources(),this._depthCullingState.depthTest=e,this._depthCullingState.depthFunc=t,this._depthCullingState.depthMask=i,this._stencilState.stencilTest=r,this._flagContextRestored()}_bindUnboundFramebuffer(e){this._currentFramebuffer!==e&&(this._currentFramebuffer&&(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_UNBINDFRAMEBUFFER),this._commandBufferEncoder.encodeCommandArgAsNativeData(this._currentFramebuffer),this._commandBufferEncoder.finishEncodingCommand()),e&&(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_BINDFRAMEBUFFER),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.finishEncodingCommand()),this._currentFramebuffer=e)}getHostDocument(){return null}clear(e,t,i,r=!1){if(this.useReverseDepthBuffer)throw new Error("reverse depth buffer is not currently implemented");this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_CLEAR),this._commandBufferEncoder.encodeCommandArgAsUInt32(t&&e?1:0),this._commandBufferEncoder.encodeCommandArgAsFloat32(e?e.r:0),this._commandBufferEncoder.encodeCommandArgAsFloat32(e?e.g:0),this._commandBufferEncoder.encodeCommandArgAsFloat32(e?e.b:0),this._commandBufferEncoder.encodeCommandArgAsFloat32(e?e.a:1),this._commandBufferEncoder.encodeCommandArgAsUInt32(i?1:0),this._commandBufferEncoder.encodeCommandArgAsFloat32(1),this._commandBufferEncoder.encodeCommandArgAsUInt32(r?1:0),this._commandBufferEncoder.encodeCommandArgAsUInt32(0),this._commandBufferEncoder.finishEncodingCommand()}createIndexBuffer(e,t,i){const r=this._normalizeIndexData(e),s=new Yg;return s.references=1,s.is32Bits=r.BYTES_PER_ELEMENT===4,r.byteLength&&(s.nativeIndexBuffer=this._engine.createIndexBuffer(r.buffer,r.byteOffset,r.byteLength,s.is32Bits,t??!1)),s}createVertexBuffer(e,t,i){const r=ArrayBuffer.isView(e)?e:new Float32Array(e),s=new Yg;return s.references=1,r.byteLength&&(s.nativeVertexBuffer=this._engine.createVertexBuffer(r.buffer,r.byteOffset,r.byteLength,t??!1)),s}_recordVertexArrayObject(e,t,i,r,s){r._checkedNonFloatVertexBuffers||(b0(t,r),r._checkedNonFloatVertexBuffers=!0),i&&this._engine.recordIndexBuffer(e,i.nativeIndexBuffer);const n=r.getAttributesNames();for(let o=0;o<n.length;o++){const l=r.getAttributeLocation(o);if(l>=0){const u=n[o];let c=null;if(s&&(c=s[u]),c||(c=t[u]),c){const h=c.effectiveBuffer;h&&h.nativeVertexBuffer&&this._engine.recordVertexBuffer(e,h.nativeVertexBuffer,l,c.effectiveByteOffset,c.effectiveByteStride,c.getSize(),cO(c.type),c.normalized,c.getInstanceDivisor())}}}}bindBuffers(e,t,i){this._boundBuffersVertexArray&&this._deleteVertexArray(this._boundBuffersVertexArray),this._boundBuffersVertexArray=this._engine.createVertexArray(),this._recordVertexArrayObject(this._boundBuffersVertexArray,e,t,i),this.bindVertexArrayObject(this._boundBuffersVertexArray)}recordVertexArrayObject(e,t,i,r){const s=this._engine.createVertexArray();return this._recordVertexArrayObject(s,e,t,i,r),s}_deleteVertexArray(e){this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEVERTEXARRAY),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.finishEncodingCommand()}bindVertexArrayObject(e){this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_BINDVERTEXARRAY),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.finishEncodingCommand()}releaseVertexArrayObject(e){this._deleteVertexArray(e)}getAttributes(e,t){const i=e,r=i.shaderProcessingContext;Fc.length=0;for(let s=0;s<t.length;s++){const n=t[s],o=r.remappedAttributeNames[n]??n;Fc[s]=o}return this._engine.getAttributes(i.program,Fc)}_checkSupportedFillMode(e){return e==5||e==8?(this._fillModeWarningDisplayed||(L.Warn("Line Loop and Triangle Fan are not supported fill modes with Babylon Native. Elements with these fill mode will not be visible."),this._fillModeWarningDisplayed=!0),!1):!0}drawElementsType(e,t,i,r){this._checkSupportedFillMode(e)&&(this._drawCalls.addCount(1,!1),r&&_native.Engine.COMMAND_DRAWINDEXEDINSTANCED?(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAWINDEXEDINSTANCED),this._commandBufferEncoder.encodeCommandArgAsUInt32(e),this._commandBufferEncoder.encodeCommandArgAsUInt32(t),this._commandBufferEncoder.encodeCommandArgAsUInt32(i),this._commandBufferEncoder.encodeCommandArgAsUInt32(r)):(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAWINDEXED),this._commandBufferEncoder.encodeCommandArgAsUInt32(e),this._commandBufferEncoder.encodeCommandArgAsUInt32(t),this._commandBufferEncoder.encodeCommandArgAsUInt32(i)),this._commandBufferEncoder.finishEncodingCommand())}drawArraysType(e,t,i,r){this._checkSupportedFillMode(e)&&(this._drawCalls.addCount(1,!1),r&&_native.Engine.COMMAND_DRAWINSTANCED?(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAWINSTANCED),this._commandBufferEncoder.encodeCommandArgAsUInt32(e),this._commandBufferEncoder.encodeCommandArgAsUInt32(t),this._commandBufferEncoder.encodeCommandArgAsUInt32(i),this._commandBufferEncoder.encodeCommandArgAsUInt32(r)):(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAW),this._commandBufferEncoder.encodeCommandArgAsUInt32(e),this._commandBufferEncoder.encodeCommandArgAsUInt32(t),this._commandBufferEncoder.encodeCommandArgAsUInt32(i)),this._commandBufferEncoder.finishEncodingCommand())}createPipelineContext(e){const t=!!(this._caps.parallelShaderCompile&&this._engine.createProgramAsync);return new rO(this,t,e)}createMaterialContext(){}createDrawContext(){}_preparePipelineContext(e,t,i,r,s,n,o,l,u,c,h){r?this.createRawShaderProgram():this.createShaderProgram(e,t,i,l),h()}_getShaderProcessingContext(e){return new fO}_executeWhenRenderingStateIsCompiled(e,t){const i=e;if(i.isAsync)if(i.onCompiled){const r=i.onCompiled;i.onCompiled=()=>{r(),t()}}else i.onCompiled=t;else t()}createRawShaderProgram(){throw new Error("Not Supported")}createShaderProgram(e,t,i,r){const s=e;this.onBeforeShaderCompilationObservable.notifyObservers(this);const n=new Bn(t);n.processCode(),t=n.code;const o=new Bn(i);o.processCode(),i=o.code,t=it._ConcatenateShader(t,r),i=it._ConcatenateShader(i,r);const l=()=>{var u;s.isCompiled=!0,(u=s.onCompiled)==null||u.call(s),this.onAfterShaderCompilationObservable.notifyObservers(this)};if(e.isAsync)s.program=this._engine.createProgramAsync(t,i,l,u=>{s.compilationError=u});else try{s.program=this._engine.createProgram(t,i),l()}catch(u){const c=u==null?void 0:u.message;throw new Error("SHADER ERROR"+(typeof c=="string"?`
`+c:""))}return s.program}inlineShaderCode(e){const t=new Bn(e);return t.debug=!1,t.processCode(),t.code}_setProgram(e){this._currentProgram!==e&&(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETPROGRAM),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.finishEncodingCommand(),this._currentProgram=e)}_deletePipelineContext(e){const t=e;t&&t.program&&(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEPROGRAM),this._commandBufferEncoder.encodeCommandArgAsNativeData(t.program),this._commandBufferEncoder.finishEncodingCommand())}getUniforms(e,t){const i=e;return this._engine.getUniforms(i.program,t)}bindUniformBlock(e,t,i){throw new Error("Not Implemented")}bindSamplers(e){const t=e.getPipelineContext();this._setProgram(t.program);const i=e.getSamplers();for(let r=0;r<i.length;r++){const s=e.getUniform(i[r]);s&&(this._boundUniforms[r]=s)}this._currentEffect=null}getRenderWidth(e=!1){return!e&&this._currentRenderTarget?this._currentRenderTarget.width:this._engine.getRenderWidth()}getRenderHeight(e=!1){return!e&&this._currentRenderTarget?this._currentRenderTarget.height:this._engine.getRenderHeight()}setViewport(e,t,i){this._cachedViewport=e,this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETVIEWPORT),this._commandBufferEncoder.encodeCommandArgAsFloat32(e.x),this._commandBufferEncoder.encodeCommandArgAsFloat32(e.y),this._commandBufferEncoder.encodeCommandArgAsFloat32(e.width),this._commandBufferEncoder.encodeCommandArgAsFloat32(e.height),this._commandBufferEncoder.finishEncodingCommand()}enableScissor(e,t,i,r){this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSCISSOR),this._commandBufferEncoder.encodeCommandArgAsFloat32(e),this._commandBufferEncoder.encodeCommandArgAsFloat32(t),this._commandBufferEncoder.encodeCommandArgAsFloat32(i),this._commandBufferEncoder.encodeCommandArgAsFloat32(r),this._commandBufferEncoder.finishEncodingCommand()}disableScissor(){this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSCISSOR),this._commandBufferEncoder.encodeCommandArgAsFloat32(0),this._commandBufferEncoder.encodeCommandArgAsFloat32(0),this._commandBufferEncoder.encodeCommandArgAsFloat32(0),this._commandBufferEncoder.encodeCommandArgAsFloat32(0),this._commandBufferEncoder.finishEncodingCommand()}setStateCullFaceType(e,t){throw new Error("setStateCullFaceType: Not Implemented")}setState(e,t=0,i,r=!1,s,n,o=0){this._zOffset=t,this._zOffsetUnits=o,this._zOffset!==0&&ae.Warn("zOffset is not supported in Native engine."),this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSTATE),this._commandBufferEncoder.encodeCommandArgAsUInt32(e?1:0),this._commandBufferEncoder.encodeCommandArgAsFloat32(t),this._commandBufferEncoder.encodeCommandArgAsFloat32(o),this._commandBufferEncoder.encodeCommandArgAsUInt32(this.cullBackFaces??s??!0?1:0),this._commandBufferEncoder.encodeCommandArgAsUInt32(r?1:0),this._commandBufferEncoder.finishEncodingCommand()}getInputElementClientRect(){return{bottom:this.getRenderHeight(),height:this.getRenderHeight(),left:0,right:this.getRenderWidth(),top:0,width:this.getRenderWidth(),x:0,y:0,toJSON:()=>{}}}setZOffset(e){e!==this._zOffset&&(this._zOffset=e,this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETZOFFSET),this._commandBufferEncoder.encodeCommandArgAsFloat32(this.useReverseDepthBuffer?-e:e),this._commandBufferEncoder.finishEncodingCommand())}getZOffset(){return this._zOffset}setZOffsetUnits(e){e!==this._zOffsetUnits&&(this._zOffsetUnits=e,this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETZOFFSETUNITS),this._commandBufferEncoder.encodeCommandArgAsFloat32(this.useReverseDepthBuffer?-e:e),this._commandBufferEncoder.finishEncodingCommand())}getZOffsetUnits(){return this._zOffsetUnits}setDepthBuffer(e){this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHTEST),this._commandBufferEncoder.encodeCommandArgAsUInt32(e?this._currentDepthTest:_native.Engine.DEPTH_TEST_ALWAYS),this._commandBufferEncoder.finishEncodingCommand()}getDepthWrite(){return this._depthWrite}getDepthFunction(){switch(this._currentDepthTest){case _native.Engine.DEPTH_TEST_NEVER:return 512;case _native.Engine.DEPTH_TEST_ALWAYS:return 519;case _native.Engine.DEPTH_TEST_GREATER:return 516;case _native.Engine.DEPTH_TEST_GEQUAL:return 518;case _native.Engine.DEPTH_TEST_NOTEQUAL:return 517;case _native.Engine.DEPTH_TEST_EQUAL:return 514;case _native.Engine.DEPTH_TEST_LESS:return 513;case _native.Engine.DEPTH_TEST_LEQUAL:return 515}return null}setDepthFunction(e){let t=0;switch(e){case 512:t=_native.Engine.DEPTH_TEST_NEVER;break;case 519:t=_native.Engine.DEPTH_TEST_ALWAYS;break;case 516:t=_native.Engine.DEPTH_TEST_GREATER;break;case 518:t=_native.Engine.DEPTH_TEST_GEQUAL;break;case 517:t=_native.Engine.DEPTH_TEST_NOTEQUAL;break;case 514:t=_native.Engine.DEPTH_TEST_EQUAL;break;case 513:t=_native.Engine.DEPTH_TEST_LESS;break;case 515:t=_native.Engine.DEPTH_TEST_LEQUAL;break}this._currentDepthTest=t,this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHTEST),this._commandBufferEncoder.encodeCommandArgAsUInt32(this._currentDepthTest),this._commandBufferEncoder.finishEncodingCommand()}setDepthWrite(e){this._depthWrite=e,this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHWRITE),this._commandBufferEncoder.encodeCommandArgAsUInt32(Number(e)),this._commandBufferEncoder.finishEncodingCommand()}setColorWrite(e){this._colorWrite=e,this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETCOLORWRITE),this._commandBufferEncoder.encodeCommandArgAsUInt32(Number(e)),this._commandBufferEncoder.finishEncodingCommand()}getColorWrite(){return this._colorWrite}applyStencil(){this._setStencil(this._stencilMask,aO(this._stencilOpStencilFail),oO(this._stencilOpDepthFail),lO(this._stencilOpStencilDepthPass),nO(this._stencilFunc),this._stencilFuncRef)}_setStencil(e,t,i,r,s,n){this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSTENCIL),this._commandBufferEncoder.encodeCommandArgAsUInt32(e),this._commandBufferEncoder.encodeCommandArgAsUInt32(t),this._commandBufferEncoder.encodeCommandArgAsUInt32(i),this._commandBufferEncoder.encodeCommandArgAsUInt32(r),this._commandBufferEncoder.encodeCommandArgAsUInt32(s),this._commandBufferEncoder.encodeCommandArgAsUInt32(n),this._commandBufferEncoder.finishEncodingCommand()}setStencilBuffer(e){this._stencilTest=e,e?this.applyStencil():this._setStencil(255,_native.Engine.STENCIL_OP_FAIL_S_KEEP,_native.Engine.STENCIL_OP_FAIL_Z_KEEP,_native.Engine.STENCIL_OP_PASS_Z_KEEP,_native.Engine.STENCIL_TEST_ALWAYS,0)}getStencilBuffer(){return this._stencilTest}getStencilOperationPass(){return this._stencilOpStencilDepthPass}setStencilOperationPass(e){this._stencilOpStencilDepthPass=e,this.applyStencil()}setStencilMask(e){this._stencilMask=e,this.applyStencil()}setStencilFunction(e){this._stencilFunc=e,this.applyStencil()}setStencilFunctionReference(e){this._stencilFuncRef=e,this.applyStencil()}setStencilFunctionMask(e){this._stencilFuncMask=e}setStencilOperationFail(e){this._stencilOpStencilFail=e,this.applyStencil()}setStencilOperationDepthFail(e){this._stencilOpDepthFail=e,this.applyStencil()}getStencilMask(){return this._stencilMask}getStencilFunction(){return this._stencilFunc}getStencilFunctionReference(){return this._stencilFuncRef}getStencilFunctionMask(){return this._stencilFuncMask}getStencilOperationFail(){return this._stencilOpStencilFail}getStencilOperationDepthFail(){return this._stencilOpDepthFail}setAlphaConstants(e,t,i,r){throw new Error("Setting alpha blend constant color not yet implemented.")}setAlphaMode(e,t=!1){if(this._alphaMode===e)return;const i=uO(e);this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETBLENDMODE),this._commandBufferEncoder.encodeCommandArgAsUInt32(i),this._commandBufferEncoder.finishEncodingCommand(),t||this.setDepthWrite(e===0),this._alphaMode=e}setInt(e,t){return e?(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINT),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.encodeCommandArgAsInt32(t),this._commandBufferEncoder.finishEncodingCommand(),!0):!1}setIntArray(e,t){return e?(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.encodeCommandArgAsInt32s(t),this._commandBufferEncoder.finishEncodingCommand(),!0):!1}setIntArray2(e,t){return e?(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY2),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.encodeCommandArgAsInt32s(t),this._commandBufferEncoder.finishEncodingCommand(),!0):!1}setIntArray3(e,t){return e?(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY3),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.encodeCommandArgAsInt32s(t),this._commandBufferEncoder.finishEncodingCommand(),!0):!1}setIntArray4(e,t){return e?(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY4),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.encodeCommandArgAsInt32s(t),this._commandBufferEncoder.finishEncodingCommand(),!0):!1}setFloatArray(e,t){return e?(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.encodeCommandArgAsFloat32s(t),this._commandBufferEncoder.finishEncodingCommand(),!0):!1}setFloatArray2(e,t){return e?(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY2),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.encodeCommandArgAsFloat32s(t),this._commandBufferEncoder.finishEncodingCommand(),!0):!1}setFloatArray3(e,t){return e?(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY3),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.encodeCommandArgAsFloat32s(t),this._commandBufferEncoder.finishEncodingCommand(),!0):!1}setFloatArray4(e,t){return e?(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY4),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.encodeCommandArgAsFloat32s(t),this._commandBufferEncoder.finishEncodingCommand(),!0):!1}setArray(e,t){return e?this.setFloatArray(e,new Float32Array(t)):!1}setArray2(e,t){return e?this.setFloatArray2(e,new Float32Array(t)):!1}setArray3(e,t){return e?this.setFloatArray3(e,new Float32Array(t)):!1}setArray4(e,t){return e?this.setFloatArray4(e,new Float32Array(t)):!1}setMatrices(e,t){return e?(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRICES),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.encodeCommandArgAsFloat32s(t),this._commandBufferEncoder.finishEncodingCommand(),!0):!1}setMatrix3x3(e,t){return e?(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRIX3X3),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.encodeCommandArgAsFloat32s(t),this._commandBufferEncoder.finishEncodingCommand(),!0):!1}setMatrix2x2(e,t){return e?(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRIX2X2),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.encodeCommandArgAsFloat32s(t),this._commandBufferEncoder.finishEncodingCommand(),!0):!1}setFloat(e,t){return e?(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.encodeCommandArgAsFloat32(t),this._commandBufferEncoder.finishEncodingCommand(),!0):!1}setFloat2(e,t,i){return e?(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT2),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.encodeCommandArgAsFloat32(t),this._commandBufferEncoder.encodeCommandArgAsFloat32(i),this._commandBufferEncoder.finishEncodingCommand(),!0):!1}setFloat3(e,t,i,r){return e?(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT3),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.encodeCommandArgAsFloat32(t),this._commandBufferEncoder.encodeCommandArgAsFloat32(i),this._commandBufferEncoder.encodeCommandArgAsFloat32(r),this._commandBufferEncoder.finishEncodingCommand(),!0):!1}setFloat4(e,t,i,r,s){return e?(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT4),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.encodeCommandArgAsFloat32(t),this._commandBufferEncoder.encodeCommandArgAsFloat32(i),this._commandBufferEncoder.encodeCommandArgAsFloat32(r),this._commandBufferEncoder.encodeCommandArgAsFloat32(s),this._commandBufferEncoder.finishEncodingCommand(),!0):!1}setColor3(e,t){return e?(this.setFloat3(e,t.r,t.g,t.b),!0):!1}setColor4(e,t,i){return e?(this.setFloat4(e,t.r,t.g,t.b,i),!0):!1}wipeCaches(e){this.preventCacheWipeBetweenFrames||(this.resetTextureCache(),this._currentEffect=null,e&&(this._currentProgram=null,this._stencilStateComposer.reset(),this._depthCullingState.reset(),this._alphaState.reset()),this._cachedVertexBuffers=null,this._cachedIndexBuffer=null,this._cachedEffectForVertexBuffers=null)}_createTexture(){return this._engine.createTexture()}_deleteTexture(e){e&&this._engine.deleteTexture(e.underlyingResource)}updateDynamicTexture(e,t,i,r=!1,s){if(r===void 0&&(r=!1),e&&e._hardwareTexture){const n=t.getCanvasTexture(),o=e._hardwareTexture.underlyingResource;this._engine.copyTexture(o,n),e.isReady=!0}}createDynamicTexture(e,t,i,r){return e=Math.max(e,1),t=Math.max(t,1),this.createRawTexture(new Uint8Array(e*t*4),e,t,5,!1,!1,r)}createVideoElement(e){return this._camera?this._camera.createVideo(e):null}updateVideoTexture(e,t,i){if(e&&e._hardwareTexture&&this._camera){const r=e._hardwareTexture.underlyingResource;this._camera.updateVideoTexture(r,t,i)}}createRawTexture(e,t,i,r,s,n,o,l=null,u=0,c=0,h=!1){const d=new Dt(this,3);if(d.format=r,d.generateMipMaps=s,d.samplingMode=o,d.invertY=n,d.baseWidth=t,d.baseHeight=i,d.width=d.baseWidth,d.height=d.baseHeight,d._compression=l,d.type=u,d._useSRGBBuffer=this._getUseSRGBBuffer(h,!s),this.updateRawTexture(d,e,r,n,l,u,d._useSRGBBuffer),d._hardwareTexture){const f=d._hardwareTexture.underlyingResource,p=_o(o);this._setTextureSampling(f,p)}return this._internalTexturesCache.push(d),d}createRawTexture2DArray(e,t,i,r,s,n,o,l,u=null,c=0){const h=new Dt(this,11);if(h.baseWidth=t,h.baseHeight=i,h.baseDepth=r,h.width=t,h.height=i,h.depth=r,h.format=s,h.type=c,h.generateMipMaps=n,h.samplingMode=l,h.is2DArray=!0,h._hardwareTexture){const d=h._hardwareTexture.underlyingResource;this._engine.loadRawTexture2DArray(d,e,t,i,r,wc(s,c),n,o);const f=_o(l);this._setTextureSampling(d,f)}return h.isReady=!0,this._internalTexturesCache.push(h),h}updateRawTexture(e,t,i,r,s=null,n=0,o=!1){if(e){if(t&&e._hardwareTexture){const l=e._hardwareTexture.underlyingResource;this._engine.loadRawTexture(l,t,e.width,e.height,wc(i,n),e.generateMipMaps,e.invertY)}e.isReady=!0}}createTexture(e,t,i,r,s=3,n=null,o=null,l=null,u=null,c=null,h=null,d,f,p,g=!1){e=e||"";const _=e.substring(0,5)==="data:",S=_&&e.indexOf(";base64,")!==-1,b=u||new Dt(this,1),y=e;this._transformTextureUrl&&!S&&!u&&!l&&(e=this._transformTextureUrl(e));const T=e.lastIndexOf("."),v=h||(T>-1?e.substring(T).toLowerCase():"");let E=null;(v.endsWith(".basis")||v.endsWith(".ktx")||v.endsWith(".ktx2")||d==="image/ktx"||d==="image/ktx2")&&(E=VR(v)),r&&r.addPendingData(b),b.url=e,b.generateMipMaps=!t,b.samplingMode=s,b.invertY=i,b._useSRGBBuffer=this._getUseSRGBBuffer(g,t),this.doNotHandleContextLost||(b._buffer=l);let R=null;n&&!u&&(R=b.onLoadedObservable.add(n)),u||this._internalTexturesCache.push(b);const O=(w,M)=>{r&&r.removePendingData(b),e===y?(R&&b.onLoadedObservable.remove(R),ze.UseFallbackTexture&&this.createTexture(ze.FallbackTexture,t,b.invertY,r,s,null,o,l,b),o&&o((w||"Unknown error")+(ze.UseFallbackTexture?" - Fallback texture was used":""),M)):(L.Warn(`Failed to load ${e}, falling back to ${y}`),this.createTexture(y,t,b.invertY,r,s,n,o,l,b,c,h,d,f))};if(E)throw new Error("Loading textures from IInternalTextureLoader not yet implemented.");{const w=M=>{if(!b._hardwareTexture){r&&r.removePendingData(b);return}const G=b._hardwareTexture.underlyingResource;this._engine.loadTexture(G,M,!t,i,b._useSRGBBuffer,()=>{b.baseWidth=this._engine.getTextureWidth(G),b.baseHeight=this._engine.getTextureHeight(G),b.width=b.baseWidth,b.height=b.baseHeight,b.isReady=!0;const H=_o(s);this._setTextureSampling(G,H),r&&r.removePendingData(b),b.onLoadedObservable.notifyObservers(b),b.onLoadedObservable.clear()},()=>{throw new Error("Could not load a native texture.")})};if(_&&l)if(l instanceof ArrayBuffer)w(new Uint8Array(l));else if(ArrayBuffer.isView(l))w(l);else if(typeof l=="string")w(new Uint8Array(ae.DecodeBase64(l)));else throw new Error("Unsupported buffer type");else S?w(new Uint8Array(ae.DecodeBase64(e))):this._loadFile(e,M=>w(new Uint8Array(M)),void 0,void 0,!0,(M,G)=>{O("Unable to load "+(M&&M.responseURL,G))})}return b}wrapNativeTexture(e,t=!1,i=3){const r=new jg(e,this._engine),s=new Dt(this,0,!0);return s._hardwareTexture=r,s.baseWidth=this._engine.getTextureWidth(e),s.baseHeight=this._engine.getTextureHeight(e),s.width=s.baseWidth,s.height=s.baseHeight,s.isReady=!0,s.useMipMaps=t,this.updateTextureSamplingMode(i,s),s}wrapWebGLTexture(){throw new Error("wrapWebGLTexture is not supported, use wrapNativeTexture instead.")}_createDepthStencilTexture(e,t,i){const r=t.generateStencil||!1,s=t.samples||1,n=i,o=new Dt(this,12),l=e.width??e,u=e.height??e,c=this._engine.createFrameBuffer(o._hardwareTexture.underlyingResource,l,u,r,!0,s);return n._framebufferDepthStencil=c,o}_releaseFramebufferObjects(e){e&&(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEFRAMEBUFFER),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.finishEncodingCommand())}_createImageBitmapFromSource(e,t){return new Promise((r,s)=>{const n=this.createCanvasImage();n.onload=()=>{try{const o=this._engine.createImageBitmap(n);r(o)}catch(o){s(`Error loading image ${n.src} with exception: ${o}`)}},n.onerror=o=>{s(`Error loading image ${n.src} with exception: ${o}`)},n.src=e})}createImageBitmap(e,t){return new Promise((i,r)=>{if(Array.isArray(e)){const s=e;if(s.length){const n=this._engine.createImageBitmap(s[0]);if(n){i(n);return}}}r("Unsupported data for createImageBitmap.")})}resizeImageBitmap(e,t,i){return this._engine.resizeImageBitmap(e,t,i)}createCubeTexture(e,t,i,r,s=null,n=null,o,l=null,u=!1,c=0,h=0,d=null,f,p=!1,g=null){const _=d||new Dt(this,7);_.isCube=!0,_.url=e,_.generateMipMaps=!r,_._lodGenerationScale=c,_._lodGenerationOffset=h,_._useSRGBBuffer=this._getUseSRGBBuffer(p,!!r),this._doNotHandleContextLost||(_._extension=l,_._files=i,_._buffer=g);const S=e.lastIndexOf(".");if((l||(S>-1?e.substring(S).toLowerCase():""))===".env"){const y=T=>{const v=kR(T);_.width=v.width,_.height=v.width,zR(_,v);const E=v.specular;if(!E)throw new Error("Nothing else parsed so far");_._lodGenerationScale=E.lodGenerationScale;const R=UR(T,v);_.format=5,_.type=0,_.generateMipMaps=!0,_.getEngine().updateTextureSamplingMode(Y.TRILINEAR_SAMPLINGMODE,_),_._isRGBD=!0,_.invertY=!0,this._engine.loadCubeTextureWithMips(_._hardwareTexture.underlyingResource,R,!1,_._useSRGBBuffer,()=>{_.isReady=!0,s&&s()},()=>{throw new Error("Could not load a native cube texture.")})};if(g)y(g);else{if(i&&i.length===6)throw new Error("Multi-file loading not allowed on env files.");{const T=(v,E)=>{n&&v&&n(v.status+" "+v.statusText,E)};this._loadFile(e,v=>{y(new Uint8Array(v,0,v.byteLength))},void 0,void 0,!0,T)}}}else{if(!i||i.length!==6)throw new Error("Cannot load cubemap because 6 files were not defined");const y=[i[0],i[3],i[1],i[4],i[2],i[5]];Promise.all(y.map(T=>this._loadFileAsync(T,void 0,!0).then(v=>new Uint8Array(v,0,v.byteLength)))).then(T=>new Promise((v,E)=>{this._engine.loadCubeTexture(_._hardwareTexture.underlyingResource,T,!r,!0,_._useSRGBBuffer,v,E)})).then(()=>{_.isReady=!0,s&&s()},T=>{n&&n(`Failed to load cubemap: ${T.message}`,T)})}return this._internalTexturesCache.push(_),_}_createHardwareTexture(){return new jg(this._createTexture(),this._engine)}_createHardwareRenderTargetWrapper(e,t,i){const r=new sO(e,t,i,this);return this._renderTargetWrapperCache.push(r),r}_createInternalTexture(e,t,i=!0,r=0){let s=!1,n=0,o=3,l=5,u=!1,c=1,h;t!==void 0&&typeof t=="object"?(s=!!t.generateMipMaps,n=t.type===void 0?0:t.type,o=t.samplingMode===void 0?3:t.samplingMode,l=t.format===void 0?5:t.format,u=t.useSRGBBuffer===void 0?!1:t.useSRGBBuffer,c=t.samples??1,h=t.label):s=!!t,u=this._getUseSRGBBuffer(u,!s),(n===1&&!this._caps.textureFloatLinearFiltering||n===2&&!this._caps.textureHalfFloatLinearFiltering)&&(o=1),n===1&&!this._caps.textureFloat&&(n=0,L.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE"));const d=new Dt(this,r),f=e.width??e,p=e.height??e,g=e.layers||0;if(g!==0)throw new Error("Texture layers are not supported in Babylon Native");const _=d._hardwareTexture.underlyingResource,S=wc(l,n);return this._engine.initializeTexture(_,f,p,s,S,!0,u,c),this._setTextureSampling(_,_o(o)),d._useSRGBBuffer=u,d.baseWidth=f,d.baseHeight=p,d.width=f,d.height=p,d.depth=g,d.isReady=!0,d.samples=c,d.generateMipMaps=s,d.samplingMode=o,d.type=n,d.format=l,d.label=h,this._internalTexturesCache.push(d),d}createRenderTargetTexture(e,t){const i=this._createHardwareRenderTargetWrapper(!1,!1,e);let r=!0,s=!1,n=!1,o,l=1;t!==void 0&&typeof t=="object"&&(r=t.generateDepthBuffer??!0,s=!!t.generateStencilBuffer,n=!!t.noColorAttachment,o=t.colorAttachment,l=t.samples??1);const u=o||(n?null:this._createInternalTexture(e,t,!0,5)),c=e.width??e,h=e.height??e,d=this._engine.createFrameBuffer(u?u._hardwareTexture.underlyingResource:null,c,h,s,r,l);return i._framebuffer=d,i._generateDepthBuffer=r,i._generateStencilBuffer=s,i._samples=l,i.setTextures(u),i}updateRenderTargetTextureSampleCount(e,t){return L.Warn("Updating render target sample count is not currently supported"),e.samples}updateTextureSamplingMode(e,t){if(t._hardwareTexture){const i=_o(e);this._setTextureSampling(t._hardwareTexture.underlyingResource,i)}t.samplingMode=e}bindFramebuffer(e,t,i,r,s){const n=e;if(this._currentRenderTarget&&this.unBindFramebuffer(this._currentRenderTarget),this._currentRenderTarget=e,t)throw new Error("Cuboid frame buffers are not yet supported in NativeEngine.");if(i||r)throw new Error("Required width/height for frame buffers not yet supported in NativeEngine.");n._framebufferDepthStencil?this._bindUnboundFramebuffer(n._framebufferDepthStencil):this._bindUnboundFramebuffer(n._framebuffer)}unBindFramebuffer(e,t=!1,i){this._currentRenderTarget=null,i&&i(),this._bindUnboundFramebuffer(null)}createDynamicVertexBuffer(e){return this.createVertexBuffer(e,!0)}updateDynamicIndexBuffer(e,t,i=0){const r=e,s=this._normalizeIndexData(t);r.is32Bits=s.BYTES_PER_ELEMENT===4,this._engine.updateDynamicIndexBuffer(r.nativeIndexBuffer,s.buffer,s.byteOffset,s.byteLength,i)}updateDynamicVertexBuffer(e,t,i=0,r){const s=e,n=t instanceof Array?new Float32Array(t):t instanceof ArrayBuffer?new Uint8Array(t):t,o=new Uint8Array(n.buffer,n.byteOffset,r??n.byteLength);this._engine.updateDynamicVertexBuffer(s.nativeVertexBuffer,o.buffer,o.byteOffset,o.byteLength,i)}_setTexture(e,t,i=!1,r=!1){const s=this._boundUniforms[e];if(!s)return!1;if(!t)return this._boundTexturesCache[e]!=null&&(this._activeChannel=e,this._boundTexturesCache[e]=null,this._unsetNativeTexture(s)),!1;if(t.video)this._activeChannel=e,t.update();else if(t.delayLoadState===4)return t.delayLoad(),!1;let n;return r?n=t.depthStencilTexture:t.isReady()?n=t.getInternalTexture():t.isCube?n=this.emptyCubeTexture:t.is3D?n=this.emptyTexture3D:t.is2DArray?n=this.emptyTexture2DArray:n=this.emptyTexture,this._activeChannel=e,!n||!n._hardwareTexture?!1:(this._setTextureWrapMode(n._hardwareTexture.underlyingResource,Nc(t.wrapU),Nc(t.wrapV),Nc(t.wrapR)),this._updateAnisotropicLevel(t),this._setNativeTexture(s,n._hardwareTexture.underlyingResource),!0)}_setTextureSampling(e,t){this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTURESAMPLING),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.encodeCommandArgAsUInt32(t),this._commandBufferEncoder.finishEncodingCommand()}_setTextureWrapMode(e,t,i,r){this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTUREWRAPMODE),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.encodeCommandArgAsUInt32(t),this._commandBufferEncoder.encodeCommandArgAsUInt32(i),this._commandBufferEncoder.encodeCommandArgAsUInt32(r),this._commandBufferEncoder.finishEncodingCommand()}_setNativeTexture(e,t){this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTURE),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.encodeCommandArgAsNativeData(t),this._commandBufferEncoder.finishEncodingCommand()}_unsetNativeTexture(e){_native.Engine.COMMAND_UNSETTEXTURE&&(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_UNSETTEXTURE),this._commandBufferEncoder.encodeCommandArgAsNativeData(e),this._commandBufferEncoder.finishEncodingCommand())}_updateAnisotropicLevel(e){const t=e.getInternalTexture(),i=e.anisotropicFilteringLevel;!t||!t._hardwareTexture||t._cachedAnisotropicFilteringLevel!==i&&(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTUREANISOTROPICLEVEL),this._commandBufferEncoder.encodeCommandArgAsNativeData(t._hardwareTexture.underlyingResource),this._commandBufferEncoder.encodeCommandArgAsUInt32(i),this._commandBufferEncoder.finishEncodingCommand(),t._cachedAnisotropicFilteringLevel=i)}_bindTexture(e,t){const i=this._boundUniforms[e];if(i)if(t&&t._hardwareTexture){const r=t._hardwareTexture.underlyingResource;this._setNativeTexture(i,r)}else this._unsetNativeTexture(i)}unbindAllTextures(){_native.Engine.COMMAND_DISCARDALLTEXTURES&&(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DISCARDALLTEXTURES),this._commandBufferEncoder.finishEncodingCommand())}_deleteBuffer(e){e.nativeIndexBuffer&&(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEINDEXBUFFER),this._commandBufferEncoder.encodeCommandArgAsNativeData(e.nativeIndexBuffer),this._commandBufferEncoder.finishEncodingCommand(),delete e.nativeIndexBuffer),e.nativeVertexBuffer&&(this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEVERTEXBUFFER),this._commandBufferEncoder.encodeCommandArgAsNativeData(e.nativeVertexBuffer),this._commandBufferEncoder.finishEncodingCommand(),delete e.nativeVertexBuffer)}createCanvas(e,t){if(!_native.Canvas)throw new Error("Native Canvas plugin not available.");const i=new _native.Canvas;return i.width=e,i.height=t,i}createCanvasImage(){if(!_native.Canvas)throw new Error("Native Canvas plugin not available.");return new _native.Image}createCanvasPath2D(e){if(!_native.Canvas)throw new Error("Native Canvas plugin not available.");return new _native.Path2D(e)}updateTextureData(e,t,i,r,s,n,o=0,l=0,u=!1){throw new Error("updateTextureData not implemented.")}_uploadCompressedDataToTextureDirectly(e,t,i,r,s,n=0,o=0){throw new Error("_uploadCompressedDataToTextureDirectly not implemented.")}_uploadDataToTextureDirectly(e,t,i=0,r=0){throw new Error("_uploadDataToTextureDirectly not implemented.")}_uploadArrayBufferViewToTexture(e,t,i=0,r=0){throw new Error("_uploadArrayBufferViewToTexture not implemented.")}_uploadImageToTexture(e,t,i=0,r=0){throw new Error("_uploadArrayBufferViewToTexture not implemented.")}getFontOffset(e){return{ascent:0,height:0,descent:0}}flushFramebuffer(){}_readTexturePixels(e,t,i,r,s,n,o,l,u,c){var h;if(r!==void 0&&r!==-1)throw new Error(`Reading cubemap faces is not supported, but faceIndex is ${r}.`);return this._engine.readTexture((h=e._hardwareTexture)==null?void 0:h.underlyingResource,s??0,u??0,c??0,t,i,(n==null?void 0:n.buffer)??null,(n==null?void 0:n.byteOffset)??0,(n==null?void 0:n.byteLength)??0).then(d=>(n||(n=new Uint8Array(d)),n))}startTimeQuery(){return this._gpuFrameTimeToken||(this._gpuFrameTimeToken=new v0),this._gpuFrameTimeToken}endTimeQuery(e){var t,i;return(i=(t=this._engine).populateFrameStats)==null||i.call(t,this._frameStats),this._frameStats.gpuTimeNs}}Ba.PROTOCOL_VERSION=8;Ba._createNativeDataStream=function(){return _native.NativeDataStream.VALIDATION_ENABLED?new gO:new Un};class gO extends Un{constructor(){super()}writeUint32(e){super.writeUint32(_native.NativeDataStream.VALIDATION_UINT_32),super.writeUint32(e)}writeInt32(e){super.writeUint32(_native.NativeDataStream.VALIDATION_INT_32),super.writeInt32(e)}writeFloat32(e){super.writeUint32(_native.NativeDataStream.VALIDATION_FLOAT_32),super.writeFloat32(e)}writeUint32Array(e){super.writeUint32(_native.NativeDataStream.VALIDATION_UINT_32_ARRAY),super.writeUint32Array(e)}writeInt32Array(e){super.writeUint32(_native.NativeDataStream.VALIDATION_INT_32_ARRAY),super.writeInt32Array(e)}writeFloat32Array(e){super.writeUint32(_native.NativeDataStream.VALIDATION_FLOAT_32_ARRAY),super.writeFloat32Array(e)}writeNativeData(e){super.writeUint32(_native.NativeDataStream.VALIDATION_NATIVE_DATA),super.writeNativeData(e)}writeBoolean(e){super.writeUint32(_native.NativeDataStream.VALIDATION_BOOLEAN),super.writeBoolean(e)}}class et{static ComputeNumMipmapLevels(e,t){return Uo(Math.max(e,t))+1}static GetTextureTypeFromFormat(e){switch(e){case"r8unorm":case"r8uint":case"rg8unorm":case"rg8uint":case"rgba8unorm":case"rgba8unorm-srgb":case"rgba8uint":case"bgra8unorm":case"bgra8unorm-srgb":case"rgb10a2uint":case"rgb10a2unorm":case"rgb9e5ufloat":case"rg11b10ufloat":case"bc7-rgba-unorm":case"bc7-rgba-unorm-srgb":case"bc6h-rgb-ufloat":case"bc5-rg-unorm":case"bc3-rgba-unorm":case"bc3-rgba-unorm-srgb":case"bc2-rgba-unorm":case"bc2-rgba-unorm-srgb":case"bc4-r-unorm":case"bc1-rgba-unorm":case"bc1-rgba-unorm-srgb":case"etc2-rgb8unorm":case"etc2-rgb8unorm-srgb":case"etc2-rgb8a1unorm":case"etc2-rgb8a1unorm-srgb":case"etc2-rgba8unorm":case"etc2-rgba8unorm-srgb":case"eac-r11unorm":case"eac-rg11unorm":case"astc-4x4-unorm":case"astc-4x4-unorm-srgb":case"astc-5x4-unorm":case"astc-5x4-unorm-srgb":case"astc-5x5-unorm":case"astc-5x5-unorm-srgb":case"astc-6x5-unorm":case"astc-6x5-unorm-srgb":case"astc-6x6-unorm":case"astc-6x6-unorm-srgb":case"astc-8x5-unorm":case"astc-8x5-unorm-srgb":case"astc-8x6-unorm":case"astc-8x6-unorm-srgb":case"astc-8x8-unorm":case"astc-8x8-unorm-srgb":case"astc-10x5-unorm":case"astc-10x5-unorm-srgb":case"astc-10x6-unorm":case"astc-10x6-unorm-srgb":case"astc-10x8-unorm":case"astc-10x8-unorm-srgb":case"astc-10x10-unorm":case"astc-10x10-unorm-srgb":case"astc-12x10-unorm":case"astc-12x10-unorm-srgb":case"astc-12x12-unorm":case"astc-12x12-unorm-srgb":case"stencil8":return 0;case"r8snorm":case"r8sint":case"rg8snorm":case"rg8sint":case"rgba8snorm":case"rgba8sint":case"bc6h-rgb-float":case"bc5-rg-snorm":case"bc4-r-snorm":case"eac-r11snorm":case"eac-rg11snorm":return 3;case"r16uint":case"r16unorm":case"rg16unorm":case"rgba16unorm":case"rg16uint":case"rgba16uint":case"depth16unorm":return 5;case"r16sint":case"r16snorm":case"rg16snorm":case"rgba16snorm":case"rg16sint":case"rgba16sint":return 4;case"r16float":case"rg16float":case"rgba16float":return 2;case"r32uint":case"rg32uint":case"rgba32uint":return 7;case"r32sint":case"rg32sint":case"rgba32sint":return 7;case"r32float":case"rg32float":case"rgba32float":case"depth32float":case"depth32float-stencil8":case"depth24plus":case"depth24plus-stencil8":return 1}return 0}static GetBlockInformationFromFormat(e){switch(e){case"r8unorm":case"r8snorm":case"r8uint":case"r8sint":return{width:1,height:1,length:1};case"r16uint":case"r16sint":case"r16unorm":case"rg16unorm":case"rgba16unorm":case"r16snorm":case"rg16snorm":case"rgba16snorm":case"r16float":case"rg8unorm":case"rg8snorm":case"rg8uint":case"rg8sint":return{width:1,height:1,length:2};case"r32uint":case"r32sint":case"r32float":case"rg16uint":case"rg16sint":case"rg16float":case"rgba8unorm":case"rgba8unorm-srgb":case"rgba8snorm":case"rgba8uint":case"rgba8sint":case"bgra8unorm":case"bgra8unorm-srgb":case"rgb9e5ufloat":case"rgb10a2uint":case"rgb10a2unorm":case"rg11b10ufloat":return{width:1,height:1,length:4};case"rg32uint":case"rg32sint":case"rg32float":case"rgba16uint":case"rgba16sint":case"rgba16float":return{width:1,height:1,length:8};case"rgba32uint":case"rgba32sint":case"rgba32float":return{width:1,height:1,length:16};case"stencil8":throw"No fixed size for Stencil8 format!";case"depth16unorm":return{width:1,height:1,length:2};case"depth24plus":throw"No fixed size for Depth24Plus format!";case"depth24plus-stencil8":throw"No fixed size for Depth24PlusStencil8 format!";case"depth32float":return{width:1,height:1,length:4};case"depth32float-stencil8":return{width:1,height:1,length:5};case"bc7-rgba-unorm":case"bc7-rgba-unorm-srgb":case"bc6h-rgb-ufloat":case"bc6h-rgb-float":case"bc5-rg-unorm":case"bc5-rg-snorm":case"bc3-rgba-unorm":case"bc3-rgba-unorm-srgb":case"bc2-rgba-unorm":case"bc2-rgba-unorm-srgb":return{width:4,height:4,length:16};case"bc4-r-unorm":case"bc4-r-snorm":case"bc1-rgba-unorm":case"bc1-rgba-unorm-srgb":return{width:4,height:4,length:8};case"etc2-rgb8unorm":case"etc2-rgb8unorm-srgb":case"etc2-rgb8a1unorm":case"etc2-rgb8a1unorm-srgb":case"eac-r11unorm":case"eac-r11snorm":return{width:4,height:4,length:8};case"etc2-rgba8unorm":case"etc2-rgba8unorm-srgb":case"eac-rg11unorm":case"eac-rg11snorm":return{width:4,height:4,length:16};case"astc-4x4-unorm":case"astc-4x4-unorm-srgb":return{width:4,height:4,length:16};case"astc-5x4-unorm":case"astc-5x4-unorm-srgb":return{width:5,height:4,length:16};case"astc-5x5-unorm":case"astc-5x5-unorm-srgb":return{width:5,height:5,length:16};case"astc-6x5-unorm":case"astc-6x5-unorm-srgb":return{width:6,height:5,length:16};case"astc-6x6-unorm":case"astc-6x6-unorm-srgb":return{width:6,height:6,length:16};case"astc-8x5-unorm":case"astc-8x5-unorm-srgb":return{width:8,height:5,length:16};case"astc-8x6-unorm":case"astc-8x6-unorm-srgb":return{width:8,height:6,length:16};case"astc-8x8-unorm":case"astc-8x8-unorm-srgb":return{width:8,height:8,length:16};case"astc-10x5-unorm":case"astc-10x5-unorm-srgb":return{width:10,height:5,length:16};case"astc-10x6-unorm":case"astc-10x6-unorm-srgb":return{width:10,height:6,length:16};case"astc-10x8-unorm":case"astc-10x8-unorm-srgb":return{width:10,height:8,length:16};case"astc-10x10-unorm":case"astc-10x10-unorm-srgb":return{width:10,height:10,length:16};case"astc-12x10-unorm":case"astc-12x10-unorm-srgb":return{width:12,height:10,length:16};case"astc-12x12-unorm":case"astc-12x12-unorm-srgb":return{width:12,height:12,length:16}}return{width:1,height:1,length:4}}static IsHardwareTexture(e){return!!e.release}static IsInternalTexture(e){return!!e.dispose}static IsImageBitmap(e){return e.close!==void 0}static IsImageBitmapArray(e){return Array.isArray(e)&&e[0].close!==void 0}static IsCompressedFormat(e){switch(e){case"bc7-rgba-unorm-srgb":case"bc7-rgba-unorm":case"bc6h-rgb-float":case"bc6h-rgb-ufloat":case"bc5-rg-snorm":case"bc5-rg-unorm":case"bc4-r-snorm":case"bc4-r-unorm":case"bc3-rgba-unorm-srgb":case"bc3-rgba-unorm":case"bc2-rgba-unorm-srgb":case"bc2-rgba-unorm":case"bc1-rgba-unorm-srgb":case"bc1-rgba-unorm":case"etc2-rgb8unorm":case"etc2-rgb8unorm-srgb":case"etc2-rgb8a1unorm":case"etc2-rgb8a1unorm-srgb":case"etc2-rgba8unorm":case"etc2-rgba8unorm-srgb":case"eac-r11unorm":case"eac-r11snorm":case"eac-rg11unorm":case"eac-rg11snorm":case"astc-4x4-unorm":case"astc-4x4-unorm-srgb":case"astc-5x4-unorm":case"astc-5x4-unorm-srgb":case"astc-5x5-unorm":case"astc-5x5-unorm-srgb":case"astc-6x5-unorm":case"astc-6x5-unorm-srgb":case"astc-6x6-unorm":case"astc-6x6-unorm-srgb":case"astc-8x5-unorm":case"astc-8x5-unorm-srgb":case"astc-8x6-unorm":case"astc-8x6-unorm-srgb":case"astc-8x8-unorm":case"astc-8x8-unorm-srgb":case"astc-10x5-unorm":case"astc-10x5-unorm-srgb":case"astc-10x6-unorm":case"astc-10x6-unorm-srgb":case"astc-10x8-unorm":case"astc-10x8-unorm-srgb":case"astc-10x10-unorm":case"astc-10x10-unorm-srgb":case"astc-12x10-unorm":case"astc-12x10-unorm-srgb":case"astc-12x12-unorm":case"astc-12x12-unorm-srgb":return!0}return!1}static GetWebGPUTextureFormat(e,t,i=!1){switch(t){case 15:return"depth16unorm";case 16:return"depth24plus";case 13:return"depth24plus-stencil8";case 14:return"depth32float";case 18:return"depth32float-stencil8";case 19:return"stencil8";case 36492:return i?"bc7-rgba-unorm-srgb":"bc7-rgba-unorm";case 36495:return"bc6h-rgb-ufloat";case 36494:return"bc6h-rgb-float";case 33779:return i?"bc3-rgba-unorm-srgb":"bc3-rgba-unorm";case 33778:return i?"bc2-rgba-unorm-srgb":"bc2-rgba-unorm";case 33777:case 33776:return i?"bc1-rgba-unorm-srgb":"bc1-rgba-unorm";case 37808:return i?"astc-4x4-unorm-srgb":"astc-4x4-unorm";case 36196:case 37492:return i?"etc2-rgb8unorm-srgb":"etc2-rgb8unorm";case 37496:return i?"etc2-rgba8unorm-srgb":"etc2-rgba8unorm"}switch(e){case 3:switch(t){case 6:return"r8snorm";case 7:return"rg8snorm";case 4:throw"RGB format not supported in WebGPU";case 8:return"r8sint";case 9:return"rg8sint";case 10:throw"RGB_INTEGER format not supported in WebGPU";case 11:return"rgba8sint";default:return"rgba8snorm"}case 0:switch(t){case 6:return"r8unorm";case 7:return"rg8unorm";case 4:throw"TEXTUREFORMAT_RGB format not supported in WebGPU";case 5:return i?"rgba8unorm-srgb":"rgba8unorm";case 12:return i?"bgra8unorm-srgb":"bgra8unorm";case 8:return"r8uint";case 9:return"rg8uint";case 10:throw"RGB_INTEGER format not supported in WebGPU";case 11:return"rgba8uint";case 0:throw"TEXTUREFORMAT_ALPHA format not supported in WebGPU";case 1:throw"TEXTUREFORMAT_LUMINANCE format not supported in WebGPU";case 2:throw"TEXTUREFORMAT_LUMINANCE_ALPHA format not supported in WebGPU";default:return"rgba8unorm"}case 4:switch(t){case 8:return"r16sint";case 9:return"rg16sint";case 10:throw"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU";case 11:return"rgba16sint";default:return"rgba16sint"}case 5:switch(t){case 8:return"r16uint";case 9:return"rg16uint";case 10:throw"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU";case 11:return"rgba16uint";default:return"rgba16uint"}case 6:switch(t){case 8:return"r32sint";case 9:return"rg32sint";case 10:throw"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU";case 11:return"rgba32sint";default:return"rgba32sint"}case 7:switch(t){case 8:return"r32uint";case 9:return"rg32uint";case 10:throw"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU";case 11:return"rgba32uint";default:return"rgba32uint"}case 1:switch(t){case 6:return"r32float";case 7:return"rg32float";case 4:throw"TEXTUREFORMAT_RGB format not supported in WebGPU";case 5:return"rgba32float";default:return"rgba32float"}case 2:switch(t){case 6:return"r16float";case 7:return"rg16float";case 4:throw"TEXTUREFORMAT_RGB format not supported in WebGPU";case 5:return"rgba16float";default:return"rgba16float"}case 10:throw"TEXTURETYPE_UNSIGNED_SHORT_5_6_5 format not supported in WebGPU";case 13:switch(t){case 5:return"rg11b10ufloat";case 11:throw"TEXTUREFORMAT_RGBA_INTEGER format not supported in WebGPU when type is TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV";default:return"rg11b10ufloat"}case 14:switch(t){case 5:return"rgb9e5ufloat";case 11:throw"TEXTUREFORMAT_RGBA_INTEGER format not supported in WebGPU when type is TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV";default:return"rgb9e5ufloat"}case 8:throw"TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 format not supported in WebGPU";case 9:throw"TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 format not supported in WebGPU";case 11:switch(t){case 5:return"rgb10a2unorm";case 11:return"rgb10a2uint";default:return"rgb10a2unorm"}}return i?"rgba8unorm-srgb":"rgba8unorm"}static GetNumChannelsFromWebGPUTextureFormat(e){switch(e){case"r8unorm":case"r8snorm":case"r8uint":case"r8sint":case"bc4-r-unorm":case"bc4-r-snorm":case"r16uint":case"r16sint":case"depth16unorm":case"r16float":case"r16unorm":case"r16snorm":case"r32uint":case"r32sint":case"r32float":case"depth32float":case"stencil8":case"depth24plus":case"eac-r11unorm":case"eac-r11snorm":return 1;case"rg8unorm":case"rg8snorm":case"rg8uint":case"rg8sint":case"depth32float-stencil8":case"bc5-rg-unorm":case"bc5-rg-snorm":case"rg16uint":case"rg16sint":case"rg16float":case"rg16unorm":case"rg16snorm":case"rg32uint":case"rg32sint":case"rg32float":case"depth24plus-stencil8":case"eac-rg11unorm":case"eac-rg11snorm":return 2;case"rgb9e5ufloat":case"rg11b10ufloat":case"bc6h-rgb-ufloat":case"bc6h-rgb-float":case"etc2-rgb8unorm":case"etc2-rgb8unorm-srgb":return 3;case"rgba8unorm":case"rgba8unorm-srgb":case"rgba8snorm":case"rgba8uint":case"rgba8sint":case"bgra8unorm":case"bgra8unorm-srgb":case"rgba16unorm":case"rgba16snorm":case"rgb10a2uint":case"rgb10a2unorm":case"bc7-rgba-unorm":case"bc7-rgba-unorm-srgb":case"bc3-rgba-unorm":case"bc3-rgba-unorm-srgb":case"bc2-rgba-unorm":case"bc2-rgba-unorm-srgb":case"bc1-rgba-unorm":case"bc1-rgba-unorm-srgb":case"rgba16uint":case"rgba16sint":case"rgba16float":case"rgba32uint":case"rgba32sint":case"rgba32float":case"etc2-rgb8a1unorm":case"etc2-rgb8a1unorm-srgb":case"etc2-rgba8unorm":case"etc2-rgba8unorm-srgb":case"astc-4x4-unorm":case"astc-4x4-unorm-srgb":case"astc-5x4-unorm":case"astc-5x4-unorm-srgb":case"astc-5x5-unorm":case"astc-5x5-unorm-srgb":case"astc-6x5-unorm":case"astc-6x5-unorm-srgb":case"astc-6x6-unorm":case"astc-6x6-unorm-srgb":case"astc-8x5-unorm":case"astc-8x5-unorm-srgb":case"astc-8x6-unorm":case"astc-8x6-unorm-srgb":case"astc-8x8-unorm":case"astc-8x8-unorm-srgb":case"astc-10x5-unorm":case"astc-10x5-unorm-srgb":case"astc-10x6-unorm":case"astc-10x6-unorm-srgb":case"astc-10x8-unorm":case"astc-10x8-unorm-srgb":case"astc-10x10-unorm":case"astc-10x10-unorm-srgb":case"astc-12x10-unorm":case"astc-12x10-unorm-srgb":case"astc-12x12-unorm":case"astc-12x12-unorm-srgb":return 4}throw`Unknown format ${e}!`}static HasStencilAspect(e){switch(e){case"stencil8":case"depth32float-stencil8":case"depth24plus-stencil8":return!0}return!1}static HasDepthAndStencilAspects(e){switch(e){case"depth32float-stencil8":case"depth24plus-stencil8":return!0}return!1}static GetDepthFormatOnly(e){switch(e){case"depth16unorm":return"depth16unorm";case"depth24plus":return"depth24plus";case"depth24plus-stencil8":return"depth24plus";case"depth32float":return"depth32float";case"depth32float-stencil8":return"depth32float"}return e}static GetSample(e){return e>1?4:1}}class xt extends st{constructor(){super(...arguments),this.dbgShowShaderCode=!1,this.dbgSanityChecks=!0,this.dbgVerboseLogsNumFrames=10,this.dbgLogIfNotDrawWrapper=!0,this.dbgShowEmptyEnableEffectCalls=!0,this.dbgVerboseLogsForFirstFrames=!1,this._currentRenderPass=null,this._snapshotRenderingMode=0,this._timestampIndex=0,this._debugStackRenderPass=[]}get enableGPUTimingMeasurements(){return this._timestampQuery.enable}set enableGPUTimingMeasurements(e){this._timestampQuery.enable!==e&&(this.gpuTimeInFrameForMainPass=e?new l_:void 0,this._timestampQuery.enable=e)}_currentPassIsMainPass(){return this._currentRenderTarget===null}_endCurrentRenderPass(){var t,i,r;if(!this._currentRenderPass)return 0;if(this._debugStackRenderPass.length!==0)for(let s=0;s<this._debugStackRenderPass.length;++s)this._currentRenderPass.popDebugGroup();const e=this._currentPassIsMainPass()?2:1;return!this._snapshotRendering.endRenderPass(this._currentRenderPass)&&!this.compatibilityMode&&(this._bundleList.run(this._currentRenderPass),this._bundleList.reset()),this._currentRenderPass.end(),this._timestampQuery.endPass(this._timestampIndex,this._currentRenderTarget&&this._currentRenderTarget.gpuTimeInFrame?this._currentRenderTarget.gpuTimeInFrame:this.gpuTimeInFrameForMainPass),this._timestampIndex+=2,this.dbgVerboseLogsForFirstFrames&&(this._count===void 0&&(this._count=0),(!this._count||this._count<this.dbgVerboseLogsNumFrames)&&L.Log("frame #"+this._count+" - "+(e===2?"main":"render target")+" end pass"+(e===1?" - internalTexture.uniqueId="+((i=(t=this._currentRenderTarget)==null?void 0:t.texture)==null?void 0:i.uniqueId):""))),(r=this._debugPopGroup)==null||r.call(this,0),this._currentRenderPass=null,e}_generateMipmaps(e,t){t=t??this._renderEncoder;const i=e._hardwareTexture;if(!i)return;t===this._renderEncoder&&this._endCurrentRenderPass();const r=e._hardwareTexture.format,s=et.ComputeNumMipmapLevels(e.width,e.height);this.dbgVerboseLogsForFirstFrames&&(this._count===void 0&&(this._count=0),(!this._count||this._count<this.dbgVerboseLogsNumFrames)&&L.Log("frame #"+this._count+" - generate mipmaps - width="+e.width+", height="+e.height+", isCube="+e.isCube+", command encoder="+(t===this._renderEncoder?"render":"copy"))),e.isCube?this._textureHelper.generateCubeMipmaps(i,r,s,t):this._textureHelper.generateMipmaps(i,r,s,0,e.is3D,t)}}xt.prototype.setAlphaMode=function(a,e=!1){if(this._alphaMode===a&&(a===0&&!this._alphaState.alphaBlend||a!==0&&this._alphaState.alphaBlend)){if(!e){const t=a===0;this.depthCullingState.depthMask!==t&&(this.setDepthWrite(t),this._cacheRenderPipeline.setDepthWriteEnabled(t))}return}switch(a){case 0:this._alphaState.alphaBlend=!1;break;case 7:this._alphaState.setAlphaBlendFunctionParameters(1,771,1,1),this._alphaState.alphaBlend=!0;break;case 8:this._alphaState.setAlphaBlendFunctionParameters(1,771,1,771),this._alphaState.alphaBlend=!0;break;case 2:this._alphaState.setAlphaBlendFunctionParameters(770,771,1,1),this._alphaState.alphaBlend=!0;break;case 6:this._alphaState.setAlphaBlendFunctionParameters(1,1,0,1),this._alphaState.alphaBlend=!0;break;case 1:this._alphaState.setAlphaBlendFunctionParameters(770,1,0,1),this._alphaState.alphaBlend=!0;break;case 3:this._alphaState.setAlphaBlendFunctionParameters(0,769,1,1),this._alphaState.alphaBlend=!0;break;case 4:this._alphaState.setAlphaBlendFunctionParameters(774,0,1,1),this._alphaState.alphaBlend=!0;break;case 5:this._alphaState.setAlphaBlendFunctionParameters(770,769,1,1),this._alphaState.alphaBlend=!0;break;case 9:this._alphaState.setAlphaBlendFunctionParameters(32769,32770,32771,32772),this._alphaState.alphaBlend=!0;break;case 10:this._alphaState.setAlphaBlendFunctionParameters(1,769,1,771),this._alphaState.alphaBlend=!0;break;case 11:this._alphaState.setAlphaBlendFunctionParameters(1,1,1,1),this._alphaState.alphaBlend=!0;break;case 12:this._alphaState.setAlphaBlendFunctionParameters(772,1,0,0),this._alphaState.alphaBlend=!0;break;case 13:this._alphaState.setAlphaBlendFunctionParameters(775,769,773,771),this._alphaState.alphaBlend=!0;break;case 14:this._alphaState.setAlphaBlendFunctionParameters(1,771,1,771),this._alphaState.alphaBlend=!0;break;case 15:this._alphaState.setAlphaBlendFunctionParameters(1,1,1,0),this._alphaState.alphaBlend=!0;break;case 16:this._alphaState.setAlphaBlendFunctionParameters(775,769,0,1),this._alphaState.alphaBlend=!0;break;case 17:this._alphaState.setAlphaBlendFunctionParameters(770,771,1,771),this._alphaState.alphaBlend=!0;break}e||(this.setDepthWrite(a===0),this._cacheRenderPipeline.setDepthWriteEnabled(a===0)),this._alphaMode=a,this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState.alphaBlend),this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters,this._alphaState._blendEquationParameters)};xt.prototype.setAlphaEquation=function(a){st.prototype.setAlphaEquation.call(this,a),this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters,this._alphaState._blendEquationParameters)};var Xg;(function(a){a.LowPower="low-power",a.HighPerformance="high-performance"})(Xg||(Xg={}));var Zg;(function(a){a.DepthClipControl="depth-clip-control",a.Depth32FloatStencil8="depth32float-stencil8",a.TextureCompressionBC="texture-compression-bc",a.TextureCompressionBCSliced3D="texture-compression-bc-sliced-3d",a.TextureCompressionETC2="texture-compression-etc2",a.TextureCompressionASTC="texture-compression-astc",a.TextureCompressionASTCSliced3D="texture-compression-astc-sliced-3d",a.TimestampQuery="timestamp-query",a.IndirectFirstInstance="indirect-first-instance",a.ShaderF16="shader-f16",a.RG11B10UFloatRenderable="rg11b10ufloat-renderable",a.BGRA8UnormStorage="bgra8unorm-storage",a.Float32Filterable="float32-filterable",a.Float32Blendable="float32-blendable",a.ClipDistances="clip-distances",a.DualSourceBlending="dual-source-blending"})(Zg||(Zg={}));var qg;(function(a){a.Unmapped="unmapped",a.Pending="pending",a.Mapped="mapped"})(qg||(qg={}));var tt;(function(a){a[a.MapRead=1]="MapRead",a[a.MapWrite=2]="MapWrite",a[a.CopySrc=4]="CopySrc",a[a.CopyDst=8]="CopyDst",a[a.Index=16]="Index",a[a.Vertex=32]="Vertex",a[a.Uniform=64]="Uniform",a[a.Storage=128]="Storage",a[a.Indirect=256]="Indirect",a[a.QueryResolve=512]="QueryResolve"})(tt||(tt={}));var Qg;(function(a){a[a.Read=1]="Read",a[a.Write=2]="Write"})(Qg||(Qg={}));var Kg;(function(a){a.E1d="1d",a.E2d="2d",a.E3d="3d"})(Kg||(Kg={}));var Jg;(function(a){a[a.CopySrc=1]="CopySrc",a[a.CopyDst=2]="CopyDst",a[a.TextureBinding=4]="TextureBinding",a[a.StorageBinding=8]="StorageBinding",a[a.RenderAttachment=16]="RenderAttachment"})(Jg||(Jg={}));var ex;(function(a){a.E1d="1d",a.E2d="2d",a.E2dArray="2d-array",a.Cube="cube",a.CubeArray="cube-array",a.E3d="3d"})(ex||(ex={}));var tx;(function(a){a.All="all",a.StencilOnly="stencil-only",a.DepthOnly="depth-only"})(tx||(tx={}));var ix;(function(a){a.R8Unorm="r8unorm",a.R8Snorm="r8snorm",a.R8Uint="r8uint",a.R8Sint="r8sint",a.R16Uint="r16uint",a.R16Sint="r16sint",a.R16Float="r16float",a.RG8Unorm="rg8unorm",a.RG8Snorm="rg8snorm",a.RG8Uint="rg8uint",a.RG8Sint="rg8sint",a.R16Unorm="r16unorm",a.R16Snorm="r16snorm",a.RG16Unorm="rg16unorm",a.RG16Snorm="rg16snorm",a.RGBA16Unorm="rgba16unorm",a.RGBA16Snorm="rgba16snorm",a.R32Uint="r32uint",a.R32Sint="r32sint",a.R32Float="r32float",a.RG16Uint="rg16uint",a.RG16Sint="rg16sint",a.RG16Float="rg16float",a.RGBA8Unorm="rgba8unorm",a.RGBA8UnormSRGB="rgba8unorm-srgb",a.RGBA8Snorm="rgba8snorm",a.RGBA8Uint="rgba8uint",a.RGBA8Sint="rgba8sint",a.BGRA8Unorm="bgra8unorm",a.BGRA8UnormSRGB="bgra8unorm-srgb",a.RGB9E5UFloat="rgb9e5ufloat",a.RGB10A2UINT="rgb10a2uint",a.RGB10A2Unorm="rgb10a2unorm",a.RG11B10UFloat="rg11b10ufloat",a.RG32Uint="rg32uint",a.RG32Sint="rg32sint",a.RG32Float="rg32float",a.RGBA16Uint="rgba16uint",a.RGBA16Sint="rgba16sint",a.RGBA16Float="rgba16float",a.RGBA32Uint="rgba32uint",a.RGBA32Sint="rgba32sint",a.RGBA32Float="rgba32float",a.Stencil8="stencil8",a.Depth16Unorm="depth16unorm",a.Depth24Plus="depth24plus",a.Depth24PlusStencil8="depth24plus-stencil8",a.Depth32Float="depth32float",a.BC1RGBAUnorm="bc1-rgba-unorm",a.BC1RGBAUnormSRGB="bc1-rgba-unorm-srgb",a.BC2RGBAUnorm="bc2-rgba-unorm",a.BC2RGBAUnormSRGB="bc2-rgba-unorm-srgb",a.BC3RGBAUnorm="bc3-rgba-unorm",a.BC3RGBAUnormSRGB="bc3-rgba-unorm-srgb",a.BC4RUnorm="bc4-r-unorm",a.BC4RSnorm="bc4-r-snorm",a.BC5RGUnorm="bc5-rg-unorm",a.BC5RGSnorm="bc5-rg-snorm",a.BC6HRGBUFloat="bc6h-rgb-ufloat",a.BC6HRGBFloat="bc6h-rgb-float",a.BC7RGBAUnorm="bc7-rgba-unorm",a.BC7RGBAUnormSRGB="bc7-rgba-unorm-srgb",a.ETC2RGB8Unorm="etc2-rgb8unorm",a.ETC2RGB8UnormSRGB="etc2-rgb8unorm-srgb",a.ETC2RGB8A1Unorm="etc2-rgb8a1unorm",a.ETC2RGB8A1UnormSRGB="etc2-rgb8a1unorm-srgb",a.ETC2RGBA8Unorm="etc2-rgba8unorm",a.ETC2RGBA8UnormSRGB="etc2-rgba8unorm-srgb",a.EACR11Unorm="eac-r11unorm",a.EACR11Snorm="eac-r11snorm",a.EACRG11Unorm="eac-rg11unorm",a.EACRG11Snorm="eac-rg11snorm",a.ASTC4x4Unorm="astc-4x4-unorm",a.ASTC4x4UnormSRGB="astc-4x4-unorm-srgb",a.ASTC5x4Unorm="astc-5x4-unorm",a.ASTC5x4UnormSRGB="astc-5x4-unorm-srgb",a.ASTC5x5Unorm="astc-5x5-unorm",a.ASTC5x5UnormSRGB="astc-5x5-unorm-srgb",a.ASTC6x5Unorm="astc-6x5-unorm",a.ASTC6x5UnormSRGB="astc-6x5-unorm-srgb",a.ASTC6x6Unorm="astc-6x6-unorm",a.ASTC6x6UnormSRGB="astc-6x6-unorm-srgb",a.ASTC8x5Unorm="astc-8x5-unorm",a.ASTC8x5UnormSRGB="astc-8x5-unorm-srgb",a.ASTC8x6Unorm="astc-8x6-unorm",a.ASTC8x6UnormSRGB="astc-8x6-unorm-srgb",a.ASTC8x8Unorm="astc-8x8-unorm",a.ASTC8x8UnormSRGB="astc-8x8-unorm-srgb",a.ASTC10x5Unorm="astc-10x5-unorm",a.ASTC10x5UnormSRGB="astc-10x5-unorm-srgb",a.ASTC10x6Unorm="astc-10x6-unorm",a.ASTC10x6UnormSRGB="astc-10x6-unorm-srgb",a.ASTC10x8Unorm="astc-10x8-unorm",a.ASTC10x8UnormSRGB="astc-10x8-unorm-srgb",a.ASTC10x10Unorm="astc-10x10-unorm",a.ASTC10x10UnormSRGB="astc-10x10-unorm-srgb",a.ASTC12x10Unorm="astc-12x10-unorm",a.ASTC12x10UnormSRGB="astc-12x10-unorm-srgb",a.ASTC12x12Unorm="astc-12x12-unorm",a.ASTC12x12UnormSRGB="astc-12x12-unorm-srgb",a.Depth32FloatStencil8="depth32float-stencil8"})(ix||(ix={}));var rx;(function(a){a.ClampToEdge="clamp-to-edge",a.Repeat="repeat",a.MirrorRepeat="mirror-repeat"})(rx||(rx={}));var sx;(function(a){a.Nearest="nearest",a.Linear="linear"})(sx||(sx={}));var nx;(function(a){a.Nearest="nearest",a.Linear="linear"})(nx||(nx={}));var ax;(function(a){a.Never="never",a.Less="less",a.Equal="equal",a.LessEqual="less-equal",a.Greater="greater",a.NotEqual="not-equal",a.GreaterEqual="greater-equal",a.Always="always"})(ax||(ax={}));var ox;(function(a){a[a.Vertex=1]="Vertex",a[a.Fragment=2]="Fragment",a[a.Compute=4]="Compute"})(ox||(ox={}));var lx;(function(a){a.Uniform="uniform",a.Storage="storage",a.ReadOnlyStorage="read-only-storage"})(lx||(lx={}));var ux;(function(a){a.Filtering="filtering",a.NonFiltering="non-filtering",a.Comparison="comparison"})(ux||(ux={}));var cx;(function(a){a.Float="float",a.UnfilterableFloat="unfilterable-float",a.Depth="depth",a.Sint="sint",a.Uint="uint"})(cx||(cx={}));var hx;(function(a){a.WriteOnly="write-only",a.ReadOnly="read-only",a.ReadWrite="read-write"})(hx||(hx={}));var dx;(function(a){a.Error="error",a.Warning="warning",a.Info="info"})(dx||(dx={}));var fx;(function(a){a.Validation="validation",a.Internal="internal"})(fx||(fx={}));var px;(function(a){a.Auto="auto"})(px||(px={}));var mx;(function(a){a.PointList="point-list",a.LineList="line-list",a.LineStrip="line-strip",a.TriangleList="triangle-list",a.TriangleStrip="triangle-strip"})(mx||(mx={}));var _x;(function(a){a.CCW="ccw",a.CW="cw"})(_x||(_x={}));var gx;(function(a){a.None="none",a.Front="front",a.Back="back"})(gx||(gx={}));var xx;(function(a){a[a.Red=1]="Red",a[a.Green=2]="Green",a[a.Blue=4]="Blue",a[a.Alpha=8]="Alpha",a[a.All=15]="All"})(xx||(xx={}));var Sx;(function(a){a.Zero="zero",a.One="one",a.Src="src",a.OneMinusSrc="one-minus-src",a.SrcAlpha="src-alpha",a.OneMinusSrcAlpha="one-minus-src-alpha",a.Dst="dst",a.OneMinusDst="one-minus-dst",a.DstAlpha="dst-alpha",a.OneMinusDstAlpha="one-minus-dst-alpha",a.SrcAlphaSaturated="src-alpha-saturated",a.Constant="constant",a.OneMinusConstant="one-minus-constant",a.Src1="src1",a.OneMinusSrc1="one-minus-src1",a.Src1Alpha="src1-alpha",a.OneMinusSrc1Alpha="one-minus-src1-alpha"})(Sx||(Sx={}));var vx;(function(a){a.Add="add",a.Subtract="subtract",a.ReverseSubtract="reverse-subtract",a.Min="min",a.Max="max"})(vx||(vx={}));var bx;(function(a){a.Keep="keep",a.Zero="zero",a.Replace="replace",a.Invert="invert",a.IncrementClamp="increment-clamp",a.DecrementClamp="decrement-clamp",a.IncrementWrap="increment-wrap",a.DecrementWrap="decrement-wrap"})(bx||(bx={}));var yx;(function(a){a.Uint16="uint16",a.Uint32="uint32"})(yx||(yx={}));var Tx;(function(a){a.Uint8x2="uint8x2",a.Uint8x4="uint8x4",a.Sint8x2="sint8x2",a.Sint8x4="sint8x4",a.Unorm8x2="unorm8x2",a.Unorm8x4="unorm8x4",a.Snorm8x2="snorm8x2",a.Snorm8x4="snorm8x4",a.Uint16x2="uint16x2",a.Uint16x4="uint16x4",a.Sint16x2="sint16x2",a.Sint16x4="sint16x4",a.Unorm16x2="unorm16x2",a.Unorm16x4="unorm16x4",a.Snorm16x2="snorm16x2",a.Snorm16x4="snorm16x4",a.Float16x2="float16x2",a.Float16x4="float16x4",a.Float32="float32",a.Float32x2="float32x2",a.Float32x3="float32x3",a.Float32x4="float32x4",a.Uint32="uint32",a.Uint32x2="uint32x2",a.Uint32x3="uint32x3",a.Uint32x4="uint32x4",a.Sint32="sint32",a.Sint32x2="sint32x2",a.Sint32x3="sint32x3",a.Sint32x4="sint32x4",a.UNORM10x10x10x2="unorm10-10-10-2"})(Tx||(Tx={}));var Cx;(function(a){a.Vertex="vertex",a.Instance="instance"})(Cx||(Cx={}));var Px;(function(a){a.Beginning="beginning",a.End="end"})(Px||(Px={}));var Ex;(function(a){a.Beginning="beginning",a.End="end"})(Ex||(Ex={}));var Ix;(function(a){a.Load="load",a.Clear="clear"})(Ix||(Ix={}));var Rx;(function(a){a.Store="store",a.Discard="discard"})(Rx||(Rx={}));var Mx;(function(a){a.Occlusion="occlusion",a.Timestamp="timestamp"})(Mx||(Mx={}));var Ax;(function(a){a.Opaque="opaque",a.Premultiplied="premultiplied"})(Ax||(Ax={}));var Dx;(function(a){a.Standard="standard",a.Extended="extended"})(Dx||(Dx={}));var Ox;(function(a){a.Unknown="unknown",a.Destroyed="destroyed"})(Ox||(Ox={}));var wx;(function(a){a.Validation="validation",a.OutOfMemory="out-of-memory",a.Internal="internal"})(wx||(wx={}));class Nt{constructor(){this.shaderLanguage=0}_addUniformToLeftOverUBO(e,t,i){let r=0;[e,t,r]=this._getArraySize(e,t,i);for(let s=0;s<this._webgpuProcessingContext.leftOverUniforms.length;s++)if(this._webgpuProcessingContext.leftOverUniforms[s].name===e)return;this._webgpuProcessingContext.leftOverUniforms.push({name:e,type:t,length:r})}_buildLeftOverUBO(){if(!this._webgpuProcessingContext.leftOverUniforms.length)return"";const e=Nt.LeftOvertUBOName;let t=this._webgpuProcessingContext.availableBuffers[e];return t||(t={binding:this._webgpuProcessingContext.getNextFreeUBOBinding()},this._webgpuProcessingContext.availableBuffers[e]=t,this._addBufferBindingDescription(e,t,"uniform",!0),this._addBufferBindingDescription(e,t,"uniform",!1)),this._generateLeftOverUBOCode(e,t)}_collectBindingNames(){for(let e=0;e<this._webgpuProcessingContext.bindGroupLayoutEntries.length;e++){const t=this._webgpuProcessingContext.bindGroupLayoutEntries[e];if(t===void 0){this._webgpuProcessingContext.bindGroupLayoutEntries[e]=[];continue}for(let i=0;i<t.length;i++){const r=this._webgpuProcessingContext.bindGroupLayoutEntries[e][i],s=this._webgpuProcessingContext.bindGroupLayoutEntryInfo[e][r.binding].name,n=this._webgpuProcessingContext.bindGroupLayoutEntryInfo[e][r.binding].nameInArrayOfTexture;r&&(r.texture||r.externalTexture||r.storageTexture?this._webgpuProcessingContext.textureNames.push(n):r.sampler?this._webgpuProcessingContext.samplerNames.push(s):r.buffer&&this._webgpuProcessingContext.bufferNames.push(s))}}}_preCreateBindGroupEntries(){const e=this._webgpuProcessingContext.bindGroupEntries;for(let t=0;t<this._webgpuProcessingContext.bindGroupLayoutEntries.length;t++){const i=this._webgpuProcessingContext.bindGroupLayoutEntries[t],r=[];for(let s=0;s<i.length;s++){const n=this._webgpuProcessingContext.bindGroupLayoutEntries[t][s];n.sampler||n.texture||n.storageTexture||n.externalTexture?r.push({binding:n.binding,resource:void 0}):n.buffer&&r.push({binding:n.binding,resource:{buffer:void 0,offset:0,size:0}})}e[t]=r}}_addTextureBindingDescription(e,t,i,r,s,n){let{groupIndex:o,bindingIndex:l}=t.textures[i];if(this._webgpuProcessingContext.bindGroupLayoutEntries[o]||(this._webgpuProcessingContext.bindGroupLayoutEntries[o]=[],this._webgpuProcessingContext.bindGroupLayoutEntryInfo[o]=[]),!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[o][l]){let u;r===null?u=this._webgpuProcessingContext.bindGroupLayoutEntries[o].push({binding:l,visibility:0,externalTexture:{}}):s?u=this._webgpuProcessingContext.bindGroupLayoutEntries[o].push({binding:l,visibility:0,storageTexture:{access:"write-only",format:s,viewDimension:r}}):u=this._webgpuProcessingContext.bindGroupLayoutEntries[o].push({binding:l,visibility:0,texture:{sampleType:t.sampleType,viewDimension:r,multisampled:!1}});const c=t.isTextureArray?e+i:e;this._webgpuProcessingContext.bindGroupLayoutEntryInfo[o][l]={name:e,index:u-1,nameInArrayOfTexture:c}}l=this._webgpuProcessingContext.bindGroupLayoutEntryInfo[o][l].index,n?this._webgpuProcessingContext.bindGroupLayoutEntries[o][l].visibility|=1:this._webgpuProcessingContext.bindGroupLayoutEntries[o][l].visibility|=2}_addSamplerBindingDescription(e,t,i){let{groupIndex:r,bindingIndex:s}=t.binding;if(this._webgpuProcessingContext.bindGroupLayoutEntries[r]||(this._webgpuProcessingContext.bindGroupLayoutEntries[r]=[],this._webgpuProcessingContext.bindGroupLayoutEntryInfo[r]=[]),!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[r][s]){const n=this._webgpuProcessingContext.bindGroupLayoutEntries[r].push({binding:s,visibility:0,sampler:{type:t.type}});this._webgpuProcessingContext.bindGroupLayoutEntryInfo[r][s]={name:e,index:n-1}}s=this._webgpuProcessingContext.bindGroupLayoutEntryInfo[r][s].index,i?this._webgpuProcessingContext.bindGroupLayoutEntries[r][s].visibility|=1:this._webgpuProcessingContext.bindGroupLayoutEntries[r][s].visibility|=2}_addBufferBindingDescription(e,t,i,r){let{groupIndex:s,bindingIndex:n}=t.binding;if(this._webgpuProcessingContext.bindGroupLayoutEntries[s]||(this._webgpuProcessingContext.bindGroupLayoutEntries[s]=[],this._webgpuProcessingContext.bindGroupLayoutEntryInfo[s]=[]),!this._webgpuProcessingContext.bindGroupLayoutEntryInfo[s][n]){const o=this._webgpuProcessingContext.bindGroupLayoutEntries[s].push({binding:n,visibility:0,buffer:{type:i}});this._webgpuProcessingContext.bindGroupLayoutEntryInfo[s][n]={name:e,index:o-1}}n=this._webgpuProcessingContext.bindGroupLayoutEntryInfo[s][n].index,r?this._webgpuProcessingContext.bindGroupLayoutEntries[s][n].visibility|=1:this._webgpuProcessingContext.bindGroupLayoutEntries[s][n].visibility|=2}}Nt.LeftOvertUBOName="LeftOver";Nt.InternalsUBOName="Internals";Nt.UniformSizes={bool:1,int:1,float:1,vec2:2,ivec2:2,uvec2:2,vec3:3,ivec3:3,uvec3:3,vec4:4,ivec4:4,uvec4:4,mat2:4,mat3:12,mat4:16,i32:1,u32:1,f32:1,mat2x2:4,mat3x3:12,mat4x4:16,mat2x2f:4,mat3x3f:12,mat4x4f:16,vec2i:2,vec3i:3,vec4i:4,vec2u:2,vec3u:3,vec4u:4,vec2f:2,vec3f:3,vec4f:4,vec2h:1,vec3h:2,vec4h:2};Nt._SamplerFunctionByWebGLSamplerType={sampler2D:"sampler2D",sampler2DArray:"sampler2DArray",sampler2DShadow:"sampler2DShadow",sampler2DArrayShadow:"sampler2DArrayShadow",samplerCube:"samplerCube",sampler3D:"sampler3D"};Nt._TextureTypeByWebGLSamplerType={sampler2D:"texture2D",sampler2DArray:"texture2DArray",sampler2DShadow:"texture2D",sampler2DArrayShadow:"texture2DArray",samplerCube:"textureCube",samplerCubeArray:"textureCubeArray",sampler3D:"texture3D"};Nt._GpuTextureViewDimensionByWebGPUTextureType={textureCube:"cube",textureCubeArray:"cube-array",texture2D:"2d",texture2DArray:"2d-array",texture3D:"3d"};Nt._SamplerTypeByWebGLSamplerType={sampler2DShadow:"samplerShadow",sampler2DArrayShadow:"samplerShadow"};Nt._IsComparisonSamplerByWebGPUSamplerType={samplerShadow:!0,samplerArrayShadow:!0,sampler:!1};class xO{get isAsync(){return!1}get isReady(){return!!this.stages}constructor(e,t){this.bindGroupLayouts={},this._name="unnamed",this.shaderProcessingContext=e,this._leftOverUniformsByName={},this.engine=t,this.vertexBufferKindToType={}}_handlesSpectorRebuildCallback(){}_fillEffectInformation(e,t,i,r,s,n,o,l){const u=this.engine;u._doNotHandleContextLost&&(e._fragmentSourceCode="",e._vertexSourceCode="");const c=this.shaderProcessingContext.availableTextures;let h;for(h=0;h<s.length;h++){const p=s[h],g=c[s[h]];g==null||g==null?(s.splice(h,1),h--):n[p]=h}for(const p of u.getAttributes(this,o))l.push(p);this.buildUniformLayout();const d=[],f=[];for(h=0;h<o.length;h++){const p=l[h];p>=0&&(d.push(o[h]),f.push(p))}this.shaderProcessingContext.attributeNamesFromEffect=d,this.shaderProcessingContext.attributeLocationsFromEffect=f}buildUniformLayout(){var e;if(this.shaderProcessingContext.leftOverUniforms.length){(e=this.uniformBuffer)==null||e.dispose(),this.uniformBuffer=new tn(this.engine,void 0,void 0,"leftOver-"+this._name);for(const t of this.shaderProcessingContext.leftOverUniforms){const i=t.type.replace(/^(.*?)(<.*>)?$/,"$1"),r=Nt.UniformSizes[i];this.uniformBuffer.addUniform(t.name,r,t.length),this._leftOverUniformsByName[t.name]=t.type}this.uniformBuffer.create()}}setEngine(e){this.engine=e}dispose(){this.uniformBuffer&&this.uniformBuffer.dispose()}setInt(e,t){!this.uniformBuffer||!this._leftOverUniformsByName[e]||this.uniformBuffer.updateInt(e,t)}setInt2(e,t,i){!this.uniformBuffer||!this._leftOverUniformsByName[e]||this.uniformBuffer.updateInt2(e,t,i)}setInt3(e,t,i,r){!this.uniformBuffer||!this._leftOverUniformsByName[e]||this.uniformBuffer.updateInt3(e,t,i,r)}setInt4(e,t,i,r,s){!this.uniformBuffer||!this._leftOverUniformsByName[e]||this.uniformBuffer.updateInt4(e,t,i,r,s)}setIntArray(e,t){!this.uniformBuffer||!this._leftOverUniformsByName[e]||this.uniformBuffer.updateIntArray(e,t)}setIntArray2(e,t){this.setIntArray(e,t)}setIntArray3(e,t){this.setIntArray(e,t)}setIntArray4(e,t){this.setIntArray(e,t)}setUInt(e,t){!this.uniformBuffer||!this._leftOverUniformsByName[e]||this.uniformBuffer.updateUInt(e,t)}setUInt2(e,t,i){!this.uniformBuffer||!this._leftOverUniformsByName[e]||this.uniformBuffer.updateUInt2(e,t,i)}setUInt3(e,t,i,r){!this.uniformBuffer||!this._leftOverUniformsByName[e]||this.uniformBuffer.updateUInt3(e,t,i,r)}setUInt4(e,t,i,r,s){!this.uniformBuffer||!this._leftOverUniformsByName[e]||this.uniformBuffer.updateUInt4(e,t,i,r,s)}setUIntArray(e,t){!this.uniformBuffer||!this._leftOverUniformsByName[e]||this.uniformBuffer.updateUIntArray(e,t)}setUIntArray2(e,t){this.setUIntArray(e,t)}setUIntArray3(e,t){this.setUIntArray(e,t)}setUIntArray4(e,t){this.setUIntArray(e,t)}setArray(e,t){!this.uniformBuffer||!this._leftOverUniformsByName[e]||this.uniformBuffer.updateArray(e,t)}setArray2(e,t){this.setArray(e,t)}setArray3(e,t){this.setArray(e,t)}setArray4(e,t){this.setArray(e,t)}setMatrices(e,t){!this.uniformBuffer||!this._leftOverUniformsByName[e]||this.uniformBuffer.updateMatrices(e,t)}setMatrix(e,t){!this.uniformBuffer||!this._leftOverUniformsByName[e]||this.uniformBuffer.updateMatrix(e,t)}setMatrix3x3(e,t){!this.uniformBuffer||!this._leftOverUniformsByName[e]||this.uniformBuffer.updateMatrix3x3(e,t)}setMatrix2x2(e,t){!this.uniformBuffer||!this._leftOverUniformsByName[e]||this.uniformBuffer.updateMatrix2x2(e,t)}setFloat(e,t){!this.uniformBuffer||!this._leftOverUniformsByName[e]||this.uniformBuffer.updateFloat(e,t)}setVector2(e,t){this.setFloat2(e,t.x,t.y)}setFloat2(e,t,i){!this.uniformBuffer||!this._leftOverUniformsByName[e]||this.uniformBuffer.updateFloat2(e,t,i)}setVector3(e,t){this.setFloat3(e,t.x,t.y,t.z)}setFloat3(e,t,i,r){!this.uniformBuffer||!this._leftOverUniformsByName[e]||this.uniformBuffer.updateFloat3(e,t,i,r)}setVector4(e,t){this.setFloat4(e,t.x,t.y,t.z,t.w)}setQuaternion(e,t){this.setFloat4(e,t.x,t.y,t.z,t.w)}setFloat4(e,t,i,r,s){!this.uniformBuffer||!this._leftOverUniformsByName[e]||this.uniformBuffer.updateFloat4(e,t,i,r,s)}setColor3(e,t){this.setFloat3(e,t.r,t.g,t.b)}setColor4(e,t,i){this.setFloat4(e,t.r,t.g,t.b,i)}setDirectColor4(e,t){this.setFloat4(e,t.r,t.g,t.b,t.a)}_getVertexShaderCode(){var e;return(e=this.sources)==null?void 0:e.vertex}_getFragmentShaderCode(){var e;return(e=this.sources)==null?void 0:e.fragment}}const SO=4,vO=65536,Nx={mat2:2,mat3:3,mat4:4,mat2x2:2,mat3x3:3,mat4x4:4};class Ki{static get KnownUBOs(){return Ki._SimplifiedKnownBindings?Ki._SimplifiedKnownUBOs:Ki._KnownUBOs}constructor(e,t=!1){this.vertexBufferKindToNumberOfComponents={},this.shaderLanguage=e,this._attributeNextLocation=0,this._varyingNextLocation=0,this.freeGroupIndex=0,this.freeBindingIndex=0,this.availableVaryings={},this.availableAttributes={},this.availableBuffers={},this.availableTextures={},this.availableSamplers={},this.orderedAttributes=[],this.bindGroupLayoutEntries=[],this.bindGroupLayoutEntryInfo=[],this.bindGroupEntries=[],this.bufferNames=[],this.textureNames=[],this.samplerNames=[],this.leftOverUniforms=[],t||this._findStartingGroupBinding()}_findStartingGroupBinding(){const e=Ki.KnownUBOs,t=[];for(const i in e){const r=e[i].binding;r.groupIndex!==-1&&(t[r.groupIndex]===void 0?t[r.groupIndex]=r.bindingIndex:t[r.groupIndex]=Math.max(t[r.groupIndex],r.bindingIndex))}this.freeGroupIndex=t.length-1,this.freeGroupIndex===0?(this.freeGroupIndex++,this.freeBindingIndex=0):this.freeBindingIndex=t[t.length-1]+1}getAttributeNextLocation(e,t=0){const i=this._attributeNextLocation;return this._attributeNextLocation+=(Nx[e]??1)*(t||1),i}getVaryingNextLocation(e,t=0){const i=this._varyingNextLocation;return this._varyingNextLocation+=(Nx[e]??1)*(t||1),i}getNextFreeUBOBinding(){return this._getNextFreeBinding(1)}_getNextFreeBinding(e){if(this.freeBindingIndex>vO-e&&(this.freeGroupIndex++,this.freeBindingIndex=0),this.freeGroupIndex===SO)throw"Too many textures or UBOs have been declared and it is not supported in WebGPU.";const t={groupIndex:this.freeGroupIndex,bindingIndex:this.freeBindingIndex};return this.freeBindingIndex+=e,t}}Ki._SimplifiedKnownBindings=!0;Ki._SimplifiedKnownUBOs={Scene:{binding:{groupIndex:0,bindingIndex:0}},Light0:{binding:{groupIndex:-1,bindingIndex:-1}},Light1:{binding:{groupIndex:-1,bindingIndex:-1}},Light2:{binding:{groupIndex:-1,bindingIndex:-1}},Light3:{binding:{groupIndex:-1,bindingIndex:-1}},Light4:{binding:{groupIndex:-1,bindingIndex:-1}},Light5:{binding:{groupIndex:-1,bindingIndex:-1}},Light6:{binding:{groupIndex:-1,bindingIndex:-1}},Light7:{binding:{groupIndex:-1,bindingIndex:-1}},Light8:{binding:{groupIndex:-1,bindingIndex:-1}},Light9:{binding:{groupIndex:-1,bindingIndex:-1}},Light10:{binding:{groupIndex:-1,bindingIndex:-1}},Light11:{binding:{groupIndex:-1,bindingIndex:-1}},Light12:{binding:{groupIndex:-1,bindingIndex:-1}},Light13:{binding:{groupIndex:-1,bindingIndex:-1}},Light14:{binding:{groupIndex:-1,bindingIndex:-1}},Light15:{binding:{groupIndex:-1,bindingIndex:-1}},Light16:{binding:{groupIndex:-1,bindingIndex:-1}},Light17:{binding:{groupIndex:-1,bindingIndex:-1}},Light18:{binding:{groupIndex:-1,bindingIndex:-1}},Light19:{binding:{groupIndex:-1,bindingIndex:-1}},Light20:{binding:{groupIndex:-1,bindingIndex:-1}},Light21:{binding:{groupIndex:-1,bindingIndex:-1}},Light22:{binding:{groupIndex:-1,bindingIndex:-1}},Light23:{binding:{groupIndex:-1,bindingIndex:-1}},Light24:{binding:{groupIndex:-1,bindingIndex:-1}},Light25:{binding:{groupIndex:-1,bindingIndex:-1}},Light26:{binding:{groupIndex:-1,bindingIndex:-1}},Light27:{binding:{groupIndex:-1,bindingIndex:-1}},Light28:{binding:{groupIndex:-1,bindingIndex:-1}},Light29:{binding:{groupIndex:-1,bindingIndex:-1}},Light30:{binding:{groupIndex:-1,bindingIndex:-1}},Light31:{binding:{groupIndex:-1,bindingIndex:-1}},Material:{binding:{groupIndex:-1,bindingIndex:-1}},Mesh:{binding:{groupIndex:-1,bindingIndex:-1}},Internals:{binding:{groupIndex:-1,bindingIndex:-1}}};Ki._KnownUBOs={Scene:{binding:{groupIndex:0,bindingIndex:0}},Light0:{binding:{groupIndex:1,bindingIndex:0}},Light1:{binding:{groupIndex:1,bindingIndex:1}},Light2:{binding:{groupIndex:1,bindingIndex:2}},Light3:{binding:{groupIndex:1,bindingIndex:3}},Light4:{binding:{groupIndex:1,bindingIndex:4}},Light5:{binding:{groupIndex:1,bindingIndex:5}},Light6:{binding:{groupIndex:1,bindingIndex:6}},Light7:{binding:{groupIndex:1,bindingIndex:7}},Light8:{binding:{groupIndex:1,bindingIndex:8}},Light9:{binding:{groupIndex:1,bindingIndex:9}},Light10:{binding:{groupIndex:1,bindingIndex:10}},Light11:{binding:{groupIndex:1,bindingIndex:11}},Light12:{binding:{groupIndex:1,bindingIndex:12}},Light13:{binding:{groupIndex:1,bindingIndex:13}},Light14:{binding:{groupIndex:1,bindingIndex:14}},Light15:{binding:{groupIndex:1,bindingIndex:15}},Light16:{binding:{groupIndex:1,bindingIndex:16}},Light17:{binding:{groupIndex:1,bindingIndex:17}},Light18:{binding:{groupIndex:1,bindingIndex:18}},Light19:{binding:{groupIndex:1,bindingIndex:19}},Light20:{binding:{groupIndex:1,bindingIndex:20}},Light21:{binding:{groupIndex:1,bindingIndex:21}},Light22:{binding:{groupIndex:1,bindingIndex:22}},Light23:{binding:{groupIndex:1,bindingIndex:23}},Light24:{binding:{groupIndex:1,bindingIndex:24}},Light25:{binding:{groupIndex:1,bindingIndex:25}},Light26:{binding:{groupIndex:1,bindingIndex:26}},Light27:{binding:{groupIndex:1,bindingIndex:27}},Light28:{binding:{groupIndex:1,bindingIndex:28}},Light29:{binding:{groupIndex:1,bindingIndex:29}},Light30:{binding:{groupIndex:1,bindingIndex:30}},Light31:{binding:{groupIndex:1,bindingIndex:31}},Material:{binding:{groupIndex:2,bindingIndex:0}},Mesh:{binding:{groupIndex:2,bindingIndex:1}},Internals:{binding:{groupIndex:2,bindingIndex:2}}};class bO extends Nt{constructor(){super(...arguments),this._missingVaryings=[],this._textureArrayProcessing=[],this._vertexIsGLES3=!1,this._fragmentIsGLES3=!1,this.shaderLanguage=0,this.parseGLES3=!0}_getArraySize(e,t,i){let r=0;const s=e.indexOf("["),n=e.indexOf("]");if(s>0&&n>0){const o=e.substring(s+1,n);r=+o,isNaN(r)&&(r=+i[o.trim()]),e=e.substring(0,s)}return[e,t,r]}initializeShaders(e){this._webgpuProcessingContext=e,this._missingVaryings.length=0,this._textureArrayProcessing.length=0,this.attributeKeywordName=void 0,this.varyingVertexKeywordName=void 0,this.varyingFragmentKeywordName=void 0}preProcessShaderCode(e,t){const i=`// Internals UBO
uniform ${Nt.InternalsUBOName} {
float yFactor_;
float textureOutputHeight_;
};
`,r=e.indexOf("// Internals UBO")!==-1;return t?(this._fragmentIsGLES3=e.indexOf("#version 3")!==-1,this._fragmentIsGLES3&&(this.varyingFragmentKeywordName="in"),r?e:i+`##INJECTCODE##
`+e):(this._vertexIsGLES3=e.indexOf("#version 3")!==-1,this._vertexIsGLES3&&(this.attributeKeywordName="in",this.varyingVertexKeywordName="out"),r?e:i+e)}varyingCheck(e,t){const i=/(flat\s)?\s*\bout\b/,r=/(flat\s)?\s*\bin\b/,s=/(flat\s)?\s*\bvarying\b/;return(t&&this._fragmentIsGLES3?r:!t&&this._vertexIsGLES3?i:s).test(e)}varyingProcessor(e,t,i){this._preProcessors=i;const r=/\s*(flat)?\s*out\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/gm,s=/\s*(flat)?\s*in\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/gm,n=/\s*(flat)?\s*varying\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/gm,l=(t&&this._fragmentIsGLES3?s:!t&&this._vertexIsGLES3?r:n).exec(e);if(l!==null){const u=l[1]??"",c=l[2],h=l[3];let d;t?(d=this._webgpuProcessingContext.availableVaryings[h],this._missingVaryings[d]="",d===void 0&&L.Warn(`Invalid fragment shader: The varying named "${h}" is not declared in the vertex shader! This declaration will be ignored.`)):(d=this._webgpuProcessingContext.getVaryingNextLocation(c,this._getArraySize(h,c,i)[2]),this._webgpuProcessingContext.availableVaryings[h]=d,this._missingVaryings[d]=`layout(location = ${d}) ${u} in ${c} ${h};`),e=e.replace(l[0],d===void 0?"":`layout(location = ${d}) ${u} ${t?"in":"out"} ${c} ${h};`)}return e}attributeProcessor(e,t){this._preProcessors=t;const i=/\s*in\s+(\S+)\s+(\S+)\s*;/gm,r=/\s*attribute\s+(\S+)\s+(\S+)\s*;/gm,n=(this._vertexIsGLES3?i:r).exec(e);if(n!==null){const o=n[1],l=n[2],u=this._webgpuProcessingContext.getAttributeNextLocation(o,this._getArraySize(l,o,t)[2]);this._webgpuProcessingContext.availableAttributes[l]=u,this._webgpuProcessingContext.orderedAttributes[u]=l;const c=this._webgpuProcessingContext.vertexBufferKindToNumberOfComponents[l];if(c!==void 0){const h=c<0?c===-1?"int":"ivec"+-c:c===1?"uint":"uvec"+c,d=`_int_${l}_`;e=e.replace(n[0],`layout(location = ${u}) in ${h} ${d}; ${o} ${l} = ${o}(${d});`)}else e=e.replace(n[0],`layout(location = ${u}) in ${o} ${l};`)}return e}uniformProcessor(e,t,i){this._preProcessors=i;const s=/\s*uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/gm.exec(e);if(s!==null){let n=s[1],o=s[2];if(n.indexOf("sampler")===0||n.indexOf("sampler")===1){let l=0;[o,n,l]=this._getArraySize(o,n,i);let u=this._webgpuProcessingContext.availableTextures[o];if(!u){u={autoBindSampler:!0,isTextureArray:l>0,isStorageTexture:!1,textures:[],sampleType:"float"};for(let R=0;R<(l||1);++R)u.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding())}const c=Nt._SamplerTypeByWebGLSamplerType[n]??"sampler",h=!!Nt._IsComparisonSamplerByWebGPUSamplerType[c],d=h?"comparison":"filtering",f=o+"Sampler";let p=this._webgpuProcessingContext.availableSamplers[f];p||(p={binding:this._webgpuProcessingContext.getNextFreeUBOBinding(),type:d});const g=n.charAt(0)==="u"?"u":n.charAt(0)==="i"?"i":"";g&&(n=n.substring(1));const _=h?"depth":g==="u"?"uint":g==="i"?"sint":"float";u.sampleType=_;const S=l>0,b=p.binding.groupIndex,y=p.binding.bindingIndex,T=Nt._SamplerFunctionByWebGLSamplerType[n],v=Nt._TextureTypeByWebGLSamplerType[n],E=Nt._GpuTextureViewDimensionByWebGPUTextureType[v];if(!S)l=1,e=`layout(set = ${b}, binding = ${y}) uniform ${c} ${f};
                        layout(set = ${u.textures[0].groupIndex}, binding = ${u.textures[0].bindingIndex}) uniform ${g}${v} ${o}Texture;
                        #define ${o} ${g}${T}(${o}Texture, ${f})`;else{const R=[];R.push(`layout(set = ${b}, binding = ${y}) uniform ${g}${c} ${f};`),e=`
`;for(let O=0;O<l;++O){const w=u.textures[O].groupIndex,M=u.textures[O].bindingIndex;R.push(`layout(set = ${w}, binding = ${M}) uniform ${v} ${o}Texture${O};`),e+=`${O>0?`
`:""}#define ${o}${O} ${g}${T}(${o}Texture${O}, ${f})`}e=R.join(`
`)+e,this._textureArrayProcessing.push(o)}this._webgpuProcessingContext.availableTextures[o]=u,this._webgpuProcessingContext.availableSamplers[f]=p,this._addSamplerBindingDescription(f,p,!t);for(let R=0;R<l;++R)this._addTextureBindingDescription(o,u,R,E,null,!t)}else this._addUniformToLeftOverUBO(o,n,i),e=""}return e}uniformBufferProcessor(e,t){const r=/uniform\s+(\w+)/gm.exec(e);if(r!==null){const s=r[1];let n=this._webgpuProcessingContext.availableBuffers[s];if(!n){const o=Ki.KnownUBOs[s];let l;o&&o.binding.groupIndex!==-1?l=o.binding:l=this._webgpuProcessingContext.getNextFreeUBOBinding(),n={binding:l},this._webgpuProcessingContext.availableBuffers[s]=n}this._addBufferBindingDescription(s,n,"uniform",!t),e=e.replace("uniform",`layout(set = ${n.binding.groupIndex}, binding = ${n.binding.bindingIndex}) uniform`)}return e}postProcessor(e,t,i,r,s){const n=e.search(/#extension.+GL_EXT_draw_buffers.+require/)!==-1,o=/#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;if(e=e.replace(o,""),e=e.replace(/texture2D\s*\(/g,"texture("),i){const l=e.indexOf("gl_FragCoord")>=0,u=`
                glFragCoord_ = gl_FragCoord;
                if (yFactor_ == 1.) {
                    glFragCoord_.y = textureOutputHeight_ - glFragCoord_.y;
                }
            `,c=l?`vec4 glFragCoord_;
`:"",h=e.search(/layout *\(location *= *0\) *out/g)!==-1;if(e=e.replace(/texture2DLodEXT\s*\(/g,"textureLod("),e=e.replace(/textureCubeLodEXT\s*\(/g,"textureLod("),e=e.replace(/textureCube\s*\(/g,"texture("),e=e.replace(/gl_FragDepthEXT/g,"gl_FragDepth"),e=e.replace(/gl_FragColor/g,"glFragColor"),e=e.replace(/gl_FragData/g,"glFragData"),e=e.replace(/gl_FragCoord/g,"glFragCoord_"),!this._fragmentIsGLES3)e=e.replace(/void\s+?main\s*\(/g,(n||h?"":`layout(location = 0) out vec4 glFragColor;
`)+"void main(");else{const d=/^\s*out\s+\S+\s+\S+\s*;/gm.exec(e);d!==null&&(e=e.substring(0,d.index)+"layout(location = 0) "+e.substring(d.index))}e=e.replace(/dFdy/g,"(-yFactor_)*dFdy"),e=e.replace("##INJECTCODE##",c),l&&(e=jl(e,"void main",u))}else if(e=e.replace(/gl_InstanceID/g,"gl_InstanceIndex"),e=e.replace(/gl_VertexID/g,"gl_VertexIndex"),t.indexOf("#define MULTIVIEW")!==-1)return`#extension GL_OVR_multiview2 : require
layout (num_views = 2) in;
`+e;if(!i){const l=e.lastIndexOf("}");e=e.substring(0,l),e+=`gl_Position.y *= yFactor_;
`,e+="}"}return e}_applyTextureArrayProcessing(e,t){const i=new RegExp(t+"\\s*\\[(.+)?\\]","gm");let r=i.exec(e);for(;r!==null;){const s=r[1];let n=+s;this._preProcessors&&isNaN(n)&&(n=+this._preProcessors[s.trim()]),e=e.replace(r[0],t+n),r=i.exec(e)}return e}_generateLeftOverUBOCode(e,t){let i=`layout(set = ${t.binding.groupIndex}, binding = ${t.binding.bindingIndex}) uniform ${e} {
    `;for(const r of this._webgpuProcessingContext.leftOverUniforms)r.length>0?i+=`    ${r.type} ${r.name}[${r.length}];
`:i+=`    ${r.type} ${r.name};
`;return i+=`};

`,i}finalizeShaders(e,t){for(let r=0;r<this._textureArrayProcessing.length;++r){const s=this._textureArrayProcessing[r];e=this._applyTextureArrayProcessing(e,s),t=this._applyTextureArrayProcessing(t,s)}for(let r=0;r<this._missingVaryings.length;++r){const s=this._missingVaryings[r];s&&s.length>0&&(t=s+`
`+t)}const i=this._buildLeftOverUBO();return e=i+e,t=i+t,this._collectBindingNames(),this._preCreateBindGroupEntries(),this._preProcessors=null,this._webgpuProcessingContext.vertexBufferKindToNumberOfComponents={},{vertexCode:e,fragmentCode:t}}}const Fx="fragmentOutputs.fragDepth",yO="uniforms",TO="internals",CO={texture_1d:"1d",texture_2d:"2d",texture_2d_array:"2d-array",texture_3d:"3d",texture_cube:"cube",texture_cube_array:"cube-array",texture_multisampled_2d:"2d",texture_depth_2d:"2d",texture_depth_2d_array:"2d-array",texture_depth_cube:"cube",texture_depth_cube_array:"cube-array",texture_depth_multisampled_2d:"2d",texture_storage_1d:"1d",texture_storage_2d:"2d",texture_storage_2d_array:"2d-array",texture_storage_3d:"3d",texture_external:null};class PO extends Nt{constructor(){super(...arguments),this.shaderLanguage=1,this.uniformRegexp=/uniform\s+(\w+)\s*:\s*(.+)\s*;/,this.textureRegexp=/var\s+(\w+)\s*:\s*((array<\s*)?(texture_\w+)\s*(<\s*(.+)\s*>)?\s*(,\s*\w+\s*>\s*)?);/,this.noPrecision=!0,this.pureMode=!1}preProcessor(e,t,i,r,s){for(const n in i){if(n==="__VERSION__")continue;const o=i[n];(!isNaN(parseInt(o))||!isNaN(parseFloat(o)))&&(e=`const ${n} = ${o};
`+e)}return e}_getArraySize(e,t,i){let r=0;const s=t.lastIndexOf(">");if(t.indexOf("array")>=0&&s>0){let n=s;for(;n>0&&t.charAt(n)!==" "&&t.charAt(n)!==",";)n--;const o=t.substring(n+1,s);for(r=+o,isNaN(r)&&(r=+i[o.trim()]);n>0&&(t.charAt(n)===" "||t.charAt(n)===",");)n--;t=t.substring(t.indexOf("<")+1,n+1)}return[e,t,r]}initializeShaders(e){this._webgpuProcessingContext=e,this._attributesInputWGSL=[],this._attributesWGSL=[],this._attributesConversionCodeWGSL=[],this._hasNonFloatAttribute=!1,this._varyingsWGSL=[],this._varyingNamesWGSL=[],this._stridedUniformArrays=[]}preProcessShaderCode(e){const t=this.pureMode?"":`struct ${Nt.InternalsUBOName} {
  yFactor_: f32,
  textureOutputHeight_: f32,
};
var<uniform> ${TO} : ${Nt.InternalsUBOName};
`;return e.indexOf(t)!==-1?e:t+ah(e)}varyingCheck(e){return/(flat|linear|perspective)?\s*(center|centroid|sample)?\s*\bvarying\b/.test(e)}varyingProcessor(e,t,i){const s=/\s*(flat|linear|perspective)?\s*(center|centroid|sample)?\s*varying\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s*:\s*(.+)\s*;/gm.exec(e);if(s!==null){const n=s[1]??"perspective",o=s[2]??"center",l=s[4],u=s[3],c=n==="flat"?`@interpolate(${n})`:`@interpolate(${n}, ${o})`;let h;t?(h=this._webgpuProcessingContext.availableVaryings[u],h===void 0&&L.Warn(`Invalid fragment shader: The varying named "${u}" is not declared in the vertex shader! This declaration will be ignored.`)):(h=this._webgpuProcessingContext.getVaryingNextLocation(l,this._getArraySize(u,l,i)[2]),this._webgpuProcessingContext.availableVaryings[u]=h,this._varyingsWGSL.push(`  @location(${h}) ${c} ${u} : ${l},`),this._varyingNamesWGSL.push(u)),e=""}return e}attributeProcessor(e,t){const r=/\s*attribute\s+(\S+)\s*:\s*(.+)\s*;/gm.exec(e);if(r!==null){const s=r[2],n=r[1],o=this._webgpuProcessingContext.getAttributeNextLocation(s,this._getArraySize(n,s,t)[2]);this._webgpuProcessingContext.availableAttributes[n]=o,this._webgpuProcessingContext.orderedAttributes[o]=n;const l=this._webgpuProcessingContext.vertexBufferKindToNumberOfComponents[n];if(l!==void 0){const u=l<0?l===-1?"i32":"vec"+-l+"<i32>":l===1?"u32":"vec"+l+"<u32>",c=`_int_${n}_`;this._attributesInputWGSL.push(`@location(${o}) ${c} : ${u},`),this._attributesWGSL.push(`${n} : ${s},`),this._attributesConversionCodeWGSL.push(`vertexInputs.${n} = ${s}(vertexInputs_.${c});`),this._hasNonFloatAttribute=!0}else this._attributesInputWGSL.push(`@location(${o}) ${n} : ${s},`),this._attributesWGSL.push(`${n} : ${s},`),this._attributesConversionCodeWGSL.push(`vertexInputs.${n} = vertexInputs_.${n};`);e=""}return e}uniformProcessor(e,t,i){const r=this.uniformRegexp.exec(e);if(r!==null){const s=r[2],n=r[1];this._addUniformToLeftOverUBO(n,s,i),e=""}return e}textureProcessor(e,t,i){const r=this.textureRegexp.exec(e);if(r!==null){const s=r[1],n=r[2],o=!!r[3],l=r[4],u=l.indexOf("storage")>0,c=r[6],h=u?c.substring(0,c.indexOf(",")).trim():null;let d=o?this._getArraySize(s,n,i)[2]:0,f=this._webgpuProcessingContext.availableTextures[s];if(f)d=f.textures.length;else{f={isTextureArray:d>0,isStorageTexture:u,textures:[],sampleType:"float"},d=d||1;for(let S=0;S<d;++S)f.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding())}this._webgpuProcessingContext.availableTextures[s]=f;const p=l.indexOf("depth")>0,g=CO[l],_=p?"depth":c==="u32"?"uint":c==="i32"?"sint":"float";if(f.sampleType=_,g===void 0)throw`Can't get the texture dimension corresponding to the texture function "${l}"!`;for(let S=0;S<d;++S){const{groupIndex:b,bindingIndex:y}=f.textures[S];S===0&&(e=`@group(${b}) @binding(${y}) ${e}`),this._addTextureBindingDescription(s,f,S,g,h,!t)}}return e}postProcessor(e){const t=/#define (.+?) (.+?)$/gm;let i;for(;(i=t.exec(e))!==null;)e=e.replace(new RegExp(i[1],"g"),i[2]);return e}finalizeShaders(e,t){const i=t.indexOf("fragmentInputs.position")>=0&&!this.pureMode?`
            if (internals.yFactor_ == 1.) {
                fragmentInputs.position.y = internals.textureOutputHeight_ - fragmentInputs.position.y;
            }
        `:"";e=this._processSamplers(e,!0),t=this._processSamplers(t,!1),e=this._processCustomBuffers(e,!0),t=this._processCustomBuffers(t,!1);const r=this._buildLeftOverUBO();e=r+e,t=r+t,e=e.replace(/#define (\w+)\s+(\d+\.?\d*)/g,"const $1 = $2;"),e=e.replace(/#define /g,"//#define "),e=this._processStridedUniformArrays(e);let s=`struct VertexInputs {
  @builtin(vertex_index) vertexIndex : u32,
  @builtin(instance_index) instanceIndex : u32,
`;this._attributesInputWGSL.length>0&&(s+=this._attributesInputWGSL.join(`
`)),s+=`
};
var<private> vertexInputs`+(this._hasNonFloatAttribute?"_":"")+` : VertexInputs;
`,this._hasNonFloatAttribute&&(s+=`struct VertexInputs_ {
  vertexIndex : u32, instanceIndex : u32,
`,s+=this._attributesWGSL.join(`
`),s+=`
};
var<private> vertexInputs : VertexInputs_;
`);let n=`struct FragmentInputs {
  @builtin(position) position : vec4<f32>,
`;this._varyingsWGSL.length>0&&(n+=this._varyingsWGSL.join(`
`)),n+=`
};
var<private> vertexOutputs : FragmentInputs;
`,e=s+n+e;let o=`
  vertexInputs${this._hasNonFloatAttribute?"_":""} = input;
`;this._hasNonFloatAttribute&&(o+=`vertexInputs.vertexIndex = vertexInputs_.vertexIndex;
vertexInputs.instanceIndex = vertexInputs_.instanceIndex;
`,o+=this._attributesConversionCodeWGSL.join(`
`),o+=`
`);const l=this.pureMode?"  return vertexOutputs;":`  vertexOutputs.position.y = vertexOutputs.position.y * internals.yFactor_;
  return vertexOutputs;`;let u=e.indexOf("#define DISABLE_UNIFORMITY_ANALYSIS")!==-1;e=(u?`diagnostic(off, derivative_uniformity);
`:"")+`diagnostic(off, chromium.unreachable_code);
`+jl(e,"fn main",o,l),t=t.replace(/#define (\w+)\s+(\d+\.?\d*)/g,"const $1 = $2;"),t=t.replace(/#define /g,"//#define "),t=this._processStridedUniformArrays(t),this.pureMode||(t=t.replace(/dpdy/g,"(-internals.yFactor_)*dpdy"));let c=`struct FragmentInputs {
  @builtin(position) position : vec4<f32>,
  @builtin(front_facing) frontFacing : bool,
`;this._varyingsWGSL.length>0&&(c+=this._varyingsWGSL.join(`
`)),c+=`
};
var<private> fragmentInputs : FragmentInputs;
`;let h=`struct FragmentOutputs {
`;const d="fragmentOutputs\\.fragData";let f=t.match(new RegExp(d+"0","g")),p=0;if(f){h+=` @location(${p}) fragData0 : vec4<f32>,
`,p++;for(let T=1;T<8;T++)f=t.match(new RegExp(d+T,"g")),f&&(h+=` @location(${p}) fragData${p} : vec4<f32>,
`,p++);t.indexOf("MRT_AND_COLOR")!==-1&&(h+=`  @location(${p}) color : vec4<f32>,
`,p++)}const g=/oitDepthSampler/;f=t.match(g),f&&(h+=` @location(${p++}) depth : vec2<f32>,
`,h+=` @location(${p++}) frontColor : vec4<f32>,
`,h+=` @location(${p++}) backColor : vec4<f32>,
`),p===0&&(h+=`  @location(0) color : vec4<f32>,
`,p++);let _=!1,S=0;for(;!_&&(S=t.indexOf(Fx,S),!(S<0));){const T=S;for(_=!0;S>1&&t.charAt(S)!==`
`;){if(t.charAt(S)==="/"&&t.charAt(S-1)==="/"){_=!1;break}S--}S=T+Fx.length}_&&(h+=`  @builtin(frag_depth) fragDepth: f32,
`),h+=`};
var<private> fragmentOutputs : FragmentOutputs;
`,t=c+h+t;const b=`  fragmentInputs = input;
  `+i,y="  return fragmentOutputs;";return u=t.indexOf("#define DISABLE_UNIFORMITY_ANALYSIS")!==-1,t=(u?`diagnostic(off, derivative_uniformity);
`:"")+`diagnostic(off, chromium.unreachable_code);
`+jl(t,"fn main",b,y),this._collectBindingNames(),this._preCreateBindGroupEntries(),this._webgpuProcessingContext.vertexBufferKindToNumberOfComponents={},{vertexCode:e,fragmentCode:t}}_generateLeftOverUBOCode(e,t){let i="",r=`struct ${e} {
`;for(const s of this._webgpuProcessingContext.leftOverUniforms){const n=s.type.replace(/^(.*?)(<.*>)?$/,"$1"),o=Nt.UniformSizes[n];if(s.length>0)if(o<=2){const l=`${e}_${this._stridedUniformArrays.length}_strided_arr`;i+=`struct ${l} {
                        @size(16)
                        el: ${n},
                    }`,this._stridedUniformArrays.push(s.name),r+=` @align(16) ${s.name} : array<${l}, ${s.length}>,
`}else r+=` ${s.name} : array<${s.type}, ${s.length}>,
`;else r+=`  ${s.name} : ${s.type},
`}return r+=`};
`,r=`${i}
${r}`,r+=`@group(${t.binding.groupIndex}) @binding(${t.binding.bindingIndex}) var<uniform> ${yO} : ${e};
`,r}_processSamplers(e,t){const i=/var\s+(\w+Sampler)\s*:\s*(sampler|sampler_comparison)\s*;/gm;for(;;){const r=i.exec(e);if(r===null)break;const s=r[1],n=r[2],o=s.length-7,l=s.lastIndexOf("Sampler")===o?s.substring(0,o):null,u=n==="sampler_comparison"?"comparison":"filtering";if(l){const p=this._webgpuProcessingContext.availableTextures[l];p&&(p.autoBindSampler=!0)}let c=this._webgpuProcessingContext.availableSamplers[s];c||(c={binding:this._webgpuProcessingContext.getNextFreeUBOBinding(),type:u},this._webgpuProcessingContext.availableSamplers[s]=c),this._addSamplerBindingDescription(s,c,t);const h=e.substring(0,r.index),d=`@group(${c.binding.groupIndex}) @binding(${c.binding.bindingIndex}) `,f=e.substring(r.index);e=h+d+f,i.lastIndex+=d.length}return e}_processCustomBuffers(e,t){var r;const i=/var<\s*(uniform|storage)\s*(,\s*(read|read_write)\s*)?>\s+(\S+)\s*:\s*(\S+)\s*;/gm;for(;;){const s=i.exec(e);if(s===null)break;const n=s[1],o=s[3];let l=s[4];const u=s[5];let c=this._webgpuProcessingContext.availableBuffers[l];if(!c){const _=n==="uniform"?Ki.KnownUBOs[u]:null;let S;_?(l=u,S=_.binding,S.groupIndex===-1&&(S=(r=this._webgpuProcessingContext.availableBuffers[l])==null?void 0:r.binding,S||(S=this._webgpuProcessingContext.getNextFreeUBOBinding()))):S=this._webgpuProcessingContext.getNextFreeUBOBinding(),c={binding:S},this._webgpuProcessingContext.availableBuffers[l]=c}this._addBufferBindingDescription(l,this._webgpuProcessingContext.availableBuffers[l],o==="read_write"?"storage":n==="storage"?"read-only-storage":"uniform",t);const h=c.binding.groupIndex,d=c.binding.bindingIndex,f=e.substring(0,s.index),p=`@group(${h}) @binding(${d}) `,g=e.substring(s.index);e=f+p+g,i.lastIndex+=p.length}return e}_processStridedUniformArrays(e){for(const t of this._stridedUniformArrays)e=e.replace(new RegExp(`${t}\\s*\\[(.*?)\\]`,"g"),`${t}[$1].el`);return e}}class Vl{get underlyingResource(){return this._webgpuTexture}getMSAATexture(e){var t;return((t=this._webgpuMSAATexture)==null?void 0:t[e])??null}setMSAATexture(e,t){this._webgpuMSAATexture||(this._webgpuMSAATexture=[]),this._webgpuMSAATexture[t]=e}releaseMSAATexture(e){if(this._webgpuMSAATexture)if(e!==void 0)this._engine._textureHelper.releaseTexture(this._webgpuMSAATexture[e]),delete this._webgpuMSAATexture[e];else{for(const t of this._webgpuMSAATexture)this._engine._textureHelper.releaseTexture(t);this._webgpuMSAATexture=null}}constructor(e,t=null){this._engine=e,this._originalFormatIsRGB=!1,this.format="rgba8unorm",this.textureUsages=0,this.textureAdditionalUsages=0,this._webgpuTexture=t,this._webgpuMSAATexture=null,this.view=null,this.viewForWriting=null}set(e){this._webgpuTexture=e}setUsage(e,t,i,r,s,n,o,l){let u="2d",c=1;r?(u=i?"cube-array":"cube",c=6*(l||1)):s?(u="3d",c=1):i&&(u="2d-array",c=l);const h=et.GetDepthFormatOnly(this.format),d=et.HasDepthAndStencilAspects(this.format)?"depth-only":"all";this.createView({label:`TextureView${s?"3D":r?"Cube":"2D"}${i?"_Array"+c:""}_${n}x${o}_${t?"wmips":"womips"}_${this.format}_${u}`,format:h,dimension:u,mipLevelCount:t?Uo(Math.max(n,o))+1:1,baseArrayLayer:0,baseMipLevel:0,arrayLayerCount:c,aspect:d})}createView(e,t=!1){if(this.view=this._webgpuTexture.createView(e),t&&e){const i=e.mipLevelCount;e.mipLevelCount=1,this.viewForWriting=this._webgpuTexture.createView(e),e.mipLevelCount=i}}reset(){this._webgpuTexture=null,this._webgpuMSAATexture=null,this.view=null,this.viewForWriting=null}release(){var e,t;(e=this._webgpuTexture)==null||e.destroy(),this.releaseMSAATexture(),(t=this._copyInvertYTempTexture)==null||t.destroy(),this.reset()}}const EO=`
    const pos = array<vec2<f32>, 4>( vec2f(-1.0f, 1.0f),  vec2f(1.0f, 1.0f),  vec2f(-1.0f, -1.0f),  vec2f(1.0f, -1.0f));
    const tex = array<vec2<f32>, 4>( vec2f(0.0f, 0.0f),  vec2f(1.0f, 0.0f),  vec2f(0.0f, 1.0f),  vec2f(1.0f, 1.0f));

    varying vTex: vec2f;

    @vertex
    fn main(input : VertexInputs) -> FragmentInputs {
        vertexOutputs.vTex = tex[input.vertexIndex];
        vertexOutputs.position = vec4f(pos[input.vertexIndex], 0.0, 1.0);
    }
    `,IO=`
    var imgSampler: sampler;
    var img: texture_2d<f32>;

    varying vTex: vec2f;

    @fragment
    fn main(input: FragmentInputs) -> FragmentOutputs {
        fragmentOutputs.color = textureSample(img, imgSampler, input.vTex);
    }
    `,T0=`
    const pos = array<vec2<f32>, 4>( vec2f(-1.0f, 1.0f),  vec2f(1.0f, 1.0f),  vec2f(-1.0f, -1.0f),  vec2f(1.0f, -1.0f));
    const tex = array<vec2<f32>, 4>( vec2f(0.0f, 0.0f),  vec2f(1.0f, 0.0f),  vec2f(0.0f, 1.0f),  vec2f(1.0f, 1.0f));

    var img: texture_2d<f32>;

    #ifdef INVERTY
        varying vTextureSize: vec2f;
    #endif

    @vertex
    fn main(input : VertexInputs) -> FragmentInputs {
        #ifdef INVERTY
            vertexOutputs.vTextureSize = vec2f(textureDimensions(img, 0));
        #endif
        vertexOutputs.position =  vec4f(pos[input.vertexIndex], 0.0, 1.0);
    }
    `,RO=`
    var img: texture_2d<f32>;

    #ifdef INVERTY
        varying vTextureSize: vec2f;
    #endif

    @fragment
    fn main(input: FragmentInputs) -> FragmentOutputs {
    #ifdef INVERTY
        var color: vec4f = textureLoad(img, vec2i(i32(input.position.x), i32(input.vTextureSize.y - input.position.y)), 0);
    #else
        var color: vec4f = textureLoad(img, vec2i(input.position.xy), 0);
    #endif
    #ifdef PREMULTIPLYALPHA
        color = vec4f(color.rgb * color.a, color.a);
    #endif
        fragmentOutputs.color = color;
    }
    `,MO=T0,AO=`
    var img: texture_2d<f32>;
    uniform ofstX: f32;
    uniform ofstY: f32;
    uniform width: f32;
    uniform height: f32;

    #ifdef INVERTY
        varying vTextureSize: vec2f;
    #endif

    @fragment
    fn main(input: FragmentInputs) -> FragmentOutputs {
        if (input.position.x < uniforms.ofstX || input.position.x >= uniforms.ofstX + uniforms.width) {
            discard;
        }
        if (input.position.y < uniforms.ofstY || input.position.y >= uniforms.ofstY + uniforms.height) {
            discard;
        }
    #ifdef INVERTY
        var color: vec4f = textureLoad(img, vec2i(i32(input.position.x), i32(uniforms.ofstY + uniforms.height - (input.position.y - uniforms.ofstY))), 0);
    #else
        var color: vec4f = textureLoad(img, vec2i(input.position.xy), 0);
    #endif
    #ifdef PREMULTIPLYALPHA
        color = vec4f(color.rgb * color.a, color.a);
    #endif
        fragmentOutputs.color = color;
    }
    `,DO=`
    const pos = array<vec2<f32>, 4>( vec2f(-1.0f, 1.0f),  vec2f(1.0f, 1.0f),  vec2f(-1.0f, -1.0f),  vec2f(1.0f, -1.0f));

    @vertex
    fn main(input : VertexInputs) -> FragmentInputs {
        vertexOutputs.position =  vec4f(pos[input.vertexIndex], 0.0, 1.0);
    }
    `,OO=`
    uniform color: vec4f;


    @fragment
    fn main(input: FragmentInputs) -> FragmentOutputs {
        fragmentOutputs.color = uniforms.color;
    }
    `,wO=`
    struct VertexOutput {
        @builtin(position) Position : vec4<f32>,
        @location(0) fragUV : vec2<f32>
    }

    @vertex
    fn main(
        @builtin(vertex_index) VertexIndex : u32
    ) -> VertexOutput {
        var pos = array<vec2<f32>, 4>(
            vec2(-1.0,  1.0),
            vec2( 1.0,  1.0),
            vec2(-1.0, -1.0),
            vec2( 1.0, -1.0)
        );
        var tex = array<vec2<f32>, 4>(
            vec2(0.0, 0.0),
            vec2(1.0, 0.0),
            vec2(0.0, 1.0),
            vec2(1.0, 1.0)
        );

        var output: VertexOutput;

        output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);
        output.fragUV = tex[VertexIndex];

        return output;
    }
    `,NO=`
    @group(0) @binding(0) var videoSampler: sampler;
    @group(0) @binding(1) var videoTexture: texture_external;

    @fragment
    fn main(
        @location(0) fragUV: vec2<f32>
    ) -> @location(0) vec4<f32> {
        return textureSampleBaseClampToEdge(videoTexture, videoSampler, fragUV);
    }
    `,FO=`
    @group(0) @binding(0) var videoSampler: sampler;
    @group(0) @binding(1) var videoTexture: texture_external;

    @fragment
    fn main(
        @location(0) fragUV: vec2<f32>
    ) -> @location(0) vec4<f32> {
        return textureSampleBaseClampToEdge(videoTexture, videoSampler, vec2<f32>(fragUV.x, 1.0 - fragUV.y));
    }
    `;var Rr;(function(a){a[a.MipMap=0]="MipMap",a[a.InvertYPremultiplyAlpha=1]="InvertYPremultiplyAlpha",a[a.Clear=2]="Clear",a[a.InvertYPremultiplyAlphaWithOfst=3]="InvertYPremultiplyAlphaWithOfst"})(Rr||(Rr={}));var _a;(function(a){a[a.DontInvertY=0]="DontInvertY",a[a.InvertY=1]="InvertY"})(_a||(_a={}));const Lx=[{vertex:EO,fragment:IO},{vertex:T0,fragment:RO},{vertex:DO,fragment:OO},{vertex:MO,fragment:AO}],qr={"":0,r8unorm:1,r8uint:2,r8sint:3,r16uint:4,r16sint:5,r16float:6,rg8unorm:7,rg8uint:8,rg8sint:9,r32uint:10,r32sint:11,r32float:12,rg16uint:13,rg16sint:14,rg16float:15,rgba8unorm:16,"rgba8unorm-srgb":17,rgba8uint:18,rgba8sint:19,bgra8unorm:20,"bgra8unorm-srgb":21,rgb10a2uint:22,rgb10a2unorm:23,rg32uint:24,rg32sint:25,rg32float:26,rgba16uint:27,rgba16sint:28,rgba16float:29,rgba32uint:30,rgba32sint:31,rgba32float:32,stencil8:33,depth16unorm:34,depth24plus:35,"depth24plus-stencil8":36,depth32float:37,"depth32float-stencil8":38,r16unorm:39,rg16unorm:40,rgba16unorm:41,r16snorm:42,rg16snorm:43,rgba16snorm:44};class LO{constructor(e,t,i,r){if(this._pipelines={},this._compiledShaders=[],this._videoPipelines={},this._videoCompiledShaders=[],this._deferredReleaseTextures=[],this._engine=e,this._device=t,this._bufferManager=i,r.indexOf("rg11b10ufloat-renderable")!==-1){const s=Object.keys(qr);qr.rg11b10ufloat=qr[s[s.length-1]]+1}this._mipmapSampler=t.createSampler({minFilter:"linear"}),this._videoSampler=t.createSampler({minFilter:"linear"}),this._ubCopyWithOfst=this._bufferManager.createBuffer(4*4,tt.Uniform|tt.CopyDst,"UBCopyWithOffset").underlyingResource,this._getPipeline("rgba8unorm"),this._getVideoPipeline("rgba8unorm")}_getPipeline(e,t=Rr.MipMap,i){const r=t===Rr.MipMap?1:t===Rr.InvertYPremultiplyAlpha?((i.invertY?1:0)<<1)+((i.premultiplyAlpha?1:0)<<2):t===Rr.Clear?8:t===Rr.InvertYPremultiplyAlphaWithOfst?((i.invertY?1:0)<<4)+((i.premultiplyAlpha?1:0)<<5):0;this._pipelines[e]||(this._pipelines[e]=[]);let s=this._pipelines[e][r];if(!s){let n="";(t===Rr.InvertYPremultiplyAlpha||t===Rr.InvertYPremultiplyAlphaWithOfst)&&(i.invertY&&(n+=`#define INVERTY
`),i.premultiplyAlpha&&(n+=`#define PREMULTIPLYALPHA
`));let o=this._compiledShaders[r];if(!o){let u=Lx[t].vertex,c=Lx[t].fragment;const h={defines:n.split(`
`),indexParameters:null,isFragment:!1,shouldUseHighPrecisionShader:!0,processor:this._engine._getShaderProcessor(1),supportsUniformBuffers:!0,shadersRepository:"",includesShadersStore:{},version:(this._engine.version*100).toString(),platformName:this._engine.shaderPlatformName,processingContext:this._engine._getShaderProcessingContext(1,!0),isNDCHalfZRange:this._engine.isNDCHalfZRange,useReverseDepthBuffer:this._engine.useReverseDepthBuffer};Kb(h),h.processor.pureMode=!0,cg(u,h,g=>{u=g},this._engine),h.isFragment=!0,cg(c,h,g=>{c=g},this._engine);const d=Qb(u,c,h);h.processor.pureMode=!1;const f=this._device.createShaderModule({label:`BabylonWebGPUDevice${this._engine.uniqueId}_InternalVertexShader_${r}`,code:d.vertexCode}),p=this._device.createShaderModule({label:`BabylonWebGPUDevice${this._engine.uniqueId}_InternalFragmentShader_${r}`,code:d.fragmentCode});o=this._compiledShaders[r]=[f,p]}const l=this._device.createRenderPipeline({label:`BabylonWebGPUDevice${this._engine.uniqueId}_InternalPipeline_${e}_${r}`,layout:"auto",vertex:{module:o[0],entryPoint:"main"},fragment:{module:o[1],entryPoint:"main",targets:[{format:e}]},primitive:{topology:"triangle-strip",stripIndexFormat:"uint16"}});s=this._pipelines[e][r]=[l,l.getBindGroupLayout(0)]}return s}_getVideoPipeline(e,t=_a.DontInvertY){const i=t===_a.InvertY?1:0;this._videoPipelines[e]||(this._videoPipelines[e]=[]);let r=this._videoPipelines[e][i];if(!r){let s=this._videoCompiledShaders[i];if(!s){const o=this._device.createShaderModule({code:wO,label:`BabylonWebGPUDevice${this._engine.uniqueId}_CopyVideoToTexture_VertexShader`}),l=this._device.createShaderModule({code:i===0?NO:FO,label:`BabylonWebGPUDevice${this._engine.uniqueId}_CopyVideoToTexture_FragmentShader_${i===0?"DontInvertY":"InvertY"}`});s=this._videoCompiledShaders[i]=[o,l]}const n=this._device.createRenderPipeline({label:`BabylonWebGPUDevice${this._engine.uniqueId}_InternalVideoPipeline_${e}_${i===0?"DontInvertY":"InvertY"}`,layout:"auto",vertex:{module:s[0],entryPoint:"main"},fragment:{module:s[1],entryPoint:"main",targets:[{format:e}]},primitive:{topology:"triangle-strip",stripIndexFormat:"uint16"}});r=this._videoPipelines[e][i]=[n,n.getBindGroupLayout(0)]}return r}setCommandEncoder(e){this._commandEncoderForCreation=e}copyVideoToTexture(e,t,i,r=!1,s){var p,g;const n=s===void 0,[o,l]=this._getVideoPipeline(i,r?_a.InvertY:_a.DontInvertY);n&&(s=this._device.createCommandEncoder({})),(p=s.pushDebugGroup)==null||p.call(s,`copy video to texture - invertY=${r}`);const u=t._hardwareTexture,c={label:`BabylonWebGPUDevice${this._engine.uniqueId}_copyVideoToTexture_${i}_${r?"InvertY":"DontInvertY"}${t.label?"_"+t.label:""}`,colorAttachments:[{view:u.underlyingResource.createView({format:i,dimension:"2d",mipLevelCount:1,baseArrayLayer:0,baseMipLevel:0,arrayLayerCount:1,aspect:"all"}),loadOp:"load",storeOp:"store"}]},h=s.beginRenderPass(c),d={layout:l,entries:[{binding:0,resource:this._videoSampler},{binding:1,resource:this._device.importExternalTexture({source:e.underlyingResource})}]},f=this._device.createBindGroup(d);h.setPipeline(o),h.setBindGroup(0,f),h.draw(4,1,0,0),h.end(),(g=s.popDebugGroup)==null||g.call(s),n&&(this._device.queue.submit([s.finish()]),s=null)}invertYPreMultiplyAlpha(e,t,i,r,s=!1,n=!1,o=0,l=0,u=1,c=0,h=0,d=0,f=0,p,g){var M,G;const _=d!==0,S=p===void 0,[b,y]=this._getPipeline(r,_?Rr.InvertYPremultiplyAlphaWithOfst:Rr.InvertYPremultiplyAlpha,{invertY:s,premultiplyAlpha:n});o=Math.max(o,0),S&&(p=this._device.createCommandEncoder({})),(M=p.pushDebugGroup)==null||M.call(p,`internal process texture - invertY=${s} premultiplyAlpha=${n}`);let T;if(et.IsHardwareTexture(e)?(T=e.underlyingResource,s&&!n&&u===1&&o===0||(e=void 0)):(T=e,e=void 0),!T)return;_&&this._bufferManager.setRawData(this._ubCopyWithOfst,0,new Float32Array([c,h,d,f]),0,4*4);const v=e,E=(v==null?void 0:v._copyInvertYTempTexture)??this.createTexture({width:t,height:i,layers:1},!1,!1,!1,!1,!1,r,1,p,21,void 0,"TempTextureForCopyWithInvertY"),R=(v==null?void 0:v._copyInvertYRenderPassDescr)??{label:`BabylonWebGPUDevice${this._engine.uniqueId}_invertYPreMultiplyAlpha_${r}_${s?"InvertY":"DontInvertY"}_${n?"PremultiplyAlpha":"DontPremultiplyAlpha"}`,colorAttachments:[{view:E.createView({format:r,dimension:"2d",baseMipLevel:0,mipLevelCount:1,arrayLayerCount:1,baseArrayLayer:0}),loadOp:"load",storeOp:"store"}]},O=p.beginRenderPass(R);let w=_?v==null?void 0:v._copyInvertYBindGroupWithOfst:v==null?void 0:v._copyInvertYBindGroup;if(!w){const H={layout:y,entries:[{binding:0,resource:T.createView({format:r,dimension:"2d",baseMipLevel:l,mipLevelCount:1,arrayLayerCount:u,baseArrayLayer:o})}]};_&&H.entries.push({binding:1,resource:{buffer:this._ubCopyWithOfst}}),w=this._device.createBindGroup(H)}O.setPipeline(b),O.setBindGroup(0,w),O.draw(4,1,0,0),O.end(),p.copyTextureToTexture({texture:E},{texture:T,mipLevel:l,origin:{x:0,y:0,z:o}},{width:d||t,height:f||i,depthOrArrayLayers:1}),v?(v._copyInvertYTempTexture=E,v._copyInvertYRenderPassDescr=R,_?v._copyInvertYBindGroupWithOfst=w:v._copyInvertYBindGroup=w):this._deferredReleaseTextures.push([E,null]),(G=p.popDebugGroup)==null||G.call(p),S&&(this._device.queue.submit([p.finish()]),p=null)}createTexture(e,t=!1,i=!1,r=!1,s=!1,n=!1,o="rgba8unorm",l=1,u,c=-1,h=0,d){l=et.GetSample(l);const f=e.layers||1,p={width:e.width,height:e.height,depthOrArrayLayers:f},g=qr[o]?16:0,_=et.IsCompressedFormat(o),S=t?et.ComputeNumMipmapLevels(e.width,e.height):1,b=c>=0?c:7;h|=t&&!_?1|g:0,!_&&!n&&(h|=g|2);const y=this._device.createTexture({label:`BabylonWebGPUDevice${this._engine.uniqueId}_Texture${n?"3D":"2D"}_${d?d+"_":""}${p.width}x${p.height}x${p.depthOrArrayLayers}_${t?"wmips":"womips"}_${o}_samples${l}`,size:p,dimension:n?"3d":"2d",format:o,usage:b|h,sampleCount:l,mipLevelCount:S});return et.IsImageBitmap(e)&&(this.updateTexture(e,y,e.width,e.height,f,o,0,0,r,s,0,0),t&&i&&this.generateMipmaps(y,o,S,0,n,u)),y}createCubeTexture(e,t=!1,i=!1,r=!1,s=!1,n="rgba8unorm",o=1,l,u=-1,c=0,h){o=et.GetSample(o);const d=et.IsImageBitmapArray(e)?e[0].width:e.width,f=et.IsImageBitmapArray(e)?e[0].height:e.height,p=qr[n]?16:0,g=et.IsCompressedFormat(n),_=t?et.ComputeNumMipmapLevels(d,f):1,S=u>=0?u:7;c|=t&&!g?1|p:0,g||(c|=p|2);const b=this._device.createTexture({label:`BabylonWebGPUDevice${this._engine.uniqueId}_TextureCube_${h?h+"_":""}${d}x${f}x6_${t?"wmips":"womips"}_${n}_samples${o}`,size:{width:d,height:f,depthOrArrayLayers:6},dimension:"2d",format:n,usage:S|c,sampleCount:o,mipLevelCount:_});return et.IsImageBitmapArray(e)&&(this.updateCubeTextures(e,b,d,f,n,r,s,0,0),t&&i&&this.generateCubeMipmaps(b,n,_,l)),b}generateCubeMipmaps(e,t,i,r){var n,o;const s=r===void 0;s&&(r=this._device.createCommandEncoder({})),(n=r.pushDebugGroup)==null||n.call(r,`create cube mipmaps - ${i} levels`);for(let l=0;l<6;++l)this.generateMipmaps(e,t,i,l,!1,r);(o=r.popDebugGroup)==null||o.call(r),s&&(this._device.queue.submit([r.finish()]),r=null)}generateMipmaps(e,t,i,r=0,s=!1,n){var d,f,p,g;const o=n===void 0,[l,u]=this._getPipeline(t);r=Math.max(r,0),o&&(n=this._device.createCommandEncoder({})),(d=n.pushDebugGroup)==null||d.call(n,`create mipmaps for face #${r} - ${i} levels`);let c;if(et.IsHardwareTexture(e)?(c=e.underlyingResource,e._mipmapGenRenderPassDescr=e._mipmapGenRenderPassDescr||[],e._mipmapGenBindGroup=e._mipmapGenBindGroup||[]):(c=e,e=void 0),!c)return;const h=e;for(let _=1;_<i;++_){const S=((f=h==null?void 0:h._mipmapGenRenderPassDescr[r])==null?void 0:f[_-1])??{label:`BabylonWebGPUDevice${this._engine.uniqueId}_generateMipmaps_${t}_faceIndex${r}_level${_}`,colorAttachments:[{view:c.createView({format:t,dimension:s?"3d":"2d",baseMipLevel:_,mipLevelCount:1,arrayLayerCount:1,baseArrayLayer:r}),loadOp:"load",storeOp:"store"}]};h&&(h._mipmapGenRenderPassDescr[r]=h._mipmapGenRenderPassDescr[r]||[],h._mipmapGenRenderPassDescr[r][_-1]=S);const b=n.beginRenderPass(S),y=((p=h==null?void 0:h._mipmapGenBindGroup[r])==null?void 0:p[_-1])??this._device.createBindGroup({layout:u,entries:[{binding:0,resource:c.createView({format:t,dimension:s?"3d":"2d",baseMipLevel:_-1,mipLevelCount:1,arrayLayerCount:1,baseArrayLayer:r})},{binding:1,resource:this._mipmapSampler}]});h&&(h._mipmapGenBindGroup[r]=h._mipmapGenBindGroup[r]||[],h._mipmapGenBindGroup[r][_-1]=y),b.setPipeline(l),b.setBindGroup(0,y),b.draw(4,1,0,0),b.end()}(g=n.popDebugGroup)==null||g.call(n),o&&(this._device.queue.submit([n.finish()]),n=null)}createGPUTextureForInternalTexture(e,t,i,r,s,n){e._hardwareTexture||(e._hardwareTexture=new Vl(this._engine)),t===void 0&&(t=e.width),i===void 0&&(i=e.height),r===void 0&&(r=e.depth);const o=e._hardwareTexture,l=((s??0)&1)!==0;o.format=et.GetWebGPUTextureFormat(e.type,e.format,e._useSRGBBuffer),o.textureUsages=e._source===5||e.source===6?21:e._source===12?20:-1,o.textureAdditionalUsages=l?8:0;const u=e.generateMipMaps,c=r||1;let h;if(e._maxLodLevel!==null?h=e._maxLodLevel:h=u?et.ComputeNumMipmapLevels(t,i):1,e.isCube){const d=this.createCubeTexture({width:t,height:i},e.generateMipMaps,e.generateMipMaps,e.invertY,!1,o.format,1,this._commandEncoderForCreation,o.textureUsages,o.textureAdditionalUsages,e.label);o.set(d);const f=e.is3D?1:c,p=et.GetDepthFormatOnly(o.format),g=et.HasDepthAndStencilAspects(o.format)?"depth-only":"all",_=e.is2DArray?"cube-array":"cube";o.createView({label:`BabylonWebGPUDevice${this._engine.uniqueId}_TextureViewCube${e.is2DArray?"_Array"+f:""}_${t}x${i}_${u?"wmips":"womips"}_${p}_${_}_${g}_${e.label??"noname"}`,format:p,dimension:_,mipLevelCount:h,baseArrayLayer:0,baseMipLevel:0,arrayLayerCount:6,aspect:g},l)}else{const d=this.createTexture({width:t,height:i,layers:c},e.generateMipMaps,e.generateMipMaps,e.invertY,!1,e.is3D,o.format,1,this._commandEncoderForCreation,o.textureUsages,o.textureAdditionalUsages,e.label);o.set(d);const f=e.is3D?1:c,p=et.GetDepthFormatOnly(o.format),g=et.HasDepthAndStencilAspects(o.format)?"depth-only":"all",_=e.is2DArray?"2d-array":e.is3D?"3d":"2d";o.createView({label:`BabylonWebGPUDevice${this._engine.uniqueId}_TextureView${e.is3D?"3D":"2D"}${e.is2DArray?"_Array"+f:""}_${t}x${i}${e.is3D?"x"+c:""}_${u?"wmips":"womips"}_${p}_${_}_${g}_${e.label??"noname"}`,format:p,dimension:_,mipLevelCount:h,baseArrayLayer:0,baseMipLevel:0,arrayLayerCount:f,aspect:g},l)}return e.width=e.baseWidth=t,e.height=e.baseHeight=i,e.depth=e.baseDepth=r,n||this.createMSAATexture(e,e.samples),o}createMSAATexture(e,t,i=!0,r=0){const s=e._hardwareTexture;if(i&&(s==null||s.releaseMSAATexture()),!s||(t??1)<=1)return;const n=e.width,o=e.height,l=this.createTexture({width:n,height:o,layers:1},!1,!1,!1,!1,!1,s.format,t,this._commandEncoderForCreation,16,0,e.label?"MSAA_"+e.label:"MSAA");s.setMSAATexture(l,r)}updateCubeTextures(e,t,i,r,s,n=!1,o=!1,l=0,u=0){const c=[0,3,1,4,2,5];for(let h=0;h<c.length;++h){const d=e[c[h]];this.updateTexture(d,t,i,r,1,s,h,0,n,o,l,u)}}updateTexture(e,t,i,r,s,n,o=0,l=0,u=!1,c=!1,h=0,d=0,f){const p=et.IsInternalTexture(t)?t._hardwareTexture.underlyingResource:t,g=et.GetBlockInformationFromFormat(n),_=et.IsInternalTexture(t)?t._hardwareTexture:t,S={texture:p,origin:{x:h,y:d,z:Math.max(o,0)},mipLevel:l,premultipliedAlpha:c},b={width:Math.ceil(i/g.width)*g.width,height:Math.ceil(r/g.height)*g.height,depthOrArrayLayers:s||1};if(e.byteLength!==void 0){e=e;const y=Math.ceil(i/g.width)*g.length;if(Math.ceil(y/256)*256===y){const v=this._device.createCommandEncoder({}),E=this._bufferManager.createRawBuffer(e.byteLength,tt.MapWrite|tt.CopySrc,!0,"TempBufferForUpdateTexture"+(p?"_"+p.label:"")),R=E.getMappedRange();new Uint8Array(R).set(e),E.unmap(),v.copyBufferToTexture({buffer:E,offset:0,bytesPerRow:y,rowsPerImage:r},S,b),this._device.queue.submit([v.finish()]),this._bufferManager.releaseBuffer(E)}else this._device.queue.writeTexture(S,e,{offset:0,bytesPerRow:y,rowsPerImage:r},b);if(u||c)if(et.IsInternalTexture(t)){const v=h===0&&d===0&&i===t.width&&r===t.height;this.invertYPreMultiplyAlpha(_,t.width,t.height,n,u,c,o,l,s||1,h,d,v?0:i,v?0:r,void 0,f)}else throw"updateTexture: Can't process the texture data because a GPUTexture was provided instead of an InternalTexture!"}else e=e,this._device.queue.copyExternalImageToTexture({source:e,flipY:u},S,b)}readPixels(e,t,i,r,s,n,o=0,l=0,u=null,c=!1){const h=et.GetBlockInformationFromFormat(n),d=Math.ceil(r/h.width)*h.length,f=Math.ceil(d/256)*256,p=f*s,g=this._bufferManager.createRawBuffer(p,tt.MapRead|tt.CopyDst,void 0,"TempBufferForReadPixels"+(e.label?"_"+e.label:"")),_=this._device.createCommandEncoder({});return _.copyTextureToBuffer({texture:e,mipLevel:l,origin:{x:t,y:i,z:Math.max(o,0)}},{buffer:g,offset:0,bytesPerRow:f},{width:r,height:s,depthOrArrayLayers:1}),this._device.queue.submit([_.finish()]),this._bufferManager.readDataFromBuffer(g,p,r,s,d,f,et.GetTextureTypeFromFormat(n),0,u,!0,c)}releaseTexture(e){if(et.IsInternalTexture(e)){const t=e._hardwareTexture,i=e._irradianceTexture;this._deferredReleaseTextures.push([t,i])}else this._deferredReleaseTextures.push([e,null])}destroyDeferredTextures(){for(let e=0;e<this._deferredReleaseTextures.length;++e){const[t,i]=this._deferredReleaseTextures[e];t&&(et.IsHardwareTexture(t)?t.release():t.destroy()),i==null||i.dispose()}this._deferredReleaseTextures.length=0}}class BO extends ry{set buffer(e){this._buffer=e}constructor(e,t=0){super(),this.engineId=-1,this.capacity=t,e&&(this._buffer=e)}get underlyingResource(){return this._buffer}}class Yl{static _IsGPUBuffer(e){return e.underlyingResource===void 0}static _FlagsToString(e,t=""){let i=t;for(let r=0;r<=9;++r)e&1<<r&&(i&&(i+="_"),i+=tt[1<<r]);return i}constructor(e,t){this._deferredReleaseBuffers=[],this._engine=e,this._device=t}createRawBuffer(e,t,i=!1,r){const s=e.byteLength!==void 0?e.byteLength+3&-4:e+3&-4,n={label:"BabylonWebGPUDevice"+this._engine.uniqueId+"_"+Yl._FlagsToString(t,r??"Buffer")+"_size"+s,mappedAtCreation:i,size:s,usage:t};return this._device.createBuffer(n)}createBuffer(e,t,i){const r=e.byteLength!==void 0,s=new BO,n="DataBufferUniqueId="+s.uniqueId;return s.buffer=this.createRawBuffer(e,t,void 0,i?n+"-"+i:n),s.references=1,s.capacity=r?e.byteLength:e,s.engineId=this._engine.uniqueId,r&&this.setSubData(s,0,e),s}setRawData(e,t,i,r,s){r+=i.byteOffset,this._device.queue.writeBuffer(e,t,i.buffer,r,s)}setSubData(e,t,i,r=0,s=0){const n=e.underlyingResource;s=s||i.byteLength-r;const o=t&3;r-=o,t-=o;const l=s;if(s=s+o+3&-4,i.buffer.byteLength-i.byteOffset<s){const c=new Uint8Array(s);c.set(new Uint8Array(i.buffer,i.byteOffset+r,l)),i=c,r=0}this.setRawData(n,t,i,r,s)}_getHalfFloatAsFloatRGBAArrayBuffer(e,t,i){i||(i=new Float32Array(e));const r=new Uint16Array(t);for(;e--;)i[e]=GR(r[e]);return i}readDataFromBuffer(e,t,i,r,s,n,o=0,l=0,u=null,c=!0,h=!1){const d=o===1?2:o===2?1:0,f=this._engine.uniqueId;return new Promise((p,g)=>{e.mapAsync(1,l,t).then(()=>{const _=e.getMappedRange(l,t);let S=u;if(h)S===null?S=hg(o,t,!0,_):S=hg(o,S.buffer,void 0,_);else if(S===null)switch(d){case 0:S=new Uint8Array(t),S.set(new Uint8Array(_));break;case 1:S=this._getHalfFloatAsFloatRGBAArrayBuffer(t/2,_);break;case 2:S=new Float32Array(t/4),S.set(new Float32Array(_));break}else switch(d){case 0:S=new Uint8Array(S.buffer),S.set(new Uint8Array(_));break;case 1:S=this._getHalfFloatAsFloatRGBAArrayBuffer(t/2,_,u);break;case 2:S=new Float32Array(S.buffer),S.set(new Float32Array(_));break}if(s!==n){d===1&&!h&&(s*=2,n*=2);const b=new Uint8Array(S.buffer);let y=s,T=0;for(let v=1;v<r;++v){T=v*n;for(let E=0;E<s;++E)b[y++]=b[T++]}d!==0&&!h?S=new Float32Array(b.buffer,0,y/4):S=new Uint8Array(b.buffer,0,y)}e.unmap(),c&&this.releaseBuffer(e),p(S)},_=>{this._engine.isDisposed||this._engine.uniqueId!==f?p(new Uint8Array):g(_)})})}releaseBuffer(e){return Yl._IsGPUBuffer(e)?(this._deferredReleaseBuffers.push(e),!0):(e.references--,e.references===0?(this._deferredReleaseBuffers.push(e.underlyingResource),!0):!1)}destroyDeferredBuffers(){for(let e=0;e<this._deferredReleaseBuffers.length;++e)this._deferredReleaseBuffers[e].destroy();this._deferredReleaseBuffers.length=0}}const VO=[0,0,3,7,0,2,6,2,4,1,5,3,1],kO=[0,64,32,96,16,80,48,112,8],zO=[0,128,128,0,0,0,0,128,0,0,0,0,128];class An{constructor(e){this._samplers={},this._device=e,this.disabled=!1}static GetSamplerHashCode(e){const t=e._cachedAnisotropicFilteringLevel?e._cachedAnisotropicFilteringLevel:1;return VO[e.samplingMode]+kO[(e._comparisonFunction||514)-512+1]+zO[e.samplingMode]+((e._cachedWrapU??1)<<8)+((e._cachedWrapV??1)<<10)+((e._cachedWrapR??1)<<12)+((e.useMipMaps?1:0)<<14)+(t<<15)}static _GetSamplerFilterDescriptor(e,t){let i,r,s,n,o;const l=e.useMipMaps;switch(e.samplingMode){case 11:i="linear",r="linear",s="nearest",l||(n=o=0);break;case 3:case 3:i="linear",r="linear",l?s="linear":(s="nearest",n=o=0);break;case 8:i="nearest",r="nearest",l?s="linear":(s="nearest",n=o=0);break;case 4:i="nearest",r="nearest",s="nearest",l||(n=o=0);break;case 5:i="nearest",r="linear",s="nearest",l||(n=o=0);break;case 6:i="nearest",r="linear",l?s="linear":(s="nearest",n=o=0);break;case 7:i="nearest",r="linear",s="nearest",n=o=0;break;case 1:case 1:i="nearest",r="nearest",s="nearest",n=o=0;break;case 9:i="linear",r="nearest",s="nearest",l||(n=o=0);break;case 10:i="linear",r="nearest",l?s="linear":(s="nearest",n=o=0);break;case 2:case 2:i="linear",r="linear",t>1?s="linear":(s="nearest",n=o=0);break;case 12:i="linear",r="nearest",s="nearest",n=o=0;break;default:i="nearest",r="nearest",s="nearest",n=o=0;break}return t>1&&(n!==0||o!==0)?{magFilter:"linear",minFilter:"linear",mipmapFilter:"linear",anisotropyEnabled:!0}:{magFilter:i,minFilter:r,mipmapFilter:s,lodMinClamp:n,lodMaxClamp:o}}static _GetWrappingMode(e){switch(e){case 1:return"repeat";case 0:return"clamp-to-edge";case 2:return"mirror-repeat"}return"repeat"}static _GetSamplerWrappingDescriptor(e){return{addressModeU:this._GetWrappingMode(e._cachedWrapU),addressModeV:this._GetWrappingMode(e._cachedWrapV),addressModeW:this._GetWrappingMode(e._cachedWrapR)}}static _GetSamplerDescriptor(e,t){let i=(e.useMipMaps||e.samplingMode===2)&&e._cachedAnisotropicFilteringLevel?e._cachedAnisotropicFilteringLevel:1;e.samplingMode!==11&&e.samplingMode!==3&&e.samplingMode!==2&&(i=1);const r=this._GetSamplerFilterDescriptor(e,i);return{label:t,...r,...this._GetSamplerWrappingDescriptor(e),compare:e._comparisonFunction?An.GetCompareFunction(e._comparisonFunction):void 0,maxAnisotropy:r.anisotropyEnabled?i:1}}static GetCompareFunction(e){switch(e){case 519:return"always";case 514:return"equal";case 516:return"greater";case 518:return"greater-equal";case 513:return"less";case 515:return"less-equal";case 512:return"never";case 517:return"not-equal";default:return"less"}}getSampler(e,t=!1,i=0,r){if(this.disabled)return this._device.createSampler(An._GetSamplerDescriptor(e,r));t?i=0:i===0&&(i=An.GetSamplerHashCode(e));let s=t?void 0:this._samplers[i];return s||(s=this._device.createSampler(An._GetSamplerDescriptor(e,r)),t||(this._samplers[i]=s)),s}}var Mt;(function(a){a[a.StencilReadMask=0]="StencilReadMask",a[a.StencilWriteMask=1]="StencilWriteMask",a[a.DepthBias=2]="DepthBias",a[a.DepthBiasSlopeScale=3]="DepthBiasSlopeScale",a[a.DepthStencilState=4]="DepthStencilState",a[a.MRTAttachments1=5]="MRTAttachments1",a[a.MRTAttachments2=6]="MRTAttachments2",a[a.RasterizationState=7]="RasterizationState",a[a.ColorStates=8]="ColorStates",a[a.ShaderStage=9]="ShaderStage",a[a.TextureStage=10]="TextureStage",a[a.VertexState=11]="VertexState",a[a.NumStates=12]="NumStates"})(Mt||(Mt={}));const Ml={0:1,1:2,768:3,769:4,770:5,771:6,772:7,773:8,774:9,775:10,776:11,32769:12,32770:13,32771:12,32772:13},da={0:0,7680:1,7681:2,7682:3,7683:4,5386:5,34055:6,34056:7};class bt{constructor(e,t){this.mrtTextureCount=0,this._device=e,this._useTextureStage=!0,this._states=new Array(30),this._statesLength=0,this._stateDirtyLowestIndex=0,this._emptyVertexBuffer=t,this._mrtFormats=[],this._parameter={token:void 0,pipeline:null},this.disabled=!1,this.vertexBuffers=[],this._kMaxVertexBufferStride=e.limits.maxVertexBufferArrayStride||2048,this.reset()}reset(){this._isDirty=!0,this.vertexBuffers.length=0,this.setAlphaToCoverage(!1),this.resetDepthCullingState(),this.setClampDepth(!1),this.setDepthBias(0),this._webgpuColorFormat=["bgra8unorm"],this.setColorFormat("bgra8unorm"),this.setMRT([]),this.setAlphaBlendEnabled(!1),this.setAlphaBlendFactors([null,null,null,null],[null,null]),this.setWriteMask(15),this.setDepthStencilFormat("depth24plus-stencil8"),this.setStencilEnabled(!1),this.resetStencilState(),this.setBuffers(null,null,null),this._setTextureState(0)}get colorFormats(){return this._mrtAttachments1>0?this._mrtFormats:this._webgpuColorFormat}getRenderPipeline(e,t,i,r=0){if(i=et.GetSample(i),this.disabled){const n=bt._GetTopology(e);return this._setVertexState(t),this._setTextureState(r),this._parameter.pipeline=this._createRenderPipeline(t,n,i),bt.NumCacheMiss++,bt._NumPipelineCreationCurrentFrame++,this._parameter.pipeline}if(this._setShaderStage(t.uniqueId),this._setRasterizationState(e,i),this._setColorStates(),this._setDepthStencilState(),this._setVertexState(t),this._setTextureState(r),this.lastStateDirtyLowestIndex=this._stateDirtyLowestIndex,!this._isDirty&&this._parameter.pipeline)return this._stateDirtyLowestIndex=this._statesLength,bt.NumCacheHitWithoutHash++,this._parameter.pipeline;if(this._getRenderPipeline(this._parameter),this._isDirty=!1,this._stateDirtyLowestIndex=this._statesLength,this._parameter.pipeline)return bt.NumCacheHitWithHash++,this._parameter.pipeline;const s=bt._GetTopology(e);return this._parameter.pipeline=this._createRenderPipeline(t,s,i),this._setRenderPipeline(this._parameter),bt.NumCacheMiss++,bt._NumPipelineCreationCurrentFrame++,this._parameter.pipeline}endFrame(){bt.NumPipelineCreationLastFrame=bt._NumPipelineCreationCurrentFrame,bt._NumPipelineCreationCurrentFrame=0}setAlphaToCoverage(e){this._alphaToCoverageEnabled=e}setFrontFace(e){this._frontFace=e}setCullEnabled(e){this._cullEnabled=e}setCullFace(e){this._cullFace=e}setClampDepth(e){this._clampDepth=e}resetDepthCullingState(){this.setDepthCullingState(!1,2,1,0,0,!0,!0,519)}setDepthCullingState(e,t,i,r,s,n,o,l){this._depthWriteEnabled=o,this._depthTestEnabled=n,this._depthCompare=(l??519)-512,this._cullFace=i,this._cullEnabled=e,this._frontFace=t,this.setDepthBiasSlopeScale(r),this.setDepthBias(s)}setDepthBias(e){this._depthBias!==e&&(this._depthBias=e,this._states[Mt.DepthBias]=e,this._isDirty=!0,this._stateDirtyLowestIndex=Math.min(this._stateDirtyLowestIndex,Mt.DepthBias))}setDepthBiasSlopeScale(e){this._depthBiasSlopeScale!==e&&(this._depthBiasSlopeScale=e,this._states[Mt.DepthBiasSlopeScale]=e,this._isDirty=!0,this._stateDirtyLowestIndex=Math.min(this._stateDirtyLowestIndex,Mt.DepthBiasSlopeScale))}setColorFormat(e){this._webgpuColorFormat[0]=e,this._colorFormat=qr[e??""]}setMRTAttachments(e){this.mrtAttachments=e;let t=0;for(let i=0;i<e.length;++i)e[i]!==0&&(t+=1<<i);this._mrtEnabledMask!==t&&(this._mrtEnabledMask=t,this._isDirty=!0,this._stateDirtyLowestIndex=Math.min(this._stateDirtyLowestIndex,Mt.MRTAttachments1))}setMRT(e,t){if(t=t??e.length,t>10)throw"Can't handle more than 10 attachments for a MRT in cache render pipeline!";this.mrtTextureArray=e,this.mrtTextureCount=t,this._mrtEnabledMask=65535;const i=[0,0];let r=0,s=0,n=0;for(let o=0;o<t;++o){const l=e[o],u=l==null?void 0:l._hardwareTexture;this._mrtFormats[n]=(u==null?void 0:u.format)??this._webgpuColorFormat[0],i[r]+=qr[this._mrtFormats[n]??""]<<s,s+=6,n++,s>=32&&(s=0,r++)}this._mrtFormats.length=n,(this._mrtAttachments1!==i[0]||this._mrtAttachments2!==i[1])&&(this._mrtAttachments1=i[0],this._mrtAttachments2=i[1],this._states[Mt.MRTAttachments1]=i[0],this._states[Mt.MRTAttachments2]=i[1],this._isDirty=!0,this._stateDirtyLowestIndex=Math.min(this._stateDirtyLowestIndex,Mt.MRTAttachments1))}setAlphaBlendEnabled(e){this._alphaBlendEnabled=e}setAlphaBlendFactors(e,t){this._alphaBlendFuncParams=e,this._alphaBlendEqParams=t}setWriteMask(e){this._writeMask=e}setDepthStencilFormat(e){this._webgpuDepthStencilFormat=e,this._depthStencilFormat=e===void 0?0:qr[e]}setDepthTestEnabled(e){this._depthTestEnabled=e}setDepthWriteEnabled(e){this._depthWriteEnabled=e}setDepthCompare(e){this._depthCompare=(e??519)-512}setStencilEnabled(e){this._stencilEnabled=e}setStencilCompare(e){this._stencilFrontCompare=(e??519)-512}setStencilDepthFailOp(e){this._stencilFrontDepthFailOp=e===null?1:da[e]}setStencilPassOp(e){this._stencilFrontPassOp=e===null?2:da[e]}setStencilFailOp(e){this._stencilFrontFailOp=e===null?1:da[e]}setStencilReadMask(e){this._stencilReadMask!==e&&(this._stencilReadMask=e,this._states[Mt.StencilReadMask]=e,this._isDirty=!0,this._stateDirtyLowestIndex=Math.min(this._stateDirtyLowestIndex,Mt.StencilReadMask))}setStencilWriteMask(e){this._stencilWriteMask!==e&&(this._stencilWriteMask=e,this._states[Mt.StencilWriteMask]=e,this._isDirty=!0,this._stateDirtyLowestIndex=Math.min(this._stateDirtyLowestIndex,Mt.StencilWriteMask))}resetStencilState(){this.setStencilState(!1,519,7680,7681,7680,255,255)}setStencilState(e,t,i,r,s,n,o){this._stencilEnabled=e,this._stencilFrontCompare=(t??519)-512,this._stencilFrontDepthFailOp=i===null?1:da[i],this._stencilFrontPassOp=r===null?2:da[r],this._stencilFrontFailOp=s===null?1:da[s],this.setStencilReadMask(n),this.setStencilWriteMask(o)}setBuffers(e,t,i){this._vertexBuffers=e,this._overrideVertexBuffers=i,this._indexBuffer=t}static _GetTopology(e){switch(e){case 0:return"triangle-list";case 2:return"point-list";case 1:return"line-list";case 3:return"point-list";case 4:return"line-list";case 5:throw"LineLoop is an unsupported fillmode in WebGPU";case 6:return"line-strip";case 7:return"triangle-strip";case 8:throw"TriangleFan is an unsupported fillmode in WebGPU";default:return"triangle-list"}}static _GetAphaBlendOperation(e){switch(e){case 32774:return"add";case 32778:return"subtract";case 32779:return"reverse-subtract";case 32775:return"min";case 32776:return"max";default:return"add"}}static _GetAphaBlendFactor(e){switch(e){case 0:return"zero";case 1:return"one";case 768:return"src";case 769:return"one-minus-src";case 770:return"src-alpha";case 771:return"one-minus-src-alpha";case 772:return"dst-alpha";case 773:return"one-minus-dst-alpha";case 774:return"dst";case 775:return"one-minus-dst";case 776:return"src-alpha-saturated";case 32769:return"constant";case 32770:return"one-minus-constant";case 32771:return"constant";case 32772:return"one-minus-constant";case 35065:return"src1";case 35066:return"one-minus-src1";case 34185:return"src1-alpha";case 35067:return"one-minus-src1-alpha";default:return"one"}}static _GetCompareFunction(e){switch(e){case 0:return"never";case 1:return"less";case 2:return"equal";case 3:return"less-equal";case 4:return"greater";case 5:return"not-equal";case 6:return"greater-equal";case 7:return"always"}return"never"}static _GetStencilOpFunction(e){switch(e){case 0:return"zero";case 1:return"keep";case 2:return"replace";case 3:return"increment-clamp";case 4:return"decrement-clamp";case 5:return"invert";case 6:return"increment-wrap";case 7:return"decrement-wrap"}return"keep"}static _GetVertexInputDescriptorFormat(e){const t=e.type,i=e.normalized,r=e.getSize();switch(t){case N.BYTE:switch(r){case 1:case 2:return i?"snorm8x2":"sint8x2";case 3:case 4:return i?"snorm8x4":"sint8x4"}break;case N.UNSIGNED_BYTE:switch(r){case 1:case 2:return i?"unorm8x2":"uint8x2";case 3:case 4:return i?"unorm8x4":"uint8x4"}break;case N.SHORT:switch(r){case 1:case 2:return i?"snorm16x2":"sint16x2";case 3:case 4:return i?"snorm16x4":"sint16x4"}break;case N.UNSIGNED_SHORT:switch(r){case 1:case 2:return i?"unorm16x2":"uint16x2";case 3:case 4:return i?"unorm16x4":"uint16x4"}break;case N.INT:switch(r){case 1:return"sint32";case 2:return"sint32x2";case 3:return"sint32x3";case 4:return"sint32x4"}break;case N.UNSIGNED_INT:switch(r){case 1:return"uint32";case 2:return"uint32x2";case 3:return"uint32x3";case 4:return"uint32x4"}break;case N.FLOAT:switch(r){case 1:return"float32";case 2:return"float32x2";case 3:return"float32x3";case 4:return"float32x4"}break}throw new Error(`Invalid Format '${e.getKind()}' - type=${t}, normalized=${i}, size=${r}`)}_getAphaBlendState(){return this._alphaBlendEnabled?{srcFactor:bt._GetAphaBlendFactor(this._alphaBlendFuncParams[2]),dstFactor:bt._GetAphaBlendFactor(this._alphaBlendFuncParams[3]),operation:bt._GetAphaBlendOperation(this._alphaBlendEqParams[1])}:null}_getColorBlendState(){return this._alphaBlendEnabled?{srcFactor:bt._GetAphaBlendFactor(this._alphaBlendFuncParams[0]),dstFactor:bt._GetAphaBlendFactor(this._alphaBlendFuncParams[1]),operation:bt._GetAphaBlendOperation(this._alphaBlendEqParams[0])}:null}_setShaderStage(e){this._shaderId!==e&&(this._shaderId=e,this._states[Mt.ShaderStage]=e,this._isDirty=!0,this._stateDirtyLowestIndex=Math.min(this._stateDirtyLowestIndex,Mt.ShaderStage))}_setRasterizationState(e,t){const i=this._frontFace,r=this._cullEnabled?this._cullFace:0,s=this._clampDepth?1:0,n=this._alphaToCoverageEnabled?1:0,o=i-1+(r<<1)+(s<<3)+(n<<4)+(e<<5)+(t<<8);this._rasterizationState!==o&&(this._rasterizationState=o,this._states[Mt.RasterizationState]=this._rasterizationState,this._isDirty=!0,this._stateDirtyLowestIndex=Math.min(this._stateDirtyLowestIndex,Mt.RasterizationState))}_setColorStates(){let e=((this._writeMask?1:0)<<22)+(this._colorFormat<<23)+((this._depthWriteEnabled?1:0)<<29);this._alphaBlendEnabled&&(e+=((this._alphaBlendFuncParams[0]===null?2:Ml[this._alphaBlendFuncParams[0]])<<0)+((this._alphaBlendFuncParams[1]===null?2:Ml[this._alphaBlendFuncParams[1]])<<4)+((this._alphaBlendFuncParams[2]===null?2:Ml[this._alphaBlendFuncParams[2]])<<8)+((this._alphaBlendFuncParams[3]===null?2:Ml[this._alphaBlendFuncParams[3]])<<12)+((this._alphaBlendEqParams[0]===null?1:this._alphaBlendEqParams[0]-32773)<<16)+((this._alphaBlendEqParams[1]===null?1:this._alphaBlendEqParams[1]-32773)<<19)),e!==this._colorStates&&(this._colorStates=e,this._states[Mt.ColorStates]=this._colorStates,this._isDirty=!0,this._stateDirtyLowestIndex=Math.min(this._stateDirtyLowestIndex,Mt.ColorStates))}_setDepthStencilState(){const e=this._stencilEnabled?this._stencilFrontCompare+(this._stencilFrontDepthFailOp<<3)+(this._stencilFrontPassOp<<6)+(this._stencilFrontFailOp<<9):591,t=this._depthStencilFormat+((this._depthTestEnabled?this._depthCompare:7)<<6)+(e<<10);this._depthStencilState!==t&&(this._depthStencilState=t,this._states[Mt.DepthStencilState]=this._depthStencilState,this._isDirty=!0,this._stateDirtyLowestIndex=Math.min(this._stateDirtyLowestIndex,Mt.DepthStencilState))}_setVertexState(e){var u;const t=this._statesLength;let i=Mt.VertexState;const r=e._pipelineContext,s=r.shaderProcessingContext.attributeNamesFromEffect,n=r.shaderProcessingContext.attributeLocationsFromEffect;let o,l=0;for(let c=0;c<s.length;c++){const h=n[c];let d=(this._overrideVertexBuffers&&this._overrideVertexBuffers[s[c]])??this._vertexBuffers[s[c]];d||(d=this._emptyVertexBuffer,bt.LogErrorIfNoVertexBuffer&&L.Error(`No vertex buffer is provided for the "${s[c]}" attribute. A default empty vertex buffer will be used, but this may generate errors in some browsers.`));const f=(u=d.effectiveBuffer)==null?void 0:u.underlyingResource;if(d._validOffsetRange===void 0){const g=d.effectiveByteOffset,_=d.getSize(!0),S=d.effectiveByteStride;d._validOffsetRange=g+_<=this._kMaxVertexBufferStride&&S===0||S!==0&&g+_<=S}o&&o===f&&d._validOffsetRange||(this.vertexBuffers[l++]=d,o=d._validOffsetRange?f:null);const p=d.hashCode+(h<<7);this._isDirty=this._isDirty||this._states[i]!==p,this._states[i++]=p}this.vertexBuffers.length=l,this._statesLength=i,this._isDirty=this._isDirty||i!==t,this._isDirty&&(this._stateDirtyLowestIndex=Math.min(this._stateDirtyLowestIndex,Mt.VertexState))}_setTextureState(e){this._textureState!==e&&(this._textureState=e,this._states[Mt.TextureStage]=this._textureState,this._isDirty=!0,this._stateDirtyLowestIndex=Math.min(this._stateDirtyLowestIndex,Mt.TextureStage))}_createPipelineLayout(e){if(this._useTextureStage)return this._createPipelineLayoutWithTextureStage(e);const t=[],i=e.shaderProcessingContext.bindGroupLayoutEntries;for(let r=0;r<i.length;r++){const s=i[r];t[r]=this._device.createBindGroupLayout({entries:s})}return e.bindGroupLayouts[0]=t,this._device.createPipelineLayout({bindGroupLayouts:t})}_createPipelineLayoutWithTextureStage(e){const t=e.shaderProcessingContext,i=t.bindGroupLayoutEntries;let r=1;for(let n=0;n<i.length;n++){const o=i[n];for(let l=0;l<o.length;l++){const u=i[n][l];if(u.texture){const c=t.bindGroupLayoutEntryInfo[n][u.binding].name,h=t.availableTextures[c],d=h.autoBindSampler?t.availableSamplers[c+"Sampler"]:null;let f=h.sampleType,p=(d==null?void 0:d.type)??"filtering";if(this._textureState&r&&f!=="depth"&&(h.autoBindSampler&&(p="non-filtering"),f="unfilterable-float"),u.texture.sampleType=f,d){const g=t.bindGroupLayoutEntryInfo[d.binding.groupIndex][d.binding.bindingIndex].index;i[d.binding.groupIndex][g].sampler.type=p}r=r<<1}}}const s=[];for(let n=0;n<i.length;++n)s[n]=this._device.createBindGroupLayout({entries:i[n]});return e.bindGroupLayouts[this._textureState]=s,this._device.createPipelineLayout({bindGroupLayouts:s})}_getVertexInputDescriptor(e){var l;const t=[],i=e._pipelineContext,r=i.shaderProcessingContext.attributeNamesFromEffect,s=i.shaderProcessingContext.attributeLocationsFromEffect;let n,o;for(let u=0;u<r.length;u++){const c=s[u];let h=(this._overrideVertexBuffers&&this._overrideVertexBuffers[r[u]])??this._vertexBuffers[r[u]];h||(h=this._emptyVertexBuffer);let d=(l=h.effectiveBuffer)==null?void 0:l.underlyingResource,f=h.effectiveByteOffset;const p=!h._validOffsetRange;if(!(n&&o&&n===d)||p){const g={arrayStride:h.effectiveByteStride,stepMode:h.getIsInstanced()?"instance":"vertex",attributes:[]};t.push(g),o=g.attributes,p&&(f=0,d=null)}o.push({shaderLocation:c,offset:f,format:bt._GetVertexInputDescriptorFormat(h)}),n=d}return t}_createRenderPipeline(e,t,i){var p;const r=e._pipelineContext,s=this._getVertexInputDescriptor(e),n=this._createPipelineLayout(r),o=[],l=this._getAphaBlendState(),u=this._getColorBlendState();if(this._vertexBuffers&&b0(this._vertexBuffers,e),this._mrtAttachments1>0)for(let g=0;g<this._mrtFormats.length;++g){const _=this._mrtFormats[g];if(_){const S={format:_,writeMask:this._mrtEnabledMask&1<<g?this._writeMask:0};l&&u&&(S.blend={alpha:l,color:u}),o.push(S)}else o.push(null)}else if(this._webgpuColorFormat[0]){const g={format:this._webgpuColorFormat[0],writeMask:this._writeMask};l&&u&&(g.blend={alpha:l,color:u}),o.push(g)}else o.push(null);const c={compare:bt._GetCompareFunction(this._stencilEnabled?this._stencilFrontCompare:7),depthFailOp:bt._GetStencilOpFunction(this._stencilEnabled?this._stencilFrontDepthFailOp:1),failOp:bt._GetStencilOpFunction(this._stencilEnabled?this._stencilFrontFailOp:1),passOp:bt._GetStencilOpFunction(this._stencilEnabled?this._stencilFrontPassOp:1)},h=t==="triangle-list"||t==="triangle-strip";let d;(t==="line-strip"||t==="triangle-strip")&&(d=!this._indexBuffer||this._indexBuffer.is32Bits?"uint32":"uint16");const f=this._webgpuDepthStencilFormat?et.HasStencilAspect(this._webgpuDepthStencilFormat):!1;return this._device.createRenderPipeline({label:`RenderPipeline_${((p=o[0])==null?void 0:p.format)??"nooutput"}_${this._webgpuDepthStencilFormat??"nodepth"}_samples${i}_textureState${this._textureState}`,layout:n,vertex:{module:r.stages.vertexStage.module,entryPoint:r.stages.vertexStage.entryPoint,buffers:s},primitive:{topology:t,stripIndexFormat:d,frontFace:this._frontFace===1?"ccw":"cw",cullMode:this._cullEnabled?this._cullFace===2?"front":"back":"none"},fragment:r.stages.fragmentStage?{module:r.stages.fragmentStage.module,entryPoint:r.stages.fragmentStage.entryPoint,targets:o}:void 0,multisample:{count:i},depthStencil:this._webgpuDepthStencilFormat===void 0?void 0:{depthWriteEnabled:this._depthWriteEnabled,depthCompare:this._depthTestEnabled?bt._GetCompareFunction(this._depthCompare):"always",format:this._webgpuDepthStencilFormat,stencilFront:this._stencilEnabled&&f?c:void 0,stencilBack:this._stencilEnabled&&f?c:void 0,stencilReadMask:this._stencilEnabled&&f?this._stencilReadMask:void 0,stencilWriteMask:this._stencilEnabled&&f?this._stencilWriteMask:void 0,depthBias:this._depthBias,depthBiasClamp:h?this._depthBiasClamp:0,depthBiasSlopeScale:h?this._depthBiasSlopeScale:0}})}}bt.LogErrorIfNoVertexBuffer=!1;bt.NumCacheHitWithoutHash=0;bt.NumCacheHitWithHash=0;bt.NumCacheMiss=0;bt.NumPipelineCreationLastFrame=0;bt._NumPipelineCreationCurrentFrame=0;class oh{constructor(){this.values={}}count(){let e=0,t=this.pipeline?1:0;for(const i in this.values){const r=this.values[i],[s,n]=r.count();e+=s,t+=n,e++}return[e,t]}}class Nr extends bt{static GetNodeCounts(){const e=Nr._Cache.count();return{nodeCount:e[0],pipelineCount:e[1]}}static _GetPipelines(e,t,i,r){if(e.pipeline){const s=i.slice();s.length=r,t.push(s)}for(const s in e.values){const n=e.values[s];i[r]=parseInt(s),Nr._GetPipelines(n,t,i,r+1)}}static GetPipelines(){const e=[];return Nr._GetPipelines(Nr._Cache,e,[],0),e}static ResetCache(){Nr._Cache=new oh}reset(){this._nodeStack=[],this._nodeStack[0]=Nr._Cache,super.reset()}_getRenderPipeline(e){let t=this._nodeStack[this._stateDirtyLowestIndex];for(let i=this._stateDirtyLowestIndex;i<this._statesLength;++i){let r=t.values[this._states[i]];r||(r=new oh,t.values[this._states[i]]=r),t=r,this._nodeStack[i+1]=t}e.token=t,e.pipeline=t.pipeline}_setRenderPipeline(e){e.token.pipeline=e.pipeline}}Nr._Cache=new oh;class UO extends WR{constructor(e){super(!1),this._cache=e,this.reset()}get func(){return this._func}set func(e){this._func!==e&&(this._func=e,this._cache.setStencilCompare(e))}get funcMask(){return this._funcMask}set funcMask(e){this._funcMask!==e&&(this._funcMask=e,this._cache.setStencilReadMask(e))}get opStencilFail(){return this._opStencilFail}set opStencilFail(e){this._opStencilFail!==e&&(this._opStencilFail=e,this._cache.setStencilFailOp(e))}get opDepthFail(){return this._opDepthFail}set opDepthFail(e){this._opDepthFail!==e&&(this._opDepthFail=e,this._cache.setStencilDepthFailOp(e))}get opStencilDepthPass(){return this._opStencilDepthPass}set opStencilDepthPass(e){this._opStencilDepthPass!==e&&(this._opStencilDepthPass=e,this._cache.setStencilPassOp(e))}get mask(){return this._mask}set mask(e){this._mask!==e&&(this._mask=e,this._cache.setStencilWriteMask(e))}get enabled(){return this._enabled}set enabled(e){this._enabled!==e&&(this._enabled=e,this._cache.setStencilEnabled(e))}reset(){super.reset(),this._cache.resetStencilState()}apply(){var t;const e=(t=this.stencilMaterial)==null?void 0:t.enabled;this.enabled=e?this.stencilMaterial.enabled:this.stencilGlobal.enabled,this.enabled&&(this.func=e?this.stencilMaterial.func:this.stencilGlobal.func,this.funcRef=e?this.stencilMaterial.funcRef:this.stencilGlobal.funcRef,this.funcMask=e?this.stencilMaterial.funcMask:this.stencilGlobal.funcMask,this.opStencilFail=e?this.stencilMaterial.opStencilFail:this.stencilGlobal.opStencilFail,this.opDepthFail=e?this.stencilMaterial.opDepthFail:this.stencilGlobal.opDepthFail,this.opStencilDepthPass=e?this.stencilMaterial.opStencilDepthPass:this.stencilGlobal.opStencilDepthPass,this.mask=e?this.stencilMaterial.mask:this.stencilGlobal.mask)}}class GO extends $R{constructor(e){super(!1),this._cache=e,this.reset()}get zOffset(){return this._zOffset}set zOffset(e){this._zOffset!==e&&(this._zOffset=e,this._isZOffsetDirty=!0,this._cache.setDepthBiasSlopeScale(e))}get zOffsetUnits(){return this._zOffsetUnits}set zOffsetUnits(e){this._zOffsetUnits!==e&&(this._zOffsetUnits=e,this._isZOffsetDirty=!0,this._cache.setDepthBias(e))}get cullFace(){return this._cullFace}set cullFace(e){this._cullFace!==e&&(this._cullFace=e,this._isCullFaceDirty=!0,this._cache.setCullFace(e??1))}get cull(){return this._cull}set cull(e){this._cull!==e&&(this._cull=e,this._isCullDirty=!0,this._cache.setCullEnabled(!!e))}get depthFunc(){return this._depthFunc}set depthFunc(e){this._depthFunc!==e&&(this._depthFunc=e,this._isDepthFuncDirty=!0,this._cache.setDepthCompare(e))}get depthMask(){return this._depthMask}set depthMask(e){this._depthMask!==e&&(this._depthMask=e,this._isDepthMaskDirty=!0,this._cache.setDepthWriteEnabled(e))}get depthTest(){return this._depthTest}set depthTest(e){this._depthTest!==e&&(this._depthTest=e,this._isDepthTestDirty=!0,this._cache.setDepthTestEnabled(e))}get frontFace(){return this._frontFace}set frontFace(e){this._frontFace!==e&&(this._frontFace=e,this._isFrontFaceDirty=!0,this._cache.setFrontFace(e??2))}reset(){super.reset(),this._cache.resetDepthCullingState()}apply(){}}class C0{static IsExternalTexture(e){return e.underlyingResource!==void 0}getClassName(){return"ExternalTexture"}get underlyingResource(){return this._video}constructor(e){this.useMipMaps=!1,this.type=16,this.format=4294967295,this._video=e,this.uniqueId=Dt._Counter++}isReady(){return this._video.readyState>=this._video.HAVE_CURRENT_DATA}dispose(){}}class zu{get forceBindGroupCreation(){return this._numExternalTextures>0}get hasFloatOrDepthTextures(){return this._numFloatOrDepthTextures>0}constructor(){this.uniqueId=zu._Counter++,this.updateId=0,this.textureState=0,this.reset()}reset(){this.samplers={},this.textures={},this.isDirty=!0,this._numFloatOrDepthTextures=0,this._numExternalTextures=0}setSampler(e,t){let i=this.samplers[e],r=-1;i?r=i.hashCode:this.samplers[e]=i={sampler:t,hashCode:0},i.sampler=t,i.hashCode=t?An.GetSamplerHashCode(t):0;const s=r!==i.hashCode;s&&this.updateId++,this.isDirty||(this.isDirty=s)}setTexture(e,t){var n;let i=this.textures[e],r=-1;i?r=((n=i.texture)==null?void 0:n.uniqueId)??-1:this.textures[e]=i={texture:t,isFloatOrDepthTexture:!1,isExternalTexture:!1},i.isExternalTexture&&this._numExternalTextures--,i.isFloatOrDepthTexture&&this._numFloatOrDepthTextures--,t?(i.isFloatOrDepthTexture=t.type===1||t.format>=13&&t.format<=18,i.isExternalTexture=C0.IsExternalTexture(t),i.isFloatOrDepthTexture&&this._numFloatOrDepthTextures++,i.isExternalTexture&&this._numExternalTextures++):(i.isFloatOrDepthTexture=!1,i.isExternalTexture=!1),i.texture=t;const s=r!==((t==null?void 0:t.uniqueId)??-1);s&&this.updateId++,this.isDirty||(this.isDirty=s)}}zu._Counter=0;class Uu{isDirty(e){return this._isDirty||this._materialContextUpdateId!==e}resetIsDirty(e){this._isDirty=!1,this._materialContextUpdateId=e}get useInstancing(){return this._useInstancing}set useInstancing(e){this._useInstancing!==e&&(e?(this.indirectDrawBuffer=this._bufferManager.createRawBuffer(20,tt.CopyDst|tt.Indirect|tt.Storage,void 0,"IndirectDrawBuffer"),this._indirectDrawData=new Uint32Array(5),this._indirectDrawData[3]=0,this._indirectDrawData[4]=0):(this.indirectDrawBuffer&&this._bufferManager.releaseBuffer(this.indirectDrawBuffer),this.indirectDrawBuffer=void 0,this._indirectDrawData=void 0),this._useInstancing=e,this._currentInstanceCount=-1)}constructor(e){this._bufferManager=e,this.uniqueId=Uu._Counter++,this._useInstancing=!1,this._currentInstanceCount=0,this.reset()}reset(){this.buffers={},this._isDirty=!0,this._materialContextUpdateId=0,this.fastBundle=void 0,this.bindGroups=void 0}setBuffer(e,t){var i;this._isDirty||(this._isDirty=(t==null?void 0:t.uniqueId)!==((i=this.buffers[e])==null?void 0:i.uniqueId)),this.buffers[e]=t}setIndirectData(e,t,i){t===this._currentInstanceCount||!this.indirectDrawBuffer||!this._indirectDrawData||(this._currentInstanceCount=t,this._indirectDrawData[0]=e,this._indirectDrawData[1]=t,this._indirectDrawData[2]=i,this._bufferManager.setRawData(this.indirectDrawBuffer,0,this._indirectDrawData,0,20))}dispose(){this.indirectDrawBuffer&&(this._bufferManager.releaseBuffer(this.indirectDrawBuffer),this.indirectDrawBuffer=void 0,this._indirectDrawData=void 0),this.fastBundle=void 0,this.bindGroups=void 0,this.buffers=void 0}}Uu._Counter=0;const WO=1<<20,$O=2**35;class xo{constructor(){this.values={}}}class at{static get Statistics(){return{totalCreated:at.NumBindGroupsCreatedTotal,lastFrameCreated:at.NumBindGroupsCreatedLastFrame,lookupLastFrame:at.NumBindGroupsLookupLastFrame,noLookupLastFrame:at.NumBindGroupsNoLookupLastFrame}}static ResetCache(){at._Cache=new xo,at.NumBindGroupsCreatedTotal=0,at.NumBindGroupsCreatedLastFrame=0,at.NumBindGroupsLookupLastFrame=0,at.NumBindGroupsNoLookupLastFrame=0,at._NumBindGroupsCreatedCurrentFrame=0,at._NumBindGroupsLookupCurrentFrame=0,at._NumBindGroupsNoLookupCurrentFrame=0}constructor(e,t,i){this.disabled=!1,this._device=e,this._cacheSampler=t,this._engine=i}endFrame(){at.NumBindGroupsCreatedLastFrame=at._NumBindGroupsCreatedCurrentFrame,at.NumBindGroupsLookupLastFrame=at._NumBindGroupsLookupCurrentFrame,at.NumBindGroupsNoLookupLastFrame=at._NumBindGroupsNoLookupCurrentFrame,at._NumBindGroupsCreatedCurrentFrame=0,at._NumBindGroupsLookupCurrentFrame=0,at._NumBindGroupsNoLookupCurrentFrame=0}getBindGroups(e,t,i){var l,u,c,h,d,f;let r,s=at._Cache;const n=this.disabled||i.forceBindGroupCreation;if(!n){if(!t.isDirty(i.updateId)&&!i.isDirty)return at._NumBindGroupsNoLookupCurrentFrame++,t.bindGroups;for(const p of e.shaderProcessingContext.bufferNames){const g=(((l=t.buffers[p])==null?void 0:l.uniqueId)??0)+WO;let _=s.values[g];_||(_=new xo,s.values[g]=_),s=_}for(const p of e.shaderProcessingContext.samplerNames){const g=((u=i.samplers[p])==null?void 0:u.hashCode)??0;let _=s.values[g];_||(_=new xo,s.values[g]=_),s=_}for(const p of e.shaderProcessingContext.textureNames){const g=(((h=(c=i.textures[p])==null?void 0:c.texture)==null?void 0:h.uniqueId)??0)+$O;let _=s.values[g];_||(_=new xo,s.values[g]=_),s=_}r=s.bindGroups}if(t.resetIsDirty(i.updateId),i.isDirty=!1,r)return t.bindGroups=r,at._NumBindGroupsLookupCurrentFrame++,r;r=[],t.bindGroups=r,n||(s.bindGroups=r),at.NumBindGroupsCreatedTotal++,at._NumBindGroupsCreatedCurrentFrame++;const o=e.bindGroupLayouts[i.textureState];for(let p=0;p<e.shaderProcessingContext.bindGroupLayoutEntries.length;p++){const g=e.shaderProcessingContext.bindGroupLayoutEntries[p],_=e.shaderProcessingContext.bindGroupEntries[p];for(let b=0;b<g.length;b++){const y=e.shaderProcessingContext.bindGroupLayoutEntries[p][b],T=e.shaderProcessingContext.bindGroupLayoutEntryInfo[p][y.binding],v=T.nameInArrayOfTexture??T.name;if(y.sampler){const E=i.samplers[v];if(E){const R=E.sampler;if(!R){this._engine.dbgSanityChecks&&L.Error(`Trying to bind a null sampler! entry=${JSON.stringify(y)}, name=${v}, bindingInfo=${JSON.stringify(E,(O,w)=>O==="texture"?"<no dump>":w)}, materialContext.uniqueId=${i.uniqueId}`,50);continue}_[b].resource=this._cacheSampler.getSampler(R,!1,E.hashCode,R.label)}else L.Error(`Sampler "${v}" could not be bound. entry=${JSON.stringify(y)}, materialContext=${JSON.stringify(i,(R,O)=>R==="texture"||R==="sampler"?"<no dump>":O)}`,50)}else if(y.texture||y.storageTexture){const E=i.textures[v];if(E){if(this._engine.dbgSanityChecks&&E.texture===null){L.Error(`Trying to bind a null texture! entry=${JSON.stringify(y)}, bindingInfo=${JSON.stringify(E,(O,w)=>O==="texture"?"<no dump>":w)}, materialContext.uniqueId=${i.uniqueId}`,50);continue}const R=E.texture._hardwareTexture;if(this._engine.dbgSanityChecks&&(!R||y.texture&&!R.view||y.storageTexture&&!R.viewForWriting)){L.Error(`Trying to bind a null gpu texture or view! entry=${JSON.stringify(y)}, name=${v}, bindingInfo=${JSON.stringify(E,(O,w)=>O==="texture"?"<no dump>":w)}, isReady=${(d=E.texture)==null?void 0:d.isReady}, materialContext.uniqueId=${i.uniqueId}`,50);continue}_[b].resource=y.storageTexture?R.viewForWriting:R.view}else L.Error(`Texture "${v}" could not be bound. entry=${JSON.stringify(y)}, materialContext=${JSON.stringify(i,(R,O)=>R==="texture"||R==="sampler"?"<no dump>":O)}`,50)}else if(y.externalTexture){const E=i.textures[v];if(E){if(this._engine.dbgSanityChecks&&E.texture===null){L.Error(`Trying to bind a null external texture! entry=${JSON.stringify(y)}, name=${v}, bindingInfo=${JSON.stringify(E,(O,w)=>O==="texture"?"<no dump>":w)}, materialContext.uniqueId=${i.uniqueId}`,50);continue}const R=E.texture.underlyingResource;if(this._engine.dbgSanityChecks&&!R){L.Error(`Trying to bind a null gpu external texture! entry=${JSON.stringify(y)}, name=${v}, bindingInfo=${JSON.stringify(E,(O,w)=>O==="texture"?"<no dump>":w)}, isReady=${(f=E.texture)==null?void 0:f.isReady}, materialContext.uniqueId=${i.uniqueId}`,50);continue}_[b].resource=this._device.importExternalTexture({source:R})}else L.Error(`Texture "${v}" could not be bound. entry=${JSON.stringify(y)}, materialContext=${JSON.stringify(i,(R,O)=>R==="texture"||R==="sampler"?"<no dump>":O)}`,50)}else if(y.buffer){const E=t.buffers[v];if(E){const R=E.underlyingResource;_[b].resource.buffer=R,_[b].resource.size=E.capacity}else L.Error(`Can't find buffer "${v}". entry=${JSON.stringify(y)}, buffers=${JSON.stringify(t.buffers)}, drawContext.uniqueId=${t.uniqueId}`,50)}}const S=o[p];r[p]=this._device.createBindGroup({layout:S,entries:_})}return r}}at.NumBindGroupsCreatedTotal=0;at.NumBindGroupsCreatedLastFrame=0;at.NumBindGroupsLookupLastFrame=0;at.NumBindGroupsNoLookupLastFrame=0;at._Cache=new xo;at._NumBindGroupsCreatedCurrentFrame=0;at._NumBindGroupsLookupCurrentFrame=0;at._NumBindGroupsNoLookupCurrentFrame=0;const Bx="clearQuadVertexShader",HO=`uniform depthValue: f32;const pos=array(
vec2f(-1.0,1.0),
vec2f(1.0,1.0),
vec2f(-1.0,-1.0),
vec2f(1.0,-1.0)
);
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
vertexOutputs.position=vec4f(pos[input.vertexIndex],uniforms.depthValue,1.0);
#define CUSTOM_VERTEX_MAIN_END
}
`;P.ShadersStoreWGSL[Bx]||(P.ShadersStoreWGSL[Bx]=HO);const Vx="clearQuadPixelShader",jO=`uniform color: vec4f;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=uniforms.color;}
`;P.ShadersStoreWGSL[Vx]||(P.ShadersStoreWGSL[Vx]=jO);class YO{setDepthStencilFormat(e){this._depthTextureFormat=e,this._cacheRenderPipeline.setDepthStencilFormat(e)}setColorFormat(e){this._cacheRenderPipeline.setColorFormat(e)}setMRTAttachments(e,t,i){this._cacheRenderPipeline.setMRT(t,i),this._cacheRenderPipeline.setMRTAttachments(e)}constructor(e,t,i){this._bindGroups={},this._bundleCache={},this._keyTemp=[],this._device=e,this._engine=t,this._cacheRenderPipeline=new Nr(this._device,i),this._cacheRenderPipeline.setDepthTestEnabled(!1),this._cacheRenderPipeline.setStencilReadMask(255),this._effect=t.createEffect("clearQuad",[],["color","depthValue"],void 0,void 0,void 0,void 0,void 0,void 0,1)}clear(e,t,i,r,s=1){let n,o=null,l;const u=!!this._engine._currentRenderTarget;if(e)n=e;else{let _=0;this._keyTemp.length=0;for(let b=0;b<this._cacheRenderPipeline.colorFormats.length;++b)this._keyTemp[_++]=qr[this._cacheRenderPipeline.colorFormats[b]??""];const S=qr[this._depthTextureFormat??0];if(this._keyTemp[_]=(t?t.r+t.g*256+t.b*256*256+t.a*256*256*256:0)+(i?2**32:0)+(r?2**33:0)+(this._engine.useReverseDepthBuffer?2**34:0)+(u?2**35:0)+(s>1?2**36:0)+S*2**37,l=this._keyTemp.join("_"),o=this._bundleCache[l],o)return o;n=this._device.createRenderBundleEncoder({label:"clearQuadRenderBundle",colorFormats:this._cacheRenderPipeline.colorFormats,depthStencilFormat:this._depthTextureFormat,sampleCount:et.GetSample(s)})}this._cacheRenderPipeline.setDepthWriteEnabled(!!i),this._cacheRenderPipeline.setStencilEnabled(!!r&&!!this._depthTextureFormat&&et.HasStencilAspect(this._depthTextureFormat)),this._cacheRenderPipeline.setStencilWriteMask(r?255:0),this._cacheRenderPipeline.setStencilCompare(r?519:512),this._cacheRenderPipeline.setStencilPassOp(r?7681:7680),this._cacheRenderPipeline.setWriteMask(t?15:0);const c=this._cacheRenderPipeline.getRenderPipeline(7,this._effect,s),h=this._effect._pipelineContext;t&&this._effect.setDirectColor4("color",t),this._effect.setFloat("depthValue",this._engine.useReverseDepthBuffer?this._engine._clearReverseDepthValue:this._engine._clearDepthValue),h.uniformBuffer.update();const d=u?this._engine._ubInvertY:this._engine._ubDontInvertY,f=h.uniformBuffer.getBuffer(),p=f.uniqueId+"-"+d.uniqueId;let g=this._bindGroups[p];if(!g){const _=h.bindGroupLayouts[0];g=this._bindGroups[p]=[],g.push(this._device.createBindGroup({label:`clearQuadBindGroup0-${p}`,layout:_[0],entries:[]})),Ki._SimplifiedKnownBindings||g.push(this._device.createBindGroup({label:`clearQuadBindGroup1-${p}`,layout:_[1],entries:[]})),g.push(this._device.createBindGroup({label:`clearQuadBindGroup${Ki._SimplifiedKnownBindings?1:2}-${p}`,layout:_[Ki._SimplifiedKnownBindings?1:2],entries:[{binding:0,resource:{buffer:d.underlyingResource,size:d.capacity}},{binding:1,resource:{buffer:f.underlyingResource,size:f.capacity}}]}))}n.setPipeline(c);for(let _=0;_<g.length;++_)n.setBindGroup(_,g[_]);return n.draw(4,1,0,0),e||(o=n.finish(),this._bundleCache[l]=o),o}}class b_{constructor(e,t,i,r){this.x=Math.floor(e),this.y=Math.floor(t),this.w=Math.floor(i),this.h=Math.floor(r)}run(e){e.setViewport(this.x,this.y,this.w,this.h,0,1)}clone(){return new b_(this.x,this.y,this.w,this.h)}}class y_{constructor(e,t,i,r){this.x=e,this.y=t,this.w=i,this.h=r}run(e){e.setScissorRect(this.x,this.y,this.w,this.h)}clone(){return new y_(this.x,this.y,this.w,this.h)}}class Xl{constructor(e){this.ref=e}run(e){e.setStencilReference(this.ref)}clone(){return new Xl(this.ref)}}class T_{constructor(e){this.color=e}run(e){e.setBlendConstant(this.color)}clone(){return new T_(this.color)}}class C_{constructor(e){this.query=e}run(e){e.beginOcclusionQuery(this.query)}clone(){return new C_(this.query)}}class P_{constructor(){}run(e){e.endOcclusionQuery()}clone(){return new P_}}class E_{constructor(){this.bundles=[]}run(e){e.executeBundles(this.bundles)}clone(){const e=new E_;return e.bundles=this.bundles,e}}class I_{constructor(e){this.numDrawCalls=0,this._device=e,this._list=new Array(10),this._listLength=0}addBundle(e){if(!this._currentItemIsBundle){const t=new E_;this._list[this._listLength++]=t,this._currentBundleList=t.bundles,this._currentItemIsBundle=!0}e&&this._currentBundleList.push(e)}_finishBundle(){this._currentItemIsBundle&&this._bundleEncoder&&(this._currentBundleList.push(this._bundleEncoder.finish()),this._bundleEncoder=void 0,this._currentItemIsBundle=!1)}addItem(e){this._finishBundle(),this._list[this._listLength++]=e,this._currentItemIsBundle=!1}getBundleEncoder(e,t,i){return this._currentItemIsBundle||(this.addBundle(),this._bundleEncoder=this._device.createRenderBundleEncoder({colorFormats:e,depthStencilFormat:t,sampleCount:et.GetSample(i)})),this._bundleEncoder}close(){this._finishBundle()}run(e){this.close();for(let t=0;t<this._listLength;++t)this._list[t].run(e)}reset(){this._listLength=0,this._currentItemIsBundle=!1,this.numDrawCalls=0}clone(){this.close();const e=new I_(this._device);e._list=new Array(this._listLength),e._listLength=this._listLength,e.numDrawCalls=this.numDrawCalls;for(let t=0;t<this._listLength;++t)e._list[t]=this._list[t].clone();return e}}class P0{get querySet(){return this._querySet}constructor(e,t,i,r,s,n=!0,o){this._dstBuffers=[],this._engine=e,this._device=r,this._bufferManager=s,this._count=t,this._canUseMultipleBuffers=n,this._querySet=r.createQuerySet({label:o??"QuerySet",type:i,count:t}),this._queryBuffer=s.createRawBuffer(8*t,tt.QueryResolve|tt.CopySrc,void 0,"QueryBuffer"),n||this._dstBuffers.push(this._bufferManager.createRawBuffer(8*this._count,tt.MapRead|tt.CopyDst,void 0,"QueryBufferNoMultipleBuffers"))}_getBuffer(e,t){if(!this._canUseMultipleBuffers&&this._dstBuffers.length===0)return null;const i=this._device.createCommandEncoder();let r;return this._dstBuffers.length===0?r=this._bufferManager.createRawBuffer(8*this._count,tt.MapRead|tt.CopyDst,void 0,"QueryBufferAdditionalBuffer"):(r=this._dstBuffers[this._dstBuffers.length-1],this._dstBuffers.length--),i.resolveQuerySet(this._querySet,e,t,this._queryBuffer,0),i.copyBufferToBuffer(this._queryBuffer,0,r,0,8*t),this._device.queue.submit([i.finish()]),r}async readValues(e=0,t=1){const i=this._getBuffer(e,t);if(i===null)return null;const r=this._engine.uniqueId;return i.mapAsync(1).then(()=>{const s=new BigUint64Array(i.getMappedRange()).slice();return i.unmap(),this._dstBuffers[this._dstBuffers.length]=i,s},s=>{if(this._engine.isDisposed||this._engine.uniqueId!==r)return null;throw s})}async readValue(e=0){const t=this._getBuffer(e,1);if(t===null)return null;const i=this._engine.uniqueId;return t.mapAsync(1).then(()=>{const r=new BigUint64Array(t.getMappedRange()),s=Number(r[0]);return t.unmap(),this._dstBuffers[this._dstBuffers.length]=t,s},r=>{if(this._engine.isDisposed||this._engine.uniqueId!==i)return 0;throw r})}async readTwoValuesAndSubtract(e=0){const t=this._getBuffer(e,2);if(t===null)return null;const i=this._engine.uniqueId;return t.mapAsync(1).then(()=>{const r=new BigUint64Array(t.getMappedRange()),s=Number(r[1]-r[0]);return t.unmap(),this._dstBuffers[this._dstBuffers.length]=t,s},r=>{if(this._engine.isDisposed||this._engine.uniqueId!==i)return 0;throw r})}dispose(){this._querySet.destroy(),this._bufferManager.releaseBuffer(this._queryBuffer);for(let e=0;e<this._dstBuffers.length;++e)this._bufferManager.releaseBuffer(this._dstBuffers[e])}}class XO{get gpuFrameTimeCounter(){return this._gpuFrameTimeCounter}constructor(e,t,i){this._enabled=!1,this._gpuFrameTimeCounter=new fu,this._measureDurationState=0,this._engine=e,this._device=t,this._bufferManager=i}get enable(){return this._enabled}set enable(e){if(this._enabled!==e)if(this._enabled=e,this._measureDurationState=0,e)try{this._measureDuration=new ZO(this._engine,this._device,this._bufferManager,2e3,"QuerySet_TimestampQuery")}catch(t){this._enabled=!1,L.Error(`Could not create a WebGPUDurationMeasure!
Error: `+t.message+`
Make sure timestamp query is supported and enabled in your browser.`);return}else this._measureDuration.dispose()}startFrame(e){this._enabled&&this._measureDurationState===0&&(this._measureDuration.start(e),this._measureDurationState=1)}endFrame(e){this._measureDurationState===1&&(this._measureDurationState=2,this._measureDuration.stop(e).then(t=>{t!==null&&t>=0&&(this._gpuFrameTimeCounter.fetchNewFrame(),this._gpuFrameTimeCounter.addCount(t,!0)),this._measureDurationState=0}))}startPass(e,t){this._enabled?this._measureDuration.startPass(e,t):e.timestampWrites=void 0}endPass(e,t){if(!this._enabled||!t)return;const i=this._engine.frameId;this._measureDuration.stopPass(e).then(r=>{t._addDuration(i,r!==null&&r>0?r:0)})}dispose(){var e;(e=this._measureDuration)==null||e.dispose()}}class ZO{constructor(e,t,i,r=2,s){this._count=r,this._querySet=new P0(e,r,"timestamp",t,i,!0,s)}start(e){var t;(t=e.writeTimestamp)==null||t.call(e,this._querySet.querySet,0)}async stop(e){var t;return(t=e.writeTimestamp)==null||t.call(e,this._querySet.querySet,1),e.writeTimestamp?this._querySet.readTwoValuesAndSubtract(0):0}startPass(e,t){if(t+3>this._count)throw new Error("WebGPUDurationMeasure: index out of range ("+t+")");e.timestampWrites={querySet:this._querySet.querySet,beginningOfPassWriteIndex:t+2,endOfPassWriteIndex:t+3}}async stopPass(e){return this._querySet.readTwoValuesAndSubtract(e+2)}dispose(){this._querySet.dispose()}}class qO{get querySet(){return this._querySet.querySet}get hasQueries(){return this._currentTotalIndices!==this._availableIndices.length}canBeginQuery(e){if(this._frameQuerySetIsDirty===this._engine.frameId||this._queryFrameId[e]===this._engine.frameId)return!1;const t=this._engine._getCurrentRenderPassWrapper().renderPassDescriptor.occlusionQuerySet!==void 0;return t&&(this._queryFrameId[e]=this._engine.frameId),t}constructor(e,t,i,r=50,s=100){this._availableIndices=[],this._frameQuerySetIsDirty=-1,this._queryFrameId=[],this._engine=e,this._device=t,this._bufferManager=i,this._frameLastBuffer=-1,this._currentTotalIndices=0,this._countIncrement=s,this._allocateNewIndices(r)}createQuery(){this._availableIndices.length===0&&this._allocateNewIndices();const e=this._availableIndices[this._availableIndices.length-1];return this._availableIndices.length--,e}deleteQuery(e){this._availableIndices[this._availableIndices.length]=e}isQueryResultAvailable(e){return this._retrieveQueryBuffer(),!!this._lastBuffer&&e<this._lastBuffer.length}getQueryResult(e){var t;return Number(((t=this._lastBuffer)==null?void 0:t[e])??-1)}_retrieveQueryBuffer(){this._lastBuffer&&this._frameLastBuffer===this._engine.frameId||this._frameLastBuffer!==this._engine.frameId&&(this._frameLastBuffer=this._engine.frameId,this._querySet.readValues(0,this._currentTotalIndices).then(e=>{this._lastBuffer=e}))}_allocateNewIndices(e){e=e??this._countIncrement,this._delayQuerySetDispose();for(let t=0;t<e;++t)this._availableIndices.push(this._currentTotalIndices+t);this._currentTotalIndices+=e,this._querySet=new P0(this._engine,this._currentTotalIndices,"occlusion",this._device,this._bufferManager,!1,"QuerySet_OcclusionQuery_count_"+this._currentTotalIndices),this._frameQuerySetIsDirty=this._engine.frameId}_delayQuerySetDispose(){const e=this._querySet;e&&setTimeout(()=>e.dispose,1e3)}dispose(){var e;(e=this._querySet)==null||e.dispose(),this._availableIndices.length=0}}class $i{async initTwgsl(e){if(!$i._Twgsl)return e=e||{},e={...$i._TWgslDefaultOptions,...e},e.twgsl?($i._Twgsl=e.twgsl,Promise.resolve()):(e.jsPath&&e.wasmPath&&await ae.LoadBabylonScriptAsync(e.jsPath),self.twgsl?($i._Twgsl=await self.twgsl(ae.GetBabylonScriptURL(e.wasmPath)),Promise.resolve()):Promise.reject("twgsl is not available."))}convertSpirV2WGSL(e,t=!1){const i=$i._Twgsl.convertSpirV2WGSL(e,$i.DisableUniformityAnalysis||t);return $i.ShowWGSLShaderCode&&(L.Log(i),L.Log("***********************************************")),$i.DisableUniformityAnalysis||t?`diagnostic(off, derivative_uniformity);
`+i:i}}$i._TWgslDefaultOptions={jsPath:`${ae._DefaultCdnUrl}/twgsl/twgsl.js`,wasmPath:`${ae._DefaultCdnUrl}/twgsl/twgsl.wasm`};$i.ShowWGSLShaderCode=!1;$i.DisableUniformityAnalysis=!1;$i._Twgsl=null;class QO{constructor(e,t,i){this._record=!1,this._play=!1,this._playBundleListIndex=0,this._allBundleLists=[],this._enabled=!1,this.showDebugLogs=!1,this._engine=e,this._mode=t,this._bundleList=i}get enabled(){return this._enabled}get play(){return this._play}get record(){return this._record}set enabled(e){this._log("enabled",`activate=${e}, mode=${this._mode}`),this._allBundleLists.length=0,this._record=this._enabled=e,this._play=!1,e&&(this._modeSaved=this._mode,this._mode=0)}get mode(){return this._mode}set mode(e){this._record?this._modeSaved=e:this._mode=e}endRenderPass(e){if(!this._record&&!this._play)return!1;let t=null;return this._record?(t=this._bundleList.clone(),this._allBundleLists.push(t),this._bundleList.reset(),this._log("endRenderPass",`bundleList recorded at position #${this._allBundleLists.length-1}`)):this._playBundleListIndex>=this._allBundleLists.length?this._log("endRenderPass",`empty or out-of-sync bundleList (_allBundleLists.length=${this._allBundleLists.length}, playBundleListIndex=${this._playBundleListIndex})`):(this._log("endRenderPass",`run bundleList #${this._playBundleListIndex}`),t=this._allBundleLists[this._playBundleListIndex++]),t&&(t.run(e),this._mode===1&&this._engine._reportDrawCall(t.numDrawCalls)),!0}endFrame(){this._record&&(this._record=!1,this._play=!0,this._mode=this._modeSaved,this._log("endFrame","bundles recorded, switching to play mode")),this._playBundleListIndex=0}reset(){this._log("reset","called"),this._record&&(this._mode=this._modeSaved),this.enabled=!1,this.enabled=!0}_log(e,t){this.showDebugLogs&&L.Log(`[Frame: ${this._engine.frameId}] WebGPUSnapshotRendering:${e} - ${t}`)}}class KO extends C0{constructor(e){super(e)}}xt.prototype.createRawTexture=function(a,e,t,i,r,s,n,o=null,l=0,u=0,c=!1){const h=new Dt(this,3);return h.baseWidth=e,h.baseHeight=t,h.width=e,h.height=t,h.format=i,h.generateMipMaps=r,h.samplingMode=n,h.invertY=s,h._compression=o,h.type=l,h._creationFlags=u,h._useSRGBBuffer=c,this._doNotHandleContextLost||(h._bufferView=a),this._textureHelper.createGPUTextureForInternalTexture(h,e,t,void 0,u),this.updateRawTexture(h,a,i,s,o,l,c),this._internalTexturesCache.push(h),h};xt.prototype.updateRawTexture=function(a,e,t,i,r=null,s=0,n=!1){if(a){if(this._doNotHandleContextLost||(a._bufferView=e,a.invertY=i,a._compression=r,a._useSRGBBuffer=n),e){const o=a._hardwareTexture;t===4&&(e=ll(e,a.width,a.height,s));const u=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);this._textureHelper.updateTexture(u,a,a.width,a.height,a.depth,o.format,0,0,i,!1,0,0),a.generateMipMaps&&this._generateMipmaps(a,this._uploadEncoder)}a.isReady=!0}};xt.prototype.createRawCubeTexture=function(a,e,t,i,r,s,n,o=null){const l=new Dt(this,8);if(i===1&&!this._caps.textureFloatLinearFiltering?(r=!1,n=1,L.Warn("Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.")):i===2&&!this._caps.textureHalfFloatLinearFiltering?(r=!1,n=1,L.Warn("Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.")):i===1&&!this._caps.textureFloatRender?(r=!1,L.Warn("Render to float textures is not supported. Mipmap generation forced to false.")):i===2&&!this._caps.colorBufferFloat&&(r=!1,L.Warn("Render to half float textures is not supported. Mipmap generation forced to false.")),l.isCube=!0,l._originalFormat=t,l.format=t===4?5:t,l.type=i,l.generateMipMaps=r,l.width=e,l.height=e,l.samplingMode=n,this._doNotHandleContextLost||(l._bufferViewArray=a),l.invertY=s,l._compression=o,l._cachedWrapU=0,l._cachedWrapV=0,this._textureHelper.createGPUTextureForInternalTexture(l),t===4){const u=l._hardwareTexture;u._originalFormatIsRGB=!0}return a&&this.updateRawCubeTexture(l,a,t,i,s,o),l.isReady=!0,l};xt.prototype.updateRawCubeTexture=function(a,e,t,i,r,s=null){a._bufferViewArray=e,a.invertY=r,a._compression=s;const n=a._hardwareTexture,o=n._originalFormatIsRGB,l=[0,2,4,1,3,5],u=[];for(let c=0;c<e.length;++c){let h=e[l[c]];o&&(h=ll(h,a.width,a.height,i)),u.push(new Uint8Array(h.buffer,h.byteOffset,h.byteLength))}this._textureHelper.updateCubeTextures(u,n.underlyingResource,a.width,a.height,n.format,r,!1,0,0),a.generateMipMaps&&this._generateMipmaps(a,this._uploadEncoder),a.isReady=!0};xt.prototype.createRawCubeTextureFromUrl=function(a,e,t,i,r,s,n,o,l=null,u=null,c=3,h=!1){const d=this.createRawCubeTexture(null,t,i,r,!s,h,c,null);e==null||e.addPendingData(d),d.url=a,d.isReady=!1,this._internalTexturesCache.push(d);const f=(g,_)=>{e==null||e.removePendingData(d),u&&g&&u(g.status+" "+g.statusText,_)},p=g=>{const _=d.width,S=n(g);if(S){if(o){const b=i===4,y=o(S),T=d._hardwareTexture,v=[0,1,2,3,4,5];for(let E=0;E<y.length;E++){const R=_>>E,O=[];for(let w=0;w<6;w++){let M=y[E][v[w]];b&&(M=ll(M,R,R,r)),O.push(new Uint8Array(M.buffer,M.byteOffset,M.byteLength))}this._textureHelper.updateCubeTextures(O,T.underlyingResource,R,R,T.format,h,!1,0,0)}}else this.updateRawCubeTexture(d,S,i,r,h);d.isReady=!0,e==null||e.removePendingData(d),l&&l()}};return this._loadFile(a,g=>{p(g)},void 0,e==null?void 0:e.offlineProvider,!0,f),d};xt.prototype.createRawTexture3D=function(a,e,t,i,r,s,n,o,l=null,u=0,c=0){const d=new Dt(this,10);return d.baseWidth=e,d.baseHeight=t,d.baseDepth=i,d.width=e,d.height=t,d.depth=i,d.format=r,d.type=u,d.generateMipMaps=s,d.samplingMode=o,d.is3D=!0,d._creationFlags=c,this._doNotHandleContextLost||(d._bufferView=a),this._textureHelper.createGPUTextureForInternalTexture(d,e,t,void 0,c),this.updateRawTexture3D(d,a,r,n,l,u),this._internalTexturesCache.push(d),d};xt.prototype.updateRawTexture3D=function(a,e,t,i,r=null,s=0){if(this._doNotHandleContextLost||(a._bufferView=e,a.format=t,a.invertY=i,a._compression=r),e){const n=a._hardwareTexture;t===4&&(e=ll(e,a.width,a.height,s));const l=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);this._textureHelper.updateTexture(l,a,a.width,a.height,a.depth,n.format,0,0,i,!1,0,0),a.generateMipMaps&&this._generateMipmaps(a,this._uploadEncoder)}a.isReady=!0};xt.prototype.createRawTexture2DArray=function(a,e,t,i,r,s,n,o,l=null,u=0,c=0){const d=new Dt(this,11);return d.baseWidth=e,d.baseHeight=t,d.baseDepth=i,d.width=e,d.height=t,d.depth=i,d.format=r,d.type=u,d.generateMipMaps=s,d.samplingMode=o,d.is2DArray=!0,d._creationFlags=c,this._doNotHandleContextLost||(d._bufferView=a),this._textureHelper.createGPUTextureForInternalTexture(d,e,t,i,c),this.updateRawTexture2DArray(d,a,r,n,l,u),this._internalTexturesCache.push(d),d};xt.prototype.updateRawTexture2DArray=function(a,e,t,i,r=null,s=0){if(this._doNotHandleContextLost||(a._bufferView=e,a.format=t,a.invertY=i,a._compression=r),e){const n=a._hardwareTexture;t===4&&(e=ll(e,a.width,a.height,s));const l=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);this._textureHelper.updateTexture(l,a,a.width,a.height,a.depth,n.format,0,0,i,!1,0,0),a.generateMipMaps&&this._generateMipmaps(a,this._uploadEncoder)}a.isReady=!0};function ll(a,e,t,i){let r,s=1;i===1?r=new Float32Array(e*t*4):i===2?(r=new Uint16Array(e*t*4),s=15360):i===7?r=new Uint32Array(e*t*4):r=new Uint8Array(e*t*4);for(let n=0;n<e;n++)for(let o=0;o<t;o++){const l=(o*e+n)*3,u=(o*e+n)*4;r[u+0]=a[l+0],r[u+1]=a[l+1],r[u+2]=a[l+2],r[u+3]=s}return r}xt.prototype._readTexturePixels=function(a,e,t,i=-1,r=0,s=null,n=!0,o=!1,l=0,u=0){const c=a._hardwareTexture;return n&&this.flushFramebuffer(),this._textureHelper.readPixels(c.underlyingResource,l,u,e,t,c.format,i,r,s,o)};xt.prototype._readTexturePixelsSync=function(){throw"_readTexturePixelsSync is unsupported in WebGPU!"};xt.prototype._createDepthStencilCubeTexture=function(a,e){const t=new Dt(this,e.generateStencil?12:14);t.isCube=!0,t.label=e.label;const i={bilinearFiltering:!1,comparisonFunction:0,samples:1,depthTextureFormat:e.generateStencil?13:14,...e};t.format=i.depthTextureFormat,this._setupDepthStencilTexture(t,a,i.bilinearFiltering,i.comparisonFunction,i.samples),this._textureHelper.createGPUTextureForInternalTexture(t);const r=t._hardwareTexture;return t.type=et.GetTextureTypeFromFormat(r.format),this._internalTexturesCache.push(t),t};xt.prototype.createCubeTexture=function(a,e,t,i,r=null,s=null,n,o=null,l=!1,u=0,c=0,h=null,d,f=!1,p=null){return this.createCubeTextureBase(a,e,t,!!i,r,s,n,o,l,u,c,h,null,(g,_)=>{const S=_,b=S[0].width,y=b;this._setCubeMapTextureParams(g,!i),g.format=n??-1;const T=this._textureHelper.createGPUTextureForInternalTexture(g,b,y);this._textureHelper.updateCubeTextures(S,T.underlyingResource,b,y,T.format,!1,!1,0,0),i||this._generateMipmaps(g,this._uploadEncoder),g.isReady=!0,g.onLoadedObservable.notifyObservers(g),g.onLoadedObservable.clear(),r&&r()},!!f,p)};xt.prototype._setCubeMapTextureParams=function(a,e,t){a.samplingMode=e?3:2,a._cachedWrapU=0,a._cachedWrapV=0,t&&(a._maxLodLevel=t)};xt.prototype.generateMipMapsForCubemap=function(a){var e;a.generateMipMaps&&((e=a._hardwareTexture)!=null&&e.underlyingResource||this._textureHelper.createGPUTextureForInternalTexture(a),this._generateMipmaps(a))};class JO extends iy{constructor(e,t,i,r,s){super(e,t,i,r,s),r.enableGPUTimingMeasurements&&(this.gpuTimeInFrame=new l_)}}xt.prototype._createHardwareRenderTargetWrapper=function(a,e,t){const i=new JO(a,e,t,this);return this._renderTargetWrapperCache.push(i),i};xt.prototype.createRenderTargetTexture=function(a,e){var s;const t=this._createHardwareRenderTargetWrapper(!1,!1,a),i={};e!==void 0&&typeof e=="object"?(i.generateMipMaps=e.generateMipMaps,i.generateDepthBuffer=e.generateDepthBuffer===void 0?!0:e.generateDepthBuffer,i.generateStencilBuffer=i.generateDepthBuffer&&e.generateStencilBuffer,i.samplingMode=e.samplingMode===void 0?3:e.samplingMode,i.creationFlags=e.creationFlags??0,i.noColorAttachment=!!e.noColorAttachment,i.colorAttachment=e.colorAttachment,i.samples=e.samples,i.label=e.label,i.format=e.format,i.type=e.type):(i.generateMipMaps=e,i.generateDepthBuffer=!0,i.generateStencilBuffer=!1,i.samplingMode=3,i.creationFlags=0,i.noColorAttachment=!1);const r=i.colorAttachment||(i.noColorAttachment?null:this._createInternalTexture(a,i,!0,5));return t.label=i.label??"RenderTargetWrapper",t._samples=((s=i.colorAttachment)==null?void 0:s.samples)??i.samples??1,t._generateDepthBuffer=i.generateDepthBuffer,t._generateStencilBuffer=!!i.generateStencilBuffer,t.setTextures(r),(t._generateDepthBuffer||t._generateStencilBuffer)&&t.createDepthStencilTexture(0,!1,t._generateStencilBuffer,t.samples,i.generateStencilBuffer?13:14,i.label?i.label+"-DepthStencil":void 0),r&&!i.colorAttachment&&(e!==void 0&&typeof e=="object"&&e.createMipMaps&&!i.generateMipMaps&&(r.generateMipMaps=!0),this._textureHelper.createGPUTextureForInternalTexture(r,void 0,void 0,void 0,i.creationFlags),e!==void 0&&typeof e=="object"&&e.createMipMaps&&!i.generateMipMaps&&(r.generateMipMaps=!1)),t};xt.prototype._createDepthStencilTexture=function(a,e,t){const i={bilinearFiltering:!1,comparisonFunction:0,samples:1,depthTextureFormat:e.generateStencil?13:14,...e},r=Fm(i.depthTextureFormat);t._depthStencilTextureWithStencil=r;const s=new Dt(this,r?12:14);return s.label=e.label,s.format=i.depthTextureFormat,s.type=sy(s.format),this._setupDepthStencilTexture(s,a,i.bilinearFiltering,i.comparisonFunction,i.samples),this._textureHelper.createGPUTextureForInternalTexture(s),this._internalTexturesCache.push(s),s};xt.prototype._setupDepthStencilTexture=function(a,e,t,i,r=1){const s=e.width??e,n=e.height??e,o=e.layers||0,l=e.depth||0;a.baseWidth=s,a.baseHeight=n,a.width=s,a.height=n,a.is2DArray=o>0,a.is3D=l>0,a.depth=o||l,a.isReady=!0,a.samples=r,a.generateMipMaps=!1,a.samplingMode=t?2:1,a.type=1,a._comparisonFunction=i,a._cachedWrapU=0,a._cachedWrapV=0};xt.prototype.updateRenderTargetTextureSampleCount=function(a,e){return!a||!a.texture||a.samples===e||(e=Math.min(e,this.getCaps().maxMSAASamples),this._textureHelper.createMSAATexture(a.texture,e),a._depthStencilTexture&&(this._textureHelper.createMSAATexture(a._depthStencilTexture,e),a._depthStencilTexture.samples=e),a._samples=e,a.texture.samples=e),e};xt.prototype.setDepthStencilTexture=function(a,e,t,i){!t||!t.depthStencilTexture?this._setTexture(a,null,void 0,void 0,i):this._setTexture(a,t,!1,!0,i)};xt.prototype.createRenderTargetCubeTexture=function(a,e){const t=this._createHardwareRenderTargetWrapper(!1,!0,a),i={generateMipMaps:!0,generateDepthBuffer:!0,generateStencilBuffer:!1,type:0,samplingMode:3,format:5,samples:1,...e};i.generateStencilBuffer=i.generateDepthBuffer&&i.generateStencilBuffer,t.label=i.label??"RenderTargetWrapper",t._generateDepthBuffer=i.generateDepthBuffer,t._generateStencilBuffer=i.generateStencilBuffer;const r=new Dt(this,5);return r.width=a,r.height=a,r.depth=0,r.isReady=!0,r.isCube=!0,r.samples=i.samples,r.generateMipMaps=i.generateMipMaps,r.samplingMode=i.samplingMode,r.type=i.type,r.format=i.format,this._internalTexturesCache.push(r),t.setTextures(r),(t._generateDepthBuffer||t._generateStencilBuffer)&&t.createDepthStencilTexture(0,i.samplingMode===void 0||i.samplingMode===2||i.samplingMode===2||i.samplingMode===3||i.samplingMode===3||i.samplingMode===5||i.samplingMode===6||i.samplingMode===7||i.samplingMode===11,t._generateStencilBuffer,t.samples),e&&e.createMipMaps&&!i.generateMipMaps&&(r.generateMipMaps=!0),this._textureHelper.createGPUTextureForInternalTexture(r),e&&e.createMipMaps&&!i.generateMipMaps&&(r.generateMipMaps=!1),t};xt.prototype.getGPUFrameTimeCounter=function(){return this._timestampQuery.gpuFrameTimeCounter};xt.prototype.captureGPUFrameTime=function(a){this._timestampQuery.enable=a&&!!this._caps.timerQuery};xt.prototype.createQuery=function(){return this._occlusionQuery.createQuery()};xt.prototype.deleteQuery=function(a){return this._occlusionQuery.deleteQuery(a),this};xt.prototype.isQueryResultAvailable=function(a){return this._occlusionQuery.isQueryResultAvailable(a)};xt.prototype.getQueryResult=function(a){return this._occlusionQuery.getQueryResult(a)};xt.prototype.beginOcclusionQuery=function(a,e){var t;if(this.compatibilityMode){if(this._occlusionQuery.canBeginQuery(e))return(t=this._currentRenderPass)==null||t.beginOcclusionQuery(e),!0}else return this._bundleList.addItem(new C_(e)),!0;return!1};xt.prototype.endOcclusionQuery=function(){var a;return this.compatibilityMode?(a=this._currentRenderPass)==null||a.endOcclusionQuery():this._bundleList.addItem(new P_),this};const kx={label:"TextureView_SwapChain_ResolveTarget",dimension:"2d",format:void 0,mipLevelCount:1,arrayLayerCount:1},zx={label:"TextureView_SwapChain",dimension:"2d",format:void 0,mipLevelCount:1,arrayLayerCount:1},ew=new xe;class ct extends xt{get snapshotRenderingMode(){return this._snapshotRendering.mode}set snapshotRenderingMode(e){this._snapshotRendering.mode=e}snapshotRenderingReset(){this._snapshotRendering.reset()}get snapshotRendering(){return this._snapshotRendering.enabled}set snapshotRendering(e){this._snapshotRendering.enabled=e}get disableCacheSamplers(){return this._cacheSampler?this._cacheSampler.disabled:!1}set disableCacheSamplers(e){this._cacheSampler&&(this._cacheSampler.disabled=e)}get disableCacheRenderPipelines(){return this._cacheRenderPipeline?this._cacheRenderPipeline.disabled:!1}set disableCacheRenderPipelines(e){this._cacheRenderPipeline&&(this._cacheRenderPipeline.disabled=e)}get disableCacheBindGroups(){return this._cacheBindGroups?this._cacheBindGroups.disabled:!1}set disableCacheBindGroups(e){this._cacheBindGroups&&(this._cacheBindGroups.disabled=e)}areAllEffectsReady(){return!0}getFontOffset(e){return HR(e)}static get IsSupportedAsync(){return navigator.gpu?navigator.gpu.requestAdapter().then(e=>!!e,()=>!1).catch(()=>!1):Promise.resolve(!1)}static get IsSupported(){return L.Warn("You must call IsSupportedAsync for WebGPU!"),!1}get supportsUniformBuffers(){return!0}get supportedExtensions(){return this._adapterSupportedExtensions}get enabledExtensions(){return this._deviceEnabledExtensions}get supportedLimits(){return this._adapterSupportedLimits}get currentLimits(){return this._deviceLimits}get description(){return this.name+this.version}get version(){return 1}getInfo(){return{vendor:this._adapterInfo.vendor||"unknown vendor",renderer:this._adapterInfo.architecture||"unknown renderer",version:this._adapterInfo.description||"unknown version"}}get compatibilityMode(){return this._compatibilityMode}set compatibilityMode(e){this._compatibilityMode=e}get currentSampleCount(){return this._currentRenderTarget?this._currentRenderTarget.samples:this._mainPassSampleCount}static CreateAsync(e,t={}){const i=new ct(e,t);return new Promise(r=>{i.initAsync(t.glslangOptions,t.twgslOptions).then(()=>r(i))})}constructor(e,t={}){if(super(t.antialias??!0,t),this.uniqueId=-1,this._uploadEncoderDescriptor={label:"upload"},this._renderEncoderDescriptor={label:"render"},this._clearDepthValue=1,this._clearReverseDepthValue=0,this._clearStencilValue=0,this._defaultSampleCount=4,this._glslang=null,this._tintWASM=null,this._glslangAndTintAreFullyLoaded=!1,this._adapterInfo={vendor:"",architecture:"",device:"",description:""},this._compiledComputeEffects={},this._counters={numEnableEffects:0,numEnableDrawWrapper:0,numBundleCreationNonCompatMode:0,numBundleReuseNonCompatMode:0},this.countersLastFrame={numEnableEffects:0,numEnableDrawWrapper:0,numBundleCreationNonCompatMode:0,numBundleReuseNonCompatMode:0},this.numMaxUncapturedErrors=20,this.scenes=[],this._virtualScenes=new Array,this._commandBuffers=[null,null],this._mainRenderPassWrapper={renderPassDescriptor:null,colorAttachmentViewDescriptor:null,depthAttachmentViewDescriptor:null,colorAttachmentGPUTextures:[],depthTextureFormat:void 0},this._rttRenderPassWrapper={renderPassDescriptor:null,colorAttachmentViewDescriptor:null,depthAttachmentViewDescriptor:null,colorAttachmentGPUTextures:[],depthTextureFormat:void 0},this._pendingDebugCommands=[],this._currentOverrideVertexBuffers=null,this._currentIndexBuffer=null,this._colorWriteLocal=!0,this._forceEnableEffect=!1,this.isNDCHalfZRange=!0,this.hasOriginBottomLeft=!1,this._workingGlslangAndTintPromise=null,this._viewportsCurrent={x:0,y:0,w:0,h:0},this._scissorsCurrent={x:0,y:0,w:0,h:0},this._scissorCached={x:0,y:0,z:0,w:0},this._stencilRefsCurrent=-1,this._blendColorsCurrent=[null,null,null,null],this._performanceMonitor=new jR,this._name="WebGPU",this._drawCalls=new fu,t.deviceDescriptor=t.deviceDescriptor||{},t.enableGPUDebugMarkers=t.enableGPUDebugMarkers??!1,L.Log(`Babylon.js v${st.Version} - ${this.description} engine`),!navigator.gpu){L.Error("WebGPU is not supported by your browser.");return}t.swapChainFormat=t.swapChainFormat||navigator.gpu.getPreferredCanvasFormat(),this._isWebGPU=!0,this._shaderPlatformName="WEBGPU",this._renderingCanvas=e,this._options=t,this._mainPassSampleCount=t.antialias?this._defaultSampleCount:1,navigator&&navigator.userAgent&&this._setupMobileChecks(),this._sharedInit(this._renderingCanvas),this._shaderProcessor=new bO,this._shaderProcessorWGSL=new PO}prepareGlslangAndTintAsync(){return this._workingGlslangAndTintPromise||(this._workingGlslangAndTintPromise=new Promise(e=>{var t;this._initGlslang(this._glslangOptions??((t=this._options)==null?void 0:t.glslangOptions)).then(i=>{var r;this._glslang=i,this._tintWASM=new $i,this._tintWASM.initTwgsl(this._twgslOptions??((r=this._options)==null?void 0:r.twgslOptions)).then(()=>{this._glslangAndTintAreFullyLoaded=!0,e()})})})),this._workingGlslangAndTintPromise}initAsync(e,t){return this.uniqueId=ct._InstanceId++,this._glslangOptions=e,this._twgslOptions=t,navigator.gpu.requestAdapter(this._options).then(i=>{var r;if(i){this._adapter=i,this._adapterSupportedExtensions=[],(r=this._adapter.features)==null||r.forEach(o=>this._adapterSupportedExtensions.push(o)),this._adapterSupportedLimits=this._adapter.limits,this._adapterInfo=this._adapter.info;const s=this._options.deviceDescriptor??{},n=(s==null?void 0:s.requiredFeatures)??(this._options.enableAllFeatures?this._adapterSupportedExtensions:void 0);if(n){const o=n,l=[];for(const u of o)this._adapterSupportedExtensions.indexOf(u)!==-1&&l.push(u);s.requiredFeatures=l}if(this._options.setMaximumLimits&&!s.requiredLimits){s.requiredLimits={};for(const o in this._adapterSupportedLimits)o==="minSubgroupSize"||o==="maxSubgroupSize"||(s.requiredLimits[o]=this._adapterSupportedLimits[o])}return s.label=`BabylonWebGPUDevice${this.uniqueId}`,this._adapter.requestDevice(s)}else throw"Could not retrieve a WebGPU adapter (adapter is null)."}).then(i=>{var s,n;this._device=i,this._deviceEnabledExtensions=[],(s=this._device.features)==null||s.forEach(o=>this._deviceEnabledExtensions.push(o)),this._deviceLimits=i.limits;let r=-1;this._device.addEventListener("uncapturederror",o=>{++r<this.numMaxUncapturedErrors?L.Warn(`WebGPU uncaptured error (${r+1}): ${o.error} - ${o.error.message}`):r++===this.numMaxUncapturedErrors&&L.Warn(`WebGPU uncaptured error: too many warnings (${this.numMaxUncapturedErrors}), no more warnings will be reported to the console for this engine.`)}),this._doNotHandleContextLost||(n=this._device.lost)==null||n.then(o=>{this._isDisposed||(this._contextWasLost=!0,L.Warn("WebGPU context lost. "+o),this.onContextLostObservable.notifyObservers(this),this._restoreEngineAfterContextLost(async()=>{var p,g;const l=this.snapshotRenderingMode,u=this.snapshotRendering,c=this.disableCacheSamplers,h=this.disableCacheRenderPipelines,d=this.disableCacheBindGroups,f=this.enableGPUTimingMeasurements;await this.initAsync(this._glslangOptions??((p=this._options)==null?void 0:p.glslangOptions),this._twgslOptions??((g=this._options)==null?void 0:g.twgslOptions)),this.snapshotRenderingMode=l,this.snapshotRendering=u,this.disableCacheSamplers=c,this.disableCacheRenderPipelines=h,this.disableCacheBindGroups=d,this.enableGPUTimingMeasurements=f,this._currentRenderPass=null}))})}).then(()=>{this._initializeLimits(),this._bufferManager=new Yl(this,this._device),this._textureHelper=new LO(this,this._device,this._bufferManager,this._deviceEnabledExtensions),this._cacheSampler=new An(this._device),this._cacheBindGroups=new at(this._device,this._cacheSampler,this),this._timestampQuery=new XO(this,this._device,this._bufferManager),this._occlusionQuery=this._device.createQuerySet?new qO(this,this._device,this._bufferManager):void 0,this._bundleList=new I_(this._device),this._snapshotRendering=new QO(this,this._snapshotRenderingMode,this._bundleList),this._ubInvertY=this._bufferManager.createBuffer(new Float32Array([-1,0]),tt.Uniform|tt.CopyDst,"UBInvertY"),this._ubDontInvertY=this._bufferManager.createBuffer(new Float32Array([1,0]),tt.Uniform|tt.CopyDst,"UBDontInvertY"),this.dbgVerboseLogsForFirstFrames&&this._count===void 0&&(this._count=0,L.Log(["%c frame #"+this._count+" - begin","background: #ffff00"])),this._uploadEncoder=this._device.createCommandEncoder(this._uploadEncoderDescriptor),this._renderEncoder=this._device.createCommandEncoder(this._renderEncoderDescriptor),this._emptyVertexBuffer=new N(this,[0],"",{stride:1,offset:0,size:1,label:"EmptyVertexBuffer"}),this._cacheRenderPipeline=new Nr(this._device,this._emptyVertexBuffer),this._depthCullingState=new GO(this._cacheRenderPipeline),this._stencilStateComposer=new UO(this._cacheRenderPipeline),this._stencilStateComposer.stencilGlobal=this._stencilState,this._depthCullingState.depthTest=!0,this._depthCullingState.depthFunc=515,this._depthCullingState.depthMask=!0,this._textureHelper.setCommandEncoder(this._uploadEncoder),this._clearQuad=new YO(this._device,this,this._emptyVertexBuffer),this._defaultDrawContext=this.createDrawContext(),this._currentDrawContext=this._defaultDrawContext,this._defaultMaterialContext=this.createMaterialContext(),this._currentMaterialContext=this._defaultMaterialContext,this._initializeContextAndSwapChain(),this._initializeMainAttachments(),this.resize()}).catch(i=>{throw L.Error("A fatal error occurred during WebGPU creation/initialization."),i})}_initGlslang(e){return e=e||{},e={...ct._GlslangDefaultOptions,...e},e.glslang?Promise.resolve(e.glslang):self.glslang?self.glslang(e.wasmPath):e.jsPath&&e.wasmPath?ae.LoadBabylonScriptAsync(e.jsPath).then(()=>self.glslang(ae.GetBabylonScriptURL(e.wasmPath))):Promise.reject("gslang is not available.")}_initializeLimits(){this._caps={maxTexturesImageUnits:this._deviceLimits.maxSampledTexturesPerShaderStage,maxVertexTextureImageUnits:this._deviceLimits.maxSampledTexturesPerShaderStage,maxCombinedTexturesImageUnits:this._deviceLimits.maxSampledTexturesPerShaderStage*2,maxTextureSize:this._deviceLimits.maxTextureDimension2D,maxCubemapTextureSize:this._deviceLimits.maxTextureDimension2D,maxRenderTextureSize:this._deviceLimits.maxTextureDimension2D,maxVertexAttribs:this._deviceLimits.maxVertexAttributes,maxDrawBuffers:8,maxVaryingVectors:this._deviceLimits.maxInterStageShaderVariables,maxFragmentUniformVectors:Math.floor(this._deviceLimits.maxUniformBufferBindingSize/4),maxVertexUniformVectors:Math.floor(this._deviceLimits.maxUniformBufferBindingSize/4),standardDerivatives:!0,astc:this._deviceEnabledExtensions.indexOf("texture-compression-astc")>=0?!0:void 0,s3tc:this._deviceEnabledExtensions.indexOf("texture-compression-bc")>=0?!0:void 0,pvrtc:null,etc1:null,etc2:this._deviceEnabledExtensions.indexOf("texture-compression-etc2")>=0?!0:void 0,bptc:this._deviceEnabledExtensions.indexOf("texture-compression-bc")>=0?!0:void 0,maxAnisotropy:16,uintIndices:!0,fragmentDepthSupported:!0,highPrecisionShaderSupported:!0,colorBufferFloat:!0,supportFloatTexturesResolve:!1,rg11b10ufColorRenderable:this._deviceEnabledExtensions.indexOf("rg11b10ufloat-renderable")>=0,textureFloat:!0,textureFloatLinearFiltering:this._deviceEnabledExtensions.indexOf("float32-filterable")>=0,textureFloatRender:!0,textureHalfFloat:!0,textureHalfFloatLinearFiltering:!0,textureHalfFloatRender:!0,textureLOD:!0,texelFetch:!0,drawBuffersExtension:!0,depthTextureExtension:!0,vertexArrayObject:!1,instancedArrays:!0,timerQuery:typeof BigUint64Array<"u"&&this._deviceEnabledExtensions.indexOf("timestamp-query")!==-1?!0:void 0,supportOcclusionQuery:typeof BigUint64Array<"u",canUseTimestampForTimerQuery:!0,multiview:!1,oculusMultiview:!1,parallelShaderCompile:void 0,blendMinMax:!0,maxMSAASamples:4,canUseGLInstanceID:!0,canUseGLVertexID:!0,supportComputeShaders:!0,supportSRGBBuffers:!0,supportTransformFeedbacks:!1,textureMaxLevel:!0,texture2DArrayMaxLayerCount:this._deviceLimits.maxTextureArrayLayers,disableMorphTargetTexture:!1,textureNorm16:!1},this._features={forceBitmapOverHTMLImageElement:!0,supportRenderAndCopyToLodForFloatTextures:!0,supportDepthStencilTexture:!0,supportShadowSamplers:!0,uniformBufferHardCheckMatrix:!1,allowTexturePrefiltering:!0,trackUbosInFrame:!0,checkUbosContentBeforeUpload:!0,supportCSM:!0,basisNeedsPOT:!1,support3DTextures:!0,needTypeSuffixInShaderConstants:!0,supportMSAA:!0,supportSSAO2:!0,supportIBLShadows:!0,supportExtendedTextureFormats:!0,supportSwitchCaseInShader:!0,supportSyncTextureRead:!1,needsInvertingBitmap:!1,useUBOBindingCache:!1,needShaderCodeInlining:!0,needToAlwaysBindUniformBuffers:!0,supportRenderPasses:!0,supportSpriteInstancing:!0,forceVertexBufferStrideAndOffsetMultiple4Bytes:!0,_checkNonFloatVertexBuffersDontRecreatePipelineContext:!0,_collectUbosUpdatedInFrame:!1}}_initializeContextAndSwapChain(){if(!this._renderingCanvas)throw"The rendering canvas has not been set!";this._context=this._renderingCanvas.getContext("webgpu"),this._configureContext(),this._colorFormat=this._options.swapChainFormat,this._mainRenderPassWrapper.colorAttachmentGPUTextures=[new Vl(this)],this._mainRenderPassWrapper.colorAttachmentGPUTextures[0].format=this._colorFormat,this._setColorFormat(this._mainRenderPassWrapper)}_initializeMainAttachments(){if(!this._bufferManager)return;this.flushFramebuffer(),this._mainTextureExtends={width:this.getRenderWidth(!0),height:this.getRenderHeight(!0),depthOrArrayLayers:1};const e=new Float32Array([this.getRenderHeight(!0)]);this._bufferManager.setSubData(this._ubInvertY,4,e),this._bufferManager.setSubData(this._ubDontInvertY,4,e);let t;if(this._options.antialias){const s={label:`Texture_MainColor_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}_antialiasing`,size:this._mainTextureExtends,mipLevelCount:1,sampleCount:this._mainPassSampleCount,dimension:"2d",format:this._options.swapChainFormat,usage:16};this._mainTexture&&this._textureHelper.releaseTexture(this._mainTexture),this._mainTexture=this._device.createTexture(s),t=[{view:this._mainTexture.createView({label:"TextureView_MainColor_antialiasing",dimension:"2d",format:this._options.swapChainFormat,mipLevelCount:1,arrayLayerCount:1}),clearValue:new xe(0,0,0,1),loadOp:"clear",storeOp:"store"}]}else t=[{view:void 0,clearValue:new xe(0,0,0,1),loadOp:"clear",storeOp:"store"}];this._mainRenderPassWrapper.depthTextureFormat=this.isStencilEnable?"depth24plus-stencil8":"depth32float",this._setDepthTextureFormat(this._mainRenderPassWrapper),this._setColorFormat(this._mainRenderPassWrapper);const i={label:`Texture_MainDepthStencil_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}`,size:this._mainTextureExtends,mipLevelCount:1,sampleCount:this._mainPassSampleCount,dimension:"2d",format:this._mainRenderPassWrapper.depthTextureFormat,usage:16};this._depthTexture&&this._textureHelper.releaseTexture(this._depthTexture),this._depthTexture=this._device.createTexture(i);const r={view:this._depthTexture.createView({label:`TextureView_MainDepthStencil_${this._mainTextureExtends.width}x${this._mainTextureExtends.height}`,dimension:"2d",format:this._depthTexture.format,mipLevelCount:1,arrayLayerCount:1}),depthClearValue:this._clearDepthValue,depthLoadOp:"clear",depthStoreOp:"store",stencilClearValue:this._clearStencilValue,stencilLoadOp:this.isStencilEnable?"clear":void 0,stencilStoreOp:this.isStencilEnable?"store":void 0};this._mainRenderPassWrapper.renderPassDescriptor={label:"MainRenderPass",colorAttachments:t,depthStencilAttachment:r}}_sharedInit(e){super._sharedInit(e),YR(this,e,this._creationOptions)}_configureContext(){this._context.configure({device:this._device,format:this._options.swapChainFormat,usage:17,alphaMode:this.premultipliedAlpha?"premultiplied":"opaque"})}resizeImageBitmap(e,t,i){return XR(this,e,t,i)}_createImageBitmapFromSource(e,t){return ZR(this,e,t)}switchFullscreen(e){this.isFullscreen?this.exitFullscreen():this.enterFullscreen(e)}enterFullscreen(e){this.isFullscreen||(this._pointerLockRequested=e,this._renderingCanvas&&qR(this._renderingCanvas))}exitFullscreen(){this.isFullscreen&&QR()}enterPointerlock(){this._renderingCanvas&&KR(this._renderingCanvas)}exitPointerlock(){JR()}_rebuildBuffers(){super._rebuildBuffers();for(const e of this._storageBuffers)e.getBuffer().engineId!==this.uniqueId&&e._rebuild()}_restoreEngineAfterContextLost(e){Nr.ResetCache(),at.ResetCache();const t=r=>{var s;for(const n of r){for(const o of n.meshes){const l=o.subMeshes;if(l)for(const u of l)u._drawWrappers=[]}for(const o of n.materials)(s=o._materialContext)==null||s.reset()}};t(this.scenes),t(this._virtualScenes);const i=[];for(const r of this._uniformBuffers)r.name.indexOf("leftOver")<0&&i.push(r);this._uniformBuffers=i,super._restoreEngineAfterContextLost(e)}setSize(e,t,i=!1){return super.setSize(e,t,i)?(this.dbgVerboseLogsForFirstFrames&&(this._count===void 0&&(this._count=0),(!this._count||this._count<this.dbgVerboseLogsNumFrames)&&L.Log(["frame #"+this._count+" - setSize -",e,t])),this._initializeMainAttachments(),this.snapshotRendering&&this.snapshotRenderingReset(),!0):!1}_getShaderProcessor(e){return e===1?this._shaderProcessorWGSL:this._shaderProcessor}_getShaderProcessingContext(e,t){return new Ki(e,t)}_getCurrentRenderPass(){return this._currentRenderTarget&&!this._currentRenderPass?this._startRenderTargetRenderPass(this._currentRenderTarget,!1,null,!1,!1):this._currentRenderPass||this._startMainRenderPass(!1),this._currentRenderPass}_getCurrentRenderPassWrapper(){return this._currentRenderTarget?this._rttRenderPassWrapper:this._mainRenderPassWrapper}applyStates(){this._stencilStateComposer.apply(),this._cacheRenderPipeline.setAlphaBlendEnabled(this._alphaState.alphaBlend)}wipeCaches(e){this.preventCacheWipeBetweenFrames&&!e||(this._forceEnableEffect=!0,this._currentIndexBuffer=null,this._currentOverrideVertexBuffers=null,this._cacheRenderPipeline.setBuffers(null,null,null),e&&(this._stencilStateComposer.reset(),this._depthCullingState.reset(),this._depthCullingState.depthFunc=515,this._alphaState.reset(),this._alphaMode=1,this._alphaEquation=0,this._cacheRenderPipeline.setAlphaBlendFactors(this._alphaState._blendFunctionParameters,this._alphaState._blendEquationParameters),this._cacheRenderPipeline.setAlphaBlendEnabled(!1),this.setColorWrite(!0)),this._cachedVertexBuffers=null,this._cachedIndexBuffer=null,this._cachedEffectForVertexBuffers=null)}setColorWrite(e){this._colorWriteLocal=e,this._cacheRenderPipeline.setWriteMask(e?15:0)}getColorWrite(){return this._colorWriteLocal}_mustUpdateViewport(){const e=this._viewportCached.x,t=this._viewportCached.y,i=this._viewportCached.z,r=this._viewportCached.w,s=this._viewportsCurrent.x!==e||this._viewportsCurrent.y!==t||this._viewportsCurrent.w!==i||this._viewportsCurrent.h!==r;return s&&(this._viewportsCurrent.x=this._viewportCached.x,this._viewportsCurrent.y=this._viewportCached.y,this._viewportsCurrent.w=this._viewportCached.z,this._viewportsCurrent.h=this._viewportCached.w),s}_applyViewport(e){const t=Math.floor(this._viewportCached.x),i=Math.floor(this._viewportCached.z),r=Math.floor(this._viewportCached.w);let s=Math.floor(this._viewportCached.y);this._currentRenderTarget||(s=this.getRenderHeight(!0)-s-r),e?e.addItem(new b_(t,s,i,r)):this._getCurrentRenderPass().setViewport(t,s,i,r,0,1),this.dbgVerboseLogsForFirstFrames&&(this._count===void 0&&(this._count=0),(!this._count||this._count<this.dbgVerboseLogsNumFrames)&&L.Log(["frame #"+this._count+" - viewport applied - (",this._viewportCached.x,this._viewportCached.y,this._viewportCached.z,this._viewportCached.w,") current pass is main pass="+this._currentPassIsMainPass()]))}_viewport(e,t,i,r){this._viewportCached.x=e,this._viewportCached.y=t,this._viewportCached.z=i,this._viewportCached.w=r}_mustUpdateScissor(){const e=this._scissorCached.x,t=this._scissorCached.y,i=this._scissorCached.z,r=this._scissorCached.w,s=this._scissorsCurrent.x!==e||this._scissorsCurrent.y!==t||this._scissorsCurrent.w!==i||this._scissorsCurrent.h!==r;return s&&(this._scissorsCurrent.x=this._scissorCached.x,this._scissorsCurrent.y=this._scissorCached.y,this._scissorsCurrent.w=this._scissorCached.z,this._scissorsCurrent.h=this._scissorCached.w),s}_applyScissor(e){const t=this._currentRenderTarget?this._scissorCached.y:this.getRenderHeight()-this._scissorCached.w-this._scissorCached.y;e?e.addItem(new y_(this._scissorCached.x,t,this._scissorCached.z,this._scissorCached.w)):this._getCurrentRenderPass().setScissorRect(this._scissorCached.x,t,this._scissorCached.z,this._scissorCached.w),this.dbgVerboseLogsForFirstFrames&&(this._count===void 0&&(this._count=0),(!this._count||this._count<this.dbgVerboseLogsNumFrames)&&L.Log(["frame #"+this._count+" - scissor applied - (",this._scissorCached.x,this._scissorCached.y,this._scissorCached.z,this._scissorCached.w,") current pass is main pass="+this._currentPassIsMainPass()]))}_scissorIsActive(){return this._scissorCached.x!==0||this._scissorCached.y!==0||this._scissorCached.z!==0||this._scissorCached.w!==0}enableScissor(e,t,i,r){this._scissorCached.x=e,this._scissorCached.y=t,this._scissorCached.z=i,this._scissorCached.w=r}disableScissor(){this._scissorCached.x=this._scissorCached.y=this._scissorCached.z=this._scissorCached.w=0,this._scissorsCurrent.x=this._scissorsCurrent.y=this._scissorsCurrent.w=this._scissorsCurrent.h=0}_mustUpdateStencilRef(){const e=this._stencilStateComposer.funcRef!==this._stencilRefsCurrent;return e&&(this._stencilRefsCurrent=this._stencilStateComposer.funcRef),e}_applyStencilRef(e){e?e.addItem(new Xl(this._stencilStateComposer.funcRef??0)):this._getCurrentRenderPass().setStencilReference(this._stencilStateComposer.funcRef??0)}_mustUpdateBlendColor(){const e=this._alphaState._blendConstants,t=e[0]!==this._blendColorsCurrent[0]||e[1]!==this._blendColorsCurrent[1]||e[2]!==this._blendColorsCurrent[2]||e[3]!==this._blendColorsCurrent[3];return t&&(this._blendColorsCurrent[0]=e[0],this._blendColorsCurrent[1]=e[1],this._blendColorsCurrent[2]=e[2],this._blendColorsCurrent[3]=e[3]),t}_applyBlendColor(e){e?e.addItem(new T_(this._alphaState._blendConstants.slice())):this._getCurrentRenderPass().setBlendConstant(this._alphaState._blendConstants)}_resetRenderPassStates(){this._viewportsCurrent.x=this._viewportsCurrent.y=this._viewportsCurrent.w=this._viewportsCurrent.h=0,this._scissorsCurrent.x=this._scissorsCurrent.y=this._scissorsCurrent.w=this._scissorsCurrent.h=0,this._stencilRefsCurrent=-1,this._blendColorsCurrent[0]=this._blendColorsCurrent[1]=this._blendColorsCurrent[2]=this._blendColorsCurrent[3]=null}clear(e,t,i,r=!1){e&&e.a===void 0&&(e.a=1);const s=this._scissorIsActive();this.dbgVerboseLogsForFirstFrames&&(this._count===void 0&&(this._count=0),(!this._count||this._count<this.dbgVerboseLogsNumFrames)&&L.Log(["frame #"+this._count+" - clear - backBuffer=",t," depth=",i," stencil=",r," scissor is active=",s])),this._currentRenderTarget?s?(this._currentRenderPass||this._startRenderTargetRenderPass(this._currentRenderTarget,!1,t?e:null,i,r),this._applyScissor(this.compatibilityMode?null:this._bundleList),this._clearFullQuad(t?e:null,i,r)):(this._currentRenderPass&&this._endCurrentRenderPass(),this._startRenderTargetRenderPass(this._currentRenderTarget,!0,t?e:null,i,r)):((!this._currentRenderPass||!s)&&this._startMainRenderPass(!s,t?e:null,i,r),s&&(this._applyScissor(this.compatibilityMode?null:this._bundleList),this._clearFullQuad(t?e:null,i,r)))}_clearFullQuad(e,t,i){const r=this.compatibilityMode?this._getCurrentRenderPass():null;this._clearQuad.setColorFormat(this._colorFormat),this._clearQuad.setDepthStencilFormat(this._depthTextureFormat),this._clearQuad.setMRTAttachments(this._cacheRenderPipeline.mrtAttachments??[],this._cacheRenderPipeline.mrtTextureArray??[],this._cacheRenderPipeline.mrtTextureCount),this.compatibilityMode?r.setStencilReference(this._clearStencilValue):this._bundleList.addItem(new Xl(this._clearStencilValue));const s=this._clearQuad.clear(r,e,t,i,this.currentSampleCount);this.compatibilityMode?this._applyStencilRef(null):(this._bundleList.addBundle(s),this._applyStencilRef(this._bundleList),this._reportDrawCall())}createVertexBuffer(e,t,i){let r;return e instanceof Array?r=new Float32Array(e):e instanceof ArrayBuffer?r=new Uint8Array(e):r=e,this._bufferManager.createBuffer(r,tt.Vertex|tt.CopyDst,i)}createDynamicVertexBuffer(e,t){return this.createVertexBuffer(e,void 0,t)}createIndexBuffer(e,t,i){let r=!0,s;if(e instanceof Uint32Array||e instanceof Int32Array)s=e;else if(e instanceof Uint16Array)s=e,r=!1;else{for(let o=0;o<e.length;o++)if(e[o]>65535){s=new Uint32Array(e);break}s||(s=new Uint16Array(e),r=!1)}const n=this._bufferManager.createBuffer(s,tt.Index|tt.CopyDst,i);return n.is32Bits=r,n}updateDynamicIndexBuffer(e,t,i=0){const r=e;let s;e.is32Bits?s=t instanceof Uint32Array?t:new Uint32Array(t):s=t instanceof Uint16Array?t:new Uint16Array(t),this._bufferManager.setSubData(r,i,s)}updateDynamicVertexBuffer(e,t,i,r){const s=e;i===void 0&&(i=0);let n;r===void 0?(t instanceof Array?n=new Float32Array(t):t instanceof ArrayBuffer?n=new Uint8Array(t):n=t,r=n.byteLength):t instanceof Array?n=new Float32Array(t):t instanceof ArrayBuffer?n=new Uint8Array(t):n=t,this._bufferManager.setSubData(s,i,n,0,r)}_createBuffer(e,t,i){let r;e instanceof Array?r=new Float32Array(e):e instanceof ArrayBuffer?r=new Uint8Array(e):r=e;let s=0;return t&1&&(s|=tt.CopySrc),t&2&&(s|=tt.CopyDst),t&4&&(s|=tt.Uniform),t&8&&(s|=tt.Vertex),t&16&&(s|=tt.Index),t&32&&(s|=tt.Storage),t&64&&(s|=tt.Indirect),this._bufferManager.createBuffer(r,s,i)}bindBuffersDirectly(){throw"Not implemented on WebGPU"}updateAndBindInstancesBuffer(){throw"Not implemented on WebGPU"}unbindInstanceAttributes(){}bindBuffers(e,t,i,r){this._currentIndexBuffer=t,this._currentOverrideVertexBuffers=r??null,this._cacheRenderPipeline.setBuffers(e,t,this._currentOverrideVertexBuffers)}_releaseBuffer(e){return this._bufferManager.releaseBuffer(e)}createUniformBuffer(e,t){let i;return e instanceof Array?i=new Float32Array(e):i=e,this._bufferManager.createBuffer(i,tt.Uniform|tt.CopyDst,t)}createDynamicUniformBuffer(e,t){return this.createUniformBuffer(e,t)}updateUniformBuffer(e,t,i,r){i===void 0&&(i=0);const s=e;let n;r===void 0?(t instanceof Float32Array?n=t:n=new Float32Array(t),r=n.byteLength):t instanceof Float32Array?n=t:n=new Float32Array(t),this._bufferManager.setSubData(s,i,n,0,r)}bindUniformBufferBase(e,t,i){this._currentDrawContext.setBuffer(i,e)}bindUniformBlock(){}createEffect(e,t,i,r,s,n,o,l,u,c=0,h){const d=typeof e=="string"?e:e.vertexToken||e.vertexSource||e.vertexElement||e.vertex,f=typeof e=="string"?e:e.fragmentToken||e.fragmentSource||e.fragmentElement||e.fragment,p=this._getGlobalDefines(),g=t.attributes!==void 0;let _=s??t.defines??"";p&&(_+=`
`+p);const S=d+"+"+f+"@"+_;if(this._compiledEffects[S]){const y=this._compiledEffects[S];return o&&y.isReady()&&o(y),y._refCount++,y}const b=new _i(e,t,g?this:i,r,this,s,n,o,l,u,S,t.shaderLanguage??c,t.extraInitializationsAsync??h);return this._compiledEffects[S]=b,b}_compileRawShaderToSpirV(e,t){return this._glslang.compileGLSL(e,t)}_compileShaderToSpirV(e,t,i,r){return this._compileRawShaderToSpirV(r+(i?i+`
`:"")+e,t)}_getWGSLShader(e,t,i){return i?i="//"+i.split(`
`).join(`
//`)+`
`:i="",i+e}_createPipelineStageDescriptor(e,t,i,r,s){return this._tintWASM&&i===0&&(e=this._tintWASM.convertSpirV2WGSL(e,r),t=this._tintWASM.convertSpirV2WGSL(t,s)),{vertexStage:{module:this._device.createShaderModule({label:"vertex",code:e}),entryPoint:"main"},fragmentStage:{module:this._device.createShaderModule({label:"fragment",code:t}),entryPoint:"main"}}}_compileRawPipelineStageDescriptor(e,t,i){const r=e.indexOf("#define DISABLE_UNIFORMITY_ANALYSIS")>=0,s=t.indexOf("#define DISABLE_UNIFORMITY_ANALYSIS")>=0,n=i===0?this._compileRawShaderToSpirV(e,"vertex"):e,o=i===0?this._compileRawShaderToSpirV(t,"fragment"):t;return this._createPipelineStageDescriptor(n,o,i,r,s)}_compilePipelineStageDescriptor(e,t,i,r){this.onBeforeShaderCompilationObservable.notifyObservers(this);const s=e.indexOf("#define DISABLE_UNIFORMITY_ANALYSIS")>=0,n=t.indexOf("#define DISABLE_UNIFORMITY_ANALYSIS")>=0,o=`#version 450
`,l=r===0?this._compileShaderToSpirV(e,"vertex",i,o):this._getWGSLShader(e,"vertex",i),u=r===0?this._compileShaderToSpirV(t,"fragment",i,o):this._getWGSLShader(t,"fragment",i),c=this._createPipelineStageDescriptor(l,u,r,s,n);return this.onAfterShaderCompilationObservable.notifyObservers(this),c}createRawShaderProgram(){throw"Not available on WebGPU"}createShaderProgram(){throw"Not available on WebGPU"}inlineShaderCode(e){const t=new Bn(e);return t.debug=!1,t.processCode(),t.code}createPipelineContext(e){return new xO(e,this)}createMaterialContext(){return new zu}createDrawContext(){return new Uu(this._bufferManager)}async _preparePipelineContext(e,t,i,r,s,n,o,l,u,c,h){const d=e,f=d.shaderProcessingContext.shaderLanguage;f===0&&!this._glslangAndTintAreFullyLoaded&&await this.prepareGlslangAndTintAsync(),this.dbgShowShaderCode&&(L.Log(["defines",l]),L.Log(t),L.Log(i),L.Log("***********************************************")),d.sources={fragment:i,vertex:t,rawVertex:s,rawFragment:n},r?d.stages=this._compileRawPipelineStageDescriptor(t,i,f):d.stages=this._compilePipelineStageDescriptor(t,i,l,f),h()}getAttributes(e,t){const i=new Array(t.length),r=e;for(let s=0;s<t.length;s++){const n=t[s],o=r.shaderProcessingContext.availableAttributes[n];o!==void 0&&(i[s]=o)}return i}enableEffect(e){if(e){if(!eM(e))this._currentEffect=e,this._currentMaterialContext=this._defaultMaterialContext,this._currentDrawContext=this._defaultDrawContext,this._counters.numEnableEffects++,this.dbgLogIfNotDrawWrapper&&L.Warn(`enableEffect has been called with an Effect and not a Wrapper! effect.uniqueId=${e.uniqueId}, effect.name=${e.name}, effect.name.vertex=${typeof e.name=="string"?"":e.name.vertex}, effect.name.fragment=${typeof e.name=="string"?"":e.name.fragment}`,10);else if(!e.effect||e.effect===this._currentEffect&&e.materialContext===this._currentMaterialContext&&e.drawContext===this._currentDrawContext&&!this._forceEnableEffect){if(!e.effect&&this.dbgShowEmptyEnableEffectCalls)throw L.Log(["drawWrapper=",e]),"Invalid call to enableEffect: the effect property is empty!";return}else if(this._currentEffect=e.effect,this._currentMaterialContext=e.materialContext,this._currentDrawContext=e.drawContext,this._counters.numEnableDrawWrapper++,!this._currentMaterialContext)throw L.Log(["drawWrapper=",e]),"Invalid call to enableEffect: the materialContext property is empty!";this._stencilStateComposer.stencilMaterial=void 0,this._forceEnableEffect=!1,this._currentEffect.onBind&&this._currentEffect.onBind(this._currentEffect),this._currentEffect._onBindObservable&&this._currentEffect._onBindObservable.notifyObservers(this._currentEffect)}}_releaseEffect(e){this._compiledEffects[e._key]&&(delete this._compiledEffects[e._key],this._deletePipelineContext(e.getPipelineContext()))}releaseEffects(){for(const e in this._compiledEffects){const t=this._compiledEffects[e].getPipelineContext();this._deletePipelineContext(t)}this._compiledEffects={},this.onReleaseEffectsObservable.notifyObservers(this)}_deletePipelineContext(e){const t=e;t&&tM(t)}get needPOTTextures(){return!1}_createHardwareTexture(){return new Vl(this)}_releaseTexture(e){const t=this._internalTexturesCache.indexOf(e);t!==-1&&this._internalTexturesCache.splice(t,1),this._textureHelper.releaseTexture(e)}_getRGBABufferInternalSizedFormat(){return 5}updateTextureComparisonFunction(e,t){e._comparisonFunction=t}_createInternalTexture(e,t,i=!0,r=0){const s={};t!==void 0&&typeof t=="object"?(s.generateMipMaps=t.generateMipMaps,s.createMipMaps=t.createMipMaps,s.type=t.type===void 0?0:t.type,s.samplingMode=t.samplingMode===void 0?3:t.samplingMode,s.format=t.format===void 0?5:t.format,s.samples=t.samples??1,s.creationFlags=t.creationFlags??0,s.useSRGBBuffer=t.useSRGBBuffer??!1,s.label=t.label):(s.generateMipMaps=t,s.type=0,s.samplingMode=3,s.format=5,s.samples=1,s.creationFlags=0,s.useSRGBBuffer=!1),(s.type===1&&!this._caps.textureFloatLinearFiltering||s.type===2&&!this._caps.textureHalfFloatLinearFiltering)&&(s.samplingMode=1),s.type===1&&!this._caps.textureFloat&&(s.type=0,L.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE"));const n=new Dt(this,r),o=e.width??e,l=e.height??e,u=e.depth??0,c=e.layers??0;if(n.baseWidth=o,n.baseHeight=l,n.width=o,n.height=l,n.depth=u||c,n.isReady=!0,n.samples=s.samples,n.generateMipMaps=!!s.generateMipMaps,n.samplingMode=s.samplingMode,n.type=s.type,n.format=s.format,n.is2DArray=c>0,n.is3D=u>0,n._cachedWrapU=0,n._cachedWrapV=0,n._useSRGBBuffer=s.useSRGBBuffer,n.label=s.label,this._internalTexturesCache.push(n),!i){const h=!s.generateMipMaps&&s.createMipMaps;h&&(n.generateMipMaps=!0),this._textureHelper.createGPUTextureForInternalTexture(n,o,l,c||1,s.creationFlags),h&&(n.generateMipMaps=!1)}return n}createTexture(e,t,i,r,s=3,n=null,o=null,l=null,u=null,c=null,h=null,d,f,p,g){return this._createTextureBase(e,t,i,r,s,n,o,(_,S,b,y,T,v,E,R)=>{var w;const O=y;if(_.baseWidth=O.width,_.baseHeight=O.height,_.width=O.width,_.height=O.height,_.format=_.format!==-1?_.format:c??5,_.type=_.type!==-1?_.type:0,_._creationFlags=p??0,R(_.width,_.height,O,S,_,()=>{}),(w=_._hardwareTexture)!=null&&w.underlyingResource)!v&&!E&&this._generateMipmaps(_,this._uploadEncoder);else{const M=this._textureHelper.createGPUTextureForInternalTexture(_,O.width,O.height,void 0,p);et.IsImageBitmap(O)&&(this._textureHelper.updateTexture(O,_,O.width,O.height,_.depth,M.format,0,0,T,!1,0,0),!v&&!E&&this._generateMipmaps(_,this._uploadEncoder))}b&&b.removePendingData(_),_.isReady=!0,_.onLoadedObservable.notifyObservers(_),_.onLoadedObservable.clear()},()=>!1,l,u,c,h,d,f,g)}wrapWebGPUTexture(e){const t=new Vl(this,e),i=new Dt(this,0,!0);return i._hardwareTexture=t,i.isReady=!0,i}wrapWebGLTexture(){throw new Error("wrapWebGLTexture is not supported, use wrapWebGPUTexture instead.")}_getUseSRGBBuffer(e,t){return e&&this._caps.supportSRGBBuffers}_unpackFlipY(e){}updateTextureSamplingMode(e,t,i=!1){i&&(t.generateMipMaps=!0,this._generateMipmaps(t)),t.samplingMode=e}updateTextureWrappingMode(e,t,i=null,r=null){t!==null&&(e._cachedWrapU=t),i!==null&&(e._cachedWrapV=i),(e.is2DArray||e.is3D)&&r!==null&&(e._cachedWrapR=r)}updateTextureDimensions(e,t,i,r=1){if(!e._hardwareTexture||e.width===t&&e.height===i&&e.depth===r)return;const s=e._hardwareTexture.textureAdditionalUsages;e._hardwareTexture.release(),this._textureHelper.createGPUTextureForInternalTexture(e,t,i,r,s)}_setInternalTexture(e,t,i){if(i=i??e,this._currentEffect){const s=this._currentEffect._pipelineContext.shaderProcessingContext.availableTextures[i];if(this._currentMaterialContext.setTexture(e,t),s&&s.autoBindSampler){const n=i+"Sampler";this._currentMaterialContext.setSampler(n,t)}}}createPrefilteredCubeTexture(e,t,i,r,s=null,n=null,o,l=null,u=!0){const c=h=>{if(!h){s&&s(null);return}const d=h.texture;u?h.info.sphericalPolynomial&&(d._sphericalPolynomial=h.info.sphericalPolynomial):d._sphericalPolynomial=new ny,d._source=9,s&&s(d)};return this.createCubeTexture(e,t,null,!1,c,n,o,l,u,i,r)}setTexture(e,t,i,r){this._setTexture(e,i,!1,!1,r,r)}setTextureArray(e,t,i,r){for(let s=0;s<i.length;s++)this._setTexture(-1,i[s],!0,!1,r+s.toString(),r)}_setTexture(e,t,i=!1,r=!1,s="",n){if(n=n??s,this._currentEffect){if(!t)return this._currentMaterialContext.setTexture(s,null),!1;if(t.video)t.update();else if(t.delayLoadState===4)return t.delayLoad(),!1;let o=null;if(r?o=t.depthStencilTexture:t.isReady()?o=t.getInternalTexture():t.isCube?o=this.emptyCubeTexture:t.is3D?o=this.emptyTexture3D:t.is2DArray?o=this.emptyTexture2DArray:o=this.emptyTexture,o&&!o.isMultiview){if(o.isCube&&o._cachedCoordinatesMode!==t.coordinatesMode){o._cachedCoordinatesMode=t.coordinatesMode;const l=t.coordinatesMode!==3&&t.coordinatesMode!==5?1:0;t.wrapU=l,t.wrapV=l}o._cachedWrapU=t.wrapU,o._cachedWrapV=t.wrapV,o.is3D&&(o._cachedWrapR=t.wrapR),this._setAnisotropicLevel(0,o,t.anisotropicFilteringLevel)}this._setInternalTexture(s,o,n)}else this.dbgVerboseLogsForFirstFrames&&(this._count===void 0&&(this._count=0),(!this._count||this._count<this.dbgVerboseLogsNumFrames)&&L.Log(["frame #"+this._count+" - _setTexture called with a null _currentEffect! texture=",t]));return!0}_setAnisotropicLevel(e,t,i){t._cachedAnisotropicFilteringLevel!==i&&(t._cachedAnisotropicFilteringLevel=Math.min(i,this._caps.maxAnisotropy))}_bindTexture(e,t,i){e!==void 0&&this._setInternalTexture(i,t)}generateMipmaps(e){this._generateMipmaps(e)}updateTextureData(e,t,i,r,s,n,o=0,l=0,u=!1){var d;let c=e._hardwareTexture;(d=e._hardwareTexture)!=null&&d.underlyingResource||(c=this._textureHelper.createGPUTextureForInternalTexture(e));const h=new Uint8Array(t.buffer,t.byteOffset,t.byteLength);this._textureHelper.updateTexture(h,e,s,n,e.depth,c.format,o,l,e.invertY,!1,i,r),u&&this._generateMipmaps(e)}_uploadCompressedDataToTextureDirectly(e,t,i,r,s,n=0,o=0){var c;let l=e._hardwareTexture;(c=e._hardwareTexture)!=null&&c.underlyingResource||(e.format=t,l=this._textureHelper.createGPUTextureForInternalTexture(e,i,r));const u=new Uint8Array(s.buffer,s.byteOffset,s.byteLength);this._textureHelper.updateTexture(u,e,i,r,e.depth,l.format,n,o,!1,!1,0,0)}_uploadDataToTextureDirectly(e,t,i=0,r=0,s,n=!1){var f;const o=Math.round(Math.log(e.width)*Math.LOG2E),l=Math.round(Math.log(e.height)*Math.LOG2E),u=n?e.width:Math.pow(2,Math.max(o-r,0)),c=n?e.height:Math.pow(2,Math.max(l-r,0));let h=e._hardwareTexture;(f=e._hardwareTexture)!=null&&f.underlyingResource||(h=this._textureHelper.createGPUTextureForInternalTexture(e,u,c));const d=new Uint8Array(t.buffer,t.byteOffset,t.byteLength);this._textureHelper.updateTexture(d,e,u,c,e.depth,h.format,i,r,e.invertY,!1,0,0)}_uploadArrayBufferViewToTexture(e,t,i=0,r=0){this._uploadDataToTextureDirectly(e,t,i,r)}_uploadImageToTexture(e,t,i=0,r=0){var u;let s=e._hardwareTexture;if((u=e._hardwareTexture)!=null&&u.underlyingResource||(s=this._textureHelper.createGPUTextureForInternalTexture(e)),t instanceof HTMLImageElement)throw"WebGPU engine: HTMLImageElement not supported in _uploadImageToTexture!";const n=t,o=Math.ceil(e.width/(1<<r)),l=Math.ceil(e.height/(1<<r));this._textureHelper.updateTexture(n,e,o,l,e.depth,s.format,i,r,e.invertY,!1,0,0)}readPixels(e,t,i,r,s=!0,n=!0,o=null){const u=this._getCurrentRenderPassWrapper().colorAttachmentGPUTextures[0];if(!u)return Promise.resolve(new Uint8Array(0));const c=u.underlyingResource,h=u.format;return c?(n&&this.flushFramebuffer(),this._textureHelper.readPixels(c,e,t,i,r,h,void 0,void 0,o)):Promise.resolve(new Uint8Array(0))}_measureFps(){this._performanceMonitor.sampleFrame(),this._fps=this._performanceMonitor.averageFPS,this._deltaTime=this._performanceMonitor.instantaneousFrameTime||0}get performanceMonitor(){return this._performanceMonitor}beginFrame(){this._measureFps(),super.beginFrame()}endFrame(){if(this._endCurrentRenderPass(),this._snapshotRendering.endFrame(),this._timestampQuery.endFrame(this._renderEncoder),this._timestampIndex=0,this.flushFramebuffer(),this._textureHelper.destroyDeferredTextures(),this._bufferManager.destroyDeferredBuffers(),this._features._collectUbosUpdatedInFrame){if(this.dbgVerboseLogsForFirstFrames&&(this._count===void 0&&(this._count=0),!this._count||this._count<this.dbgVerboseLogsNumFrames)){const e=[];for(const t in tn._UpdatedUbosInFrame)e.push(t+":"+tn._UpdatedUbosInFrame[t]);L.Log(["frame #"+this._count+" - updated ubos -",e.join(", ")])}tn._UpdatedUbosInFrame={}}this.countersLastFrame.numEnableEffects=this._counters.numEnableEffects,this.countersLastFrame.numEnableDrawWrapper=this._counters.numEnableDrawWrapper,this.countersLastFrame.numBundleCreationNonCompatMode=this._counters.numBundleCreationNonCompatMode,this.countersLastFrame.numBundleReuseNonCompatMode=this._counters.numBundleReuseNonCompatMode,this._counters.numEnableEffects=0,this._counters.numEnableDrawWrapper=0,this._counters.numBundleCreationNonCompatMode=0,this._counters.numBundleReuseNonCompatMode=0,this._cacheRenderPipeline.endFrame(),this._cacheBindGroups.endFrame(),this._pendingDebugCommands.length=0,this.dbgVerboseLogsForFirstFrames&&(this._count===void 0&&(this._count=0),this._count<this.dbgVerboseLogsNumFrames&&L.Log(["%c frame #"+this._count+" - end","background: #ffff00"]),this._count<this.dbgVerboseLogsNumFrames&&(this._count++,this._count!==this.dbgVerboseLogsNumFrames&&L.Log(["%c frame #"+this._count+" - begin","background: #ffff00"]))),super.endFrame()}extractDriverInfo(){return""}flushFramebuffer(){this._endCurrentRenderPass(),this._commandBuffers[0]=this._uploadEncoder.finish(),this._commandBuffers[1]=this._renderEncoder.finish(),this._device.queue.submit(this._commandBuffers),this._uploadEncoder=this._device.createCommandEncoder(this._uploadEncoderDescriptor),this._renderEncoder=this._device.createCommandEncoder(this._renderEncoderDescriptor),this._timestampQuery.startFrame(this._uploadEncoder),this._textureHelper.setCommandEncoder(this._uploadEncoder),this._bundleList.reset()}_currentFrameBufferIsDefaultFrameBuffer(){return this._currentPassIsMainPass()}_startRenderTargetRenderPass(e,t,i,r,s){var y,T,v,E;this._endCurrentRenderPass();const n=e,o=n._depthStencilTexture,l=o==null?void 0:o._hardwareTexture,u=l==null?void 0:l.underlyingResource,c=l==null?void 0:l.getMSAATexture(0),h=u==null?void 0:u.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor),d=c==null?void 0:c.createView(this._rttRenderPassWrapper.depthAttachmentViewDescriptor),f=l?et.HasStencilAspect(l.format):!1,p=[];this.useReverseDepthBuffer&&this.setDepthFunctionToGreaterOrEqual();const g=ew;i&&(g.r=i.r*255,g.g=i.g*255,g.b=i.b*255,g.a=i.a*255);const _=t&&i,S=t&&r,b=t&&s;if(n._attachments&&n.isMulti){(!this._mrtAttachments||this._mrtAttachments.length===0)&&(this._mrtAttachments=n._defaultAttachments);for(let R=0;R<this._mrtAttachments.length;++R){const O=this._mrtAttachments[R],w=n.textures[R],M=w==null?void 0:w._hardwareTexture,G=M==null?void 0:M.underlyingResource;if(M&&G){const H=n.getBaseArrayLayer(R),q=M.getMSAATexture(H),X={...this._rttRenderPassWrapper.colorAttachmentViewDescriptor,dimension:w.is3D?"3d":"2d",format:M.format,baseArrayLayer:H},ee={...this._rttRenderPassWrapper.colorAttachmentViewDescriptor,dimension:w.is3D?"3d":"2d",format:M.format,baseArrayLayer:0},oe=w.type===7||w.type===5,_e=G.createView(X),te=q==null?void 0:q.createView(ee);p.push({view:te||_e,resolveTarget:q?_e:void 0,depthSlice:w.is3D?((y=n.layerIndices)==null?void 0:y[R])??0:void 0,clearValue:O!==0&&_?oe?g:i:void 0,loadOp:O!==0&&_?"clear":"load",storeOp:"store"})}}this._cacheRenderPipeline.setMRT(n.textures,this._mrtAttachments.length),this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments)}else{const R=n.texture;if(R){const O=R._hardwareTexture,w=O.underlyingResource;let M;n.is3D&&(M=this._rttRenderPassWrapper.colorAttachmentViewDescriptor.baseArrayLayer,this._rttRenderPassWrapper.colorAttachmentViewDescriptor.baseArrayLayer=0);const G=O.getMSAATexture(0),H=w.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor),q=G==null?void 0:G.createView(this._rttRenderPassWrapper.colorAttachmentViewDescriptor),X=R.type===7||R.type===5;p.push({view:q||H,resolveTarget:G?H:void 0,depthSlice:M,clearValue:_?X?g:i:void 0,loadOp:_?"clear":"load",storeOp:"store"})}else p.push(null)}if((T=this._debugPushGroup)==null||T.call(this,"render target pass"+(e.label?" ("+e.label+")":""),0),this._rttRenderPassWrapper.renderPassDescriptor={label:(e.label??"RTT")+" - RenderPass",colorAttachments:p,depthStencilAttachment:o&&u?{view:d||h,depthClearValue:S?this.useReverseDepthBuffer?this._clearReverseDepthValue:this._clearDepthValue:void 0,depthLoadOp:S?"clear":"load",depthStoreOp:"store",stencilClearValue:n._depthStencilTextureWithStencil&&b?this._clearStencilValue:void 0,stencilLoadOp:f?n._depthStencilTextureWithStencil&&b?"clear":"load":void 0,stencilStoreOp:f?"store":void 0}:void 0,occlusionQuerySet:(v=this._occlusionQuery)!=null&&v.hasQueries?this._occlusionQuery.querySet:void 0},this._timestampQuery.startPass(this._rttRenderPassWrapper.renderPassDescriptor,this._timestampIndex),this._currentRenderPass=this._renderEncoder.beginRenderPass(this._rttRenderPassWrapper.renderPassDescriptor),this.dbgVerboseLogsForFirstFrames&&(this._count===void 0&&(this._count=0),!this._count||this._count<this.dbgVerboseLogsNumFrames)){const R=n.texture;L.Log(["frame #"+this._count+" - render target begin pass - rtt name="+e.label+", internalTexture.uniqueId="+R.uniqueId+", width="+R.width+", height="+R.height+", setClearStates="+t,"renderPassDescriptor=",this._rttRenderPassWrapper.renderPassDescriptor])}(E=this._debugFlushPendingCommands)==null||E.call(this),this._resetRenderPassStates(),(!l||!et.HasStencilAspect(l.format))&&(this._stencilStateComposer.enabled=!1)}_startMainRenderPass(e,t,i,r){var u,c,h;this._endCurrentRenderPass(),this.useReverseDepthBuffer&&this.setDepthFunctionToGreaterOrEqual();const s=e&&t,n=e&&i,o=e&&r;this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].clearValue=s?t:void 0,this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].loadOp=s?"clear":"load",this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.depthClearValue=n?this.useReverseDepthBuffer?this._clearReverseDepthValue:this._clearDepthValue:void 0,this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.depthLoadOp=n?"clear":"load",this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.stencilClearValue=o?this._clearStencilValue:void 0,this._mainRenderPassWrapper.renderPassDescriptor.depthStencilAttachment.stencilLoadOp=this.isStencilEnable?o?"clear":"load":void 0,this._mainRenderPassWrapper.renderPassDescriptor.occlusionQuerySet=(u=this._occlusionQuery)!=null&&u.hasQueries?this._occlusionQuery.querySet:void 0;const l=this._context.getCurrentTexture();this._mainRenderPassWrapper.colorAttachmentGPUTextures[0].set(l),this._options.antialias?(kx.format=l.format,this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].resolveTarget=l.createView(kx)):(zx.format=l.format,this._mainRenderPassWrapper.renderPassDescriptor.colorAttachments[0].view=l.createView(zx)),this.dbgVerboseLogsForFirstFrames&&(this._count===void 0&&(this._count=0),(!this._count||this._count<this.dbgVerboseLogsNumFrames)&&L.Log(["frame #"+this._count+" - main begin pass - texture width="+this._mainTextureExtends.width," height="+this._mainTextureExtends.height+", setClearStates="+e,"renderPassDescriptor=",this._mainRenderPassWrapper.renderPassDescriptor])),(c=this._debugPushGroup)==null||c.call(this,"main pass",0),this._timestampQuery.startPass(this._mainRenderPassWrapper.renderPassDescriptor,this._timestampIndex),this._currentRenderPass=this._renderEncoder.beginRenderPass(this._mainRenderPassWrapper.renderPassDescriptor),this._setDepthTextureFormat(this._mainRenderPassWrapper),this._setColorFormat(this._mainRenderPassWrapper),(h=this._debugFlushPendingCommands)==null||h.call(this),this._resetRenderPassStates(),this._isStencilEnable||(this._stencilStateComposer.enabled=!1)}bindFramebuffer(e,t=0,i,r,s,n=0,o=0){var c,h;const l=(c=e.texture)==null?void 0:c._hardwareTexture;this._currentRenderTarget?this.unBindFramebuffer(this._currentRenderTarget):this._endCurrentRenderPass(),this._currentRenderTarget=e;const u=this._currentRenderTarget._depthStencilTexture;this._rttRenderPassWrapper.colorAttachmentGPUTextures[0]=l,this._rttRenderPassWrapper.depthTextureFormat=u?et.GetWebGPUTextureFormat(-1,u.format):void 0,this._setDepthTextureFormat(this._rttRenderPassWrapper),this._setColorFormat(this._rttRenderPassWrapper),this._rttRenderPassWrapper.colorAttachmentViewDescriptor={format:this._colorFormat,dimension:e.is3D?"3d":"2d",mipLevelCount:1,baseArrayLayer:e.isCube?o*6+t:o,baseMipLevel:n,arrayLayerCount:1,aspect:"all"},this._rttRenderPassWrapper.depthAttachmentViewDescriptor={format:this._depthTextureFormat,dimension:u&&u.is3D?"3d":"2d",mipLevelCount:1,baseArrayLayer:u?u.isCube?o*6+t:o:0,baseMipLevel:0,arrayLayerCount:1,aspect:"all"},this.dbgVerboseLogsForFirstFrames&&(this._count===void 0&&(this._count=0),(!this._count||this._count<this.dbgVerboseLogsNumFrames)&&L.Log(["frame #"+this._count+" - bindFramebuffer - rtt name="+e.label+", internalTexture.uniqueId="+((h=e.texture)==null?void 0:h.uniqueId)+", face="+t+", lodLevel="+n+", layer="+o,"colorAttachmentViewDescriptor=",this._rttRenderPassWrapper.colorAttachmentViewDescriptor,"depthAttachmentViewDescriptor=",this._rttRenderPassWrapper.depthAttachmentViewDescriptor])),this._cachedViewport&&!s?this.setViewport(this._cachedViewport,i,r):(i||(i=e.width,n&&(i=i/Math.pow(2,n))),r||(r=e.height,n&&(r=r/Math.pow(2,n))),this._viewport(0,0,i,r)),this.wipeCaches()}unBindFramebuffer(e,t=!1,i){var s;const r=this._currentRenderTarget;this._currentRenderTarget=null,i&&i(),this._currentRenderTarget=r,this._endCurrentRenderPass(),t||(e.isMulti?this.generateMipMapsMultiFramebuffer(e):this.generateMipMapsFramebuffer(e)),this._currentRenderTarget=null,this.dbgVerboseLogsForFirstFrames&&(this._count===void 0&&(this._count=0),(!this._count||this._count<this.dbgVerboseLogsNumFrames)&&L.Log("frame #"+this._count+" - unBindFramebuffer - rtt name="+e.label+", internalTexture.uniqueId=",(s=e.texture)==null?void 0:s.uniqueId)),this._mrtAttachments=[],this._cacheRenderPipeline.setMRT([]),this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments)}generateMipMapsFramebuffer(e){var t;!e.isMulti&&((t=e.texture)!=null&&t.generateMipMaps)&&!e.isCube&&this._generateMipmaps(e.texture)}resolveFramebuffer(e){throw new Error("resolveFramebuffer is not yet implemented in WebGPU!")}restoreDefaultFramebuffer(){this._currentRenderTarget?this.unBindFramebuffer(this._currentRenderTarget):this._currentRenderPass||this._startMainRenderPass(!1),this._cachedViewport&&this.setViewport(this._cachedViewport),this.wipeCaches()}_setColorFormat(e){var i;const t=((i=e.colorAttachmentGPUTextures[0])==null?void 0:i.format)??null;this._cacheRenderPipeline.setColorFormat(t),this._colorFormat!==t&&(this._colorFormat=t)}_setDepthTextureFormat(e){this._cacheRenderPipeline.setDepthStencilFormat(e.depthTextureFormat),this._depthTextureFormat!==e.depthTextureFormat&&(this._depthTextureFormat=e.depthTextureFormat)}setDitheringState(){}setRasterizerState(){}_executeWhenRenderingStateIsCompiled(e,t){t()}bindSamplers(){}_getUnpackAlignement(){return 1}_bindTextureDirectly(){return!1}setStateCullFaceType(e,t=!1){const i=this.cullBackFaces??e??!0?1:2;(this._depthCullingState.cullFace!==i||t)&&(this._depthCullingState.cullFace=i)}setState(e,t=0,i,r=!1,s,n,o=0){(this._depthCullingState.cull!==e||i)&&(this._depthCullingState.cull=e),this.setStateCullFaceType(s,i),this.setZOffset(t),this.setZOffsetUnits(o);const l=r?this._currentRenderTarget?1:2:this._currentRenderTarget?2:1;(this._depthCullingState.frontFace!==l||i)&&(this._depthCullingState.frontFace=l),this._stencilStateComposer.stencilMaterial=n}_applyRenderPassChanges(e){const t=this._stencilStateComposer.enabled?this._mustUpdateStencilRef():!1,i=this._alphaState.alphaBlend?this._mustUpdateBlendColor():!1;this._mustUpdateViewport()&&this._applyViewport(e),this._mustUpdateScissor()&&this._applyScissor(e),t&&this._applyStencilRef(e),i&&this._applyBlendColor(e)}_draw(e,t,i,r,s){var _;const n=this._getCurrentRenderPass(),o=this._bundleList;this.applyStates();const l=this._currentEffect._pipelineContext;if(this.bindUniformBufferBase(this._currentRenderTarget?this._ubInvertY:this._ubDontInvertY,0,Nt.InternalsUBOName),l.uniformBuffer&&(l.uniformBuffer.update(),this.bindUniformBufferBase(l.uniformBuffer.getBuffer(),0,Nt.LeftOvertUBOName)),this._snapshotRendering.play){this._reportDrawCall();return}!this.compatibilityMode&&(this._currentDrawContext.isDirty(this._currentMaterialContext.updateId)||this._currentMaterialContext.isDirty||this._currentMaterialContext.forceBindGroupCreation)&&(this._currentDrawContext.fastBundle=void 0);const u=!this.compatibilityMode&&this._currentDrawContext.fastBundle;let c=n;if(u||this._snapshotRendering.record){if(this._applyRenderPassChanges(o),!this._snapshotRendering.record){this._counters.numBundleReuseNonCompatMode++,this._currentDrawContext.indirectDrawBuffer&&this._currentDrawContext.setIndirectData(r,s||1,i),o.addBundle(this._currentDrawContext.fastBundle),this._reportDrawCall();return}c=o.getBundleEncoder(this._cacheRenderPipeline.colorFormats,this._depthTextureFormat,this.currentSampleCount),o.numDrawCalls++}let h=0;if(this._currentMaterialContext.hasFloatOrDepthTextures){let S=1;for(let b=0;b<l.shaderProcessingContext.textureNames.length;++b){const y=l.shaderProcessingContext.textureNames[b],T=(_=this._currentMaterialContext.textures[y])==null?void 0:_.texture,v=T&&T.format>=13&&T.format<=18;((T==null?void 0:T.type)===1&&!this._caps.textureFloatLinearFiltering||v)&&(h|=S),S=S<<1}}this._currentMaterialContext.textureState=h;const d=this._cacheRenderPipeline.getRenderPipeline(t,this._currentEffect,this.currentSampleCount,h),f=this._cacheBindGroups.getBindGroups(l,this._currentDrawContext,this._currentMaterialContext);this._snapshotRendering.record||(this._applyRenderPassChanges(this.compatibilityMode?null:o),this.compatibilityMode||(this._counters.numBundleCreationNonCompatMode++,c=this._device.createRenderBundleEncoder({colorFormats:this._cacheRenderPipeline.colorFormats,depthStencilFormat:this._depthTextureFormat,sampleCount:et.GetSample(this.currentSampleCount)}))),c.setPipeline(d),this._currentIndexBuffer&&c.setIndexBuffer(this._currentIndexBuffer.underlyingResource,this._currentIndexBuffer.is32Bits?"uint32":"uint16",0);const p=this._cacheRenderPipeline.vertexBuffers;for(let S=0;S<p.length;S++){const b=p[S],y=b.effectiveBuffer;y&&c.setVertexBuffer(S,y.underlyingResource,b._validOffsetRange?0:b.byteOffset)}for(let S=0;S<f.length;S++)c.setBindGroup(S,f[S]);const g=!this.compatibilityMode&&!this._snapshotRendering.record;g&&this._currentDrawContext.indirectDrawBuffer?(this._currentDrawContext.setIndirectData(r,s||1,i),e===0?c.drawIndexedIndirect(this._currentDrawContext.indirectDrawBuffer,0):c.drawIndirect(this._currentDrawContext.indirectDrawBuffer,0)):e===0?c.drawIndexed(r,s||1,i,0,0):c.draw(r,s||1,i,0),g&&(this._currentDrawContext.fastBundle=c.finish(),o.addBundle(this._currentDrawContext.fastBundle)),this._reportDrawCall()}drawElementsType(e,t,i,r=1){this._draw(0,e,t,i,r)}drawArraysType(e,t,i,r=1){this._currentIndexBuffer=null,this._draw(1,e,t,i,r)}dispose(){var e,t;this._isDisposed=!0,this.hideLoadingUI(),this._timestampQuery.dispose(),(e=this._mainTexture)==null||e.destroy(),(t=this._depthTexture)==null||t.destroy(),this._textureHelper.destroyDeferredTextures(),this._bufferManager.destroyDeferredBuffers(),this._device.destroy(),iM(this,this._renderingCanvas),super.dispose()}getRenderWidth(e=!1){var t;return!e&&this._currentRenderTarget?this._currentRenderTarget.width:((t=this._renderingCanvas)==null?void 0:t.width)??0}getRenderHeight(e=!1){var t;return!e&&this._currentRenderTarget?this._currentRenderTarget.height:((t=this._renderingCanvas)==null?void 0:t.height)??0}getError(){return 0}createExternalTexture(e){return new KO(e)}setExternalTexture(e,t){if(!t){this._currentMaterialContext.setTexture(e,null);return}this._setInternalTexture(e,t)}setTextureSampler(e,t){var i;(i=this._currentMaterialContext)==null||i.setSampler(e,t)}createStorageBuffer(e,t,i){return this._createBuffer(e,t|32,i)}updateStorageBuffer(e,t,i,r){const s=e;i===void 0&&(i=0);let n;r===void 0?(t instanceof Array?n=new Float32Array(t):t instanceof ArrayBuffer?n=new Uint8Array(t):n=t,r=n.byteLength):t instanceof Array?n=new Float32Array(t):t instanceof ArrayBuffer?n=new Uint8Array(t):n=t,this._bufferManager.setSubData(s,i,n,0,r)}_readFromGPUBuffer(e,t,i,r){return new Promise((s,n)=>{const o=()=>{e.mapAsync(1,0,t).then(()=>{const l=e.getMappedRange(0,t);let u=i;if(u===void 0)u=new Uint8Array(t),u.set(new Uint8Array(l));else{const c=u.constructor;u=new c(u.buffer),u.set(new c(l))}e.unmap(),this._bufferManager.releaseBuffer(e),s(u)},l=>{this.isDisposed?s(new Uint8Array):n(l)})};r?(this.flushFramebuffer(),o()):this.onEndFrameObservable.addOnce(()=>{o()})})}readFromStorageBuffer(e,t,i,r,s){i=i||e.capacity;const n=this._bufferManager.createRawBuffer(i,tt.MapRead|tt.CopyDst,void 0,"TempReadFromStorageBuffer");return this._renderEncoder.copyBufferToBuffer(e.underlyingResource,t??0,n,0,i),this._readFromGPUBuffer(n,i,r,s)}readFromMultipleStorageBuffers(e,t,i,r,s){i=i||e[0].capacity;const n=this._bufferManager.createRawBuffer(i*e.length,tt.MapRead|tt.CopyDst,void 0,"TempReadFromMultipleStorageBuffers");for(let o=0;o<e.length;o++)this._renderEncoder.copyBufferToBuffer(e[o].underlyingResource,t??0,n,o*i,i);return this._readFromGPUBuffer(n,i*e.length,r,s)}setStorageBuffer(e,t){var i;(i=this._currentDrawContext)==null||i.setBuffer(e,(t==null?void 0:t.getBuffer())??null)}}ct._GlslangDefaultOptions={jsPath:`${ae._DefaultCdnUrl}/glslang/glslang.js`,wasmPath:`${ae._DefaultCdnUrl}/glslang/glslang.wasm`};ct._InstanceId=0;class Gu{getBindGroups(e,t,i){if(!i)throw new Error("WebGPUComputeContext.getBindGroups: bindingsMapping is required until browsers support reflection for wgsl shaders!");if(this._bindGroups.length===0){const r=this._bindGroupEntries.length>0;for(const s in e){const n=e[s],o=i[s],l=o.group,u=o.binding,c=n.type,h=n.object;let d=n.indexInGroupEntries,f=this._bindGroupEntries[l];switch(f||(f=this._bindGroupEntries[l]=[]),c){case 5:{const p=h;d!==void 0&&r?f[d].resource=this._cacheSampler.getSampler(p):(n.indexInGroupEntries=f.length,f.push({binding:u,resource:this._cacheSampler.getSampler(p)}));break}case 0:case 4:{const p=h,g=p._texture._hardwareTexture;d!==void 0&&r?(c===0&&(f[d++].resource=this._cacheSampler.getSampler(p._texture)),f[d].resource=g.view):(n.indexInGroupEntries=f.length,c===0&&f.push({binding:u-1,resource:this._cacheSampler.getSampler(p._texture)}),f.push({binding:u,resource:g.view}));break}case 1:{const p=h,g=p._texture._hardwareTexture;g.textureAdditionalUsages&8||L.Error(`computeDispatch: The texture (name=${p.name}, uniqueId=${p.uniqueId}) is not a storage texture!`,50),d!==void 0&&r?f[d].resource=g.viewForWriting:(n.indexInGroupEntries=f.length,f.push({binding:u,resource:g.viewForWriting}));break}case 6:{const g=h.underlyingResource;d!==void 0&&r?f[d].resource=this._device.importExternalTexture({source:g}):(n.indexInGroupEntries=f.length,f.push({binding:u,resource:this._device.importExternalTexture({source:g})}));break}case 2:case 3:case 7:{const p=c===7?h:h.getBuffer(),g=p.underlyingResource;d!==void 0&&r?(f[d].resource.buffer=g,f[d].resource.size=p.capacity):(n.indexInGroupEntries=f.length,f.push({binding:u,resource:{buffer:g,offset:0,size:p.capacity}}));break}}}for(let s=0;s<this._bindGroupEntries.length;++s){const n=this._bindGroupEntries[s];if(!n){this._bindGroups[s]=void 0;continue}this._bindGroups[s]=this._device.createBindGroup({layout:t.getBindGroupLayout(s),entries:n})}this._bindGroups.length=this._bindGroupEntries.length}return this._bindGroups}constructor(e,t){this._device=e,this._cacheSampler=t,this.uniqueId=Gu._Counter++,this._bindGroupEntries=[],this.clear()}clear(){this._bindGroups=[]}}Gu._Counter=0;class tw{get isAsync(){return!1}get isReady(){return this.isAsync,!1}constructor(e){this._name="unnamed",this.engine=e}_getComputeShaderCode(){var e;return(e=this.sources)==null?void 0:e.compute}dispose(){}}const Ux={};ct.prototype.createComputeContext=function(){return new Gu(this._device,this._cacheSampler)};ct.prototype.createComputeEffect=function(a,e){const i=(typeof a=="string"?a:a.computeToken||a.computeSource||a.computeElement||a.compute)+"@"+e.defines;if(this._compiledComputeEffects[i]){const s=this._compiledComputeEffects[i];return e.onCompiled&&s.isReady()&&e.onCompiled(s),s}const r=new Na(a,e,this,i);return this._compiledComputeEffects[i]=r,r};ct.prototype.createComputePipelineContext=function(){return new tw(this)};ct.prototype.areAllComputeEffectsReady=function(){for(const a in this._compiledComputeEffects)if(!this._compiledComputeEffects[a].isReady())return!1;return!0};ct.prototype.computeDispatch=function(a,e,t,i,r=1,s=1,n,o){this._computeDispatch(a,e,t,i,r,s,void 0,void 0,n,o)};ct.prototype.computeDispatchIndirect=function(a,e,t,i,r=0,s,n){this._computeDispatch(a,e,t,void 0,void 0,void 0,i,r,s,n)};ct.prototype._computeDispatch=function(a,e,t,i,r,s,n,o,l,u){this._endCurrentRenderPass();const c=a._pipelineContext,h=e;c.computePipeline||(c.computePipeline=this._device.createComputePipeline({layout:"auto",compute:c.stage})),u&&this._timestampQuery.startPass(Ux,this._timestampIndex);const d=this._renderEncoder.beginComputePass(Ux);d.setPipeline(c.computePipeline);const f=h.getBindGroups(t,c.computePipeline,l);for(let p=0;p<f.length;++p){const g=f[p];g&&d.setBindGroup(p,g)}n!==void 0?d.dispatchWorkgroupsIndirect(n.underlyingResource,o):i+r+s>0&&d.dispatchWorkgroups(i,r,s),d.end(),u&&(this._timestampQuery.endPass(this._timestampIndex,u),this._timestampIndex+=2)};ct.prototype.releaseComputeEffects=function(){for(const a in this._compiledComputeEffects){const e=this._compiledComputeEffects[a].getPipelineContext();this._deleteComputePipelineContext(e)}this._compiledComputeEffects={}};ct.prototype._prepareComputePipelineContext=function(a,e,t,i,r){const s=a;this.dbgShowShaderCode&&(L.Log(i),L.Log(e)),s.sources={compute:e,rawCompute:t},s.stage=this._createComputePipelineStageDescriptor(e,i,r)};ct.prototype._releaseComputeEffect=function(a){this._compiledComputeEffects[a._key]&&(delete this._compiledComputeEffects[a._key],this._deleteComputePipelineContext(a.getPipelineContext()))};ct.prototype._rebuildComputeEffects=function(){for(const a in this._compiledComputeEffects){const e=this._compiledComputeEffects[a];e._pipelineContext=null,e._wasPreviouslyReady=!1,e._prepareEffect()}};ct.prototype._executeWhenComputeStateIsCompiled=function(a,e){a.stage.module.getCompilationInfo().then(t=>{const i={numErrors:0,messages:[]};for(const r of t.messages)r.type==="error"&&i.numErrors++,i.messages.push({type:r.type,text:r.message,line:r.lineNum,column:r.linePos,length:r.length,offset:r.offset});e(i)})};ct.prototype._deleteComputePipelineContext=function(a){a&&a.dispose()};ct.prototype._createComputePipelineStageDescriptor=function(a,e,t){return e?e="//"+e.split(`
`).join(`
//`)+`
`:e="",{module:this._device.createShaderModule({code:e+a}),entryPoint:t}};ct.prototype._debugPushGroup=function(a,e){this._options.enableGPUDebugMarkers&&(e===0||e===1?(e===1&&(this._currentRenderTarget?this.unBindFramebuffer(this._currentRenderTarget):this._endCurrentRenderPass()),this._renderEncoder.pushDebugGroup(a)):this._currentRenderPass?(this._currentRenderPass.pushDebugGroup(a),this._debugStackRenderPass.push(a)):this._pendingDebugCommands.push(["push",a,e]))};ct.prototype._debugPopGroup=function(a){this._options.enableGPUDebugMarkers&&(a===0||a===1?(a===1&&(this._currentRenderTarget?this.unBindFramebuffer(this._currentRenderTarget):this._endCurrentRenderPass()),this._renderEncoder.popDebugGroup()):this._currentRenderPass?(this._currentRenderPass.popDebugGroup(),this._debugStackRenderPass.pop()):this._pendingDebugCommands.push(["pop",null,a]))};ct.prototype._debugInsertMarker=function(a,e){this._options.enableGPUDebugMarkers&&(e===0||e===1?(e===1&&(this._currentRenderTarget?this.unBindFramebuffer(this._currentRenderTarget):this._endCurrentRenderPass()),this._renderEncoder.insertDebugMarker(a)):this._currentRenderPass?this._currentRenderPass.insertDebugMarker(a):this._pendingDebugCommands.push(["insert",a,e]))};ct.prototype._debugFlushPendingCommands=function(){if(this._debugStackRenderPass.length!==0){const a=this._debugStackRenderPass.slice();this._debugStackRenderPass.length=0;for(let e=0;e<a.length;++e)this._debugPushGroup(a[e],2)}for(let a=0;a<this._pendingDebugCommands.length;++a){const[e,t,i]=this._pendingDebugCommands[a];switch(e){case"push":this._debugPushGroup(t,i);break;case"pop":this._debugPopGroup(i);break;case"insert":this._debugInsertMarker(t,i);break}}this._pendingDebugCommands.length=0};ct.prototype.createDynamicTexture=function(a,e,t,i){const r=new Dt(this,4);return r.baseWidth=a,r.baseHeight=e,t&&(a=this.needPOTTextures?ds(a,this._caps.maxTextureSize):a,e=this.needPOTTextures?ds(e,this._caps.maxTextureSize):e),r.width=a,r.height=e,r.isReady=!1,r.generateMipMaps=t,r.samplingMode=i,this.updateTextureSamplingMode(i,r),this._internalTexturesCache.push(r),a&&e&&this._textureHelper.createGPUTextureForInternalTexture(r,a,e),r};ct.prototype.updateDynamicTexture=function(a,e,t,i=!1,r,s,n){var c;if(!a)return;const o=e.width,l=e.height;let u=a._hardwareTexture;(c=a._hardwareTexture)!=null&&c.underlyingResource||(u=this._textureHelper.createGPUTextureForInternalTexture(a,o,l)),this._textureHelper.updateTexture(e,a,o,l,a.depth,u.format,0,0,t,i,0,0,n),a.generateMipMaps&&this._generateMipmaps(a),a._dynamicTextureSource=e,a._premulAlpha=i,a.invertY=t||!1,a.isReady=!0};ct.prototype.unBindMultiColorAttachmentFramebuffer=function(a,e=!1,t){t&&t(),this._endCurrentRenderPass(),e||this.generateMipMapsMultiFramebuffer(a),this._currentRenderTarget=null,this._mrtAttachments=[],this._cacheRenderPipeline.setMRT([]),this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments)};ct.prototype.createMultipleRenderTarget=function(a,e,t){let i=!1,r=!0,s=!1,n=!1,o=15,l=1,u=1;const c=0,h=3,d=!1,f=5,p=3553;let g=[],_=[],S=[],b=[],y=[],T=[],v=[],E=[],R=[],O=[],w=!1;const M=this._createHardwareRenderTargetWrapper(!0,!1,a);e!==void 0&&(i=e.generateMipMaps??!1,r=e.generateDepthBuffer??!0,s=e.generateStencilBuffer??!1,n=e.generateDepthTexture??!1,l=e.textureCount??1,o=e.depthTextureFormat??15,g=e.types||g,_=e.samplingModes||_,S=e.useSRGBBuffers||S,b=e.formats||b,y=e.targetTypes||y,T=e.faceIndex||T,v=e.layerIndex||v,E=e.layerCounts||E,R=e.labels||R,O=e.creationFlags||O,u=e.samples??u,w=e.dontCreateTextures??!1);const G=a.width??a,H=a.height??a,q=[],X=[],ee=[];M.label=(e==null?void 0:e.label)??"MultiRenderTargetWrapper",M._generateDepthBuffer=r,M._generateStencilBuffer=s,M._attachments=X,M._defaultAttachments=ee;let oe=null;(r||s||n)&&!w&&(n||(r&&s?o=13:r?o=14:o=19),oe=M.createDepthStencilTexture(0,!1,s,1,o,M.label+"-DepthStencil"));const _e=e!==void 0&&typeof e=="object"&&e.createMipMaps&&!i;for(let te=0;te<l;te++){let ie=_[te]||h,Z=g[te]||c;const D=b[te]||f,W=(S[te]||d)&&this._caps.supportSRGBBuffers,K=y[te]||p,ue=E[te]??1,ye=O[te];if((Z===1&&!this._caps.textureFloatLinearFiltering||Z===2&&!this._caps.textureHalfFloatLinearFiltering)&&(ie=1),Z===1&&!this._caps.textureFloat&&(Z=0,L.Warn("Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type")),X.push(te+1),ee.push(t?te+1:te===0?1:0),K===-1||w)continue;const se=new Dt(this,6);switch(q[te]=se,K){case 34067:se.isCube=!0;break;case 32879:se.is3D=!0,se.baseDepth=se.depth=ue;break;case 35866:se.is2DArray=!0,se.baseDepth=se.depth=ue;break}se.baseWidth=G,se.baseHeight=H,se.width=G,se.height=H,se.isReady=!0,se.samples=1,se.generateMipMaps=i,se.samplingMode=ie,se.type=Z,se._cachedWrapU=0,se._cachedWrapV=0,se._useSRGBBuffer=W,se.format=D,se.label=R[te]??M.label+"-Texture"+te,this._internalTexturesCache.push(se),_e&&(se.generateMipMaps=!0),this._textureHelper.createGPUTextureForInternalTexture(se,void 0,void 0,void 0,ye,!0),_e&&(se.generateMipMaps=!1)}return oe&&(oe.incrementReferences(),q[l]=oe,this._internalTexturesCache.push(oe)),M.setTextures(q),M.setLayerAndFaceIndices(v,T),w?M._samples=u:this.updateMultipleRenderTargetTextureSampleCount(M,u),M};ct.prototype.updateMultipleRenderTargetTextureSampleCount=function(a,e){if(!a||!a.textures||a.textures.length===0||a.textures[0].samples===e)return e;const t=a.textures.length;if(t===0)return 1;e=Math.min(e,this.getCaps().maxMSAASamples);for(let r=0;r<t;++r){const n=a.textures[r]._hardwareTexture;n==null||n.releaseMSAATexture(a.getBaseArrayLayer(r))}const i=a._depthStencilTexture===a.textures[t-1];for(let r=0;r<t;++r){const s=a.textures[r];this._textureHelper.createMSAATexture(s,e,!1,a.getBaseArrayLayer(r)),s.samples=e}return a._depthStencilTexture&&!i&&(this._textureHelper.createMSAATexture(a._depthStencilTexture,e),a._depthStencilTexture.samples=e),a._samples=e,e};ct.prototype.generateMipMapsMultiFramebuffer=function(a){const e=a;if(!e.isMulti)return;const i=e._attachments.length;for(let r=0;r<i;r++){const s=e.textures[r];s.generateMipMaps&&!s.isCube&&!s.is3D&&this._generateMipmaps(s)}};ct.prototype.resolveMultiFramebuffer=function(a){throw new Error("resolveMultiFramebuffer is not yet implemented in WebGPU!")};ct.prototype.bindAttachments=function(a){a.length===0||!this._currentRenderTarget||(this._mrtAttachments=a,this._currentRenderPass&&this._cacheRenderPipeline.setMRTAttachments(a))};ct.prototype.buildTextureLayout=function(a){const e=[];for(let t=0;t<a.length;t++)a[t]?e.push(t+1):e.push(0);return e};ct.prototype.restoreSingleAttachment=function(){};ct.prototype.restoreSingleAttachmentForRenderTarget=function(){};function iw(a){return!!(a&&a.underlyingResource!==void 0)}ct.prototype.updateVideoTexture=function(a,e,t){var r;if(!a||a._isDisabled)return;this._videoTextureSupported===void 0&&(this._videoTextureSupported=!0);let i=a._hardwareTexture;if((r=a._hardwareTexture)!=null&&r.underlyingResource||(i=this._textureHelper.createGPUTextureForInternalTexture(a)),iw(e)){if(e.isReady()){try{this._textureHelper.copyVideoToTexture(e,a,i.format,!t),a.generateMipMaps&&this._generateMipmaps(a)}catch{}a.isReady=!0}}else e&&this.createImageBitmap(e).then(s=>{this._textureHelper.updateTexture(s,a,a.width,a.height,a.depth,i.format,0,0,!t,!1,0,0),a.generateMipMaps&&this._generateMipmaps(a),a.isReady=!0}).catch(()=>{a.isReady=!0})};class ya{}ya.COPY=1;ya.CUT=2;ya.PASTE=3;class OW{constructor(e,t){this.type=e,this.event=t}static GetTypeFromCharacter(e){switch(e){case 67:return ya.COPY;case 86:return ya.PASTE;case 88:return ya.CUT;default:return-1}}}var Gx;(function(a){a.PlayAnimation="FlowGraphPlayAnimationBlock",a.StopAnimation="FlowGraphStopAnimationBlock",a.PauseAnimation="FlowGraphPauseAnimationBlock",a.ValueInterpolation="FlowGraphInterpolationBlock",a.SceneReadyEvent="FlowGraphSceneReadyEventBlock",a.SceneTickEvent="FlowGraphSceneTickEventBlock",a.SendCustomEvent="FlowGraphSendCustomEventBlock",a.ReceiveCustomEvent="FlowGraphReceiveCustomEventBlock",a.MeshPickEvent="FlowGraphMeshPickEventBlock",a.PointerEvent="FlowGraphPointerEventBlock",a.PointerDownEvent="FlowGraphPointerDownEventBlock",a.PointerUpEvent="FlowGraphPointerUpEventBlock",a.PointerMoveEvent="FlowGraphPointerMoveEventBlock",a.PointerOverEvent="FlowGraphPointerOverEventBlock",a.PointerOutEvent="FlowGraphPointerOutEventBlock",a.E="FlowGraphEBlock",a.PI="FlowGraphPIBlock",a.Inf="FlowGraphInfBlock",a.NaN="FlowGraphNaNBlock",a.Random="FlowGraphRandomBlock",a.Add="FlowGraphAddBlock",a.Subtract="FlowGraphSubtractBlock",a.Multiply="FlowGraphMultiplyBlock",a.Divide="FlowGraphDivideBlock",a.Abs="FlowGraphAbsBlock",a.Sign="FlowGraphSignBlock",a.Trunc="FlowGraphTruncBlock",a.Floor="FlowGraphFloorBlock",a.Ceil="FlowGraphCeilBlock",a.Round="FlowGraphRoundBlock",a.Fraction="FlowGraphFractBlock",a.Negation="FlowGraphNegationBlock",a.Modulo="FlowGraphModuloBlock",a.Min="FlowGraphMinBlock",a.Max="FlowGraphMaxBlock",a.Clamp="FlowGraphClampBlock",a.Saturate="FlowGraphSaturateBlock",a.MathInterpolation="FlowGraphMathInterpolationBlock",a.Equality="FlowGraphEqualityBlock",a.LessThan="FlowGraphLessThanBlock",a.LessThanOrEqual="FlowGraphLessThanOrEqualBlock",a.GreaterThan="FlowGraphGreaterThanBlock",a.GreaterThanOrEqual="FlowGraphGreaterThanOrEqualBlock",a.IsNaN="FlowGraphIsNaNBlock",a.IsInfinity="FlowGraphIsInfBlock",a.DegToRad="FlowGraphDegToRadBlock",a.RadToDeg="FlowGraphRadToDegBlock",a.Sin="FlowGraphSinBlock",a.Cos="FlowGraphCosBlock",a.Tan="FlowGraphTanBlock",a.Asin="FlowGraphASinBlock",a.Acos="FlowGraphACosBlock",a.Atan="FlowGraphATanBlock",a.Atan2="FlowGraphATan2Block",a.Sinh="FlowGraphSinhBlock",a.Cosh="FlowGraphCoshBlock",a.Tanh="FlowGraphTanhBlock",a.Asinh="FlowGraphASinhBlock",a.Acosh="FlowGraphACoshBlock",a.Atanh="FlowGraphATanhBlock",a.Exponential="FlowGraphExponentialBlock",a.Log="FlowGraphLogBlock",a.Log2="FlowGraphLog2Block",a.Log10="FlowGraphLog10Block",a.SquareRoot="FlowGraphSquareRootBlock",a.CubeRoot="FlowGraphCubeRootBlock",a.Power="FlowGraphPowerBlock",a.Length="FlowGraphLengthBlock",a.Normalize="FlowGraphNormalizeBlock",a.Dot="FlowGraphDotBlock",a.Cross="FlowGraphCrossBlock",a.Rotate2D="FlowGraphRotate2DBlock",a.Rotate3D="FlowGraphRotate3DBlock",a.Transpose="FlowGraphTransposeBlock",a.Determinant="FlowGraphDeterminantBlock",a.InvertMatrix="FlowGraphInvertMatrixBlock",a.MatrixMultiplication="FlowGraphMatrixMultiplicationBlock",a.BitwiseAnd="FlowGraphBitwiseAndBlock",a.BitwiseOr="FlowGraphBitwiseOrBlock",a.BitwiseXor="FlowGraphBitwiseXorBlock",a.BitwiseNot="FlowGraphBitwiseNotBlock",a.BitwiseLeftShift="FlowGraphBitwiseLeftShiftBlock",a.BitwiseRightShift="FlowGraphBitwiseRightShiftBlock",a.LeadingZeros="FlowGraphLeadingZerosBlock",a.TrailingZeros="FlowGraphTrailingZerosBlock",a.OneBitsCounter="FlowGraphOneBitsCounterBlock",a.Branch="FlowGraphBranchBlock",a.SetDelay="FlowGraphSetDelayBlock",a.CancelDelay="FlowGraphCancelDelayBlock",a.CallCounter="FlowGraphCallCounterBlock",a.Debounce="FlowGraphDebounceBlock",a.Throttle="FlowGraphThrottleBlock",a.DoN="FlowGraphDoNBlock",a.FlipFlop="FlowGraphFlipFlopBlock",a.ForLoop="FlowGraphForLoopBlock",a.MultiGate="FlowGraphMultiGateBlock",a.Sequence="FlowGraphSequenceBlock",a.Switch="FlowGraphSwitchBlock",a.WaitAll="FlowGraphWaitAllBlock",a.WhileLoop="FlowGraphWhileLoopBlock",a.ConsoleLog="FlowGraphConsoleLogBlock",a.Conditional="FlowGraphConditionalBlock",a.Constant="FlowGraphConstantBlock",a.TransformCoordinatesSystem="FlowGraphTransformCoordinatesSystemBlock",a.GetAsset="FlowGraphGetAssetBlock",a.GetProperty="FlowGraphGetPropertyBlock",a.SetProperty="FlowGraphSetPropertyBlock",a.GetVariable="FlowGraphGetVariableBlock",a.SetVariable="FlowGraphSetVariableBlock",a.JsonPointerParser="FlowGraphJsonPointerParserBlock",a.CombineVector2="FlowGraphCombineVector2Block",a.CombineVector3="FlowGraphCombineVector3Block",a.CombineVector4="FlowGraphCombineVector4Block",a.CombineMatrix="FlowGraphCombineMatrixBlock",a.CombineMatrix2D="FlowGraphCombineMatrix2DBlock",a.CombineMatrix3D="FlowGraphCombineMatrix3DBlock",a.ExtractVector2="FlowGraphExtractVector2Block",a.ExtractVector3="FlowGraphExtractVector3Block",a.ExtractVector4="FlowGraphExtractVector4Block",a.ExtractMatrix="FlowGraphExtractMatrixBlock",a.ExtractMatrix2D="FlowGraphExtractMatrix2DBlock",a.ExtractMatrix3D="FlowGraphExtractMatrix3DBlock",a.TransformVector="FlowGraphTransformVectorBlock",a.TransformCoordinates="FlowGraphTransformCoordinatesBlock",a.MatrixDecompose="FlowGraphMatrixDecompose",a.MatrixCompose="FlowGraphMatrixCompose",a.BooleanToFloat="FlowGraphBooleanToFloat",a.BooleanToInt="FlowGraphBooleanToInt",a.FloatToBoolean="FlowGraphFloatToBoolean",a.IntToBoolean="FlowGraphIntToBoolean",a.IntToFloat="FlowGraphIntToFloat",a.FloatToInt="FlowGraphFloatToInt",a.Easing="FlowGraphEasingBlock",a.Context="FlowGraphContextBlock",a.ArrayIndex="FlowGraphArrayIndexBlock",a.CodeExecution="FlowGraphCodeExecutionBlock",a.IndexOf="FlowGraphIndexOfBlock",a.FunctionReference="FlowGraphFunctionReference",a.BezierCurveEasing="FlowGraphBezierCurveEasing",a.DataSwitch="FlowGraphDataSwitchBlock"})(Gx||(Gx={}));var J;(function(a){a[a.Texture=1]="Texture",a[a.TextureBackBuffer=2]="TextureBackBuffer",a[a.TextureBackBufferDepthStencilAttachment=4]="TextureBackBufferDepthStencilAttachment",a[a.TextureDepthStencilAttachment=8]="TextureDepthStencilAttachment",a[a.TextureViewDepth=16]="TextureViewDepth",a[a.TextureViewNormal=32]="TextureViewNormal",a[a.TextureAlbedo=64]="TextureAlbedo",a[a.TextureReflectivity=128]="TextureReflectivity",a[a.TextureWorldPosition=256]="TextureWorldPosition",a[a.TextureVelocity=512]="TextureVelocity",a[a.TextureIrradiance=1024]="TextureIrradiance",a[a.TextureAlbedoSqrt=2048]="TextureAlbedoSqrt",a[a.TextureScreenDepth=4096]="TextureScreenDepth",a[a.TextureWorldNormal=8192]="TextureWorldNormal",a[a.TextureLocalPosition=16384]="TextureLocalPosition",a[a.TextureLinearVelocity=32768]="TextureLinearVelocity",a[a.TextureAllButBackBufferDepthStencil=1048571]="TextureAllButBackBufferDepthStencil",a[a.TextureAllButBackBuffer=1048569]="TextureAllButBackBuffer",a[a.TextureAll=1048575]="TextureAll",a[a.ResourceContainer=1048576]="ResourceContainer",a[a.ShadowGenerator=2097152]="ShadowGenerator",a[a.ShadowLight=4194304]="ShadowLight",a[a.Camera=16777216]="Camera",a[a.ObjectList=33554432]="ObjectList",a[a.AutoDetect=268435456]="AutoDetect",a[a.BasedOnInput=536870912]="BasedOnInput",a[a.Undefined=1073741824]="Undefined",a[a.Object=2147483648]="Object",a[a.All=4294967295]="All"})(J||(J={}));var Wx;(function(a){a[a.Compatible=0]="Compatible",a[a.TypeIncompatible=1]="TypeIncompatible",a[a.HierarchyIssue=2]="HierarchyIssue"})(Wx||(Wx={}));var $x;(function(a){a[a.Input=0]="Input",a[a.Output=1]="Output"})($x||($x={}));class Dn{get direction(){return this._direction}static IsTextureHandle(e){return e!==void 0&&Number.isFinite(e)}static IsShadowGenerator(e){return e!==void 0&&e.mapSize!==void 0}static IsShadowLight(e){return e!==void 0&&e.setShadowProjectionMatrix!==void 0}get type(){if(this._type===J.AutoDetect){if(this._ownerBlock.isInput)return this._ownerBlock.type;if(this._connectedPoint)return this._connectedPoint.type;if(this._linkedConnectionSource){if(this._linkedConnectionSource.isConnected)return this._linkedConnectionSource.type;if(this._linkedConnectionSource._defaultConnectionPointType)return this._linkedConnectionSource._defaultConnectionPointType}if(this._defaultConnectionPointType)return this._defaultConnectionPointType}if(this._type===J.BasedOnInput){if(this._typeConnectionSource){const e=typeof this._typeConnectionSource=="function"?this._typeConnectionSource():this._typeConnectionSource;return e.isConnected?e._connectedPoint.type:this._defaultConnectionPointType??e.type}else if(this._defaultConnectionPointType)return this._defaultConnectionPointType}return this._type}set type(e){this._type=e}get isConnected(){return this.connectedPoint!==null||this.hasEndpoints}get connectedPoint(){return this._connectedPoint}get ownerBlock(){return this._ownerBlock}get sourceBlock(){return this._connectedPoint?this._connectedPoint.ownerBlock:null}get connectedBlocks(){return this._endpoints.length===0?[]:this._endpoints.map(e=>e.ownerBlock)}get endpoints(){return this._endpoints}get hasEndpoints(){return this._endpoints&&this._endpoints.length>0}get innerType(){return this._linkedConnectionSource&&!this._isMainLinkSource&&this._linkedConnectionSource.isConnected?this.type:this._type}createCustomInputBlock(){return null}constructor(e,t,i){this._connectedPoint=null,this._acceptedConnectionPointType=null,this._endpoints=new Array,this._type=J.Undefined,this._linkedConnectionSource=null,this._isMainLinkSource=!1,this._typeConnectionSource=null,this._defaultConnectionPointType=null,this.needDualDirectionValidation=!1,this.acceptedConnectionPointTypes=[],this.excludedConnectionPointTypes=[],this.onConnectionObservable=new j,this.onDisconnectionObservable=new j,this.isExposedOnFrame=!1,this.exposedPortPosition=-1,this._ownerBlock=t,this.name=e,this._direction=i}getClassName(){return"NodeRenderGraphConnectionPoint"}canConnectTo(e){return this.checkCompatibilityState(e)===0}checkCompatibilityState(e){const t=this._ownerBlock,i=e.ownerBlock;if(this.type!==e.type&&e.innerType!==J.AutoDetect)return e.acceptedConnectionPointTypes&&e.acceptedConnectionPointTypes.indexOf(this.type)!==-1?0:1;if(e.excludedConnectionPointTypes&&e.excludedConnectionPointTypes.indexOf(this.type)!==-1)return 1;let r=i,s=t;return this.direction===0&&(r=t,s=i),r.isAnAncestorOf(s)?2:0}connectTo(e,t=!1){if(!t&&!this.canConnectTo(e))throw"Cannot connect these two connectors.";return this._endpoints.push(e),e._connectedPoint=this,this.onConnectionObservable.notifyObservers(e),e.onConnectionObservable.notifyObservers(this),this}disconnectFrom(e){const t=this._endpoints.indexOf(e);return t===-1?this:(this._endpoints.splice(t,1),e._connectedPoint=null,this.onDisconnectionObservable.notifyObservers(e),e.onDisconnectionObservable.notifyObservers(this),this)}addExcludedConnectionPointFromAllowedTypes(e){let t=0,i=2**t;for(;i<J.All;)e&i||this.excludedConnectionPointTypes.push(i),t++,i=2**t}addAcceptedConnectionPointTypes(e){let t=0,i=2**t;for(;i<J.All;)e&i&&this.acceptedConnectionPointTypes.indexOf(i)===-1&&this.acceptedConnectionPointTypes.push(i),t++,i=2**t}serialize(e=!0){const t={};return t.name=this.name,t.displayName=this.displayName,e&&this.connectedPoint&&(t.inputName=this.name,t.targetBlockId=this.connectedPoint.ownerBlock.uniqueId,t.targetConnectionName=this.connectedPoint.name,t.isExposedOnFrame=!0,t.exposedPortPosition=this.exposedPortPosition),(this.isExposedOnFrame||this.exposedPortPosition>=0)&&(t.isExposedOnFrame=!0,t.exposedPortPosition=this.exposedPortPosition),t}dispose(){this.onConnectionObservable.clear(),this.onDisconnectionObservable.clear()}}class pi{get disabled(){var e;return!!((e=this._frameGraphTask)!=null&&e.disabled)}set disabled(e){this._frameGraphTask&&(this._frameGraphTask.disabled=e)}get task(){return this._frameGraphTask}get inputs(){return this._inputs}get outputs(){return this._outputs}get name(){return this._name}set name(e){this._name=e}get isInput(){return this._isInput}get isTeleportOut(){return this._isTeleportOut}get isTeleportIn(){return this._isTeleportIn}get isDebug(){return this._isDebug}get isUnique(){return this._isUnique}getClassName(){return"NodeRenderGraphBlock"}_inputRename(e){return e}_outputRename(e){return e}isAnAncestorOf(e){for(const t of this._outputs)if(t.hasEndpoints){for(const i of t.endpoints)if(i.ownerBlock===e||i.ownerBlock.isAnAncestorOf(e))return!0}return!1}isAnAncestorOfType(e){if(this.getClassName()===e)return!0;for(const t of this._outputs)if(t.hasEndpoints){for(const i of t.endpoints)if(i.ownerBlock.isAnAncestorOfType(e))return!0}return!1}getDescendantOfPredicate(e){if(e(this))return this;for(const t of this._outputs)if(t.hasEndpoints)for(const i of t.endpoints){const r=i.ownerBlock.getDescendantOfPredicate(e);if(r)return r}return null}constructor(e,t,i,...r){this._name="",this._isInput=!1,this._isTeleportOut=!1,this._isTeleportIn=!1,this._isDebug=!1,this._isUnique=!1,this.onBuildObservable=new j,this._inputs=new Array,this._outputs=new Array,this._codeVariableName="",this._additionalConstructionParameters=null,this.visibleOnFrame=!1,this._name=e,this._frameGraph=t,this._scene=i,this._engine=i.getEngine(),this.uniqueId=pu.UniqueId}registerInput(e,t,i=!1,r){return r=r??new Dn(e,this,0),r.type=t,r.isOptional=i,this._inputs.push(r),this}registerOutput(e,t,i){return i=i??new Dn(e,this,1),i.type=t,this._outputs.push(i),this}_addDependenciesInput(e=0){this.registerInput("dependencies",J.AutoDetect,!0);const t=this.getInputByName("dependencies");return t.addExcludedConnectionPointFromAllowedTypes(J.TextureAllButBackBuffer|J.ResourceContainer|J.ShadowGenerator|e),t}_buildBlock(e){}_customBuildStep(e){}_propagateInputValueToOutput(e,t){e.connectedPoint&&(t.value=e.connectedPoint.value)}build(e){var t;if(this._buildId===e.buildId)return!0;this._buildId=e.buildId;for(const i of this._inputs){if(!i.connectedPoint){i.isOptional||e._notConnectedNonOptionalInputs.push(i);continue}const r=i.connectedPoint.ownerBlock;r&&r!==this&&r.build(e)}if(this._customBuildStep(e),e.verbose&&L.Log(`Building ${this.name} [${this.getClassName()}]`),this._frameGraphTask&&(this._frameGraphTask.name=this.name),this._buildBlock(e),this._frameGraphTask){this._frameGraphTask.dependencies=void 0;const i=(t=this.getInputByName("dependencies"))==null?void 0:t.connectedPoint;if(i)if(i.type===J.ResourceContainer){const r=i.ownerBlock;for(let s=0;s<r.inputs.length;s++){const n=r.inputs[s];n.connectedPoint&&n.connectedPoint.value!==void 0&&Dn.IsTextureHandle(n.connectedPoint.value)&&(this._frameGraphTask.dependencies=this._frameGraphTask.dependencies||new Set,this._frameGraphTask.dependencies.add(n.connectedPoint.value))}}else Dn.IsTextureHandle(i.value)&&(this._frameGraphTask.dependencies=this._frameGraphTask.dependencies||new Set,this._frameGraphTask.dependencies.add(i.value));this._frameGraph.addTask(this._frameGraphTask)}return this.onBuildObservable.notifyObservers(this),!1}_linkConnectionTypes(e,t,i=!1){i?this._inputs[t]._acceptedConnectionPointType=this._inputs[e]:(this._inputs[e]._linkedConnectionSource=this._inputs[t],this._inputs[e]._isMainLinkSource=!0),this._inputs[t]._linkedConnectionSource=this._inputs[e]}initialize(){}autoConfigure(){}getInputByName(e){const t=this._inputs.filter(i=>i.name===e);return t.length?t[0]:null}getOutputByName(e){const t=this._outputs.filter(i=>i.name===e);return t.length?t[0]:null}serialize(){const e={};e.customType="BABYLON."+this.getClassName(),e.id=this.uniqueId,e.name=this.name,e.visibleOnFrame=this.visibleOnFrame,e.disabled=this.disabled,this._additionalConstructionParameters&&(e.additionalConstructionParameters=this._additionalConstructionParameters),e.inputs=[],e.outputs=[];for(const t of this.inputs)e.inputs.push(t.serialize());for(const t of this.outputs)e.outputs.push(t.serialize(!1));return e}_deserialize(e){this._name=e.name,this.comments=e.comments,this.visibleOnFrame=e.visibleOnFrame,this.disabled=e.disabled,this._deserializePortDisplayNamesAndExposedOnFrame(e)}_deserializePortDisplayNamesAndExposedOnFrame(e){const t=e.inputs,i=e.outputs;t&&t.forEach(r=>{const s=this.inputs.find(n=>n.name===r.name);s&&(r.displayName&&(s.displayName=r.displayName),r.isExposedOnFrame&&(s.isExposedOnFrame=r.isExposedOnFrame,s.exposedPortPosition=r.exposedPortPosition))}),i&&i.forEach((r,s)=>{r.displayName&&(this.outputs[s].displayName=r.displayName),r.isExposedOnFrame&&(this.outputs[s].isExposedOnFrame=r.isExposedOnFrame,this.outputs[s].exposedPortPosition=r.exposedPortPosition)})}_dumpPropertiesCode(){const e=this._codeVariableName;return`${e}.visibleOnFrame = ${this.visibleOnFrame};
${e}.disabled = ${this.disabled};
`}_dumpCodeForOutputConnections(e){let t="";if(e.indexOf(this)!==-1)return t;e.push(this);for(const i of this.inputs){if(!i.isConnected)continue;const r=i.connectedPoint,s=r.ownerBlock;t+=s._dumpCodeForOutputConnections(e),t+=`${s._codeVariableName}.${s._outputRename(r.name)}.connectTo(${this._codeVariableName}.${this._inputRename(i.name)});
`}return t}_dumpCode(e,t){t.push(this);const i=this.name.replace(/[^A-Za-z_]+/g,"");if(this._codeVariableName=i||`${this.getClassName()}_${this.uniqueId}`,e.indexOf(this._codeVariableName)!==-1){let n=0;do n++,this._codeVariableName=i+n;while(e.indexOf(this._codeVariableName)!==-1)}e.push(this._codeVariableName);let r=`
// ${this.getClassName()}
`;this.comments&&(r+=`// ${this.comments}
`);const s=this.getClassName();if(s==="RenderGraphInputBlock"){const o=this.type;r+=`var ${this._codeVariableName} = new BABYLON.NodeRenderGraphInputBlock("${this.name}", nodeRenderGraph.frameGraph, scene, BABYLON.NodeRenderGraphBlockConnectionPointTypes.${J[o]});
`}else this._additionalConstructionParameters?r+=`var ${this._codeVariableName} = new BABYLON.${s}("${this.name}", nodeRenderGraph.frameGraph, scene, ...${JSON.stringify(this._additionalConstructionParameters)});
`:r+=`var ${this._codeVariableName} = new BABYLON.${s}("${this.name}", nodeRenderGraph.frameGraph, scene);
`;r+=this._dumpPropertiesCode()+`
`;for(const n of this.inputs){if(!n.isConnected)continue;const l=n.connectedPoint.ownerBlock;t.indexOf(l)===-1&&(r+=l._dumpCode(e,t))}for(const n of this.outputs)if(n.hasEndpoints)for(const o of n.endpoints){const l=o.ownerBlock;l&&t.indexOf(l)===-1&&(r+=l._dumpCode(e,t))}return r}clone(){const e=this.serialize(),t=oi(e.customType);if(t){const i=e.additionalConstructionParameters,r=i?new t("",this._frameGraph,this._scene,...i):new t("",this._frameGraph,this._scene);return r._deserialize(e),r}return null}dispose(){var e;for(const t of this.inputs)t.dispose();for(const t of this.outputs)t.dispose();(e=this._frameGraphTask)==null||e.dispose(),this._frameGraphTask=void 0,this.onBuildObservable.clear()}}C([F("comment")],pi.prototype,"comments",void 0);const Hi=0,ar=1;class R_{constructor(e,t,i){this.name=e,this._parentTask=t,this._context=i,this.disabled=!1}setExecuteFunc(e){this._executeFunc=e}_execute(){this.disabled||this._executeFunc(this._context)}_isValid(){return this._executeFunc!==void 0?null:"Execute function is not set (call setExecuteFunc to set it)"}}class lh extends R_{static IsCullPass(e){return e.setObjectList!==void 0}get objectList(){return this._objectList}setObjectList(e){this._objectList=e}constructor(e,t,i,r){super(e,t,i),this._engine=r}_isValid(){const e=super._isValid();return e||(this._objectList!==void 0?null:"Object list is not set (call setObjectList to set it)")}}class Zl extends R_{static IsRenderPass(e){return e.setRenderTarget!==void 0}get renderTarget(){return this._renderTarget}get renderTargetDepth(){return this._renderTargetDepth}constructor(e,t,i,r){super(e,t,i),this._dependencies=new Set,this._engine=r}setRenderTarget(e){this._renderTarget=e}setRenderTargetDepth(e){this._renderTargetDepth=e}addDependencies(e){if(Array.isArray(e))for(const t of e)this._dependencies.add(t);else this._dependencies.add(e)}collectDependencies(e){const t=this._dependencies.keys();for(let i=t.next();i.done!==!0;i=t.next())e.add(i.value);if(this._renderTarget)if(Array.isArray(this._renderTarget))for(const i of this._renderTarget)i!==void 0&&e.add(i);else e.add(this._renderTarget);this._renderTargetDepth&&e.add(this._renderTargetDepth)}_execute(){this._frameGraphRenderTarget=this._frameGraphRenderTarget||this._context.createRenderTarget(this.name,this._renderTarget,this._renderTargetDepth),this._context.bindRenderTarget(this._frameGraphRenderTarget,`frame graph render pass - ${this.name}`),super._execute(),this._context._flushDebugMessages()}_isValid(){const e=super._isValid();return e||(this._renderTarget!==void 0||this.renderTargetDepth!==void 0?null:"Render target and render target depth cannot both be undefined.")}}class zi{get name(){return this._name}set name(e){this._name=e}get disabled(){return this._disabled}set disabled(e){this._disabled=e}get passes(){return this._passes}get passesDisabled(){return this._passesDisabled}isReady(){return!0}dispose(){this._reset(),this.onTexturesAllocatedObservable.clear()}constructor(e,t){this._passes=[],this._passesDisabled=[],this._disabled=!1,this.onTexturesAllocatedObservable=new j,this.name=e,this._frameGraph=t,this._reset()}_reset(){this._passes.length=0,this._passesDisabled.length=0}_addPass(e,t){t?this._passesDisabled.push(e):this._passes.push(e)}_checkTask(){let e=null,t=null,i;for(const l of this._passes){const u=l._isValid();if(u)throw new Error(`Pass "${l.name}" is not valid. ${u}`);if(Zl.IsRenderPass(l)){const c=Array.isArray(l.renderTarget)?l.renderTarget:[l.renderTarget];e=[];for(const h of c)h!==void 0&&e.push(this._frameGraph.textureManager.getTextureFromHandle(h));t=l.renderTargetDepth!==void 0?this._frameGraph.textureManager.getTextureFromHandle(l.renderTargetDepth):null}else lh.IsCullPass(l)&&(i=l.objectList)}let r=null,s=[],n=null,o;for(const l of this._passesDisabled){const u=l._isValid();if(u)throw new Error(`Pass "${l.name}" is not valid. ${u}`);if(Zl.IsRenderPass(l)){const c=Array.isArray(l.renderTarget)?l.renderTarget:[l.renderTarget];r=[];for(const h of c)h!==void 0&&r.push(this._frameGraph.textureManager.getTextureFromHandle(h));s=c,n=l.renderTargetDepth!==void 0?this._frameGraph.textureManager.getTextureFromHandle(l.renderTargetDepth):null}else lh.IsCullPass(l)&&(o=l.objectList)}if(this._passesDisabled.length>0){if(!this._checkSameRenderTarget(e,r)){let l=!0;for(const u of s)if(u!==void 0&&!this._frameGraph.textureManager.isHistoryTexture(u)){l=!1;break}if(!l)throw new Error(`The output texture of the task "${this.name}" is different when it is enabled or disabled.`)}if(t!==n)throw new Error(`The output depth texture of the task "${this.name}" is different when it is enabled or disabled.`);if(i!==o)throw new Error(`The output object list of the task "${this.name}" is different when it is enabled or disabled.`)}}_getPasses(){return this.disabled&&this._passesDisabled.length>0?this._passesDisabled:this._passes}_checkSameRenderTarget(e,t){if(e===null||t===null)return e===t;if(e.length!==t.length)return!1;for(let i=0;i<e.length;i++)if(e[i]!==t[i])return!1;return!0}}class rw extends zi{record(){if(this.sourceTexture===void 0)throw new Error(`FrameGraphCopyToBackbufferColorTask "${this.name}": sourceTexture is required`);const e=this._frameGraph.addRenderPass(this.name);e.addDependencies(this.sourceTexture),e.setRenderTarget(Hi),e.setExecuteFunc(i=>{i.isBackbuffer(this.sourceTexture)||i.copyTexture(this.sourceTexture)});const t=this._frameGraph.addRenderPass(this.name+"_disabled",!0);t.setRenderTarget(Hi),t.setExecuteFunc(i=>{})}}class E0 extends pi{get task(){return this._frameGraphTask}constructor(e,t,i){super(e,t,i),this._isUnique=!0,this.registerInput("texture",J.Texture),this.texture.addAcceptedConnectionPointTypes(J.TextureAll),this._frameGraphTask=new rw(e,t)}getClassName(){return"NodeRenderGraphOutputBlock"}get texture(){return this._inputs[0]}_buildBlock(e){super._buildBlock(e),this._frameGraphTask.name=this.name;const t=this.texture.connectedPoint;t&&(this._frameGraphTask.sourceTexture=t.value)}}B("BABYLON.NodeRenderGraphOutputBlock",E0);var Hx;(function(a){a[a.None=0]="None",a[a.ToLinearSpace=1]="ToLinearSpace",a[a.ToGammaSpace=2]="ToGammaSpace"})(Hx||(Hx={}));class I0{get shaderLanguage(){return this._shaderLanguage}_textureIsInternal(e){return e.getInternalTexture===void 0}constructor(e,t=!1){this._shaderLanguage=0,this._shadersLoaded=!1,this._engine=e,this._isDepthTexture=t,this._renderer=new il(e),this._initShaderSourceAsync(t)}async _initShaderSourceAsync(e){const t=this._engine;t.isWebGPU?(this._shaderLanguage=1,await k(()=>Promise.resolve().then(()=>qB),void 0)):await k(()=>Promise.resolve().then(()=>XB),void 0),this._shadersLoaded=!0,this._effectWrapper=new Qt({engine:t,name:"CopyTextureToTexture",fragmentShader:"copyTextureToTexture",useShaderStore:!0,uniformNames:["conversion"],samplerNames:["textureSampler"],defines:e?["#define DEPTH_TEXTURE"]:[],shaderLanguage:this._shaderLanguage}),this._effectWrapper.onApplyObservable.add(()=>{e?(t.setState(!1),t.setDepthBuffer(!0),t.depthCullingState.depthMask=!0,t.depthCullingState.depthFunc=519):t.depthCullingState.depthMask=!1,this._textureIsInternal(this._source)?this._effectWrapper.effect._bindTexture("textureSampler",this._source):this._effectWrapper.effect.setTexture("textureSampler",this._source),this._effectWrapper.effect.setFloat("conversion",this._conversion)})}isReady(){var e,t;return this._shadersLoaded&&!!((t=(e=this._effectWrapper)==null?void 0:e.effect)!=null&&t.isReady())}copy(e,t=null,i=0){if(!this.isReady())return!1;this._source=e,this._conversion=i;const r=this._engine.getDepthFunction(),s=this._engine.getDepthWrite();return this._renderer.render(this._effectWrapper,t),this._engine.setDepthWrite(s),this._isDepthTexture&&r&&this._engine.setDepthFunction(r),!0}dispose(){var e;(e=this._effectWrapper)==null||e.dispose(),this._renderer.dispose()}}class R0{}class M_ extends R0{static _IsObjectRenderer(e){return e.initRender!==void 0}constructor(e,t,i){super(),this._engine=e,this._textureManager=t,this._scene=i,this._debugMessageHasBeenPushed=!1,this._renderTargetIsBound=!0,this._effectRenderer=new il(this._engine),this._copyTexture=new I0(this._engine)}isBackbuffer(e){return this._textureManager.isBackbuffer(e)}isBackbufferColor(e){return this._textureManager.isBackbufferColor(e)}isBackbufferDepthStencil(e){return this._textureManager.isBackbufferDepthStencil(e)}createRenderTarget(e,t,i){return this._textureManager.createRenderTarget(e,t,i)}clear(e,t,i,r){this._applyRenderTarget(),this._engine.clear(e,t,i,r)}clearColorAttachments(e,t){this._applyRenderTarget(),this._engine.bindAttachments(t),this._engine.clear(e,!0,!1,!1)}bindAttachments(e){this._applyRenderTarget(),this._engine.bindAttachments(e)}generateMipMaps(){var t;if(((t=this._currentRenderTarget)==null?void 0:t.renderTargetWrapper)===void 0)return;this._renderTargetIsBound&&this._engine._currentRenderTarget&&(this._flushDebugMessages(),this._engine.unBindFramebuffer(this._engine._currentRenderTarget),this._renderTargetIsBound=!1);const e=this._currentRenderTarget.renderTargetWrapper.textures;if(e)for(const i of e)this._engine.generateMipmaps(i)}setTextureSamplingMode(e,t){const i=this._textureManager.getTextureFromHandle(e);i&&i.samplingMode!==t&&this._engine.updateTextureSamplingMode(t,i)}bindTextureHandle(e,t,i){let r;const s=this._textureManager._historyTextures.get(i);s?(r=s.textures[s.index],this._currentRenderTarget!==void 0&&this._currentRenderTarget.renderTargetWrapper!==void 0&&this._currentRenderTarget.renderTargetWrapper.textures.includes(r)&&(r=s.textures[s.index^1])):r=this._textureManager._textures.get(i).texture,e._bindTexture(t,r)}saveDepthStates(){this._depthTest=this._engine.getDepthBuffer(),this._depthWrite=this._engine.getDepthWrite()}restoreDepthStates(){this._engine.setDepthBuffer(this._depthTest),this._engine.setDepthWrite(this._depthWrite)}setDepthStates(e,t){this._engine.setDepthBuffer(e),this._engine.setDepthWrite(t)}applyFullScreenEffect(e,t){var r;if(!((r=e.effect)!=null&&r.isReady()))return!1;this._applyRenderTarget();const i=this._engine.getDepthWrite();return this._effectRenderer.saveStates(),this._effectRenderer.setViewport(),this._engine.enableEffect(e),this._engine.setState(!1),this._engine.setDepthBuffer(!1),this._engine.setDepthWrite(!1),this._effectRenderer.bindBuffers(e.effect),t==null||t(),this._effectRenderer.draw(),this._effectRenderer.restoreStates(),this._engine.setDepthWrite(i),this._engine.setAlphaMode(0),!0}copyTexture(e,t=!1){t&&this.bindRenderTarget(),this._applyRenderTarget(),this._copyTexture.copy(this._textureManager.getTextureFromHandle(e))}render(e,t,i){M_._IsObjectRenderer(e)?e.shouldRender()&&(this._scene.incrementRenderId(),this._scene.resetCachedMaterial(),this._applyRenderTarget(),e.prepareRenderList(),e.initRender(t,i),e.render(),e.finishRender()):(this._applyRenderTarget(),e.render())}bindRenderTarget(e,t){var i,r;if((e==null?void 0:e.renderTargetWrapper)===void 0&&this._currentRenderTarget===void 0||e&&this._currentRenderTarget&&e.equals(this._currentRenderTarget)){this._flushDebugMessages(),t!==void 0&&((r=(i=this._engine)._debugPushGroup)==null||r.call(i,t,2),this._debugMessageWhenTargetBound=void 0,this._debugMessageHasBeenPushed=!0);return}this._currentRenderTarget=(e==null?void 0:e.renderTargetWrapper)===void 0?void 0:e,this._debugMessageWhenTargetBound=t,this._renderTargetIsBound=!1}_flushDebugMessages(){var e,t;this._debugMessageHasBeenPushed&&((t=(e=this._engine)._debugPopGroup)==null||t.call(e,2),this._debugMessageHasBeenPushed=!1)}_applyRenderTarget(){var t,i,r;if(this._renderTargetIsBound)return;this._flushDebugMessages();const e=(t=this._currentRenderTarget)==null?void 0:t.renderTargetWrapper;e===void 0?this._engine.restoreDefaultFramebuffer():(this._engine._currentRenderTarget&&this._engine.unBindFramebuffer(this._engine._currentRenderTarget),this._engine.bindFramebuffer(e)),this._debugMessageWhenTargetBound!==void 0&&((r=(i=this._engine)._debugPushGroup)==null||r.call(i,this._debugMessageWhenTargetBound,2),this._debugMessageWhenTargetBound=void 0,this._debugMessageHasBeenPushed=!0),this._renderTargetIsBound=!0}_isReady(){return this._copyTexture.isReady()}_dispose(){this._effectRenderer.dispose(),this._copyTexture.dispose()}}function js(a){return a.width!==void 0}function ql(a){return js(a)?{width:a.width,height:a.height}:{width:a,height:a}}class sw{constructor(e,t,i,r){this._isBackBuffer=!1,this.name=e,this._textureManager=t,this._renderTargets=i===void 0?void 0:Array.isArray(i)?i:[i],this._renderTargetDepth=r}get renderTargetWrapper(){var e;if(!this._isBackBuffer){if(!this._renderTargetWrapper){const t=this._textureManager.engine,i=this._renderTargets===void 0?this._renderTargetDepth:this._renderTargets[0];if(this._textureManager.isBackbuffer(i)){this._isBackBuffer=!0;return}const r=this._textureManager.getTextureDescription(i),s={textureCount:((e=this._renderTargets)==null?void 0:e.length)??0,generateDepthBuffer:!1,label:this.name,samples:r.options.samples??1,dontCreateTextures:!0};this._renderTargetWrapper=t.createMultipleRenderTarget(r.size,s,!0);for(let n=0;n<s.textureCount;n++){const o=this._renderTargets[n],l=this._textureManager.getTextureFromHandle(o);if(!l)throw new Error(`FrameGraphRenderTarget.renderTargetWrapper: Failed to get texture from handle. handle: ${o}, name: ${this.name}, index: ${n}, renderTargets: ${this._renderTargets}`);this._renderTargetWrapper.setTexture(l,n,!1)}this._renderTargetDepth!==void 0&&this._renderTargetWrapper.setDepthStencilTexture(this._textureManager.getTextureFromHandle(this._renderTargetDepth),!1)}return this._renderTargetWrapper}}equals(e){const t=this._renderTargets,i=e._renderTargets;if(t!==void 0&&i!==void 0){if(t.length!==i.length)return!1;for(let r=0;r<t.length;r++)if(t[r]!==i[r])return!1}else if(t===void 0&&i!==void 0||t!==void 0&&i===void 0)return!1;return this._renderTargetDepth===e._renderTargetDepth}}var wi;(function(a){a[a.Task=0]="Task",a[a.Graph=1]="Graph",a[a.External=2]="External"})(wi||(wi={}));class wr{constructor(e,t=!1,i){this.engine=e,this._debugTextures=t,this._scene=i,this._textures=new Map,this._historyTextures=new Map,this._isRecordingTask=!1,this.showDebugLogsForTextureAllcationOptimization=!1,this._addSystemTextures()}isBackbuffer(e){if(e===Hi||e===ar)return!0;const t=this._textures.get(e);return t?t.refHandle===Hi||t.refHandle===ar:!1}isBackbufferColor(e){if(e===Hi)return!0;const t=this._textures.get(e);return t?t.refHandle===Hi:!1}isBackbufferDepthStencil(e){if(e===ar)return!0;const t=this._textures.get(e);return t?t.refHandle===ar:!1}isHistoryTexture(e){const t=this._textures.get(e);return t?(e=t.refHandle??e,this._historyTextures.has(e)):!1}getTextureCreationOptions(e){const t=this._textures.get(e),i=t.creationOptions;return{size:js(i.size)?{...i.size}:i.size,sizeIsPercentage:i.sizeIsPercentage,options:wr.CloneTextureOptions(i.options,t.textureIndex),isHistoryTexture:i.isHistoryTexture}}getTextureDescription(e){const t=this.getTextureCreationOptions(e);return{size:t.sizeIsPercentage?this.getAbsoluteDimensions(t.size):js(t.size)?t.size:{width:t.size,height:t.size},options:t.options}}getTextureHandleOrCreateTexture(e,t,i){if(e===void 0){if(t===void 0||i===void 0)throw new Error("getTextureHandleOrCreateTexture: Either handle or newTextureName and creationOptions must be provided.");return this.createRenderTargetTexture(t,i)}return e}getTextureFromHandle(e){const t=this._historyTextures.get(e);return t?t.textures[t.index^1]:this._textures.get(e).texture}importTexture(e,t,i){i!==void 0&&this._freeEntry(i);const r={size:{width:t.width,height:t.height},sizeIsPercentage:!1,isHistoryTexture:!1,options:{createMipMaps:t.generateMipMaps,samples:t.samples,types:[t.type],formats:[t.format],useSRGBBuffers:[t._useSRGBBuffer],creationFlags:[t._creationFlags],labels:t.label?[t.label]:["imported"]}};return this._createHandleForTexture(e,t,r,wi.External,i)}createRenderTargetTexture(e,t,i){return this._createHandleForTexture(e,null,{size:js(t.size)?{...t.size}:t.size,sizeIsPercentage:t.sizeIsPercentage,isHistoryTexture:t.isHistoryTexture,options:wr.CloneTextureOptions(t.options,void 0,!0)},this._isRecordingTask?wi.Task:wi.Graph,i)}createRenderTarget(e,t,i){var n;const r=new sw(e,this,t,i),s=r.renderTargetWrapper;if(s!==void 0&&t){const o=Array.isArray(t)?t:[t];for(let l=0;l<o.length;l++){let u=o[l];u=((n=this._textures.get(u))==null?void 0:n.refHandle)??u;const c=this._historyTextures.get(u);c&&(c.references.push({renderTargetWrapper:s,textureIndex:l}),s.setTexture(c.textures[c.index],l,!1))}}return r}createDanglingHandle(){return wr._Counter++}resolveDanglingHandle(e,t,i,r){if(t===void 0){if(i===void 0||r===void 0)throw new Error("resolveDanglingHandle: Either handle or newTextureName and creationOptions must be provided.");this.createRenderTargetTexture(i,r,e);return}const s=this._textures.get(t);if(s===void 0)throw new Error(`resolveDanglingHandle: Handle ${t} does not exist!`);this._textures.set(e,{texture:s.texture,refHandle:t,name:s.name,creationOptions:{size:{...s.creationOptions.size},options:wr.CloneTextureOptions(s.creationOptions.options),sizeIsPercentage:s.creationOptions.sizeIsPercentage,isHistoryTexture:!1},namespace:s.namespace,textureIndex:s.textureIndex})}getAbsoluteDimensions(e,t=this.engine.getRenderWidth(!0),i=this.engine.getRenderHeight(!0)){const{width:r,height:s}=ql(e);return{width:Math.floor(r*t/100),height:Math.floor(s*i/100)}}computeTotalTextureSize(e,t,i){let r=0;return this._textures.forEach((s,n)=>{var f;if(n===Hi||n===ar||s.refHandle!==void 0||e&&s.aliasHandle!==void 0)return;const o=s.creationOptions,l=s.textureIndex||0,u=o.sizeIsPercentage?this.getAbsoluteDimensions(o.size,t,i):ql(o.size),c=wr._GetTextureBlockInformation(((f=o.options.types)==null?void 0:f[l])??0,o.options.formats[l]),h=Math.ceil(u.width/c.width)*Math.ceil(u.height/c.height)*c.length;let d=h;o.options.createMipMaps&&(d=Math.floor(d*4/3)),(o.options.samples||1)>1&&(d+=h),r+=d}),r}_dispose(){this._releaseTextures()}_allocateTextures(e){e&&this._optimizeTextureAllocation(e),this._textures.forEach(t=>{var i,r,s,n,o,l;if(!t.texture){if(t.refHandle!==void 0){const u=this._textures.get(t.refHandle);t.texture=u.texture,u.refHandle===Hi&&(t.refHandle=Hi),u.refHandle===ar&&(t.refHandle=ar)}else if(t.namespace!==wi.External)if(t.aliasHandle!==void 0){const u=this._textures.get(t.aliasHandle);t.texture=u.texture,t.texture.incrementReferences()}else{const u=t.creationOptions,c=u.sizeIsPercentage?this.getAbsoluteDimensions(u.size):u.size,h=t.textureIndex||0,d={createMipMaps:u.options.createMipMaps,samples:u.options.samples,type:(i=u.options.types)==null?void 0:i[h],format:(r=u.options.formats)==null?void 0:r[h],useSRGBBuffer:(s=u.options.useSRGBBuffers)==null?void 0:s[h],creationFlags:(n=u.options.creationFlags)==null?void 0:n[h],label:((o=u.options.labels)==null?void 0:o[h])??`${t.name}${h>0?"#"+h:""}`,samplingMode:1,createMSAATexture:u.options.samples>1},f=rM(d.format),p=Fm(d.format),g=f&&p?12:f||p?14:5,_=this.engine._createInternalTexture(c,d,!1,g);f&&(_.type=sy(_.format)),t.texture=_}}t.texture&&t.refHandle===void 0&&((l=t.debug)==null||l.dispose(),t.debug=this._createDebugTexture(t.name,t.texture))}),this._historyTextures.forEach(t=>{for(let i=0;i<t.handles.length;i++)t.textures[i]=this._textures.get(t.handles[i]).texture})}_releaseTextures(e=!0){this._textures.forEach((t,i)=>{var r,s;t.lifespan&&(t.lifespan.firstTask=Number.MAX_VALUE,t.lifespan.lastTask=0),t.aliasHandle=void 0,(e||t.namespace!==wi.External)&&((r=t.debug)==null||r.dispose(),t.debug=void 0),t.namespace!==wi.External&&((s=t.texture)==null||s.dispose(),t.texture=null,(e||t.namespace===wi.Task)&&this._textures.delete(i))}),this._historyTextures.forEach(t=>{for(let i=0;i<t.handles.length;i++)t.textures[i]=null}),e&&(this._textures.clear(),this._historyTextures.clear(),this._addSystemTextures())}_updateHistoryTextures(){this._historyTextures.forEach(e=>{e.index=e.index^1;const t=e.textures[e.index];if(t)for(const{renderTargetWrapper:i,textureIndex:r}of e.references)i.setTexture(t,r,!1)})}_addSystemTextures(){const e={width:this.engine.getRenderWidth(!0),height:this.engine.getRenderHeight(!0)};this._textures.set(Hi,{name:"backbuffer color",texture:null,creationOptions:{size:e,options:{createMipMaps:!1,samples:this.engine.getCreationOptions().antialias?4:1,types:[0],formats:[5],useSRGBBuffers:[!1],creationFlags:[0],labels:["backbuffer color"]},sizeIsPercentage:!1},namespace:wi.External}),this._textures.set(ar,{name:"backbuffer depth/stencil",texture:null,creationOptions:{size:e,options:{createMipMaps:!1,samples:this.engine.getCreationOptions().antialias?4:1,types:[0],formats:[16],useSRGBBuffers:[!1],creationFlags:[0],labels:["backbuffer depth/stencil"]},sizeIsPercentage:!1},namespace:wi.External})}_createDebugTexture(e,t){if(!this._debugTextures)return;const i=new Y(null,this._scene);return i.name=e,i._texture=t,i._texture.incrementReferences(),i}_freeEntry(e){var i;const t=this._textures.get(e);t&&((i=t.debug)==null||i.dispose(),this._textures.delete(e))}_createHandleForTexture(e,t,i,r,s,n){var c;s=s??wr._Counter++,n=n||0;const o=i.isHistoryTexture?`${e} ping`:e;let l=((c=i.options.labels)==null?void 0:c[n])??"";l===o&&(l="");const u={texture:t,name:`${o}${l?" "+l:""}`,creationOptions:{size:js(i.size)?i.size:{width:i.size,height:i.size},options:i.options,sizeIsPercentage:i.sizeIsPercentage,isHistoryTexture:i.isHistoryTexture},namespace:r,textureIndex:n,textureDescriptionHash:this._createTextureDescriptionHash(i),lifespan:{firstTask:Number.MAX_VALUE,lastTask:0}};if(this._textures.set(s,u),r===wi.External)return s;if(i.isHistoryTexture){const h={size:{...u.creationOptions.size},options:{...u.creationOptions.options},sizeIsPercentage:u.creationOptions.sizeIsPercentage,isHistoryTexture:!1},d=this._createHandleForTexture(`${e} pong`,null,h,r);return this._historyTextures.set(s,{textures:[null,null],handles:[s,d],index:0,references:[]}),s}if(i.options.types&&i.options.types.length>1&&n===0){const h=i.options.types.length,d={size:js(i.size)?i.size:{width:i.size,height:i.size},options:i.options,sizeIsPercentage:i.sizeIsPercentage};for(let f=1;f<h;f++)this._createHandleForTexture(o,null,d,r,s+f,f);wr._Counter+=h-1}return s}_createTextureDescriptionHash(e){const t=[];return t.push(js(e.size)?`${e.size.width}_${e.size.height}`:`${e.size}`),t.push(e.sizeIsPercentage?"%":"A"),t.push(e.options.createMipMaps?"M":"N"),t.push(e.options.samples?`${e.options.samples}`:"S1"),t.push(e.options.types?e.options.types.join("_"):"0"),t.push(e.options.formats?e.options.formats.join("_"):"5"),t.push(e.options.useSRGBBuffers?e.options.useSRGBBuffers.join("_"):"false"),t.push(e.options.creationFlags?e.options.creationFlags.join("_"):"0"),t.join("_")}_optimizeTextureAllocation(e){this._computeTextureLifespan(e),this.showDebugLogsForTextureAllcationOptimization&&L.Log("================== Optimization of texture allocation ==================");const t=new Map,i=this._textures.keys();for(let r=i.next();r.done!==!0;r=i.next()){const s=r.value,n=this._textures.get(s);if(n.refHandle!==void 0||n.namespace===wi.External||this._historyTextures.has(s))continue;const o=n.textureDescriptionHash,l=n.lifespan,u=t.get(o);if(u){let c=!1;for(const h of u){const[d,f]=h;let p=!1;for(const g of f)if(g.firstTask<=l.lastTask&&g.lastTask>=l.firstTask){p=!0;break}if(!p){this.showDebugLogsForTextureAllcationOptimization&&L.Log(`Texture ${s} (${n.name}) reuses cache entry ${d}`),f.push(l),n.aliasHandle=d,c=!0;break}}c||u.push([s,[l]])}else t.set(o,[[s,[l]]])}}_computeTextureLifespan(e){this.showDebugLogsForTextureAllcationOptimization&&L.Log("================== Dump of texture dependencies for all tasks/passes ==================");for(let t=0;t<e.length;++t){const i=e[t];i.passes.length>0&&this._computeTextureLifespanForPasses(i,t,i.passes),i.passesDisabled.length>0&&this._computeTextureLifespanForPasses(i,t,i.passesDisabled),i.dependencies&&(this.showDebugLogsForTextureAllcationOptimization&&L.Log(`task#${t} (${i.name}), global dependencies`),this._updateLifespan(t*100+99,i.dependencies))}if(this.showDebugLogsForTextureAllcationOptimization){L.Log("================== Texture lifespans ==================");const t=this._textures.keys();for(let i=t.next();i.done!==!0;i=t.next()){const r=i.value,s=this._textures.get(r);s.refHandle!==void 0||s.namespace===wi.External||this._historyTextures.has(r)||L.Log(`${r} (${s.name}): ${s.lifespan.firstTask} - ${s.lifespan.lastTask}`)}}}_computeTextureLifespanForPasses(e,t,i){for(let r=0;r<i.length;++r){const s=new Set,n=i[r];Zl.IsRenderPass(n)&&(n.collectDependencies(s),this.showDebugLogsForTextureAllcationOptimization&&L.Log(`task#${t} (${e.name}), pass#${r} (${n.name})`),this._updateLifespan(t*100+r,s))}}_updateLifespan(e,t){const i=t.keys();for(let r=i.next();r.done!==!0;r=i.next()){const s=r.value;let n=this._textures.get(s);if(!n)throw new Error(`FrameGraph._computeTextureLifespan: Texture handle "${s}" not found in the texture manager.`);let o=s;for(;n.refHandle!==void 0;)if(o=n.refHandle,n=this._textures.get(o),!n)throw new Error(`FrameGraph._computeTextureLifespan: Texture handle "${o}" not found in the texture manager (source handle="${s}").`);n.namespace===wi.External||this._historyTextures.has(o)||(this.showDebugLogsForTextureAllcationOptimization&&L.Log(`    ${o} (${n.name})`),n.lifespan.firstTask=Math.min(n.lifespan.firstTask,e),n.lifespan.lastTask=Math.max(n.lifespan.lastTask,e))}}static CloneTextureOptions(e,t,i){return t!==void 0?{createMipMaps:e.createMipMaps,samples:e.samples,types:e.types?[e.types[t]]:void 0,formats:e.formats?[e.formats[t]]:void 0,useSRGBBuffers:e.useSRGBBuffers?[e.useSRGBBuffers[t]]:void 0,creationFlags:e.creationFlags?[e.creationFlags[t]]:void 0,labels:e.labels?[e.labels[t]]:void 0}:{createMipMaps:e.createMipMaps,samples:e.samples,types:e.types?[...e.types]:void 0,formats:e.formats?[...e.formats]:void 0,useSRGBBuffers:e.useSRGBBuffers?[...e.useSRGBBuffers]:void 0,creationFlags:e.creationFlags?[...e.creationFlags]:void 0,labels:e.labels&&i?[...e.labels]:void 0}}static _GetTextureBlockInformation(e,t){switch(t){case 15:return{width:1,height:1,length:2};case 16:return{width:1,height:1,length:3};case 13:return{width:1,height:1,length:4};case 14:return{width:1,height:1,length:4};case 18:return{width:1,height:1,length:5};case 19:return{width:1,height:1,length:1};case 36492:return{width:4,height:4,length:16};case 36495:return{width:4,height:4,length:16};case 36494:return{width:4,height:4,length:16};case 33779:return{width:4,height:4,length:16};case 33778:return{width:4,height:4,length:16};case 33777:case 33776:return{width:4,height:4,length:8};case 37808:return{width:4,height:4,length:16};case 36196:case 37492:return{width:4,height:4,length:8};case 37496:return{width:4,height:4,length:16}}switch(e){case 3:case 0:switch(t){case 6:case 8:case 0:case 1:case 2:return{width:1,height:1,length:1};case 7:case 9:return{width:1,height:1,length:2};case 4:case 10:return{width:1,height:1,length:3};case 11:return{width:1,height:1,length:4};default:return{width:1,height:1,length:4}}case 4:case 5:switch(t){case 8:return{width:1,height:1,length:2};case 9:return{width:1,height:1,length:4};case 10:return{width:1,height:1,length:6};case 11:return{width:1,height:1,length:8};default:return{width:1,height:1,length:8}}case 6:case 7:switch(t){case 8:return{width:1,height:1,length:4};case 9:return{width:1,height:1,length:8};case 10:return{width:1,height:1,length:12};case 11:return{width:1,height:1,length:16};default:return{width:1,height:1,length:16}}case 1:switch(t){case 6:return{width:1,height:1,length:4};case 7:return{width:1,height:1,length:8};case 4:return{width:1,height:1,length:12};case 5:return{width:1,height:1,length:16};default:return{width:1,height:1,length:16}}case 2:switch(t){case 6:return{width:1,height:1,length:2};case 7:return{width:1,height:1,length:4};case 4:return{width:1,height:1,length:6};case 5:return{width:1,height:1,length:8};default:return{width:1,height:1,length:8}}case 10:return{width:1,height:1,length:2};case 13:switch(t){case 5:case 11:return{width:1,height:1,length:4};default:return{width:1,height:1,length:4}}case 14:switch(t){case 5:case 11:return{width:1,height:1,length:4};default:return{width:1,height:1,length:4}}case 8:return{width:1,height:1,length:2};case 9:return{width:1,height:1,length:2};case 11:switch(t){case 5:return{width:1,height:1,length:4};case 11:return{width:1,height:1,length:4};default:return{width:1,height:1,length:4}}}return{width:1,height:1,length:4}}}wr._Counter=2;var Mn;(function(a){a[a.Normal=0]="Normal",a[a.Render=1]="Render",a[a.Cull=2]="Cull"})(Mn||(Mn={}));class nw{get engine(){return this._engine}get scene(){return this._scene}get tasks(){return this._tasks}getLinkedNodeRenderGraph(){return this._linkedNodeRenderGraph}constructor(e,t=!1,i=null){this._linkedNodeRenderGraph=i,this._tasks=[],this._currentProcessedTask=null,this._whenReadyAsyncCancel=null,this.name="Frame Graph",this.optimizeTextureAllocation=!0,this.onBuildObservable=new j,this._scene=e,this._engine=e.getEngine(),this.textureManager=new wr(this._engine,t,e),this._passContext=new R0,this._renderContext=new M_(this._engine,this.textureManager,e),this._scene.frameGraphs.push(this)}getClassName(){return"FrameGraph"}getTaskByName(e){return this._tasks.find(t=>t.name===e)}addTask(e){if(this._currentProcessedTask!==null)throw new Error(`FrameGraph.addTask: Can't add the task "${e.name}" while another task is currently building (task: ${this._currentProcessedTask.name}).`);this._tasks.push(e)}addPass(e,t=!1){return this._addPass(e,Mn.Normal,t)}addRenderPass(e,t=!1){return this._addPass(e,Mn.Render,t)}addCullPass(e,t=!1){return this._addPass(e,Mn.Cull,t)}_addPass(e,t,i=!1){if(!this._currentProcessedTask)throw new Error("FrameGraph: A pass must be created during a Task.record execution only.");let r;switch(t){case Mn.Render:r=new Zl(e,this._currentProcessedTask,this._renderContext,this._engine);break;case Mn.Cull:r=new lh(e,this._currentProcessedTask,this._passContext,this._engine);break;default:r=new R_(e,this._currentProcessedTask,this._passContext);break}return this._currentProcessedTask._addPass(r,i),r}build(){this.textureManager._releaseTextures(!1);try{for(const e of this._tasks)e._reset(),this._currentProcessedTask=e,this.textureManager._isRecordingTask=!0,e.record(),this.textureManager._isRecordingTask=!1,this._currentProcessedTask=null;this.textureManager._allocateTextures(this.optimizeTextureAllocation?this._tasks:void 0);for(const e of this._tasks)e._checkTask();for(const e of this._tasks)e.onTexturesAllocatedObservable.notifyObservers(this._renderContext);this.onBuildObservable.notifyObservers(this)}catch(e){throw this._tasks.length=0,this._currentProcessedTask=null,this.textureManager._isRecordingTask=!1,e}}whenReadyAsync(e=16,t=3e4){let i=null;return new Promise(r=>{this._whenReadyAsyncCancel=du(()=>{let s=this._renderContext._isReady();for(const n of this._tasks){const o=n.isReady();!o&&!i&&(i=n),s&&(s=o)}return s},()=>{this._whenReadyAsyncCancel=null,r()},(s,n)=>{this._whenReadyAsyncCancel=null,n?(L.Error(`FrameGraph: Timeout while waiting for the frame graph to be ready.${i?` First task not ready: ${i.name}`:""}`),s&&L.Error(s)):(L.Error("FrameGraph: An unexpected error occurred while waiting for the frame graph to be ready."),s&&(L.Error(s),s.stack&&L.Error(s.stack)))},e,t)})}execute(){this._renderContext.bindRenderTarget(),this.textureManager._updateHistoryTextures();for(const e of this._tasks){const t=e._getPasses();for(const i of t)i._execute()}}clear(){var e;(e=this._whenReadyAsyncCancel)==null||e.call(this),this._whenReadyAsyncCancel=null;for(const t of this._tasks)t._reset();this._tasks.length=0,this.textureManager._releaseTextures(),this._currentProcessedTask=null}dispose(){var t;(t=this._whenReadyAsyncCancel)==null||t.call(this),this._whenReadyAsyncCancel=null,this.clear(),this.textureManager._dispose(),this._renderContext._dispose();const e=this._scene.frameGraphs.indexOf(this);e!==-1&&this._scene.frameGraphs.splice(e,1)}}var jx;(function(a){a[a.Boolean=0]="Boolean",a[a.Float=1]="Float",a[a.Int=2]="Int",a[a.Vector2=3]="Vector2",a[a.List=4]="List",a[a.Color4=5]="Color4",a[a.SamplingMode=6]="SamplingMode",a[a.TextureFormat=7]="TextureFormat",a[a.TextureType=8]="TextureType"})(jx||(jx={}));function U(a,e=0,t="PROPERTIES",i){return(r,s)=>{let n=r._propStore;n||(n=[],r._propStore=n),n.push({propertyName:s,displayName:a,type:e,groupName:t,options:i??{},className:r.getClassName()})}}class ga extends pi{get type(){return this._type}constructor(e,t,i,r=J.Undefined){super(e,t,i),this._storedValue=null,this._type=J.Undefined,this.onValueChangedObservable=new j,this.isExternal=!1,this._type=r,this._isInput=!0,this.registerOutput("output",r),this.setDefaultValue()}setDefaultValue(){switch(this.type){case J.Texture:case J.TextureViewDepth:case J.TextureScreenDepth:case J.TextureViewNormal:case J.TextureWorldNormal:case J.TextureAlbedo:case J.TextureReflectivity:case J.TextureLocalPosition:case J.TextureWorldPosition:case J.TextureVelocity:case J.TextureLinearVelocity:case J.TextureIrradiance:case J.TextureAlbedoSqrt:{const e={size:{width:100,height:100},options:{createMipMaps:!1,types:[0],formats:[5],samples:1,useSRGBBuffers:[!1]},sizeIsPercentage:!0};this.creationOptions=e;break}case J.TextureDepthStencilAttachment:{const e={size:{width:100,height:100},options:{createMipMaps:!1,types:[0],formats:[13],useSRGBBuffers:[!1],labels:[this.name],samples:1},sizeIsPercentage:!0};this.creationOptions=e;break}case J.ObjectList:this.value={meshes:[],particleSystems:[]},this.isExternal=!0;break;case J.Camera:this.value=this._scene.cameras[0],this.isExternal=!0;break;default:this.isExternal=!0}}get value(){return this._storedValue}set value(e){this._storedValue=e,this.output.value=void 0,this.onValueChangedObservable.notifyObservers(this)}getTypedValue(){return this._storedValue}getInternalTextureFromValue(){return this._storedValue._swapAndDie?this._storedValue:null}getClassName(){return"NodeRenderGraphInputBlock"}get output(){return this._outputs[0]}isAnyTexture(){return(this.type&J.TextureAll)!==0}isBackBuffer(){return(this.type&J.TextureBackBuffer)!==0}isBackBufferDepthStencilAttachment(){return(this.type&J.TextureBackBufferDepthStencilAttachment)!==0}isCamera(){return(this.type&J.Camera)!==0}isObjectList(){return(this.type&J.ObjectList)!==0}isShadowLight(){return(this.type&J.ShadowLight)!==0}_buildBlock(e){if(super._buildBlock(e),this.isExternal){if(this.isBackBuffer())this.output.value=Hi;else if(this.isBackBufferDepthStencilAttachment())this.output.value=ar;else if(this.isCamera())this.output.value=this.getTypedValue();else if(this.isObjectList())this.output.value=this.getTypedValue();else if(this.isShadowLight())this.output.value=this.getTypedValue();else{if(this._storedValue===void 0||this._storedValue===null)throw new Error(`NodeRenderGraphInputBlock: External input "${this.name}" is not set`);const t=this.getInternalTextureFromValue();t&&(this.output.value=this._frameGraph.textureManager.importTexture(this.name,t,this.output.value))}return}if(this.type&J.TextureAllButBackBuffer){const t=this.creationOptions;if(!t)throw new Error(`NodeRenderGraphInputBlock: Creation options are missing for texture "${this.name}"`);this.output.value=this._frameGraph.textureManager.createRenderTargetTexture(this.name,t)}}dispose(){this._storedValue=null,this.onValueChangedObservable.clear(),super.dispose()}_dumpPropertiesCode(){const e=[];return e.push(`${this._codeVariableName}.isExternal = ${this.isExternal};`),this.isAnyTexture()?this.isExternal?e.push(`${this._codeVariableName}.value = EXTERNAL_TEXTURE; // TODO: set the external texture`):e.push(`${this._codeVariableName}.creationOptions = ${JSON.stringify(this.creationOptions)};`):this.isCamera()?e.push(`${this._codeVariableName}.value = EXTERNAL_CAMERA; // TODO: set the external camera`):this.isObjectList()?e.push(`${this._codeVariableName}.value = EXTERNAL_OBJECT_LIST; // TODO: set the external object list`):this.isShadowLight()&&e.push(`${this._codeVariableName}.value = EXTERNAL_SHADOW_LIGHT; // TODO: set the external shadow light`),super._dumpPropertiesCode()+e.join(`
`)}serialize(){const e=super.serialize();return e.type=this.type,e.isExternal=this.isExternal,this.creationOptions&&(e.creationOptions=this.creationOptions),e}_deserialize(e){super._deserialize(e),this._type=e.type,this.output.type=this._type,this.isExternal=e.isExternal,e.creationOptions&&(e.creationOptions.options.depthTextureFormat!==void 0&&(e.creationOptions.options.formats=[e.creationOptions.options.depthTextureFormat]),this.creationOptions=e.creationOptions)}}C([U("Is external",0,"PROPERTIES")],ga.prototype,"isExternal",void 0);B("BABYLON.NodeRenderGraphInputBlock",ga);class M0 extends zi{constructor(e,t){super(e,t),this.color=new xe(.2,.2,.3,1),this.clearColor=!0,this.convertColorToLinearSpace=!1,this.clearDepth=!1,this.clearStencil=!1,this.outputTexture=this._frameGraph.textureManager.createDanglingHandle(),this.outputDepthTexture=this._frameGraph.textureManager.createDanglingHandle()}record(){if(this.targetTexture===void 0&&this.depthTexture===void 0)throw new Error(`FrameGraphClearTextureTask ${this.name}: targetTexture and depthTexture can't both be undefined.`);let e=0,t=0;if(this.targetTexture!==void 0&&(e=this._frameGraph.textureManager.getTextureDescription(this.targetTexture).options.samples||1,this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture,this.targetTexture)),this.depthTexture!==void 0&&(t=this._frameGraph.textureManager.getTextureDescription(this.depthTexture).options.samples||1,this._frameGraph.textureManager.resolveDanglingHandle(this.outputDepthTexture,this.depthTexture)),e!==t&&e!==0&&t!==0)throw new Error(`FrameGraphClearTextureTask ${this.name}: the depth texture and the target texture must have the same number of samples.`);const i=_t.Color4[0],r=this._frameGraph.addRenderPass(this.name);r.setRenderTarget(this.targetTexture),r.setRenderTargetDepth(this.depthTexture),r.setExecuteFunc(n=>{i.copyFrom(this.color),this.convertColorToLinearSpace&&i.toLinearSpaceToRef(i),n.clear(i,!!this.clearColor,!!this.clearDepth,!!this.clearStencil)});const s=this._frameGraph.addRenderPass(this.name+"_disabled",!0);return s.setRenderTarget(this.targetTexture),s.setRenderTargetDepth(this.depthTexture),s.setExecuteFunc(n=>{}),r}}class Jn extends pi{get task(){return this._frameGraphTask}constructor(e,t,i){super(e,t,i),this.registerInput("target",J.AutoDetect,!0),this.registerInput("depth",J.AutoDetect,!0),this._addDependenciesInput(),this.registerOutput("output",J.BasedOnInput),this.registerOutput("outputDepth",J.BasedOnInput),this.target.addExcludedConnectionPointFromAllowedTypes(J.TextureAll),this.depth.addExcludedConnectionPointFromAllowedTypes(J.TextureDepthStencilAttachment|J.TextureBackBufferDepthStencilAttachment),this.output._typeConnectionSource=this.target,this.outputDepth._typeConnectionSource=this.depth,this._frameGraphTask=new M0(e,t)}get color(){return this._frameGraphTask.color}set color(e){this._frameGraphTask.color=e}get clearColor(){return!!this._frameGraphTask.clearColor}set clearColor(e){this._frameGraphTask.clearColor=e}get convertColorToLinearSpace(){return!!this._frameGraphTask.convertColorToLinearSpace}set convertColorToLinearSpace(e){this._frameGraphTask.convertColorToLinearSpace=e}get clearDepth(){return!!this._frameGraphTask.clearDepth}set clearDepth(e){this._frameGraphTask.clearDepth=e}get clearStencil(){return!!this._frameGraphTask.clearStencil}set clearStencil(e){this._frameGraphTask.clearStencil=e}getClassName(){return"NodeRenderGraphClearBlock"}get target(){return this._inputs[0]}get depth(){return this._inputs[1]}get output(){return this._outputs[0]}get outputDepth(){return this._outputs[1]}_buildBlock(e){var t,i;super._buildBlock(e),this._propagateInputValueToOutput(this.target,this.output),this._propagateInputValueToOutput(this.depth,this.outputDepth),this._frameGraphTask.targetTexture=(t=this.target.connectedPoint)==null?void 0:t.value,this._frameGraphTask.depthTexture=(i=this.depth.connectedPoint)==null?void 0:i.value}_dumpPropertiesCode(){const e=[];return e.push(`${this._codeVariableName}.color = new BABYLON.Color4(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.color.a});`),e.push(`${this._codeVariableName}.clearColor = ${this.clearColor};`),e.push(`${this._codeVariableName}.convertColorToLinearSpace = ${this.convertColorToLinearSpace};`),e.push(`${this._codeVariableName}.clearDepth = ${this.clearDepth};`),e.push(`${this._codeVariableName}.clearStencil = ${this.clearStencil};`),super._dumpPropertiesCode()+e.join(`
`)}serialize(){const e=super.serialize();return e.color=this.color.asArray(),e.clearColor=this.clearColor,e.convertColorToLinearSpace=this.convertColorToLinearSpace,e.clearDepth=this.clearDepth,e.clearStencil=this.clearStencil,e}_deserialize(e){super._deserialize(e),this.color=xe.FromArray(e.color),this.clearColor=e.clearColor,this.convertColorToLinearSpace=!!e.convertColorToLinearSpace,this.clearDepth=e.clearDepth,this.clearStencil=e.clearStencil}}C([U("Color",5)],Jn.prototype,"color",null);C([U("Clear color",0,void 0,{embedded:!0})],Jn.prototype,"clearColor",null);C([U("Convert color to linear space",0)],Jn.prototype,"convertColorToLinearSpace",null);C([U("Clear depth",0,void 0,{embedded:!0})],Jn.prototype,"clearDepth",null);C([U("Clear stencil",0,void 0,{embedded:!0})],Jn.prototype,"clearStencil",null);B("BABYLON.NodeRenderGraphClearBlock",Jn);class It extends Qt{_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(Promise.all([k(()=>Promise.resolve().then(()=>I3),void 0),k(()=>Promise.resolve().then(()=>A3),void 0)]))):t.push(Promise.all([k(()=>Promise.resolve().then(()=>S3),void 0),k(()=>Promise.resolve().then(()=>y3),void 0)]))}constructor(e,t=null,i,r,s){const n=!!(s!=null&&s.blockCompilation);super({...s,name:e,engine:t||mt.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:It.FragmentUrl,uniforms:It.Uniforms,samplers:It.Samplers,vertexUrl:It.VertexUrl,blockCompilation:!0}),this._packedFloat=!1,this._staticDefines="",this.textureWidth=0,this.textureHeight=0,this.options.blockCompilation=n,i!==void 0&&(this.direction=i),r!==void 0&&(this.kernel=r)}set kernel(e){this._idealKernel!==e&&(e=Math.max(e,1),this._idealKernel=e,this._kernel=this._nearestBestKernel(e),this.options.blockCompilation||this._updateParameters())}get kernel(){return this._idealKernel}set packedFloat(e){this._packedFloat!==e&&(this._packedFloat=e,this.options.blockCompilation||this._updateParameters())}get packedFloat(){return this._packedFloat}bind(){super.bind(),this._drawWrapper.effect.setFloat2("delta",1/this.textureWidth*this.direction.x,1/this.textureHeight*this.direction.y)}_updateParameters(e,t){const i=this._kernel,r=(i-1)/2;let s=[],n=[],o=0;for(let _=0;_<i;_++){const S=_/(i-1),b=this._gaussianWeight(S*2-1);s[_]=_-r,n[_]=b,o+=b}for(let _=0;_<n.length;_++)n[_]/=o;const l=[],u=[],c=[];for(let _=0;_<=r;_+=2){const S=Math.min(_+1,Math.floor(r));if(_===S)c.push({o:s[_],w:n[_]});else{const y=S===r,T=n[_]+n[S]*(y?.5:1),v=s[_]+1/(1+n[_]/n[S]);v===0?(c.push({o:s[_],w:n[_]}),c.push({o:s[_+1],w:n[_+1]})):(c.push({o:v,w:T}),c.push({o:-v,w:T}))}}for(let _=0;_<c.length;_++)u[_]=c[_].o,l[_]=c[_].w;s=u,n=l;const h=this.options.engine.getCaps().maxVaryingVectors-(this.options.shaderLanguage===1?1:0),d=Math.max(h,0)-1;let f=Math.min(s.length,d),p="";p+=this._staticDefines,this._staticDefines.indexOf("DOF")!=-1&&(p+=`#define CENTER_WEIGHT ${this._glslFloat(n[f-1])}
`,f--);for(let _=0;_<f;_++)p+=`#define KERNEL_OFFSET${_} ${this._glslFloat(s[_])}
`,p+=`#define KERNEL_WEIGHT${_} ${this._glslFloat(n[_])}
`;let g=0;for(let _=d;_<s.length;_++)p+=`#define KERNEL_DEP_OFFSET${g} ${this._glslFloat(s[_])}
`,p+=`#define KERNEL_DEP_WEIGHT${g} ${this._glslFloat(n[_])}
`,g++;this.packedFloat&&(p+="#define PACKEDFLOAT 1"),this.options.blockCompilation=!1,this.updateEffect(p,null,null,{varyingCount:f,depCount:g},e,t)}_nearestBestKernel(e){const t=Math.round(e);for(const i of[t,t-1,t+1,t-2,t+2])if(i%2!==0&&Math.floor(i/2)%2===0&&i>0)return Math.max(i,3);return Math.max(t,3)}_gaussianWeight(e){const t=.3333333333333333,i=Math.sqrt(2*Math.PI)*t,r=-(e*e/(2*t*t));return 1/i*Math.exp(r)}_glslFloat(e,t=8){return e.toFixed(t).replace(/0+$/,"")}}It.VertexUrl="kernelBlur";It.FragmentUrl="kernelBlur";It.Uniforms=["delta","direction"];It.Samplers=["circleOfConfusionSampler"];class zt extends Ce{get direction(){return this._effectWrapper.direction}set direction(e){this._effectWrapper.direction=e}set kernel(e){this._effectWrapper.kernel=e}get kernel(){return this._effectWrapper.kernel}set packedFloat(e){this._effectWrapper.packedFloat=e}get packedFloat(){return this._effectWrapper.packedFloat}getClassName(){return"BlurPostProcess"}constructor(e,t,i,r,s=null,n=Y.BILINEAR_SAMPLINGMODE,o,l,u=0,c="",h=!1,d=5){const f=typeof r=="number"?h:!!r.blockCompilation,p={uniforms:It.Uniforms,samplers:It.Samplers,size:typeof r=="number"?r:void 0,camera:s,samplingMode:n,engine:o,reusable:l,textureType:u,vertexUrl:It.VertexUrl,indexParameters:{varyingCount:0,depCount:0},textureFormat:d,defines:c,...r,blockCompilation:!0};super(e,It.FragmentUrl,{effectWrapper:typeof r=="number"||!r.effectWrapper?new It(e,o,void 0,void 0,p):void 0,...p}),this._effectWrapper.options.blockCompilation=f,this.direction=t,this.onApplyObservable.add(()=>{this._effectWrapper.textureWidth=this._outputTexture?this._outputTexture.width:this.width,this._effectWrapper.textureHeight=this._outputTexture?this._outputTexture.height:this.height}),this.kernel=i}updateEffect(e=null,t=null,i=null,r,s,n){this._effectWrapper._updateParameters(s,n)}static _Parse(e,t,i,r){return Me.Parse(()=>new zt(e.name,e.direction,e.kernel,e.options,t,e.renderTargetSamplingMode,i.getEngine(),e.reusable,e.textureType,void 0,!1),e,i,r)}}C([qb()],zt.prototype,"direction",null);C([F()],zt.prototype,"kernel",null);C([F()],zt.prototype,"packedFloat",null);B("BABYLON.BlurPostProcess",zt);class de{get bias(){return this._bias}set bias(e){this._bias=e}get normalBias(){return this._normalBias}set normalBias(e){this._normalBias=e}get blurBoxOffset(){return this._blurBoxOffset}set blurBoxOffset(e){this._blurBoxOffset!==e&&(this._blurBoxOffset=e,this._disposeBlurPostProcesses())}get blurScale(){return this._blurScale}set blurScale(e){this._blurScale!==e&&(this._blurScale=e,this._disposeBlurPostProcesses())}get blurKernel(){return this._blurKernel}set blurKernel(e){this._blurKernel!==e&&(this._blurKernel=e,this._disposeBlurPostProcesses())}get useKernelBlur(){return this._useKernelBlur}set useKernelBlur(e){this._useKernelBlur!==e&&(this._useKernelBlur=e,this._disposeBlurPostProcesses())}get depthScale(){return this._depthScale!==void 0?this._depthScale:this._light.getDepthScale()}set depthScale(e){this._depthScale=e}_validateFilter(e){return e}get filter(){return this._filter}set filter(e){if(e=this._validateFilter(e),this._light.needCube()){if(e===de.FILTER_BLUREXPONENTIALSHADOWMAP){this.useExponentialShadowMap=!0;return}else if(e===de.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP){this.useCloseExponentialShadowMap=!0;return}else if(e===de.FILTER_PCF||e===de.FILTER_PCSS){this.usePoissonSampling=!0;return}}if((e===de.FILTER_PCF||e===de.FILTER_PCSS)&&!this._scene.getEngine()._features.supportShadowSamplers){this.usePoissonSampling=!0;return}this._filter!==e&&(this._filter=e,this._disposeBlurPostProcesses(),this._applyFilterValues(),this._light._markMeshesAsLightDirty())}get usePoissonSampling(){return this.filter===de.FILTER_POISSONSAMPLING}set usePoissonSampling(e){const t=this._validateFilter(de.FILTER_POISSONSAMPLING);!e&&this.filter!==de.FILTER_POISSONSAMPLING||(this.filter=e?t:de.FILTER_NONE)}get useExponentialShadowMap(){return this.filter===de.FILTER_EXPONENTIALSHADOWMAP}set useExponentialShadowMap(e){const t=this._validateFilter(de.FILTER_EXPONENTIALSHADOWMAP);!e&&this.filter!==de.FILTER_EXPONENTIALSHADOWMAP||(this.filter=e?t:de.FILTER_NONE)}get useBlurExponentialShadowMap(){return this.filter===de.FILTER_BLUREXPONENTIALSHADOWMAP}set useBlurExponentialShadowMap(e){const t=this._validateFilter(de.FILTER_BLUREXPONENTIALSHADOWMAP);!e&&this.filter!==de.FILTER_BLUREXPONENTIALSHADOWMAP||(this.filter=e?t:de.FILTER_NONE)}get useCloseExponentialShadowMap(){return this.filter===de.FILTER_CLOSEEXPONENTIALSHADOWMAP}set useCloseExponentialShadowMap(e){const t=this._validateFilter(de.FILTER_CLOSEEXPONENTIALSHADOWMAP);!e&&this.filter!==de.FILTER_CLOSEEXPONENTIALSHADOWMAP||(this.filter=e?t:de.FILTER_NONE)}get useBlurCloseExponentialShadowMap(){return this.filter===de.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP}set useBlurCloseExponentialShadowMap(e){const t=this._validateFilter(de.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);!e&&this.filter!==de.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP||(this.filter=e?t:de.FILTER_NONE)}get usePercentageCloserFiltering(){return this.filter===de.FILTER_PCF}set usePercentageCloserFiltering(e){const t=this._validateFilter(de.FILTER_PCF);!e&&this.filter!==de.FILTER_PCF||(this.filter=e?t:de.FILTER_NONE)}get filteringQuality(){return this._filteringQuality}set filteringQuality(e){this._filteringQuality!==e&&(this._filteringQuality=e,this._disposeBlurPostProcesses(),this._applyFilterValues(),this._light._markMeshesAsLightDirty())}get useContactHardeningShadow(){return this.filter===de.FILTER_PCSS}set useContactHardeningShadow(e){const t=this._validateFilter(de.FILTER_PCSS);!e&&this.filter!==de.FILTER_PCSS||(this.filter=e?t:de.FILTER_NONE)}get contactHardeningLightSizeUVRatio(){return this._contactHardeningLightSizeUVRatio}set contactHardeningLightSizeUVRatio(e){this._contactHardeningLightSizeUVRatio=e}get darkness(){return this._darkness}set darkness(e){this.setDarkness(e)}getDarkness(){return this._darkness}setDarkness(e){return e>=1?this._darkness=1:e<=0?this._darkness=0:this._darkness=e,this}get transparencyShadow(){return this._transparencyShadow}set transparencyShadow(e){this.setTransparencyShadow(e)}setTransparencyShadow(e){return this._transparencyShadow=e,this}getShadowMap(){return this._shadowMap}getShadowMapForRendering(){return this._shadowMap2?this._shadowMap2:this._shadowMap}getClassName(){return de.CLASSNAME}addShadowCaster(e,t=!0){if(!this._shadowMap)return this;if(this._shadowMap.renderList||(this._shadowMap.renderList=[]),this._shadowMap.renderList.indexOf(e)===-1&&this._shadowMap.renderList.push(e),t)for(const i of e.getChildMeshes())this._shadowMap.renderList.indexOf(i)===-1&&this._shadowMap.renderList.push(i);return this}removeShadowCaster(e,t=!0){if(!this._shadowMap||!this._shadowMap.renderList)return this;const i=this._shadowMap.renderList.indexOf(e);if(i!==-1&&this._shadowMap.renderList.splice(i,1),t)for(const r of e.getChildren())this.removeShadowCaster(r);return this}getLight(){return this._light}get shaderLanguage(){return this._shaderLanguage}_getCamera(){return this._camera??this._scene.activeCamera}get mapSize(){return this._mapSize}set mapSize(e){this._mapSize=e,this._light._markMeshesAsLightDirty(),this.recreateShadowMap()}constructor(e,t,i,r,s,n=!1){this.onBeforeShadowMapRenderObservable=new j,this.onAfterShadowMapRenderObservable=new j,this.onBeforeShadowMapRenderMeshObservable=new j,this.onAfterShadowMapRenderMeshObservable=new j,this.doNotSerialize=!1,this._bias=5e-5,this._normalBias=0,this._blurBoxOffset=1,this._blurScale=2,this._blurKernel=1,this._useKernelBlur=!1,this._filter=de.FILTER_NONE,this._filteringQuality=de.QUALITY_HIGH,this._contactHardeningLightSizeUVRatio=.1,this._darkness=0,this._transparencyShadow=!1,this.enableSoftTransparentShadow=!1,this.useOpacityTextureForTransparentShadow=!1,this.frustumEdgeFalloff=0,this._shaderLanguage=0,this.forceBackFacesOnly=!1,this._lightDirection=m.Zero(),this._viewMatrix=$.Zero(),this._projectionMatrix=$.Zero(),this._transformMatrix=$.Zero(),this._cachedPosition=new m(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cachedDirection=new m(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._currentFaceIndex=0,this._currentFaceIndexCache=0,this._defaultTextureMatrix=$.Identity(),this._shadersLoaded=!1,this._mapSize=e,this._light=t,this._scene=t.getScene(),this._camera=r??null,this._useRedTextureType=!!s,this._initShaderSourceAsync(n);let o=t._shadowGenerators;o||(o=t._shadowGenerators=new Map),o.set(this._camera,this),this.id=t.id,this._useUBO=this._scene.getEngine().supportsUniformBuffers,this._useUBO&&(this._sceneUBOs=[],this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for Shadow Generator (light "${this._light.name}")`))),de._SceneComponentInitialization(this._scene);const l=this._scene.getEngine().getCaps();i?l.textureFloatRender&&l.textureFloatLinearFiltering?this._textureType=1:l.textureHalfFloatRender&&l.textureHalfFloatLinearFiltering?this._textureType=2:this._textureType=0:l.textureHalfFloatRender&&l.textureHalfFloatLinearFiltering?this._textureType=2:l.textureFloatRender&&l.textureFloatLinearFiltering?this._textureType=1:this._textureType=0,this._initializeGenerator(),this._applyFilterValues()}_initializeGenerator(){this._light._markMeshesAsLightDirty(),this._initializeShadowMap()}_createTargetRenderTexture(){const e=this._scene.getEngine();e._features.supportDepthStencilTexture?(this._shadowMap=new Kt(this._light.name+"_shadowMap",this._mapSize,this._scene,!1,!0,this._textureType,this._light.needCube(),void 0,!1,!1,void 0,this._useRedTextureType?6:5),this._shadowMap.createDepthStencilTexture(e.useReverseDepthBuffer?516:513,!0,void 0,void 0,void 0,`DepthStencilForShadowGenerator-${this._light.name}`)):this._shadowMap=new Kt(this._light.name+"_shadowMap",this._mapSize,this._scene,!1,!0,this._textureType,this._light.needCube()),this._shadowMap.noPrePassRenderer=!0}_initializeShadowMap(){if(this._createTargetRenderTexture(),this._shadowMap===null)return;this._shadowMap.wrapU=Y.CLAMP_ADDRESSMODE,this._shadowMap.wrapV=Y.CLAMP_ADDRESSMODE,this._shadowMap.anisotropicFilteringLevel=1,this._shadowMap.updateSamplingMode(Y.BILINEAR_SAMPLINGMODE),this._shadowMap.renderParticles=!1,this._shadowMap.ignoreCameraViewport=!0,this._storedUniqueId&&(this._shadowMap.uniqueId=this._storedUniqueId),this._shadowMap.customRenderFunction=(r,s,n,o)=>this._renderForShadowMap(r,s,n,o),this._shadowMap.customIsReadyFunction=(r,s,n)=>{if(!n||!r.subMeshes)return!0;let o=!0;for(const l of r.subMeshes){const u=l.getRenderingMesh(),h=this._scene.getEngine(),d=l.getMaterial();if(!d||l.verticesCount===0||this.customAllowRendering&&!this.customAllowRendering(l))continue;const f=u._getInstancesRenderList(l._id,!!l.getReplacementMesh());if(f.mustReturn)continue;const p=h.getCaps().instancedArrays&&(f.visibleInstances[l._id]!==null&&f.visibleInstances[l._id]!==void 0||u.hasThinInstances),g=d.needAlphaBlendingForMesh(u);o=this.isReady(l,p,g)&&o}return o};const e=this._scene.getEngine();this._shadowMap.onBeforeBindObservable.add(()=>{var r;this._currentSceneUBO=this._scene.getSceneUniformBuffer(),(r=e._debugPushGroup)==null||r.call(e,`shadow map generation for pass id ${e.currentRenderPassId}`,1)}),this._shadowMap.onBeforeRenderObservable.add(r=>{this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._sceneUBOs[0]),this._currentFaceIndex=r,this._filter===de.FILTER_PCF&&e.setColorWrite(!1),this.getTransformMatrix(),this._scene.setTransformMatrix(this._viewMatrix,this._projectionMatrix),this._useUBO&&(this._scene.getSceneUniformBuffer().unbindEffect(),this._scene.finalizeSceneUbo())}),this._shadowMap.onAfterUnbindObservable.add(()=>{var s,n;if(this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._currentSceneUBO),this._scene.updateTransformMatrix(),this._filter===de.FILTER_PCF&&e.setColorWrite(!0),!this.useBlurExponentialShadowMap&&!this.useBlurCloseExponentialShadowMap){(s=e._debugPopGroup)==null||s.call(e,1);return}const r=this.getShadowMapForRendering();r&&(this._scene.postProcessManager.directRender(this._blurPostProcesses,r.renderTarget,!0),e.unBindFramebuffer(r.renderTarget,!0)),(n=e._debugPopGroup)==null||n.call(e,1)});const t=new xe(0,0,0,0),i=new xe(1,1,1,1);this._shadowMap.onClearObservable.add(r=>{this._filter===de.FILTER_PCF?r.clear(i,!1,!0,!1):this.useExponentialShadowMap||this.useBlurExponentialShadowMap?r.clear(t,!0,!0,!1):r.clear(i,!0,!0,!1)}),this._shadowMap.onResizeObservable.add(r=>{this._storedUniqueId=this._shadowMap.uniqueId,this._mapSize=r.getRenderSize(),this._light._markMeshesAsLightDirty(),this.recreateShadowMap()});for(let r=dg.MIN_RENDERINGGROUPS;r<dg.MAX_RENDERINGGROUPS;r++)this._shadowMap.setRenderingAutoClearDepthStencil(r,!1)}async _initShaderSourceAsync(e=!1){this._scene.getEngine().isWebGPU&&!e&&!de.ForceGLSL?(this._shaderLanguage=1,await Promise.all([k(()=>Promise.resolve().then(()=>j1),void 0),k(()=>Promise.resolve().then(()=>K1),void 0),k(()=>Promise.resolve().then(()=>eN),void 0),k(()=>Promise.resolve().then(()=>iN),void 0)])):await Promise.all([k(()=>Promise.resolve().then(()=>lN),void 0),k(()=>Promise.resolve().then(()=>xN),void 0),k(()=>Promise.resolve().then(()=>vN),void 0),k(()=>Promise.resolve().then(()=>yN),void 0)]),this._shadersLoaded=!0}_initializeBlurRTTAndPostProcesses(){const e=this._scene.getEngine(),t=this._mapSize/this.blurScale;(!this.useKernelBlur||this.blurScale!==1)&&(this._shadowMap2=new Kt(this._light.name+"_shadowMap2",t,this._scene,!1,!0,this._textureType,void 0,void 0,!1),this._shadowMap2.wrapU=Y.CLAMP_ADDRESSMODE,this._shadowMap2.wrapV=Y.CLAMP_ADDRESSMODE,this._shadowMap2.updateSamplingMode(Y.BILINEAR_SAMPLINGMODE)),this.useKernelBlur?(this._kernelBlurXPostprocess=new zt(this._light.name+"KernelBlurX",new Q(1,0),this.blurKernel,1,null,Y.BILINEAR_SAMPLINGMODE,e,!1,this._textureType),this._kernelBlurXPostprocess.width=t,this._kernelBlurXPostprocess.height=t,this._kernelBlurXPostprocess.externalTextureSamplerBinding=!0,this._kernelBlurXPostprocess.onApplyObservable.add(i=>{i.setTexture("textureSampler",this._shadowMap)}),this._kernelBlurYPostprocess=new zt(this._light.name+"KernelBlurY",new Q(0,1),this.blurKernel,1,null,Y.BILINEAR_SAMPLINGMODE,e,!1,this._textureType),this._kernelBlurXPostprocess.autoClear=!1,this._kernelBlurYPostprocess.autoClear=!1,this._textureType===0&&(this._kernelBlurXPostprocess.packedFloat=!0,this._kernelBlurYPostprocess.packedFloat=!0),this._blurPostProcesses=[this._kernelBlurXPostprocess,this._kernelBlurYPostprocess]):(this._boxBlurPostprocess=new Ce(this._light.name+"DepthBoxBlur","depthBoxBlur",["screenSize","boxOffset"],[],1,null,Y.BILINEAR_SAMPLINGMODE,e,!1,"#define OFFSET "+this._blurBoxOffset,this._textureType,void 0,void 0,void 0,void 0,this._shaderLanguage),this._boxBlurPostprocess.externalTextureSamplerBinding=!0,this._boxBlurPostprocess.onApplyObservable.add(i=>{i.setFloat2("screenSize",t,t),i.setTexture("textureSampler",this._shadowMap)}),this._boxBlurPostprocess.autoClear=!1,this._blurPostProcesses=[this._boxBlurPostprocess])}_renderForShadowMap(e,t,i,r){let s;if(r.length)for(s=0;s<r.length;s++)this._renderSubMeshForShadowMap(r.data[s]);for(s=0;s<e.length;s++)this._renderSubMeshForShadowMap(e.data[s]);for(s=0;s<t.length;s++)this._renderSubMeshForShadowMap(t.data[s]);if(this._transparencyShadow)for(s=0;s<i.length;s++)this._renderSubMeshForShadowMap(i.data[s],!0);else for(s=0;s<i.length;s++)i.data[s].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate=!1}_bindCustomEffectForRenderSubMeshForShadowMap(e,t,i){t.setMatrix("viewProjection",this.getTransformMatrix())}_renderSubMeshForShadowMap(e,t=!1){var p;const i=e.getRenderingMesh(),r=e.getEffectiveMesh(),s=this._scene,n=s.getEngine(),o=e.getMaterial();if(r._internalAbstractMeshDataInfo._isActiveIntermediate=!1,!o||e.verticesCount===0||e._renderId===s.getRenderId())return;const l=s.useRightHandedSystem,u=r._getWorldMatrixDeterminant()<0;let c=o._getEffectiveOrientation(i);(u&&!l||!u&&l)&&(c=c===0?1:0);const h=c===0;n.setState(o.backFaceCulling,void 0,void 0,h,o.cullBackFaces);const d=i._getInstancesRenderList(e._id,!!e.getReplacementMesh());if(d.mustReturn)return;const f=n.getCaps().instancedArrays&&(d.visibleInstances[e._id]!==null&&d.visibleInstances[e._id]!==void 0||i.hasThinInstances);if(!(this.customAllowRendering&&!this.customAllowRendering(e)))if(this.isReady(e,f,t)){e._renderId=s.getRenderId();const g=o.shadowDepthWrapper,_=(g==null?void 0:g.getEffect(e,this,n.currentRenderPassId))??e._getDrawWrapper(),S=vi.GetEffect(_);n.enableEffect(_),f||i._bind(e,S,o.fillMode),this.getTransformMatrix(),S.setFloat3("biasAndScaleSM",this.bias,this.normalBias,this.depthScale),this.getLight().getTypeID()===rs.LIGHTTYPEID_DIRECTIONALLIGHT?S.setVector3("lightDataSM",this._cachedDirection):S.setVector3("lightDataSM",this._cachedPosition);const b=this._getCamera();if(S.setFloat2("depthValuesSM",this.getLight().getDepthMinZ(b),this.getLight().getDepthMinZ(b)+this.getLight().getDepthMaxZ(b)),t&&this.enableSoftTransparentShadow&&S.setFloat2("softTransparentShadowSM",r.visibility*o.alpha,(p=this._opacityTexture)!=null&&p.getAlphaFromRGB?1:0),g)e._setMainDrawWrapperOverride(_),g.standalone?g.baseMaterial.bindForSubMesh(r.getWorldMatrix(),i,e):o.bindForSubMesh(r.getWorldMatrix(),i,e),e._setMainDrawWrapperOverride(null);else{if(this._opacityTexture&&(S.setTexture("diffuseSampler",this._opacityTexture),S.setMatrix("diffuseMatrix",this._opacityTexture.getTextureMatrix()||this._defaultTextureMatrix)),i.useBones&&i.computeBonesUsingShaders&&i.skeleton){const v=i.skeleton;if(v.isUsingTextureForMatrices){const E=v.getTransformMatrixTexture(i);if(!E)return;S.setTexture("boneSampler",E),S.setFloat("boneTextureWidth",4*(v.bones.length+1))}else S.setMatrices("mBones",v.getTransformMatrices(i))}Ns(i,S),i.morphTargetManager&&i.morphTargetManager.isUsingTextureForTargets&&i.morphTargetManager._bind(S);const T=e.getMesh().bakedVertexAnimationManager;T&&T.isEnabled&&T.bind(S,f),Fs(S,o,s)}!this._useUBO&&!g&&this._bindCustomEffectForRenderSubMeshForShadowMap(e,S,r),Lm(S,this._scene.getSceneUniformBuffer()),this._scene.getSceneUniformBuffer().bindUniformBuffer();const y=r.getWorldMatrix();f&&(r.getMeshUniformBuffer().bindToEffect(S,"Mesh"),r.transferToEffect(y)),this.forceBackFacesOnly&&n.setState(!0,0,!1,!0,o.cullBackFaces),this.onBeforeShadowMapRenderMeshObservable.notifyObservers(i),this.onBeforeShadowMapRenderObservable.notifyObservers(S),i._processRendering(r,e,S,o.fillMode,d,f,(T,v)=>{r!==i&&!T?(i.getMeshUniformBuffer().bindToEffect(S,"Mesh"),i.transferToEffect(v)):(r.getMeshUniformBuffer().bindToEffect(S,"Mesh"),r.transferToEffect(T?v:y))}),this.forceBackFacesOnly&&n.setState(!0,0,!1,!1,o.cullBackFaces),this.onAfterShadowMapRenderObservable.notifyObservers(S),this.onAfterShadowMapRenderMeshObservable.notifyObservers(i)}else this._shadowMap&&this._shadowMap.resetRefreshCounter()}_applyFilterValues(){this._shadowMap&&(this.filter===de.FILTER_NONE||this.filter===de.FILTER_PCSS?this._shadowMap.updateSamplingMode(Y.NEAREST_SAMPLINGMODE):this._shadowMap.updateSamplingMode(Y.BILINEAR_SAMPLINGMODE))}forceCompilation(e,t){const i={useInstances:!1,...t},r=this.getShadowMap();if(!r){e&&e(this);return}const s=r.renderList;if(!s){e&&e(this);return}const n=[];for(const u of s)n.push(...u.subMeshes);if(n.length===0){e&&e(this);return}let o=0;const l=()=>{var u;if(!(!this._scene||!this._scene.getEngine())){for(;this.isReady(n[o],i.useInstances,((u=n[o].getMaterial())==null?void 0:u.needAlphaBlendingForMesh(n[o].getMesh()))??!1);)if(o++,o>=n.length){e&&e(this);return}setTimeout(l,16)}};l()}forceCompilationAsync(e){return new Promise(t=>{this.forceCompilation(()=>{t()},e)})}_isReadyCustomDefines(e,t,i){}_prepareShadowDefines(e,t,i,r){i.push("#define SM_LIGHTTYPE_"+this._light.getClassName().toUpperCase()),i.push("#define SM_FLOAT "+(this._textureType!==0?"1":"0")),i.push("#define SM_ESM "+(this.useExponentialShadowMap||this.useBlurExponentialShadowMap?"1":"0")),i.push("#define SM_DEPTHTEXTURE "+(this.usePercentageCloserFiltering||this.useContactHardeningShadow?"1":"0"));const s=e.getMesh();return i.push("#define SM_NORMALBIAS "+(this.normalBias&&s.isVerticesDataPresent(N.NormalKind)?"1":"0")),i.push("#define SM_DIRECTIONINLIGHTDATA "+(this.getLight().getTypeID()===rs.LIGHTTYPEID_DIRECTIONALLIGHT?"1":"0")),i.push("#define SM_USEDISTANCE "+(this._light.needCube()?"1":"0")),i.push("#define SM_SOFTTRANSPARENTSHADOW "+(this.enableSoftTransparentShadow&&r?"1":"0")),this._isReadyCustomDefines(i,e,t),i}isReady(e,t,i){if(!this._shadersLoaded)return!1;const r=e.getMaterial(),s=r==null?void 0:r.shadowDepthWrapper;if(this._opacityTexture=null,!r)return!1;const n=[];if(this._prepareShadowDefines(e,t,n,i),s){if(!s.isReadyForSubMesh(e,n,this,t,this._scene.getEngine().currentRenderPassId))return!1}else{const o=e._getDrawWrapper(void 0,!0);let l=o.effect,u=o.defines;const c=[N.PositionKind],h=e.getMesh();let d=!1,f=!1,p=!1;const g=!1;this.normalBias&&h.isVerticesDataPresent(N.NormalKind)&&(c.push(N.NormalKind),n.push("#define NORMAL"),d=!0,h.nonUniformScaling&&n.push("#define NONUNIFORMSCALING"));const _=r.needAlphaTestingForMesh(h);if((_||r.needAlphaBlendingForMesh(h))&&(this.useOpacityTextureForTransparentShadow?this._opacityTexture=r.opacityTexture:this._opacityTexture=r.getAlphaTestTexture(),this._opacityTexture)){if(!this._opacityTexture.isReady())return!1;const v=r.alphaCutOff??de.DEFAULT_ALPHA_CUTOFF;n.push("#define ALPHATEXTURE"),_&&n.push(`#define ALPHATESTVALUE ${v}${v%1===0?".":""}`),h.isVerticesDataPresent(N.UVKind)&&(c.push(N.UVKind),n.push("#define UV1"),f=!0),h.isVerticesDataPresent(N.UV2Kind)&&this._opacityTexture.coordinatesIndex===1&&(c.push(N.UV2Kind),n.push("#define UV2"),p=!0)}const S=new Xn;if(h.useBones&&h.computeBonesUsingShaders&&h.skeleton){c.push(N.MatricesIndicesKind),c.push(N.MatricesWeightsKind),h.numBoneInfluencers>4&&(c.push(N.MatricesIndicesExtraKind),c.push(N.MatricesWeightsExtraKind));const v=h.skeleton;n.push("#define NUM_BONE_INFLUENCERS "+h.numBoneInfluencers),h.numBoneInfluencers>0&&S.addCPUSkinningFallback(0,h),v.isUsingTextureForMatrices?n.push("#define BONETEXTURE"):n.push("#define BonesPerMesh "+(v.bones.length+1))}else n.push("#define NUM_BONE_INFLUENCERS 0");const b=h.morphTargetManager?jn(h.morphTargetManager,n,c,h,!0,d,!1,f,p,g):0;if(Zn(r,this._scene,n),t&&(n.push("#define INSTANCES"),qn(c),e.getRenderingMesh().hasThinInstances&&n.push("#define THIN_INSTANCES")),this.customShaderOptions&&this.customShaderOptions.defines)for(const v of this.customShaderOptions.defines)n.indexOf(v)===-1&&n.push(v);const y=h.bakedVertexAnimationManager;y&&y.isEnabled&&(n.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),t&&c.push("bakedVertexAnimationSettingsInstanced"));const T=n.join(`
`);if(u!==T){u=T;let v="shadowMap";const E=["world","mBones","viewProjection","diffuseMatrix","lightDataSM","depthValuesSM","biasAndScaleSM","morphTargetInfluences","morphTargetCount","boneTextureWidth","softTransparentShadowSM","morphTargetTextureInfo","morphTargetTextureIndices","bakedVertexAnimationSettings","bakedVertexAnimationTextureSizeInverted","bakedVertexAnimationTime","bakedVertexAnimationTexture"],R=["diffuseSampler","boneSampler","morphTargets","bakedVertexAnimationTexture"],O=["Scene","Mesh"];if(_n(E),this.customShaderOptions){if(v=this.customShaderOptions.shaderName,this.customShaderOptions.attributes)for(const M of this.customShaderOptions.attributes)c.indexOf(M)===-1&&c.push(M);if(this.customShaderOptions.uniforms)for(const M of this.customShaderOptions.uniforms)E.indexOf(M)===-1&&E.push(M);if(this.customShaderOptions.samplers)for(const M of this.customShaderOptions.samplers)R.indexOf(M)===-1&&R.push(M)}const w=this._scene.getEngine();l=w.createEffect(v,{attributes:c,uniformsNames:E,uniformBuffersNames:O,samplers:R,defines:T,fallbacks:S,onCompiled:null,onError:null,indexParameters:{maxSimultaneousMorphTargets:b},shaderLanguage:this._shaderLanguage},w),o.setEffect(l,u)}if(!l.isReady())return!1}return(this.useBlurExponentialShadowMap||this.useBlurCloseExponentialShadowMap)&&(!this._blurPostProcesses||!this._blurPostProcesses.length)&&this._initializeBlurRTTAndPostProcesses(),!(this._kernelBlurXPostprocess&&!this._kernelBlurXPostprocess.isReady()||this._kernelBlurYPostprocess&&!this._kernelBlurYPostprocess.isReady()||this._boxBlurPostprocess&&!this._boxBlurPostprocess.isReady())}prepareDefines(e,t){const i=this._scene,r=this._light;!i.shadowsEnabled||!r.shadowEnabled||(e["SHADOW"+t]=!0,this.useContactHardeningShadow?(e["SHADOWPCSS"+t]=!0,this._filteringQuality===de.QUALITY_LOW?e["SHADOWLOWQUALITY"+t]=!0:this._filteringQuality===de.QUALITY_MEDIUM&&(e["SHADOWMEDIUMQUALITY"+t]=!0)):this.usePercentageCloserFiltering?(e["SHADOWPCF"+t]=!0,this._filteringQuality===de.QUALITY_LOW?e["SHADOWLOWQUALITY"+t]=!0:this._filteringQuality===de.QUALITY_MEDIUM&&(e["SHADOWMEDIUMQUALITY"+t]=!0)):this.usePoissonSampling?e["SHADOWPOISSON"+t]=!0:this.useExponentialShadowMap||this.useBlurExponentialShadowMap?e["SHADOWESM"+t]=!0:(this.useCloseExponentialShadowMap||this.useBlurCloseExponentialShadowMap)&&(e["SHADOWCLOSEESM"+t]=!0),r.needCube()&&(e["SHADOWCUBE"+t]=!0))}bindShadowLight(e,t){const i=this._light;if(!this._scene.shadowsEnabled||!i.shadowEnabled)return;const s=this._getCamera(),n=this.getShadowMap();if(!n)return;i.needCube()||t.setMatrix("lightMatrix"+e,this.getTransformMatrix());const o=this.getShadowMapForRendering();this._filter===de.FILTER_PCF?(t.setDepthStencilTexture("shadowTexture"+e,o),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),n.getSize().width,1/n.getSize().width,this.frustumEdgeFalloff,e)):this._filter===de.FILTER_PCSS?(t.setDepthStencilTexture("shadowTexture"+e,o),t.setTexture("depthTexture"+e,o),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),1/n.getSize().width,this._contactHardeningLightSizeUVRatio*n.getSize().width,this.frustumEdgeFalloff,e)):(t.setTexture("shadowTexture"+e,o),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),this.blurScale/n.getSize().width,this.depthScale,this.frustumEdgeFalloff,e)),i._uniformBuffer.updateFloat2("depthValues",this.getLight().getDepthMinZ(s),this.getLight().getDepthMinZ(s)+this.getLight().getDepthMaxZ(s),e)}get viewMatrix(){return this._viewMatrix}get projectionMatrix(){return this._projectionMatrix}getTransformMatrix(){const e=this._scene;if(this._currentRenderId===e.getRenderId()&&this._currentFaceIndexCache===this._currentFaceIndex)return this._transformMatrix;this._currentRenderId=e.getRenderId(),this._currentFaceIndexCache=this._currentFaceIndex;let t=this._light.position;if(this._light.computeTransformedInformation()&&(t=this._light.transformedPosition),m.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex),this._lightDirection),Math.abs(m.Dot(this._lightDirection,m.Up()))===1&&(this._lightDirection.z=1e-13),this._light.needProjectionMatrixCompute()||!this._cachedPosition||!this._cachedDirection||!t.equals(this._cachedPosition)||!this._lightDirection.equals(this._cachedDirection)){this._cachedPosition.copyFrom(t),this._cachedDirection.copyFrom(this._lightDirection),$.LookAtLHToRef(t,t.add(this._lightDirection),m.Up(),this._viewMatrix);const i=this.getShadowMap();if(i){const r=i.renderList;r&&this._light.setShadowProjectionMatrix(this._projectionMatrix,this._viewMatrix,r)}this._viewMatrix.multiplyToRef(this._projectionMatrix,this._transformMatrix)}return this._transformMatrix}recreateShadowMap(){const e=this._shadowMap;if(!e)return;const t=e.renderList;if(this._disposeRTTandPostProcesses(),this._initializeGenerator(),this.filter=this._filter,this._applyFilterValues(),t){this._shadowMap.renderList||(this._shadowMap.renderList=[]);for(const i of t)this._shadowMap.renderList.push(i)}else this._shadowMap.renderList=null}_disposeBlurPostProcesses(){this._shadowMap2&&(this._shadowMap2.dispose(),this._shadowMap2=null),this._boxBlurPostprocess&&(this._boxBlurPostprocess.dispose(),this._boxBlurPostprocess=null),this._kernelBlurXPostprocess&&(this._kernelBlurXPostprocess.dispose(),this._kernelBlurXPostprocess=null),this._kernelBlurYPostprocess&&(this._kernelBlurYPostprocess.dispose(),this._kernelBlurYPostprocess=null),this._blurPostProcesses=[]}_disposeRTTandPostProcesses(){this._shadowMap&&(this._shadowMap.dispose(),this._shadowMap=null),this._disposeBlurPostProcesses()}_disposeSceneUBOs(){if(this._sceneUBOs){for(const e of this._sceneUBOs)e.dispose();this._sceneUBOs=[]}}dispose(){if(this._disposeRTTandPostProcesses(),this._disposeSceneUBOs(),this._light){if(this._light._shadowGenerators){const e=this._light._shadowGenerators.entries();for(let t=e.next();t.done!==!0;t=e.next()){const[i,r]=t.value;r===this&&this._light._shadowGenerators.delete(i)}this._light._shadowGenerators.size===0&&(this._light._shadowGenerators=null)}this._light._markMeshesAsLightDirty()}this.onBeforeShadowMapRenderMeshObservable.clear(),this.onBeforeShadowMapRenderObservable.clear(),this.onAfterShadowMapRenderMeshObservable.clear(),this.onAfterShadowMapRenderObservable.clear()}serialize(){var i;const e={},t=this.getShadowMap();if(!t)return e;if(e.className=this.getClassName(),e.lightId=this._light.id,e.cameraId=(i=this._camera)==null?void 0:i.id,e.id=this.id,e.mapSize=t.getRenderSize(),e.forceBackFacesOnly=this.forceBackFacesOnly,e.darkness=this.getDarkness(),e.transparencyShadow=this._transparencyShadow,e.frustumEdgeFalloff=this.frustumEdgeFalloff,e.bias=this.bias,e.normalBias=this.normalBias,e.usePercentageCloserFiltering=this.usePercentageCloserFiltering,e.useContactHardeningShadow=this.useContactHardeningShadow,e.contactHardeningLightSizeUVRatio=this.contactHardeningLightSizeUVRatio,e.filteringQuality=this.filteringQuality,e.useExponentialShadowMap=this.useExponentialShadowMap,e.useBlurExponentialShadowMap=this.useBlurExponentialShadowMap,e.useCloseExponentialShadowMap=this.useBlurExponentialShadowMap,e.useBlurCloseExponentialShadowMap=this.useBlurExponentialShadowMap,e.usePoissonSampling=this.usePoissonSampling,e.depthScale=this.depthScale,e.blurBoxOffset=this.blurBoxOffset,e.blurKernel=this.blurKernel,e.blurScale=this.blurScale,e.useKernelBlur=this.useKernelBlur,e.renderList=[],t.renderList)for(let r=0;r<t.renderList.length;r++){const s=t.renderList[r];e.renderList.push(s.id)}return e}static Parse(e,t,i){const r=t.getLightById(e.lightId),s=e.cameraId!==void 0?t.getCameraById(e.cameraId):null,n=i?i(e.mapSize,r,s):new de(e.mapSize,r,void 0,s),o=n.getShadowMap();for(let l=0;l<e.renderList.length;l++)t.getMeshesById(e.renderList[l]).forEach(function(c){o&&(o.renderList||(o.renderList=[]),o.renderList.push(c))});return e.id!==void 0&&(n.id=e.id),n.forceBackFacesOnly=!!e.forceBackFacesOnly,e.darkness!==void 0&&n.setDarkness(e.darkness),e.transparencyShadow&&n.setTransparencyShadow(!0),e.frustumEdgeFalloff!==void 0&&(n.frustumEdgeFalloff=e.frustumEdgeFalloff),e.bias!==void 0&&(n.bias=e.bias),e.normalBias!==void 0&&(n.normalBias=e.normalBias),e.usePercentageCloserFiltering?n.usePercentageCloserFiltering=!0:e.useContactHardeningShadow?n.useContactHardeningShadow=!0:e.usePoissonSampling?n.usePoissonSampling=!0:e.useExponentialShadowMap?n.useExponentialShadowMap=!0:e.useBlurExponentialShadowMap?n.useBlurExponentialShadowMap=!0:e.useCloseExponentialShadowMap?n.useCloseExponentialShadowMap=!0:e.useBlurCloseExponentialShadowMap?n.useBlurCloseExponentialShadowMap=!0:e.useVarianceShadowMap?n.useExponentialShadowMap=!0:e.useBlurVarianceShadowMap&&(n.useBlurExponentialShadowMap=!0),e.contactHardeningLightSizeUVRatio!==void 0&&(n.contactHardeningLightSizeUVRatio=e.contactHardeningLightSizeUVRatio),e.filteringQuality!==void 0&&(n.filteringQuality=e.filteringQuality),e.depthScale&&(n.depthScale=e.depthScale),e.blurScale&&(n.blurScale=e.blurScale),e.blurBoxOffset&&(n.blurBoxOffset=e.blurBoxOffset),e.useKernelBlur&&(n.useKernelBlur=e.useKernelBlur),e.blurKernel&&(n.blurKernel=e.blurKernel),n}}de.CLASSNAME="ShadowGenerator";de.ForceGLSL=!1;de.FILTER_NONE=0;de.FILTER_EXPONENTIALSHADOWMAP=1;de.FILTER_POISSONSAMPLING=2;de.FILTER_BLUREXPONENTIALSHADOWMAP=3;de.FILTER_CLOSEEXPONENTIALSHADOWMAP=4;de.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP=5;de.FILTER_PCF=6;de.FILTER_PCSS=7;de.QUALITY_HIGH=0;de.QUALITY_MEDIUM=1;de.QUALITY_LOW=2;de.DEFAULT_ALPHA_CUTOFF=.5;de._SceneComponentInitialization=a=>{throw Cr("ShadowGeneratorSceneComponent")};const uh="packingFunctions",A0=`vec4 pack(float depth)
{const vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}
float unpack(vec4 color)
{const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}`;P.IncludesShadersStore[uh]||(P.IncludesShadersStore[uh]=A0);const aw={name:uh,shader:A0},ow=Object.freeze(Object.defineProperty({__proto__:null,packingFunctions:aw},Symbol.toStringTag,{value:"Module"})),ch="depthPixelShader",D0=`#ifdef ALPHATEST
varying vec2 vUV;uniform sampler2D diffuseSampler;
#endif
#include<clipPlaneFragmentDeclaration>
varying float vDepthMetric;
#ifdef PACKED
#include<packingFunctions>
#endif
#ifdef STORE_CAMERASPACE_Z
varying vec4 vViewPos;
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#include<clipPlaneFragment>
#ifdef ALPHATEST
if (texture2D(diffuseSampler,vUV).a<0.4)
discard;
#endif
#ifdef STORE_CAMERASPACE_Z
#ifdef PACKED
gl_FragColor=pack(vViewPos.z);
#else
gl_FragColor=vec4(vViewPos.z,0.0,0.0,1.0);
#endif
#else
#ifdef NONLINEARDEPTH
#ifdef PACKED
gl_FragColor=pack(gl_FragCoord.z);
#else
gl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);
#endif
#else
#ifdef PACKED
gl_FragColor=pack(vDepthMetric);
#else
gl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);
#endif
#endif
#endif
}`;P.ShadersStore[ch]||(P.ShadersStore[ch]=D0);const lw={name:ch,shader:D0},uw=Object.freeze(Object.defineProperty({__proto__:null,depthPixelShader:lw},Symbol.toStringTag,{value:"Module"})),Yx="pointCloudVertexDeclaration",cw=`#ifdef POINTSIZE
uniform float pointSize;
#endif
`;P.IncludesShadersStore[Yx]||(P.IncludesShadersStore[Yx]=cw);const hh="depthVertexShader",O0=`attribute vec3 position;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;uniform vec2 depthValues;
#if defined(ALPHATEST) || defined(NEED_UV)
varying vec2 vUV;uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
#ifdef STORE_CAMERASPACE_Z
uniform mat4 view;varying vec4 vViewPos;
#endif
#include<pointCloudVertexDeclaration>
varying float vDepthMetric;
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{vec3 positionUpdated=position;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#ifdef UV2
vec2 uv2Updated=uv2;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#include<clipPlaneVertex>
gl_Position=viewProjection*worldPos;
#ifdef STORE_CAMERASPACE_Z
vViewPos=view*worldPos;
#else
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));
#else
vDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));
#endif
#endif
#if defined(ALPHATEST) || defined(BASIC_RENDER)
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2Updated,1.0,0.0));
#endif
#endif
#include<pointCloudVertex>
}
`;P.ShadersStore[hh]||(P.ShadersStore[hh]=O0);const hw={name:hh,shader:O0},dw=Object.freeze(Object.defineProperty({__proto__:null,depthVertexShader:hw},Symbol.toStringTag,{value:"Module"}));class As{get shaderLanguage(){return this._shaderLanguage}setMaterialForRendering(e,t){this._depthMap.setMaterialForRendering(e,t)}constructor(e,t=1,i=null,r=!1,s=Y.TRILINEAR_SAMPLINGMODE,n=!1,o){this._shaderLanguage=0,this.enabled=!0,this.forceDepthWriteTransparentMeshes=!1,this.useOnlyInActiveCamera=!1,this.reverseCulling=!1,this._shadersLoaded=!1,this._scene=e,this._storeNonLinearDepth=r,this._storeCameraSpaceZ=n,this.isPacked=t===0,this.isPacked?this.clearColor=new xe(1,1,1,1):this.clearColor=new xe(n?1e8:1,0,0,1),this._initShaderSourceAsync(),As._SceneComponentInitialization(this._scene);const l=e.getEngine();this._camera=i,s!==Y.NEAREST_SAMPLINGMODE&&(t===1&&!l._caps.textureFloatLinearFiltering&&(s=Y.NEAREST_SAMPLINGMODE),t===2&&!l._caps.textureHalfFloatLinearFiltering&&(s=Y.NEAREST_SAMPLINGMODE));const u=this.isPacked||!l._features.supportExtendedTextureFormats?5:6;this._depthMap=new Kt(o??"DepthRenderer",{width:l.getRenderWidth(),height:l.getRenderHeight()},this._scene,!1,!0,t,!1,s,void 0,void 0,void 0,u),this._depthMap.wrapU=Y.CLAMP_ADDRESSMODE,this._depthMap.wrapV=Y.CLAMP_ADDRESSMODE,this._depthMap.refreshRate=1,this._depthMap.renderParticles=!1,this._depthMap.renderList=null,this._depthMap.noPrePassRenderer=!0,this._depthMap.activeCamera=this._camera,this._depthMap.ignoreCameraViewport=!0,this._depthMap.useCameraPostProcesses=!1,this._depthMap.onClearObservable.add(h=>{h.clear(this.clearColor,!0,!0,!0)}),this._depthMap.onBeforeBindObservable.add(()=>{var h;(h=l._debugPushGroup)==null||h.call(l,"depth renderer",1)}),this._depthMap.onAfterUnbindObservable.add(()=>{var h;(h=l._debugPopGroup)==null||h.call(l,1)}),this._depthMap.customIsReadyFunction=(h,d,f)=>{if((f||d===0)&&h.subMeshes)for(let p=0;p<h.subMeshes.length;++p){const g=h.subMeshes[p],_=g.getRenderingMesh(),S=_._getInstancesRenderList(g._id,!!g.getReplacementMesh()),b=l.getCaps().instancedArrays&&(S.visibleInstances[g._id]!==null&&S.visibleInstances[g._id]!==void 0||_.hasThinInstances);if(!this.isReady(g,b))return!1}return!0};const c=h=>{var R;const d=h.getRenderingMesh(),f=h.getEffectiveMesh(),p=this._scene,g=p.getEngine(),_=h.getMaterial();if(f._internalAbstractMeshDataInfo._isActiveIntermediate=!1,!_||f.infiniteDistance||_.disableDepthWrite||h.verticesCount===0||h._renderId===p.getRenderId())return;const S=f._getWorldMatrixDeterminant()<0;let b=_._getEffectiveOrientation(d);S&&(b=b===0?1:0);const y=b===0;g.setState(_.backFaceCulling,0,!1,y,this.reverseCulling?!_.cullBackFaces:_.cullBackFaces);const T=d._getInstancesRenderList(h._id,!!h.getReplacementMesh());if(T.mustReturn)return;const v=g.getCaps().instancedArrays&&(T.visibleInstances[h._id]!==null&&T.visibleInstances[h._id]!==void 0||d.hasThinInstances),E=this._camera||p.activeCamera;if(this.isReady(h,v)&&E){h._renderId=p.getRenderId();const O=(R=f._internalAbstractMeshDataInfo._materialForRenderPass)==null?void 0:R[g.currentRenderPassId];let w=h._getDrawWrapper();!w&&O&&(w=O._getDrawWrapper());const M=E.mode===Ze.ORTHOGRAPHIC_CAMERA;if(!w)return;const G=w.effect;g.enableEffect(w),v||d._bind(h,G,_.fillMode),O?O.bindForSubMesh(f.getWorldMatrix(),f,h):(G.setMatrix("viewProjection",p.getTransformMatrix()),G.setMatrix("world",f.getWorldMatrix()),this._storeCameraSpaceZ&&G.setMatrix("view",p.getViewMatrix()));let H,q;if(M?(H=!g.useReverseDepthBuffer&&g.isNDCHalfZRange?0:1,q=g.useReverseDepthBuffer&&g.isNDCHalfZRange?0:1):(H=g.useReverseDepthBuffer&&g.isNDCHalfZRange?E.minZ:g.isNDCHalfZRange?0:E.minZ,q=g.useReverseDepthBuffer&&g.isNDCHalfZRange?0:E.maxZ),G.setFloat2("depthValues",H,H+q),!O){if(_.needAlphaTestingForMesh(f)){const ee=_.getAlphaTestTexture();ee&&(G.setTexture("diffuseSampler",ee),G.setMatrix("diffuseMatrix",ee.getTextureMatrix()))}Yn(d,G),Fs(G,_,p),Ns(d,G),d.morphTargetManager&&d.morphTargetManager.isUsingTextureForTargets&&d.morphTargetManager._bind(G);const X=h.getMesh().bakedVertexAnimationManager;X&&X.isEnabled&&X.bind(G,v),_.pointsCloud&&G.setFloat("pointSize",_.pointSize)}d._processRendering(f,h,G,_.fillMode,T,v,(X,ee)=>G.setMatrix("world",ee))}};this._depthMap.customRenderFunction=(h,d,f,p)=>{let g;if(p.length)for(g=0;g<p.length;g++)c(p.data[g]);for(g=0;g<h.length;g++)c(h.data[g]);for(g=0;g<d.length;g++)c(d.data[g]);if(this.forceDepthWriteTransparentMeshes)for(g=0;g<f.length;g++)c(f.data[g]);else for(g=0;g<f.length;g++)f.data[g].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate=!1}}async _initShaderSourceAsync(e=!1){this._scene.getEngine().isWebGPU&&!e&&!As.ForceGLSL?(this._shaderLanguage=1,await Promise.all([k(()=>Promise.resolve().then(()=>xU),void 0),k(()=>Promise.resolve().then(()=>_U),void 0)])):await Promise.all([k(()=>Promise.resolve().then(()=>dw),void 0),k(()=>Promise.resolve().then(()=>uw),void 0)]),this._shadersLoaded=!0}isReady(e,t){var y;if(!this._shadersLoaded)return!1;const i=this._scene.getEngine(),r=e.getMesh(),s=r.getScene(),n=(y=r._internalAbstractMeshDataInfo._materialForRenderPass)==null?void 0:y[i.currentRenderPassId];if(n)return n.isReadyForSubMesh(r,e,t);const o=e.getMaterial();if(!o||o.disableDepthWrite)return!1;const l=[],u=[N.PositionKind];let c=!1,h=!1;const d=!1;o.needAlphaTestingForMesh(r)&&o.getAlphaTestTexture()&&(l.push("#define ALPHATEST"),r.isVerticesDataPresent(N.UVKind)&&(u.push(N.UVKind),l.push("#define UV1"),c=!0),r.isVerticesDataPresent(N.UV2Kind)&&(u.push(N.UV2Kind),l.push("#define UV2"),h=!0));const f=new Xn;if(r.useBones&&r.computeBonesUsingShaders&&r.skeleton){u.push(N.MatricesIndicesKind),u.push(N.MatricesWeightsKind),r.numBoneInfluencers>4&&(u.push(N.MatricesIndicesExtraKind),u.push(N.MatricesWeightsExtraKind)),l.push("#define NUM_BONE_INFLUENCERS "+r.numBoneInfluencers),r.numBoneInfluencers>0&&f.addCPUSkinningFallback(0,r);const T=r.skeleton;T.isUsingTextureForMatrices?l.push("#define BONETEXTURE"):l.push("#define BonesPerMesh "+(T.bones.length+1))}else l.push("#define NUM_BONE_INFLUENCERS 0");const p=r.morphTargetManager?jn(r.morphTargetManager,l,u,r,!0,!1,!1,c,h,d):0;o.pointsCloud&&l.push("#define POINTSIZE"),t&&(l.push("#define INSTANCES"),qn(u),e.getRenderingMesh().hasThinInstances&&l.push("#define THIN_INSTANCES"));const g=r.bakedVertexAnimationManager;g&&g.isEnabled&&(l.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),t&&u.push("bakedVertexAnimationSettingsInstanced")),this._storeNonLinearDepth&&l.push("#define NONLINEARDEPTH"),this._storeCameraSpaceZ&&l.push("#define STORE_CAMERASPACE_Z"),this.isPacked&&l.push("#define PACKED"),Zn(o,s,l);const _=e._getDrawWrapper(void 0,!0),S=_.defines,b=l.join(`
`);if(S!==b){const T=["world","mBones","boneTextureWidth","pointSize","viewProjection","view","diffuseMatrix","depthValues","morphTargetInfluences","morphTargetCount","morphTargetTextureInfo","morphTargetTextureIndices","bakedVertexAnimationSettings","bakedVertexAnimationTextureSizeInverted","bakedVertexAnimationTime","bakedVertexAnimationTexture"],v=["diffuseSampler","morphTargets","boneSampler","bakedVertexAnimationTexture"];_n(T),_.setEffect(i.createEffect("depth",{attributes:u,uniformsNames:T,uniformBuffersNames:[],samplers:v,defines:b,fallbacks:f,onCompiled:null,onError:null,indexParameters:{maxSimultaneousMorphTargets:p},shaderLanguage:this._shaderLanguage},i),b)}return _.effect.isReady()}getDepthMap(){return this._depthMap}dispose(){const e=[];for(const t in this._scene._depthRenderer)this._scene._depthRenderer[t]===this&&e.push(t);if(e.length>0){this._depthMap.dispose();for(const t of e)delete this._scene._depthRenderer[t]}}}As.ForceGLSL=!1;As._SceneComponentInitialization=a=>{throw Cr("DepthRendererSceneComponent")};const Xx="minmaxReduxPixelShader",fw=`varying vec2 vUV;uniform sampler2D textureSampler;
#if defined(INITIAL)
uniform sampler2D sourceTexture;uniform vec2 texSize;void main(void)
{ivec2 coord=ivec2(vUV*(texSize-1.0));float f1=texelFetch(sourceTexture,coord,0).r;float f2=texelFetch(sourceTexture,coord+ivec2(1,0),0).r;float f3=texelFetch(sourceTexture,coord+ivec2(1,1),0).r;float f4=texelFetch(sourceTexture,coord+ivec2(0,1),0).r;float minz=min(min(min(f1,f2),f3),f4);
#ifdef DEPTH_REDUX
float maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);
#else
float maxz=max(max(max(f1,f2),f3),f4);
#endif
glFragColor=vec4(minz,maxz,0.,0.);}
#elif defined(MAIN)
uniform vec2 texSize;void main(void)
{ivec2 coord=ivec2(vUV*(texSize-1.0));vec2 f1=texelFetch(textureSampler,coord,0).rg;vec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;vec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;vec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);glFragColor=vec4(minz,maxz,0.,0.);}
#elif defined(ONEBEFORELAST)
uniform ivec2 texSize;void main(void)
{ivec2 coord=ivec2(vUV*vec2(texSize-1));vec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;vec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;vec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;vec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;float minz=min(f1.x,f2.x);float maxz=max(f1.y,f2.y);glFragColor=vec4(minz,maxz,0.,0.);}
#elif defined(LAST)
void main(void)
{glFragColor=vec4(0.);if (true) { 
discard;}}
#endif
`;P.ShadersStore[Xx]||(P.ShadersStore[Xx]=fw);class pw{constructor(e){this.onAfterReductionPerformed=new j,this._forceFullscreenViewport=!0,this._activated=!1,this._camera=e,this._postProcessManager=new sM(e.getScene()),this._onContextRestoredObserver=e.getEngine().onContextRestoredObservable.add(()=>{this._postProcessManager._rebuild()})}get sourceTexture(){return this._sourceTexture}setSourceTexture(e,t,i=2,r=!0){if(e===this._sourceTexture)return;this.dispose(!1),this._sourceTexture=e,this._reductionSteps=[],this._forceFullscreenViewport=r;const s=this._camera.getScene(),n=new Ce("Initial reduction phase","minmaxRedux",["texSize"],["sourceTexture"],1,null,1,s.getEngine(),!1,"#define INITIAL"+(t?`
#define DEPTH_REDUX`:""),i,void 0,void 0,void 0,7);n.autoClear=!1,n.forceFullscreenViewport=r;let o=this._sourceTexture.getRenderWidth(),l=this._sourceTexture.getRenderHeight();n.onApply=((c,h)=>d=>{d.setTexture("sourceTexture",this._sourceTexture),d.setFloat2("texSize",c,h)})(o,l),this._reductionSteps.push(n);let u=1;for(;o>1||l>1;){o=Math.max(Math.round(o/2),1),l=Math.max(Math.round(l/2),1);const c=new Ce("Reduction phase "+u,"minmaxRedux",["texSize"],null,{width:o,height:l},null,1,s.getEngine(),!1,"#define "+(o==1&&l==1?"LAST":o==1||l==1?"ONEBEFORELAST":"MAIN"),i,void 0,void 0,void 0,7);if(c.autoClear=!1,c.forceFullscreenViewport=r,c.onApply=((h,d)=>f=>{h==1||d==1?f.setInt2("texSize",h,d):f.setFloat2("texSize",h,d)})(o,l),this._reductionSteps.push(c),u++,o==1&&l==1){const h=(d,f,p)=>{const g=new Float32Array(4*d*f),_={min:0,max:0};return()=>{s.getEngine()._readTexturePixels(p.inputTexture.texture,d,f,-1,0,g,!1),_.min=g[0],_.max=g[1],this.onAfterReductionPerformed.notifyObservers(_)}};c.onAfterRenderObservable.add(h(o,l,c))}}}get refreshRate(){return this._sourceTexture?this._sourceTexture.refreshRate:-1}set refreshRate(e){this._sourceTexture&&(this._sourceTexture.refreshRate=e)}get activated(){return this._activated}activate(){this._onAfterUnbindObserver||!this._sourceTexture||(this._onAfterUnbindObserver=this._sourceTexture.onAfterUnbindObservable.add(()=>{var t,i;const e=this._camera.getScene().getEngine();(t=e._debugPushGroup)==null||t.call(e,"min max reduction",1),this._reductionSteps[0].activate(this._camera),this._postProcessManager.directRender(this._reductionSteps,this._reductionSteps[0].inputTexture,this._forceFullscreenViewport),e.unBindFramebuffer(this._reductionSteps[0].inputTexture,!1),(i=e._debugPopGroup)==null||i.call(e,1)}),this._activated=!0)}deactivate(){!this._onAfterUnbindObserver||!this._sourceTexture||(this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver),this._onAfterUnbindObserver=null,this._activated=!1)}dispose(e=!0){if(e&&(this.onAfterReductionPerformed.clear(),this._onContextRestoredObserver&&(this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null)),this.deactivate(),this._reductionSteps){for(let t=0;t<this._reductionSteps.length;++t)this._reductionSteps[t].dispose();this._reductionSteps=null}this._postProcessManager&&e&&this._postProcessManager.dispose(),this._sourceTexture=null}}class mw extends pw{get depthRenderer(){return this._depthRenderer}constructor(e){super(e)}setDepthRenderer(e=null,t=2,i=!0){const r=this._camera.getScene();this._depthRenderer&&(delete r._depthRenderer[this._depthRendererId],this._depthRenderer.dispose(),this._depthRenderer=null),e===null&&(r._depthRenderer||(r._depthRenderer={}),e=this._depthRenderer=new As(r,t,this._camera,!1,1),e.enabled=!1,this._depthRendererId="minmax"+this._camera.id,r._depthRenderer[this._depthRendererId]=e),super.setSourceTexture(e.getDepthMap(),!0,t,i)}setSourceTexture(e,t,i=2,r=!0){super.setSourceTexture(e,t,i,r)}activate(){this._depthRenderer&&(this._depthRenderer.enabled=!0),super.activate()}deactivate(){super.deactivate(),this._depthRenderer&&(this._depthRenderer.enabled=!1)}dispose(e=!0){if(super.dispose(e),this._depthRenderer&&e){const t=this._depthRenderer.getDepthMap().getScene();t&&delete t._depthRenderer[this._depthRendererId],this._depthRenderer.dispose(),this._depthRenderer=null}}}const Zx=m.Up(),_w=m.Zero(),Lt=new m,fa=new m,Al=new $;class Vt extends de{_validateFilter(e){return e===de.FILTER_NONE||e===de.FILTER_PCF||e===de.FILTER_PCSS?e:(L.Error('Unsupported filter "'+e+'"!'),de.FILTER_NONE)}get numCascades(){return this._numCascades}set numCascades(e){e=Math.min(Math.max(e,Vt.MIN_CASCADES_COUNT),Vt.MAX_CASCADES_COUNT),e!==this._numCascades&&(this._numCascades=e,this.recreateShadowMap(),this._recreateSceneUBOs())}get freezeShadowCastersBoundingInfo(){return this._freezeShadowCastersBoundingInfo}set freezeShadowCastersBoundingInfo(e){this._freezeShadowCastersBoundingInfoObservable&&e&&(this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable),this._freezeShadowCastersBoundingInfoObservable=null),!this._freezeShadowCastersBoundingInfoObservable&&!e&&(this._freezeShadowCastersBoundingInfoObservable=this._scene.onBeforeRenderObservable.add(()=>this._computeShadowCastersBoundingInfo())),this._freezeShadowCastersBoundingInfo=e,e&&this._computeShadowCastersBoundingInfo()}_computeShadowCastersBoundingInfo(){if(this._scbiMin.copyFromFloats(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._scbiMax.copyFromFloats(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this._shadowMap&&this._shadowMap.renderList){const e=this._shadowMap.renderList;for(let t=0;t<e.length;t++){const i=e[t];if(!i)continue;const r=i.getBoundingInfo(),s=r.boundingBox;this._scbiMin.minimizeInPlace(s.minimumWorld),this._scbiMax.maximizeInPlace(s.maximumWorld)}}this._shadowCastersBoundingInfo.reConstruct(this._scbiMin,this._scbiMax)}get shadowCastersBoundingInfo(){return this._shadowCastersBoundingInfo}set shadowCastersBoundingInfo(e){this._shadowCastersBoundingInfo=e}setMinMaxDistance(e,t){this._minDistance===e&&this._maxDistance===t||(e>t&&(e=0,t=1),e<0&&(e=0),t>1&&(t=1),this._minDistance=e,this._maxDistance=t,this._breaksAreDirty=!0)}get minDistance(){return this._minDistance}get maxDistance(){return this._maxDistance}getClassName(){return Vt.CLASSNAME}getCascadeMinExtents(e){return e>=0&&e<this._numCascades?this._cascadeMinExtents[e]:null}getCascadeMaxExtents(e){return e>=0&&e<this._numCascades?this._cascadeMaxExtents[e]:null}get shadowMaxZ(){return this._getCamera()?this._shadowMaxZ:0}set shadowMaxZ(e){const t=this._getCamera();if(!t){this._shadowMaxZ=e;return}this._shadowMaxZ===e||e<t.minZ||e>t.maxZ&&t.maxZ!==0||(this._shadowMaxZ=e,this._light._markMeshesAsLightDirty(),this._breaksAreDirty=!0)}get debug(){return this._debug}set debug(e){this._debug=e,this._light._markMeshesAsLightDirty()}get depthClamp(){return this._depthClamp}set depthClamp(e){this._depthClamp=e}get cascadeBlendPercentage(){return this._cascadeBlendPercentage}set cascadeBlendPercentage(e){this._cascadeBlendPercentage=e,this._light._markMeshesAsLightDirty()}get lambda(){return this._lambda}set lambda(e){const t=Math.min(Math.max(e,0),1);this._lambda!=t&&(this._lambda=t,this._breaksAreDirty=!0)}getCascadeViewMatrix(e){return e>=0&&e<this._numCascades?this._viewMatrices[e]:null}getCascadeProjectionMatrix(e){return e>=0&&e<this._numCascades?this._projectionMatrices[e]:null}getCascadeTransformMatrix(e){return e>=0&&e<this._numCascades?this._transformMatrices[e]:null}setDepthRenderer(e){this._depthRenderer=e,this._depthReducer&&this._depthReducer.setDepthRenderer(this._depthRenderer)}get autoCalcDepthBounds(){return this._autoCalcDepthBounds}set autoCalcDepthBounds(e){const t=this._getCamera();if(t){if(this._autoCalcDepthBounds=e,!e){this._depthReducer&&this._depthReducer.deactivate(),this.setMinMaxDistance(0,1);return}this._depthReducer||(this._depthReducer=new mw(t),this._depthReducer.onAfterReductionPerformed.add(i=>{let r=i.min,s=i.max;r>=s&&(r=0,s=1),(r!=this._minDistance||s!=this._maxDistance)&&this.setMinMaxDistance(r,s)}),this._depthReducer.setDepthRenderer(this._depthRenderer)),this._depthReducer.activate()}}get autoCalcDepthBoundsRefreshRate(){var e,t;return((t=(e=this._depthReducer)==null?void 0:e.depthRenderer)==null?void 0:t.getDepthMap().refreshRate)??-1}set autoCalcDepthBoundsRefreshRate(e){var t;(t=this._depthReducer)!=null&&t.depthRenderer&&(this._depthReducer.depthRenderer.getDepthMap().refreshRate=e)}splitFrustum(){this._breaksAreDirty=!0}_splitFrustum(){const e=this._getCamera();if(!e)return;const t=e.minZ,i=e.maxZ||this._shadowMaxZ,r=i-t,s=this._minDistance,n=this._shadowMaxZ<i&&this._shadowMaxZ>=t?Math.min((this._shadowMaxZ-t)/(i-t),this._maxDistance):this._maxDistance,o=t+s*r,l=t+n*r,u=l-o,c=l/o;for(let h=0;h<this._cascades.length;++h){const d=(h+1)/this._numCascades,f=o*c**d,p=o+u*d,g=this._lambda*(f-p)+p;this._cascades[h].prevBreakDistance=h===0?s:this._cascades[h-1].breakDistance,this._cascades[h].breakDistance=(g-t)/r,this._viewSpaceFrustumsZ[h]=g,this._frustumLengths[h]=(this._cascades[h].breakDistance-this._cascades[h].prevBreakDistance)*r}this._breaksAreDirty=!1}_computeMatrices(){const e=this._scene;if(!this._getCamera())return;m.NormalizeToRef(this._light.getShadowDirection(0),this._lightDirection),Math.abs(m.Dot(this._lightDirection,m.Up()))===1&&(this._lightDirection.z=1e-13),this._cachedDirection.copyFrom(this._lightDirection);const i=e.getEngine().useReverseDepthBuffer;for(let r=0;r<this._numCascades;++r){this._computeFrustumInWorldSpace(r),this._computeCascadeFrustum(r),this._cascadeMaxExtents[r].subtractToRef(this._cascadeMinExtents[r],Lt),this._frustumCenter[r].addToRef(this._lightDirection.scale(this._cascadeMinExtents[r].z),this._shadowCameraPos[r]),$.LookAtLHToRef(this._shadowCameraPos[r],this._frustumCenter[r],Zx,this._viewMatrices[r]);let s=0,n=Lt.z;const o=this._shadowCastersBoundingInfo;o.update(this._viewMatrices[r]);const l=o.boundingBox.minimumWorld.z,u=o.boundingBox.maximumWorld.z;l>n||(!this._depthClamp||this.filter===de.FILTER_PCSS?(s=Math.min(s,l),this.filter!==de.FILTER_PCSS&&(n=Math.min(n,u))):(n=Math.min(n,u),s=Math.max(s,l),n=Math.max(s+1,n))),$.OrthoOffCenterLHToRef(this._cascadeMinExtents[r].x,this._cascadeMaxExtents[r].x,this._cascadeMinExtents[r].y,this._cascadeMaxExtents[r].y,i?n:s,i?s:n,this._projectionMatrices[r],e.getEngine().isNDCHalfZRange),this._cascadeMinExtents[r].z=s,this._cascadeMaxExtents[r].z=n,this._viewMatrices[r].multiplyToRef(this._projectionMatrices[r],this._transformMatrices[r]),m.TransformCoordinatesToRef(_w,this._transformMatrices[r],Lt),Lt.scaleInPlace(this._mapSize/2),fa.copyFromFloats(Math.round(Lt.x),Math.round(Lt.y),Math.round(Lt.z)),fa.subtractInPlace(Lt).scaleInPlace(2/this._mapSize),$.TranslationToRef(fa.x,fa.y,0,Al),this._projectionMatrices[r].multiplyToRef(Al,this._projectionMatrices[r]),this._viewMatrices[r].multiplyToRef(this._projectionMatrices[r],this._transformMatrices[r]),this._transformMatrices[r].copyToArray(this._transformMatricesAsArray,r*16)}}_computeFrustumInWorldSpace(e){const t=this._getCamera();if(!t)return;const i=this._cascades[e].prevBreakDistance,r=this._cascades[e].breakDistance,s=this._scene.getEngine().isNDCHalfZRange;t.getViewMatrix();const n=t.maxZ===0,o=t.maxZ;n&&(t.maxZ=this._shadowMaxZ,t.getProjectionMatrix(!0));const l=$.Invert(t.getTransformationMatrix());n&&(t.maxZ=o,t.getProjectionMatrix(!0));const u=this._scene.getEngine().useReverseDepthBuffer?4:0;for(let c=0;c<Vt._FrustumCornersNDCSpace.length;++c)Lt.copyFrom(Vt._FrustumCornersNDCSpace[(c+u)%Vt._FrustumCornersNDCSpace.length]),s&&Lt.z===-1&&(Lt.z=0),m.TransformCoordinatesToRef(Lt,l,this._frustumCornersWorldSpace[e][c]);for(let c=0;c<Vt._FrustumCornersNDCSpace.length/2;++c)Lt.copyFrom(this._frustumCornersWorldSpace[e][c+4]).subtractInPlace(this._frustumCornersWorldSpace[e][c]),fa.copyFrom(Lt).scaleInPlace(i),Lt.scaleInPlace(r),Lt.addInPlace(this._frustumCornersWorldSpace[e][c]),this._frustumCornersWorldSpace[e][c+4].copyFrom(Lt),this._frustumCornersWorldSpace[e][c].addInPlace(fa)}_computeCascadeFrustum(e){if(this._cascadeMinExtents[e].copyFromFloats(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cascadeMaxExtents[e].copyFromFloats(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this._frustumCenter[e].copyFromFloats(0,0,0),!!this._getCamera()){for(let i=0;i<this._frustumCornersWorldSpace[e].length;++i)this._frustumCenter[e].addInPlace(this._frustumCornersWorldSpace[e][i]);if(this._frustumCenter[e].scaleInPlace(1/this._frustumCornersWorldSpace[e].length),this.stabilizeCascades){let i=0;for(let r=0;r<this._frustumCornersWorldSpace[e].length;++r){const s=this._frustumCornersWorldSpace[e][r].subtractToRef(this._frustumCenter[e],Lt).length();i=Math.max(i,s)}i=Math.ceil(i*16)/16,this._cascadeMaxExtents[e].copyFromFloats(i,i,i),this._cascadeMinExtents[e].copyFromFloats(-i,-i,-i)}else{const i=this._frustumCenter[e];this._frustumCenter[e].addToRef(this._lightDirection,Lt),$.LookAtLHToRef(i,Lt,Zx,Al);for(let r=0;r<this._frustumCornersWorldSpace[e].length;++r)m.TransformCoordinatesToRef(this._frustumCornersWorldSpace[e][r],Al,Lt),this._cascadeMinExtents[e].minimizeInPlace(Lt),this._cascadeMaxExtents[e].maximizeInPlace(Lt)}}}_recreateSceneUBOs(){if(this._disposeSceneUBOs(),this._sceneUBOs)for(let e=0;e<this._numCascades;++e)this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light "${this._light.name}" cascade #${e})`))}static get IsSupported(){const e=ze.LastCreatedEngine;return e?e._features.supportCSM:!1}constructor(e,t,i,r,s=!0){if(!Vt.IsSupported){L.Error("CascadedShadowMap is not supported by the current engine.");return}super(e,t,i,r,s),this.usePercentageCloserFiltering=!0}_initializeGenerator(){var e;this.penumbraDarkness=this.penumbraDarkness??1,this._numCascades=this._numCascades??Vt.DEFAULT_CASCADES_COUNT,this.stabilizeCascades=this.stabilizeCascades??!1,this._freezeShadowCastersBoundingInfoObservable=this._freezeShadowCastersBoundingInfoObservable??null,this.freezeShadowCastersBoundingInfo=this.freezeShadowCastersBoundingInfo??!1,this._scbiMin=this._scbiMin??new m(0,0,0),this._scbiMax=this._scbiMax??new m(0,0,0),this._shadowCastersBoundingInfo=this._shadowCastersBoundingInfo??new nM(new m(0,0,0),new m(0,0,0)),this._breaksAreDirty=this._breaksAreDirty??!0,this._minDistance=this._minDistance??0,this._maxDistance=this._maxDistance??1,this._currentLayer=this._currentLayer??0,this._shadowMaxZ=this._shadowMaxZ??((e=this._getCamera())==null?void 0:e.maxZ)??1e4,this._debug=this._debug??!1,this._depthClamp=this._depthClamp??!0,this._cascadeBlendPercentage=this._cascadeBlendPercentage??.1,this._lambda=this._lambda??.5,this._autoCalcDepthBounds=this._autoCalcDepthBounds??!1,this._recreateSceneUBOs(),super._initializeGenerator()}_createTargetRenderTexture(){const e=this._scene.getEngine(),t={width:this._mapSize,height:this._mapSize,layers:this.numCascades};this._shadowMap=new Kt(this._light.name+"_CSMShadowMap",t,this._scene,!1,!0,this._textureType,!1,void 0,!1,!1,void 0,this._useRedTextureType?6:5),this._shadowMap.createDepthStencilTexture(e.useReverseDepthBuffer?516:513,!0,void 0,void 0,void 0,`DepthStencilForCSMShadowGenerator-${this._light.name}`),this._shadowMap.noPrePassRenderer=!0}_initializeShadowMap(){if(super._initializeShadowMap(),this._shadowMap===null)return;this._transformMatricesAsArray=new Float32Array(this._numCascades*16),this._viewSpaceFrustumsZ=new Array(this._numCascades),this._frustumLengths=new Array(this._numCascades),this._lightSizeUVCorrection=new Array(this._numCascades*2),this._depthCorrection=new Array(this._numCascades),this._cascades=[],this._viewMatrices=[],this._projectionMatrices=[],this._transformMatrices=[],this._cascadeMinExtents=[],this._cascadeMaxExtents=[],this._frustumCenter=[],this._shadowCameraPos=[],this._frustumCornersWorldSpace=[];for(let t=0;t<this._numCascades;++t){this._cascades[t]={prevBreakDistance:0,breakDistance:0},this._viewMatrices[t]=$.Zero(),this._projectionMatrices[t]=$.Zero(),this._transformMatrices[t]=$.Zero(),this._cascadeMinExtents[t]=new m,this._cascadeMaxExtents[t]=new m,this._frustumCenter[t]=new m,this._shadowCameraPos[t]=new m,this._frustumCornersWorldSpace[t]=new Array(Vt._FrustumCornersNDCSpace.length);for(let i=0;i<Vt._FrustumCornersNDCSpace.length;++i)this._frustumCornersWorldSpace[t][i]=new m}const e=this._scene.getEngine();this._shadowMap.onBeforeBindObservable.clear(),this._shadowMap.onBeforeRenderObservable.clear(),this._shadowMap.onBeforeRenderObservable.add(t=>{this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._sceneUBOs[t]),this._currentLayer=t,this._filter===de.FILTER_PCF&&e.setColorWrite(!1),this._scene.setTransformMatrix(this.getCascadeViewMatrix(t),this.getCascadeProjectionMatrix(t)),this._useUBO&&(this._scene.getSceneUniformBuffer().unbindEffect(),this._scene.finalizeSceneUbo())}),this._shadowMap.onBeforeBindObservable.add(()=>{var t;this._currentSceneUBO=this._scene.getSceneUniformBuffer(),(t=e._debugPushGroup)==null||t.call(e,`cascaded shadow map generation for pass id ${e.currentRenderPassId}`,1),this._breaksAreDirty&&this._splitFrustum(),this._computeMatrices()}),this._splitFrustum()}_bindCustomEffectForRenderSubMeshForShadowMap(e,t){t.setMatrix("viewProjection",this.getCascadeTransformMatrix(this._currentLayer))}_isReadyCustomDefines(e){e.push("#define SM_DEPTHCLAMP "+(this._depthClamp&&this._filter!==de.FILTER_PCSS?"1":"0"))}prepareDefines(e,t){super.prepareDefines(e,t);const i=this._scene,r=this._light;if(!i.shadowsEnabled||!r.shadowEnabled)return;e["SHADOWCSM"+t]=!0,e["SHADOWCSMDEBUG"+t]=this.debug,e["SHADOWCSMNUM_CASCADES"+t]=this.numCascades,e["SHADOWCSM_RIGHTHANDED"+t]=i.useRightHandedSystem;const s=this._getCamera();s&&this._shadowMaxZ<=(s.maxZ||this._shadowMaxZ)&&(e["SHADOWCSMUSESHADOWMAXZ"+t]=!0),this.cascadeBlendPercentage===0&&(e["SHADOWCSMNOBLEND"+t]=!0)}bindShadowLight(e,t){const i=this._light;if(!this._scene.shadowsEnabled||!i.shadowEnabled)return;const s=this._getCamera();if(!s)return;const n=this.getShadowMap();if(!n)return;const o=n.getSize().width;if(t.setMatrices("lightMatrix"+e,this._transformMatricesAsArray),t.setArray("viewFrustumZ"+e,this._viewSpaceFrustumsZ),t.setFloat("cascadeBlendFactor"+e,this.cascadeBlendPercentage===0?1e4:1/this.cascadeBlendPercentage),t.setArray("frustumLengths"+e,this._frustumLengths),this._filter===de.FILTER_PCF)t.setDepthStencilTexture("shadowTexture"+e,n),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),o,1/o,this.frustumEdgeFalloff,e);else if(this._filter===de.FILTER_PCSS){for(let l=0;l<this._numCascades;++l)this._lightSizeUVCorrection[l*2+0]=l===0?1:(this._cascadeMaxExtents[0].x-this._cascadeMinExtents[0].x)/(this._cascadeMaxExtents[l].x-this._cascadeMinExtents[l].x),this._lightSizeUVCorrection[l*2+1]=l===0?1:(this._cascadeMaxExtents[0].y-this._cascadeMinExtents[0].y)/(this._cascadeMaxExtents[l].y-this._cascadeMinExtents[l].y),this._depthCorrection[l]=l===0?1:(this._cascadeMaxExtents[l].z-this._cascadeMinExtents[l].z)/(this._cascadeMaxExtents[0].z-this._cascadeMinExtents[0].z);t.setDepthStencilTexture("shadowTexture"+e,n),t.setTexture("depthTexture"+e,n),t.setArray2("lightSizeUVCorrection"+e,this._lightSizeUVCorrection),t.setArray("depthCorrection"+e,this._depthCorrection),t.setFloat("penumbraDarkness"+e,this.penumbraDarkness),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),1/o,this._contactHardeningLightSizeUVRatio*o,this.frustumEdgeFalloff,e)}else t.setTexture("shadowTexture"+e,n),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),o,1/o,this.frustumEdgeFalloff,e);i._uniformBuffer.updateFloat2("depthValues",this.getLight().getDepthMinZ(s),this.getLight().getDepthMinZ(s)+this.getLight().getDepthMaxZ(s),e)}getTransformMatrix(){return this.getCascadeTransformMatrix(0)}dispose(){super.dispose(),this._freezeShadowCastersBoundingInfoObservable&&(this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable),this._freezeShadowCastersBoundingInfoObservable=null),this._depthReducer&&(this._depthReducer.dispose(),this._depthReducer=null)}serialize(){const e=super.serialize(),t=this.getShadowMap();if(!t)return e;if(e.numCascades=this._numCascades,e.debug=this._debug,e.stabilizeCascades=this.stabilizeCascades,e.lambda=this._lambda,e.cascadeBlendPercentage=this.cascadeBlendPercentage,e.depthClamp=this._depthClamp,e.autoCalcDepthBounds=this.autoCalcDepthBounds,e.shadowMaxZ=this._shadowMaxZ,e.penumbraDarkness=this.penumbraDarkness,e.freezeShadowCastersBoundingInfo=this._freezeShadowCastersBoundingInfo,e.minDistance=this.minDistance,e.maxDistance=this.maxDistance,e.renderList=[],t.renderList)for(let i=0;i<t.renderList.length;i++){const r=t.renderList[i];e.renderList.push(r.id)}return e}static Parse(e,t){const i=de.Parse(e,t,(r,s,n)=>new Vt(r,s,void 0,n));return e.numCascades!==void 0&&(i.numCascades=e.numCascades),e.debug!==void 0&&(i.debug=e.debug),e.stabilizeCascades!==void 0&&(i.stabilizeCascades=e.stabilizeCascades),e.lambda!==void 0&&(i.lambda=e.lambda),e.cascadeBlendPercentage!==void 0&&(i.cascadeBlendPercentage=e.cascadeBlendPercentage),e.depthClamp!==void 0&&(i.depthClamp=e.depthClamp),e.autoCalcDepthBounds!==void 0&&(i.autoCalcDepthBounds=e.autoCalcDepthBounds),e.shadowMaxZ!==void 0&&(i.shadowMaxZ=e.shadowMaxZ),e.penumbraDarkness!==void 0&&(i.penumbraDarkness=e.penumbraDarkness),e.freezeShadowCastersBoundingInfo!==void 0&&(i.freezeShadowCastersBoundingInfo=e.freezeShadowCastersBoundingInfo),e.minDistance!==void 0&&e.maxDistance!==void 0&&i.setMinMaxDistance(e.minDistance,e.maxDistance),i}}Vt._FrustumCornersNDCSpace=[new m(-1,1,-1),new m(1,1,-1),new m(1,-1,-1),new m(-1,-1,-1),new m(-1,1,1),new m(1,1,1),new m(1,-1,1),new m(-1,-1,1)];Vt.CLASSNAME="CascadedShadowGenerator";Vt.DEFAULT_CASCADES_COUNT=4;Vt.MIN_CASCADES_COUNT=2;Vt.MAX_CASCADES_COUNT=4;Vt._SceneComponentInitialization=a=>{throw Cr("ShadowGeneratorSceneComponent")};class w0 extends zi{get light(){return this._light}set light(e){e!==this._light&&(this._light=e,this._setupShadowGenerator())}get camera(){return this._camera}set camera(e){this._camera=e,this._setupShadowGenerator()}get mapSize(){return this._mapSize}set mapSize(e){e!==this._mapSize&&(this._mapSize=e,this._setupShadowGenerator())}get useFloat32TextureType(){return this._useFloat32TextureType}set useFloat32TextureType(e){e!==this._useFloat32TextureType&&(this._useFloat32TextureType=e,this._setupShadowGenerator())}get useRedTextureFormat(){return this._useRedTextureFormat}set useRedTextureFormat(e){e!==this._useRedTextureFormat&&(this._useRedTextureFormat=e,this._setupShadowGenerator())}get bias(){return this._bias}set bias(e){e!==this._bias&&(this._bias=e,this._shadowGenerator&&(this._shadowGenerator.bias=e))}get normalBias(){return this._normalBias}set normalBias(e){e!==this._normalBias&&(this._normalBias=e,this._shadowGenerator&&(this._shadowGenerator.normalBias=e))}get darkness(){return this._darkness}set darkness(e){e!==this._darkness&&(this._darkness=e,this._shadowGenerator&&(this._shadowGenerator.darkness=e))}get transparencyShadow(){return this._transparencyShadow}set transparencyShadow(e){e!==this._transparencyShadow&&(this._transparencyShadow=e,this._shadowGenerator&&(this._shadowGenerator.transparencyShadow=e))}get enableSoftTransparentShadow(){return this._enableSoftTransparentShadow}set enableSoftTransparentShadow(e){e!==this._enableSoftTransparentShadow&&(this._enableSoftTransparentShadow=e,this._shadowGenerator&&(this._shadowGenerator.enableSoftTransparentShadow=e))}get useOpacityTextureForTransparentShadow(){return this._useOpacityTextureForTransparentShadow}set useOpacityTextureForTransparentShadow(e){e!==this._useOpacityTextureForTransparentShadow&&(this._useOpacityTextureForTransparentShadow=e,this._shadowGenerator&&(this._shadowGenerator.useOpacityTextureForTransparentShadow=e))}get filter(){return this._filter}set filter(e){e!==this._filter&&(this._filter=e,this._shadowGenerator&&(this._shadowGenerator.filter=e))}get filteringQuality(){return this._filteringQuality}set filteringQuality(e){e!==this._filteringQuality&&(this._filteringQuality=e,this._shadowGenerator&&(this._shadowGenerator.filteringQuality=e))}_createShadowGenerator(){this._shadowGenerator=new de(this._mapSize,this._light,this._useFloat32TextureType,void 0,this._useRedTextureFormat)}_setupShadowGenerator(){var e;if((e=this._shadowGenerator)==null||e.dispose(),this._shadowGenerator=void 0,this._light!==void 0){this._createShadowGenerator();const t=this._shadowGenerator;if(t===void 0)return;t.bias=this._bias,t.normalBias=this._normalBias,t.darkness=this._darkness,t.transparencyShadow=this._transparencyShadow,t.enableSoftTransparentShadow=this._enableSoftTransparentShadow,t.useOpacityTextureForTransparentShadow=this._useOpacityTextureForTransparentShadow,t.filter=this._filter,t.filteringQuality=this._filteringQuality;const i=t.getShadowMap();i._disableEngineStages=!0,i.cameraForLOD=this._camera,this.shadowGenerator=t}}isReady(){var e;return!!this._shadowGenerator&&!!((e=this._shadowGenerator.getShadowMap())!=null&&e.isReadyForRendering())}constructor(e,t,i){super(e,t),this._mapSize=1024,this._useFloat32TextureType=!1,this._useRedTextureFormat=!0,this._bias=.01,this._normalBias=0,this._darkness=0,this._transparencyShadow=!1,this._enableSoftTransparentShadow=!1,this._useOpacityTextureForTransparentShadow=!1,this._filter=de.FILTER_PCF,this._filteringQuality=de.QUALITY_HIGH,this._engine=i.getEngine(),this._scene=i,this.outputTexture=this._frameGraph.textureManager.createDanglingHandle()}record(){if(this.light===void 0||this.objectList===void 0||this.camera===void 0)throw new Error(`FrameGraphShadowGeneratorTask ${this.name}: light, objectList and camera are required`);const e=this._shadowGenerator.getShadowMap();e.renderList=this.objectList.meshes,e.particleSystemList=this.objectList.particleSystems;const t=this._frameGraph.textureManager.importTexture(`${this.name} shadowmap`,this._shadowGenerator.getShadowMap().getInternalTexture());this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture,t),this._frameGraph.addPass(this.name).setExecuteFunc(s=>{if(!this.light.isEnabled()||!this.light.shadowEnabled)return;const n=this._shadowGenerator.getShadowMap();n.renderList=this.objectList.meshes,n.particleSystemList=this.objectList.particleSystems;const o=this._engine._currentRenderTarget;this._scene.incrementRenderId(),this._scene.resetCachedMaterial(),n.render(),this._engine._currentRenderTarget!==o&&(o?this._engine.bindFramebuffer(o):this._engine.restoreDefaultFramebuffer())}),this._frameGraph.addPass(this.name+"_disabled",!0).setExecuteFunc(s=>{})}dispose(){var e;(e=this._shadowGenerator)==null||e.dispose(),this._shadowGenerator=void 0}}class N0 extends w0{constructor(){super(...arguments),this._numCascades=Vt.DEFAULT_CASCADES_COUNT,this._debug=!1,this._stabilizeCascades=!1,this._lambda=.5,this._cascadeBlendPercentage=.1,this._depthClamp=!0,this._autoCalcDepthBounds=!1,this._shadowMaxZ=1e4}static IsCascadedShadowGenerator(e){return e.numCascades!==void 0}get numCascades(){return this._numCascades}set numCascades(e){e!==this._numCascades&&(this._numCascades=e,this._setupShadowGenerator())}get debug(){return this._debug}set debug(e){e!==this._debug&&(this._debug=e,this._shadowGenerator&&(this._shadowGenerator.debug=e))}get stabilizeCascades(){return this._stabilizeCascades}set stabilizeCascades(e){e!==this._stabilizeCascades&&(this._stabilizeCascades=e,this._shadowGenerator&&(this._shadowGenerator.stabilizeCascades=e))}get lambda(){return this._lambda}set lambda(e){e!==this._lambda&&(this._lambda=e,this._shadowGenerator&&(this._shadowGenerator.lambda=e))}get cascadeBlendPercentage(){return this._cascadeBlendPercentage}set cascadeBlendPercentage(e){e!==this._cascadeBlendPercentage&&(this._cascadeBlendPercentage=e,this._shadowGenerator&&(this._shadowGenerator.cascadeBlendPercentage=e))}get depthClamp(){return this._depthClamp}set depthClamp(e){e!==this._depthClamp&&(this._depthClamp=e,this._shadowGenerator&&(this._shadowGenerator.depthClamp=e))}get autoCalcDepthBounds(){return this._autoCalcDepthBounds}set autoCalcDepthBounds(e){e!==this._autoCalcDepthBounds&&(this._autoCalcDepthBounds=e,this._shadowGenerator&&(this._shadowGenerator.autoCalcDepthBounds=e))}get shadowMaxZ(){return this._shadowMaxZ}set shadowMaxZ(e){e!==this._shadowMaxZ&&(this._shadowMaxZ=e,this._shadowGenerator&&(this._shadowGenerator.shadowMaxZ=e))}_createShadowGenerator(){if(!(this.light instanceof Bm))throw new Error(`FrameGraphCascadedShadowGeneratorTask ${this.name}: the CSM shadow generator only supports directional lights.`);this._shadowGenerator=new Vt(this.mapSize,this.light,this.useFloat32TextureType,this.camera,this.useRedTextureFormat),this._shadowGenerator.numCascades=this._numCascades}_setupShadowGenerator(){super._setupShadowGenerator();const e=this._shadowGenerator;e!==void 0&&(e.debug=this._debug,e.stabilizeCascades=this._stabilizeCascades,e.lambda=this._lambda,e.cascadeBlendPercentage=this._cascadeBlendPercentage,e.depthClamp=this._depthClamp,e.autoCalcDepthBounds=this._autoCalcDepthBounds,e.shadowMaxZ=this._shadowMaxZ)}}class Ql extends zi{get camera(){return this._camera}set camera(e){this._camera=e,this._renderer.activeCamera=this.camera}get objectRenderer(){return this._renderer}get name(){return this._name}set name(e){this._name=e,this._renderer&&(this._renderer.name=e)}constructor(e,t,i,r,s){super(e,t),this.shadowGenerators=[],this.depthTest=!0,this.depthWrite=!0,this.disableShadows=!1,this.renderInLinearSpace=!1,this._onBeforeRenderObservable=null,this._onAfterRenderObservable=null,this._externalObjectRenderer=!1,this._scene=i,this._externalObjectRenderer=!!s,this._renderer=s??new Vm(e,i,r),this.name=e,this._externalObjectRenderer||this._renderer.onBeforeRenderingManagerRenderObservable.add(()=>{this._renderer.options.doNotChangeAspectRatio||i.updateTransformMatrix(!0)}),this.outputTexture=this._frameGraph.textureManager.createDanglingHandle(),this.outputDepthTexture=this._frameGraph.textureManager.createDanglingHandle()}isReady(){return this._renderer.isReadyForRendering(this._textureWidth,this._textureHeight)}record(e=!1,t){if(this.targetTexture===void 0||this.objectList===void 0)throw new Error(`FrameGraphObjectRendererTask ${this.name}: targetTexture and objectList are required`);this._renderer.renderList=this.objectList.meshes,this._renderer.particleSystemList=this.objectList.particleSystems,this._renderer.renderInLinearSpace=this.renderInLinearSpace;const i=this._frameGraph.textureManager.getTextureDescription(this.targetTexture);let r=!1;if(this.depthTexture!==void 0){if(this.depthTexture===ar&&this.targetTexture!==Hi)throw new Error(`FrameGraphObjectRendererTask ${this.name}: the back buffer color texture is the only color texture allowed when the depth is the back buffer depth/stencil`);if(this.depthTexture!==ar&&this.targetTexture===Hi)throw new Error(`FrameGraphObjectRendererTask ${this.name}: the back buffer depth/stencil texture is the only depth texture allowed when the target is the back buffer color`);if(this._frameGraph.textureManager.getTextureDescription(this.depthTexture).options.samples!==i.options.samples)throw new Error(`FrameGraphObjectRendererTask ${this.name}: the depth texture and the output texture must have the same number of samples`);r=!0}this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture,this.targetTexture),this.depthTexture!==void 0&&this._frameGraph.textureManager.resolveDanglingHandle(this.outputDepthTexture,this.depthTexture),this._textureWidth=i.size.width,this._textureHeight=i.size.height,this._setLightsForShadow();const s=this._frameGraph.addRenderPass(this.name);if(s.setRenderTarget(this.targetTexture),s.setRenderTargetDepth(this.depthTexture),s.setExecuteFunc(n=>{this._renderer.renderList=this.objectList.meshes,this._renderer.particleSystemList=this.objectList.particleSystems,this._renderer.renderInLinearSpace=this.renderInLinearSpace,n.setDepthStates(this.depthTest&&r,this.depthWrite&&r),n.render(this._renderer,this._textureWidth,this._textureHeight),t==null||t(n)}),!e){const n=this._frameGraph.addRenderPass(this.name+"_disabled",!0);n.setRenderTarget(this.targetTexture),n.setRenderTargetDepth(this.depthTexture),n.setExecuteFunc(o=>{})}return s}dispose(){this._renderer.onBeforeRenderObservable.remove(this._onBeforeRenderObservable),this._renderer.onAfterRenderObservable.remove(this._onAfterRenderObservable),this._externalObjectRenderer||this._renderer.dispose(),super.dispose()}_setLightsForShadow(){const e=new Set,t=new Map;if(this.shadowGenerators)for(const i of this.shadowGenerators){const r=i.shadowGenerator,s=r.getLight();s.isEnabled()&&s.shadowEnabled&&(e.add(s),N0.IsCascadedShadowGenerator(i)?s._shadowGenerators.set(i.camera,r):s._shadowGenerators.set(null,r))}this._renderer.onBeforeRenderObservable.remove(this._onBeforeRenderObservable),this._onBeforeRenderObservable=this._renderer.onBeforeRenderObservable.add(()=>{for(let i=0;i<this._scene.lights.length;i++){const r=this._scene.lights[i];t.set(r,r.shadowEnabled),r.shadowEnabled=!this.disableShadows&&e.has(r)}}),this._renderer.onAfterRenderObservable.remove(this._onAfterRenderObservable),this._onAfterRenderObservable=this._renderer.onAfterRenderObservable.add(()=>{for(let i=0;i<this._scene.lights.length;i++){const r=this._scene.lights[i];r.shadowEnabled=t.get(r)}})}}class ul extends Dn{constructor(e,t,i,r,s){super(e,t,i),this._blockType=r,this._blockName=s,this.needDualDirectionValidation=!0}checkCompatibilityState(e){return e instanceof ul&&e._blockName===this._blockName?0:1}createCustomInputBlock(){return[new this._blockType(this._blockName),this.name]}}class ms extends pi{get task(){return this._frameGraphTask}constructor(e,t,i){super(e,t,i),this.registerInput("target",J.AutoDetect),this.registerInput("depth",J.AutoDetect,!0),this.registerInput("camera",J.Camera),this.registerInput("objects",J.ObjectList),this._addDependenciesInput(),this.registerInput("shadowGenerators",J.AutoDetect,!0),this.registerOutput("output",J.BasedOnInput),this.registerOutput("outputDepth",J.BasedOnInput),this.registerOutput("objectRenderer",J.Object,new ul("objectRenderer",this,1,ms,"NodeRenderGraphBaseObjectRendererBlock")),this.target.addExcludedConnectionPointFromAllowedTypes(J.TextureAllButBackBufferDepthStencil),this.depth.addExcludedConnectionPointFromAllowedTypes(J.TextureDepthStencilAttachment|J.TextureBackBufferDepthStencilAttachment),this.shadowGenerators.addExcludedConnectionPointFromAllowedTypes(J.ShadowGenerator|J.ResourceContainer),this.output._typeConnectionSource=this.target,this.outputDepth._typeConnectionSource=this.depth}get depthTest(){return this._frameGraphTask.depthTest}set depthTest(e){this._frameGraphTask.depthTest=e}get depthWrite(){return this._frameGraphTask.depthWrite}set depthWrite(e){this._frameGraphTask.depthWrite=e}get disableShadows(){return this._frameGraphTask.disableShadows}set disableShadows(e){this._frameGraphTask.disableShadows=e}get renderInLinearSpace(){return this._frameGraphTask.renderInLinearSpace}set renderInLinearSpace(e){this._frameGraphTask.renderInLinearSpace=e}getClassName(){return"NodeRenderGraphBaseObjectRendererBlock"}get target(){return this._inputs[0]}get depth(){return this._inputs[1]}get camera(){return this._inputs[2]}get objects(){return this._inputs[3]}get dependencies(){return this._inputs[4]}get shadowGenerators(){return this._inputs[5]}get output(){return this._outputs[0]}get outputDepth(){return this._outputs[1]}get objectRenderer(){return this._outputs[2]}_buildBlock(e){var i,r,s,n;super._buildBlock(e),this.output.value=this._frameGraphTask.outputTexture,this.outputDepth.value=this._frameGraphTask.outputDepthTexture,this.objectRenderer.value=this._frameGraphTask,this._frameGraphTask.targetTexture=(i=this.target.connectedPoint)==null?void 0:i.value,this._frameGraphTask.depthTexture=(r=this.depth.connectedPoint)==null?void 0:r.value,this._frameGraphTask.camera=(s=this.camera.connectedPoint)==null?void 0:s.value,this._frameGraphTask.objectList=(n=this.objects.connectedPoint)==null?void 0:n.value,this._frameGraphTask.shadowGenerators=[];const t=this.shadowGenerators.connectedPoint;t&&(t.type===J.ResourceContainer?t.ownerBlock.inputs.forEach(l=>{l.connectedPoint&&l.connectedPoint.value!==void 0&&Dn.IsShadowGenerator(l.connectedPoint.value)&&this._frameGraphTask.shadowGenerators.push(l.connectedPoint.value)}):Dn.IsShadowGenerator(t.value)&&(this._frameGraphTask.shadowGenerators[0]=t.value))}_dumpPropertiesCode(){const e=[];return e.push(`${this._codeVariableName}.depthTest = ${this.depthTest};`),e.push(`${this._codeVariableName}.depthWrite = ${this.depthWrite};`),e.push(`${this._codeVariableName}.disableShadows = ${this.disableShadows};`),e.push(`${this._codeVariableName}.renderInLinearSpace = ${this.renderInLinearSpace};`),super._dumpPropertiesCode()+e.join(`
`)}serialize(){const e=super.serialize();return e.depthTest=this.depthTest,e.depthWrite=this.depthWrite,e.disableShadows=this.disableShadows,e.renderInLinearSpace=this.renderInLinearSpace,e}_deserialize(e){super._deserialize(e),this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.disableShadows=e.disableShadows,this.renderInLinearSpace=!!e.renderInLinearSpace}}C([U("Depth test",0,"PROPERTIES")],ms.prototype,"depthTest",null);C([U("Depth write",0,"PROPERTIES")],ms.prototype,"depthWrite",null);C([U("Disable shadows",0,"PROPERTIES")],ms.prototype,"disableShadows",null);C([U("Render in linear space",0,"PROPERTIES")],ms.prototype,"renderInLinearSpace",null);class A_ extends ms{constructor(e,t,i,r=!0){super(e,t,i),this._additionalConstructionParameters=[r],this._frameGraphTask=new Ql(this.name,t,i,{doNotChangeAspectRatio:r})}get doNotChangeAspectRatio(){return this._frameGraphTask.objectRenderer.options.doNotChangeAspectRatio}set doNotChangeAspectRatio(e){const t=this._frameGraphTask.disabled,i=this.depthTest,r=this.depthWrite,s=this.disableShadows,n=this.renderInLinearSpace;this._frameGraphTask.dispose(),this._frameGraphTask=new Ql(this.name,this._frameGraph,this._scene,{doNotChangeAspectRatio:e}),this._additionalConstructionParameters=[e],this.depthTest=i,this.depthWrite=r,this.disableShadows=s,this.renderInLinearSpace=n,this._frameGraphTask.disabled=t}getClassName(){return"NodeRenderGraphObjectRendererBlock"}}C([U("Do not change aspect ratio",0,"PROPERTIES")],A_.prototype,"doNotChangeAspectRatio",null);B("BABYLON.NodeRenderGraphObjectRendererBlock",A_);class gw{constructor(){this.verbose=!1,this._notConnectedNonOptionalInputs=[]}emitErrors(e=null){let t="";for(const i of this._notConnectedNonOptionalInputs)t+=`input "${i.name}" from block "${i.ownerBlock.name}"[${i.ownerBlock.getClassName()}] is not connected and is not optional.
`;return t?(e&&e.notifyObservers(t),L.Error(`Build of node render graph failed:
`+t),!1):!0}}class ji{_getGlobalNodeRenderGraphEditor(){if(typeof NODERENDERGRAPHEDITOR<"u")return NODERENDERGRAPHEDITOR;if(typeof BABYLON<"u"&&typeof BABYLON.NodeRenderGraphEditor<"u")return BABYLON}get frameGraph(){return this._frameGraph}getScene(){return this._scene}constructor(e,t,i){this._buildId=ji._BuildIdGenerator++,this.BJSNODERENDERGRAPHEDITOR=this._getGlobalNodeRenderGraphEditor(),this.editorData=null,this.attachedBlocks=[],this.onBuildObservable=new j,this.onBuildErrorObservable=new j,this.outputBlock=null,this._resizeObserver=null,this.name=e,this._scene=t,this._engine=t.getEngine(),i={debugTextures:!1,autoConfigure:!1,verbose:!1,rebuildGraphOnEngineResize:!0,autoFillExternalInputs:!0,...i},this._options=i,this._frameGraph=new nw(this._scene,i.debugTextures,this),this._frameGraph.name=e,i.rebuildGraphOnEngineResize&&(this._resizeObserver=this._engine.onResizeObservable.add(()=>{this.build()}))}getClassName(){return"NodeRenderGraph"}getBlockByName(e){let t=null;for(const i of this.attachedBlocks)if(i.name===e)if(!t)t=i;else return ae.Warn("More than one block was found with the name `"+e+"`"),t;return t}getBlockByPredicate(e){for(const t of this.attachedBlocks)if(e(t))return t;return null}getBlocksByPredicate(e){const t=[];for(const i of this.attachedBlocks)e(i)&&t.push(i);return t}getInputBlocks(){const e=[];for(const t of this.attachedBlocks)t.isInput&&e.push(t);return e}edit(e){return new Promise(t=>{if(this.BJSNODERENDERGRAPHEDITOR=this.BJSNODERENDERGRAPHEDITOR||this._getGlobalNodeRenderGraphEditor(),typeof this.BJSNODERENDERGRAPHEDITOR>"u"){const i=e&&e.editorURL?e.editorURL:ji.EditorURL;ae.LoadBabylonScript(i,()=>{this.BJSNODERENDERGRAPHEDITOR=this.BJSNODERENDERGRAPHEDITOR||this._getGlobalNodeRenderGraphEditor(),this._createNodeEditor(e==null?void 0:e.nodeRenderGraphEditorConfig),t()})}else this._createNodeEditor(e==null?void 0:e.nodeRenderGraphEditorConfig),t()})}_createNodeEditor(e){const t={nodeRenderGraph:this,...e};this.BJSNODERENDERGRAPHEDITOR.NodeRenderGraphEditor.Show(t)}build(){if(!this.outputBlock)throw new Error("You must define the outputBlock property before building the node render graph");this._initializeBlock(this.outputBlock),this._frameGraph.clear();const e=new gw;e.buildId=this._buildId,e.verbose=this._options.verbose,this._options.autoFillExternalInputs&&this._autoFillExternalInputs();try{this.outputBlock.build(e),this._frameGraph.build()}finally{this._buildId=ji._BuildIdGenerator++,e.emitErrors(this.onBuildErrorObservable)&&this.onBuildObservable.notifyObservers(this)}}_autoFillExternalInputs(){const e=this.getInputBlocks(),t=[];for(const s of this._scene.lights)s.setShadowProjectionMatrix!==void 0&&t.push(s);let i=0,r=0;for(const s of e)if(s.isExternal&&s.isAnAncestorOfType("NodeRenderGraphOutputBlock")&&!(s.type&J.TextureAllButBackBuffer))if(s.isCamera()){const n=this._scene.cameras[i++]||this._scene.cameras[0];this._scene.cameraToUseForPointers||(this._scene.cameraToUseForPointers=n),s.value=n}else s.isObjectList()?s.value={meshes:this._scene.meshes,particleSystems:this._scene.particleSystems}:s.isShadowLight()&&r<t.length&&(s.value=t[r++],r=r%t.length)}whenReadyAsync(e=16,t=3e4){return this._frameGraph.whenReadyAsync(e,t)}execute(){this._frameGraph.execute()}_initializeBlock(e){e.initialize(),this._options.autoConfigure&&e.autoConfigure(),this.attachedBlocks.indexOf(e)===-1&&this.attachedBlocks.push(e);for(const t of e.inputs){const i=t.connectedPoint;if(i){const r=i.ownerBlock;r!==e&&this._initializeBlock(r)}}}clear(){this.outputBlock=null,this.attachedBlocks.length=0}removeBlock(e){const t=this.attachedBlocks.indexOf(e);t>-1&&this.attachedBlocks.splice(t,1),e===this.outputBlock&&(this.outputBlock=null)}parseSerializedObject(e,t=!1){t||this.clear();const i={};for(const r of e.blocks){const s=oi(r.customType);if(s){const n=r.additionalConstructionParameters,o=n?new s("",this._frameGraph,this._scene,...n):new s("",this._frameGraph,this._scene);o._deserialize(r),i[r.id]=o,this.attachedBlocks.push(o)}}for(const r of this.attachedBlocks)if(r.isTeleportOut){const s=r,n=s._tempEntryPointUniqueId;if(n){const o=i[n];o&&o.attachToEndpoint(s)}}for(let r=0;r<e.blocks.length;r++){const s=e.blocks[r],n=i[s.id];n&&(n.inputs.length&&s.inputs.some(o=>o.targetConnectionName)&&!t||this._restoreConnections(n,e,i))}if(e.outputNodeId&&(this.outputBlock=i[e.outputNodeId]),e.locations||e.editorData&&e.editorData.locations){const r=e.locations||e.editorData.locations;for(const n of r)i[n.blockId]&&(n.blockId=i[n.blockId].uniqueId);t&&this.editorData&&this.editorData.locations&&r.concat(this.editorData.locations),e.locations?this.editorData={locations:r}:(this.editorData=e.editorData,this.editorData.locations=r);const s=[];for(const n in i)s[n]=i[n].uniqueId;this.editorData.map=s}this.comment=e.comment}_restoreConnections(e,t,i){for(const r of e.outputs)for(const s of t.blocks){const n=i[s.id];if(n){for(const o of s.inputs)if(i[o.targetBlockId]===e&&o.targetConnectionName===r.name){const l=n.getInputByName(o.inputName);if(!l||l.isConnected)continue;r.connectTo(l,!0),this._restoreConnections(n,t,i);continue}}}}generateCode(){let e=[];const t=[],i=["const","var","let"];this.outputBlock&&this._gatherBlocks(this.outputBlock,t);const r=JSON.stringify(this._options);let s=`let nodeRenderGraph = new BABYLON.NodeRenderGraph("${this.name||"render graph"}", scene, ${r});
`;for(const n of t)n.isInput&&e.indexOf(n)===-1&&(s+=n._dumpCode(i,e)+`
`);return this.outputBlock&&(e=[],s+=`// Connections
`,s+=this.outputBlock._dumpCodeForOutputConnections(e),s+=`// Output nodes
`,s+=`nodeRenderGraph.outputBlock = ${this.outputBlock._codeVariableName};
`,s+=`nodeRenderGraph.build();
`),s}_gatherBlocks(e,t){if(t.indexOf(e)===-1){t.push(e);for(const i of e.inputs){const r=i.connectedPoint;if(r){const s=r.ownerBlock;s!==e&&this._gatherBlocks(s,t)}}if(e.isTeleportOut){const i=e;i.entryPoint&&this._gatherBlocks(i.entryPoint,t)}}}setToDefault(){this.clear(),this.editorData=null;const e=new ga("Color Texture",this._frameGraph,this._scene,J.Texture);e.creationOptions.options.samples=4;const t=new ga("Depth Texture",this._frameGraph,this._scene,J.TextureDepthStencilAttachment);t.creationOptions.options.samples=4;const i=new Jn("Clear",this._frameGraph,this._scene);i.clearDepth=!0,i.clearStencil=!0,e.output.connectTo(i.target),t.output.connectTo(i.depth);const r=new ga("Camera",this._frameGraph,this._scene,J.Camera),s=new ga("Object List",this._frameGraph,this._scene,J.ObjectList),n=new A_("Main Rendering",this._frameGraph,this._scene);r.output.connectTo(n.camera),s.output.connectTo(n.objects),i.output.connectTo(n.target),i.outputDepth.connectTo(n.depth);const o=new E0("Output",this._frameGraph,this._scene);n.output.connectTo(o.texture),this.outputBlock=o}clone(e){const t=this.serialize(),i=Me.Clone(()=>new ji(e,this._scene),this);return i.name=e,i.parseSerializedObject(t),i._buildId=this._buildId,i.build(),i}serialize(e){const t=e?{}:Me.Serialize(this);t.editorData=JSON.parse(JSON.stringify(this.editorData));let i=[];e?i=e:(t.customType="BABYLON.NodeRenderGraph",this.outputBlock&&(t.outputNodeId=this.outputBlock.uniqueId)),t.blocks=[];for(const r of i)t.blocks.push(r.serialize());if(!e)for(const r of this.attachedBlocks)i.indexOf(r)===-1&&t.blocks.push(r.serialize());return t}dispose(){for(const e of this.attachedBlocks)e.dispose();this._frameGraph.dispose(),this._frameGraph=void 0,this._engine.onResizeObservable.remove(this._resizeObserver),this._resizeObserver=null,this.attachedBlocks.length=0,this.onBuildObservable.clear(),this.onBuildErrorObservable.clear()}static CreateDefault(e,t,i){const r=new ji(e,t,i);return r.setToDefault(),r.build(),r}static Parse(e,t,i,r=!0){const s=Me.Parse(()=>new ji(e.name,t,i),e,null);return s.parseSerializedObject(e),r||s.build(),s}static ParseFromSnippetAsync(e,t,i,r,s=!0){return e==="_BLANK"?Promise.resolve(ji.CreateDefault("blank",t,i)):new Promise((n,o)=>{const l=new ss;l.addEventListener("readystatechange",()=>{if(l.readyState==4)if(l.status==200){const u=JSON.parse(JSON.parse(l.responseText).jsonPayload),c=JSON.parse(u.nodeRenderGraph);r||(r=Me.Parse(()=>new ji(e,t,i),c,null)),r.parseSerializedObject(c),r.snippetId=e;try{s||r.build(),n(r)}catch(h){o(h)}}else o("Unable to load the snippet "+e)}),l.open("GET",this.SnippetUrl+"/"+e.replace(/#/g,"/")),l.send()})}}ji._BuildIdGenerator=0;ji.EditorURL=`${ae._DefaultCdnUrl}/v${mt.Version}/NodeRenderGraph/babylon.nodeRenderGraph.js`;ji.SnippetUrl="https://snippet.babylonjs.com";C([F()],ji.prototype,"name",void 0);C([F("comment")],ji.prototype,"comment",void 0);class xw extends zi{constructor(e,t,i){super(e,t),this._scene=i,this.outputObjectList={meshes:[],particleSystems:[]}}record(){if(this.objectList===void 0||this.camera===void 0)throw new Error(`FrameGraphCullObjectsTask ${this.name}: objectList and camera are required`);const e=this._frameGraph.addCullPass(this.name);e.setObjectList(this.outputObjectList),e.setExecuteFunc(i=>{this.outputObjectList.meshes=[],this.camera._updateFrustumPlanes();const r=this.camera._frustumPlanes,s=this.objectList.meshes||this._scene.meshes;for(let n=0;n<s.length;n++){const o=s[n];o.isBlocked||!o.isReady()||!o.isEnabled()||o.scaling.hasAZeroComponent||o.isVisible&&o.visibility>0&&o.layerMask&this.camera.layerMask&&(this._scene.skipFrustumClipping||o.alwaysSelectAsActiveMesh||o.isInFrustum(r))&&this.outputObjectList.meshes.push(o)}});const t=this._frameGraph.addCullPass(this.name+"_disabled",!0);t.setObjectList(this.outputObjectList),t.setExecuteFunc(i=>{this.outputObjectList.meshes=this.objectList.meshes,this.outputObjectList.particleSystems=this.objectList.particleSystems})}}class Sw extends pi{get task(){return this._frameGraphTask}constructor(e,t,i){super(e,t,i),this.registerInput("camera",J.Camera),this.registerInput("objects",J.ObjectList),this._addDependenciesInput(),this.registerOutput("output",J.ObjectList),this._frameGraphTask=new xw(this.name,t,i)}getClassName(){return"NodeRenderGraphCullObjectsBlock"}get camera(){return this._inputs[0]}get objects(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){var t,i;super._buildBlock(e),this.output.value=this._frameGraphTask.outputObjectList,this._frameGraphTask.camera=(t=this.camera.connectedPoint)==null?void 0:t.value,this._frameGraphTask.objectList=(i=this.objects.connectedPoint)==null?void 0:i.value}_dumpPropertiesCode(){const e=[];return super._dumpPropertiesCode()+e.join(`
`)}serialize(){return super.serialize()}_deserialize(e){super._deserialize(e)}}B("BABYLON.NodeRenderGraphCullObjectsBlock",Sw);class vw extends pi{constructor(e,t,i){super(e,t,i),this.registerInput("input",J.AutoDetect),this.registerOutput("output",J.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0]}getClassName(){return"NodeRenderGraphElbowBlock"}get input(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0],i=this._inputs[0];this._propagateInputValueToOutput(i,t)}}B("BABYLON.NodeRenderGraphElbowBlock",vw);class dh extends zi{constructor(e,t){super(e,t)}record(){if(!this.func)throw new Error("FrameGraphExecuteTask: Execute task must have a function.");const e=this._frameGraph.addPass(this.name);return e.setExecuteFunc(i=>{this.func(i)}),this._frameGraph.addPass(this.name+"_disabled",!0).setExecuteFunc(i=>{var r;(r=this.funcDisabled)==null||r.call(this,i)}),e}}class bw extends pi{get task(){return this._frameGraphTask}constructor(e,t,i){super(e,t,i),this._addDependenciesInput(J.Camera|J.ShadowLight|J.ObjectList),this.registerOutput("output",J.ResourceContainer),this._frameGraphTask=new dh(e,t)}getClassName(){return"NodeRenderGraphExecuteBlock"}get output(){return this._outputs[0]}}B("BABYLON.NodeRenderGraphExecuteBlock",bw);class yw extends pi{constructor(e,t,i){super(e,t,i),this.registerInput("resource0",J.AutoDetect,!0),this.registerInput("resource1",J.AutoDetect,!0),this.registerInput("resource2",J.AutoDetect,!0),this.registerInput("resource3",J.AutoDetect,!0),this.registerInput("resource4",J.AutoDetect,!0),this.registerInput("resource5",J.AutoDetect,!0),this.registerInput("resource6",J.AutoDetect,!0),this.registerInput("resource7",J.AutoDetect,!0),this.registerOutput("output",J.ResourceContainer),this.resource0.addExcludedConnectionPointFromAllowedTypes(J.TextureAllButBackBuffer|J.ShadowGenerator),this.resource1.addExcludedConnectionPointFromAllowedTypes(J.TextureAllButBackBuffer|J.ShadowGenerator),this.resource2.addExcludedConnectionPointFromAllowedTypes(J.TextureAllButBackBuffer|J.ShadowGenerator),this.resource3.addExcludedConnectionPointFromAllowedTypes(J.TextureAllButBackBuffer|J.ShadowGenerator),this.resource4.addExcludedConnectionPointFromAllowedTypes(J.TextureAllButBackBuffer|J.ShadowGenerator),this.resource5.addExcludedConnectionPointFromAllowedTypes(J.TextureAllButBackBuffer|J.ShadowGenerator),this.resource6.addExcludedConnectionPointFromAllowedTypes(J.TextureAllButBackBuffer|J.ShadowGenerator),this.resource7.addExcludedConnectionPointFromAllowedTypes(J.TextureAllButBackBuffer|J.ShadowGenerator)}getClassName(){return"NodeRenderGraphResourceContainerBlock"}get resource0(){return this._inputs[0]}get resource1(){return this._inputs[1]}get resource2(){return this._inputs[2]}get resource3(){return this._inputs[3]}get resource4(){return this._inputs[4]}get resource5(){return this._inputs[5]}get resource6(){return this._inputs[6]}get resource7(){return this._inputs[7]}get output(){return this._outputs[0]}}B("BABYLON.NodeRenderGraphResourceContainerBlock",yw);class kr extends Qt{constructor(e,t=null,i,r,s){super({...s,name:e,engine:t||mt.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:kr.FragmentUrl,uniforms:kr.Uniforms}),this.direction=i,this.kernel=r,this.textureWidth=0,this.textureHeight=0}_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(k(()=>Promise.resolve().then(()=>Zu),void 0))):t.push(k(()=>Promise.resolve().then(()=>Xu),void 0)),super._gatherImports(e,t)}bind(){super.bind(),this._drawWrapper.effect.setFloat2("screenSize",this.textureWidth,this.textureHeight),this._drawWrapper.effect.setVector2("direction",this.direction),this._drawWrapper.effect.setFloat("blurWidth",this.kernel)}}kr.FragmentUrl="glowBlurPostProcess";kr.Uniforms=["screenSize","direction","blurWidth"];class sn{get camera(){return this._options.camera}set camera(e){this._options.camera=e}get renderingGroupId(){return this._options.renderingGroupId}set renderingGroupId(e){this._options.renderingGroupId=e}get objectRenderer(){return this._objectRenderer}get shaderLanguage(){return this._shaderLanguage}setMaterialForRendering(e,t){if(this._objectRenderer.setMaterialForRendering(e,t),Array.isArray(e))for(let i=0;i<e.length;++i){const r=e[i];t?this._materialForRendering[r.uniqueId]=[r,t]:delete this._materialForRendering[r.uniqueId]}else t?this._materialForRendering[e.uniqueId]=[e,t]:delete this._materialForRendering[e.uniqueId]}getEffectIntensity(e){return this._effectIntensity[e.uniqueId]??1}setEffectIntensity(e,t){this._effectIntensity[e.uniqueId]=t}constructor(e,t,i=!1,r=!1,s){this._additionalImportShadersAsync=s,this._vertexBuffers={},this._dontCheckIfReady=!1,this._shouldRender=!0,this._emissiveTextureAndColor={texture:null,color:new xe},this._effectIntensity={},this._postProcesses=[],this.neutralColor=new xe,this.isEnabled=!0,this.disableBoundingBoxesFromEffectLayer=!1,this.onDisposeObservable=new j,this.onBeforeRenderLayerObservable=new j,this.onBeforeComposeObservable=new j,this.onBeforeRenderMeshToEffect=new j,this.onAfterRenderMeshToEffect=new j,this.onAfterComposeObservable=new j,this.onBeforeBlurObservable=new j,this.onAfterBlurObservable=new j,this._shaderLanguage=0,this._materialForRendering={},this._shadersLoaded=!1,this.name=e,this._scene=t||ze.LastCreatedScene,this._dontCheckIfReady=r,this._scene.getEngine().isWebGPU&&!i&&!sn.ForceGLSL&&(this._shaderLanguage=1),this._engine=this._scene.getEngine(),this._mergeDrawWrapper=[],this._generateIndexBuffer(),this._generateVertexBuffer()}getEffectName(){return""}isReady(e,t){return!0}needStencil(){return!1}_createMergeEffect(){throw new Error("Effect Layer: no merge effect defined")}_createTextureAndPostProcesses(){}_internalCompose(e,t){}_setEmissiveTextureAndColor(e,t,i){}_numInternalDraws(){return 1}_init(e){this._options={mainTextureRatio:.5,mainTextureFixedSize:0,mainTextureType:0,alphaBlendingMode:2,camera:null,renderingGroupId:-1,...e},this._createObjectRenderer()}_generateIndexBuffer(){const e=[];e.push(0),e.push(1),e.push(2),e.push(0),e.push(2),e.push(3),this._indexBuffer=this._engine.createIndexBuffer(e)}_generateVertexBuffer(){const e=[];e.push(1,1),e.push(-1,1),e.push(-1,-1),e.push(1,-1);const t=new N(this._engine,e,N.PositionKind,!1,!1,2);this._vertexBuffers[N.PositionKind]=t}_createObjectRenderer(){this._objectRenderer=new Vm(`ObjectRenderer for thin effect layer ${this.name}`,this._scene,{doNotChangeAspectRatio:!0}),this._objectRenderer.activeCamera=this._options.camera,this._objectRenderer.renderParticles=!1,this._objectRenderer.renderList=null;const e=!!this._scene.getBoundingBoxRenderer;let t=!1;e&&(this._objectRenderer.onBeforeRenderObservable.add(()=>{t=this._scene.getBoundingBoxRenderer().enabled,this._scene.getBoundingBoxRenderer().enabled=!this.disableBoundingBoxesFromEffectLayer&&t}),this._objectRenderer.onAfterRenderObservable.add(()=>{this._scene.getBoundingBoxRenderer().enabled=t})),this._objectRenderer.customIsReadyFunction=(i,r,s)=>{if((s||r===0)&&i.subMeshes)for(let n=0;n<i.subMeshes.length;++n){const o=i.subMeshes[n],l=o.getMaterial(),u=o.getRenderingMesh();if(!l)continue;const h=u._getInstancesRenderList(o._id,!!o.getReplacementMesh()).hardwareInstancedRendering[o._id]||u.hasThinInstances;if(this._setEmissiveTextureAndColor(u,o,l),!this._isSubMeshReady(o,h,this._emissiveTextureAndColor.texture))return!1}return!0},this._objectRenderer.customRenderFunction=(i,r,s,n)=>{this.onBeforeRenderLayerObservable.notifyObservers(this);let o;const l=this._scene.getEngine();if(n.length){for(l.setColorWrite(!1),o=0;o<n.length;o++)this._renderSubMesh(n.data[o]);l.setColorWrite(!0)}for(o=0;o<i.length;o++)this._renderSubMesh(i.data[o]);for(o=0;o<r.length;o++)this._renderSubMesh(r.data[o]);const u=l.getAlphaMode();for(o=0;o<s.length;o++){const c=s.data[o],h=c.getMaterial();if(h&&h.needDepthPrePass){const d=h.getScene().getEngine();d.setColorWrite(!1),this._renderSubMesh(c),d.setColorWrite(!0)}this._renderSubMesh(c,!0)}l.setAlphaMode(u)}}_addCustomEffectDefines(e){}_internalIsSubMeshReady(e,t,i){var y;const r=this._scene.getEngine(),s=e.getMesh(),n=(y=s._internalAbstractMeshDataInfo._materialForRenderPass)==null?void 0:y[r.currentRenderPassId];if(n)return n.isReadyForSubMesh(s,e,t);const o=e.getMaterial();if(!o)return!1;if(this._useMeshMaterial(e.getRenderingMesh()))return o.isReadyForSubMesh(e.getMesh(),e,t);const l=[],u=[N.PositionKind];let c=!1,h=!1;const d=!1;if(o){const T=o.needAlphaTestingForMesh(s),v=o.getAlphaTestTexture(),E=v&&v.hasAlpha&&(o.useAlphaFromDiffuseTexture||o._useAlphaFromAlbedoTexture);v&&(T||E)&&(l.push("#define DIFFUSE"),s.isVerticesDataPresent(N.UV2Kind)&&v.coordinatesIndex===1?(l.push("#define DIFFUSEUV2"),h=!0):s.isVerticesDataPresent(N.UVKind)&&(l.push("#define DIFFUSEUV1"),c=!0),T&&(l.push("#define ALPHATEST"),l.push("#define ALPHATESTVALUE 0.4")),v.gammaSpace||l.push("#define DIFFUSE_ISLINEAR"));const R=o.opacityTexture;R&&(l.push("#define OPACITY"),s.isVerticesDataPresent(N.UV2Kind)&&R.coordinatesIndex===1?(l.push("#define OPACITYUV2"),h=!0):s.isVerticesDataPresent(N.UVKind)&&(l.push("#define OPACITYUV1"),c=!0))}i&&(l.push("#define EMISSIVE"),s.isVerticesDataPresent(N.UV2Kind)&&i.coordinatesIndex===1?(l.push("#define EMISSIVEUV2"),h=!0):s.isVerticesDataPresent(N.UVKind)&&(l.push("#define EMISSIVEUV1"),c=!0),i.gammaSpace||l.push("#define EMISSIVE_ISLINEAR")),s.useVertexColors&&s.isVerticesDataPresent(N.ColorKind)&&s.hasVertexAlpha&&o.transparencyMode!==ft.MATERIAL_OPAQUE&&(u.push(N.ColorKind),l.push("#define VERTEXALPHA")),c&&(u.push(N.UVKind),l.push("#define UV1")),h&&(u.push(N.UV2Kind),l.push("#define UV2"));const f=new Xn;if(s.useBones&&s.computeBonesUsingShaders){u.push(N.MatricesIndicesKind),u.push(N.MatricesWeightsKind),s.numBoneInfluencers>4&&(u.push(N.MatricesIndicesExtraKind),u.push(N.MatricesWeightsExtraKind)),l.push("#define NUM_BONE_INFLUENCERS "+s.numBoneInfluencers);const T=s.skeleton;T&&T.isUsingTextureForMatrices?l.push("#define BONETEXTURE"):l.push("#define BonesPerMesh "+(T?T.bones.length+1:0)),s.numBoneInfluencers>0&&f.addCPUSkinningFallback(0,s)}else l.push("#define NUM_BONE_INFLUENCERS 0");const p=s.morphTargetManager?jn(s.morphTargetManager,l,u,s,!0,!1,!1,c,h,d):0;t&&(l.push("#define INSTANCES"),qn(u),e.getRenderingMesh().hasThinInstances&&l.push("#define THIN_INSTANCES")),Zn(o,this._scene,l),this._addCustomEffectDefines(l);const g=e._getDrawWrapper(void 0,!0),_=g.defines,S=l.join(`
`);if(_!==S){const T=["world","mBones","viewProjection","glowColor","morphTargetInfluences","morphTargetCount","boneTextureWidth","diffuseMatrix","emissiveMatrix","opacityMatrix","opacityIntensity","morphTargetTextureInfo","morphTargetTextureIndices","glowIntensity"];_n(T),g.setEffect(this._engine.createEffect("glowMapGeneration",u,T,["diffuseSampler","emissiveSampler","opacitySampler","boneSampler","morphTargets"],S,f,void 0,void 0,{maxSimultaneousMorphTargets:p},this._shaderLanguage,this._shadersLoaded?void 0:async()=>{await this._importShadersAsync(),this._shadersLoaded=!0}),S)}return g.effect.isReady()&&(this._dontCheckIfReady||!this._dontCheckIfReady&&this.isLayerReady())}_isSubMeshReady(e,t,i){return this._internalIsSubMeshReady(e,t,i)}async _importShadersAsync(){var e;this._shaderLanguage===1?await Promise.all([k(()=>Promise.resolve().then(()=>p1),void 0),k(()=>Promise.resolve().then(()=>d1),void 0)]):await Promise.all([k(()=>Promise.resolve().then(()=>c1),void 0),k(()=>Promise.resolve().then(()=>l1),void 0)]),(e=this._additionalImportShadersAsync)==null||e.call(this)}_internalIsLayerReady(){let e=!0;for(let i=0;i<this._postProcesses.length;i++)e=this._postProcesses[i].isReady()&&e;const t=this._numInternalDraws();for(let i=0;i<t;++i){let r=this._mergeDrawWrapper[i];r||(r=this._mergeDrawWrapper[i]=new vi(this._engine),r.setEffect(this._createMergeEffect())),e=r.effect.isReady()&&e}return e}isLayerReady(){return this._internalIsLayerReady()}compose(){if(!this._dontCheckIfReady&&!this.isLayerReady())return!1;const e=this._scene.getEngine(),t=this._numInternalDraws();this.onBeforeComposeObservable.notifyObservers(this);const i=e.getAlphaMode();for(let r=0;r<t;++r){const s=this._mergeDrawWrapper[r];e.enableEffect(s),e.setState(!1),e.bindBuffers(this._vertexBuffers,this._indexBuffer,s.effect),e.setAlphaMode(this._options.alphaBlendingMode),this._internalCompose(s.effect,r)}return e.setAlphaMode(i),this.onAfterComposeObservable.notifyObservers(this),!0}_internalHasMesh(e){return this.renderingGroupId===-1||e.renderingGroupId===this.renderingGroupId}hasMesh(e){return this._internalHasMesh(e)}_internalShouldRender(){return this.isEnabled&&this._shouldRender}shouldRender(){return this._internalShouldRender()}_shouldRenderMesh(e){return!0}_internalCanRenderMesh(e,t){return!t.needAlphaBlendingForMesh(e)}_canRenderMesh(e,t){return this._internalCanRenderMesh(e,t)}_renderSubMesh(e,t=!1){var g;if(!this._internalShouldRender())return;const i=e.getMaterial(),r=e.getMesh(),s=e.getReplacementMesh(),n=e.getRenderingMesh(),o=e.getEffectiveMesh(),l=this._scene,u=l.getEngine();if(o._internalAbstractMeshDataInfo._isActiveIntermediate=!1,!i||!this._canRenderMesh(n,i))return;let c=i._getEffectiveOrientation(n);o._getWorldMatrixDeterminant()<0&&(c=c===ft.ClockWiseSideOrientation?ft.CounterClockWiseSideOrientation:ft.ClockWiseSideOrientation);const d=c===ft.ClockWiseSideOrientation;u.setState(i.backFaceCulling,i.zOffset,void 0,d,i.cullBackFaces,void 0,i.zOffsetUnits);const f=n._getInstancesRenderList(e._id,!!s);if(f.mustReturn||!this._shouldRenderMesh(n))return;const p=f.hardwareInstancedRendering[e._id]||n.hasThinInstances;if(this._setEmissiveTextureAndColor(n,e,i),this.onBeforeRenderMeshToEffect.notifyObservers(r),this._useMeshMaterial(n))e.getMaterial()._glowModeEnabled=!0,n.render(e,t,s||void 0),e.getMaterial()._glowModeEnabled=!1;else if(this._isSubMeshReady(e,p,this._emissiveTextureAndColor.texture)){const _=(g=o._internalAbstractMeshDataInfo._materialForRenderPass)==null?void 0:g[u.currentRenderPassId];let S=e._getDrawWrapper();if(!S&&_&&(S=_._getDrawWrapper()),!S)return;const b=S.effect;if(u.enableEffect(S),p||n._bind(e,b,i.fillMode),_?_.bindForSubMesh(o.getWorldMatrix(),o,e):(b.setMatrix("viewProjection",l.getTransformMatrix()),b.setMatrix("world",o.getWorldMatrix()),b.setFloat4("glowColor",this._emissiveTextureAndColor.color.r,this._emissiveTextureAndColor.color.g,this._emissiveTextureAndColor.color.b,this._emissiveTextureAndColor.color.a)),!_){const y=i.needAlphaTestingForMesh(o),T=i.getAlphaTestTexture(),v=T&&T.hasAlpha&&(i.useAlphaFromDiffuseTexture||i._useAlphaFromAlbedoTexture);if(T&&(y||v)){b.setTexture("diffuseSampler",T);const R=T.getTextureMatrix();R&&b.setMatrix("diffuseMatrix",R)}const E=i.opacityTexture;if(E){b.setTexture("opacitySampler",E),b.setFloat("opacityIntensity",E.level);const R=E.getTextureMatrix();R&&b.setMatrix("opacityMatrix",R)}if(this._emissiveTextureAndColor.texture&&(b.setTexture("emissiveSampler",this._emissiveTextureAndColor.texture),b.setMatrix("emissiveMatrix",this._emissiveTextureAndColor.texture.getTextureMatrix())),n.useBones&&n.computeBonesUsingShaders&&n.skeleton){const R=n.skeleton;if(R.isUsingTextureForMatrices){const O=R.getTransformMatrixTexture(n);if(!O)return;b.setTexture("boneSampler",O),b.setFloat("boneTextureWidth",4*(R.bones.length+1))}else b.setMatrices("mBones",R.getTransformMatrices(n))}Ns(n,b),n.morphTargetManager&&n.morphTargetManager.isUsingTextureForTargets&&n.morphTargetManager._bind(b),t&&u.setAlphaMode(i.alphaMode),b.setFloat("glowIntensity",this.getEffectIntensity(n)),Fs(b,i,l)}n._processRendering(o,e,b,i.fillMode,f,p,(y,T)=>b.setMatrix("world",T))}else this._objectRenderer.resetRefreshCounter();this.onAfterRenderMeshToEffect.notifyObservers(r)}_useMeshMaterial(e){return!1}_rebuild(){const e=this._vertexBuffers[N.PositionKind];e&&e._rebuild(),this._generateIndexBuffer()}dispose(){const e=this._vertexBuffers[N.PositionKind];e&&(e.dispose(),this._vertexBuffers[N.PositionKind]=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null);for(const t of this._mergeDrawWrapper)t.dispose();this._mergeDrawWrapper=[],this._objectRenderer.dispose(),this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this.onBeforeRenderLayerObservable.clear(),this.onBeforeComposeObservable.clear(),this.onBeforeRenderMeshToEffect.clear(),this.onAfterRenderMeshToEffect.clear(),this.onAfterComposeObservable.clear()}}sn.ForceGLSL=!1;class Gn extends sn{get ldrMerge(){return this._options.ldrMerge}set blurKernelSize(e){if(e===this._options.blurKernelSize)return;this._options.blurKernelSize=e;const t=this._getEffectiveBlurKernelSize();this._horizontalBlurPostprocess1.kernel=t,this._verticalBlurPostprocess1.kernel=t,this._horizontalBlurPostprocess2.kernel=t,this._verticalBlurPostprocess2.kernel=t}get blurKernelSize(){return this._options.blurKernelSize}set intensity(e){this._intensity=e}get intensity(){return this._intensity}constructor(e,t,i,r=!1){super(e,t,!1,r),this._intensity=1,this._includedOnlyMeshes=[],this._excludedMeshes=[],this._meshesUsingTheirOwnMaterials=[],this._renderPassId=0,this.neutralColor=new xe(0,0,0,1),this._options={mainTextureRatio:.5,mainTextureFixedSize:0,mainTextureType:0,blurKernelSize:32,camera:null,renderingGroupId:-1,ldrMerge:!1,alphaBlendingMode:1,...i},this._init(this._options),r&&this._createTextureAndPostProcesses()}getClassName(){return"GlowLayer"}async _importShadersAsync(){this._shaderLanguage===1?await Promise.all([k(()=>Promise.resolve().then(()=>nT),void 0),k(()=>Promise.resolve().then(()=>oT),void 0),k(()=>Promise.resolve().then(()=>Zu),void 0)]):await Promise.all([k(()=>Promise.resolve().then(()=>eT),void 0),k(()=>Promise.resolve().then(()=>iT),void 0),k(()=>Promise.resolve().then(()=>Xu),void 0)]),await super._importShadersAsync()}getEffectName(){return Gn.EffectName}_createMergeEffect(){let e=`#define EMISSIVE 
`;return this._options.ldrMerge&&(e+=`#define LDR 
`),this._engine.createEffect("glowMapMerge",[N.PositionKind],["offset"],["textureSampler","textureSampler2"],e,void 0,void 0,void 0,void 0,this.shaderLanguage,this._shadersLoaded?void 0:async()=>{await this._importShadersAsync(),this._shadersLoaded=!0})}_createTextureAndPostProcesses(){const e=this._getEffectiveBlurKernelSize();this._horizontalBlurPostprocess1=new It("GlowLayerHBP1",this._scene.getEngine(),new Q(1,0),e),this._verticalBlurPostprocess1=new It("GlowLayerVBP1",this._scene.getEngine(),new Q(0,1),e),this._horizontalBlurPostprocess2=new It("GlowLayerHBP2",this._scene.getEngine(),new Q(1,0),e),this._verticalBlurPostprocess2=new It("GlowLayerVBP2",this._scene.getEngine(),new Q(0,1),e),this._postProcesses=[this._horizontalBlurPostprocess1,this._verticalBlurPostprocess1,this._horizontalBlurPostprocess2,this._verticalBlurPostprocess2]}_getEffectiveBlurKernelSize(){return this._options.blurKernelSize/2}isReady(e,t){const i=e.getMaterial(),r=e.getRenderingMesh();if(!i||!r)return!1;const s=i.emissiveTexture;return super._isSubMeshReady(e,t,s)}_canRenderMesh(e,t){return!0}_internalCompose(e){this.bindTexturesForCompose(e),e.setFloat("offset",this._intensity);const t=this._engine,i=t.getStencilBuffer();t.setStencilBuffer(!1),t.drawElementsType(ft.TriangleFillMode,0,6),t.setStencilBuffer(i)}_setEmissiveTextureAndColor(e,t,i){let r=1;if(this.customEmissiveTextureSelector?this._emissiveTextureAndColor.texture=this.customEmissiveTextureSelector(e,t,i):i?(this._emissiveTextureAndColor.texture=i.emissiveTexture,this._emissiveTextureAndColor.texture&&(r=this._emissiveTextureAndColor.texture.level)):this._emissiveTextureAndColor.texture=null,this.customEmissiveColorSelector)this.customEmissiveColorSelector(e,t,i,this._emissiveTextureAndColor.color);else if(i.emissiveColor){const s=i.emissiveIntensity??1;r*=s,this._emissiveTextureAndColor.color.set(i.emissiveColor.r*r,i.emissiveColor.g*r,i.emissiveColor.b*r,i.alpha)}else this._emissiveTextureAndColor.color.set(this.neutralColor.r,this.neutralColor.g,this.neutralColor.b,this.neutralColor.a)}_shouldRenderMesh(e){return this.hasMesh(e)}_addCustomEffectDefines(e){e.push("#define GLOW")}addExcludedMesh(e){this._excludedMeshes.indexOf(e.uniqueId)===-1&&this._excludedMeshes.push(e.uniqueId)}removeExcludedMesh(e){const t=this._excludedMeshes.indexOf(e.uniqueId);t!==-1&&this._excludedMeshes.splice(t,1)}addIncludedOnlyMesh(e){this._includedOnlyMeshes.indexOf(e.uniqueId)===-1&&this._includedOnlyMeshes.push(e.uniqueId)}removeIncludedOnlyMesh(e){const t=this._includedOnlyMeshes.indexOf(e.uniqueId);t!==-1&&this._includedOnlyMeshes.splice(t,1)}hasMesh(e){return super.hasMesh(e)?this._includedOnlyMeshes.length?this._includedOnlyMeshes.indexOf(e.uniqueId)!==-1:this._excludedMeshes.length?this._excludedMeshes.indexOf(e.uniqueId)===-1:!0:!1}_useMeshMaterial(e){var t;return(t=e.material)!=null&&t._supportGlowLayer?!0:this._meshesUsingTheirOwnMaterials.length==0?!1:this._meshesUsingTheirOwnMaterials.indexOf(e.uniqueId)>-1}referenceMeshToUseItsOwnMaterial(e){e.resetDrawCache(this._renderPassId),this._meshesUsingTheirOwnMaterials.push(e.uniqueId),e.onDisposeObservable.add(()=>{this._disposeMesh(e)})}unReferenceMeshFromUsingItsOwnMaterial(e,t){let i=this._meshesUsingTheirOwnMaterials.indexOf(e.uniqueId);for(;i>=0;)this._meshesUsingTheirOwnMaterials.splice(i,1),i=this._meshesUsingTheirOwnMaterials.indexOf(e.uniqueId);e.resetDrawCache(t)}_disposeMesh(e){this.removeIncludedOnlyMesh(e),this.removeExcludedMesh(e)}}Gn.EffectName="GlowLayer";Gn.DefaultBlurKernelSize=32;class sr extends zi{get drawWrapper(){return this._postProcessDrawWrapper}constructor(e,t,i){super(e,t),this.sourceSamplingMode=2,this.postProcess=i,this._postProcessDrawWrapper=this.postProcess.drawWrapper,this.outputTexture=this._frameGraph.textureManager.createDanglingHandle(),this.onTexturesAllocatedObservable.add(r=>{r.setTextureSamplingMode(this.sourceTexture,this.sourceSamplingMode)})}isReady(){return this.postProcess.isReady()}record(e=!1,t,i){if(this.sourceTexture===void 0)throw new Error(`FrameGraphPostProcessTask "${this.name}": sourceTexture is required`);const r=this._frameGraph.textureManager.getTextureCreationOptions(this.sourceTexture);r.options.samples=1,this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture,this.targetTexture,this.name,r);const s=r.sizeIsPercentage?this._frameGraph.textureManager.getAbsoluteDimensions(r.size):js(r.size)?r.size:{width:r.size,height:r.size};this._sourceWidth=s.width,this._sourceHeight=s.height;const n=this._frameGraph.textureManager.getTextureDescription(this.outputTexture);this._outputWidth=n.size.width,this._outputHeight=n.size.height;const o=this._frameGraph.addRenderPass(this.name);if(o.addDependencies(this.sourceTexture),o.setRenderTarget(this.outputTexture),o.setExecuteFunc(l=>{t==null||t(l),l.applyFullScreenEffect(this._postProcessDrawWrapper,()=>{l.bindTextureHandle(this._postProcessDrawWrapper.effect,"textureSampler",this.sourceTexture),i==null||i(l),this.postProcess.bind()})}),!e){const l=this._frameGraph.addRenderPass(this.name+"_disabled",!0);l.addDependencies(this.sourceTexture),l.setRenderTarget(this.outputTexture),l.setExecuteFunc(u=>{u.copyTexture(this.sourceTexture)})}return o}dispose(){this.postProcess.dispose(),super.dispose()}}class Va extends sr{constructor(e,t,i){super(e,t,i||new It(e,t.engine,new Q(1,0),10))}record(e=!1,t,i){const r=super.record(e,t,i);return this.postProcess.textureWidth=this._outputWidth,this.postProcess.textureHeight=this._outputHeight,r}}class qx extends sr{constructor(e,t,i){super(e,t,i||new kr(e,t.engine,new Q(1,0),1))}record(e=!1,t,i){const r=super.record(e,t,i);return this.postProcess.textureWidth=this._outputWidth,this.postProcess.textureHeight=this._outputHeight,r}}class F0 extends zi{get name(){return this._name}set name(e){if(this._name=e,this._blurX)for(let t=0;t<this._blurX.length;t++)this._blurX[t].name=`${e} Blur X${t}`,this._blurY[t].name=`${e} Blur Y${t}`;this._clearLayerTextures&&(this._clearLayerTextures.name=e+" Clear Layer"),this._objectRendererForLayer&&(this._objectRendererForLayer.name=e+" Render to Layer")}constructor(e,t,i,r,s,n=!1,o=!1,l=!1){super(e,t),this._setRenderTargetDepth=o,this._notifyBlurObservable=l,this._blurX=[],this._blurY=[],this._onBeforeBlurTask=null,this._onAfterBlurTask=null,this._onBeforeObservableObserver=null,this._onAfterObservableObserver=null,this._onAfterRenderingGroupObserver=null,this._scene=i,this._engine=i.getEngine(),this.layer=r;for(let u=0;u<s;u++)n?(this._blurX.push(new qx(`${e} Blur X${u}`,this._frameGraph,this.layer._postProcesses[1+u*2+0])),this._blurY.push(new qx(`${e} Blur Y${u}`,this._frameGraph,this.layer._postProcesses[1+u*2+1]))):(this._blurX.push(new Va(`${e} Blur X${u}`,this._frameGraph,this.layer._postProcesses[u*2+0])),this._blurY.push(new Va(`${e} Blur Y${u}`,this._frameGraph,this.layer._postProcesses[u*2+1])));this._clearLayerTextures=new M0(e+" Clear Layer",t),this._clearLayerTextures.clearColor=!0,this._clearLayerTextures.clearDepth=!0,this._objectRendererForLayer=new Ql(e+" Render to Layer",t,i,void 0,this.layer.objectRenderer),this._notifyBlurObservable&&(this._onBeforeBlurTask=new dh(e+" On Before Blur",t),this._onAfterBlurTask=new dh(e+" On After Blur",t),this._onBeforeBlurTask.func=()=>{this.layer.onBeforeBlurObservable.hasObservers()&&this.layer.onBeforeBlurObservable.notifyObservers(this.layer)},this._onAfterBlurTask.func=()=>{this.layer.onAfterBlurObservable.hasObservers()&&this.layer.onAfterBlurObservable.notifyObservers(this.layer)}),this.outputTexture=this._frameGraph.textureManager.createDanglingHandle(),this.onTexturesAllocatedObservable.add(u=>{for(let c=0;c<this._blurX.length;c++)this._blurX[c].onTexturesAllocatedObservable.notifyObservers(u),this._blurY[c].onTexturesAllocatedObservable.notifyObservers(u);u.setTextureSamplingMode(this._blurY[this._blurY.length-1].targetTexture,2)})}isReady(){return this._objectRendererForLayer.isReady()&&this.layer.isLayerReady()}record(){var g,_;if(this.targetTexture===void 0||this.objectRendererTask===void 0)throw new Error(`${this.constructor.name} "${this.name}": targetTexture and objectRendererTask are required`);this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture,this.targetTexture);let e,t,i;if(this.layerTexture)i=this.layerTexture,t=this._frameGraph.textureManager.getTextureCreationOptions(this.layerTexture),e=ql(t.size),t.size=e;else{const S=this._frameGraph.textureManager.getTextureCreationOptions(this.targetTexture),b=this.layer._options.mainTextureFixedSize?Math.max(2,this.layer._options.mainTextureFixedSize):0;e=ql(S.size),e.width=b||Math.floor(e.width*(this.layer._options.mainTextureRatio||.1))||1,e.height=b||Math.floor(e.height*(this.layer._options.mainTextureRatio||.1))||1,t={size:e,options:{createMipMaps:!1,types:[this.layer._options.mainTextureType],formats:[5],samples:1,useSRGBBuffers:[!1],creationFlags:[0]},sizeIsPercentage:this.layer._options.mainTextureFixedSize?!1:S.sizeIsPercentage},i=this._frameGraph.textureManager.createRenderTargetTexture(`${this.name} Color`,t)}const r={size:e,options:wr.CloneTextureOptions(t.options),sizeIsPercentage:t.sizeIsPercentage};r.options.formats[0]=14;const s=this._frameGraph.textureManager.createRenderTargetTexture(`${this.name} Depth`,r);this._clearLayerTextures.targetTexture=i,this._clearLayerTextures.depthTexture=s,this._clearLayerTextures.color=this.layer.neutralColor,this._clearLayerTextures.clearDepth=!0;const n=this._clearLayerTextures.record();this._objectRendererForLayer.targetTexture=this._clearLayerTextures.outputTexture,this._objectRendererForLayer.depthTexture=this._clearLayerTextures.outputDepthTexture,this._objectRendererForLayer.camera=this.objectRendererTask.camera,this._objectRendererForLayer.objectList=this.objectRendererTask.objectList,this._objectRendererForLayer.disableShadows=!0;const o=this._objectRendererForLayer.record();let l=0;this._engine.getCaps().textureHalfFloatRender?l=2:l=0,t.options.types[0]=l;const u=this.layer._options.blurTextureSizeRatio!==void 0?this.layer._options.blurTextureSizeRatio||.1:void 0;u!==void 0&&(e.width=Math.floor(e.width*u)||1,e.height=Math.floor(e.height*u)||1);const c=(g=this._onBeforeBlurTask)==null?void 0:g.record(),h=[];for(let S=0;S<this._blurX.length;S++){const b=this._frameGraph.textureManager.createRenderTargetTexture(this._blurX[S].name,t);this._blurX[S].sourceTexture=S===0?this._objectRendererForLayer.outputTexture:this._blurY[S-1].outputTexture,this._blurX[S].sourceSamplingMode=2,this._blurX[S].targetTexture=b,h.push(this._blurX[S].record(!0));const y=this._frameGraph.textureManager.createRenderTargetTexture(this._blurY[S].name,t);this._blurY[S].sourceTexture=this._blurX[S].outputTexture,this._blurY[S].sourceSamplingMode=2,this._blurY[S].targetTexture=y,h.push(this._blurY[S].record(!0)),e.width=e.width>>1,e.height=e.height>>1}const d=(_=this._onAfterBlurTask)==null?void 0:_.record();this.objectRendererTask.objectRenderer.onBeforeRenderObservable.remove(this._onBeforeObservableObserver),this._onBeforeObservableObserver=this.objectRendererTask.objectRenderer.onBeforeRenderObservable.add(()=>{const S=this.layer.shouldRender();n.disabled=!S,o.disabled=!S,c&&(c.disabled=!S);for(let b=0;b<h.length;b++)h[b].disabled=!S;d&&(d.disabled=!S),S&&this.layer.needStencil()&&(this._engine.setStencilBuffer(!0),this._engine.setStencilFunctionReference(1))}),this.objectRendererTask.objectRenderer.onAfterRenderObservable.remove(this._onAfterObservableObserver),this._onAfterObservableObserver=this.objectRendererTask.objectRenderer.onAfterRenderObservable.add(()=>{this.layer.shouldRender()&&this.layer.needStencil()&&this._engine.setStencilBuffer(!1)}),this.layer.bindTexturesForCompose=void 0,this._clearAfterRenderingGroupObserver();const f=this._frameGraph.addRenderPass(this.name);for(let S=0;S<this._blurY.length;S++)f.addDependencies(this._blurY[S].outputTexture);f.setRenderTarget(this.outputTexture),this._setRenderTargetDepth&&f.setRenderTargetDepth(this.objectRendererTask.depthTexture),f.setExecuteFunc(S=>{this.layer.bindTexturesForCompose||(this.layer.bindTexturesForCompose=b=>{for(let y=0;y<this._blurY.length;y++)S.bindTextureHandle(b,`textureSampler${y>0?y+1:""}`,this._blurY[y].outputTexture)}),this.layer._options.renderingGroupId!==-1?this._onAfterRenderingGroupObserver||(this._onAfterRenderingGroupObserver=this._scene.onAfterRenderingGroupObservable.add(b=>{!this.layer.shouldRender()||b.renderingGroupId!==this.layer._options.renderingGroupId||b.renderingManager!==this.objectRendererTask.objectRenderer._renderingManager||(this._objectRendererForLayer.objectList=this.objectRendererTask.objectList,S.saveDepthStates(),S.setDepthStates(!1,!1),S._applyRenderTarget(),this.layer.compose(),S.restoreDepthStates())})):(this._clearAfterRenderingGroupObserver(),this.layer.shouldRender()&&(this._objectRendererForLayer.objectList=this.objectRendererTask.objectList,S.setDepthStates(!1,!1),S._applyRenderTarget(),this.layer.compose()))});const p=this._frameGraph.addRenderPass(this.name+"_disabled",!0);p.setRenderTarget(this.outputTexture),this._setRenderTargetDepth&&p.setRenderTargetDepth(this.objectRendererTask.depthTexture),p.setExecuteFunc(S=>{})}_clearAfterRenderingGroupObserver(){this._scene.onAfterRenderingGroupObservable.remove(this._onAfterRenderingGroupObserver),this._onAfterRenderingGroupObserver=null}dispose(){var e,t;this._clearAfterRenderingGroupObserver(),this._clearLayerTextures.dispose(),this._objectRendererForLayer.dispose(),(e=this._onBeforeBlurTask)==null||e.dispose(),(t=this._onAfterBlurTask)==null||t.dispose(),this.layer.dispose();for(let i=0;i<this._blurX.length;i++)this._blurX[i].dispose(),this._blurY[i].dispose();super.dispose()}}class Qx extends F0{constructor(e,t,i,r){super(e,t,i,new Gn(e,i,r,!0),2),this.layer._renderPassId=this._objectRendererForLayer.objectRenderer.renderPassId}}class ea extends pi{get task(){return this._frameGraphTask}constructor(e,t,i,r=!1,s=.5,n,o=0){super(e,t,i),this._additionalConstructionParameters=[r,s,n,o],this.registerInput("target",J.AutoDetect),this.registerInput("layer",J.AutoDetect,!0),this.registerInput("objectRenderer",J.Object,!0,new ul("objectRenderer",this,0,ms,"NodeRenderGraphBaseObjectRendererBlock")),this._addDependenciesInput(),this.registerOutput("output",J.BasedOnInput),this.target.addExcludedConnectionPointFromAllowedTypes(J.TextureAllButBackBufferDepthStencil),this.layer.addExcludedConnectionPointFromAllowedTypes(J.TextureAllButBackBuffer),this.output._typeConnectionSource=this.target,this._frameGraphTask=new Qx(this.name,this._frameGraph,this._scene,{ldrMerge:r,mainTextureRatio:s,mainTextureFixedSize:n,mainTextureType:o})}_createTask(e,t,i,r){var o;const s=this.blurKernelSize,n=this.intensity;(o=this._frameGraphTask)==null||o.dispose(),this._frameGraphTask=new Qx(this.name,this._frameGraph,this._scene,{ldrMerge:e,mainTextureRatio:t,mainTextureFixedSize:i,mainTextureType:r}),this.blurKernelSize=s,this.intensity=n,this._additionalConstructionParameters=[e,t,i,r]}get ldrMerge(){return this._frameGraphTask.layer.ldrMerge}set ldrMerge(e){const t=this._frameGraphTask.layer._options;this._createTask(e,t.mainTextureRatio,t.mainTextureFixedSize,t.mainTextureType)}get layerTextureRatio(){return this._frameGraphTask.layer._options.mainTextureRatio}set layerTextureRatio(e){const t=this._frameGraphTask.layer._options;this._createTask(t.ldrMerge,e,t.mainTextureFixedSize,t.mainTextureType)}get layerTextureFixedSize(){return this._frameGraphTask.layer._options.mainTextureFixedSize}set layerTextureFixedSize(e){const t=this._frameGraphTask.layer._options;this._createTask(t.ldrMerge,t.mainTextureRatio,e,t.mainTextureType)}get layerTextureType(){return this._frameGraphTask.layer._options.mainTextureType}set layerTextureType(e){const t=this._frameGraphTask.layer._options;this._createTask(t.ldrMerge,t.mainTextureRatio,t.mainTextureFixedSize,e)}get blurKernelSize(){return this._frameGraphTask.layer.blurKernelSize}set blurKernelSize(e){this._frameGraphTask.layer.blurKernelSize=e}get intensity(){return this._frameGraphTask.layer.intensity}set intensity(e){this._frameGraphTask.layer.intensity=e}getClassName(){return"NodeRenderGraphGlowLayerBlock"}get target(){return this._inputs[0]}get layer(){return this._inputs[1]}get objectRenderer(){return this._inputs[2]}get output(){return this._outputs[0]}_buildBlock(e){var t,i,r;super._buildBlock(e),this.output.value=this._frameGraphTask.outputTexture,this._frameGraphTask.targetTexture=(t=this.target.connectedPoint)==null?void 0:t.value,this._frameGraphTask.layerTexture=(i=this.layer.connectedPoint)==null?void 0:i.value,this._frameGraphTask.objectRendererTask=(r=this.objectRenderer.connectedPoint)==null?void 0:r.value}_dumpPropertiesCode(){const e=[];return e.push(`${this._codeVariableName}.blurKernelSize = ${this.blurKernelSize};`),e.push(`${this._codeVariableName}.intensity = ${this.intensity};`),super._dumpPropertiesCode()+e.join(`
`)}serialize(){const e=super.serialize();return e.blurKernelSize=this.blurKernelSize,e.intensity=this.intensity,e}_deserialize(e){super._deserialize(e),this.blurKernelSize=e.blurKernelSize,this.intensity=e.intensity}}C([U("LDR merge",0,"PROPERTIES")],ea.prototype,"ldrMerge",null);C([U("Layer texture ratio",1,"PROPERTIES")],ea.prototype,"layerTextureRatio",null);C([U("Layer texture fixed size",1,"PROPERTIES")],ea.prototype,"layerTextureFixedSize",null);C([U("Layer texture type",8,"PROPERTIES")],ea.prototype,"layerTextureType",null);C([U("Blur kernel size",2,"PROPERTIES",{min:1,max:256})],ea.prototype,"blurKernelSize",null);C([U("Intensity",1,"PROPERTIES",{min:0,max:5})],ea.prototype,"intensity",null);B("BABYLON.NodeRenderGraphGlowLayerBlock",ea);class ur extends sn{set blurHorizontalSize(e){this._horizontalBlurPostprocess.kernel=e,this._options.blurHorizontalSize=e}set blurVerticalSize(e){this._verticalBlurPostprocess.kernel=e,this._options.blurVerticalSize=e}get blurHorizontalSize(){return this._horizontalBlurPostprocess.kernel}get blurVerticalSize(){return this._verticalBlurPostprocess.kernel}constructor(e,t,i,r=!1){super(e,t,i!==void 0?!!i.forceGLSL:!1),this.innerGlow=!0,this.outerGlow=!0,this._instanceGlowingMeshStencilReference=ur.GlowingMeshStencilReference++,this._meshes={},this._excludedMeshes={},this._mainObjectRendererRenderPassId=-1,this.neutralColor=ur.NeutralColor,this._options={mainTextureRatio:.5,blurTextureSizeRatio:.5,mainTextureFixedSize:0,blurHorizontalSize:1,blurVerticalSize:1,alphaBlendingMode:2,camera:null,renderingGroupId:-1,forceGLSL:!1,mainTextureType:0,isStroke:!1,...i},this._init(this._options),this._shouldRender=!1,r&&this._createTextureAndPostProcesses()}getClassName(){return"HighlightLayer"}async _importShadersAsync(){this._shaderLanguage===1?await Promise.all([k(()=>Promise.resolve().then(()=>nT),void 0),k(()=>Promise.resolve().then(()=>oT),void 0),k(()=>Promise.resolve().then(()=>Zu),void 0)]):await Promise.all([k(()=>Promise.resolve().then(()=>eT),void 0),k(()=>Promise.resolve().then(()=>iT),void 0),k(()=>Promise.resolve().then(()=>Xu),void 0)]),await super._importShadersAsync()}getEffectName(){return ur.EffectName}_numInternalDraws(){return 2}_createMergeEffect(){return this._engine.createEffect("glowMapMerge",[N.PositionKind],["offset"],["textureSampler"],this._options.isStroke?`#define STROKE 
`:void 0,void 0,void 0,void 0,void 0,this._shaderLanguage,this._shadersLoaded?void 0:async()=>{await this._importShadersAsync(),this._shadersLoaded=!0})}_createTextureAndPostProcesses(){this._options.alphaBlendingMode===2?(this._downSamplePostprocess=new km("HighlightLayerPPP",this._scene.getEngine()),this._horizontalBlurPostprocess=new kr("HighlightLayerHBP",this._scene.getEngine(),new Q(1,0),this._options.blurHorizontalSize),this._verticalBlurPostprocess=new kr("HighlightLayerVBP",this._scene.getEngine(),new Q(0,1),this._options.blurVerticalSize),this._postProcesses=[this._downSamplePostprocess,this._horizontalBlurPostprocess,this._verticalBlurPostprocess]):(this._horizontalBlurPostprocess=new It("HighlightLayerHBP",this._scene.getEngine(),new Q(1,0),this._options.blurHorizontalSize/2),this._verticalBlurPostprocess=new It("HighlightLayerVBP",this._scene.getEngine(),new Q(0,1),this._options.blurVerticalSize/2),this._postProcesses=[this._horizontalBlurPostprocess,this._verticalBlurPostprocess])}needStencil(){return!0}isReady(e,t){const i=e.getMaterial(),r=e.getRenderingMesh();if(!i||!r||!this._meshes)return!1;let s=null;const n=this._meshes[r.uniqueId];return n&&n.glowEmissiveOnly&&i&&(s=i.emissiveTexture),super._isSubMeshReady(e,t,s)}_canRenderMesh(e,t){return!0}_internalCompose(e,t){this.bindTexturesForCompose(e);const i=this._engine;i.cacheStencilState(),i.setStencilOperationPass(7681),i.setStencilOperationFail(7680),i.setStencilOperationDepthFail(7680),i.setStencilMask(0),i.setStencilBuffer(!0),i.setStencilFunctionReference(this._instanceGlowingMeshStencilReference),this.outerGlow&&t===0&&(e.setFloat("offset",0),i.setStencilFunction(517),i.drawElementsType(ft.TriangleFillMode,0,6)),this.innerGlow&&t===1&&(e.setFloat("offset",1),i.setStencilFunction(514),i.drawElementsType(ft.TriangleFillMode,0,6)),i.restoreStencilState()}_setEmissiveTextureAndColor(e,t,i){const r=this._meshes[e.uniqueId];r?this._emissiveTextureAndColor.color.set(r.color.r,r.color.g,r.color.b,1):this._emissiveTextureAndColor.color.set(this.neutralColor.r,this.neutralColor.g,this.neutralColor.b,this.neutralColor.a),r&&r.glowEmissiveOnly&&i?(this._emissiveTextureAndColor.texture=i.emissiveTexture,this._emissiveTextureAndColor.color.set(1,1,1,1)):this._emissiveTextureAndColor.texture=null}shouldRender(){return!!(this._meshes&&super.shouldRender())}_shouldRenderMesh(e){return this._excludedMeshes&&this._excludedMeshes[e.uniqueId]?!1:super.hasMesh(e)}_addCustomEffectDefines(e){e.push("#define HIGHLIGHT")}addExcludedMesh(e){if(!this._excludedMeshes)return;if(!this._excludedMeshes[e.uniqueId]){const i={mesh:e,beforeBind:null,afterRender:null,stencilState:!1};i.beforeBind=e.onBeforeBindObservable.add(r=>{this._mainObjectRendererRenderPassId!==-1&&this._mainObjectRendererRenderPassId!==this._engine.currentRenderPassId||(i.stencilState=r.getEngine().getStencilBuffer(),r.getEngine().setStencilBuffer(!1))}),i.afterRender=e.onAfterRenderObservable.add(r=>{this._mainObjectRendererRenderPassId!==-1&&this._mainObjectRendererRenderPassId!==this._engine.currentRenderPassId||r.getEngine().setStencilBuffer(i.stencilState)}),this._excludedMeshes[e.uniqueId]=i}}removeExcludedMesh(e){if(!this._excludedMeshes)return;const t=this._excludedMeshes[e.uniqueId];t&&(t.beforeBind&&e.onBeforeBindObservable.remove(t.beforeBind),t.afterRender&&e.onAfterRenderObservable.remove(t.afterRender)),this._excludedMeshes[e.uniqueId]=null}hasMesh(e){return!this._meshes||!super.hasMesh(e)?!1:!!this._meshes[e.uniqueId]}addMesh(e,t,i=!1){if(!this._meshes)return;const r=this._meshes[e.uniqueId];r?r.color=t:(this._meshes[e.uniqueId]={mesh:e,color:t,observerHighlight:e.onBeforeBindObservable.add(s=>{this._mainObjectRendererRenderPassId!==-1&&this._mainObjectRendererRenderPassId!==this._engine.currentRenderPassId||this.isEnabled&&(this._excludedMeshes&&this._excludedMeshes[s.uniqueId]?this._defaultStencilReference(s):s.getScene().getEngine().setStencilFunctionReference(this._instanceGlowingMeshStencilReference))}),observerDefault:e.onAfterRenderObservable.add(s=>{this._mainObjectRendererRenderPassId!==-1&&this._mainObjectRendererRenderPassId!==this._engine.currentRenderPassId||this.isEnabled&&this._defaultStencilReference(s)}),glowEmissiveOnly:i},e.onDisposeObservable.add(()=>{this._disposeMesh(e)})),this._shouldRender=!0}removeMesh(e){if(!this._meshes)return;const t=this._meshes[e.uniqueId];t&&(t.observerHighlight&&e.onBeforeBindObservable.remove(t.observerHighlight),t.observerDefault&&e.onAfterRenderObservable.remove(t.observerDefault),delete this._meshes[e.uniqueId]),this._shouldRender=!1;for(const i in this._meshes)if(this._meshes[i]){this._shouldRender=!0;break}}removeAllMeshes(){if(this._meshes){for(const e in this._meshes)if(Object.prototype.hasOwnProperty.call(this._meshes,e)){const t=this._meshes[e];t&&this.removeMesh(t.mesh)}}}_defaultStencilReference(e){e.getScene().getEngine().setStencilFunctionReference(ur.NormalMeshStencilReference)}_disposeMesh(e){this.removeMesh(e),this.removeExcludedMesh(e)}dispose(){if(this._meshes){for(const e in this._meshes){const t=this._meshes[e];t&&t.mesh&&(t.observerHighlight&&t.mesh.onBeforeBindObservable.remove(t.observerHighlight),t.observerDefault&&t.mesh.onAfterRenderObservable.remove(t.observerDefault))}this._meshes=null}if(this._excludedMeshes){for(const e in this._excludedMeshes){const t=this._excludedMeshes[e];t&&(t.beforeBind&&t.mesh.onBeforeBindObservable.remove(t.beforeBind),t.afterRender&&t.mesh.onAfterRenderObservable.remove(t.afterRender))}this._excludedMeshes=null}super.dispose()}}ur.EffectName="HighlightLayer";ur.NeutralColor=new xe(0,0,0,0);ur.GlowingMeshStencilReference=2;ur.NormalMeshStencilReference=1;class Kx extends F0{constructor(e,t,i,r){const s=(r==null?void 0:r.alphaBlendingMode)??2;super(e,t,i,new ur(e,i,r,!0),1,s===2,!0,!0)}record(){if(!this.objectRendererTask.depthTexture)throw new Error(`FrameGraphHighlightLayerTask "${this.name}": objectRendererTask must have a depthTexture input`);const e=this._frameGraph.textureManager.getTextureCreationOptions(this.objectRendererTask.depthTexture);if(!e.options.formats||!Fm(e.options.formats[0]))throw new Error(`FrameGraphHighlightLayerTask "${this.name}": objectRendererTask depthTexture must have a stencil aspect`);super.record(),this.layer._mainObjectRendererRenderPassId=this.objectRendererTask.objectRenderer.renderPassId}}class Sn extends pi{get task(){return this._frameGraphTask}constructor(e,t,i,r=.5,s,n=.5,o=!1,l=0){super(e,t,i),this._additionalConstructionParameters=[r,s,n,o,l],this.registerInput("target",J.AutoDetect),this.registerInput("layer",J.AutoDetect,!0),this.registerInput("objectRenderer",J.Object,!0,new ul("objectRenderer",this,0,ms,"NodeRenderGraphBaseObjectRendererBlock")),this._addDependenciesInput(),this.registerOutput("output",J.BasedOnInput),this.target.addExcludedConnectionPointFromAllowedTypes(J.TextureAllButBackBufferDepthStencil),this.layer.addExcludedConnectionPointFromAllowedTypes(J.TextureAllButBackBuffer),this.output._typeConnectionSource=this.target,this._frameGraphTask=new Kx(this.name,this._frameGraph,this._scene,{mainTextureRatio:r,mainTextureFixedSize:s,blurTextureSizeRatio:n,isStroke:o,mainTextureType:l})}_createTask(e,t,i,r,s){var l;const n=this.blurHorizontalSize,o=this.blurVerticalSize;(l=this._frameGraphTask)==null||l.dispose(),this._frameGraphTask=new Kx(this.name,this._frameGraph,this._scene,{mainTextureRatio:e,mainTextureFixedSize:t,blurTextureSizeRatio:i,isStroke:r,mainTextureType:s}),this.blurHorizontalSize=n,this.blurVerticalSize=o,this._additionalConstructionParameters=[e,t,i,r,s]}get layerTextureRatio(){return this._frameGraphTask.layer._options.mainTextureRatio}set layerTextureRatio(e){const t=this._frameGraphTask.layer._options;this._createTask(e,t.mainTextureFixedSize,t.blurTextureSizeRatio,t.isStroke,t.mainTextureType)}get layerTextureFixedSize(){return this._frameGraphTask.layer._options.mainTextureFixedSize}set layerTextureFixedSize(e){const t=this._frameGraphTask.layer._options;this._createTask(t.mainTextureRatio,e,t.blurTextureSizeRatio,t.isStroke,t.mainTextureType)}get blurTextureSizeRatio(){return this._frameGraphTask.layer._options.blurTextureSizeRatio}set blurTextureSizeRatio(e){const t=this._frameGraphTask.layer._options;this._createTask(t.mainTextureRatio,t.mainTextureFixedSize,e,t.isStroke,t.mainTextureType)}get isStroke(){return this._frameGraphTask.layer._options.isStroke}set isStroke(e){const t=this._frameGraphTask.layer._options;this._createTask(t.mainTextureRatio,t.mainTextureFixedSize,t.blurTextureSizeRatio,e,t.mainTextureType)}get layerTextureType(){return this._frameGraphTask.layer._options.mainTextureType}set layerTextureType(e){const t=this._frameGraphTask.layer._options;this._createTask(t.mainTextureRatio,t.mainTextureFixedSize,t.blurTextureSizeRatio,t.isStroke,e)}get blurHorizontalSize(){return this._frameGraphTask.layer.blurHorizontalSize}set blurHorizontalSize(e){this._frameGraphTask.layer.blurHorizontalSize=e}get blurVerticalSize(){return this._frameGraphTask.layer.blurVerticalSize}set blurVerticalSize(e){this._frameGraphTask.layer.blurVerticalSize=e}getClassName(){return"NodeRenderGraphHighlightLayerBlock"}get target(){return this._inputs[0]}get layer(){return this._inputs[1]}get objectRenderer(){return this._inputs[2]}get output(){return this._outputs[0]}_buildBlock(e){var t,i,r;super._buildBlock(e),this.output.value=this._frameGraphTask.outputTexture,this._frameGraphTask.targetTexture=(t=this.target.connectedPoint)==null?void 0:t.value,this._frameGraphTask.layerTexture=(i=this.layer.connectedPoint)==null?void 0:i.value,this._frameGraphTask.objectRendererTask=(r=this.objectRenderer.connectedPoint)==null?void 0:r.value}_dumpPropertiesCode(){const e=[];return e.push(`${this._codeVariableName}.blurHorizontalSize = ${this.blurHorizontalSize};`),e.push(`${this._codeVariableName}.blurVerticalSize = ${this.blurVerticalSize};`),super._dumpPropertiesCode()+e.join(`
`)}serialize(){const e=super.serialize();return e.blurHorizontalSize=this.blurHorizontalSize,e.blurVerticalSize=this.blurVerticalSize,e}_deserialize(e){super._deserialize(e),this.blurHorizontalSize=e.blurHorizontalSize,this.blurVerticalSize=e.blurVerticalSize}}C([U("Layer texture ratio",1,"PROPERTIES")],Sn.prototype,"layerTextureRatio",null);C([U("Layer texture fixed size",1,"PROPERTIES")],Sn.prototype,"layerTextureFixedSize",null);C([U("Blur texture size ratio",1,"PROPERTIES")],Sn.prototype,"blurTextureSizeRatio",null);C([U("Is stroke",0,"PROPERTIES")],Sn.prototype,"isStroke",null);C([U("Layer texture type",8,"PROPERTIES")],Sn.prototype,"layerTextureType",null);C([U("Blur horizontal size",1,"PROPERTIES",{min:0,max:4})],Sn.prototype,"blurHorizontalSize",null);C([U("Blur vertical size",1,"PROPERTIES",{min:0,max:4})],Sn.prototype,"blurVerticalSize",null);B("BABYLON.NodeRenderGraphHighlightLayerBlock",Sn);class Tw extends sr{constructor(e,t,i){super(e,t,i||new ns(e,t.engine))}record(e=!1){if(this.sourceTexture===void 0||this.leftTexture===void 0)throw new Error(`FrameGraphAnaglyphTask "${this.name}": sourceTexture and leftTexture are required`);const t=super.record(e,void 0,i=>{i.bindTextureHandle(this._postProcessDrawWrapper.effect,"leftSampler",this.leftTexture)});return t.addDependencies(this.leftTexture),t}}class Pr extends pi{constructor(e,t,i){super(e,t,i),this.registerInput("source",J.AutoDetect),this.registerInput("target",J.AutoDetect,!0),this.source.addExcludedConnectionPointFromAllowedTypes(J.TextureAllButBackBuffer),this.target.addExcludedConnectionPointFromAllowedTypes(J.TextureAll)}_finalizeInputOutputRegistering(){this._addDependenciesInput(),this.registerOutput("output",J.BasedOnInput),this.output._typeConnectionSource=()=>this.target.isConnected?this.target:this.source}get sourceSamplingMode(){return this._frameGraphTask.sourceSamplingMode}set sourceSamplingMode(e){this._frameGraphTask.sourceSamplingMode=e}getClassName(){return"NodeRenderGraphBasePostProcessBlock"}get source(){return this._inputs[0]}get target(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){var t,i;super._buildBlock(e),this.output.value=this._frameGraphTask.outputTexture,this._frameGraphTask.sourceTexture=(t=this.source.connectedPoint)==null?void 0:t.value,this._frameGraphTask.targetTexture=(i=this.target.connectedPoint)==null?void 0:i.value}_dumpPropertiesCode(){const e=[];return e.push(`${this._codeVariableName}.sourceSamplingMode = ${this.sourceSamplingMode};`),super._dumpPropertiesCode()+e.join(`
`)}serialize(){const e=super.serialize();return e.sourceSamplingMode=this.sourceSamplingMode,e}_deserialize(e){super._deserialize(e),this.sourceSamplingMode=e.sourceSamplingMode}}C([U("Source sampling mode",6,"PROPERTIES")],Pr.prototype,"sourceSamplingMode",null);class Cw extends Pr{get task(){return this._frameGraphTask}constructor(e,t,i){super(e,t,i),this.registerInput("leftTexture",J.AutoDetect),this.leftTexture.addExcludedConnectionPointFromAllowedTypes(J.TextureAllButBackBuffer),this._finalizeInputOutputRegistering(),this._frameGraphTask=new Tw(this.name,t,new ns(e,i.getEngine()))}getClassName(){return"NodeRenderGraphAnaglyphPostProcessBlock"}get leftTexture(){return this._inputs[2]}_buildBlock(e){var t;super._buildBlock(e),this._frameGraphTask.leftTexture=(t=this.leftTexture.connectedPoint)==null?void 0:t.value}}B("BABYLON.NodeRenderGraphAnaglyphPostProcessBlock",Cw);class os extends Qt{_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(k(()=>Promise.resolve().then(()=>vk),void 0))):t.push(k(()=>Promise.resolve().then(()=>xk),void 0))}constructor(e,t=null,i){super({...i,name:e,engine:t||mt.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:os.FragmentUrl,uniforms:os.Uniforms}),this.degree=1}bind(){super.bind(),this._drawWrapper.effect.setFloat("degree",this.degree)}}os.FragmentUrl="blackAndWhite";os.Uniforms=["degree"];class Pw extends sr{constructor(e,t,i){super(e,t,i||new os(e,t.engine))}}class L0 extends Pr{get task(){return this._frameGraphTask}constructor(e,t,i){super(e,t,i),this._finalizeInputOutputRegistering(),this._frameGraphTask=new Pw(this.name,t,new os(e,i.getEngine()))}get degree(){return this._frameGraphTask.postProcess.degree}set degree(e){this._frameGraphTask.postProcess.degree=e}getClassName(){return"NodeRenderGraphBlackAndWhitePostProcessBlock"}_dumpPropertiesCode(){const e=[];return e.push(`${this._codeVariableName}.degree = ${this.degree};`),super._dumpPropertiesCode()+e.join(`
`)}serialize(){const e=super.serialize();return e.degree=this.degree,e}_deserialize(e){super._deserialize(e),this.degree=e.degree}}C([U("Degree",1,"PROPERTIES",{min:0,max:1})],L0.prototype,"degree",null);B("BABYLON.NodeRenderGraphBlackAndWhitePostProcessBlock",L0);class cr extends Qt{_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(k(()=>Promise.resolve().then(()=>sk),void 0))):t.push(k(()=>Promise.resolve().then(()=>ik),void 0))}constructor(e,t=null,i){super({...i,name:e,engine:t||mt.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:cr.FragmentUrl,uniforms:cr.Uniforms,samplers:cr.Samplers}),this.weight=1}bind(){super.bind(),this._drawWrapper.effect.setFloat("bloomWeight",this.weight)}}cr.FragmentUrl="bloomMerge";cr.Uniforms=["bloomWeight"];cr.Samplers=["bloomBlur"];class Ew extends sr{constructor(e,t,i){super(e,t,i||new cr(e,t.engine))}record(e=!1){if(this.sourceTexture===void 0||this.blurTexture===void 0)throw new Error(`FrameGraphBloomMergeTask "${this.name}": sourceTexture and blurTexture are required`);const t=super.record(e,void 0,i=>{i.bindTextureHandle(this._postProcessDrawWrapper.effect,"bloomBlur",this.blurTexture)});return t.addDependencies(this.blurTexture),t}}class zr extends Qt{_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(k(()=>Promise.resolve().then(()=>lk),void 0))):t.push(k(()=>Promise.resolve().then(()=>ak),void 0))}constructor(e,t=null,i){super({...i,name:e,engine:t||mt.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:zr.FragmentUrl,uniforms:zr.Uniforms}),this.threshold=.9,this._exposure=1}bind(){super.bind();const e=this._drawWrapper.effect;e.setFloat("threshold",Math.pow(this.threshold,Bl)),e.setFloat("exposure",this._exposure)}}zr.FragmentUrl="extractHighlights";zr.Uniforms=["threshold","exposure"];class B0{get threshold(){return this._downscale.threshold}set threshold(e){this._downscale.threshold=e}get weight(){return this._merge.weight}set weight(e){this._merge.weight=e}get kernel(){return this._blurX.kernel/this.scale}set kernel(e){this._blurX.kernel=e*this.scale,this._blurY.kernel=e*this.scale}constructor(e,t,i,r=!1){this.scale=i,this._downscale=new zr(e+"_downscale",t,{blockCompilation:r}),this._blurX=new It(e+"_blurX",t,new Q(1,0),10,{blockCompilation:r}),this._blurY=new It(e+"_blurY",t,new Q(0,1),10,{blockCompilation:r}),this._merge=new cr(e+"_merge",t,{blockCompilation:r})}isReady(){return this._downscale.isReady()&&this._blurX.isReady()&&this._blurY.isReady()&&this._merge.isReady()}}class V0 extends sr{constructor(e,t,i){super(e,t,i||new zr(e,t.engine))}}class Jx extends zi{get name(){return this._name}set name(e){this._name=e,this._downscale&&(this._downscale.name=`${e} Downscale`),this._blurX&&(this._blurX.name=`${e} Blur X`),this._blurY&&(this._blurY.name=`${e} Blur Y`),this._merge&&(this._merge.name=`${e} Merge`)}constructor(e,t,i,r,s,n=!1,o=.5){if(super(e,t),this.sourceSamplingMode=2,this.hdr=n,this._defaultPipelineTextureType=0,n){const l=t.engine.getCaps();l.textureHalfFloatRender?this._defaultPipelineTextureType=2:l.textureFloatRender&&(this._defaultPipelineTextureType=1)}this.bloom=new B0(e,t.engine,o),this.bloom.threshold=s,this.bloom.kernel=r,this.bloom.weight=i,this._downscale=new V0(`${e} Downscale`,this._frameGraph,this.bloom._downscale),this._blurX=new Va(`${e} Blur X`,this._frameGraph,this.bloom._blurX),this._blurY=new Va(`${e} Blur Y`,this._frameGraph,this.bloom._blurY),this._merge=new Ew(`${e} Merge`,this._frameGraph,this.bloom._merge),this.onTexturesAllocatedObservable.add(l=>{this._downscale.onTexturesAllocatedObservable.notifyObservers(l),this._blurX.onTexturesAllocatedObservable.notifyObservers(l),this._blurY.onTexturesAllocatedObservable.notifyObservers(l),this._merge.onTexturesAllocatedObservable.notifyObservers(l)}),this.outputTexture=this._frameGraph.textureManager.createDanglingHandle()}isReady(){return this.bloom.isReady()}record(){if(this.sourceTexture===void 0)throw new Error("FrameGraphBloomTask: sourceTexture is required");const e=this._frameGraph.textureManager.getTextureDescription(this.sourceTexture),t={size:{width:Math.floor(e.size.width*this.bloom.scale)||1,height:Math.floor(e.size.height*this.bloom.scale)||1},options:{createMipMaps:!1,types:[this._defaultPipelineTextureType],formats:[5],samples:1,useSRGBBuffers:[!1],labels:[""]},sizeIsPercentage:!1},i=this._frameGraph.textureManager.createRenderTargetTexture(this._downscale.name,t);this._downscale.sourceTexture=this.sourceTexture,this._downscale.sourceSamplingMode=2,this._downscale.targetTexture=i,this._downscale.record(!0);const r=this._frameGraph.textureManager.createRenderTargetTexture(this._blurX.name,t);this._blurX.sourceTexture=i,this._blurX.sourceSamplingMode=2,this._blurX.targetTexture=r,this._blurX.record(!0);const s=this._frameGraph.textureManager.createRenderTargetTexture(this._blurY.name,t);this._blurY.sourceTexture=r,this._blurY.sourceSamplingMode=2,this._blurY.targetTexture=s,this._blurY.record(!0);const n=this._frameGraph.textureManager.getTextureCreationOptions(this.sourceTexture);this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture,this.targetTexture,this._merge.name,n),this._merge.sourceTexture=this.sourceTexture,this._merge.sourceSamplingMode=this.sourceSamplingMode,this._merge.blurTexture=s,this._merge.targetTexture=this.outputTexture,this._merge.record(!0);const o=this._frameGraph.addRenderPass(this.name+"_disabled",!0);o.addDependencies(this.sourceTexture),o.setRenderTarget(this.outputTexture),o.setExecuteFunc(l=>{l.copyTexture(this.sourceTexture)})}dispose(){this._downscale.dispose(),this._blurX.dispose(),this._blurY.dispose(),this._merge.dispose(),super.dispose()}}class eo extends Pr{get task(){return this._frameGraphTask}constructor(e,t,i,r=!1,s=.5){super(e,t,i),this._additionalConstructionParameters=[r,s],this._finalizeInputOutputRegistering(),this._frameGraphTask=new Jx(this.name,t,.75,64,.2,r,s)}_createTask(e,t){const i=this._frameGraphTask.sourceSamplingMode,r=this._frameGraphTask.bloom.threshold,s=this._frameGraphTask.bloom.weight,n=this._frameGraphTask.bloom.kernel;this._frameGraphTask.dispose(),this._frameGraphTask=new Jx(this.name,this._frameGraph,s,n,r,t,e),this._frameGraphTask.sourceSamplingMode=i,this._additionalConstructionParameters=[t,e]}get bloomScale(){return this._frameGraphTask.bloom.scale}set bloomScale(e){this._createTask(e,this._frameGraphTask.hdr)}get hdr(){return this._frameGraphTask.hdr}set hdr(e){this._createTask(this._frameGraphTask.bloom.scale,e)}get threshold(){return this._frameGraphTask.bloom.threshold}set threshold(e){this._frameGraphTask.bloom.threshold=e}get weight(){return this._frameGraphTask.bloom.weight}set weight(e){this._frameGraphTask.bloom.weight=e}get kernel(){return this._frameGraphTask.bloom.kernel}set kernel(e){this._frameGraphTask.bloom.kernel=e}getClassName(){return"NodeRenderGraphBloomPostProcessBlock"}_dumpPropertiesCode(){const e=[];return e.push(`${this._codeVariableName}.threshold = ${this.threshold};`),e.push(`${this._codeVariableName}.weight = ${this.weight};`),e.push(`${this._codeVariableName}.kernel = ${this.kernel};`),super._dumpPropertiesCode()+e.join(`
`)}serialize(){const e=super.serialize();return e.threshold=this.threshold,e.weight=this.weight,e.kernel=this.kernel,e}_deserialize(e){super._deserialize(e),this.threshold=e.threshold,this.weight=e.weight,this.kernel=e.kernel}}C([U("Bloom scale",1,"PROPERTIES")],eo.prototype,"bloomScale",null);C([U("HDR",0,"PROPERTIES")],eo.prototype,"hdr",null);C([U("Threshold",1,"PROPERTIES",{min:0,max:2})],eo.prototype,"threshold",null);C([U("Weight",1,"PROPERTIES",{min:0,max:3})],eo.prototype,"weight",null);C([U("Kernel",2,"PROPERTIES",{min:1,max:128})],eo.prototype,"kernel",null);B("BABYLON.NodeRenderGraphBloomPostProcessBlock",eo);class D_ extends Pr{get task(){return this._frameGraphTask}constructor(e,t,i){super(e,t,i),this._finalizeInputOutputRegistering(),this._frameGraphTask=new Va(this.name,t,new It(e,i.getEngine(),new Q(1,0),32))}get direction(){return this._frameGraphTask.postProcess.direction}set direction(e){this._frameGraphTask.postProcess.direction=e}get kernel(){return this._frameGraphTask.postProcess.kernel}set kernel(e){this._frameGraphTask.postProcess.kernel=e}getClassName(){return"NodeRenderGraphBlurPostProcessBlock"}_dumpPropertiesCode(){const e=[];return e.push(`${this._codeVariableName}.direction = new BABYLON.Vector2(${this.direction.x}, ${this.direction.y});`),e.push(`${this._codeVariableName}.kernel = ${this.kernel};`),super._dumpPropertiesCode()+e.join(`
`)}serialize(){const e=super.serialize();return e.direction=this.direction.asArray(),e.kernel=this.kernel,e}_deserialize(e){super._deserialize(e),this.direction.fromArray(e.direction),this.kernel=e.kernel}}C([U("Direction",3,"PROPERTIES")],D_.prototype,"direction",null);C([U("Kernel",2,"PROPERTIES",{min:1,max:256})],D_.prototype,"kernel",null);B("BABYLON.NodeRenderGraphBlurPostProcessBlock",D_);class ls extends Qt{_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(k(()=>Promise.resolve().then(()=>j3),void 0))):t.push(k(()=>Promise.resolve().then(()=>OV),void 0))}constructor(e,t=null,i){super({...i,name:e,engine:t||mt.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:ls.FragmentUrl,uniforms:ls.Uniforms}),this.aberrationAmount=30,this.radialIntensity=0,this.direction=new Q(.707,.707),this.centerPosition=new Q(.5,.5)}bind(){super.bind();const e=this._drawWrapper.effect;e.setFloat("chromatic_aberration",this.aberrationAmount),e.setFloat("screen_width",this.screenWidth),e.setFloat("screen_height",this.screenHeight),e.setFloat("radialIntensity",this.radialIntensity),e.setFloat2("direction",this.direction.x,this.direction.y),e.setFloat2("centerPosition",this.centerPosition.x,this.centerPosition.y)}}ls.FragmentUrl="chromaticAberration";ls.Uniforms=["chromatic_aberration","screen_width","screen_height","direction","radialIntensity","centerPosition"];class Iw extends sr{constructor(e,t,i){super(e,t,i||new ls(e,t.engine))}record(e=!1,t,i){const r=super.record(e,t,i);return this.postProcess.screenWidth=this._sourceWidth,this.postProcess.screenHeight=this._sourceHeight,r}}class Wu extends Pr{get task(){return this._frameGraphTask}constructor(e,t,i){super(e,t,i),this._finalizeInputOutputRegistering(),this._frameGraphTask=new Iw(this.name,t,new ls(e,i.getEngine()))}get aberrationAmount(){return this._frameGraphTask.postProcess.aberrationAmount}set aberrationAmount(e){this._frameGraphTask.postProcess.aberrationAmount=e}get radialIntensity(){return this._frameGraphTask.postProcess.radialIntensity}set radialIntensity(e){this._frameGraphTask.postProcess.radialIntensity=e}get direction(){return this._frameGraphTask.postProcess.direction}set direction(e){this._frameGraphTask.postProcess.direction=e}getClassName(){return"NodeRenderGraphChromaticAberrationPostProcessBlock"}_dumpPropertiesCode(){const e=[];return e.push(`${this._codeVariableName}.aberrationAmount = ${this.aberrationAmount};`),e.push(`${this._codeVariableName}.radialIntensity = ${this.radialIntensity};`),e.push(`${this._codeVariableName}.direction = new BABYLON.Vector2(${this.direction.x}, ${this.direction.y});`),super._dumpPropertiesCode()+e.join(`
`)}serialize(){const e=super.serialize();return e.aberrationAmount=this.aberrationAmount,e.radialIntensity=this.radialIntensity,e.direction=this.direction.asArray(),e}_deserialize(e){super._deserialize(e),this.aberrationAmount=e.aberrationAmount,this.radialIntensity=e.radialIntensity,this.direction=Q.FromArray(e.direction)}}C([U("Amount",1,"PROPERTIES",{min:-1e3,max:1e3})],Wu.prototype,"aberrationAmount",null);C([U("Radial intensity",1,"PROPERTIES",{min:.1,max:5})],Wu.prototype,"radialIntensity",null);C([U("Direction",3,"PROPERTIES")],Wu.prototype,"direction",null);B("BABYLON.NodeRenderGraphChromaticAberrationPostProcessBlock",Wu);class yi extends Qt{_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(k(()=>Promise.resolve().then(()=>ek),void 0))):t.push(k(()=>Promise.resolve().then(()=>K3),void 0))}constructor(e,t=null,i){super({...i,name:e,engine:t||mt.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:yi.FragmentUrl,uniforms:yi.Uniforms,samplers:yi.Samplers,defines:i!=null&&i.depthNotNormalized?yi.DefinesDepthNotNormalized:void 0}),this.lensSize=50,this.fStop=1.4,this.focusDistance=2e3,this.focalLength=50}bind(){super.bind();const e=this.options,t=this._drawWrapper.effect;e.depthNotNormalized||t.setFloat2("cameraMinMaxZ",this.camera.minZ,this.camera.maxZ-this.camera.minZ);const r=this.lensSize/this.fStop*this.focalLength/(this.focusDistance-this.focalLength);t.setFloat("focusDistance",this.focusDistance),t.setFloat("cocPrecalculation",r)}}yi.FragmentUrl="circleOfConfusion";yi.Uniforms=["cameraMinMaxZ","focusDistance","cocPrecalculation"];yi.Samplers=["depthSampler"];yi.DefinesDepthNotNormalized="#define COC_DEPTH_NOT_NORMALIZED";class k0 extends sr{constructor(e,t,i){super(e,t,i||new yi(e,t.engine)),this.depthSamplingMode=2,this.onTexturesAllocatedObservable.add(r=>{r.setTextureSamplingMode(this.depthTexture,this.depthSamplingMode)})}record(e=!1){if(this.sourceTexture===void 0||this.depthTexture===void 0||this.camera===void 0)throw new Error(`FrameGraphCircleOfConfusionTask "${this.name}": sourceTexture, depthTexture and camera are required`);const t=super.record(e,void 0,i=>{this.postProcess.camera=this.camera,i.bindTextureHandle(this._postProcessDrawWrapper.effect,"depthSampler",this.depthTexture)});return t.addDependencies(this.depthTexture),t}}class to extends Pr{get task(){return this._frameGraphTask}constructor(e,t,i){super(e,t,i),this.registerInput("geomViewDepth",J.TextureViewDepth),this.registerInput("camera",J.Camera),this._finalizeInputOutputRegistering(),this._frameGraphTask=new k0(this.name,t,new yi(e,i.getEngine(),{depthNotNormalized:!0}))}get depthSamplingMode(){return this._frameGraphTask.depthSamplingMode}set depthSamplingMode(e){this._frameGraphTask.depthSamplingMode=e}get lensSize(){return this._frameGraphTask.postProcess.lensSize}set lensSize(e){this._frameGraphTask.postProcess.lensSize=e}get fStop(){return this._frameGraphTask.postProcess.fStop}set fStop(e){this._frameGraphTask.postProcess.fStop=e}get focusDistance(){return this._frameGraphTask.postProcess.focusDistance}set focusDistance(e){this._frameGraphTask.postProcess.focusDistance=e}get focalLength(){return this._frameGraphTask.postProcess.focalLength}set focalLength(e){this._frameGraphTask.postProcess.focalLength=e}getClassName(){return"NodeRenderGraphCircleOfConfusionPostProcessBlock"}get geomViewDepth(){return this._inputs[2]}get camera(){return this._inputs[3]}_buildBlock(e){var t,i;super._buildBlock(e),this._frameGraphTask.depthTexture=(t=this.geomViewDepth.connectedPoint)==null?void 0:t.value,this._frameGraphTask.camera=(i=this.camera.connectedPoint)==null?void 0:i.value}_dumpPropertiesCode(){const e=[];return e.push(`${this._codeVariableName}.lensSize = ${this.lensSize};`),e.push(`${this._codeVariableName}.fStop = ${this.fStop};`),e.push(`${this._codeVariableName}.focusDistance = ${this.focusDistance};`),e.push(`${this._codeVariableName}.focalLength = ${this.focalLength};`),e.push(`${this._codeVariableName}.depthSamplingMode = ${this.depthSamplingMode};`),super._dumpPropertiesCode()+e.join(`
`)}serialize(){const e=super.serialize();return e.lensSize=this.lensSize,e.fStop=this.fStop,e.focusDistance=this.focusDistance,e.focalLength=this.focalLength,e.depthSamplingMode=this.depthSamplingMode,e}_deserialize(e){super._deserialize(e),this.lensSize=e.lensSize,this.fStop=e.fStop,this.focusDistance=e.focusDistance,this.focalLength=e.focalLength,this.depthSamplingMode=e.depthSamplingMode}}C([U("Depth sampling mode",6,"PROPERTIES")],to.prototype,"depthSamplingMode",null);C([U("Lens size",1,"PROPERTIES")],to.prototype,"lensSize",null);C([U("F-Stop",1,"PROPERTIES")],to.prototype,"fStop",null);C([U("Focus distance",1,"PROPERTIES")],to.prototype,"focusDistance",null);C([U("Focal length",1,"PROPERTIES")],to.prototype,"focalLength",null);B("BABYLON.NodeRenderGraphCircleOfConfusionPostProcessBlock",to);class us extends Qt{_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(k(()=>Promise.resolve().then(()=>q3),void 0))):t.push(k(()=>Promise.resolve().then(()=>X3),void 0))}constructor(e,t=null,i){super({...i,name:e,engine:t||mt.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:us.FragmentUrl,samplers:us.Samplers})}}us.FragmentUrl="depthOfFieldMerge";us.Samplers=["circleOfConfusionSampler","blurStep0","blurStep1","blurStep2"];class Rw extends sr{constructor(e,t,i){super(e,t,i||new us(e,t.engine)),this.blurSteps=[],this.onTexturesAllocatedObservable.add(r=>{r.setTextureSamplingMode(this.blurSteps[this.blurSteps.length-1],2)})}record(e=!1){if(this.sourceTexture===void 0||this.circleOfConfusionTexture===void 0||this.blurSteps.length===0)throw new Error(`FrameGraphBloomMergeTask "${this.name}": sourceTexture, circleOfConfusionTexture and blurSteps are required`);this.postProcess.updateEffect("#define BLUR_LEVEL "+(this.blurSteps.length-1)+`
`);const t=super.record(e,void 0,i=>{i.bindTextureHandle(this._postProcessDrawWrapper.effect,"circleOfConfusionSampler",this.circleOfConfusionTexture),this.blurSteps.forEach((r,s)=>{i.bindTextureHandle(this._postProcessDrawWrapper.effect,"blurStep"+(this.blurSteps.length-s-1),r)})});return t.addDependencies(this.circleOfConfusionTexture),t.addDependencies(this.blurSteps),t}}class Mw extends It{constructor(e,t=null,i,r,s){super(e,t,i,r,{...s,defines:`#define DOF 1
`})}}class eS extends Va{constructor(e,t,i){super(e,t,i||new Mw(e,t.engine,new Q(1,0),10)),this.circleOfConfusionSamplingMode=2,this.onTexturesAllocatedObservable.add(r=>{r.setTextureSamplingMode(this.circleOfConfusionTexture,this.circleOfConfusionSamplingMode)})}record(e=!1){if(this.sourceTexture===void 0||this.circleOfConfusionTexture===void 0)throw new Error(`FrameGraphDepthOfFieldBlurTask "${this.name}": sourceTexture and circleOfConfusionTexture are required`);const t=super.record(e,void 0,i=>{i.bindTextureHandle(this._postProcessDrawWrapper.effect,"circleOfConfusionSampler",this.circleOfConfusionTexture)});return t.addDependencies(this.circleOfConfusionTexture),t}}var tS;(function(a){a[a.Low=0]="Low",a[a.Medium=1]="Medium",a[a.High=2]="High"})(tS||(tS={}));class z0{set focalLength(e){this._circleOfConfusion.focalLength=e}get focalLength(){return this._circleOfConfusion.focalLength}set fStop(e){this._circleOfConfusion.fStop=e}get fStop(){return this._circleOfConfusion.fStop}set focusDistance(e){this._circleOfConfusion.focusDistance=e}get focusDistance(){return this._circleOfConfusion.focusDistance}set lensSize(e){this._circleOfConfusion.lensSize=e}get lensSize(){return this._circleOfConfusion.lensSize}constructor(e,t,i=0,r=!1,s=!1){this._depthOfFieldBlurX=[],this._depthOfFieldBlurY=[],this._circleOfConfusion=new yi(e,t,{depthNotNormalized:r,blockCompilation:s}),this.blurLevel=i;let n=1,o=15;switch(i){case 2:{n=3,o=51;break}case 1:{n=2,o=31;break}default:{o=15,n=1;break}}const l=o/Math.pow(2,n-1);let u=1;for(let c=0;c<n;c++)this._depthOfFieldBlurY.push([new It(e,t,new Q(0,1),l,{blockCompilation:s}),u]),u=.75/Math.pow(2,c),this._depthOfFieldBlurX.push([new It(e,t,new Q(1,0),l,{blockCompilation:s}),u]);this._dofMerge=new us(e,t,{blockCompilation:s})}isReady(){let e=this._circleOfConfusion.isReady()&&this._dofMerge.isReady();for(let t=0;t<this._depthOfFieldBlurX.length;t++)e=e&&this._depthOfFieldBlurX[t][0].isReady()&&this._depthOfFieldBlurY[t][0].isReady();return e}}class iS extends zi{get name(){return this._name}set name(e){if(this._name=e,this._circleOfConfusion&&(this._circleOfConfusion.name=`${e} Circle of Confusion`),this._blurX)for(let t=0;t<this._blurX.length;t++)this._blurX[t].name=`${e} Blur X${t}`,this._blurY[t].name=`${e} Blur Y${t}`;this._merge&&(this._merge.name=`${e} Merge`)}constructor(e,t,i=0,r=!1){if(super(e,t),this.sourceSamplingMode=2,this.depthSamplingMode=2,this._blurX=[],this._blurY=[],this._engine=t.engine,this.hdr=r,this._defaultPipelineTextureType=0,r){const n=t.engine.getCaps();n.textureHalfFloatRender?this._defaultPipelineTextureType=2:n.textureFloatRender&&(this._defaultPipelineTextureType=1)}this.depthOfField=new z0(e,t.engine,i,!0),this._circleOfConfusion=new k0(`${e} Circle of Confusion`,this._frameGraph,this.depthOfField._circleOfConfusion);const s=this.depthOfField._depthOfFieldBlurX.length;for(let n=0;n<s;n++)this._blurX.push(new eS(`${e} Blur X${n}`,this._frameGraph,this.depthOfField._depthOfFieldBlurX[n][0])),this._blurY.push(new eS(`${e} Blur Y${n}`,this._frameGraph,this.depthOfField._depthOfFieldBlurY[n][0]));this._merge=new Rw(`${e} Merge`,this._frameGraph,this.depthOfField._dofMerge),this.onTexturesAllocatedObservable.add(n=>{this._circleOfConfusion.onTexturesAllocatedObservable.notifyObservers(n);for(let o=0;o<s;o++)this._blurX[o].onTexturesAllocatedObservable.notifyObservers(n),this._blurY[o].onTexturesAllocatedObservable.notifyObservers(n);this._merge.onTexturesAllocatedObservable.notifyObservers(n)}),this.outputTexture=this._frameGraph.textureManager.createDanglingHandle()}isReady(){return this.depthOfField.isReady()}record(){if(this.sourceTexture===void 0||this.depthTexture===void 0||this.camera===void 0)throw new Error("FrameGraphDepthOfFieldTask: sourceTexture, depthTexture and camera are required");const e=this._frameGraph.textureManager.getTextureDescription(this.sourceTexture),t={width:e.size.width,height:e.size.height},i=this._engine.isWebGPU||this._engine.version>1?6:5,r={size:t,options:{createMipMaps:!1,types:[this._defaultPipelineTextureType],formats:[i],samples:1,useSRGBBuffers:[!1],labels:[""]},sizeIsPercentage:!1},s=this._frameGraph.textureManager.createRenderTargetTexture(this._circleOfConfusion.name,r);this._circleOfConfusion.sourceTexture=this.sourceTexture,this._circleOfConfusion.depthTexture=this.depthTexture,this._circleOfConfusion.depthSamplingMode=this.depthSamplingMode,this._circleOfConfusion.camera=this.camera,this._circleOfConfusion.targetTexture=s,this._circleOfConfusion.record(!0),r.options.formats=[5];const n=[];for(let u=0;u<this._blurX.length;u++){const c=this.depthOfField._depthOfFieldBlurX[u][1];t.width=Math.floor(e.size.width*c)||1,t.height=Math.floor(e.size.height*c)||1,r.options.labels[0]="step "+(u+1);const h=this._frameGraph.textureManager.createRenderTargetTexture(this._blurY[u].name,r);this._blurY[u].sourceTexture=u===0?this.sourceTexture:this._blurX[u-1].outputTexture,this._blurY[u].sourceSamplingMode=2,this._blurY[u].circleOfConfusionTexture=s,this._blurY[u].targetTexture=h,this._blurY[u].record(!0);const d=this._frameGraph.textureManager.createRenderTargetTexture(this._blurX[u].name,r);this._blurX[u].sourceTexture=this._blurY[u].outputTexture,this._blurX[u].sourceSamplingMode=2,this._blurX[u].circleOfConfusionTexture=s,this._blurX[u].targetTexture=d,this._blurX[u].record(!0),n.push(d)}const o=this._frameGraph.textureManager.getTextureCreationOptions(this.sourceTexture);this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture,this.targetTexture,this._merge.name,o),this._merge.sourceTexture=this.sourceTexture,this._merge.sourceSamplingMode=this.sourceSamplingMode,this._merge.circleOfConfusionTexture=s,this._merge.blurSteps=n,this._merge.targetTexture=this.outputTexture,this._merge.record(!0);const l=this._frameGraph.addRenderPass(this.name+"_disabled",!0);l.addDependencies(this.sourceTexture),l.setRenderTarget(this.outputTexture),l.setExecuteFunc(u=>{u.copyTexture(this.sourceTexture)})}dispose(){this._circleOfConfusion.dispose();for(let e=0;e<this._blurX.length;e++)this._blurX[e].dispose(),this._blurY[e].dispose();this._merge.dispose(),super.dispose()}}class vn extends Pr{get task(){return this._frameGraphTask}constructor(e,t,i,r=0,s=!1){super(e,t,i),this._additionalConstructionParameters=[r,s],this.registerInput("geomViewDepth",J.TextureViewDepth),this.registerInput("camera",J.Camera),this._finalizeInputOutputRegistering(),this._frameGraphTask=new iS(this.name,t,r,s)}_createTask(e,t){const i=this._frameGraphTask.sourceSamplingMode,r=this._frameGraphTask.depthSamplingMode,s=this._frameGraphTask.depthOfField.focalLength,n=this._frameGraphTask.depthOfField.fStop,o=this._frameGraphTask.depthOfField.focusDistance,l=this._frameGraphTask.depthOfField.lensSize;this._frameGraphTask.dispose(),this._frameGraphTask=new iS(this.name,this._frameGraph,e,t),this._frameGraphTask.sourceSamplingMode=i,this._frameGraphTask.depthSamplingMode=r,this._frameGraphTask.depthOfField.focalLength=s,this._frameGraphTask.depthOfField.fStop=n,this._frameGraphTask.depthOfField.focusDistance=o,this._frameGraphTask.depthOfField.lensSize=l,this._additionalConstructionParameters=[e,t]}get blurLevel(){return this._frameGraphTask.depthOfField.blurLevel}set blurLevel(e){this._createTask(e,this._frameGraphTask.hdr)}get hdr(){return this._frameGraphTask.hdr}set hdr(e){this._createTask(this._frameGraphTask.depthOfField.blurLevel,e)}get depthSamplingMode(){return this._frameGraphTask.depthSamplingMode}set depthSamplingMode(e){this._frameGraphTask.depthSamplingMode=e}get focalLength(){return this._frameGraphTask.depthOfField.focalLength}set focalLength(e){this._frameGraphTask.depthOfField.focalLength=e}get fStop(){return this._frameGraphTask.depthOfField.fStop}set fStop(e){this._frameGraphTask.depthOfField.fStop=e}get focusDistance(){return this._frameGraphTask.depthOfField.focusDistance}set focusDistance(e){this._frameGraphTask.depthOfField.focusDistance=e}get lensSize(){return this._frameGraphTask.depthOfField.lensSize}set lensSize(e){this._frameGraphTask.depthOfField.lensSize=e}getClassName(){return"NodeRenderGraphDepthOfFieldPostProcessBlock"}get geomViewDepth(){return this._inputs[2]}get camera(){return this._inputs[3]}_buildBlock(e){var t,i;super._buildBlock(e),this.output.value=this._frameGraphTask.outputTexture,this._frameGraphTask.depthTexture=(t=this.geomViewDepth.connectedPoint)==null?void 0:t.value,this._frameGraphTask.camera=(i=this.camera.connectedPoint)==null?void 0:i.value}_dumpPropertiesCode(){const e=[];return e.push(`${this._codeVariableName}.lensSize = ${this.lensSize};`),e.push(`${this._codeVariableName}.fStop = ${this.fStop};`),e.push(`${this._codeVariableName}.focusDistance = ${this.focusDistance};`),e.push(`${this._codeVariableName}.focalLength = ${this.focalLength};`),e.push(`${this._codeVariableName}.depthSamplingMode = ${this.depthSamplingMode};`),super._dumpPropertiesCode()+e.join(`
`)}serialize(){const e=super.serialize();return e.lensSize=this.lensSize,e.fStop=this.fStop,e.focusDistance=this.focusDistance,e.focalLength=this.focalLength,e.depthSamplingMode=this.depthSamplingMode,e}_deserialize(e){super._deserialize(e),this.lensSize=e.lensSize,this.fStop=e.fStop,this.focusDistance=e.focusDistance,this.focalLength=e.focalLength,this.depthSamplingMode=e.depthSamplingMode}}C([U("Blur level",4,"PROPERTIES",{options:[{label:"Low",value:0},{label:"Medium",value:1},{label:"High",value:2}]})],vn.prototype,"blurLevel",null);C([U("HDR",0,"PROPERTIES")],vn.prototype,"hdr",null);C([U("Depth sampling mode",6,"PROPERTIES")],vn.prototype,"depthSamplingMode",null);C([U("Focal length",1,"PROPERTIES")],vn.prototype,"focalLength",null);C([U("F-Stop",1,"PROPERTIES")],vn.prototype,"fStop",null);C([U("Focus distance",1,"PROPERTIES")],vn.prototype,"focusDistance",null);C([U("Lens size",1,"PROPERTIES")],vn.prototype,"lensSize",null);B("BABYLON.NodeRenderGraphDepthOfFieldPostProcessBlock",vn);class U0 extends Pr{get task(){return this._frameGraphTask}constructor(e,t,i){super(e,t,i),this._finalizeInputOutputRegistering(),this._frameGraphTask=new V0(this.name,t,new zr(e,i.getEngine()))}get threshold(){return this._frameGraphTask.postProcess.threshold}set threshold(e){this._frameGraphTask.postProcess.threshold=e}getClassName(){return"NodeRenderGraphExtractHighlightsPostProcessBlock"}_dumpPropertiesCode(){const e=[];return e.push(`${this._codeVariableName}.threshold = ${this.threshold};`),super._dumpPropertiesCode()+e.join(`
`)}serialize(){const e=super.serialize();return e.threshold=this.threshold,e}_deserialize(e){super._deserialize(e),this.threshold=e.threshold}}C([U("Threshold",1,"PROPERTIES",{min:0,max:1})],U0.prototype,"threshold",null);B("BABYLON.NodeRenderGraphExtractHighlightsPostProcessBlock",U0);class Aw extends sr{constructor(e,t,i){super(e,t,i||new km(e,t.engine))}}class Dw extends sr{constructor(e,t,i){super(e,t,i||new ay(e,t.engine))}}class Ow extends Pr{get task(){return this._frameGraphTask}constructor(e,t,i){super(e,t,i),this._finalizeInputOutputRegistering(),this._frameGraphTask=new Aw(this.name,t,new km(e,i.getEngine()))}getClassName(){return"NodeRenderGraphPassPostProcessBlock"}}B("BABYLON.NodeRenderGraphPassPostProcessBlock",Ow);class ww extends Pr{get task(){return this._frameGraphTask}constructor(e,t,i){super(e,t,i),this._finalizeInputOutputRegistering(),this._frameGraphTask=new Dw(this.name,t,new ay(e,i.getEngine()))}getClassName(){return"NodeRenderGraphPassCubePostProcessBlock"}}B("BABYLON.NodeRenderGraphPassCubePostProcessBlock",ww);const Nw=$.Compose(new m(.5,.5,.5),re.Identity(),new m(.5,.5,.5)),Fw=$.Compose(new m(.5,.5,1),re.Identity(),new m(.5,.5,0));class yr extends Qt{_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(k(()=>Promise.resolve().then(()=>i3),void 0))):t.push(k(()=>Promise.resolve().then(()=>ZV),void 0))}get reflectivityThreshold(){return this._reflectivityThreshold}set reflectivityThreshold(e){e!==this._reflectivityThreshold&&(e===0&&this._reflectivityThreshold!==0||e!==0&&this._reflectivityThreshold===0?(this._reflectivityThreshold=e,this._updateEffectDefines()):this._reflectivityThreshold=e)}get useBlur(){return this._useBlur}set useBlur(e){this._useBlur!==e&&(this._useBlur=e,this._updateEffectDefines())}get enableSmoothReflections(){return this._enableSmoothReflections}set enableSmoothReflections(e){e!==this._enableSmoothReflections&&(this._enableSmoothReflections=e,this._updateEffectDefines())}get environmentTexture(){return this._environmentTexture}set environmentTexture(e){this._environmentTexture=e,this._updateEffectDefines()}get environmentTextureIsProbe(){return this._environmentTextureIsProbe}set environmentTextureIsProbe(e){this._environmentTextureIsProbe=e,this._updateEffectDefines()}get attenuateScreenBorders(){return this._attenuateScreenBorders}set attenuateScreenBorders(e){this._attenuateScreenBorders!==e&&(this._attenuateScreenBorders=e,this._updateEffectDefines())}get attenuateIntersectionDistance(){return this._attenuateIntersectionDistance}set attenuateIntersectionDistance(e){this._attenuateIntersectionDistance!==e&&(this._attenuateIntersectionDistance=e,this._updateEffectDefines())}get attenuateIntersectionIterations(){return this._attenuateIntersectionIterations}set attenuateIntersectionIterations(e){this._attenuateIntersectionIterations!==e&&(this._attenuateIntersectionIterations=e,this._updateEffectDefines())}get attenuateFacingCamera(){return this._attenuateFacingCamera}set attenuateFacingCamera(e){this._attenuateFacingCamera!==e&&(this._attenuateFacingCamera=e,this._updateEffectDefines())}get attenuateBackfaceReflection(){return this._attenuateBackfaceReflection}set attenuateBackfaceReflection(e){this._attenuateBackfaceReflection!==e&&(this._attenuateBackfaceReflection=e,this._updateEffectDefines())}get clipToFrustum(){return this._clipToFrustum}set clipToFrustum(e){this._clipToFrustum!==e&&(this._clipToFrustum=e,this._updateEffectDefines())}get useFresnel(){return this._useFresnel}set useFresnel(e){this._useFresnel!==e&&(this._useFresnel=e,this._updateEffectDefines())}get enableAutomaticThicknessComputation(){return this._enableAutomaticThicknessComputation}set enableAutomaticThicknessComputation(e){this._enableAutomaticThicknessComputation!==e&&(this._enableAutomaticThicknessComputation=e,this._updateEffectDefines())}get inputTextureColorIsInGammaSpace(){return this._inputTextureColorIsInGammaSpace}set inputTextureColorIsInGammaSpace(e){this._inputTextureColorIsInGammaSpace!==e&&(this._inputTextureColorIsInGammaSpace=e,this._updateEffectDefines())}get generateOutputInGammaSpace(){return this._generateOutputInGammaSpace}set generateOutputInGammaSpace(e){this._generateOutputInGammaSpace!==e&&(this._generateOutputInGammaSpace=e,this._updateEffectDefines())}get debug(){return this._debug}set debug(e){this._debug!==e&&(this._debug=e,this._updateEffectDefines())}get textureWidth(){return this._textureWidth}set textureWidth(e){this._textureWidth!==e&&(this._textureWidth=e)}get textureHeight(){return this._textureHeight}set textureHeight(e){this._textureHeight!==e&&(this._textureHeight=e)}get useScreenspaceDepth(){return this._useScreenspaceDepth}set useScreenspaceDepth(e){this._useScreenspaceDepth!==e&&(this._useScreenspaceDepth=e,this._updateEffectDefines())}get normalsAreInWorldSpace(){return this._normalsAreInWorldSpace}set normalsAreInWorldSpace(e){this._normalsAreInWorldSpace!==e&&(this._normalsAreInWorldSpace=e,this._updateEffectDefines())}get normalsAreUnsigned(){return this._normalsAreUnsigned}set normalsAreUnsigned(e){this._normalsAreUnsigned!==e&&(this._normalsAreUnsigned=e,this._updateEffectDefines())}constructor(e,t,i){super({...i,name:e,engine:t.getEngine()||mt.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:yr.FragmentUrl,uniforms:yr.Uniforms,samplers:yr.Samplers,shaderLanguage:t.getEngine().isWebGPU?1:0}),this.isSSRSupported=!0,this.maxDistance=1e3,this.step=1,this.thickness=.5,this.strength=1,this.reflectionSpecularFalloffExponent=1,this.maxSteps=1e3,this.roughnessFactor=.2,this.selfCollisionNumSkip=1,this._reflectivityThreshold=.04,this._useBlur=!1,this._enableSmoothReflections=!1,this._environmentTextureIsProbe=!1,this._attenuateScreenBorders=!0,this._attenuateIntersectionDistance=!0,this._attenuateIntersectionIterations=!0,this._attenuateFacingCamera=!1,this._attenuateBackfaceReflection=!1,this._clipToFrustum=!0,this._useFresnel=!1,this._enableAutomaticThicknessComputation=!1,this._inputTextureColorIsInGammaSpace=!0,this._generateOutputInGammaSpace=!0,this._debug=!1,this._textureWidth=0,this._textureHeight=0,this.camera=null,this._useScreenspaceDepth=!1,this._normalsAreInWorldSpace=!1,this._normalsAreUnsigned=!1,this._scene=t,this._updateEffectDefines()}bind(){super.bind();const e=this._drawWrapper.effect,t=this.camera;if(!t)return;const i=t.getViewMatrix(),r=t.getProjectionMatrix();r.invertToRef(V.Matrix[0]),i.invertToRef(V.Matrix[1]),e.setMatrix("projection",r),e.setMatrix("view",i),e.setMatrix("invView",V.Matrix[1]),e.setMatrix("invProjectionMatrix",V.Matrix[0]),e.setFloat("thickness",this.thickness),e.setFloat("reflectionSpecularFalloffExponent",this.reflectionSpecularFalloffExponent),e.setFloat("strength",this.strength),e.setFloat("stepSize",this.step),e.setFloat("maxSteps",this.maxSteps),e.setFloat("roughnessFactor",this.roughnessFactor),e.setFloat("nearPlaneZ",t.minZ),e.setFloat("farPlaneZ",t.maxZ),e.setFloat("maxDistance",this.maxDistance),e.setFloat("selfCollisionNumSkip",this.selfCollisionNumSkip),e.setFloat("reflectivityThreshold",this._reflectivityThreshold),$.ScalingToRef(this.textureWidth,this.textureHeight,1,V.Matrix[2]),r.multiplyToRef(this._scene.getEngine().isWebGPU?Fw:Nw,V.Matrix[3]),V.Matrix[3].multiplyToRef(V.Matrix[2],V.Matrix[4]),e.setMatrix("projectionPixel",V.Matrix[4]),this._environmentTexture&&(e.setTexture("envCubeSampler",this._environmentTexture),this._environmentTexture.boundingBoxSize&&(e.setVector3("vReflectionPosition",this._environmentTexture.boundingBoxPosition),e.setVector3("vReflectionSize",this._environmentTexture.boundingBoxSize)))}_updateEffectDefines(){const e=[];this.isSSRSupported&&e.push("#define SSR_SUPPORTED"),this._enableSmoothReflections&&e.push("#define SSRAYTRACE_ENABLE_REFINEMENT"),this._scene.useRightHandedSystem&&e.push("#define SSRAYTRACE_RIGHT_HANDED_SCENE"),this._useScreenspaceDepth&&e.push("#define SSRAYTRACE_SCREENSPACE_DEPTH"),this._environmentTexture&&(e.push("#define SSR_USE_ENVIRONMENT_CUBE"),this._environmentTexture.boundingBoxSize&&e.push("#define SSR_USE_LOCAL_REFLECTIONMAP_CUBIC"),this._environmentTexture.gammaSpace&&e.push("#define SSR_ENVIRONMENT_CUBE_IS_GAMMASPACE")),this._environmentTextureIsProbe&&e.push("#define SSR_INVERTCUBICMAP"),this._enableAutomaticThicknessComputation&&e.push("#define SSRAYTRACE_USE_BACK_DEPTHBUFFER"),this._attenuateScreenBorders&&e.push("#define SSR_ATTENUATE_SCREEN_BORDERS"),this._attenuateIntersectionDistance&&e.push("#define SSR_ATTENUATE_INTERSECTION_DISTANCE"),this._attenuateIntersectionIterations&&e.push("#define SSR_ATTENUATE_INTERSECTION_NUMITERATIONS"),this._attenuateFacingCamera&&e.push("#define SSR_ATTENUATE_FACING_CAMERA"),this._attenuateBackfaceReflection&&e.push("#define SSR_ATTENUATE_BACKFACE_REFLECTION"),this._clipToFrustum&&e.push("#define SSRAYTRACE_CLIP_TO_FRUSTUM"),this.useBlur&&e.push("#define SSR_USE_BLUR"),this._debug&&e.push("#define SSRAYTRACE_DEBUG"),this._inputTextureColorIsInGammaSpace&&e.push("#define SSR_INPUT_IS_GAMMA_SPACE"),this._generateOutputInGammaSpace&&e.push("#define SSR_OUTPUT_IS_GAMMA_SPACE"),this._useFresnel&&e.push("#define SSR_BLEND_WITH_FRESNEL"),this._reflectivityThreshold===0&&e.push("#define SSR_DISABLE_REFLECTIVITY_TEST"),this._normalsAreInWorldSpace&&e.push("#define SSR_NORMAL_IS_IN_WORLDSPACE"),this._normalsAreUnsigned&&e.push("#define SSR_DECODE_NORMAL"),this.camera&&this.camera.mode===1&&e.push("#define ORTHOGRAPHIC_CAMERA"),this.updateEffect(e.join(`
`))}}yr.FragmentUrl="screenSpaceReflection2";yr.Uniforms=["projection","invProjectionMatrix","view","invView","thickness","reflectionSpecularFalloffExponent","strength","stepSize","maxSteps","roughnessFactor","projectionPixel","nearPlaneZ","farPlaneZ","maxDistance","selfCollisionNumSkip","vReflectionPosition","vReflectionSize","backSizeFactor","reflectivityThreshold"];yr.Samplers=["textureSampler","normalSampler","reflectivitySampler","depthSampler","envCubeSampler","backDepthSampler"];class Ii extends Qt{_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(k(()=>Promise.resolve().then(()=>s3),void 0))):t.push(k(()=>Promise.resolve().then(()=>QV),void 0))}constructor(e,t=null,i,r,s){super({...s,name:e,engine:t||mt.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:Ii.FragmentUrl,uniforms:Ii.Uniforms,samplers:Ii.Samplers}),this.textureWidth=0,this.textureHeight=0,this.direction=new Q(1,0),this.blurStrength=.03,i!==void 0&&(this.direction=i),r!==void 0&&(this.blurStrength=r)}bind(){super.bind(),this._drawWrapper.effect.setFloat2("texelOffsetScale",1/this.textureWidth*this.direction.x*this.blurStrength,1/this.textureHeight*this.direction.y*this.blurStrength)}}Ii.FragmentUrl="screenSpaceReflection2Blur";Ii.Uniforms=["texelOffsetScale"];Ii.Samplers=["textureSampler"];class Ur extends Qt{_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(k(()=>Promise.resolve().then(()=>a3),void 0))):t.push(k(()=>Promise.resolve().then(()=>JV),void 0))}constructor(e,t=null,i){super({...i,name:e,engine:t||mt.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:Ur.FragmentUrl,uniforms:Ur.Uniforms,samplers:Ur.Samplers}),this.strength=1,this.reflectionSpecularFalloffExponent=1,this.camera=null,this._useFresnel=!1,this._useScreenspaceDepth=!1,this._inputTextureColorIsInGammaSpace=!0,this._generateOutputInGammaSpace=!0,this._debug=!1,this._reflectivityThreshold=.04,this._normalsAreInWorldSpace=!1,this._normalsAreUnsigned=!1,this._updateEffectDefines()}get useFresnel(){return this._useFresnel}set useFresnel(e){this._useFresnel!==e&&(this._useFresnel=e,this._updateEffectDefines())}get useScreenspaceDepth(){return this._useScreenspaceDepth}set useScreenspaceDepth(e){this._useScreenspaceDepth!==e&&(this._useScreenspaceDepth=e,this._updateEffectDefines())}get inputTextureColorIsInGammaSpace(){return this._inputTextureColorIsInGammaSpace}set inputTextureColorIsInGammaSpace(e){this._inputTextureColorIsInGammaSpace!==e&&(this._inputTextureColorIsInGammaSpace=e,this._updateEffectDefines())}get generateOutputInGammaSpace(){return this._generateOutputInGammaSpace}set generateOutputInGammaSpace(e){this._generateOutputInGammaSpace!==e&&(this._generateOutputInGammaSpace=e,this._updateEffectDefines())}get debug(){return this._debug}set debug(e){this._debug!==e&&(this._debug=e,this._updateEffectDefines())}get reflectivityThreshold(){return this._reflectivityThreshold}set reflectivityThreshold(e){e!==this._reflectivityThreshold&&(e===0&&this._reflectivityThreshold!==0||e!==0&&this._reflectivityThreshold===0?(this._reflectivityThreshold=e,this._updateEffectDefines()):this._reflectivityThreshold=e)}get normalsAreInWorldSpace(){return this._normalsAreInWorldSpace}set normalsAreInWorldSpace(e){this._normalsAreInWorldSpace!==e&&(this._normalsAreInWorldSpace=e,this._updateEffectDefines())}get normalsAreUnsigned(){return this._normalsAreUnsigned}set normalsAreUnsigned(e){this._normalsAreUnsigned!==e&&(this._normalsAreUnsigned=e,this._updateEffectDefines())}bind(){super.bind();const e=this._drawWrapper.effect;if(e.setFloat("strength",this.strength),e.setFloat("reflectionSpecularFalloffExponent",this.reflectionSpecularFalloffExponent),e.setFloat("reflectivityThreshold",this.reflectivityThreshold),this.useFresnel&&this.camera){const t=this.camera.getProjectionMatrix();t.invertToRef(V.Matrix[0]),e.setMatrix("projection",t),e.setMatrix("invProjectionMatrix",V.Matrix[0]),e.setMatrix("view",this.camera.getViewMatrix()),this.useScreenspaceDepth&&(e.setFloat("nearPlaneZ",this.camera.minZ),e.setFloat("farPlaneZ",this.camera.maxZ))}}_updateEffectDefines(){let e="";this._debug&&(e+=`#define SSRAYTRACE_DEBUG
`),this._inputTextureColorIsInGammaSpace&&(e+=`#define SSR_INPUT_IS_GAMMA_SPACE
`),this._generateOutputInGammaSpace&&(e+=`#define SSR_OUTPUT_IS_GAMMA_SPACE
`),this._useFresnel&&(e+=`#define SSR_BLEND_WITH_FRESNEL
`),this._useScreenspaceDepth&&(e+=`#define SSRAYTRACE_SCREENSPACE_DEPTH
`),this._reflectivityThreshold===0&&(e+=`#define SSR_DISABLE_REFLECTIVITY_TEST
`),this._normalsAreInWorldSpace&&(e+=`#define SSR_NORMAL_IS_IN_WORLDSPACE
`),this._normalsAreUnsigned&&(e+=`#define SSR_DECODE_NORMAL
`),this.updateEffect(e)}}Ur.FragmentUrl="screenSpaceReflection2BlurCombiner";Ur.Uniforms=["strength","reflectionSpecularFalloffExponent","reflectivityThreshold","projection","invProjectionMatrix","nearPlaneZ","farPlaneZ","view"];Ur.Samplers=["textureSampler","depthSampler","normalSampler","mainSampler","reflectivitySampler"];class G0{get isSSRSupported(){return this._ssrPostProcess.isSSRSupported}set isSSRSupported(e){this._ssrPostProcess.isSSRSupported=e}get maxDistance(){return this._ssrPostProcess.maxDistance}set maxDistance(e){this._ssrPostProcess.maxDistance=e}get step(){return this._ssrPostProcess.step}set step(e){this._ssrPostProcess.step=e}get thickness(){return this._ssrPostProcess.thickness}set thickness(e){this._ssrPostProcess.thickness=e}get strength(){return this._ssrPostProcess.strength}set strength(e){this._ssrPostProcess.strength=e,this._ssrBlurCombinerPostProcess.strength=e}get reflectionSpecularFalloffExponent(){return this._ssrPostProcess.reflectionSpecularFalloffExponent}set reflectionSpecularFalloffExponent(e){this._ssrPostProcess.reflectionSpecularFalloffExponent=e,this._ssrBlurCombinerPostProcess.reflectionSpecularFalloffExponent=e}get maxSteps(){return this._ssrPostProcess.maxSteps}set maxSteps(e){this._ssrPostProcess.maxSteps=e}get roughnessFactor(){return this._ssrPostProcess.roughnessFactor}set roughnessFactor(e){this._ssrPostProcess.roughnessFactor=e}get selfCollisionNumSkip(){return this._ssrPostProcess.selfCollisionNumSkip}set selfCollisionNumSkip(e){this._ssrPostProcess.selfCollisionNumSkip=e}get reflectivityThreshold(){return this._ssrPostProcess.reflectivityThreshold}set reflectivityThreshold(e){const t=this._ssrPostProcess.reflectivityThreshold;e!==t&&(this._ssrPostProcess.reflectivityThreshold=e,this._ssrBlurCombinerPostProcess.reflectivityThreshold=e)}get blurDispersionStrength(){return this._ssrBlurXPostProcess.blurStrength}set blurDispersionStrength(e){e!==this._ssrBlurXPostProcess.blurStrength&&(this._ssrPostProcess.useBlur=e>0,this._ssrBlurXPostProcess.blurStrength=e,this._ssrBlurYPostProcess.blurStrength=e)}get enableSmoothReflections(){return this._ssrPostProcess.enableSmoothReflections}set enableSmoothReflections(e){this._ssrPostProcess.enableSmoothReflections=e}get environmentTexture(){return this._ssrPostProcess.environmentTexture}set environmentTexture(e){this._ssrPostProcess.environmentTexture=e}get environmentTextureIsProbe(){return this._ssrPostProcess.environmentTextureIsProbe}set environmentTextureIsProbe(e){this._ssrPostProcess.environmentTextureIsProbe=e}get attenuateScreenBorders(){return this._ssrPostProcess.attenuateScreenBorders}set attenuateScreenBorders(e){this._ssrPostProcess.attenuateScreenBorders=e}get attenuateIntersectionDistance(){return this._ssrPostProcess.attenuateIntersectionDistance}set attenuateIntersectionDistance(e){this._ssrPostProcess.attenuateIntersectionDistance=e}get attenuateIntersectionIterations(){return this._ssrPostProcess.attenuateIntersectionIterations}set attenuateIntersectionIterations(e){this._ssrPostProcess.attenuateIntersectionIterations=e}get attenuateFacingCamera(){return this._ssrPostProcess.attenuateFacingCamera}set attenuateFacingCamera(e){this._ssrPostProcess.attenuateFacingCamera=e}get attenuateBackfaceReflection(){return this._ssrPostProcess.attenuateBackfaceReflection}set attenuateBackfaceReflection(e){this._ssrPostProcess.attenuateBackfaceReflection=e}get clipToFrustum(){return this._ssrPostProcess.clipToFrustum}set clipToFrustum(e){this._ssrPostProcess.clipToFrustum=e}get useFresnel(){return this._ssrPostProcess.useFresnel}set useFresnel(e){this._ssrPostProcess.useFresnel=e,this._ssrBlurCombinerPostProcess.useFresnel=e}get enableAutomaticThicknessComputation(){return this._ssrPostProcess.enableAutomaticThicknessComputation}set enableAutomaticThicknessComputation(e){this._ssrPostProcess.enableAutomaticThicknessComputation!==e&&(this._ssrPostProcess.enableAutomaticThicknessComputation=e)}get inputTextureColorIsInGammaSpace(){return this._ssrPostProcess.inputTextureColorIsInGammaSpace}set inputTextureColorIsInGammaSpace(e){this._ssrPostProcess.inputTextureColorIsInGammaSpace!==e&&(this._ssrPostProcess.inputTextureColorIsInGammaSpace=e,this._ssrBlurCombinerPostProcess.inputTextureColorIsInGammaSpace=e)}get generateOutputInGammaSpace(){return this._ssrPostProcess.generateOutputInGammaSpace}set generateOutputInGammaSpace(e){this._ssrPostProcess.generateOutputInGammaSpace!==e&&(this._ssrPostProcess.generateOutputInGammaSpace=e,this._ssrBlurCombinerPostProcess.generateOutputInGammaSpace=e)}get debug(){return this._ssrPostProcess.debug}set debug(e){this._ssrPostProcess.debug!==e&&(this._ssrPostProcess.debug=e,this._ssrBlurCombinerPostProcess.debug=e)}get camera(){return this._ssrPostProcess.camera}set camera(e){this._ssrPostProcess.camera=e,this._ssrBlurCombinerPostProcess.camera=e}get useScreenspaceDepth(){return this._ssrPostProcess.useScreenspaceDepth}set useScreenspaceDepth(e){this._ssrPostProcess.useScreenspaceDepth=e,this._ssrBlurCombinerPostProcess.useScreenspaceDepth=e}get normalsAreInWorldSpace(){return this._ssrPostProcess.normalsAreInWorldSpace}set normalsAreInWorldSpace(e){this._ssrPostProcess.normalsAreInWorldSpace=e,this._ssrBlurCombinerPostProcess.normalsAreInWorldSpace=e}get normalsAreUnsigned(){return this._ssrPostProcess.normalsAreUnsigned}set normalsAreUnsigned(e){this._ssrPostProcess.normalsAreUnsigned=e,this._ssrBlurCombinerPostProcess.normalsAreUnsigned=e}isReady(){return this._ssrPostProcess.isReady()&&this._ssrBlurXPostProcess.isReady()&&this._ssrBlurYPostProcess.isReady()&&this._ssrBlurCombinerPostProcess.isReady()}constructor(e,t){this.ssrDownsample=0,this.blurDownsample=0,this.name=e,this._scene=t,this._ssrPostProcess=new yr(this.name,this._scene),this._ssrBlurXPostProcess=new Ii(this.name+" BlurX",this._scene.getEngine(),new Q(1,0)),this._ssrBlurYPostProcess=new Ii(this.name+" BlurY",this._scene.getEngine(),new Q(0,1)),this._ssrBlurCombinerPostProcess=new Ur(this.name+" BlurCombiner",this._scene.getEngine()),this._ssrPostProcess.useBlur=this._ssrBlurXPostProcess.blurStrength>0}dispose(){var e,t,i,r;(e=this._ssrPostProcess)==null||e.dispose(),(t=this._ssrBlurXPostProcess)==null||t.dispose(),(i=this._ssrBlurYPostProcess)==null||i.dispose(),(r=this._ssrBlurCombinerPostProcess)==null||r.dispose()}}class Lw extends sr{constructor(e,t,i){super(e,t,i||new yr(e,t.scene)),this.onTexturesAllocatedObservable.add(r=>{r.setTextureSamplingMode(this.normalTexture,2),r.setTextureSamplingMode(this.depthTexture,2),r.setTextureSamplingMode(this.reflectivityTexture,2),this.backDepthTexture&&r.setTextureSamplingMode(this.backDepthTexture,1)})}record(e=!1){if(this.sourceTexture===void 0||this.normalTexture===void 0||this.depthTexture===void 0||this.reflectivityTexture===void 0||this.camera===void 0)throw new Error(`FrameGraphSSRTask "${this.name}": sourceTexture, normalTexture, depthTexture, reflectivityTexture and camera are required`);const t=super.record(e,void 0,i=>{this.postProcess.camera=this.camera,i.bindTextureHandle(this._postProcessDrawWrapper.effect,"normalSampler",this.normalTexture),i.bindTextureHandle(this._postProcessDrawWrapper.effect,"depthSampler",this.depthTexture),i.bindTextureHandle(this._postProcessDrawWrapper.effect,"reflectivitySampler",this.reflectivityTexture),this.backDepthTexture&&i.bindTextureHandle(this._postProcessDrawWrapper.effect,"backDepthSampler",this.backDepthTexture),this.postProcess.enableAutomaticThicknessComputation&&this._postProcessDrawWrapper.effect.setFloat("backSizeFactor",1)});return t.addDependencies([this.normalTexture,this.depthTexture,this.reflectivityTexture]),this.postProcess.textureWidth=this._sourceWidth,this.postProcess.textureHeight=this._sourceHeight,t}}class rS extends sr{constructor(e,t,i){super(e,t,i||new Ii(e,t.engine,new Q(1,0),.03))}record(e=!1,t,i){const r=super.record(e,t,i);return this.postProcess.textureWidth=this._sourceWidth,this.postProcess.textureHeight=this._sourceHeight,r}}class sS extends zi{get camera(){return this._camera}set camera(e){e!==this._camera&&(this._camera=e,this.ssr.camera=e)}get name(){return this._name}set name(e){this._name=e,this._ssr&&(this._ssr.name=`${e} SSR`),this._ssrBlurX&&(this._ssrBlurX.name=`${e} SSR Blur X`),this._ssrBlurY&&(this._ssrBlurY.name=`${e} SSR Blur Y`),this._ssrBlurCombiner&&(this._ssrBlurCombiner.name=`${e} SSR Blur Combiner`)}constructor(e,t,i=0){super(e,t),this.sourceSamplingMode=2,this.textureType=i,this.ssr=new G0(e,t.scene),this._ssr=new Lw(`${e} SSR`,this._frameGraph,this.ssr._ssrPostProcess),this._ssrBlurX=new rS(`${e} SSR Blur X`,this._frameGraph,this.ssr._ssrBlurXPostProcess),this._ssrBlurY=new rS(`${e} SSR Blur Y`,this._frameGraph,this.ssr._ssrBlurYPostProcess),this._ssrBlurCombiner=new sr(`${e} SSR Blur Combiner`,this._frameGraph,this.ssr._ssrBlurCombinerPostProcess),this.onTexturesAllocatedObservable.add(r=>{this._ssr.onTexturesAllocatedObservable.notifyObservers(r),this.ssr.blurDispersionStrength!==0&&(this._ssrBlurX.onTexturesAllocatedObservable.notifyObservers(r),this._ssrBlurY.onTexturesAllocatedObservable.notifyObservers(r),this._ssrBlurCombiner.onTexturesAllocatedObservable.notifyObservers(r))}),this.outputTexture=this._frameGraph.textureManager.createDanglingHandle()}isReady(){return this.ssr.isReady()}record(){if(this.sourceTexture===void 0||this.normalTexture===void 0||this.depthTexture===void 0||this.reflectivityTexture===void 0||this.camera===void 0)throw new Error(`FrameGraphSSRRenderingPipelineTask "${this.name}": sourceTexture, normalTexture, depthTexture, reflectivityTexture and camera are required`);const e=this._frameGraph.textureManager.getTextureDescription(this.sourceTexture);this._ssr.sourceTexture=this.sourceTexture,this._ssr.sourceSamplingMode=this.sourceSamplingMode,this._ssr.camera=this.camera,this._ssr.normalTexture=this.normalTexture,this._ssr.depthTexture=this.depthTexture,this._ssr.backDepthTexture=this.backDepthTexture,this._ssr.reflectivityTexture=this.reflectivityTexture;let t;const i={width:Math.floor(e.size.width/(this.ssr.ssrDownsample+1))||1,height:Math.floor(e.size.height/(this.ssr.ssrDownsample+1))||1},r={size:i,options:{createMipMaps:!1,types:[this.textureType],formats:[5],samples:1,useSRGBBuffers:[!1],labels:[""]},sizeIsPercentage:!1};if((this.ssr.blurDispersionStrength>0||!this.targetTexture)&&(t=this._frameGraph.textureManager.createRenderTargetTexture(this._ssr.name,r)),this.ssr.blurDispersionStrength===0)this._ssr.targetTexture=this.outputTexture,t!==void 0?this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture,t):this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture,this.targetTexture),this._ssr.record(!0);else{this._ssr.targetTexture=t,this._ssr.record(!0),i.width=Math.floor(e.size.width/(this.ssr.blurDownsample+1))||1,i.height=Math.floor(e.size.height/(this.ssr.blurDownsample+1))||1;const n=this._frameGraph.textureManager.getTextureCreationOptions(this.sourceTexture);this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture,this.targetTexture,this.name+" Output",n);const o=this._frameGraph.textureManager.createRenderTargetTexture(this._ssrBlurX.name,r);this._ssrBlurX.sourceTexture=t,this._ssrBlurX.sourceSamplingMode=2,this._ssrBlurX.targetTexture=o,this._ssrBlurX.record(!0);const l=this._frameGraph.textureManager.createRenderTargetTexture(this._ssrBlurY.name,r);this._ssrBlurY.sourceTexture=o,this._ssrBlurY.sourceSamplingMode=2,this._ssrBlurY.targetTexture=l,this._ssrBlurY.record(!0),this._ssrBlurCombiner.sourceTexture=this.sourceTexture,this._ssrBlurCombiner.sourceSamplingMode=this.sourceSamplingMode,this._ssrBlurCombiner.targetTexture=this.outputTexture,this._ssrBlurCombiner.record(!0,void 0,c=>{c.bindTextureHandle(this._ssrBlurCombiner.drawWrapper.effect,"mainSampler",this.sourceTexture),c.bindTextureHandle(this._ssrBlurCombiner.drawWrapper.effect,"textureSampler",l),c.bindTextureHandle(this._ssrBlurCombiner.drawWrapper.effect,"reflectivitySampler",this.reflectivityTexture),this.ssr.useFresnel&&(c.bindTextureHandle(this._ssrBlurCombiner.drawWrapper.effect,"normalSampler",this.normalTexture),c.bindTextureHandle(this._ssrBlurCombiner.drawWrapper.effect,"depthSampler",this.depthTexture))}).addDependencies(l)}const s=this._frameGraph.addRenderPass(this.name+"_disabled",!0);s.addDependencies(this.sourceTexture),s.setRenderTarget(this.outputTexture),s.setExecuteFunc(n=>{n.copyTexture(this.sourceTexture)})}dispose(){this._ssr.dispose(),this._ssrBlurX.dispose(),this._ssrBlurY.dispose(),this._ssrBlurCombiner.dispose(),this.ssr.dispose(),super.dispose()}}class Ot extends Pr{get task(){return this._frameGraphTask}constructor(e,t,i,r=0){super(e,t,i),this._additionalConstructionParameters=[r],this.registerInput("camera",J.Camera),this.registerInput("geomDepth",J.AutoDetect),this.registerInput("geomNormal",J.AutoDetect),this.registerInput("geomReflectivity",J.TextureReflectivity),this.registerInput("geomBackDepth",J.AutoDetect,!0),this.geomNormal.addExcludedConnectionPointFromAllowedTypes(J.TextureWorldNormal|J.TextureViewNormal),this.geomDepth.addExcludedConnectionPointFromAllowedTypes(J.TextureScreenDepth|J.TextureViewDepth),this.geomBackDepth.addExcludedConnectionPointFromAllowedTypes(J.TextureScreenDepth|J.TextureViewDepth),this._finalizeInputOutputRegistering(),this._frameGraphTask=new sS(this.name,t,r)}_createTask(e){const t=this.sourceSamplingMode,i=this.maxDistance,r=this.step,s=this.thickness,n=this.strength,o=this.reflectionSpecularFalloffExponent,l=this.maxSteps,u=this.roughnessFactor,c=this.selfCollisionNumSkip,h=this.reflectivityThreshold,d=this.ssrDownsample,f=this.blurDispersionStrength,p=this.blurDownsample,g=this.enableSmoothReflections,_=this.attenuateScreenBorders,S=this.attenuateIntersectionDistance,b=this.attenuateIntersectionIterations,y=this.attenuateFacingCamera,T=this.attenuateBackfaceReflection,v=this.clipToFrustum,E=this.enableAutomaticThicknessComputation,R=this.useFresnel,O=this.inputTextureColorIsInGammaSpace,w=this.generateOutputInGammaSpace,M=this.debug;this._frameGraphTask.dispose(),this._frameGraphTask=new sS(this.name,this._frameGraph,e),this.sourceSamplingMode=t,this.maxDistance=i,this.step=r,this.thickness=s,this.strength=n,this.reflectionSpecularFalloffExponent=o,this.maxSteps=l,this.roughnessFactor=u,this.selfCollisionNumSkip=c,this.reflectivityThreshold=h,this.ssrDownsample=d,this.blurDispersionStrength=f,this.blurDownsample=p,this.enableSmoothReflections=g,this.attenuateScreenBorders=_,this.attenuateIntersectionDistance=S,this.attenuateIntersectionIterations=b,this.attenuateFacingCamera=y,this.attenuateBackfaceReflection=T,this.clipToFrustum=v,this.useFresnel=R,this.enableAutomaticThicknessComputation=E,this.inputTextureColorIsInGammaSpace=O,this.generateOutputInGammaSpace=w,this.debug=M,this._additionalConstructionParameters=[e]}get textureType(){return this._frameGraphTask.textureType}set textureType(e){this._createTask(e)}get debug(){return this._frameGraphTask.ssr.debug}set debug(e){this._frameGraphTask.ssr.debug=e}get strength(){return this._frameGraphTask.ssr.strength}set strength(e){this._frameGraphTask.ssr.strength=e}get reflectionSpecularFalloffExponent(){return this._frameGraphTask.ssr.reflectionSpecularFalloffExponent}set reflectionSpecularFalloffExponent(e){this._frameGraphTask.ssr.reflectionSpecularFalloffExponent=e}get reflectivityThreshold(){return this._frameGraphTask.ssr.reflectivityThreshold}set reflectivityThreshold(e){this._frameGraphTask.ssr.reflectivityThreshold=e}get thickness(){return this._frameGraphTask.ssr.thickness}set thickness(e){this._frameGraphTask.ssr.thickness=e}get step(){return this._frameGraphTask.ssr.step}set step(e){this._frameGraphTask.ssr.step=e}get enableSmoothReflections(){return this._frameGraphTask.ssr.enableSmoothReflections}set enableSmoothReflections(e){this._frameGraphTask.ssr.enableSmoothReflections=e}get maxSteps(){return this._frameGraphTask.ssr.maxSteps}set maxSteps(e){this._frameGraphTask.ssr.maxSteps=e}get maxDistance(){return this._frameGraphTask.ssr.maxDistance}set maxDistance(e){this._frameGraphTask.ssr.maxDistance=e}get roughnessFactor(){return this._frameGraphTask.ssr.roughnessFactor}set roughnessFactor(e){this._frameGraphTask.ssr.roughnessFactor=e}get selfCollisionNumSkip(){return this._frameGraphTask.ssr.selfCollisionNumSkip}set selfCollisionNumSkip(e){this._frameGraphTask.ssr.selfCollisionNumSkip=e}get ssrDownsample(){return this._frameGraphTask.ssr.ssrDownsample}set ssrDownsample(e){this._frameGraphTask.ssr.ssrDownsample=e}get clipToFrustum(){return this._frameGraphTask.ssr.clipToFrustum}set clipToFrustum(e){this._frameGraphTask.ssr.clipToFrustum=e}get enableAutomaticThicknessComputation(){return this._frameGraphTask.ssr.enableAutomaticThicknessComputation}set enableAutomaticThicknessComputation(e){this._frameGraphTask.ssr.enableAutomaticThicknessComputation=e}get useFresnel(){return this._frameGraphTask.ssr.useFresnel}set useFresnel(e){this._frameGraphTask.ssr.useFresnel=e}get blurDispersionStrength(){return this._frameGraphTask.ssr.blurDispersionStrength}set blurDispersionStrength(e){this._frameGraphTask.ssr.blurDispersionStrength=e}get blurDownsample(){return this._frameGraphTask.ssr.blurDownsample}set blurDownsample(e){this._frameGraphTask.ssr.blurDownsample=e}get attenuateScreenBorders(){return this._frameGraphTask.ssr.attenuateScreenBorders}set attenuateScreenBorders(e){this._frameGraphTask.ssr.attenuateScreenBorders=e}get attenuateIntersectionDistance(){return this._frameGraphTask.ssr.attenuateIntersectionDistance}set attenuateIntersectionDistance(e){this._frameGraphTask.ssr.attenuateIntersectionDistance=e}get attenuateIntersectionIterations(){return this._frameGraphTask.ssr.attenuateIntersectionIterations}set attenuateIntersectionIterations(e){this._frameGraphTask.ssr.attenuateIntersectionIterations=e}get attenuateFacingCamera(){return this._frameGraphTask.ssr.attenuateFacingCamera}set attenuateFacingCamera(e){this._frameGraphTask.ssr.attenuateFacingCamera=e}get attenuateBackfaceReflection(){return this._frameGraphTask.ssr.attenuateBackfaceReflection}set attenuateBackfaceReflection(e){this._frameGraphTask.ssr.attenuateBackfaceReflection=e}get inputTextureColorIsInGammaSpace(){return this._frameGraphTask.ssr.inputTextureColorIsInGammaSpace}set inputTextureColorIsInGammaSpace(e){this._frameGraphTask.ssr.inputTextureColorIsInGammaSpace=e}get generateOutputInGammaSpace(){return this._frameGraphTask.ssr.generateOutputInGammaSpace}set generateOutputInGammaSpace(e){this._frameGraphTask.ssr.generateOutputInGammaSpace=e}getClassName(){return"NodeRenderGraphSSRPostProcessBlock"}get camera(){return this._inputs[2]}get geomDepth(){return this._inputs[3]}get geomNormal(){return this._inputs[4]}get geomReflectivity(){return this._inputs[5]}get geomBackDepth(){return this._inputs[6]}_buildBlock(e){var t,i,r,s,n;if(super._buildBlock(e),this._frameGraphTask.normalTexture=(t=this.geomNormal.connectedPoint)==null?void 0:t.value,this._frameGraphTask.depthTexture=(i=this.geomDepth.connectedPoint)==null?void 0:i.value,this._frameGraphTask.reflectivityTexture=(r=this.geomReflectivity.connectedPoint)==null?void 0:r.value,this._frameGraphTask.backDepthTexture=(s=this.geomBackDepth.connectedPoint)==null?void 0:s.value,this._frameGraphTask.camera=(n=this.camera.connectedPoint)==null?void 0:n.value,this.enableAutomaticThicknessComputation){if(!this._frameGraphTask.backDepthTexture)throw new Error(`SSR post process "${this.name}": Automatic thickness computation requires a back depth texture to be connected!`);const o=this.geomBackDepth.connectedPoint.ownerBlock;if(o.getClassName()==="NodeRenderGraphGeometryRendererBlock"){if(!o.reverseCulling)throw new Error(`SSR post process "${this.name}": Automatic thickness computation requires the geometry renderer block for the back depth texture to have reverse culling enabled!`);if(this._frameGraphTask.depthTexture&&this.geomDepth.connectedPoint.ownerBlock.getClassName()==="NodeRenderGraphGeometryRendererBlock"){const c=this.geomDepth.connectedPoint.type,h=this.geomBackDepth.connectedPoint.type;if(c!==h)throw new Error(`SSR post process "${this.name}": Automatic thickness computation requires that geomDepth and geomBackDepth have the same type (view or screen space depth)!`)}}}this.geomNormal.connectedPoint&&this.geomNormal.connectedPoint.type===J.TextureWorldNormal&&(this._frameGraphTask.ssr.normalsAreInWorldSpace=!0,this._frameGraphTask.ssr.normalsAreUnsigned=!0),this.geomDepth.connectedPoint&&this.geomDepth.connectedPoint.type===J.TextureScreenDepth&&(this._frameGraphTask.ssr.useScreenspaceDepth=!0)}_dumpPropertiesCode(){const e=[];return e.push(`${this._codeVariableName}.debug = ${this.debug};`),e.push(`${this._codeVariableName}.strength = ${this.strength};`),e.push(`${this._codeVariableName}.reflectionSpecularFalloffExponent = ${this.reflectionSpecularFalloffExponent};`),e.push(`${this._codeVariableName}.reflectivityThreshold = ${this.reflectivityThreshold};`),e.push(`${this._codeVariableName}.thickness = ${this.thickness};`),e.push(`${this._codeVariableName}.step = ${this.step};`),e.push(`${this._codeVariableName}.enableSmoothReflections = ${this.enableSmoothReflections};`),e.push(`${this._codeVariableName}.maxSteps = ${this.maxSteps};`),e.push(`${this._codeVariableName}.maxDistance = ${this.maxDistance};`),e.push(`${this._codeVariableName}.roughnessFactor = ${this.roughnessFactor};`),e.push(`${this._codeVariableName}.selfCollisionNumSkip = ${this.selfCollisionNumSkip};`),e.push(`${this._codeVariableName}.ssrDownsample = ${this.ssrDownsample};`),e.push(`${this._codeVariableName}.clipToFrustum = ${this.clipToFrustum};`),e.push(`${this._codeVariableName}.useFresnel = ${this.useFresnel};`),e.push(`${this._codeVariableName}.enableAutomaticThicknessComputation = ${this.enableAutomaticThicknessComputation};`),e.push(`${this._codeVariableName}.blurDispersionStrength = ${this.blurDispersionStrength};`),e.push(`${this._codeVariableName}.blurDownsample = ${this.blurDownsample};`),e.push(`${this._codeVariableName}.attenuateScreenBorders = ${this.attenuateScreenBorders};`),e.push(`${this._codeVariableName}.attenuateIntersectionDistance = ${this.attenuateIntersectionDistance};`),e.push(`${this._codeVariableName}.attenuateIntersectionIterations = ${this.attenuateIntersectionIterations};`),e.push(`${this._codeVariableName}.attenuateFacingCamera = ${this.attenuateFacingCamera};`),e.push(`${this._codeVariableName}.attenuateBackfaceReflection = ${this.attenuateBackfaceReflection};`),e.push(`${this._codeVariableName}.inputTextureColorIsInGammaSpace = ${this.inputTextureColorIsInGammaSpace};`),e.push(`${this._codeVariableName}.generateOutputInGammaSpace = ${this.generateOutputInGammaSpace};`),super._dumpPropertiesCode()+e.join(`
`)}serialize(){const e=super.serialize();return e.debug=this.debug,e.strength=this.strength,e.reflectionSpecularFalloffExponent=this.reflectionSpecularFalloffExponent,e.reflectivityThreshold=this.reflectivityThreshold,e.thickness=this.thickness,e.step=this.step,e.enableSmoothReflections=this.enableSmoothReflections,e.maxSteps=this.maxSteps,e.maxDistance=this.maxDistance,e.roughnessFactor=this.roughnessFactor,e.selfCollisionNumSkip=this.selfCollisionNumSkip,e.ssrDownsample=this.ssrDownsample,e.clipToFrustum=this.clipToFrustum,e.useFresnel=this.useFresnel,e.enableAutomaticThicknessComputation=this.enableAutomaticThicknessComputation,e.blurDispersionStrength=this.blurDispersionStrength,e.blurDownsample=this.blurDownsample,e.attenuateScreenBorders=this.attenuateScreenBorders,e.attenuateIntersectionDistance=this.attenuateIntersectionDistance,e.attenuateIntersectionIterations=this.attenuateIntersectionIterations,e.attenuateFacingCamera=this.attenuateFacingCamera,e.attenuateBackfaceReflection=this.attenuateBackfaceReflection,e.inputTextureColorIsInGammaSpace=this.inputTextureColorIsInGammaSpace,e.generateOutputInGammaSpace=this.generateOutputInGammaSpace,e}_deserialize(e){super._deserialize(e),this.debug=e.debug,this.strength=e.strength,this.reflectionSpecularFalloffExponent=e.reflectionSpecularFalloffExponent,this.reflectivityThreshold=e.reflectivityThreshold,this.thickness=e.thickness,this.step=e.step,this.enableSmoothReflections=e.enableSmoothReflections,this.maxSteps=e.maxSteps,this.maxDistance=e.maxDistance,this.roughnessFactor=e.roughnessFactor,this.selfCollisionNumSkip=e.selfCollisionNumSkip,this.ssrDownsample=e.ssrDownsample,this.clipToFrustum=e.clipToFrustum,this.useFresnel=e.useFresnel,this.enableAutomaticThicknessComputation=e.enableAutomaticThicknessComputation,this.blurDispersionStrength=e.blurDispersionStrength,this.blurDownsample=e.blurDownsample,this.attenuateScreenBorders=e.attenuateScreenBorders,this.attenuateIntersectionDistance=e.attenuateIntersectionDistance,this.attenuateIntersectionIterations=e.attenuateIntersectionIterations,this.attenuateFacingCamera=e.attenuateFacingCamera,this.attenuateBackfaceReflection=e.attenuateBackfaceReflection,this.inputTextureColorIsInGammaSpace=e.inputTextureColorIsInGammaSpace,this.generateOutputInGammaSpace=e.generateOutputInGammaSpace}}C([U("Texture type",8,"SSR")],Ot.prototype,"textureType",null);C([U("Debug",0,"SSR")],Ot.prototype,"debug",null);C([U("Strength",1,"SSR",{min:0,max:5})],Ot.prototype,"strength",null);C([U("Reflection exponent",1,"SSR",{min:0,max:5})],Ot.prototype,"reflectionSpecularFalloffExponent",null);C([U("Reflectivity threshold",1,"SSR",{min:0,max:1})],Ot.prototype,"reflectivityThreshold",null);C([U("Thickness",1,"SSR",{min:0,max:10})],Ot.prototype,"thickness",null);C([U("Step",2,"SSR",{min:1,max:50})],Ot.prototype,"step",null);C([U("Smooth reflections",0,"SSR")],Ot.prototype,"enableSmoothReflections",null);C([U("Max steps",2,"SSR",{min:1,max:3e3})],Ot.prototype,"maxSteps",null);C([U("Max distance",1,"SSR",{min:1,max:3e3})],Ot.prototype,"maxDistance",null);C([U("Roughness factor",1,"SSR",{min:0,max:1})],Ot.prototype,"roughnessFactor",null);C([U("Self collision skips",2,"SSR",{min:1,max:10})],Ot.prototype,"selfCollisionNumSkip",null);C([U("SSR downsample",2,"SSR",{min:0,max:5})],Ot.prototype,"ssrDownsample",null);C([U("Clip to frustum",0,"SSR")],Ot.prototype,"clipToFrustum",null);C([U("Automatic thickness computation",0,"SSR")],Ot.prototype,"enableAutomaticThicknessComputation",null);C([U("Use Fresnel",0,"SSR")],Ot.prototype,"useFresnel",null);C([U("Strength",1,"Blur",{min:0,max:.15})],Ot.prototype,"blurDispersionStrength",null);C([U("Blur downsample",2,"Blur",{min:0,max:5})],Ot.prototype,"blurDownsample",null);C([U("Screen borders",0,"Attenuations")],Ot.prototype,"attenuateScreenBorders",null);C([U("Distance",0,"Attenuations")],Ot.prototype,"attenuateIntersectionDistance",null);C([U("Step iterations",0,"Attenuations")],Ot.prototype,"attenuateIntersectionIterations",null);C([U("Facing camera",0,"Attenuations")],Ot.prototype,"attenuateFacingCamera",null);C([U("Backface reflections",0,"Attenuations")],Ot.prototype,"attenuateBackfaceReflection",null);C([U("Input is in gamma space",0,"Color space")],Ot.prototype,"inputTextureColorIsInGammaSpace",null);C([U("Output to gamma space",0,"Color space")],Ot.prototype,"generateOutputInGammaSpace",null);B("BABYLON.NodeRenderGraphSSRPostProcessBlock",Ot);class fr extends pi{get task(){return this._frameGraphTask}constructor(e,t,i){super(e,t,i),this.registerInput("light",J.ShadowLight),this.registerInput("objects",J.ObjectList),this.registerInput("camera",J.Camera),this._addDependenciesInput(),this.registerOutput("generator",J.ShadowGenerator),this.registerOutput("output",J.Texture)}get mapSize(){return this._frameGraphTask.mapSize}set mapSize(e){this._frameGraphTask.mapSize=e}get useFloat32TextureType(){return this._frameGraphTask.useFloat32TextureType}set useFloat32TextureType(e){this._frameGraphTask.useFloat32TextureType=e}get useRedTextureFormat(){return this._frameGraphTask.useRedTextureFormat}set useRedTextureFormat(e){this._frameGraphTask.useRedTextureFormat=e}get bias(){return this._frameGraphTask.bias}set bias(e){this._frameGraphTask.bias=e}get normalBias(){return this._frameGraphTask.normalBias}set normalBias(e){this._frameGraphTask.normalBias=e}get darkness(){return this._frameGraphTask.darkness}set darkness(e){this._frameGraphTask.darkness=e}get filter(){return this._frameGraphTask.filter}set filter(e){this._frameGraphTask.filter=e}get filteringQuality(){return this._frameGraphTask.filteringQuality}set filteringQuality(e){this._frameGraphTask.filteringQuality=e}get transparencyShadow(){return this._frameGraphTask.transparencyShadow}set transparencyShadow(e){this._frameGraphTask.transparencyShadow=e}get enableSoftTransparentShadow(){return this._frameGraphTask.enableSoftTransparentShadow}set enableSoftTransparentShadow(e){this._frameGraphTask.enableSoftTransparentShadow=e}get useOpacityTextureForTransparentShadow(){return this._frameGraphTask.useOpacityTextureForTransparentShadow}set useOpacityTextureForTransparentShadow(e){this._frameGraphTask.useOpacityTextureForTransparentShadow=e}getClassName(){return"NodeRenderGraphBaseShadowGeneratorBlock"}get light(){return this._inputs[0]}get objects(){return this._inputs[1]}get camera(){return this._inputs[2]}get generator(){return this._outputs[0]}get output(){return this._outputs[1]}_buildBlock(e){var t,i,r;super._buildBlock(e),this._frameGraphTask.light=(t=this.light.connectedPoint)==null?void 0:t.value,this._frameGraphTask.objectList=(i=this.objects.connectedPoint)==null?void 0:i.value,this._frameGraphTask.camera=(r=this.camera.connectedPoint)==null?void 0:r.value,this.generator.value=this._frameGraphTask,this.output.value=this._frameGraphTask.outputTexture}_dumpPropertiesCode(){const e=[];return e.push(`${this._codeVariableName}.mapSize = ${this.mapSize};`),e.push(`${this._codeVariableName}.useFloat32TextureType = ${this.useFloat32TextureType};`),e.push(`${this._codeVariableName}.useRedTextureFormat = ${this.useRedTextureFormat};`),e.push(`${this._codeVariableName}.bias = ${this.bias};`),e.push(`${this._codeVariableName}.normalBias = ${this.normalBias};`),e.push(`${this._codeVariableName}.darkness = ${this.darkness};`),e.push(`${this._codeVariableName}.filter = ${this.filter};`),e.push(`${this._codeVariableName}.filteringQuality = ${this.filteringQuality};`),e.push(`${this._codeVariableName}.transparencyShadow = ${this.transparencyShadow};`),e.push(`${this._codeVariableName}.enableSoftTransparentShadow = ${this.enableSoftTransparentShadow};`),e.push(`${this._codeVariableName}.useOpacityTextureForTransparentShadow = ${this.useOpacityTextureForTransparentShadow};`),super._dumpPropertiesCode()+e.join(`
`)}serialize(){const e=super.serialize();return e.mapSize=this.mapSize,e.useFloat32TextureType=this.useFloat32TextureType,e.useRedTextureFormat=this.useRedTextureFormat,e.bias=this.bias,e.normalBias=this.normalBias,e.darkness=this.darkness,e.filter=this.filter,e.filteringQuality=this.filteringQuality,e.transparencyShadow=this.transparencyShadow,e.enableSoftTransparentShadow=this.enableSoftTransparentShadow,e.useOpacityTextureForTransparentShadow=this.useOpacityTextureForTransparentShadow,e}_deserialize(e){super._deserialize(e),this.mapSize=e.mapSize,this.useFloat32TextureType=e.useFloat32TextureType,this.useRedTextureFormat=e.useRedTextureFormat,this.bias=e.bias,this.normalBias=e.normalBias,this.darkness=e.darkness,this.filter=e.filter,this.filteringQuality=e.filteringQuality,this.transparencyShadow=e.transparencyShadow,this.enableSoftTransparentShadow=e.enableSoftTransparentShadow,this.useOpacityTextureForTransparentShadow=e.useOpacityTextureForTransparentShadow}}C([U("Map size",4,"PROPERTIES",{options:[{label:"128",value:128},{label:"256",value:256},{label:"512",value:512},{label:"1024",value:1024},{label:"2048",value:2048},{label:"4096",value:4096},{label:"8192",value:8192}]})],fr.prototype,"mapSize",null);C([U("Use 32 bits float texture type",0,"PROPERTIES")],fr.prototype,"useFloat32TextureType",null);C([U("Use red texture format",0,"PROPERTIES")],fr.prototype,"useRedTextureFormat",null);C([U("Bias",1,"PROPERTIES",{min:0,max:1})],fr.prototype,"bias",null);C([U("Normal bias",1,"PROPERTIES",{min:0,max:1})],fr.prototype,"normalBias",null);C([U("Darkness",1,"PROPERTIES",{min:0,max:1})],fr.prototype,"darkness",null);C([U("Filter",4,"PROPERTIES",{options:[{label:"None",value:de.FILTER_NONE},{label:"Exponential",value:de.FILTER_EXPONENTIALSHADOWMAP},{label:"Poisson Sampling",value:de.FILTER_POISSONSAMPLING},{label:"Blur exponential",value:de.FILTER_BLUREXPONENTIALSHADOWMAP},{label:"Close exponential",value:de.FILTER_CLOSEEXPONENTIALSHADOWMAP},{label:"Blur close exponential",value:de.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP},{label:"PCF",value:de.FILTER_PCF},{label:"PCSS",value:de.FILTER_PCSS}]})],fr.prototype,"filter",null);C([U("Filter quality",4,"PROPERTIES",{options:[{label:"Low",value:de.QUALITY_LOW},{label:"Medium",value:de.QUALITY_MEDIUM},{label:"High",value:de.QUALITY_HIGH}]})],fr.prototype,"filteringQuality",null);C([U("Transparency shadow",0,"PROPERTIES")],fr.prototype,"transparencyShadow",null);C([U("Enable soft transparent shadows",0,"PROPERTIES")],fr.prototype,"enableSoftTransparentShadow",null);C([U("Use opacity texture for transparent shadows",0,"PROPERTIES")],fr.prototype,"useOpacityTextureForTransparentShadow",null);class Ls extends fr{get task(){return this._frameGraphTask}constructor(e,t,i){super(e,t,i),this._frameGraphTask=new N0(this.name,t,i)}get numCascades(){return this._frameGraphTask.numCascades}set numCascades(e){this._frameGraphTask.numCascades=e}get debug(){return this._frameGraphTask.debug}set debug(e){this._frameGraphTask.debug=e}get stabilizeCascades(){return this._frameGraphTask.stabilizeCascades}set stabilizeCascades(e){this._frameGraphTask.stabilizeCascades=e}get lambda(){return this._frameGraphTask.lambda}set lambda(e){this._frameGraphTask.lambda=e}get cascadeBlendPercentage(){return this._frameGraphTask.cascadeBlendPercentage}set cascadeBlendPercentage(e){this._frameGraphTask.cascadeBlendPercentage=e}get depthClamp(){return this._frameGraphTask.depthClamp}set depthClamp(e){this._frameGraphTask.depthClamp=e}get autoCalcDepthBounds(){return this._frameGraphTask.autoCalcDepthBounds}set autoCalcDepthBounds(e){this._frameGraphTask.autoCalcDepthBounds=e}get shadowMaxZ(){return this._frameGraphTask.shadowMaxZ}set shadowMaxZ(e){this._frameGraphTask.shadowMaxZ=e}getClassName(){return"NodeRenderGraphCascadedShadowGeneratorBlock"}_dumpPropertiesCode(){const e=[];return e.push(`${this._codeVariableName}.numCascades = ${this.numCascades};`),e.push(`${this._codeVariableName}.debug = ${this.debug};`),e.push(`${this._codeVariableName}.stabilizeCascades = ${this.stabilizeCascades};`),e.push(`${this._codeVariableName}.lambda = ${this.lambda};`),e.push(`${this._codeVariableName}.cascadeBlendPercentage = ${this.cascadeBlendPercentage};`),e.push(`${this._codeVariableName}.depthClamp = ${this.depthClamp};`),e.push(`${this._codeVariableName}.autoCalcDepthBounds = ${this.autoCalcDepthBounds};`),e.push(`${this._codeVariableName}.shadowMaxZ = ${this.shadowMaxZ};`),super._dumpPropertiesCode()+e.join(`
`)}serialize(){const e=super.serialize();return e.numCascades=this.numCascades,e.debug=this.debug,e.stabilizeCascades=this.stabilizeCascades,e.lambda=this.lambda,e.cascadeBlendPercentage=this.cascadeBlendPercentage,e.depthClamp=this.depthClamp,e.autoCalcDepthBounds=this.autoCalcDepthBounds,e.shadowMaxZ=this.shadowMaxZ,e}_deserialize(e){super._deserialize(e),this.numCascades=e.numCascades,this.debug=e.debug,this.stabilizeCascades=e.stabilizeCascades,this.lambda=e.lambda,this.cascadeBlendPercentage=e.cascadeBlendPercentage,this.depthClamp=e.depthClamp,this.autoCalcDepthBounds=e.autoCalcDepthBounds,this.shadowMaxZ=e.shadowMaxZ}}C([U("Number of cascades",4,"CSM PROPERTIES",{options:[{label:"2",value:2},{label:"3",value:3},{label:"4",value:4}]})],Ls.prototype,"numCascades",null);C([U("Debug mode",0,"CSM PROPERTIES")],Ls.prototype,"debug",null);C([U("Stabilize cascades",0,"CSM PROPERTIES")],Ls.prototype,"stabilizeCascades",null);C([U("Lambda",1,"CSM PROPERTIES",{min:0,max:1})],Ls.prototype,"lambda",null);C([U("Cascade blend",1,"CSM PROPERTIES",{min:0,max:1})],Ls.prototype,"cascadeBlendPercentage",null);C([U("Depth clamp",0,"CSM PROPERTIES")],Ls.prototype,"depthClamp",null);C([U("Auto-Calc depth bounds",0,"CSM PROPERTIES")],Ls.prototype,"autoCalcDepthBounds",null);C([U("Shadow maxZ",1,"CSM PROPERTIES")],Ls.prototype,"shadowMaxZ",null);B("BABYLON.NodeRenderGraphCascadedShadowGeneratorBlock",Ls);const Bw=[new xe(0,0,0,0),new xe(1,1,1,1),new xe(1e8,1e8,1e8,1e8)];class nS extends zi{get camera(){return this._camera}set camera(e){this._camera=e,this._renderer.activeCamera=this.camera}get reverseCulling(){return this._reverseCulling}set reverseCulling(e){this._reverseCulling=e;const t=Ui.GetConfiguration(this._renderer.renderPassId);t&&(t.reverseCulling=e)}get objectRenderer(){return this._renderer}get name(){return this._name}set name(e){this._name=e,this._renderer&&(this._renderer.name=e)}constructor(e,t,i,r){super(e,t),this.depthTest=!0,this.depthWrite=!0,this.size={width:100,height:100},this.sizeIsPercentage=!0,this.samples=1,this._reverseCulling=!1,this.dontRenderWhenMaterialDepthWriteIsDisabled=!0,this.textureDescriptions=[],this._scene=i,this._engine=this._scene.getEngine(),this._renderer=new Vm(e,i,r),this._renderer.renderSprites=!1,this._renderer.renderParticles=!1,this._renderer.customIsReadyFunction=(s,n,o)=>this.dontRenderWhenMaterialDepthWriteIsDisabled&&s.material&&s.material.disableDepthWrite?!!o:s.isReady(n===0),this._renderer.onBeforeRenderingManagerRenderObservable.add(()=>{this._renderer.options.doNotChangeAspectRatio||i.updateTransformMatrix(!0)}),this.name=e,this._clearAttachmentsLayout=new Map,this._allAttachmentsLayout=[],this.outputDepthTexture=this._frameGraph.textureManager.createDanglingHandle(),this.geometryViewDepthTexture=this._frameGraph.textureManager.createDanglingHandle(),this.geometryScreenDepthTexture=this._frameGraph.textureManager.createDanglingHandle(),this.geometryViewNormalTexture=this._frameGraph.textureManager.createDanglingHandle(),this.geometryWorldNormalTexture=this._frameGraph.textureManager.createDanglingHandle(),this.geometryLocalPositionTexture=this._frameGraph.textureManager.createDanglingHandle(),this.geometryWorldPositionTexture=this._frameGraph.textureManager.createDanglingHandle(),this.geometryAlbedoTexture=this._frameGraph.textureManager.createDanglingHandle(),this.geometryReflectivityTexture=this._frameGraph.textureManager.createDanglingHandle(),this.geometryVelocityTexture=this._frameGraph.textureManager.createDanglingHandle(),this.geometryLinearVelocityTexture=this._frameGraph.textureManager.createDanglingHandle()}get excludedSkinnedMeshFromVelocityTexture(){return Ui.GetConfiguration(this._renderer.renderPassId).excludedSkinnedMesh}isReady(){return this._renderer.isReadyForRendering(this._textureWidth,this._textureHeight)}record(){if(this.textureDescriptions.length===0||this.objectList===void 0)throw new Error(`FrameGraphGeometryRendererTask ${this.name}: object list and at least one geometry texture description must be provided`);this._renderer.renderList=this.objectList.meshes,this._renderer.particleSystemList=this.objectList.particleSystems;const e=this._createMultiRenderTargetTexture(),t=this._checkDepthTextureCompatibility();this._buildClearAttachmentsLayout(),this._registerForRenderPassId(this._renderer.renderPassId);const i=this._frameGraph.textureManager.getTextureDescription(e[0]);this._textureWidth=i.size.width,this._textureHeight=i.size.height,Ui.MarkAsDirty(this._renderer.renderPassId,this.objectList.meshes||this._scene.meshes);const r=this._frameGraph.addRenderPass(this.name);r.setRenderTarget(e);for(let n=0;n<this.textureDescriptions.length;n++){const o=this.textureDescriptions[n],l=e[n],u=Ui.GeometryTextureDescriptions.findIndex(h=>h.type===o.type);switch(Ui.GeometryTextureDescriptions[u].type){case 5:this._frameGraph.textureManager.resolveDanglingHandle(this.geometryViewDepthTexture,l);break;case 10:this._frameGraph.textureManager.resolveDanglingHandle(this.geometryScreenDepthTexture,l);break;case 6:this._frameGraph.textureManager.resolveDanglingHandle(this.geometryViewNormalTexture,l);break;case 8:this._frameGraph.textureManager.resolveDanglingHandle(this.geometryWorldNormalTexture,l);break;case 9:this._frameGraph.textureManager.resolveDanglingHandle(this.geometryLocalPositionTexture,l);break;case 1:this._frameGraph.textureManager.resolveDanglingHandle(this.geometryWorldPositionTexture,l);break;case 12:this._frameGraph.textureManager.resolveDanglingHandle(this.geometryAlbedoTexture,l);break;case 3:this._frameGraph.textureManager.resolveDanglingHandle(this.geometryReflectivityTexture,l);break;case 2:this._frameGraph.textureManager.resolveDanglingHandle(this.geometryVelocityTexture,l);break;case 11:this._frameGraph.textureManager.resolveDanglingHandle(this.geometryLinearVelocityTexture,l);break}}r.setRenderTargetDepth(this.depthTexture),r.setExecuteFunc(n=>{this._renderer.renderList=this.objectList.meshes,this._renderer.particleSystemList=this.objectList.particleSystems,n.setDepthStates(this.depthTest&&t,this.depthWrite&&t),this._clearAttachmentsLayout.forEach((o,l)=>{n.clearColorAttachments(Bw[l],o)}),n.bindAttachments(this._allAttachmentsLayout),n.render(this._renderer,this._textureWidth,this._textureHeight)});const s=this._frameGraph.addRenderPass(this.name+"_disabled",!0);s.setRenderTarget(e),s.setRenderTargetDepth(this.depthTexture),s.setExecuteFunc(n=>{})}dispose(){Ui.DeleteConfiguration(this._renderer.renderPassId),this._renderer.dispose(),super.dispose()}_createMultiRenderTargetTexture(){const e=[],t=[],i=[],r=[];for(let o=0;o<this.textureDescriptions.length;o++){const l=this.textureDescriptions[o],u=Ui.GeometryTextureDescriptions.findIndex(c=>c.type===l.type);if(u===-1)throw new Error(`FrameGraphGeometryRendererTask ${this.name}: unknown texture type ${l.type}`);e[o]=l.textureType,t[o]=l.textureFormat,i[o]=Ui.GeometryTextureDescriptions[u].name,r[o]=!1}const s=this._frameGraph.textureManager.createRenderTargetTexture(this.name,{size:this.size,sizeIsPercentage:this.sizeIsPercentage,options:{createMipMaps:!1,samples:this.samples,types:e,formats:t,useSRGBBuffers:r,labels:i}}),n=[];for(let o=0;o<this.textureDescriptions.length;o++)n.push(s+o);return n}_checkDepthTextureCompatibility(){let e=!1;if(this.depthTexture!==void 0){if(this.depthTexture===ar)throw new Error(`FrameGraphGeometryRendererTask ${this.name}: the depth/stencil back buffer is not allowed as a depth texture`);if(this._frameGraph.textureManager.getTextureDescription(this.depthTexture).options.samples!==this.samples)throw new Error(`FrameGraphGeometryRendererTask ${this.name}: the depth texture and the output texture must have the same number of samples`);this._frameGraph.textureManager.resolveDanglingHandle(this.outputDepthTexture,this.depthTexture),e=!0}return e}_buildClearAttachmentsLayout(){const e=new Map,t=[];for(let i=0;i<this.textureDescriptions.length;i++){const r=this.textureDescriptions[i],s=Ui.GeometryTextureDescriptions.findIndex(l=>l.type===r.type),n=Ui.GeometryTextureDescriptions[s];let o=e.get(n.clearType);if(o===void 0){o=[],e.set(n.clearType,o);for(let l=0;l<i;l++)o[l]=!1}e.forEach((l,u)=>{l.push(u===n.clearType)}),t.push(!0)}this._clearAttachmentsLayout=new Map,e.forEach((i,r)=>{this._clearAttachmentsLayout.set(r,this._engine.buildTextureLayout(i))}),this._allAttachmentsLayout=this._engine.buildTextureLayout(t)}_registerForRenderPassId(e){const t=Ui.CreateConfiguration(e);for(let i=0;i<this.textureDescriptions.length;i++){const r=this.textureDescriptions[i],s=Ui.GeometryTextureDescriptions.findIndex(o=>o.type===r.type),n=Ui.GeometryTextureDescriptions[s];t.defines[n.defineIndex]=i}t.reverseCulling=this.reverseCulling}}class Ct extends pi{get task(){return this._frameGraphTask}constructor(e,t,i,r=!0){super(e,t,i),this.viewDepthFormat=6,this.viewDepthType=1,this.screenDepthFormat=6,this.screenDepthType=1,this.viewNormalFormat=5,this.viewNormalType=2,this.worldNormalFormat=5,this.worldNormalType=0,this.localPositionFormat=5,this.localPositionType=2,this.worldPositionFormat=5,this.worldPositionType=2,this.albedoFormat=5,this.albedoType=0,this.reflectivityFormat=5,this.reflectivityType=0,this.velocityFormat=5,this.velocityType=0,this.linearVelocityFormat=5,this.linearVelocityType=0,this._additionalConstructionParameters=[r],this.registerInput("depth",J.AutoDetect,!0),this.registerInput("camera",J.Camera),this.registerInput("objects",J.ObjectList),this._addDependenciesInput(),this.registerOutput("outputDepth",J.BasedOnInput),this.registerOutput("geomViewDepth",J.TextureViewDepth),this.registerOutput("geomScreenDepth",J.TextureScreenDepth),this.registerOutput("geomViewNormal",J.TextureViewNormal),this.registerOutput("geomWorldNormal",J.TextureWorldNormal),this.registerOutput("geomLocalPosition",J.TextureLocalPosition),this.registerOutput("geomWorldPosition",J.TextureWorldPosition),this.registerOutput("geomAlbedo",J.TextureAlbedo),this.registerOutput("geomReflectivity",J.TextureReflectivity),this.registerOutput("geomVelocity",J.TextureVelocity),this.registerOutput("geomLinearVelocity",J.TextureLinearVelocity),this.depth.addExcludedConnectionPointFromAllowedTypes(J.TextureDepthStencilAttachment|J.TextureBackBufferDepthStencilAttachment),this.outputDepth._typeConnectionSource=this.depth,this._frameGraphTask=new nS(this.name,t,i,{doNotChangeAspectRatio:r})}get depthTest(){return this._frameGraphTask.depthTest}set depthTest(e){this._frameGraphTask.depthTest=e}get depthWrite(){return this._frameGraphTask.depthWrite}set depthWrite(e){this._frameGraphTask.depthWrite=e}get doNotChangeAspectRatio(){return this._frameGraphTask.objectRenderer.options.doNotChangeAspectRatio}set doNotChangeAspectRatio(e){const t=this._frameGraphTask.disabled,i=this.depthTest,r=this.depthWrite,s=this.width,n=this.height,o=this.sizeInPercentage,l=this.samples,u=this.reverseCulling,c=this.dontRenderWhenMaterialDepthWriteIsDisabled;this._frameGraphTask.dispose(),this._frameGraphTask=new nS(this.name,this._frameGraph,this._scene,{doNotChangeAspectRatio:e}),this._additionalConstructionParameters=[e],this.depthTest=i,this.depthWrite=r,this.width=s,this.height=n,this.sizeInPercentage=o,this.samples=l,this.reverseCulling=u,this.dontRenderWhenMaterialDepthWriteIsDisabled=c,this._frameGraphTask.disabled=t}get width(){return this._frameGraphTask.size.width}set width(e){this._frameGraphTask.size.width=e}get height(){return this._frameGraphTask.size.height}set height(e){this._frameGraphTask.size.height=e}get sizeInPercentage(){return this._frameGraphTask.sizeIsPercentage}set sizeInPercentage(e){this._frameGraphTask.sizeIsPercentage=e}get samples(){return this._frameGraphTask.samples}set samples(e){this._frameGraphTask.samples=e}get reverseCulling(){return this._frameGraphTask.reverseCulling}set reverseCulling(e){this._frameGraphTask.reverseCulling=e}get dontRenderWhenMaterialDepthWriteIsDisabled(){return this._frameGraphTask.dontRenderWhenMaterialDepthWriteIsDisabled}set dontRenderWhenMaterialDepthWriteIsDisabled(e){this._frameGraphTask.dontRenderWhenMaterialDepthWriteIsDisabled=e}getClassName(){return"NodeRenderGraphGeometryRendererBlock"}get depth(){return this._inputs[0]}get camera(){return this._inputs[1]}get objects(){return this._inputs[2]}get outputDepth(){return this._outputs[0]}get geomViewDepth(){return this._outputs[1]}get geomScreenDepth(){return this._outputs[2]}get geomViewNormal(){return this._outputs[3]}get geomWorldNormal(){return this._outputs[4]}get geomLocalPosition(){return this._outputs[5]}get geomWorldPosition(){return this._outputs[6]}get geomAlbedo(){return this._outputs[7]}get geomReflectivity(){return this._outputs[8]}get geomVelocity(){return this._outputs[9]}get geomLinearVelocity(){return this._outputs[10]}_buildBlock(e){var n,o,l;super._buildBlock(e);const t=[this.geomViewDepth.isConnected,this.geomScreenDepth.isConnected,this.geomViewNormal.isConnected,this.geomWorldNormal.isConnected,this.geomLocalPosition.isConnected,this.geomWorldPosition.isConnected,this.geomAlbedo.isConnected,this.geomReflectivity.isConnected,this.geomVelocity.isConnected,this.geomLinearVelocity.isConnected];if(t.every(u=>!u))throw new Error("NodeRenderGraphGeometryRendererBlock: At least one output geometry buffer must be connected");this.outputDepth.value=this._frameGraphTask.outputDepthTexture,this.geomViewDepth.value=this._frameGraphTask.geometryViewDepthTexture,this.geomScreenDepth.value=this._frameGraphTask.geometryScreenDepthTexture,this.geomViewNormal.value=this._frameGraphTask.geometryViewNormalTexture,this.geomWorldNormal.value=this._frameGraphTask.geometryWorldNormalTexture,this.geomLocalPosition.value=this._frameGraphTask.geometryLocalPositionTexture,this.geomWorldPosition.value=this._frameGraphTask.geometryWorldPositionTexture,this.geomAlbedo.value=this._frameGraphTask.geometryAlbedoTexture,this.geomReflectivity.value=this._frameGraphTask.geometryReflectivityTexture,this.geomVelocity.value=this._frameGraphTask.geometryVelocityTexture,this.geomLinearVelocity.value=this._frameGraphTask.geometryLinearVelocityTexture,this._frameGraphTask.depthTexture=(n=this.depth.connectedPoint)==null?void 0:n.value,this._frameGraphTask.camera=(o=this.camera.connectedPoint)==null?void 0:o.value,this._frameGraphTask.objectList=(l=this.objects.connectedPoint)==null?void 0:l.value,this._frameGraphTask.textureDescriptions=[];const i=[this.viewDepthFormat,this.screenDepthFormat,this.viewNormalFormat,this.worldNormalFormat,this.localPositionFormat,this.worldPositionFormat,this.albedoFormat,this.reflectivityFormat,this.velocityFormat,this.linearVelocityFormat],r=[this.viewDepthType,this.screenDepthType,this.viewNormalType,this.worldNormalType,this.localPositionType,this.worldPositionType,this.albedoType,this.reflectivityType,this.velocityType,this.linearVelocityType],s=[5,10,6,8,9,1,12,3,2,11];for(let u=0;u<t.length;u++)t[u]&&this._frameGraphTask.textureDescriptions.push({textureFormat:i[u],textureType:r[u],type:s[u]})}_dumpPropertiesCode(){const e=[];return e.push(`${this._codeVariableName}.depthTest = ${this.depthTest};`),e.push(`${this._codeVariableName}.depthWrite = ${this.depthWrite};`),e.push(`${this._codeVariableName}.samples = ${this.samples};`),e.push(`${this._codeVariableName}.reverseCulling = ${this.reverseCulling};`),e.push(`${this._codeVariableName}.dontRenderWhenMaterialDepthWriteIsDisabled = ${this.dontRenderWhenMaterialDepthWriteIsDisabled};`),e.push(`${this._codeVariableName}.viewDepthFormat = ${this.viewDepthFormat};`),e.push(`${this._codeVariableName}.viewDepthType = ${this.viewDepthType};`),e.push(`${this._codeVariableName}.screenDepthFormat = ${this.screenDepthFormat};`),e.push(`${this._codeVariableName}.screenDepthType = ${this.screenDepthType};`),e.push(`${this._codeVariableName}.localPositionFormat = ${this.localPositionFormat};`),e.push(`${this._codeVariableName}.localPositionType = ${this.localPositionType};`),e.push(`${this._codeVariableName}.worldPositionFormat = ${this.worldPositionFormat};`),e.push(`${this._codeVariableName}.worldPositionType = ${this.worldPositionType};`),e.push(`${this._codeVariableName}.viewNormalFormat = ${this.viewNormalFormat};`),e.push(`${this._codeVariableName}.viewNormalType = ${this.viewNormalType};`),e.push(`${this._codeVariableName}.worldNormalFormat = ${this.worldNormalFormat};`),e.push(`${this._codeVariableName}.worldNormalType = ${this.worldNormalType};`),e.push(`${this._codeVariableName}.albedoFormat = ${this.albedoFormat};`),e.push(`${this._codeVariableName}.albedoType = ${this.albedoType};`),e.push(`${this._codeVariableName}.reflectivityFormat = ${this.reflectivityFormat};`),e.push(`${this._codeVariableName}.reflectivityType = ${this.reflectivityType};`),e.push(`${this._codeVariableName}.velocityFormat = ${this.velocityFormat};`),e.push(`${this._codeVariableName}.velocityType = ${this.velocityType};`),e.push(`${this._codeVariableName}.linearVelocityFormat = ${this.linearVelocityFormat};`),e.push(`${this._codeVariableName}.linearVelocityType = ${this.linearVelocityType};`),super._dumpPropertiesCode()+e.join(`
`)}serialize(){const e=super.serialize();return e.depthTest=this.depthTest,e.depthWrite=this.depthWrite,e.samples=this.samples,e.reverseCulling=this.reverseCulling,e.dontRenderWhenMaterialDepthWriteIsDisabled=this.dontRenderWhenMaterialDepthWriteIsDisabled,e.viewDepthFormat=this.viewDepthFormat,e.viewDepthType=this.viewDepthType,e.screenDepthFormat=this.screenDepthFormat,e.screenDepthType=this.screenDepthType,e.localPositionFormat=this.localPositionFormat,e.localPositionType=this.localPositionType,e.worldPositionFormat=this.worldPositionFormat,e.worldPositionType=this.worldPositionType,e.viewNormalFormat=this.viewNormalFormat,e.viewNormalType=this.viewNormalType,e.worldNormalFormat=this.worldNormalFormat,e.worldNormalType=this.worldNormalType,e.albedoFormat=this.albedoFormat,e.albedoType=this.albedoType,e.reflectivityFormat=this.reflectivityFormat,e.reflectivityType=this.reflectivityType,e.velocityFormat=this.velocityFormat,e.velocityType=this.velocityType,e.linearVelocityFormat=this.linearVelocityFormat,e.linearVelocityType=this.linearVelocityType,e}_deserialize(e){super._deserialize(e),this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.samples=e.samples,this.reverseCulling=e.reverseCulling,this.dontRenderWhenMaterialDepthWriteIsDisabled=e.dontRenderWhenMaterialDepthWriteIsDisabled,this.viewDepthFormat=e.viewDepthFormat,this.viewDepthType=e.viewDepthType,this.screenDepthFormat=e.screenDepthFormat,this.screenDepthType=e.screenDepthType,this.localPositionFormat=e.localPositionFormat,this.localPositionType=e.localPositionType,this.worldPositionFormat=e.worldPositionFormat,this.worldPositionType=e.worldPositionType,this.viewNormalFormat=e.viewNormalFormat,this.viewNormalType=e.viewNormalType,this.worldNormalFormat=e.worldNormalFormat,this.worldNormalType=e.worldNormalType,this.albedoFormat=e.albedoFormat,this.albedoType=e.albedoType,this.reflectivityFormat=e.reflectivityFormat,this.reflectivityType=e.reflectivityType,this.velocityFormat=e.velocityFormat,this.velocityType=e.velocityType,this.linearVelocityFormat=e.linearVelocityFormat,this.linearVelocityType=e.linearVelocityType}}C([U("Depth test",0,"PROPERTIES")],Ct.prototype,"depthTest",null);C([U("Depth write",0,"PROPERTIES")],Ct.prototype,"depthWrite",null);C([U("Do not change aspect ratio",0,"PROPERTIES")],Ct.prototype,"doNotChangeAspectRatio",null);C([U("Texture width",2,"PROPERTIES")],Ct.prototype,"width",null);C([U("Texture height",2,"PROPERTIES")],Ct.prototype,"height",null);C([U("Size is in percentage",0,"PROPERTIES")],Ct.prototype,"sizeInPercentage",null);C([U("Samples",2,"PROPERTIES",{min:1,max:8})],Ct.prototype,"samples",null);C([U("Reverse culling",0,"PROPERTIES")],Ct.prototype,"reverseCulling",null);C([U("Don't render if material depth write is disabled",0,"PROPERTIES")],Ct.prototype,"dontRenderWhenMaterialDepthWriteIsDisabled",null);C([U("View depth format",7,"GEOMETRY BUFFERS")],Ct.prototype,"viewDepthFormat",void 0);C([U("View depth type",8,"GEOMETRY BUFFERS")],Ct.prototype,"viewDepthType",void 0);C([U("Screen depth format",7,"GEOMETRY BUFFERS")],Ct.prototype,"screenDepthFormat",void 0);C([U("Screen depth type",8,"GEOMETRY BUFFERS")],Ct.prototype,"screenDepthType",void 0);C([U("View normal format",7,"GEOMETRY BUFFERS")],Ct.prototype,"viewNormalFormat",void 0);C([U("View normal type",8,"GEOMETRY BUFFERS")],Ct.prototype,"viewNormalType",void 0);C([U("World normal format",7,"GEOMETRY BUFFERS")],Ct.prototype,"worldNormalFormat",void 0);C([U("World normal type",8,"GEOMETRY BUFFERS")],Ct.prototype,"worldNormalType",void 0);C([U("Local position format",7,"GEOMETRY BUFFERS")],Ct.prototype,"localPositionFormat",void 0);C([U("Local position type",8,"GEOMETRY BUFFERS")],Ct.prototype,"localPositionType",void 0);C([U("World position format",7,"GEOMETRY BUFFERS")],Ct.prototype,"worldPositionFormat",void 0);C([U("World position type",8,"GEOMETRY BUFFERS")],Ct.prototype,"worldPositionType",void 0);C([U("Albedo format",7,"GEOMETRY BUFFERS")],Ct.prototype,"albedoFormat",void 0);C([U("Albedo type",8,"GEOMETRY BUFFERS")],Ct.prototype,"albedoType",void 0);C([U("Reflectivity format",7,"GEOMETRY BUFFERS")],Ct.prototype,"reflectivityFormat",void 0);C([U("Reflectivity type",8,"GEOMETRY BUFFERS")],Ct.prototype,"reflectivityType",void 0);C([U("Velocity format",7,"GEOMETRY BUFFERS")],Ct.prototype,"velocityFormat",void 0);C([U("Velocity type",8,"GEOMETRY BUFFERS")],Ct.prototype,"velocityType",void 0);C([U("Linear velocity format",7,"GEOMETRY BUFFERS")],Ct.prototype,"linearVelocityFormat",void 0);C([U("Linear velocity type",8,"GEOMETRY BUFFERS")],Ct.prototype,"linearVelocityType",void 0);B("BABYLON.NodeRenderGraphGeometryRendererBlock",Ct);class Vw extends fr{constructor(e,t,i){super(e,t,i),this._frameGraphTask=new w0(this.name,t,i)}getClassName(){return"NodeRenderGraphShadowGeneratorBlock"}}B("BABYLON.NodeRenderGraphShadowGeneratorBlock",Vw);class kw{constructor(e,t=2,i=3,r=1,s=1){this._curIndex=0,this._sequence=[],this._numSamples=0,this.x=0,this.y=0,this._width=r,this._height=s,this._baseX=t,this._baseY=i,this._generateSequence(e),this.next()}regenerate(e){this._generateSequence(e),this.next()}setDimensions(e,t){this._width=e,this._height=t}next(){this.x=this._sequence[this._curIndex]/this._width,this.y=this._sequence[this._curIndex+1]/this._height,this._curIndex+=2,this._curIndex>=this._numSamples*2&&(this._curIndex=0)}_generateSequence(e){this._sequence=[],this._curIndex=0,this._numSamples=e;for(let t=1;t<=e;++t)this._sequence.push(this._halton(t,this._baseX)-.5,this._halton(t,this._baseY)-.5)}_halton(e,t){let i=1,r=0;for(;e>0;)i/=t,r+=i*(e%t),e=~~(e/t);return r}}class Rs extends Qt{_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(k(()=>Promise.resolve().then(()=>c3),void 0))):t.push(k(()=>Promise.resolve().then(()=>l3),void 0))}set samples(e){this._samples!==e&&(this._samples=e,this._hs.regenerate(e))}get samples(){return this._samples}get disabled(){return this._disabled}set disabled(e){this._disabled!==e&&(this._disabled=e,this._reset())}get textureWidth(){return this._textureWidth}set textureWidth(e){this._textureWidth!==e&&(this._textureWidth=e,this._reset())}get textureHeight(){return this._textureHeight}set textureHeight(e){this._textureHeight!==e&&(this._textureHeight=e,this._reset())}constructor(e,t=null,i){super({...i,name:e,engine:t||mt.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:Rs.FragmentUrl,uniforms:Rs.Uniforms,samplers:Rs.Samplers}),this._samples=8,this.factor=.05,this._disabled=!1,this._textureWidth=0,this._textureHeight=0,this.disableOnCameraMove=!0,this._firstUpdate=!0,this._hs=new kw(this.samples)}_reset(){this._hs.setDimensions(this._textureWidth/2,this._textureHeight/2),this._hs.next(),this._firstUpdate=!0}updateProjectionMatrix(){if(!this.disabled){if(this.camera&&!this.camera.hasMoved)if(this.camera.mode===Ze.PERSPECTIVE_CAMERA){const e=this.camera.getProjectionMatrix();e.setRowFromFloats(2,this._hs.x,this._hs.y,e.m[10],e.m[11])}else{const e=this.camera.getProjectionMatrix(!0);e.setRowFromFloats(3,this._hs.x+e.m[12],this._hs.y+e.m[13],e.m[14],e.m[15])}this._hs.next()}}bind(){var t;if(super.bind(),this.disabled)return;this._drawWrapper.effect.setFloat("factor",(t=this.camera)!=null&&t.hasMoved&&this.disableOnCameraMove||this._firstUpdate?1:this.factor),this._firstUpdate=!1}}Rs.FragmentUrl="taa";Rs.Uniforms=["factor"];Rs.Samplers=["historySampler"];class aS extends Ql{constructor(e,t,i,r){super(e,t,i,r),this.postProcess=new Rs(`${e} post-process`,i.getEngine()),this._postProcessDrawWrapper=this.postProcess.drawWrapper}record(){if(this.targetTexture===void 0||this.objectList===void 0)throw new Error(`FrameGraphTAAObjectRendererTask ${this.name}: destinationTexture and objectList are required`);if(this.targetTexture===Hi||this.depthTexture===ar)throw new Error(`FrameGraphTAAObjectRendererTask ${this.name}: the back buffer color/depth textures are not allowed. Use regular textures instead.`);this._renderer.renderList=this.objectList.meshes,this._renderer.particleSystemList=this.objectList.particleSystems;const e=this._frameGraph.textureManager.getTextureDescription(this.targetTexture);let t=!1;if(this.depthTexture!==void 0){if(this._frameGraph.textureManager.getTextureDescription(this.depthTexture).options.samples!==e.options.samples)throw new Error(`FrameGraphTAAObjectRendererTask ${this.name}: the depth texture and the output texture must have the same number of samples`);t=!0}this.postProcess.camera=this.camera,this.postProcess.textureWidth=e.size.width,this.postProcess.textureHeight=e.size.height;const i={size:e.size,options:{createMipMaps:e.options.createMipMaps,types:[2],formats:[5],samples:1,useSRGBBuffers:[!1],creationFlags:[0],labels:[""]},sizeIsPercentage:!1,isHistoryTexture:!0},r=this._frameGraph.textureManager.createRenderTargetTexture(`${this.name} history`,i);this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture,r),this.depthTexture!==void 0&&this._frameGraph.textureManager.resolveDanglingHandle(this.outputDepthTexture,this.depthTexture),this._textureWidth=e.size.width,this._textureHeight=e.size.height;let s;this._setLightsForShadow();const n=this._frameGraph.addRenderPass(this.name);n.setRenderTarget(this.targetTexture),n.setRenderTargetDepth(this.depthTexture),n.setExecuteFunc(l=>{this._renderer.renderList=this.objectList.meshes,this._renderer.particleSystemList=this.objectList.particleSystems,this._renderer.renderInLinearSpace=this.renderInLinearSpace,this.postProcess.updateProjectionMatrix(),l.setDepthStates(this.depthTest&&t,this.depthWrite&&t),this.postProcess.disabled||(this._scene.activeCamera=this.camera,this._scene.setTransformMatrix(this.camera.getViewMatrix(),this.camera.getProjectionMatrix())),l.render(this._renderer,this._textureWidth,this._textureHeight),this._scene.activeCamera=null,s=s||l.createRenderTarget(`${this.name} ping/pong`,r),l.bindRenderTarget(s,"frame graph - TAA merge with history texture"),this.postProcess.disabled?l.copyTexture(this.targetTexture):l.applyFullScreenEffect(this._postProcessDrawWrapper,()=>{this.postProcess.bind(),l.bindTextureHandle(this._postProcessDrawWrapper.effect,"textureSampler",this.targetTexture),l.bindTextureHandle(this._postProcessDrawWrapper.effect,"historySampler",r)})});const o=this._frameGraph.addRenderPass(this.name+"_disabled",!0);return o.setRenderTarget(this.outputTexture),o.setRenderTargetDepth(this.depthTexture),o.setExecuteFunc(l=>{l.copyTexture(this.targetTexture)}),n}}class io extends ms{get task(){return this._frameGraphTask}constructor(e,t,i,r=!0){super(e,t,i),this._additionalConstructionParameters=[r],this._frameGraphTask=new aS(this.name,t,i,{doNotChangeAspectRatio:r})}get doNotChangeAspectRatio(){return this._frameGraphTask.objectRenderer.options.doNotChangeAspectRatio}set doNotChangeAspectRatio(e){const t=this._frameGraphTask.disabled;this._frameGraphTask.dispose(),this._frameGraphTask=new aS(this.name,this._frameGraph,this._scene,{doNotChangeAspectRatio:e}),this._additionalConstructionParameters=[e],this._frameGraphTask.disabled=t}get samples(){return this._frameGraphTask.postProcess.samples}set samples(e){this._frameGraphTask.postProcess.samples=e}get factor(){return this._frameGraphTask.postProcess.factor}set factor(e){this._frameGraphTask.postProcess.factor=e}get disableOnCameraMove(){return this._frameGraphTask.postProcess.disableOnCameraMove}set disableOnCameraMove(e){this._frameGraphTask.postProcess.disableOnCameraMove=e}get disableTAA(){return this._frameGraphTask.postProcess.disabled}set disableTAA(e){this._frameGraphTask.postProcess.disabled=e}getClassName(){return"NodeRenderGraphTAAObjectRendererBlock"}_dumpPropertiesCode(){const e=[];return e.push(`${this._codeVariableName}.doNotChangeAspectRatio = ${this.doNotChangeAspectRatio};`),e.push(`${this._codeVariableName}.samples = ${this.samples};`),e.push(`${this._codeVariableName}.factor = ${this.factor};`),e.push(`${this._codeVariableName}.disableOnCameraMove = ${this.disableOnCameraMove};`),e.push(`${this._codeVariableName}.disableTAA = ${this.disableTAA};`),super._dumpPropertiesCode()+e.join(`
`)}serialize(){const e=super.serialize();return e.doNotChangeAspectRatio=this.doNotChangeAspectRatio,e.samples=this.samples,e.factor=this.factor,e.disableOnCameraMove=this.disableOnCameraMove,e.disableTAA=this.disableTAA,e}_deserialize(e){super._deserialize(e),this.doNotChangeAspectRatio=e.doNotChangeAspectRatio,this.samples=e.samples,this.factor=e.factor,this.disableOnCameraMove=e.disableOnCameraMove,this.disableTAA=e.disableTAA}}C([U("Do not change aspect ratio",0,"PROPERTIES")],io.prototype,"doNotChangeAspectRatio",null);C([U("Samples",2,"TEMPORAL ANTI-ALIASING")],io.prototype,"samples",null);C([U("Factor",1,"TEMPORAL ANTI-ALIASING")],io.prototype,"factor",null);C([U("Disable on camera move",0,"TEMPORAL ANTI-ALIASING")],io.prototype,"disableOnCameraMove",null);C([U("Disable TAA",0,"TEMPORAL ANTI-ALIASING")],io.prototype,"disableTAA",null);B("BABYLON.NodeRenderGraphTAAObjectRendererBlock",io);class oS extends zi{constructor(e,t,i,r=!0){super(e,t),this.layer=new gt(i,r,!0),this.layer.utilityLayerScene._useCurrentFrameBuffer=!0,this.outputTexture=this._frameGraph.textureManager.createDanglingHandle()}record(){if(!this.targetTexture||!this.camera)throw new Error("FrameGraphUtilityLayerRendererTask: targetTexture and camera are required");this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture,this.targetTexture);const e=this._frameGraph.addRenderPass(this.name);e.setRenderTarget(this.outputTexture),e.setExecuteFunc(i=>{this.layer.setRenderCamera(this.camera),i.render(this.layer)});const t=this._frameGraph.addRenderPass(this.name+"_disabled",!0);t.setRenderTarget(this.outputTexture),t.setExecuteFunc(i=>{})}dispose(){this.layer.dispose(),super.dispose()}}class W0 extends pi{get task(){return this._frameGraphTask}constructor(e,t,i,r=!0){super(e,t,i),this._additionalConstructionParameters=[r],this.registerInput("target",J.AutoDetect),this.registerInput("camera",J.Camera),this._addDependenciesInput(),this.registerOutput("output",J.BasedOnInput),this.target.addExcludedConnectionPointFromAllowedTypes(J.TextureAll),this.output._typeConnectionSource=this.target,this._frameGraphTask=new oS(e,t,i,r)}_createTask(e){const t=this._frameGraphTask.disabled;this._frameGraphTask.dispose(),this._frameGraphTask=new oS(this.name,this._frameGraph,this._scene,e),this._additionalConstructionParameters=[e],this._frameGraphTask.disabled=t}get handleEvents(){return this._frameGraphTask.layer.handleEvents}set handleEvents(e){this._createTask(e)}getClassName(){return"NodeRenderGraphUtilityLayerRendererBlock"}get target(){return this._inputs[0]}get camera(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){var t,i;super._buildBlock(e),this.output.value=this._frameGraphTask.outputTexture,this._frameGraphTask.targetTexture=(t=this.target.connectedPoint)==null?void 0:t.value,this._frameGraphTask.camera=(i=this.camera.connectedPoint)==null?void 0:i.value}}C([U("Handle events",0,"PROPERTIES")],W0.prototype,"handleEvents",null);B("BABYLON.NodeRenderGraphUtilityLayerRendererBlock",W0);class zw extends pi{get endpoints(){return this._endpoints}constructor(e,t,i){super(e,t,i),this._endpoints=[],this._isTeleportIn=!0,this.registerInput("input",J.AutoDetect)}getClassName(){return"NodeRenderGraphTeleportInBlock"}get input(){return this._inputs[0]}_dumpCode(e,t){let i=super._dumpCode(e,t);for(const r of this.endpoints)t.indexOf(r)===-1&&(i+=r._dumpCode(e,t));return i}isAnAncestorOfType(e){if(this.getClassName()===e)return!0;for(const t of this.endpoints)if(t.isAnAncestorOfType(e))return!0;return!1}isAnAncestorOf(e){for(const t of this.endpoints)if(t===e||t.isAnAncestorOf(e))return!0;return!1}getDescendantOfPredicate(e){if(e(this))return this;for(const t of this.endpoints){const i=t.getDescendantOfPredicate(e);if(i)return i}return null}attachToEndpoint(e){e.detach(),this._endpoints.push(e),e._entryPoint=this,e._outputs[0]._typeConnectionSource=this._inputs[0],e._tempEntryPointUniqueId=null,e.name="> "+this.name}detachFromEndpoint(e){const t=this._endpoints.indexOf(e);t!==-1&&(this._endpoints.splice(t,1),e._outputs[0]._typeConnectionSource=null,e._entryPoint=null)}dispose(){super.dispose();for(const e of this._endpoints)this.detachFromEndpoint(e);this._endpoints=[]}}B("BABYLON.NodeRenderGraphTeleportInBlock",zw);class Uw extends pi{constructor(e,t,i){super(e,t,i),this._entryPoint=null,this._tempEntryPointUniqueId=null,this._isTeleportOut=!0,this.registerOutput("output",J.BasedOnInput)}get entryPoint(){return this._entryPoint}getClassName(){return"NodeRenderGraphTeleportOutBlock"}get output(){return this._outputs[0]}detach(){this._entryPoint&&this._entryPoint.detachFromEndpoint(this)}_buildBlock(){}_customBuildStep(e){this.entryPoint&&this.entryPoint.build(e)}_dumpCode(e,t){let i="";return this.entryPoint&&t.indexOf(this.entryPoint)===-1&&(i+=this.entryPoint._dumpCode(e,t)),i+super._dumpCode(e,t)}_dumpCodeForOutputConnections(e){let t=super._dumpCodeForOutputConnections(e);return this.entryPoint&&(t+=this.entryPoint._dumpCodeForOutputConnections(e)),t}clone(){const e=super.clone();return this.entryPoint&&this.entryPoint.attachToEndpoint(e),e}_dumpPropertiesCode(){let e=super._dumpPropertiesCode();return this.entryPoint&&(e+=`${this.entryPoint._codeVariableName}.attachToEndpoint(${this._codeVariableName});
`),e}serialize(){var t;const e=super.serialize();return e.entryPoint=((t=this.entryPoint)==null?void 0:t.uniqueId)??"",e}_deserialize(e){super._deserialize(e),this._tempEntryPointUniqueId=e.entryPoint}}B("BABYLON.NodeRenderGraphTeleportOutBlock",Uw);class Gw extends zi{constructor(e,t){super(e,t),this.outputTexture=this._frameGraph.textureManager.createDanglingHandle()}record(){if(this.sourceTexture===void 0||this.targetTexture===void 0)throw new Error(`FrameGraphCopyToTextureTask "${this.name}": sourceTexture and targetTexture are required`);this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture,this.targetTexture);const e=this._frameGraph.addRenderPass(this.name);e.addDependencies(this.sourceTexture),e.setRenderTarget(this.outputTexture),e.setExecuteFunc(i=>{i.copyTexture(this.sourceTexture)});const t=this._frameGraph.addRenderPass(this.name+"_disabled",!0);t.setRenderTarget(this.outputTexture),t.setExecuteFunc(i=>{})}}class Ww extends pi{get task(){return this._frameGraphTask}constructor(e,t,i){super(e,t,i),this.registerInput("source",J.AutoDetect),this.registerInput("target",J.AutoDetect),this._addDependenciesInput(),this.registerOutput("output",J.BasedOnInput),this.source.addExcludedConnectionPointFromAllowedTypes(J.TextureAllButBackBuffer),this.target.addExcludedConnectionPointFromAllowedTypes(J.TextureAll),this.output._typeConnectionSource=this.target,this._frameGraphTask=new Gw(e,t)}getClassName(){return"NodeRenderGraphCopyTextureBlock"}get source(){return this._inputs[0]}get target(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){var t,i;super._buildBlock(e),this.output.value=this._frameGraphTask.outputTexture,this._frameGraphTask.sourceTexture=(t=this.source.connectedPoint)==null?void 0:t.value,this._frameGraphTask.targetTexture=(i=this.target.connectedPoint)==null?void 0:i.value}}B("BABYLON.NodeRenderGraphCopyTextureBlock",Ww);class $w extends zi{constructor(e,t){super(e,t),this.outputTexture=this._frameGraph.textureManager.createDanglingHandle()}record(){if(this.targetTexture===void 0)throw new Error(`FrameGraphGenerateMipMapsTask ${this.name}: targetTexture is required`);if(this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture,this.targetTexture),!this._frameGraph.textureManager.getTextureDescription(this.targetTexture).options.createMipMaps)throw new Error(`FrameGraphGenerateMipMapsTask ${this.name}: targetTexture must have createMipMaps set to true`);const t=this._frameGraph.addRenderPass(this.name);t.setRenderTarget(this.outputTexture),t.setExecuteFunc(r=>{r.generateMipMaps()});const i=this._frameGraph.addRenderPass(this.name+"_disabled",!0);i.setRenderTarget(this.outputTexture),i.setExecuteFunc(r=>{})}}class Hw extends pi{get task(){return this._frameGraphTask}constructor(e,t,i){super(e,t,i),this.registerInput("target",J.AutoDetect),this._addDependenciesInput(),this.registerOutput("output",J.BasedOnInput),this.target.addExcludedConnectionPointFromAllowedTypes(J.TextureAllButBackBuffer),this.output._typeConnectionSource=this.target,this._frameGraphTask=new $w(e,t)}getClassName(){return"NodeRenderGraphGenerateMipmapsBlock"}get target(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){var t;super._buildBlock(e),this._propagateInputValueToOutput(this.target,this.output),this._frameGraphTask.targetTexture=(t=this.target.connectedPoint)==null?void 0:t.value}}B("BABYLON.NodeRenderGraphGenerateMipmapsBlock",Hw);class Ys extends ri{get coloredMaterial(){return this._coloredMaterial}get hoverMaterial(){return this._hoverMaterial}get disableMaterial(){return this._disableMaterial}constructor(e,t=ne.Gray(),i=gt.DefaultUtilityLayer,r=null,s=1,n=ne.Yellow(),o=ne.Gray()){var v,E,R,O,w,M,G;super(i),this._pointerObserver=null,this.snapDistance=0,this.onSnapObservable=new j,this.uniformScaling=!1,this.sensitivity=1,this.dragScale=1,this.incrementalSnap=!1,this._isEnabled=!0,this._parent=null,this._dragging=!1,this._tmpVector=new m(0,0,0),this._incrementalStartupValue=m.Zero(),this._parent=r,this._coloredMaterial=new Ut("",i.utilityLayerScene),this._coloredMaterial.diffuseColor=t,this._coloredMaterial.specularColor=t.subtract(new ne(.1,.1,.1)),this._hoverMaterial=new Ut("",i.utilityLayerScene),this._hoverMaterial.diffuseColor=n,this._disableMaterial=new Ut("",i.utilityLayerScene),this._disableMaterial.diffuseColor=o,this._disableMaterial.alpha=.4,this._gizmoMesh=new z("axis",i.utilityLayerScene);const{arrowMesh:l,arrowTail:u}=this._createGizmoMesh(this._gizmoMesh,s),c=this._createGizmoMesh(this._gizmoMesh,s+4,!0);this._gizmoMesh.lookAt(this._rootMesh.position.add(e)),this._rootMesh.addChild(this._gizmoMesh,ri.PreserveScaling),this._gizmoMesh.scaling.scaleInPlace(1/3);const h=l.position.clone(),d=u.position.clone(),f=u.scaling.clone(),p=H=>{const q=H*(3/this._rootMesh.scaling.length())*6;l.position.z+=q/3.5,u.scaling.y+=q,this.dragScale=u.scaling.y,u.position.z=l.position.z/2},g=()=>{l.position.set(h.x,h.y,h.z),u.position.set(d.x,d.y,d.z),u.scaling.set(f.x,f.y,f.z),this.dragScale=u.scaling.y,this._dragging=!1};this.dragBehavior=new gi({dragAxis:e}),this.dragBehavior.moveAttached=!1,this.dragBehavior.updateDragPlane=!1,this._rootMesh.addBehavior(this.dragBehavior);let _=0,S=0;const b={snapDistance:0};this.dragBehavior.onDragObservable.add(H=>{if(this.attachedNode){const q=this.sensitivity*H.dragDistance*(this.scaleRatio*3/this._rootMesh.scaling.length()),X=this._tmpVector;let ee=!1,oe=0;if(this.uniformScaling?X.setAll(.57735):X.copyFrom(e),this.snapDistance==0)X.scaleToRef(q,X);else{_+=q,S+=q;const ie=this.incrementalSnap?S:_;Math.abs(ie)>this.snapDistance?(oe=Math.floor(Math.abs(ie)/this.snapDistance),ie<0&&(oe*=-1),_=_%this.snapDistance,X.scaleToRef(this.snapDistance*oe,X),ee=!0):X.scaleInPlace(0)}X.addInPlaceFromFloats(1,1,1),X.x=Math.abs(X.x)<Ys.MinimumAbsoluteScale?Ys.MinimumAbsoluteScale*(X.x<0?-1:1):X.x,X.y=Math.abs(X.y)<Ys.MinimumAbsoluteScale?Ys.MinimumAbsoluteScale*(X.y<0?-1:1):X.y,X.z=Math.abs(X.z)<Ys.MinimumAbsoluteScale?Ys.MinimumAbsoluteScale*(X.z<0?-1:1):X.z;const _e=this.attachedNode._isMesh?this.attachedNode:void 0;Math.abs(this.snapDistance)>0&&this.incrementalSnap?(this.attachedNode.getWorldMatrix().decompose(void 0,V.Quaternion[0],V.Vector3[2],ri.PreserveScaling?_e:void 0),X.addInPlace(this._incrementalStartupValue),X.addInPlaceFromFloats(-1,-1,-1),X.x=Math.abs(X.x)*(this._incrementalStartupValue.x>0?1:-1),X.y=Math.abs(X.y)*(this._incrementalStartupValue.y>0?1:-1),X.z=Math.abs(X.z)*(this._incrementalStartupValue.z>0?1:-1),$.ComposeToRef(X,V.Quaternion[0],V.Vector3[2],V.Matrix[1])):($.ScalingToRef(X.x,X.y,X.z,V.Matrix[2]),V.Matrix[2].multiplyToRef(this.attachedNode.getWorldMatrix(),V.Matrix[1])),V.Matrix[1].decompose(V.Vector3[1],void 0,void 0,ri.PreserveScaling?_e:void 0);const te=1e5;Math.abs(V.Vector3[1].x)<te&&Math.abs(V.Vector3[1].y)<te&&Math.abs(V.Vector3[1].z)<te&&this.attachedNode.getWorldMatrix().copyFrom(V.Matrix[1]),ee&&(b.snapDistance=this.snapDistance*oe,this.onSnapObservable.notifyObservers(b)),this._matrixChanged()}}),this.dragBehavior.onDragStartObservable.add(()=>{var q;this._dragging=!0;const H=this.attachedNode._isMesh?this.attachedNode:void 0;(q=this.attachedNode)==null||q.getWorldMatrix().decompose(this._incrementalStartupValue,void 0,void 0,ri.PreserveScaling?H:void 0),_=0,S=0}),this.dragBehavior.onDragObservable.add(H=>p(H.dragDistance)),this.dragBehavior.onDragEndObservable.add(g),(R=(E=(v=r==null?void 0:r.uniformScaleGizmo)==null?void 0:v.dragBehavior)==null?void 0:E.onDragObservable)==null||R.add(H=>p(H.delta.y)),(M=(w=(O=r==null?void 0:r.uniformScaleGizmo)==null?void 0:O.dragBehavior)==null?void 0:w.onDragEndObservable)==null||M.add(g);const y={gizmoMeshes:[l,u],colliderMeshes:[c.arrowMesh,c.arrowTail],material:this._coloredMaterial,hoverMaterial:this._hoverMaterial,disableMaterial:this._disableMaterial,active:!1,dragBehavior:this.dragBehavior};(G=this._parent)==null||G.addToAxisCache(this._gizmoMesh,y),this._pointerObserver=i.utilityLayerScene.onPointerObservable.add(H=>{var X,ee,oe,_e;if(this._customMeshSet)return;let q=(X=this._parent)==null?void 0:X.getAxisCache(this._gizmoMesh);if(this._isHovered=!!q&&q.colliderMeshes.indexOf((ee=H==null?void 0:H.pickInfo)==null?void 0:ee.pickedMesh)!=-1,q=(oe=this._parent)==null?void 0:oe.getAxisCache(this._rootMesh),this._isHovered||(this._isHovered=!!q&&q.colliderMeshes.indexOf((_e=H==null?void 0:H.pickInfo)==null?void 0:_e.pickedMesh)!=-1),!this._parent){const te=this.dragBehavior.enabled?this._isHovered||this._dragging?this._hoverMaterial:this._coloredMaterial:this._disableMaterial;this._setGizmoMeshMaterial(y.gizmoMeshes,te)}}),this.dragBehavior.onEnabledObservable.add(H=>{this._setGizmoMeshMaterial(y.gizmoMeshes,H?this._coloredMaterial:this._disableMaterial)});const T=i._getSharedGizmoLight();T.includedOnlyMeshes=T.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes())}_createGizmoMesh(e,t,i=!1){const r=Xi("yPosMesh",{size:.4*(1+(t-1)/4)},this.gizmoLayer.utilityLayerScene),s=tr("cylinder",{diameterTop:.005*t,height:.275,diameterBottom:.005*t,tessellation:96},this.gizmoLayer.utilityLayerScene);return r.scaling.scaleInPlace(.1),r.material=this._coloredMaterial,r.rotation.x=Math.PI/2,r.position.z+=.3,s.material=this._coloredMaterial,s.position.z+=.275/2,s.rotation.x=Math.PI/2,i&&(r.visibility=0,s.visibility=0),e.addChild(r),e.addChild(s),{arrowMesh:r,arrowTail:s}}_attachedNodeChanged(e){this.dragBehavior&&(this.dragBehavior.enabled=!!e)}set isEnabled(e){this._isEnabled=e,e?this._parent&&(this.attachedMesh=this._parent.attachedMesh,this.attachedNode=this._parent.attachedNode):(this.attachedMesh=null,this.attachedNode=null)}get isEnabled(){return this._isEnabled}dispose(){this.onSnapObservable.clear(),this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver),this.dragBehavior.detach(),this._gizmoMesh&&this._gizmoMesh.dispose(),[this._coloredMaterial,this._hoverMaterial,this._disableMaterial].forEach(e=>{e&&e.dispose()}),super.dispose()}setCustomMesh(e,t=!1){super.setCustomMesh(e),t&&(this._rootMesh.getChildMeshes().forEach(i=>{i.material=this._coloredMaterial,i.color&&(i.color=this._coloredMaterial.diffuseColor)}),this._customMeshSet=!1)}}Ys.MinimumAbsoluteScale=He;var lS;(function(a){a[a.Rotation=0]="Rotation",a[a.Scaling=1]="Scaling"})(lS||(lS={}));class wW extends ri{set axisFactor(e){this._axisFactor=e;const t=this._scaleBoxesParent.getChildMeshes();let i=0;for(let r=0;r<3;r++)for(let s=0;s<3;s++)for(let n=0;n<3;n++){const o=(r===1?1:0)+(s===1?1:0)+(n===1?1:0);if(!(o===1||o===3)){if(t[i]){const l=new m(r-1,s-1,n-1);l.multiplyInPlace(this._axisFactor),t[i].setEnabled(l.lengthSquared()>He)}i++}}}get axisFactor(){return this._axisFactor}set scaleDragSpeed(e){this._scaleDragSpeed=e}get scaleDragSpeed(){return this._scaleDragSpeed}get coloredMaterial(){return this._coloredMaterial}get hoverMaterial(){return this._hoverColoredMaterial}get pointerDragBehavior(){return this._pointerDragBehavior}get isDragging(){return this._dragging||this._pointerDragBehavior.dragging}setColor(e){this._coloredMaterial.emissiveColor=e,this._hoverColoredMaterial.emissiveColor=e.clone().add(new ne(.3,.3,.3)),this._lineBoundingBox.getChildren().forEach(t=>{t.color&&(t.color=e)})}constructor(e=ne.Gray(),t=gt.DefaultKeepDepthUtilityLayer){super(t),this._boundingDimensions=new m(1,1,1),this._renderObserver=null,this._pointerObserver=null,this._scaleDragSpeed=.2,this._rotateAnchorsDragBehaviors=[],this._scaleBoxesDragBehaviors=[],this._dragging=!1,this._tmpQuaternion=new re,this._tmpVector=new m(0,0,0),this._tmpRotationMatrix=new $,this._incrementalStartupValue=m.Zero(),this._incrementalAnchorStartupValue=m.Zero(),this.ignoreChildren=!1,this.includeChildPredicate=null,this.rotationSphereSize=.1,this.scaleBoxSize=.1,this.fixedDragMeshScreenSize=!1,this.fixedDragMeshBoundsSize=!1,this.fixedDragMeshScreenSizeDistanceFactor=10,this.scalingSnapDistance=0,this.rotationSnapDistance=0,this.onDragStartObservable=new j,this.onHoverStartObservable=new j,this.onHoverEndObservable=new j,this.onScaleBoxDragObservable=new j,this.onScaleBoxDragEndObservable=new j,this.onRotationSphereDragObservable=new j,this.onRotationSphereDragEndObservable=new j,this.scalePivot=null,this._axisFactor=new m(1,1,1),this.incrementalSnap=!1,this._existingMeshScale=new m,this._dragMesh=null,this._pointerDragBehavior=new gi,this._cornerMesh=null,this.updateScale=!1,this._anchorMesh=new Bi("anchor",t.utilityLayerScene),this._coloredMaterial=new Ut("",t.utilityLayerScene),this._coloredMaterial.disableLighting=!0,this._hoverColoredMaterial=new Ut("",t.utilityLayerScene),this._hoverColoredMaterial.disableLighting=!0,this._lineBoundingBox=new Bi("",t.utilityLayerScene),this._lineBoundingBox.rotationQuaternion=new re;const i=[];i.push(ai("lines",{points:[new m(0,0,0),new m(this._boundingDimensions.x,0,0)]},t.utilityLayerScene)),i.push(ai("lines",{points:[new m(0,0,0),new m(0,this._boundingDimensions.y,0)]},t.utilityLayerScene)),i.push(ai("lines",{points:[new m(0,0,0),new m(0,0,this._boundingDimensions.z)]},t.utilityLayerScene)),i.push(ai("lines",{points:[new m(this._boundingDimensions.x,0,0),new m(this._boundingDimensions.x,this._boundingDimensions.y,0)]},t.utilityLayerScene)),i.push(ai("lines",{points:[new m(this._boundingDimensions.x,0,0),new m(this._boundingDimensions.x,0,this._boundingDimensions.z)]},t.utilityLayerScene)),i.push(ai("lines",{points:[new m(0,this._boundingDimensions.y,0),new m(this._boundingDimensions.x,this._boundingDimensions.y,0)]},t.utilityLayerScene)),i.push(ai("lines",{points:[new m(0,this._boundingDimensions.y,0),new m(0,this._boundingDimensions.y,this._boundingDimensions.z)]},t.utilityLayerScene)),i.push(ai("lines",{points:[new m(0,0,this._boundingDimensions.z),new m(this._boundingDimensions.x,0,this._boundingDimensions.z)]},t.utilityLayerScene)),i.push(ai("lines",{points:[new m(0,0,this._boundingDimensions.z),new m(0,this._boundingDimensions.y,this._boundingDimensions.z)]},t.utilityLayerScene)),i.push(ai("lines",{points:[new m(this._boundingDimensions.x,this._boundingDimensions.y,this._boundingDimensions.z),new m(0,this._boundingDimensions.y,this._boundingDimensions.z)]},t.utilityLayerScene)),i.push(ai("lines",{points:[new m(this._boundingDimensions.x,this._boundingDimensions.y,this._boundingDimensions.z),new m(this._boundingDimensions.x,0,this._boundingDimensions.z)]},t.utilityLayerScene)),i.push(ai("lines",{points:[new m(this._boundingDimensions.x,this._boundingDimensions.y,this._boundingDimensions.z),new m(this._boundingDimensions.x,this._boundingDimensions.y,0)]},t.utilityLayerScene)),i.forEach(s=>{s.color=e,s.position.addInPlace(new m(-this._boundingDimensions.x/2,-this._boundingDimensions.y/2,-this._boundingDimensions.z/2)),s.isPickable=!1,this._lineBoundingBox.addChild(s)}),this._rootMesh.addChild(this._lineBoundingBox),this.setColor(e),this._rotateAnchorsParent=new Bi("",t.utilityLayerScene),this._rotateAnchorsParent.rotationQuaternion=new re;for(let s=0;s<12;s++){const n=Xi("",{width:s<4||s>=8?1.6:.4,height:s>=4&&s<8?1.6:.4,depth:.4},t.utilityLayerScene);n.rotation.x=s<4||s>=8?Math.PI*.25:0,n.rotation.y=s>=4&&s<8?Math.PI*.25:0,n.bakeTransformIntoVertices(n.computeWorldMatrix(!0)),n.rotationQuaternion=new re,n.material=this._coloredMaterial,n.isNearGrabbable=!0;const o=new gi({});o.moveAttached=!1,o.updateDragPlane=!1,n.addBehavior(o);const l=new m(1,0,0);let u=0,c=0;o.onDragStartObservable.add(()=>{l.copyFrom(n.forward),u=0,c=0});const h=function(){const d=Math.floor(s/4);return V.Vector3[0].set(d==0?1:0,d==1?1:0,d==2?1:0),V.Vector3[0]};o.onDragObservable.add(d=>{if(this.onRotationSphereDragObservable.notifyObservers({dragOperation:0,dragAxis:h().clone()}),this.attachedMesh){const f=this.attachedMesh.parent;if(f&&f.scaling&&f.scaling.isNonUniformWithinEpsilon(.001)){L.Warn("BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling");return}Ke._RemoveAndStorePivotPoint(this.attachedMesh);const p=l,g=d.dragPlaneNormal.scale(m.Dot(d.dragPlaneNormal,p)),_=p.subtract(g).normalizeToNew();let S=m.Dot(_,d.delta)<0?Math.abs(d.delta.length()):-Math.abs(d.delta.length());if(S=S/this._boundingDimensions.length()*this._anchorMesh.scaling.length(),this.attachedMesh.rotationQuaternion||(this.attachedMesh.rotationQuaternion=re.RotationYawPitchRoll(this.attachedMesh.rotation.y,this.attachedMesh.rotation.x,this.attachedMesh.rotation.z)),this._anchorMesh.rotationQuaternion||(this._anchorMesh.rotationQuaternion=re.RotationYawPitchRoll(this._anchorMesh.rotation.y,this._anchorMesh.rotation.x,this._anchorMesh.rotation.z)),u+=S,Math.abs(u)<=2*Math.PI){if(this.rotationSnapDistance>0){const b=Math.floor(Math.abs(u)/this.rotationSnapDistance)*(u<0?-1:1),y=this.rotationSnapDistance*b;S=y-c,c=y}s>=8?re.RotationYawPitchRollToRef(0,0,S,this._tmpQuaternion):s>=4?re.RotationYawPitchRollToRef(S,0,0,this._tmpQuaternion):re.RotationYawPitchRollToRef(0,S,0,this._tmpQuaternion),this.attachedMesh.isUsingPivotMatrix()&&this._anchorMesh.position.copyFrom(this.attachedMesh.position),this._anchorMesh.addChild(this.attachedMesh),this._anchorMesh.getScene().useRightHandedSystem&&this._tmpQuaternion.conjugateInPlace(),this._tmpQuaternion.normalize(),this._anchorMesh.rotationQuaternion.multiplyToRef(this._tmpQuaternion,this._anchorMesh.rotationQuaternion),this._anchorMesh.rotationQuaternion.normalize(),this._anchorMesh.removeChild(this.attachedMesh),this.attachedMesh.setParent(f)}this.updateBoundingBox(),Ke._RestorePivotPoint(this.attachedMesh)}this._updateDummy()}),o.onDragStartObservable.add(()=>{this.onDragStartObservable.notifyObservers({dragOperation:0,dragAxis:h().clone()}),this._dragging=!0,this._selectNode(n)}),o.onDragEndObservable.add(d=>{this.onRotationSphereDragEndObservable.notifyObservers({dragOperation:0,dragAxis:h().clone()}),this._dragging=!1,this._selectNode(null),this._updateDummy(),this._unhoverMeshOnTouchUp(d.pointerInfo,n)}),this._rotateAnchorsDragBehaviors.push(o),this._rotateAnchorsParent.addChild(n)}this._rootMesh.addChild(this._rotateAnchorsParent),this._scaleBoxesParent=new Bi("",t.utilityLayerScene),this._scaleBoxesParent.rotationQuaternion=new re;for(let s=0;s<3;s++)for(let n=0;n<3;n++)for(let o=0;o<3;o++){const l=(s===1?1:0)+(n===1?1:0)+(o===1?1:0);if(l===1||l===3)continue;const u=l===2?Xi("",{size:1},t.utilityLayerScene):this._getCornerMesh(t);l===0&&(u.rotationQuaternion=re.FromEulerAngles(n*.25*Math.PI,(o+3*s-s*o)*.25*Math.PI,0)),u.material=this._coloredMaterial,u._internalMetadata=l===2,u.isNearGrabbable=!0,V.Vector3[0].set(s-1,n-1,o-1),V.Vector3[0].normalize(),u.computeWorldMatrix(!0).invertToRef(V.Matrix[0]);const c=m.TransformCoordinates(V.Vector3[0],V.Matrix[0]);c.normalize();const h=new gi({dragAxis:c});h.updateDragPlane=!1,h.moveAttached=!1;let d=0,f=0;u.addBehavior(h),h.onDragObservable.add(p=>{if(this.onScaleBoxDragObservable.notifyObservers({dragOperation:1,dragAxis:new m(s-1,n-1,o-1)}),this.attachedMesh){const g=this.attachedMesh.parent;if(g&&g.scaling&&g.scaling.isNonUniformWithinEpsilon(.001)){L.Warn("BoundingBoxGizmo controls are not supported on child meshes with non-uniform parent scaling");return}Ke._RemoveAndStorePivotPoint(this.attachedMesh);let _=p.dragDistance/this._boundingDimensions.length()*this._anchorMesh.scaling.length();if(d+=_,this.scalingSnapDistance>0){const y=Math.floor(Math.abs(d)/this.scalingSnapDistance)*(d<0?-1:1),T=this.scalingSnapDistance*y;_=T-f,f=T}const S=new m(_,_,_),b=new m(f,f,f);l===2&&(S.x*=Math.abs(c.x),S.y*=Math.abs(c.y),S.z*=Math.abs(c.z)),S.scaleInPlace(this._scaleDragSpeed),S.multiplyInPlace(this._axisFactor),b.scaleInPlace(this._scaleDragSpeed),b.multiplyInPlace(this._axisFactor),b.addInPlace(this._incrementalStartupValue),this.updateBoundingBox(),this.scalePivot?(this.attachedMesh.getWorldMatrix().getRotationMatrixToRef(this._tmpRotationMatrix),this._boundingDimensions.scaleToRef(.5,this._tmpVector),m.TransformCoordinatesToRef(this._tmpVector,this._tmpRotationMatrix,this._tmpVector),this._anchorMesh.position.subtractInPlace(this._tmpVector),this._boundingDimensions.multiplyToRef(this.scalePivot,this._tmpVector),m.TransformCoordinatesToRef(this._tmpVector,this._tmpRotationMatrix,this._tmpVector),this._anchorMesh.position.addInPlace(this._tmpVector)):(u.absolutePosition.subtractToRef(this._anchorMesh.position,this._tmpVector),this._anchorMesh.position.subtractInPlace(this._tmpVector),this.attachedMesh.isUsingPivotMatrix()&&this._anchorMesh.position.subtractInPlace(this.attachedMesh.getPivotPoint())),this._anchorMesh.addChild(this.attachedMesh),this.incrementalSnap?(b.x/=Math.abs(this._incrementalStartupValue.x)<He?1:this._incrementalStartupValue.x,b.y/=Math.abs(this._incrementalStartupValue.y)<He?1:this._incrementalStartupValue.y,b.z/=Math.abs(this._incrementalStartupValue.z)<He?1:this._incrementalStartupValue.z,b.x=Math.max(this._incrementalAnchorStartupValue.x*b.x,this.scalingSnapDistance),b.y=Math.max(this._incrementalAnchorStartupValue.y*b.y,this.scalingSnapDistance),b.z=Math.max(this._incrementalAnchorStartupValue.z*b.z,this.scalingSnapDistance),this._anchorMesh.scaling.x+=(b.x-this._anchorMesh.scaling.x)*Math.abs(c.x),this._anchorMesh.scaling.y+=(b.y-this._anchorMesh.scaling.y)*Math.abs(c.y),this._anchorMesh.scaling.z+=(b.z-this._anchorMesh.scaling.z)*Math.abs(c.z)):(this._anchorMesh.scaling.addInPlace(S),(this._anchorMesh.scaling.x<0||this._anchorMesh.scaling.y<0||this._anchorMesh.scaling.z<0)&&this._anchorMesh.scaling.subtractInPlace(S)),this._anchorMesh.removeChild(this.attachedMesh),this.attachedMesh.setParent(g),Ke._RestorePivotPoint(this.attachedMesh)}this._updateDummy()}),h.onDragStartObservable.add(()=>{this.onDragStartObservable.notifyObservers({dragOperation:1,dragAxis:new m(s-1,n-1,o-1)}),this._dragging=!0,this._selectNode(u),d=0,f=0,this._incrementalStartupValue.copyFrom(this.attachedMesh.scaling),this._incrementalAnchorStartupValue.copyFrom(this._anchorMesh.scaling)}),h.onDragEndObservable.add(p=>{this.onScaleBoxDragEndObservable.notifyObservers({dragOperation:1,dragAxis:new m(s-1,n-1,o-1)}),this._dragging=!1,this._selectNode(null),this._updateDummy(),this._unhoverMeshOnTouchUp(p.pointerInfo,u)}),this._scaleBoxesParent.addChild(u),this._scaleBoxesDragBehaviors.push(h)}this._rootMesh.addChild(this._scaleBoxesParent);const r=[];this._pointerObserver=t.utilityLayerScene.onPointerObservable.add(s=>{r[s.event.pointerId]?s.pickInfo&&s.pickInfo.pickedMesh!=r[s.event.pointerId]&&(r[s.event.pointerId].material=this._coloredMaterial,delete r[s.event.pointerId],this.onHoverEndObservable.notifyObservers(),this._isHovered=!1):this._rotateAnchorsParent.getChildMeshes().concat(this._scaleBoxesParent.getChildMeshes()).forEach(n=>{s.pickInfo&&s.pickInfo.pickedMesh==n&&(r[s.event.pointerId]=n,n.material=this._hoverColoredMaterial,this.onHoverStartObservable.notifyObservers(),this._isHovered=!0)})}),this._renderObserver=this.gizmoLayer.originalScene.onBeforeRenderObservable.add(()=>{this.attachedMesh&&!this._existingMeshScale.equals(this.attachedMesh.scaling)?this.updateBoundingBox():(this.fixedDragMeshScreenSize||this.fixedDragMeshBoundsSize)&&(this._updateRotationAnchors(),this._updateScaleBoxes()),this._dragMesh&&this.attachedMesh&&this._pointerDragBehavior.dragging&&(this._lineBoundingBox.position.rotateByQuaternionToRef(this._rootMesh.rotationQuaternion,this._tmpVector),this.attachedMesh.setAbsolutePosition(this._dragMesh.position.add(this._tmpVector.scale(-1))))}),this.updateBoundingBox()}_getCornerMesh(e){if(!this._cornerMesh){const t=Xi("",{width:.4,height:.4,depth:1.6},e.utilityLayerScene);t.position.z=.6;const i=Xi("",{width:.4,height:1.6,depth:.4},e.utilityLayerScene);i.position.y=.6;const r=Xi("",{width:1.6,height:.4,depth:.4},e.utilityLayerScene);return r.position.x=.6,this._cornerMesh=z.MergeMeshes([r,i,t],!0),this._cornerMesh}return this._cornerMesh.clone()}_attachedNodeChanged(e){if(e){this._anchorMesh.scaling.setAll(1),Ke._RemoveAndStorePivotPoint(e);const t=e.parent;this._anchorMesh.addChild(e),this._anchorMesh.removeChild(e),e.setParent(t),Ke._RestorePivotPoint(e),this.updateBoundingBox(),e.getChildMeshes(!1).forEach(i=>{i.markAsDirty("scaling")}),this.gizmoLayer.utilityLayerScene.onAfterRenderObservable.addOnce(()=>{this._updateDummy()})}}_selectNode(e){this._rotateAnchorsParent.getChildMeshes().concat(this._scaleBoxesParent.getChildMeshes()).forEach(t=>{t.isVisible=!e||t==e})}_unhoverMeshOnTouchUp(e,t){(e==null?void 0:e.event)instanceof PointerEvent&&(e==null?void 0:e.event.pointerType)==="touch"&&(t.material=this._coloredMaterial)}getScaleBoxes(){return this._scaleBoxesParent.getChildMeshes()}updateBoundingBox(){if(this.attachedMesh){Ke._RemoveAndStorePivotPoint(this.attachedMesh);const e=this.attachedMesh.parent;this.attachedMesh.setParent(null),this._update(),this.attachedMesh.rotationQuaternion||(this.attachedMesh.rotationQuaternion=re.RotationYawPitchRoll(this.attachedMesh.rotation.y,this.attachedMesh.rotation.x,this.attachedMesh.rotation.z)),this._anchorMesh.rotationQuaternion||(this._anchorMesh.rotationQuaternion=re.RotationYawPitchRoll(this._anchorMesh.rotation.y,this._anchorMesh.rotation.x,this._anchorMesh.rotation.z)),this._anchorMesh.rotationQuaternion.copyFrom(this.attachedMesh.rotationQuaternion),this._tmpQuaternion.copyFrom(this.attachedMesh.rotationQuaternion),this._tmpVector.copyFrom(this.attachedMesh.position),this.attachedMesh.rotationQuaternion.set(0,0,0,1),this.attachedMesh.position.set(0,0,0);const t=this.attachedMesh.getHierarchyBoundingVectors(!this.ignoreChildren,this.includeChildPredicate);t.max.subtractToRef(t.min,this._boundingDimensions),this._lineBoundingBox.scaling.copyFrom(this._boundingDimensions),this._lineBoundingBox.position.set((t.max.x+t.min.x)/2,(t.max.y+t.min.y)/2,(t.max.z+t.min.z)/2),this._rotateAnchorsParent.position.copyFrom(this._lineBoundingBox.position),this._scaleBoxesParent.position.copyFrom(this._lineBoundingBox.position),this._lineBoundingBox.computeWorldMatrix(),this._anchorMesh.position.copyFrom(this._lineBoundingBox.absolutePosition),this.attachedMesh.rotationQuaternion.copyFrom(this._tmpQuaternion),this.attachedMesh.position.copyFrom(this._tmpVector),this.attachedMesh.setParent(e)}this._updateRotationAnchors(),this._updateScaleBoxes(),this.attachedMesh&&(this._existingMeshScale.copyFrom(this.attachedMesh.scaling),Ke._RestorePivotPoint(this.attachedMesh))}_updateRotationAnchors(){const e=this._rotateAnchorsParent.getChildMeshes();for(let t=0;t<3;t++)for(let i=0;i<2;i++)for(let r=0;r<2;r++){const s=t*4+i*2+r;e[s].position.normalizeToRef(V.Vector3[0]),t==0&&(e[s].position.set(0,this._boundingDimensions.y*(i-.5),this._boundingDimensions.z*(r-.5)),V.Vector3[1].set(1,0,0)),t==1&&(e[s].position.set(this._boundingDimensions.x*(i-.5),0,this._boundingDimensions.z*(r-.5)),V.Vector3[1].set(0,1,0)),t==2&&(e[s].position.set(this._boundingDimensions.x*(i-.5),this._boundingDimensions.y*(r-.5),0),V.Vector3[1].set(0,0,1));const n=V.Vector3[2];if(m.CrossToRef(V.Vector3[0],V.Vector3[1],n),n.normalize(),n.addInPlace(e[s].position),e[s].lookAt(n),this.fixedDragMeshScreenSize&&this.gizmoLayer.utilityLayerScene.activeCamera){e[s].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.position,this._tmpVector);const o=this.rotationSphereSize*this._tmpVector.length()/this.fixedDragMeshScreenSizeDistanceFactor;e[s].scaling.set(o,o,o)}else this.fixedDragMeshBoundsSize?e[s].scaling.set(this.rotationSphereSize*this._boundingDimensions.x,this.rotationSphereSize*this._boundingDimensions.y,this.rotationSphereSize*this._boundingDimensions.z):e[s].scaling.set(this.rotationSphereSize,this.rotationSphereSize,this.rotationSphereSize)}}_updateScaleBoxes(){const e=this._scaleBoxesParent.getChildMeshes();let t=0;for(let i=0;i<3;i++)for(let r=0;r<3;r++)for(let s=0;s<3;s++){const n=(i===1?1:0)+(r===1?1:0)+(s===1?1:0);if(!(n===1||n===3)){if(e[t])if(e[t].position.set(this._boundingDimensions.x*(i/2),this._boundingDimensions.y*(r/2),this._boundingDimensions.z*(s/2)),e[t].position.addInPlace(new m(-this._boundingDimensions.x/2,-this._boundingDimensions.y/2,-this._boundingDimensions.z/2)),this.fixedDragMeshScreenSize&&this.gizmoLayer.utilityLayerScene.activeCamera){e[t].absolutePosition.subtractToRef(this.gizmoLayer.utilityLayerScene.activeCamera.globalPosition,this._tmpVector);const o=this.scaleBoxSize*this._tmpVector.length()/this.fixedDragMeshScreenSizeDistanceFactor;e[t].scaling.set(o,o,o)}else this.fixedDragMeshBoundsSize?e[t].scaling.set(this.scaleBoxSize*this._boundingDimensions.x,this.scaleBoxSize*this._boundingDimensions.y,this.scaleBoxSize*this._boundingDimensions.z):e[t].scaling.set(this.scaleBoxSize,this.scaleBoxSize,this.scaleBoxSize);t++}}}setEnabledRotationAxis(e){this._rotateAnchorsParent.getChildMeshes().forEach((t,i)=>{i<4?t.setEnabled(e.indexOf("x")!=-1):i<8?t.setEnabled(e.indexOf("y")!=-1):t.setEnabled(e.indexOf("z")!=-1)})}setEnabledScaling(e,t=!1){this._scaleBoxesParent.getChildMeshes().forEach(i=>{let r=e;t&&i._internalMetadata===!0&&(r=!1),i.setEnabled(r)})}_updateDummy(){this._dragMesh&&(this._dragMesh.position.copyFrom(this._lineBoundingBox.getAbsolutePosition()),this._dragMesh.scaling.copyFrom(this._lineBoundingBox.scaling),this._dragMesh.rotationQuaternion.copyFrom(this._rootMesh.rotationQuaternion))}enableDragBehavior(){this._dragMesh=Xi("dummy",{size:1},this.gizmoLayer.utilityLayerScene),this._dragMesh.visibility=0,this._dragMesh.rotationQuaternion=new re,this._pointerDragBehavior.useObjectOrientationForDragging=!1,this._dragMesh.addBehavior(this._pointerDragBehavior)}releaseDrag(){this._scaleBoxesDragBehaviors.forEach(e=>{e.releaseDrag()}),this._rotateAnchorsDragBehaviors.forEach(e=>{e.releaseDrag()}),this._pointerDragBehavior.releaseDrag()}dispose(){this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver),this.gizmoLayer.originalScene.onBeforeRenderObservable.remove(this._renderObserver),this._lineBoundingBox.dispose(),this._rotateAnchorsParent.dispose(),this._scaleBoxesParent.dispose(),this._dragMesh&&this._dragMesh.dispose(),this._scaleBoxesDragBehaviors.length=0,this._rotateAnchorsDragBehaviors.length=0,this.onDragStartObservable.clear(),this.onHoverStartObservable.clear(),this.onHoverEndObservable.clear(),this.onScaleBoxDragObservable.clear(),this.onScaleBoxDragEndObservable.clear(),this.onRotationSphereDragObservable.clear(),this.onRotationSphereDragEndObservable.clear(),super.dispose()}static MakeNotPickableAndWrapInBoundingBox(e){const t=o=>{o.isPickable=!1,o.getChildMeshes().forEach(l=>{t(l)})};t(e),e.rotationQuaternion||(e.rotationQuaternion=re.RotationYawPitchRoll(e.rotation.y,e.rotation.x,e.rotation.z));const i=e.position.clone(),r=e.rotationQuaternion.clone();e.rotationQuaternion.set(0,0,0,1),e.position.set(0,0,0);const s=Xi("box",{size:1},e.getScene()),n=e.getHierarchyBoundingVectors();return n.max.subtractToRef(n.min,s.scaling),s.scaling.y===0&&(s.scaling.y=He),s.scaling.x===0&&(s.scaling.x=He),s.scaling.z===0&&(s.scaling.z=He),s.position.set((n.max.x+n.min.x)/2,(n.max.y+n.min.y)/2,(n.max.z+n.min.z)/2),e.addChild(s),e.rotationQuaternion.copyFrom(r),e.position.copyFrom(i),e.removeChild(s),s.addChild(e),s.visibility=0,s}setCustomMesh(){L.Error("Custom meshes are not supported on this gizmo")}}class Qs extends ri{get coloredMaterial(){return this._coloredMaterial}get hoverMaterial(){return this._hoverMaterial}set rotationColor(e){this._rotationShaderMaterial.setColor3("rotationColor",e)}get disableMaterial(){return this._disableMaterial}constructor(e,t=ne.Gray(),i=gt.DefaultUtilityLayer,r=32,s=null,n=!1,o=1,l=ne.Yellow(),u=ne.Gray()){var E;super(i),this._pointerObserver=null,this.snapDistance=0,this.onSnapObservable=new j,this.angle=0,this.sensitivity=1,this._isEnabled=!0,this._parent=null,this._dragging=!1,this._angles=new m,this._parent=s,this._coloredMaterial=new Ut("",i.utilityLayerScene),this._coloredMaterial.diffuseColor=t,this._coloredMaterial.specularColor=t.subtract(new ne(.1,.1,.1)),this._hoverMaterial=new Ut("",i.utilityLayerScene),this._hoverMaterial.diffuseColor=l,this._hoverMaterial.specularColor=l,this._disableMaterial=new Ut("",i.utilityLayerScene),this._disableMaterial.diffuseColor=u,this._disableMaterial.alpha=.4,this._gizmoMesh=new z("",i.utilityLayerScene);const{rotationMesh:c,collider:h}=this._createGizmoMesh(this._gizmoMesh,o,r);this._rotationDisplayPlane=gn("rotationDisplay",{size:.6,updatable:!1},this.gizmoLayer.utilityLayerScene),this._rotationDisplayPlane.rotation.z=Math.PI*.5,this._rotationDisplayPlane.parent=this._gizmoMesh,this._rotationDisplayPlane.setEnabled(!1),_i.ShadersStore.rotationGizmoVertexShader=Qs._RotationGizmoVertexShader,_i.ShadersStore.rotationGizmoFragmentShader=Qs._RotationGizmoFragmentShader,this._rotationShaderMaterial=new Wr("shader",this.gizmoLayer.utilityLayerScene,{vertex:"rotationGizmo",fragment:"rotationGizmo"},{attributes:["position","uv"],uniforms:["worldViewProjection","angles","rotationColor"]}),this._rotationShaderMaterial.backFaceCulling=!1,this.rotationColor=l,this._rotationDisplayPlane.material=this._rotationShaderMaterial,this._rotationDisplayPlane.visibility=.999,this._gizmoMesh.lookAt(this._rootMesh.position.add(e)),this._rootMesh.addChild(this._gizmoMesh,ri.PreserveScaling),this._gizmoMesh.scaling.scaleInPlace(1/3),this.dragBehavior=new gi({dragPlaneNormal:e}),this.dragBehavior.moveAttached=!1,this.dragBehavior.maxDragAngle=Qs.MaxDragAngle,this.dragBehavior._useAlternatePickedPointAboveMaxDragAngle=!0,this._rootMesh.addBehavior(this.dragBehavior);const d=new m,f=new $,p=new m;let g=new m;this.dragBehavior.onDragStartObservable.add(R=>{this.attachedNode&&(d.copyFrom(R.dragPlanePoint),this._rotationDisplayPlane.setEnabled(!0),this._rotationDisplayPlane.getWorldMatrix().invertToRef(f),m.TransformCoordinatesToRef(R.dragPlanePoint,f,d),this._angles.x=Math.atan2(d.y,d.x)+Math.PI,this._angles.y=0,this._angles.z=this.updateGizmoRotationToMatchAttachedMesh?1:0,this._dragging=!0,d.copyFrom(R.dragPlanePoint),this._rotationShaderMaterial.setVector3("angles",this._angles),this.angle=0)}),this.dragBehavior.onDragEndObservable.add(()=>{this._dragging=!1,this._rotationDisplayPlane.setEnabled(!1)});const _={snapDistance:0};let S=0;const b=new $,y=new re;this.dragBehavior.onDragObservable.add(R=>{if(this.attachedNode){const O=new m(1,1,1),w=new re(0,0,0,1),M=new m(0,0,0),G=this._attachedNode;if(G&&G.isUsingPivotMatrix&&G.isUsingPivotMatrix()&&G.position&&G.getWorldMatrix().setTranslation(G.position),this.attachedNode.getWorldMatrix().decompose(O,w,M),!(Math.abs(Math.abs(O.x)-Math.abs(O.y))<=He&&Math.abs(Math.abs(O.x)-Math.abs(O.z))<=He)&&this.updateGizmoRotationToMatchAttachedMesh){L.Warn("Unable to use a rotation gizmo matching mesh rotation with non uniform scaling. Use uniform scaling or set updateGizmoRotationToMatchAttachedMesh to false.");return}w.normalize();const q=this.updateGizmoPositionToMatchAttachedMesh?M:this._rootMesh.absolutePosition,X=R.dragPlanePoint.subtract(q).normalize(),ee=d.subtract(q).normalize(),oe=m.Cross(X,ee),_e=m.Dot(X,ee);let te=Math.atan2(oe.length(),_e)*this.sensitivity;p.copyFrom(e),g.copyFrom(e),this.updateGizmoRotationToMatchAttachedMesh&&(w.toRotationMatrix(f),g=m.TransformCoordinates(p,f));let ie=!1;if(i.utilityLayerScene.activeCamera){const K=i.utilityLayerScene.activeCamera.position.subtract(q).normalize();m.Dot(K,g)>0&&(p.scaleInPlace(-1),g.scaleInPlace(-1),ie=!0)}m.Dot(g,oe)>0&&(te=-te),V.Vector3[0].set(te,0,0),this.dragBehavior.validateDrag(V.Vector3[0])||(te=0);let D=!1;if(this.snapDistance!=0)if(S+=te,Math.abs(S)>this.snapDistance){let K=Math.floor(Math.abs(S)/this.snapDistance);S<0&&(K*=-1),S=S%this.snapDistance,te=this.snapDistance*K,D=!0}else te=0;const W=Math.sin(te/2);if(y.set(p.x*W,p.y*W,p.z*W,Math.cos(te/2)),b.determinant()>0){const K=new m;y.toEulerAnglesToRef(K),re.RotationYawPitchRollToRef(K.y,-K.x,-K.z,y)}if(this.updateGizmoRotationToMatchAttachedMesh)w.multiplyToRef(y,w),w.normalize(),$.ComposeToRef(O,w,M,this.attachedNode.getWorldMatrix());else{y.toRotationMatrix(V.Matrix[0]);const K=this.attachedNode.getWorldMatrix().getTranslation();this.attachedNode.getWorldMatrix().multiplyToRef(V.Matrix[0],this.attachedNode.getWorldMatrix()),this.attachedNode.getWorldMatrix().setTranslation(K)}d.copyFrom(R.dragPlanePoint),D&&(_.snapDistance=te,this.onSnapObservable.notifyObservers(_)),this._angles.y+=te,this.angle+=ie?-te:te,this._rotationShaderMaterial.setVector3("angles",this._angles),this._matrixChanged()}});const T=i._getSharedGizmoLight();T.includedOnlyMeshes=T.includedOnlyMeshes.concat(this._rootMesh.getChildMeshes(!1));const v={colliderMeshes:[h],gizmoMeshes:[c],material:this._coloredMaterial,hoverMaterial:this._hoverMaterial,disableMaterial:this._disableMaterial,active:!1,dragBehavior:this.dragBehavior};(E=this._parent)==null||E.addToAxisCache(this._gizmoMesh,v),this._pointerObserver=i.utilityLayerScene.onPointerObservable.add(R=>{var O;if(!this._customMeshSet&&(this.dragBehavior.maxDragAngle=Qs.MaxDragAngle,this._isHovered=v.colliderMeshes.indexOf((O=R==null?void 0:R.pickInfo)==null?void 0:O.pickedMesh)!=-1,!this._parent)){const w=v.dragBehavior.enabled?this._isHovered||this._dragging?this._hoverMaterial:this._coloredMaterial:this._disableMaterial;this._setGizmoMeshMaterial(v.gizmoMeshes,w)}}),this.dragBehavior.onEnabledObservable.add(R=>{this._setGizmoMeshMaterial(v.gizmoMeshes,R?this._coloredMaterial:this._disableMaterial)})}_createGizmoMesh(e,t,i){const r=fs("ignore",{diameter:.6,thickness:.03*t,tessellation:i},this.gizmoLayer.utilityLayerScene);r.visibility=0;const s=fs("",{diameter:.6,thickness:.005*t,tessellation:i},this.gizmoLayer.utilityLayerScene);return s.material=this._coloredMaterial,s.rotation.x=Math.PI/2,r.rotation.x=Math.PI/2,e.addChild(s,ri.PreserveScaling),e.addChild(r,ri.PreserveScaling),{rotationMesh:s,collider:r}}_attachedNodeChanged(e){this.dragBehavior&&(this.dragBehavior.enabled=!!e)}set isEnabled(e){this._isEnabled=e,e?this._parent&&(this.attachedMesh=this._parent.attachedMesh):this.attachedMesh=null}get isEnabled(){return this._isEnabled}dispose(){this.onSnapObservable.clear(),this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver),this.dragBehavior.detach(),this._gizmoMesh&&this._gizmoMesh.dispose(),this._rotationDisplayPlane&&this._rotationDisplayPlane.dispose(),this._rotationShaderMaterial&&this._rotationShaderMaterial.dispose(),[this._coloredMaterial,this._hoverMaterial,this._disableMaterial].forEach(e=>{e&&e.dispose()}),super.dispose()}}Qs.MaxDragAngle=Math.PI*9/20;Qs._RotationGizmoVertexShader=`
        precision highp float;
        attribute vec3 position;
        attribute vec2 uv;
        uniform mat4 worldViewProjection;
        varying vec3 vPosition;
        varying vec2 vUV;

        void main(void) {
            gl_Position = worldViewProjection * vec4(position, 1.0);
            vUV = uv;
        }`;Qs._RotationGizmoFragmentShader=`
        precision highp float;
        varying vec2 vUV;
        varying vec3 vPosition;
        uniform vec3 angles;
        uniform vec3 rotationColor;

        #define twopi 6.283185307

        void main(void) {
            vec2 uv = vUV - vec2(0.5);
            float angle = atan(uv.y, uv.x) + 3.141592;
            float delta = gl_FrontFacing ? angles.y : -angles.y;
            float begin = angles.x - delta * angles.z;
            float start = (begin < (begin + delta)) ? begin : (begin + delta);
            float end = (begin > (begin + delta)) ? begin : (begin + delta);
            float len = sqrt(dot(uv,uv));
            float opacity = 1. - step(0.5, len);

            float base = abs(floor(start / twopi)) * twopi;
            start += base;
            end += base;

            float intensity = 0.;
            for (int i = 0; i < 5; i++)
            {
                intensity += max(step(start, angle) - step(end, angle), 0.);
                angle += twopi;
            }
            gl_FragColor = vec4(rotationColor, min(intensity * 0.25, 0.8)) * opacity;
        }
    `;function Kl(a,e={},t){e.diameter||(e.diameter=1),e.segments||(e.segments=16);const i=Ti("",{slice:.5,diameter:e.diameter,segments:e.segments},t),r=Ou("",{radius:e.diameter/2,tessellation:e.segments*3+(4-e.segments)},t);r.rotation.x=-Math.PI/2,r.parent=i;const s=z.MergeMeshes([r,i],!0);return s.name=a,s}const NW={CreateHemisphere:Kl};z.CreateHemisphere=(a,e,t,i)=>Kl(a,{segments:e,diameter:t},i);class Dr extends ri{constructor(e=gt.DefaultUtilityLayer){super(e),this._cachedPosition=new m,this._cachedForward=new m(0,0,1),this._pointerObserver=null,this.onClickedObservable=new j,this._light=null,this.attachedMesh=new z("",this.gizmoLayer.utilityLayerScene),this._attachedMeshParent=new Bi("parent",this.gizmoLayer.utilityLayerScene),this.attachedMesh.parent=this._attachedMeshParent,this._material=new Ut("light",this.gizmoLayer.utilityLayerScene),this._material.diffuseColor=new ne(.5,.5,.5),this._material.specularColor=new ne(.1,.1,.1),this._pointerObserver=e.utilityLayerScene.onPointerObservable.add(t=>{this._light&&(this._isHovered=!!(t.pickInfo&&this._rootMesh.getChildMeshes().indexOf(t.pickInfo.pickedMesh)!=-1),this._isHovered&&t.event.button===0&&this.onClickedObservable.notifyObservers(this._light))},Be.POINTERDOWN)}get attachedNode(){return this.attachedMesh}set attachedNode(e){L.Warn("Nodes cannot be attached to LightGizmo. Attach to a mesh instead.")}set light(e){if(this._light=e,e){this._lightMesh&&this._lightMesh.dispose(),e instanceof wm?this._lightMesh=Dr._CreateHemisphericLightMesh(this.gizmoLayer.utilityLayerScene):e instanceof Bm?this._lightMesh=Dr._CreateDirectionalLightMesh(this.gizmoLayer.utilityLayerScene):e instanceof aM?this._lightMesh=Dr._CreateSpotLightMesh(this.gizmoLayer.utilityLayerScene):this._lightMesh=Dr._CreatePointLightMesh(this.gizmoLayer.utilityLayerScene),this._lightMesh.getChildMeshes(!1).forEach(i=>{i.material=this._material}),this._lightMesh.parent=this._rootMesh;const t=this.gizmoLayer._getSharedGizmoLight();if(t.includedOnlyMeshes=t.includedOnlyMeshes.concat(this._lightMesh.getChildMeshes(!1)),this._lightMesh.rotationQuaternion=new re,this.attachedMesh.reservedDataStore||(this.attachedMesh.reservedDataStore={}),this.attachedMesh.reservedDataStore.lightGizmo=this,e.parent&&this._attachedMeshParent.freezeWorldMatrix(e.parent.getWorldMatrix()),e.position&&(this.attachedMesh.position.copyFrom(e.position),this.attachedMesh.computeWorldMatrix(!0),this._cachedPosition.copyFrom(this.attachedMesh.position)),e.direction){this.attachedMesh.setDirection(e.direction),this.attachedMesh.computeWorldMatrix(!0);const i=this._getMeshForward();this._cachedForward.copyFrom(i)}this._update()}}get light(){return this._light}get material(){return this._material}_getMeshForward(){let e=this.attachedMesh.forward;return this.attachedMesh.getScene().useRightHandedSystem&&(e.negateToRef(V.Vector3[0]),e=V.Vector3[0]),e}_update(){if(super._update(),!!this._light){if(this._light.parent&&this._attachedMeshParent.freezeWorldMatrix(this._light.parent.getWorldMatrix()),this._light.position)if(this.attachedMesh.position.equals(this._cachedPosition))this.attachedMesh.position.copyFrom(this._light.position),this.attachedMesh.computeWorldMatrix(!0),this._cachedPosition.copyFrom(this.attachedMesh.position);else{const e=this.attachedMesh.position;this._light.position=new m(e.x,e.y,e.z),this._cachedPosition.copyFrom(this.attachedMesh.position)}if(this._light.direction){const e=this._getMeshForward();if(m.DistanceSquared(e,this._cachedForward)>1e-4){const t=e;this._light.direction=new m(t.x,t.y,t.z),this._cachedForward.copyFrom(e)}else m.DistanceSquared(e,this._light.direction)>1e-4&&(this.attachedMesh.setDirection(this._light.direction),this.attachedMesh.computeWorldMatrix(!0),this._cachedForward.copyFrom(e))}}}dispose(){this.onClickedObservable.clear(),this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver),this._material.dispose(),super.dispose(),this._attachedMeshParent.dispose()}static _CreateHemisphericLightMesh(e){const t=new z("hemisphereLight",e),i=Kl(t.name,{segments:10,diameter:1},e);i.position.z=-.15,i.rotation.x=Math.PI/2,i.parent=t;const r=this._CreateLightLines(3,e);return r.parent=t,t.scaling.scaleInPlace(Dr._Scale),t.rotation.x=Math.PI/2,t}static _CreatePointLightMesh(e){const t=new z("pointLight",e),i=Ti(t.name,{segments:10,diameter:1},e);i.rotation.x=Math.PI/2,i.parent=t;const r=this._CreateLightLines(5,e);return r.parent=t,t.scaling.scaleInPlace(Dr._Scale),t.rotation.x=Math.PI/2,t}static _CreateSpotLightMesh(e){const t=new z("spotLight",e),i=Ti(t.name,{segments:10,diameter:1},e);i.parent=t;const r=Kl(t.name,{segments:10,diameter:2},e);r.parent=t,r.rotation.x=-Math.PI/2;const s=this._CreateLightLines(2,e);return s.parent=t,t.scaling.scaleInPlace(Dr._Scale),t.rotation.x=Math.PI/2,t}static _CreateDirectionalLightMesh(e){const t=new z("directionalLight",e),i=new z(t.name,e);i.parent=t;const r=Ti(t.name,{diameter:1.2,segments:10},e);r.parent=i;const s=tr(t.name,{updatable:!1,height:6,diameterTop:.3,diameterBottom:.3,tessellation:6,subdivisions:1},e);s.parent=i;let n=s.clone(t.name);n.scaling.y=.5,n.position.x+=1.25;let o=s.clone(t.name);o.scaling.y=.5,o.position.x+=-1.25;const l=tr(t.name,{updatable:!1,height:1,diameterTop:0,diameterBottom:.6,tessellation:6,subdivisions:1},e);return l.position.y+=3,l.parent=i,n=l.clone(t.name),n.position.y=1.5,n.position.x+=1.25,o=l.clone(t.name),o.position.y=1.5,o.position.x+=-1.25,i.scaling.scaleInPlace(Dr._Scale),i.rotation.z=Math.PI/2,i.rotation.y=Math.PI/2,t}}Dr._Scale=.007;Dr._CreateLightLines=(a,e)=>{const i=new z("root",e);i.rotation.x=Math.PI/2;const r=new z("linePivot",e);r.parent=i;const s=tr("line",{updatable:!1,height:2,diameterTop:.2,diameterBottom:.3,tessellation:6,subdivisions:1},e);if(s.position.y=s.scaling.y/2+1.2,s.parent=r,a<2)return r;for(let o=0;o<4;o++){const l=r.clone("lineParentClone");l.rotation.z=Math.PI/4,l.rotation.y=Math.PI/2+Math.PI/2*o,l.getChildMeshes()[0].scaling.y=.5,l.getChildMeshes()[0].scaling.x=l.getChildMeshes()[0].scaling.z=.8,l.getChildMeshes()[0].position.y=l.getChildMeshes()[0].scaling.y/2+1.2}if(a<3)return i;for(let o=0;o<4;o++){const l=r.clone("linePivotClone");l.rotation.z=Math.PI/2,l.rotation.y=Math.PI/2*o}if(a<4)return i;for(let o=0;o<4;o++){const l=r.clone("linePivotClone");l.rotation.z=Math.PI+Math.PI/4,l.rotation.y=Math.PI/2+Math.PI/2*o,l.getChildMeshes()[0].scaling.y=.5,l.getChildMeshes()[0].scaling.x=l.getChildMeshes()[0].scaling.z=.8,l.getChildMeshes()[0].position.y=l.getChildMeshes()[0].scaling.y/2+1.2}if(a<5)return i;const n=r.clone("linePivotClone");return n.rotation.z=Math.PI,i};class vo extends ri{constructor(e=gt.DefaultUtilityLayer,t,i){super(e),this._pointerObserver=null,this.onClickedObservable=new j,this._camera=null,this._invProjection=new $,this._material=new Ut("cameraGizmoMaterial",this.gizmoLayer.utilityLayerScene),this._frustumLinesColor=i,this._material.diffuseColor=t??new ne(.5,.5,.5),this._material.specularColor=new ne(.1,.1,.1),this._pointerObserver=e.utilityLayerScene.onPointerObservable.add(r=>{this._camera&&(this._isHovered=!!(r.pickInfo&&this._rootMesh.getChildMeshes().indexOf(r.pickInfo.pickedMesh)!=-1),this._isHovered&&r.event.button===0&&this.onClickedObservable.notifyObservers(this._camera))},Be.POINTERDOWN)}get displayFrustum(){return this._cameraLinesMesh.isEnabled()}set displayFrustum(e){this._cameraLinesMesh.setEnabled(e)}set camera(e){var t;if(this._camera=e,this.attachedNode=e,e){this._customMeshSet||(this._cameraMesh&&this._cameraMesh.dispose(),this._cameraMesh=vo._CreateCameraMesh(this.gizmoLayer.utilityLayerScene),this._cameraMesh.getChildMeshes(!1).forEach(s=>{s.material=this._material}),this._cameraMesh.parent=this._rootMesh),this._cameraLinesMesh&&this._cameraLinesMesh.dispose();const i=((t=this._frustumLinesColor)==null?void 0:t.toColor4(1))??new xe(1,1,1,1);this._cameraLinesMesh=vo._CreateCameraFrustum(this.gizmoLayer.utilityLayerScene,i),this._cameraLinesMesh.parent=this._rootMesh,this.gizmoLayer.utilityLayerScene.activeCamera&&this.gizmoLayer.utilityLayerScene.activeCamera.maxZ<e.maxZ*1.5&&(this.gizmoLayer.utilityLayerScene.activeCamera.maxZ=e.maxZ*1.5),this.attachedNode.reservedDataStore||(this.attachedNode.reservedDataStore={}),this.attachedNode.reservedDataStore.cameraGizmo=this;const r=this.gizmoLayer._getSharedGizmoLight();r.includedOnlyMeshes=r.includedOnlyMeshes.concat(this._cameraMesh.getChildMeshes(!1)),this._update()}}get camera(){return this._camera}get material(){return this._material}_update(){super._update(),this._camera&&(this._camera.getProjectionMatrix().invertToRef(this._invProjection),this._cameraLinesMesh.setPivotMatrix(this._invProjection,!1),this._cameraLinesMesh.scaling.x=1/this._rootMesh.scaling.x,this._cameraLinesMesh.scaling.y=1/this._rootMesh.scaling.y,this._cameraLinesMesh.scaling.z=1/this._rootMesh.scaling.z,this._cameraMesh.parent=null,this._cameraMesh.rotation.y=Math.PI*.5*(this._camera.getScene().useRightHandedSystem?1:-1),this._cameraMesh.parent=this._rootMesh)}setCustomMesh(e){if(e.getScene()!=this.gizmoLayer.utilityLayerScene)throw"When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)";this._cameraMesh&&this._cameraMesh.dispose(),this._cameraMesh=e,this._cameraMesh.parent=this._rootMesh,this._customMeshSet=!0}dispose(){this.onClickedObservable.clear(),this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver),this._cameraMesh&&this._cameraMesh.dispose(),this._cameraLinesMesh&&this._cameraLinesMesh.dispose(),this._material.dispose(),super.dispose()}static _CreateCameraMesh(e){const t=new z("rootCameraGizmo",e),i=new z(t.name,e);i.parent=t;const r=Xi(t.name,{width:1,height:.8,depth:.5},e);r.parent=i;const s=tr(t.name,{height:.5,diameterTop:.8,diameterBottom:.8},e);s.parent=i,s.position.y=.3,s.position.x=-.6,s.rotation.x=Math.PI*.5;const n=tr(t.name,{height:.5,diameterTop:.6,diameterBottom:.6},e);n.parent=i,n.position.y=.5,n.position.x=.4,n.rotation.x=Math.PI*.5;const o=tr(t.name,{height:.5,diameterTop:.5,diameterBottom:.5},e);return o.parent=i,o.position.y=0,o.position.x=.6,o.rotation.z=Math.PI*.5,t.scaling.scaleInPlace(vo._Scale),i.position.x=-.9,t}static _CreateCameraFrustum(e,t){const i=new z("rootCameraGizmo",e),r=new z(i.name,e);r.parent=i;for(let s=0;s<4;s+=2)for(let n=0;n<4;n+=2){let o=ai("lines",{points:[new m(-1+n,-1+s,-1),new m(-1+n,-1+s,1)],colors:[t,t]},e);o.parent=r,o.alwaysSelectAsActiveMesh=!0,o.isPickable=!1,o=ai("lines",{points:[new m(-1,-1+n,-1+s),new m(1,-1+n,-1+s)],colors:[t,t]},e),o.parent=r,o.alwaysSelectAsActiveMesh=!0,o.isPickable=!1,o=ai("lines",{points:[new m(-1+n,-1,-1+s),new m(-1+n,1,-1+s)],colors:[t,t]},e),o.parent=r,o.alwaysSelectAsActiveMesh=!0,o.isPickable=!1}return i}}vo._Scale=.05;class $u extends Kt{set blurRatio(e){this._blurRatio!==e&&(this._blurRatio=e,this._preparePostProcesses())}get blurRatio(){return this._blurRatio}set adaptiveBlurKernel(e){this._adaptiveBlurKernel=e,this._autoComputeBlurKernel()}set blurKernel(e){this.blurKernelX=e,this.blurKernelY=e}set blurKernelX(e){this._blurKernelX!==e&&(this._blurKernelX=e,this._preparePostProcesses())}get blurKernelX(){return this._blurKernelX}set blurKernelY(e){this._blurKernelY!==e&&(this._blurKernelY=e,this._preparePostProcesses())}get blurKernelY(){return this._blurKernelY}_autoComputeBlurKernel(){const e=this.getScene().getEngine(),t=this.getRenderWidth()/e.getRenderWidth(),i=this.getRenderHeight()/e.getRenderHeight();this.blurKernelX=this._adaptiveBlurKernel*t,this.blurKernelY=this._adaptiveBlurKernel*i}_onRatioRescale(){this._sizeRatio&&(this.resize(this._initialSizeParameter),this._adaptiveBlurKernel||this._preparePostProcesses()),this._adaptiveBlurKernel&&this._autoComputeBlurKernel()}_updateGammaSpace(){const e=this.getScene();e&&(this.gammaSpace=!e.imageProcessingConfiguration.isEnabled||!e.imageProcessingConfiguration.applyByPostProcess)}constructor(e,t,i,r,s=0,n=Y.BILINEAR_SAMPLINGMODE,o=!0){if(super(e,t,i,r,!0,s,!1,n,o),this.mirrorPlane=new ko(0,1,0,1),this._transformMatrix=$.Zero(),this._mirrorMatrix=$.Zero(),this._adaptiveBlurKernel=0,this._blurKernelX=0,this._blurKernelY=0,this._blurRatio=1,i=this.getScene(),!i)return this;this.ignoreCameraViewport=!0,this._updateGammaSpace(),this._imageProcessingConfigChangeObserver=i.imageProcessingConfiguration.onUpdateParameters.add(()=>{this._updateGammaSpace()}),i.getEngine().supportsUniformBuffers&&(this._sceneUBO=i.createSceneUniformBuffer(`Scene for Mirror Texture (name "${e}")`));let u;this.onBeforeRenderObservable.add(()=>{this._sceneUBO&&(this._currentSceneUBO=i.getSceneUniformBuffer(),i.setSceneUniformBuffer(this._sceneUBO),i.getSceneUniformBuffer().unbindEffect()),$.ReflectionToRef(this.mirrorPlane,this._mirrorMatrix),this._mirrorMatrix.multiplyToRef(i.getViewMatrix(),this._transformMatrix),i.setTransformMatrix(this._transformMatrix,i.getProjectionMatrix()),u=i.clipPlane,i.clipPlane=this.mirrorPlane,i._mirroredCameraPosition=m.TransformCoordinates(i.activeCamera.globalPosition,this._mirrorMatrix)}),this.onAfterRenderObservable.add(()=>{this._sceneUBO&&i.setSceneUniformBuffer(this._currentSceneUBO),i.updateTransformMatrix(),i._mirroredCameraPosition=null,i.clipPlane=u})}_preparePostProcesses(){if(this.clearPostProcesses(!0),this._blurKernelX&&this._blurKernelY){const e=this.getScene().getEngine(),t=e.getCaps().textureFloatRender&&e.getCaps().textureFloatLinearFiltering?1:2;this._blurX=new zt("horizontal blur",new Q(1,0),this._blurKernelX,this._blurRatio,null,Y.BILINEAR_SAMPLINGMODE,e,!1,t),this._blurX.autoClear=!1,this._blurRatio===1&&this.samples<2&&this._texture?this._blurX.inputTexture=this._renderTarget:this._blurX.alwaysForcePOT=!0,this._blurY=new zt("vertical blur",new Q(0,1),this._blurKernelY,this._blurRatio,null,Y.BILINEAR_SAMPLINGMODE,e,!1,t),this._blurY.autoClear=!1,this._blurY.alwaysForcePOT=this._blurRatio!==1,this.addPostProcess(this._blurX),this.addPostProcess(this._blurY)}else this._blurY&&(this.removePostProcess(this._blurY),this._blurY.dispose(),this._blurY=null),this._blurX&&(this.removePostProcess(this._blurX),this._blurX.dispose(),this._blurX=null)}clone(){const e=this.getScene();if(!e)return this;const t=this.getSize(),i=new $u(this.name,t.width,e,this._renderTargetOptions.generateMipMaps,this._renderTargetOptions.type,this._renderTargetOptions.samplingMode,this._renderTargetOptions.generateDepthBuffer);return i.hasAlpha=this.hasAlpha,i.level=this.level,i.mirrorPlane=this.mirrorPlane.clone(),this.renderList&&(i.renderList=this.renderList.slice(0)),i}serialize(){if(!this.name)return null;const e=super.serialize();return e.mirrorPlane=this.mirrorPlane.asArray(),e}dispose(){var t;super.dispose();const e=this.getScene();e&&e.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigChangeObserver),(t=this._sceneUBO)==null||t.dispose()}}Y._CreateMirror=(a,e,t,i)=>new $u(a,e,t,i);class jw extends ps{constructor(){super(),this.DIFFUSE=!1,this.DIFFUSEDIRECTUV=0,this.GAMMADIFFUSE=!1,this.DIFFUSEHASALPHA=!1,this.OPACITYFRESNEL=!1,this.REFLECTIONBLUR=!1,this.REFLECTIONFRESNEL=!1,this.REFLECTIONFALLOFF=!1,this.TEXTURELODSUPPORT=!1,this.PREMULTIPLYALPHA=!1,this.USERGBCOLOR=!1,this.USEHIGHLIGHTANDSHADOWCOLORS=!1,this.BACKMAT_SHADOWONLY=!1,this.NOISE=!1,this.REFLECTIONBGR=!1,this.PROJECTED_GROUND=!1,this.IMAGEPROCESSING=!1,this.VIGNETTE=!1,this.VIGNETTEBLENDMODEMULTIPLY=!1,this.VIGNETTEBLENDMODEOPAQUE=!1,this.TONEMAPPING=0,this.CONTRAST=!1,this.COLORCURVES=!1,this.COLORGRADING=!1,this.COLORGRADING3D=!1,this.SAMPLER3DGREENDEPTH=!1,this.SAMPLER3DBGRMAP=!1,this.DITHER=!1,this.IMAGEPROCESSINGPOSTPROCESS=!1,this.SKIPFINALCOLORCLAMP=!1,this.EXPOSURE=!1,this.MULTIVIEW=!1,this.REFLECTION=!1,this.REFLECTIONMAP_3D=!1,this.REFLECTIONMAP_SPHERICAL=!1,this.REFLECTIONMAP_PLANAR=!1,this.REFLECTIONMAP_CUBIC=!1,this.REFLECTIONMAP_PROJECTION=!1,this.REFLECTIONMAP_SKYBOX=!1,this.REFLECTIONMAP_EXPLICIT=!1,this.REFLECTIONMAP_EQUIRECTANGULAR=!1,this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED=!1,this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED=!1,this.INVERTCUBICMAP=!1,this.REFLECTIONMAP_OPPOSITEZ=!1,this.LODINREFLECTIONALPHA=!1,this.GAMMAREFLECTION=!1,this.RGBDREFLECTION=!1,this.EQUIRECTANGULAR_RELFECTION_FOV=!1,this.MAINUV1=!1,this.MAINUV2=!1,this.UV1=!1,this.UV2=!1,this.CLIPPLANE=!1,this.CLIPPLANE2=!1,this.CLIPPLANE3=!1,this.CLIPPLANE4=!1,this.CLIPPLANE5=!1,this.CLIPPLANE6=!1,this.POINTSIZE=!1,this.FOG=!1,this.NORMAL=!1,this.NUM_BONE_INFLUENCERS=0,this.BonesPerMesh=0,this.INSTANCES=!1,this.SHADOWFLOAT=!1,this.LOGARITHMICDEPTH=!1,this.NONUNIFORMSCALING=!1,this.ALPHATEST=!1,this.rebuild()}}class Fe extends oy{get _perceptualColor(){return this.__perceptualColor}set _perceptualColor(e){this.__perceptualColor=e,this._computePrimaryColorFromPerceptualColor(),this._markAllSubMeshesAsLightsDirty()}get primaryColorShadowLevel(){return this._primaryColorShadowLevel}set primaryColorShadowLevel(e){this._primaryColorShadowLevel=e,this._computePrimaryColors(),this._markAllSubMeshesAsLightsDirty()}get primaryColorHighlightLevel(){return this._primaryColorHighlightLevel}set primaryColorHighlightLevel(e){this._primaryColorHighlightLevel=e,this._computePrimaryColors(),this._markAllSubMeshesAsLightsDirty()}set reflectionStandardFresnelWeight(e){let t=e;t<.5?(t=t*2,this.reflectionReflectance0=Fe.StandardReflectance0*t,this.reflectionReflectance90=Fe.StandardReflectance90*t):(t=t*2-1,this.reflectionReflectance0=Fe.StandardReflectance0+(1-Fe.StandardReflectance0)*t,this.reflectionReflectance90=Fe.StandardReflectance90+(1-Fe.StandardReflectance90)*t)}get fovMultiplier(){return this._fovMultiplier}set fovMultiplier(e){isNaN(e)&&(e=1),this._fovMultiplier=Math.max(0,Math.min(2,e))}_attachImageProcessingConfiguration(e){e!==this._imageProcessingConfiguration&&(this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),e?this._imageProcessingConfiguration=e:this._imageProcessingConfiguration=this.getScene().imageProcessingConfiguration,this._imageProcessingConfiguration&&(this._imageProcessingObserver=this._imageProcessingConfiguration.onUpdateParameters.add(()=>{this._computePrimaryColorFromPerceptualColor(),this._markAllSubMeshesAsImageProcessingDirty()})))}get imageProcessingConfiguration(){return this._imageProcessingConfiguration}set imageProcessingConfiguration(e){this._attachImageProcessingConfiguration(e),this._markAllSubMeshesAsTexturesDirty()}get cameraColorCurvesEnabled(){return this.imageProcessingConfiguration.colorCurvesEnabled}set cameraColorCurvesEnabled(e){this.imageProcessingConfiguration.colorCurvesEnabled=e}get cameraColorGradingEnabled(){return this.imageProcessingConfiguration.colorGradingEnabled}set cameraColorGradingEnabled(e){this.imageProcessingConfiguration.colorGradingEnabled=e}get cameraToneMappingEnabled(){return this._imageProcessingConfiguration.toneMappingEnabled}set cameraToneMappingEnabled(e){this._imageProcessingConfiguration.toneMappingEnabled=e}get cameraExposure(){return this._imageProcessingConfiguration.exposure}set cameraExposure(e){this._imageProcessingConfiguration.exposure=e}get cameraContrast(){return this._imageProcessingConfiguration.contrast}set cameraContrast(e){this._imageProcessingConfiguration.contrast=e}get cameraColorGradingTexture(){return this._imageProcessingConfiguration.colorGradingTexture}set cameraColorGradingTexture(e){this.imageProcessingConfiguration.colorGradingTexture=e}get cameraColorCurves(){return this.imageProcessingConfiguration.colorCurves}set cameraColorCurves(e){this.imageProcessingConfiguration.colorCurves=e}constructor(e,t,i=!1){super(e,t,void 0,i),this.primaryColor=ne.White(),this._primaryColorShadowLevel=0,this._primaryColorHighlightLevel=0,this.reflectionTexture=null,this.reflectionBlur=0,this.diffuseTexture=null,this._shadowLights=null,this.shadowLights=null,this.shadowLevel=0,this.sceneCenter=m.Zero(),this.opacityFresnel=!0,this.reflectionFresnel=!1,this.reflectionFalloffDistance=0,this.reflectionAmount=1,this.reflectionReflectance0=.05,this.reflectionReflectance90=.5,this.useRGBColor=!0,this.enableNoise=!1,this._fovMultiplier=1,this.useEquirectangularFOV=!1,this._maxSimultaneousLights=4,this.maxSimultaneousLights=4,this._shadowOnly=!1,this.shadowOnly=!1,this._imageProcessingObserver=null,this.switchToBGR=!1,this._enableGroundProjection=!1,this.enableGroundProjection=!1,this.projectedGroundRadius=1e3,this.projectedGroundHeight=10,this._renderTargets=new Go(16),this._reflectionControls=Ve.Zero(),this._white=ne.White(),this._primaryShadowColor=ne.Black(),this._primaryHighlightColor=ne.Black(),this._shadersLoaded=!1,this._attachImageProcessingConfiguration(null),this.getRenderTargetTextures=()=>(this._renderTargets.reset(),this._diffuseTexture&&this._diffuseTexture.isRenderTarget&&this._renderTargets.push(this._diffuseTexture),this._reflectionTexture&&this._reflectionTexture.isRenderTarget&&this._renderTargets.push(this._reflectionTexture),this._renderTargets)}get hasRenderTargetTextures(){return!!(this._diffuseTexture&&this._diffuseTexture.isRenderTarget||this._reflectionTexture&&this._reflectionTexture.isRenderTarget)}needAlphaTesting(){return!0}needAlphaBlending(){return this.alpha<1||this._diffuseTexture!=null&&this._diffuseTexture.hasAlpha||this._shadowOnly}isReadyForSubMesh(e,t,i=!1){const r=t._drawWrapper;if(r.effect&&this.isFrozen&&r._wasPreviouslyReady&&r._wasPreviouslyUsingInstances===i)return!0;t.materialDefines||(t.materialDefines=new jw);const s=this.getScene(),n=t.materialDefines;if(this._isReadyForSubMesh(t))return!0;const o=s.getEngine();if(mu(s,e,n,!1,this._maxSimultaneousLights),n._needNormals=!0,zm(s,n),n._areTexturesDirty){if(n._needUVs=!1,s.texturesEnabled){if(s.getEngine().getCaps().textureLOD&&(n.TEXTURELODSUPPORT=!0),this._diffuseTexture&&vr.DiffuseTextureEnabled){if(!this._diffuseTexture.isReadyOrNotBlocking())return!1;Um(this._diffuseTexture,n,"DIFFUSE"),n.DIFFUSEHASALPHA=this._diffuseTexture.hasAlpha,n.GAMMADIFFUSE=this._diffuseTexture.gammaSpace,n.OPACITYFRESNEL=this._opacityFresnel}else n.DIFFUSE=!1,n.DIFFUSEDIRECTUV=0,n.DIFFUSEHASALPHA=!1,n.GAMMADIFFUSE=!1,n.OPACITYFRESNEL=!1;const l=this._reflectionTexture;if(l&&vr.ReflectionTextureEnabled){if(!l.isReadyOrNotBlocking())return!1;switch(n.REFLECTION=!0,n.GAMMAREFLECTION=l.gammaSpace,n.RGBDREFLECTION=l.isRGBD,n.REFLECTIONBLUR=this._reflectionBlur>0,n.LODINREFLECTIONALPHA=l.lodLevelInAlpha,n.EQUIRECTANGULAR_RELFECTION_FOV=this.useEquirectangularFOV,n.REFLECTIONBGR=this.switchToBGR,l.coordinatesMode===Y.INVCUBIC_MODE&&(n.INVERTCUBICMAP=!0),n.REFLECTIONMAP_3D=l.isCube,n.REFLECTIONMAP_OPPOSITEZ=n.REFLECTIONMAP_3D&&this.getScene().useRightHandedSystem?!l.invertZ:l.invertZ,l.coordinatesMode){case Y.EXPLICIT_MODE:n.REFLECTIONMAP_EXPLICIT=!0;break;case Y.PLANAR_MODE:n.REFLECTIONMAP_PLANAR=!0;break;case Y.PROJECTION_MODE:n.REFLECTIONMAP_PROJECTION=!0;break;case Y.SKYBOX_MODE:n.REFLECTIONMAP_SKYBOX=!0;break;case Y.SPHERICAL_MODE:n.REFLECTIONMAP_SPHERICAL=!0;break;case Y.EQUIRECTANGULAR_MODE:n.REFLECTIONMAP_EQUIRECTANGULAR=!0;break;case Y.FIXED_EQUIRECTANGULAR_MODE:n.REFLECTIONMAP_EQUIRECTANGULAR_FIXED=!0;break;case Y.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:n.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED=!0;break;case Y.CUBIC_MODE:case Y.INVCUBIC_MODE:default:n.REFLECTIONMAP_CUBIC=!0;break}this.reflectionFresnel?(n.REFLECTIONFRESNEL=!0,n.REFLECTIONFALLOFF=this.reflectionFalloffDistance>0,this._reflectionControls.x=this.reflectionAmount,this._reflectionControls.y=this.reflectionReflectance0,this._reflectionControls.z=this.reflectionReflectance90,this._reflectionControls.w=1/this.reflectionFalloffDistance):(n.REFLECTIONFRESNEL=!1,n.REFLECTIONFALLOFF=!1)}else n.REFLECTION=!1,n.REFLECTIONFRESNEL=!1,n.REFLECTIONFALLOFF=!1,n.REFLECTIONBLUR=!1,n.REFLECTIONMAP_3D=!1,n.REFLECTIONMAP_SPHERICAL=!1,n.REFLECTIONMAP_PLANAR=!1,n.REFLECTIONMAP_CUBIC=!1,n.REFLECTIONMAP_PROJECTION=!1,n.REFLECTIONMAP_SKYBOX=!1,n.REFLECTIONMAP_EXPLICIT=!1,n.REFLECTIONMAP_EQUIRECTANGULAR=!1,n.REFLECTIONMAP_EQUIRECTANGULAR_FIXED=!1,n.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED=!1,n.INVERTCUBICMAP=!1,n.REFLECTIONMAP_OPPOSITEZ=!1,n.LODINREFLECTIONALPHA=!1,n.GAMMAREFLECTION=!1,n.RGBDREFLECTION=!1}n.PREMULTIPLYALPHA=this.alphaMode===7||this.alphaMode===8,n.USERGBCOLOR=this._useRGBColor,n.NOISE=this._enableNoise}if(n._areLightsDirty&&(n.USEHIGHLIGHTANDSHADOWCOLORS=!this._useRGBColor&&(this._primaryColorShadowLevel!==0||this._primaryColorHighlightLevel!==0),n.BACKMAT_SHADOWONLY=this._shadowOnly),n._areImageProcessingDirty&&this._imageProcessingConfiguration){if(!this._imageProcessingConfiguration.isReady())return!1;this._imageProcessingConfiguration.prepareDefines(n)}if(n._areMiscDirty&&(n.REFLECTIONMAP_3D&&this._enableGroundProjection?(n.PROJECTED_GROUND=!0,n.REFLECTIONMAP_SKYBOX=!0):n.PROJECTED_GROUND=!1),ly(e,s,this._useLogarithmicDepth,this.pointsCloud,this.fogEnabled,this.needAlphaTestingForMesh(e),n),uy(s,o,this,n,i,null,t.getRenderingMesh().hasThinInstances),cy(e,n,!1,!0,!1)&&e&&!s.getEngine().getCaps().standardDerivatives&&!e.isVerticesDataPresent(N.NormalKind)&&(e.createNormals(!0),L.Warn("BackgroundMaterial: Normals have been created for the mesh: "+e.name)),n.isDirty){n.markAsProcessed(),s.resetCachedMaterial();const l=new Xn;n.FOG&&l.addFallback(0,"FOG"),n.POINTSIZE&&l.addFallback(1,"POINTSIZE"),n.MULTIVIEW&&l.addFallback(0,"MULTIVIEW"),hy(n,l,this._maxSimultaneousLights);const u=[N.PositionKind];n.NORMAL&&u.push(N.NormalKind),n.UV1&&u.push(N.UVKind),n.UV2&&u.push(N.UV2Kind),dy(u,e,n,l),fy(u,n);const c=["world","view","viewProjection","vEyePosition","vLightsType","vFogInfos","vFogColor","pointSize","mBones","vPrimaryColor","vPrimaryColorShadow","vReflectionInfos","reflectionMatrix","vReflectionMicrosurfaceInfos","fFovMultiplier","shadowLevel","alpha","vBackgroundCenter","vReflectionControl","vDiffuseInfos","diffuseMatrix","projectedGroundInfos","logarithmicDepthConstant"];_n(c);const h=["diffuseSampler","reflectionSampler","reflectionSamplerLow","reflectionSamplerHigh"],d=["Material","Scene"];ts&&(ts.PrepareUniforms(c,n),ts.PrepareSamplers(h,n)),py({uniformsNames:c,uniformBuffersNames:d,samplers:h,defines:n,maxSimultaneousLights:this._maxSimultaneousLights});const f=n.toString(),p=s.getEngine().createEffect("background",{attributes:u,uniformsNames:c,uniformBuffersNames:d,samplers:h,defines:f,fallbacks:l,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousLights:this._maxSimultaneousLights},shaderLanguage:this._shaderLanguage,extraInitializationsAsync:this._shadersLoaded?void 0:async()=>{this.shaderLanguage===1?await Promise.all([k(()=>Promise.resolve().then(()=>wN),void 0),k(()=>Promise.resolve().then(()=>LN),void 0)]):await Promise.all([k(()=>Promise.resolve().then(()=>zN),void 0),k(()=>Promise.resolve().then(()=>$N),void 0)]),this._shadersLoaded=!0}},o);t.setEffect(p,n,this._materialContext),this.buildUniformLayout()}return!t.effect||!t.effect.isReady()?!1:(n._renderId=s.getRenderId(),r._wasPreviouslyReady=!0,r._wasPreviouslyUsingInstances=i,this._checkScenePerformancePriority(),!0)}_computePrimaryColorFromPerceptualColor(){this.__perceptualColor&&(this._primaryColor.copyFrom(this.__perceptualColor),this._primaryColor.toLinearSpaceToRef(this._primaryColor,this.getScene().getEngine().useExactSrgbConversions),this._imageProcessingConfiguration&&this._primaryColor.scaleToRef(1/this._imageProcessingConfiguration.exposure,this._primaryColor),this._computePrimaryColors())}_computePrimaryColors(){this._primaryColorShadowLevel===0&&this._primaryColorHighlightLevel===0||(this._primaryColor.scaleToRef(this._primaryColorShadowLevel,this._primaryShadowColor),this._primaryColor.subtractToRef(this._primaryShadowColor,this._primaryShadowColor),this._white.subtractToRef(this._primaryColor,this._primaryHighlightColor),this._primaryHighlightColor.scaleToRef(this._primaryColorHighlightLevel,this._primaryHighlightColor),this._primaryColor.addToRef(this._primaryHighlightColor,this._primaryHighlightColor))}buildUniformLayout(){this._uniformBuffer.addUniform("vPrimaryColor",4),this._uniformBuffer.addUniform("vPrimaryColorShadow",4),this._uniformBuffer.addUniform("vDiffuseInfos",2),this._uniformBuffer.addUniform("vReflectionInfos",2),this._uniformBuffer.addUniform("diffuseMatrix",16),this._uniformBuffer.addUniform("reflectionMatrix",16),this._uniformBuffer.addUniform("vReflectionMicrosurfaceInfos",3),this._uniformBuffer.addUniform("fFovMultiplier",1),this._uniformBuffer.addUniform("pointSize",1),this._uniformBuffer.addUniform("shadowLevel",1),this._uniformBuffer.addUniform("alpha",1),this._uniformBuffer.addUniform("vBackgroundCenter",3),this._uniformBuffer.addUniform("vReflectionControl",4),this._uniformBuffer.addUniform("projectedGroundInfos",2),this._uniformBuffer.create()}unbind(){this._diffuseTexture&&this._diffuseTexture.isRenderTarget&&this._uniformBuffer.setTexture("diffuseSampler",null),this._reflectionTexture&&this._reflectionTexture.isRenderTarget&&this._uniformBuffer.setTexture("reflectionSampler",null),super.unbind()}bindOnlyWorldMatrix(e){this._activeEffect.setMatrix("world",e)}bindForSubMesh(e,t,i){const r=this.getScene(),s=i.materialDefines;if(!s)return;const n=i.effect;if(!n)return;this._activeEffect=n,this.bindOnlyWorldMatrix(e),Yn(t,this._activeEffect);const o=this._mustRebind(r,n,i,t.visibility);if(o){this._uniformBuffer.bindToEffect(n,"Material"),this.bindViewProjection(n);const l=this._reflectionTexture;(!this._uniformBuffer.useUbo||!this.isFrozen||!this._uniformBuffer.isSync||i._drawWrapper._forceRebindOnNextCall)&&(r.texturesEnabled&&(this._diffuseTexture&&vr.DiffuseTextureEnabled&&(this._uniformBuffer.updateFloat2("vDiffuseInfos",this._diffuseTexture.coordinatesIndex,this._diffuseTexture.level),Gm(this._diffuseTexture,this._uniformBuffer,"diffuse")),l&&vr.ReflectionTextureEnabled&&(this._uniformBuffer.updateMatrix("reflectionMatrix",l.getReflectionTextureMatrix()),this._uniformBuffer.updateFloat2("vReflectionInfos",l.level,this._reflectionBlur),this._uniformBuffer.updateFloat3("vReflectionMicrosurfaceInfos",l.getSize().width,l.lodGenerationScale,l.lodGenerationOffset))),this.shadowLevel>0&&this._uniformBuffer.updateFloat("shadowLevel",this.shadowLevel),this._uniformBuffer.updateFloat("alpha",this.alpha),this.pointsCloud&&this._uniformBuffer.updateFloat("pointSize",this.pointSize),s.USEHIGHLIGHTANDSHADOWCOLORS?(this._uniformBuffer.updateColor4("vPrimaryColor",this._primaryHighlightColor,1),this._uniformBuffer.updateColor4("vPrimaryColorShadow",this._primaryShadowColor,1)):this._uniformBuffer.updateColor4("vPrimaryColor",this._primaryColor,1)),this._uniformBuffer.updateFloat("fFovMultiplier",this._fovMultiplier),r.texturesEnabled&&(this._diffuseTexture&&vr.DiffuseTextureEnabled&&this._uniformBuffer.setTexture("diffuseSampler",this._diffuseTexture),l&&vr.ReflectionTextureEnabled&&(s.REFLECTIONBLUR&&s.TEXTURELODSUPPORT?this._uniformBuffer.setTexture("reflectionSampler",l):s.REFLECTIONBLUR?(this._uniformBuffer.setTexture("reflectionSampler",l._lodTextureMid||l),this._uniformBuffer.setTexture("reflectionSamplerLow",l._lodTextureLow||l),this._uniformBuffer.setTexture("reflectionSamplerHigh",l._lodTextureHigh||l)):this._uniformBuffer.setTexture("reflectionSampler",l),s.REFLECTIONFRESNEL&&(this._uniformBuffer.updateFloat3("vBackgroundCenter",this.sceneCenter.x,this.sceneCenter.y,this.sceneCenter.z),this._uniformBuffer.updateFloat4("vReflectionControl",this._reflectionControls.x,this._reflectionControls.y,this._reflectionControls.z,this._reflectionControls.w))),s.PROJECTED_GROUND&&this._uniformBuffer.updateFloat2("projectedGroundInfos",this.projectedGroundRadius,this.projectedGroundHeight)),Fs(this._activeEffect,this,r),r.bindEyePosition(n)}else r.getEngine()._features.needToAlwaysBindUniformBuffers&&(this._uniformBuffer.bindToEffect(n,"Material"),this._needToBindSceneUbo=!0);(o||!this.isFrozen)&&(r.lightsEnabled&&_u(r,t,this._activeEffect,s,this._maxSimultaneousLights),this.bindView(n),gu(r,t,this._activeEffect,!0),this._useLogarithmicDepth&&qa(s,n,r),this._imageProcessingConfiguration&&this._imageProcessingConfiguration.bind(this._activeEffect)),this._afterBind(t,this._activeEffect,i),this._uniformBuffer.update()}hasTexture(e){return!!(super.hasTexture(e)||this._reflectionTexture===e||this._diffuseTexture===e)}dispose(e=!1,t=!1){t&&(this.diffuseTexture&&this.diffuseTexture.dispose(),this.reflectionTexture&&this.reflectionTexture.dispose()),this._renderTargets.dispose(),this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),super.dispose(e)}clone(e){return Me.Clone(()=>new Fe(e,this.getScene()),this)}serialize(){const e=super.serialize();return e.customType="BABYLON.BackgroundMaterial",e}getClassName(){return"BackgroundMaterial"}static Parse(e,t,i){return Me.Parse(()=>new Fe(e.name,t),e,t,i)}}Fe.StandardReflectance0=.05;Fe.StandardReflectance90=.5;C([ir()],Fe.prototype,"_primaryColor",void 0);C([Ue("_markAllSubMeshesAsLightsDirty")],Fe.prototype,"primaryColor",void 0);C([ir()],Fe.prototype,"__perceptualColor",void 0);C([F()],Fe.prototype,"_primaryColorShadowLevel",void 0);C([F()],Fe.prototype,"_primaryColorHighlightLevel",void 0);C([Ue("_markAllSubMeshesAsLightsDirty")],Fe.prototype,"primaryColorHighlightLevel",null);C([Mi()],Fe.prototype,"_reflectionTexture",void 0);C([Ue("_markAllSubMeshesAsTexturesDirty")],Fe.prototype,"reflectionTexture",void 0);C([F()],Fe.prototype,"_reflectionBlur",void 0);C([Ue("_markAllSubMeshesAsTexturesDirty")],Fe.prototype,"reflectionBlur",void 0);C([Mi()],Fe.prototype,"_diffuseTexture",void 0);C([Ue("_markAllSubMeshesAsTexturesDirty")],Fe.prototype,"diffuseTexture",void 0);C([Ue("_markAllSubMeshesAsTexturesDirty")],Fe.prototype,"shadowLights",void 0);C([F()],Fe.prototype,"_shadowLevel",void 0);C([Ue("_markAllSubMeshesAsTexturesDirty")],Fe.prototype,"shadowLevel",void 0);C([Hn()],Fe.prototype,"_sceneCenter",void 0);C([Ue("_markAllSubMeshesAsTexturesDirty")],Fe.prototype,"sceneCenter",void 0);C([F()],Fe.prototype,"_opacityFresnel",void 0);C([Ue("_markAllSubMeshesAsTexturesDirty")],Fe.prototype,"opacityFresnel",void 0);C([F()],Fe.prototype,"_reflectionFresnel",void 0);C([Ue("_markAllSubMeshesAsTexturesDirty")],Fe.prototype,"reflectionFresnel",void 0);C([F()],Fe.prototype,"_reflectionFalloffDistance",void 0);C([Ue("_markAllSubMeshesAsTexturesDirty")],Fe.prototype,"reflectionFalloffDistance",void 0);C([F()],Fe.prototype,"_reflectionAmount",void 0);C([Ue("_markAllSubMeshesAsTexturesDirty")],Fe.prototype,"reflectionAmount",void 0);C([F()],Fe.prototype,"_reflectionReflectance0",void 0);C([Ue("_markAllSubMeshesAsTexturesDirty")],Fe.prototype,"reflectionReflectance0",void 0);C([F()],Fe.prototype,"_reflectionReflectance90",void 0);C([Ue("_markAllSubMeshesAsTexturesDirty")],Fe.prototype,"reflectionReflectance90",void 0);C([F()],Fe.prototype,"_useRGBColor",void 0);C([Ue("_markAllSubMeshesAsTexturesDirty")],Fe.prototype,"useRGBColor",void 0);C([F()],Fe.prototype,"_enableNoise",void 0);C([Ue("_markAllSubMeshesAsTexturesDirty")],Fe.prototype,"enableNoise",void 0);C([F()],Fe.prototype,"_maxSimultaneousLights",void 0);C([Ue("_markAllSubMeshesAsTexturesDirty")],Fe.prototype,"maxSimultaneousLights",void 0);C([F()],Fe.prototype,"_shadowOnly",void 0);C([Ue("_markAllSubMeshesAsLightsDirty")],Fe.prototype,"shadowOnly",void 0);C([oM()],Fe.prototype,"_imageProcessingConfiguration",void 0);C([F(),Ue("_markAllSubMeshesAsMiscDirty")],Fe.prototype,"enableGroundProjection",void 0);C([F()],Fe.prototype,"projectedGroundRadius",void 0);C([F()],Fe.prototype,"projectedGroundHeight",void 0);B("BABYLON.BackgroundMaterial",Fe);class Wn{static _GetDefaultOptions(e){return{createGround:!0,groundSize:15,groundTexture:ae.GetAssetUrl(this._GroundTextureCDNUrl),groundColor:new ne(.2,.2,.3).toLinearSpace(e.getEngine().useExactSrgbConversions).scale(3),groundOpacity:.9,enableGroundShadow:!0,groundShadowLevel:.5,enableGroundMirror:!1,groundMirrorSizeRatio:.3,groundMirrorBlurKernel:64,groundMirrorAmount:1,groundMirrorFresnelWeight:1,groundMirrorFallOffDistance:0,groundMirrorTextureType:0,groundYBias:1e-5,createSkybox:!0,skyboxSize:20,skyboxTexture:ae.GetAssetUrl(this._SkyboxTextureCDNUrl),skyboxColor:new ne(.2,.2,.3).toLinearSpace(e.getEngine().useExactSrgbConversions).scale(3),backgroundYRotation:0,sizeAuto:!0,rootPosition:m.Zero(),setupImageProcessing:!0,environmentTexture:ae.GetAssetUrl(this._EnvironmentTextureCDNUrl),cameraExposure:.8,cameraContrast:1.2,toneMappingEnabled:!0}}get rootMesh(){return this._rootMesh}get skybox(){return this._skybox}get skyboxTexture(){return this._skyboxTexture}get skyboxMaterial(){return this._skyboxMaterial}get ground(){return this._ground}get groundTexture(){return this._groundTexture}get groundMirror(){return this._groundMirror}get groundMirrorRenderList(){return this._groundMirror?this._groundMirror.renderList:null}get groundMaterial(){return this._groundMaterial}constructor(e,t){this._errorHandler=(i,r)=>{this.onErrorObservable.notifyObservers({message:i,exception:r})},this._options={...Wn._GetDefaultOptions(t),...e},this._scene=t,this.onErrorObservable=new j,this._setupBackground(),this._setupImageProcessing()}updateOptions(e){const t={...this._options,...e};this._ground&&!t.createGround&&(this._ground.dispose(),this._ground=null),this._groundMaterial&&!t.createGround&&(this._groundMaterial.dispose(),this._groundMaterial=null),this._groundTexture&&this._options.groundTexture!=t.groundTexture&&(this._groundTexture.dispose(),this._groundTexture=null),this._skybox&&!t.createSkybox&&(this._skybox.dispose(),this._skybox=null),this._skyboxMaterial&&!t.createSkybox&&(this._skyboxMaterial.dispose(),this._skyboxMaterial=null),this._skyboxTexture&&this._options.skyboxTexture!=t.skyboxTexture&&(this._skyboxTexture.dispose(),this._skyboxTexture=null),this._groundMirror&&!t.enableGroundMirror&&(this._groundMirror.dispose(),this._groundMirror=null),this._scene.environmentTexture&&this._options.environmentTexture!=t.environmentTexture&&this._scene.environmentTexture.dispose(),this._options=t,this._setupBackground(),this._setupImageProcessing()}setMainColor(e){this.groundMaterial&&(this.groundMaterial.primaryColor=e),this.skyboxMaterial&&(this.skyboxMaterial.primaryColor=e),this.groundMirror&&(this.groundMirror.clearColor=new xe(e.r,e.g,e.b,1))}_setupImageProcessing(){this._options.setupImageProcessing&&(this._scene.imageProcessingConfiguration.contrast=this._options.cameraContrast,this._scene.imageProcessingConfiguration.exposure=this._options.cameraExposure,this._scene.imageProcessingConfiguration.toneMappingEnabled=this._options.toneMappingEnabled,this._setupEnvironmentTexture())}_setupEnvironmentTexture(){if(this._scene.environmentTexture)return;if(this._options.environmentTexture instanceof Vr){this._scene.environmentTexture=this._options.environmentTexture;return}const e=rn.CreateFromPrefilteredData(this._options.environmentTexture,this._scene);this._scene.environmentTexture=e}_setupBackground(){this._rootMesh||(this._rootMesh=new z("BackgroundHelper",this._scene)),this._rootMesh.rotation.y=this._options.backgroundYRotation;const e=this._getSceneSize();this._options.createGround&&(this._setupGround(e),this._setupGroundMaterial(),this._setupGroundDiffuseTexture(),this._options.enableGroundMirror&&this._setupGroundMirrorTexture(e),this._setupMirrorInGroundMaterial()),this._options.createSkybox&&(this._setupSkybox(e),this._setupSkyboxMaterial(),this._setupSkyboxReflectionTexture()),this._rootMesh.position.x=e.rootPosition.x,this._rootMesh.position.z=e.rootPosition.z,this._rootMesh.position.y=e.rootPosition.y}_getSceneSize(){let e=this._options.groundSize,t=this._options.skyboxSize,i=this._options.rootPosition;if(!this._scene.meshes||this._scene.meshes.length===1)return{groundSize:e,skyboxSize:t,rootPosition:i};const r=this._scene.getWorldExtends(n=>n!==this._ground&&n!==this._rootMesh&&n!==this._skybox),s=r.max.subtract(r.min);if(this._options.sizeAuto){this._scene.activeCamera instanceof lt&&this._scene.activeCamera.upperRadiusLimit&&(e=this._scene.activeCamera.upperRadiusLimit*2,t=e);const n=s.length();n>e&&(e=n*2,t=e),e*=1.1,t*=1.5,i=r.min.add(s.scale(.5)),i.y=r.min.y-this._options.groundYBias}return{groundSize:e,skyboxSize:t,rootPosition:i}}_setupGround(e){(!this._ground||this._ground.isDisposed())&&(this._ground=gn("BackgroundPlane",{size:e.groundSize},this._scene),this._ground.rotation.x=Math.PI/2,this._ground.isPickable=!1,this._ground.parent=this._rootMesh,this._ground.onDisposeObservable.add(()=>{this._ground=null})),this._ground.receiveShadows=this._options.enableGroundShadow}_setupGroundMaterial(){this._groundMaterial||(this._groundMaterial=new Fe("BackgroundPlaneMaterial",this._scene)),this._groundMaterial.alpha=this._options.groundOpacity,this._groundMaterial.alphaMode=8,this._groundMaterial.shadowLevel=this._options.groundShadowLevel,this._groundMaterial.primaryColor=this._options.groundColor,this._groundMaterial.useRGBColor=!1,this._groundMaterial.enableNoise=!0,this._ground&&(this._ground.material=this._groundMaterial)}_setupGroundDiffuseTexture(){if(this._groundMaterial&&!this._groundTexture){if(this._options.groundTexture instanceof Vr){this._groundMaterial.diffuseTexture=this._options.groundTexture;return}this._groundTexture=new Y(this._options.groundTexture,this._scene,void 0,void 0,void 0,void 0,this._errorHandler),this._groundTexture.gammaSpace=!1,this._groundTexture.hasAlpha=!0,this._groundMaterial.diffuseTexture=this._groundTexture}}_setupGroundMirrorTexture(e){const t=Y.CLAMP_ADDRESSMODE;if(!this._groundMirror&&(this._groundMirror=new $u("BackgroundPlaneMirrorTexture",{ratio:this._options.groundMirrorSizeRatio},this._scene,!1,this._options.groundMirrorTextureType,Y.BILINEAR_SAMPLINGMODE,!0),this._groundMirror.mirrorPlane=new ko(0,-1,0,e.rootPosition.y),this._groundMirror.anisotropicFilteringLevel=1,this._groundMirror.wrapU=t,this._groundMirror.wrapV=t,this._groundMirror.renderList))for(let r=0;r<this._scene.meshes.length;r++){const s=this._scene.meshes[r];s!==this._ground&&s!==this._skybox&&s!==this._rootMesh&&this._groundMirror.renderList.push(s)}const i=this._options.groundColor.toGammaSpace(this._scene.getEngine().useExactSrgbConversions);this._groundMirror.clearColor=new xe(i.r,i.g,i.b,1),this._groundMirror.adaptiveBlurKernel=this._options.groundMirrorBlurKernel}_setupMirrorInGroundMaterial(){this._groundMaterial&&(this._groundMaterial.reflectionTexture=this._groundMirror,this._groundMaterial.reflectionFresnel=!0,this._groundMaterial.reflectionAmount=this._options.groundMirrorAmount,this._groundMaterial.reflectionStandardFresnelWeight=this._options.groundMirrorFresnelWeight,this._groundMaterial.reflectionFalloffDistance=this._options.groundMirrorFallOffDistance)}_setupSkybox(e){(!this._skybox||this._skybox.isDisposed())&&(this._skybox=Xi("BackgroundSkybox",{size:e.skyboxSize,sideOrientation:z.BACKSIDE},this._scene),this._skybox.isPickable=!1,this._skybox.onDisposeObservable.add(()=>{this._skybox=null})),this._skybox.parent=this._rootMesh}_setupSkyboxMaterial(){this._skybox&&(this._skyboxMaterial||(this._skyboxMaterial=new Fe("BackgroundSkyboxMaterial",this._scene)),this._skyboxMaterial.useRGBColor=!1,this._skyboxMaterial.primaryColor=this._options.skyboxColor,this._skyboxMaterial.enableNoise=!0,this._skybox.material=this._skyboxMaterial)}_setupSkyboxReflectionTexture(){if(this._skyboxMaterial&&!this._skyboxTexture){if(this._options.skyboxTexture instanceof Vr){this._skyboxMaterial.reflectionTexture=this._options.skyboxTexture;return}this._skyboxTexture=new rn(this._options.skyboxTexture,this._scene,void 0,void 0,void 0,void 0,this._errorHandler),this._skyboxTexture.coordinatesMode=Y.SKYBOX_MODE,this._skyboxTexture.gammaSpace=!1,this._skyboxMaterial.reflectionTexture=this._skyboxTexture}}dispose(){this._groundMaterial&&this._groundMaterial.dispose(!0,!0),this._skyboxMaterial&&this._skyboxMaterial.dispose(!0,!0),this._rootMesh.dispose(!1)}}Wn._GroundTextureCDNUrl="https://assets.babylonjs.com/core/environments/backgroundGround.png";Wn._SkyboxTextureCDNUrl="https://assets.babylonjs.com/core/environments/backgroundSkybox.dds";Wn._EnvironmentTextureCDNUrl="https://assets.babylonjs.com/core/environments/environmentSpecular.env";class Ri extends Bi{get texture(){return this._texture}set texture(e){this._texture!==e&&(this._texture=e,this._useDirectMapping?(this._texture.wrapU=Y.CLAMP_ADDRESSMODE,this._texture.wrapV=Y.CLAMP_ADDRESSMODE,this._material.diffuseTexture=this._texture):(this._texture.coordinatesMode=Y.FIXED_EQUIRECTANGULAR_MIRRORED_MODE,this._texture.wrapV=Y.CLAMP_ADDRESSMODE,this._material.reflectionTexture=this._texture),this._changeTextureMode(this._textureMode))}get mesh(){return this._mesh}get fovMultiplier(){return this._material.fovMultiplier}set fovMultiplier(e){this._material.fovMultiplier=e}get textureMode(){return this._textureMode}set textureMode(e){this._textureMode!==e&&this._changeTextureMode(e)}get halfDome(){return this._halfDome}set halfDome(e){this._halfDome=e,this._halfDomeMask.setEnabled(e),this._changeTextureMode(this._textureMode)}set crossEye(e){this._crossEye=e,this._changeTextureMode(this._textureMode)}get crossEye(){return this._crossEye}get material(){return this._material}constructor(e,t,i,r,s=null){super(e,r),this.onError=s,this._halfDome=!1,this._crossEye=!1,this._useDirectMapping=!1,this._textureMode=Ri.MODE_MONOSCOPIC,this._onBeforeCameraRenderObserver=null,this.onLoadErrorObservable=new j,this.onLoadObservable=new j,r=this.getScene(),e=e||"textureDome",i.resolution=Math.abs(i.resolution)|0||32,i.clickToPlay=!!i.clickToPlay,i.autoPlay=i.autoPlay===void 0?!0:!!i.autoPlay,i.loop=i.loop===void 0?!0:!!i.loop,i.size=Math.abs(i.size)||(r.activeCamera?r.activeCamera.maxZ*.48:1e3),i.useDirectMapping===void 0?this._useDirectMapping=!0:this._useDirectMapping=i.useDirectMapping,i.faceForward===void 0&&(i.faceForward=!0),this._setReady(!1),i.mesh?this._mesh=i.mesh:this._mesh=Ti(e+"_mesh",{segments:i.resolution,diameter:i.size,updatable:!1,sideOrientation:z.BACKSIDE},r);const n=this._material=new Fe(e+"_material",r);n.useEquirectangularFOV=!0,n.fovMultiplier=1,n.opacityFresnel=!1;const o=this._initTexture(t,r,i);if(this.texture=o,this._mesh.material=n,this._mesh.parent=this,this._halfDomeMask=Ti("",{slice:.5,diameter:i.size*.98,segments:i.resolution*2,sideOrientation:z.BACKSIDE},r),this._halfDomeMask.rotate(qi.X,-Math.PI/2),this._halfDomeMask.parent=this._mesh,this._halfDome=!!i.halfDomeMode,this._halfDomeMask.setEnabled(this._halfDome),this._crossEye=!!i.crossEyeMode,this._texture.anisotropicFilteringLevel=1,this._texture.onLoadObservable.addOnce(()=>{this._setReady(!0)}),i.faceForward&&r.activeCamera){const l=r.activeCamera,u=m.Forward(),c=m.TransformNormal(u,l.getViewMatrix());c.normalize(),this.rotation.y=Math.acos(m.Dot(u,c))}this._changeTextureMode(this._textureMode)}_changeTextureMode(e){switch(this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver),this._textureMode=e,this._texture.uScale=1,this._texture.vScale=1,this._texture.uOffset=0,this._texture.vOffset=0,this._texture.vAng=0,e){case Ri.MODE_MONOSCOPIC:this._halfDome&&(this._texture.uScale=2,this._texture.uOffset=-1);break;case Ri.MODE_SIDEBYSIDE:{this._texture.uScale=this._halfDome?.99999:.5;const t=this._halfDome?0:.5,i=this._halfDome?-.5:0;this._onBeforeCameraRenderObserver=this._scene.onBeforeCameraRenderObservable.add(r=>{let s=r.isRightCamera;this._crossEye&&(s=!s),s?this._texture.uOffset=t:this._texture.uOffset=i});break}case Ri.MODE_TOPBOTTOM:this._texture.vScale=this._halfDome?.99999:.5,this._onBeforeCameraRenderObserver=this._scene.onBeforeCameraRenderObservable.add(t=>{let i=t.isRightCamera;this._crossEye&&(i=!i),this._texture.vOffset=i?.5:0});break}}dispose(e,t=!1){this._texture.dispose(),this._mesh.dispose(),this._material.dispose(),this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver),this.onLoadErrorObservable.clear(),this.onLoadObservable.clear(),super.dispose(e,t)}}Ri.MODE_MONOSCOPIC=0;Ri.MODE_TOPBOTTOM=1;Ri.MODE_SIDEBYSIDE=2;class O_ extends Ri{get photoTexture(){return this.texture}set photoTexture(e){this.texture=e}get imageMode(){return this.textureMode}set imageMode(e){this.textureMode=e}_initTexture(e,t,i){return new Y(e,t,!i.generateMipMaps,!this._useDirectMapping,void 0,()=>{this.onLoadObservable.notifyObservers()},(r,s)=>{this.onLoadErrorObservable.notifyObservers(r||"Unknown error occured"),this.onError&&this.onError(r,s)})}}O_.MODE_MONOSCOPIC=Ri.MODE_MONOSCOPIC;O_.MODE_TOPBOTTOM=Ri.MODE_TOPBOTTOM;O_.MODE_SIDEBYSIDE=Ri.MODE_SIDEBYSIDE;class Ho extends Ms{constructor(e,t,i){super(e,m.Zero(),t),this._xrSessionManager=i,this._firstFrame=!1,this._referenceQuaternion=re.Identity(),this._referencedPosition=new m,this._trackingState=0,this.onXRCameraInitializedObservable=new j,this.onBeforeCameraTeleport=new j,this.onAfterCameraTeleport=new j,this.onTrackingStateChanged=new j,this.compensateOnFirstFrame=!0,this._rotate180=new re(0,1,0,0),this.minZ=.1,this.rotationQuaternion=new re,this.cameraRigMode=Ze.RIG_MODE_CUSTOM,this.updateUpVectorFromRotation=!0,this._updateNumberOfRigCameras(1),this.freezeProjectionMatrix(),this._deferOnly=!0,this._xrSessionManager.onXRSessionInit.add(()=>{this._referencedPosition.copyFromFloats(0,0,0),this._referenceQuaternion.copyFromFloats(0,0,0,1),this._firstFrame=this.compensateOnFirstFrame,this._xrSessionManager.onWorldScaleFactorChangedObservable.add(()=>{this._xrSessionManager.currentFrame&&this._updateDepthNearFar()})}),this._xrSessionManager.onXRFrameObservable.add(()=>{this._firstFrame&&this._updateFromXRSession(),this.onXRCameraInitializedObservable.hasObservers()&&(this.onXRCameraInitializedObservable.notifyObservers(this),this.onXRCameraInitializedObservable.clear()),this._deferredUpdated&&(this.position.copyFrom(this._deferredPositionUpdate),this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate)),this._updateReferenceSpace(),this._updateFromXRSession()},void 0,!0)}get trackingState(){return this._trackingState}_setTrackingState(e){this._trackingState!==e&&(this._trackingState=e,this.onTrackingStateChanged.notifyObservers(e))}get realWorldHeight(){const e=this._xrSessionManager.currentFrame&&this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.baseReferenceSpace);return e&&e.transform?e.transform.position.y*this._xrSessionManager.worldScalingFactor:0}_updateForDualEyeDebugging(){this._updateNumberOfRigCameras(2),this.rigCameras[0].viewport=new pn(0,0,.5,1),this.rigCameras[0].outputRenderTarget=null,this.rigCameras[1].viewport=new pn(.5,0,.5,1),this.rigCameras[1].outputRenderTarget=null}setTransformationFromNonVRCamera(e=this.getScene().activeCamera,t=!0){if(!e||e===this)return;e.computeWorldMatrix().decompose(void 0,this.rotationQuaternion,this.position),this.position.y=0,re.FromEulerAnglesToRef(0,this.rotationQuaternion.toEulerAngles().y,0,this.rotationQuaternion),this._firstFrame=!0,t&&this._xrSessionManager.resetReferenceSpace()}getClassName(){return"WebXRCamera"}setTarget(e){const t=V.Vector3[1];e.subtractToRef(this.position,t),t.y=0,t.normalize();const i=Math.atan2(t.x,t.z);this.rotationQuaternion.toEulerAnglesToRef(t),re.FromEulerAnglesToRef(t.x,i,t.z,this.rotationQuaternion)}dispose(){super.dispose(),this._lastXRViewerPose=void 0,this.onTrackingStateChanged.clear()}_updateDepthNearFar(){const e=(this.maxZ||1e4)*this._xrSessionManager.worldScalingFactor,t={depthFar:e,depthNear:this.minZ};this._xrSessionManager.updateRenderState(t),this._cache.minZ=this.minZ,this._cache.maxZ=e}_updateFromXRSession(){const e=this._xrSessionManager.currentFrame&&this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.referenceSpace);if(this._lastXRViewerPose=e||void 0,!e){this._setTrackingState(0);return}const t=e.emulatedPosition?1:2;if(this._setTrackingState(t),(this.minZ!==this._cache.minZ||this.maxZ!==this._cache.maxZ)&&this._updateDepthNearFar(),e.transform){const i=e.transform.orientation;if(e.transform.orientation.x===void 0)return;const r=e.transform.position;this._referencedPosition.set(r.x,r.y,r.z).scaleInPlace(this._xrSessionManager.worldScalingFactor),this._referenceQuaternion.set(i.x,i.y,i.z,i.w),this._scene.useRightHandedSystem?this._referenceQuaternion.multiplyInPlace(this._rotate180):(this._referencedPosition.z*=-1,this._referenceQuaternion.z*=-1,this._referenceQuaternion.w*=-1),this._firstFrame?(this._firstFrame=!1,this.position.y+=this._referencedPosition.y,this._referenceQuaternion.copyFromFloats(0,0,0,1)):(this.rotationQuaternion.copyFrom(this._referenceQuaternion),this.position.copyFrom(this._referencedPosition))}this.rigCameras.length!==e.views.length&&this._updateNumberOfRigCameras(e.views.length),e.views.forEach((i,r)=>{var h;const s=this.rigCameras[r];!s.isLeftCamera&&!s.isRightCamera&&(i.eye==="right"?s._isRightCamera=!0:i.eye==="left"&&(s._isLeftCamera=!0));const n=this.getScene().customRenderTargets;for(let d=0;d<n.length;d++){const f=n[d];s.customRenderTargets.indexOf(f)===-1&&s.customRenderTargets.push(f)}const o=i.transform.position,l=i.transform.orientation;s.parent=this.parent,s.position.set(o.x,o.y,o.z).scaleInPlace(this._xrSessionManager.worldScalingFactor),s.rotationQuaternion.set(l.x,l.y,l.z,l.w),this._scene.useRightHandedSystem?s.rotationQuaternion.multiplyInPlace(this._rotate180):(s.position.z*=-1,s.rotationQuaternion.z*=-1,s.rotationQuaternion.w*=-1),$.FromFloat32ArrayToRefScaled(i.projectionMatrix,0,1,s._projectionMatrix),this._scene.useRightHandedSystem||s._projectionMatrix.toggleProjectionMatrixHandInPlace();const u=Math.atan2(1,i.projectionMatrix[5])*2;s.fov=u,r===0&&(this.fov=u,this._projectionMatrix.copyFrom(s._projectionMatrix));const c=this._xrSessionManager.getRenderTargetTextureForView(i);this._renderingMultiview=((h=c==null?void 0:c._texture)==null?void 0:h.isMultiview)||!1,this._renderingMultiview?r==0&&(this._xrSessionManager.trySetViewportForView(this.viewport,i),this.outputRenderTarget=c):(this._xrSessionManager.trySetViewportForView(s.viewport,i),s.outputRenderTarget=c||this._xrSessionManager.getRenderTargetTextureForView(i)),s.layerMask=this.layerMask})}_updateNumberOfRigCameras(e=1){for(;this.rigCameras.length<e;){const t=new Xa("XR-RigCamera: "+this.rigCameras.length,m.Zero(),this.getScene());t.minZ=.1,t.rotationQuaternion=new re,t.updateUpVectorFromRotation=!0,t.isRigCamera=!0,t.rigParent=this,t.freezeProjectionMatrix(),this.rigCameras.push(t)}for(;this.rigCameras.length>e;){const t=this.rigCameras.pop();t&&t.dispose()}}_updateReferenceSpace(){if(!this.position.equals(this._referencedPosition)||!this.rotationQuaternion.equals(this._referenceQuaternion)){const e=V.Matrix[0],t=V.Matrix[1],i=V.Matrix[2];$.ComposeToRef(Ho._ScaleReadOnly,this._referenceQuaternion,this._referencedPosition,e),$.ComposeToRef(Ho._ScaleReadOnly,this.rotationQuaternion,this.position,t),e.invert().multiplyToRef(t,i),i.invert(),this._scene.useRightHandedSystem||i.toggleModelMatrixHandInPlace(),i.decompose(void 0,this._referenceQuaternion,this._referencedPosition);const r=new XRRigidTransform({x:this._referencedPosition.x/this._xrSessionManager.worldScalingFactor,y:this._referencedPosition.y/this._xrSessionManager.worldScalingFactor,z:this._referencedPosition.z/this._xrSessionManager.worldScalingFactor},{x:this._referenceQuaternion.x,y:this._referenceQuaternion.y,z:this._referenceQuaternion.z,w:this._referenceQuaternion.w});this._xrSessionManager.referenceSpace=this._xrSessionManager.referenceSpace.getOffsetReferenceSpace(r)}}}Ho._ScaleReadOnly=m.One();class w_{constructor(e){this._scene=e,this._nonVRCamera=null,this._attachedToElement=!1,this._spectatorCamera=null,this._originalSceneAutoClear=!0,this._supported=!1,this._spectatorMode=!1,this._lastTimestamp=0,this.onInitialXRPoseSetObservable=new j,this.onStateChangedObservable=new j,this.state=3,this.sessionManager=new Mu(e),this.camera=new Ho("webxr",e,this.sessionManager),this.featuresManager=new Tt(this.sessionManager),e.onDisposeObservable.addOnce(()=>{this.dispose()})}static CreateAsync(e){const t=new w_(e);return t.sessionManager.initializeAsync().then(()=>(t._supported=!0,t)).catch(i=>{throw t._setState(3),t.dispose(),i})}dispose(){var e;this.exitXRAsync(),this.camera.dispose(),this.onStateChangedObservable.clear(),this.onInitialXRPoseSetObservable.clear(),this.sessionManager.dispose(),(e=this._spectatorCamera)==null||e.dispose(),this._nonVRCamera&&(this._scene.activeCamera=this._nonVRCamera)}async enterXRAsync(e,t,i=this.sessionManager.getWebXRRenderTarget(),r={}){var s,n,o,l;if(!this._supported)throw"WebXR not supported in this browser or environment";this._setState(0),t!=="viewer"&&t!=="local"&&(r.optionalFeatures=r.optionalFeatures||[],r.optionalFeatures.push(t)),r=await this.featuresManager._extendXRSessionInitObject(r),e==="immersive-ar"&&t!=="unbounded"&&L.Warn("We recommend using 'unbounded' reference space type when using 'immersive-ar' session mode");try{await this.sessionManager.initializeSessionAsync(e,r),await this.sessionManager.setReferenceSpaceTypeAsync(t);const u={depthFar:this.camera.maxZ||1e4,depthNear:this.camera.minZ};if(!this.featuresManager.getEnabledFeature(ke.LAYERS)){const c=await i.initializeXRLayerAsync(this.sessionManager.session);u.baseLayer=c}return this.sessionManager.updateRenderState(u),this.sessionManager.runXRRenderLoop(),this._originalSceneAutoClear=this._scene.autoClear,this._nonVRCamera=this._scene.activeCamera,this._attachedToElement=!!((n=(s=this._nonVRCamera)==null?void 0:s.inputs)!=null&&n.attachedToElement),(o=this._nonVRCamera)==null||o.detachControl(),this._scene.activeCamera=this.camera,e!=="immersive-ar"?this._nonXRToXRCamera():(this._scene.autoClear=!1,this.camera.compensateOnFirstFrame=!1,this.camera.position.set(0,0,0),this.camera.rotationQuaternion.set(0,0,0,1),this.onInitialXRPoseSetObservable.notifyObservers(this.camera)),(l=st.audioEngine)==null||l._resumeAudioContextOnStateChange(),this.sessionManager.onXRSessionEnded.addOnce(()=>{this.state!==1&&this._setState(1),this.camera.rigCameras.forEach(c=>{c.outputRenderTarget=null}),this._scene.autoClear=this._originalSceneAutoClear,this._scene.activeCamera=this._nonVRCamera,this._attachedToElement&&this._nonVRCamera&&this._nonVRCamera.attachControl(!!this._nonVRCamera.inputs.noPreventDefault),e!=="immersive-ar"&&this.camera.compensateOnFirstFrame&&(this._nonVRCamera.setPosition?this._nonVRCamera.setPosition(this.camera.position):this._nonVRCamera.position.copyFrom(this.camera.position)),this._setState(3)}),this.sessionManager.onXRFrameObservable.addOnce(()=>{this._setState(2)}),this.sessionManager}catch(u){throw L.Log(u),L.Log(u.message),this._setState(3),u}}exitXRAsync(){return this.state!==2?Promise.resolve():(this._setState(1),this.sessionManager.exitXRAsync())}enableSpectatorMode(e){this._spectatorMode||(this._spectatorMode=!0,this._switchSpectatorMode(e))}disableSpecatatorMode(){this._spectatorMode&&(this._spectatorMode=!1,this._switchSpectatorMode())}_switchSpectatorMode(e){const i=1/(e!=null&&e.fps?e.fps:1e3)*1e3,r=e!=null&&e.preferredCameraIndex?e==null?void 0:e.preferredCameraIndex:0,s=()=>{this._spectatorCamera&&this.sessionManager.currentTimestamp-this._lastTimestamp>=i&&(this._lastTimestamp=this.sessionManager.currentTimestamp,this._spectatorCamera.position.copyFrom(this.camera.rigCameras[r].globalPosition),this._spectatorCamera.rotationQuaternion.copyFrom(this.camera.rigCameras[r].absoluteRotation))};if(this._spectatorMode){if(r>=this.camera.rigCameras.length)throw new Error("the preferred camera index is beyond the length of rig camera array.");const n=()=>{this.state===2?(this._spectatorCamera=new Ka("webxr-spectator",m.Zero(),this._scene),this._spectatorCamera.rotationQuaternion=new re,this._scene.activeCameras=[this.camera,this._spectatorCamera],this.sessionManager.onXRFrameObservable.add(s),this._scene.onAfterRenderCameraObservable.add(o=>{o===this.camera&&(this._scene.getEngine().framebufferDimensionsObject=null)})):this.state===1&&(this.sessionManager.onXRFrameObservable.removeCallback(s),this._scene.activeCameras=null)};this.onStateChangedObservable.add(n),n()}else this.sessionManager.onXRFrameObservable.removeCallback(s),this._scene.activeCameras=[this.camera]}_nonXRToXRCamera(){this.camera.setTransformationFromNonVRCamera(this._nonVRCamera),this.onInitialXRPoseSetObservable.notifyObservers(this.camera)}_setState(e){this.state!==e&&(this.state=e,this.onStateChangedObservable.notifyObservers(this.state))}}class Ji{constructor(e,t,i=-1,r=[]){this.id=e,this.type=t,this._buttonIndex=i,this._axesIndices=r,this._axes={x:0,y:0},this._changes={},this._currentValue=0,this._hasChanges=!1,this._pressed=!1,this._touched=!1,this.onAxisValueChangedObservable=new j,this.onButtonStateChangedObservable=new j}get axes(){return this._axes}get changes(){return this._changes}get hasChanges(){return this._hasChanges}get pressed(){return this._pressed}get touched(){return this._touched}get value(){return this._currentValue}dispose(){this.onAxisValueChangedObservable.clear(),this.onButtonStateChangedObservable.clear()}isAxes(){return this._axesIndices.length!==0}isButton(){return this._buttonIndex!==-1}update(e){let t=!1,i=!1;if(this._hasChanges=!1,this._changes={},this.isButton()){const r=e.buttons[this._buttonIndex];if(!r)return;this._currentValue!==r.value&&(this.changes.value={current:r.value,previous:this._currentValue},t=!0,this._currentValue=r.value),this._touched!==r.touched&&(this.changes.touched={current:r.touched,previous:this._touched},t=!0,this._touched=r.touched),this._pressed!==r.pressed&&(this.changes.pressed={current:r.pressed,previous:this._pressed},t=!0,this._pressed=r.pressed)}this.isAxes()&&(this._axes.x!==e.axes[this._axesIndices[0]]&&(this.changes.axes={current:{x:e.axes[this._axesIndices[0]],y:this._axes.y},previous:{x:this._axes.x,y:this._axes.y}},this._axes.x=e.axes[this._axesIndices[0]],i=!0),this._axes.y!==e.axes[this._axesIndices[1]]&&(this.changes.axes?this.changes.axes.current.y=e.axes[this._axesIndices[1]]:this.changes.axes={current:{x:this._axes.x,y:e.axes[this._axesIndices[1]]},previous:{x:this._axes.x,y:this._axes.y}},this._axes.y=e.axes[this._axesIndices[1]],i=!0)),t&&(this._hasChanges=!0,this.onButtonStateChangedObservable.notifyObservers(this)),i&&(this._hasChanges=!0,this.onAxisValueChangedObservable.notifyObservers(this._axes))}}Ji.BUTTON_TYPE="button";Ji.SQUEEZE_TYPE="squeeze";Ji.THUMBSTICK_TYPE="thumbstick";Ji.TOUCHPAD_TYPE="touchpad";Ji.TRIGGER_TYPE="trigger";class ro{constructor(e,t,i,r,s=!1,n){this.scene=e,this.layout=t,this.gamepadObject=i,this.handedness=r,this._doNotLoadControllerMesh=s,this._controllerCache=n,this._initComponent=o=>{if(!o)return;const l=this.layout.components[o],u=l.type,c=l.gamepadIndices.button,h=[];l.gamepadIndices.xAxis!==void 0&&l.gamepadIndices.yAxis!==void 0&&h.push(l.gamepadIndices.xAxis,l.gamepadIndices.yAxis),this.components[o]=new Ji(o,u,c,h)},this._modelReady=!1,this.components={},this.disableAnimation=!1,this.onModelLoadedObservable=new j,t.components&&Object.keys(t.components).forEach(this._initComponent)}dispose(){this.getComponentIds().forEach(e=>this.getComponent(e).dispose()),this.rootMesh&&(this.rootMesh.getChildren(void 0,!0).forEach(e=>{e.setEnabled(!1)}),this.rootMesh.dispose(!!this._controllerCache,!this._controllerCache)),this.onModelLoadedObservable.clear()}getAllComponentsOfType(e){return this.getComponentIds().map(t=>this.components[t]).filter(t=>t.type===e)}getComponent(e){return this.components[e]}getComponentIds(){return Object.keys(this.components)}getComponentOfType(e){return this.getAllComponentsOfType(e)[0]||null}getMainComponent(){return this.getComponent(this.layout.selectComponentId)}async loadModel(){const e=!this._getModelLoadingConstraints();let t=this._getGenericFilenameAndPath();return e?L.Warn("Falling back to generic models"):t=this._getFilenameAndPath(),new Promise((i,r)=>{const s=n=>{e?this._getGenericParentMesh(n):this._setRootMesh(n),this._processLoadedModel(n),this._modelReady=!0,this.onModelLoadedObservable.notifyObservers(this),i(!0)};if(this._controllerCache){const n=this._controllerCache.filter(o=>o.filename===t.filename&&o.path===t.path);if(n[0]){n[0].meshes.forEach(o=>o.setEnabled(!0)),s(n[0].meshes);return}}At.ImportMesh("",t.path,t.filename,this.scene,n=>{this._controllerCache&&this._controllerCache.push({...t,meshes:n}),s(n)},null,(n,o)=>{L.Log(o),L.Warn(`Failed to retrieve controller model of type ${this.profileId} from the remote server: ${t.path}${t.filename}`),r(o)})})}updateFromXRFrame(e){this.getComponentIds().forEach(t=>this.getComponent(t).update(this.gamepadObject)),this.updateModel(e)}get handness(){return this.handedness}pulse(e,t,i=0){return this.gamepadObject.hapticActuators&&this.gamepadObject.hapticActuators[i]?this.gamepadObject.hapticActuators[i].pulse(e,t):Promise.resolve(!1)}_getChildByName(e,t){return e.getChildren(i=>i.name===t,!1)[0]}_getImmediateChildByName(e,t){return e.getChildren(i=>i.name==t,!0)[0]}_lerpTransform(e,t,i){if(!e.minMesh||!e.maxMesh||!e.valueMesh||!e.minMesh.rotationQuaternion||!e.maxMesh.rotationQuaternion||!e.valueMesh.rotationQuaternion)return;const r=i?t*.5+.5:t;re.SlerpToRef(e.minMesh.rotationQuaternion,e.maxMesh.rotationQuaternion,r,e.valueMesh.rotationQuaternion),m.LerpToRef(e.minMesh.position,e.maxMesh.position,r,e.valueMesh.position)}updateModel(e){this._modelReady&&this._updateModel(e)}_getGenericFilenameAndPath(){return{filename:"generic.babylon",path:"https://controllers.babylonjs.com/generic/"}}_getGenericParentMesh(e){this.rootMesh=new z(this.profileId+" "+this.handedness,this.scene),e.forEach(t=>{t.parent||(t.isPickable=!1,t.setParent(this.rootMesh))}),this.rootMesh.rotationQuaternion=re.FromEulerAngles(0,Math.PI,0)}}class jo extends ro{constructor(e,t,i){super(e,Yw[i],t,i),this.profileId=jo.ProfileId}_getFilenameAndPath(){return{filename:"generic.babylon",path:"https://controllers.babylonjs.com/generic/"}}_getModelLoadingConstraints(){return!0}_processLoadedModel(e){}_setRootMesh(e){this.rootMesh=new z(this.profileId+" "+this.handedness,this.scene),e.forEach(t=>{t.isPickable=!1,t.parent||t.setParent(this.rootMesh)}),this.rootMesh.rotationQuaternion=re.FromEulerAngles(0,Math.PI,0)}_updateModel(){}}jo.ProfileId="generic-trigger";const Yw={left:{selectComponentId:"xr-standard-trigger",components:{"xr-standard-trigger":{type:"trigger",gamepadIndices:{button:0},rootNodeName:"xr_standard_trigger",visualResponses:{}}},gamepadMapping:"xr-standard",rootNodeName:"generic-trigger-left",assetPath:"left.glb"},right:{selectComponentId:"xr-standard-trigger",components:{"xr-standard-trigger":{type:"trigger",gamepadIndices:{button:0},rootNodeName:"xr_standard_trigger",visualResponses:{}}},gamepadMapping:"xr-standard",rootNodeName:"generic-trigger-right",assetPath:"right.glb"},none:{selectComponentId:"xr-standard-trigger",components:{"xr-standard-trigger":{type:"trigger",gamepadIndices:{button:0},rootNodeName:"xr_standard_trigger",visualResponses:{}}},gamepadMapping:"xr-standard",rootNodeName:"generic-trigger-none",assetPath:"none.glb"}};class Xw extends ro{constructor(e,t,i,r,s){super(e,i.layouts[t.handedness||"none"],t.gamepad,t.handedness,void 0,s),this._repositoryUrl=r,this.controllerCache=s,this._buttonMeshMapping={},this._touchDots={},this.profileId=i.profileId}dispose(){super.dispose(),this.controllerCache||Object.keys(this._touchDots).forEach(e=>{this._touchDots[e].dispose()})}_getFilenameAndPath(){return{filename:this.layout.assetPath,path:`${this._repositoryUrl}/profiles/${this.profileId}/`}}_getModelLoadingConstraints(){const e=At.IsPluginForExtensionAvailable(".glb");return e||L.Warn("glTF / glb loader was not registered, using generic controller instead"),e}_processLoadedModel(e){this.getComponentIds().forEach(t=>{const i=this.layout.components[t];this._buttonMeshMapping[t]={mainMesh:this._getChildByName(this.rootMesh,i.rootNodeName),states:{}},Object.keys(i.visualResponses).forEach(r=>{const s=i.visualResponses[r];if(s.valueNodeProperty==="transform")this._buttonMeshMapping[t].states[r]={valueMesh:this._getChildByName(this.rootMesh,s.valueNodeName),minMesh:this._getChildByName(this.rootMesh,s.minNodeName),maxMesh:this._getChildByName(this.rootMesh,s.maxNodeName)};else{const n=i.type===Ji.TOUCHPAD_TYPE&&i.touchPointNodeName?i.touchPointNodeName:s.valueNodeName;if(this._buttonMeshMapping[t].states[r]={valueMesh:this._getChildByName(this.rootMesh,n)},i.type===Ji.TOUCHPAD_TYPE&&!this._touchDots[r]){const o=Ti(r+"dot",{diameter:.0015,segments:8},this.scene);o.material=new Ut(r+"mat",this.scene),o.material.diffuseColor=ne.Red(),o.parent=this._buttonMeshMapping[t].states[r].valueMesh||null,o.isVisible=!1,this._touchDots[r]=o}}})})}_setRootMesh(e){this.rootMesh=new z(this.profileId+"-"+this.handedness,this.scene),this.rootMesh.isPickable=!1;let t;for(let i=0;i<e.length;i++){const r=e[i];r.isPickable=!1,r.parent||(t=r)}t&&t.setParent(this.rootMesh),this.scene.useRightHandedSystem||this.rootMesh.rotate(qi.Y,Math.PI,1)}_updateModel(e){this.disableAnimation||this.getComponentIds().forEach(t=>{const i=this.getComponent(t);if(!i.hasChanges)return;const r=this._buttonMeshMapping[t],s=this.layout.components[t];Object.keys(s.visualResponses).forEach(n=>{const o=s.visualResponses[n];let l=i.value;if(o.componentProperty==="xAxis"?l=i.axes.x:o.componentProperty==="yAxis"&&(l=i.axes.y),o.valueNodeProperty==="transform")this._lerpTransform(r.states[n],l,o.componentProperty!=="button");else{const u=r.states[n].valueMesh;u&&(u.isVisible=i.touched||i.pressed),this._touchDots[n]&&(this._touchDots[n].isVisible=i.touched||i.pressed)}})})}}const Lc=[];class Yt{static ClearProfilesCache(){this._ProfilesList=null,this._ProfileLoadingPromises={}}static DefaultFallbacks(){this.RegisterFallbacksForProfileId("google-daydream",["generic-touchpad"]),this.RegisterFallbacksForProfileId("htc-vive-focus",["generic-trigger-touchpad"]),this.RegisterFallbacksForProfileId("htc-vive",["generic-trigger-squeeze-touchpad"]),this.RegisterFallbacksForProfileId("magicleap-one",["generic-trigger-squeeze-touchpad"]),this.RegisterFallbacksForProfileId("windows-mixed-reality",["generic-trigger-squeeze-touchpad-thumbstick"]),this.RegisterFallbacksForProfileId("microsoft-mixed-reality",["windows-mixed-reality","generic-trigger-squeeze-touchpad-thumbstick"]),this.RegisterFallbacksForProfileId("oculus-go",["generic-trigger-touchpad"]),this.RegisterFallbacksForProfileId("oculus-touch-v2",["oculus-touch","generic-trigger-squeeze-thumbstick"]),this.RegisterFallbacksForProfileId("oculus-touch",["generic-trigger-squeeze-thumbstick"]),this.RegisterFallbacksForProfileId("samsung-gearvr",["windows-mixed-reality","generic-trigger-squeeze-touchpad-thumbstick"]),this.RegisterFallbacksForProfileId("samsung-odyssey",["generic-touchpad"]),this.RegisterFallbacksForProfileId("valve-index",["generic-trigger-squeeze-touchpad-thumbstick"]),this.RegisterFallbacksForProfileId("generic-hand-select",["generic-trigger"])}static FindFallbackWithProfileId(e){const t=this._Fallbacks[e]||[];return t.unshift(e),t}static GetMotionControllerWithXRInput(e,t,i){const r=[];if(i&&r.push(i),r.push(...e.profiles||[]),r.length&&!r[0]&&r.pop(),e.gamepad&&e.gamepad.id)switch(e.gamepad.id){case(e.gamepad.id.match(/oculus touch/gi)?e.gamepad.id:void 0):r.push("oculus-touch-v2");break}const s=r.indexOf("windows-mixed-reality");if(s!==-1&&r.splice(s,0,"microsoft-mixed-reality"),r.length||r.push("generic-trigger"),this.UseOnlineRepository){const n=this.PrioritizeOnlineRepository?this._LoadProfileFromRepository:this._LoadProfilesFromAvailableControllers,o=this.PrioritizeOnlineRepository?this._LoadProfilesFromAvailableControllers:this._LoadProfileFromRepository;return n.call(this,r,e,t).catch(()=>o.call(this,r,e,t))}else return this._LoadProfilesFromAvailableControllers(r,e,t)}static RegisterController(e,t){this._AvailableControllers[e]=t}static RegisterFallbacksForProfileId(e,t){this._Fallbacks[e]?this._Fallbacks[e].push(...t):this._Fallbacks[e]=t}static UpdateProfilesList(){return this._ProfilesList=ae.LoadFileAsync(this.BaseRepositoryUrl+"/profiles/profilesList.json",!1).then(e=>JSON.parse(e)),this._ProfilesList}static ClearControllerCache(){Lc.forEach(e=>{e.meshes.forEach(t=>{t.dispose(!1,!0)})}),Lc.length=0}static _LoadProfileFromRepository(e,t,i){return Promise.resolve().then(()=>this._ProfilesList?this._ProfilesList:this.UpdateProfilesList()).then(r=>{for(let s=0;s<e.length;++s)if(e[s]&&r[e[s]])return e[s];throw new Error(`neither controller ${e[0]} nor all fallbacks were found in the repository,`)}).then(r=>(this._ProfileLoadingPromises[r]||(this._ProfileLoadingPromises[r]=ae.LoadFileAsync(`${this.BaseRepositoryUrl}/profiles/${r}/profile.json`,!1).then(s=>JSON.parse(s))),this._ProfileLoadingPromises[r])).then(r=>new Xw(i,t,r,this.BaseRepositoryUrl,this.DisableControllerCache?void 0:Lc))}static _LoadProfilesFromAvailableControllers(e,t,i){for(let r=0;r<e.length;++r){if(!e[r])continue;const s=this.FindFallbackWithProfileId(e[r]);for(let n=0;n<s.length;++n){const o=this._AvailableControllers[s[n]];if(o)return Promise.resolve(o(t,i))}}throw new Error("no controller requested was found in the available controllers list")}}Yt._AvailableControllers={};Yt._Fallbacks={};Yt._ProfileLoadingPromises={};Yt.BaseRepositoryUrl="https://immersive-web.github.io/webxr-input-profiles/packages/viewer/dist";Yt.PrioritizeOnlineRepository=!0;Yt.UseOnlineRepository=!0;Yt.DisableControllerCache=!0;Yt.RegisterController(jo.ProfileId,(a,e)=>new jo(e,a.gamepad,a.handedness));Yt.DefaultFallbacks();let Zw=0;class qw{constructor(e,t,i={}){this._scene=e,this.inputSource=t,this._options=i,this._tmpVector=new m,this._disposed=!1,this.onDisposeObservable=new j,this.onMeshLoadedObservable=new j,this.onMotionControllerInitObservable=new j,this._uniqueId=`controller-${Zw++}-${t.targetRayMode}-${t.handedness}`,this.pointer=new z(`${this._uniqueId}-pointer`,e),this.pointer.rotationQuaternion=new re,this.inputSource.gripSpace&&(this.grip=new z(`${this._uniqueId}-grip`,this._scene),this.grip.rotationQuaternion=new re),this._tmpVector.set(0,0,this._scene.useRightHandedSystem?-1:1),this.inputSource.gamepad&&this.inputSource.targetRayMode==="tracked-pointer"&&Yt.GetMotionControllerWithXRInput(t,e,this._options.forceControllerProfile).then(r=>{this.motionController=r,this.onMotionControllerInitObservable.notifyObservers(r),!this._options.doNotLoadControllerMesh&&!this.motionController._doNotLoadControllerMesh&&this.motionController.loadModel().then(s=>{var n;s&&this.motionController&&this.motionController.rootMesh&&(this._options.renderingGroupId&&(this.motionController.rootMesh.renderingGroupId=this._options.renderingGroupId,this.motionController.rootMesh.getChildMeshes(!1).forEach(o=>o.renderingGroupId=this._options.renderingGroupId)),this.onMeshLoadedObservable.notifyObservers(this.motionController.rootMesh),this.motionController.rootMesh.parent=this.grip||this.pointer,this.motionController.disableAnimation=!!this._options.disableMotionControllerAnimation),this._disposed&&((n=this.motionController)==null||n.dispose())})},()=>{ae.Warn("Could not find a matching motion controller for the registered input source")})}get uniqueId(){return this._uniqueId}dispose(){this.grip&&this.grip.dispose(!0),this.motionController&&this.motionController.dispose(),this.pointer.dispose(!0),this.onMotionControllerInitObservable.clear(),this.onMeshLoadedObservable.clear(),this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this._disposed=!0}getWorldPointerRayToRef(e,t=!1){const i=t&&this.grip?this.grip:this.pointer;m.TransformNormalToRef(this._tmpVector,i.getWorldMatrix(),e.direction),e.direction.normalize(),e.origin.copyFrom(i.absolutePosition),e.length=1e3}updateFromXRFrame(e,t,i,r){const s=e.getPose(this.inputSource.targetRaySpace,t);if(this._lastXRPose=s,s){const n=s.transform.position;this.pointer.position.set(n.x,n.y,n.z).scaleInPlace(r.worldScalingFactor);const o=s.transform.orientation;this.pointer.rotationQuaternion.set(o.x,o.y,o.z,o.w),this._scene.useRightHandedSystem||(this.pointer.position.z*=-1,this.pointer.rotationQuaternion.z*=-1,this.pointer.rotationQuaternion.w*=-1),this.pointer.parent=i.parent,this.pointer.scaling.setAll(r.worldScalingFactor)}if(this.inputSource.gripSpace&&this.grip){const n=e.getPose(this.inputSource.gripSpace,t);if(n){const o=n.transform.position,l=n.transform.orientation;this.grip.position.set(o.x,o.y,o.z).scaleInPlace(r.worldScalingFactor),this.grip.rotationQuaternion.set(l.x,l.y,l.z,l.w),this._scene.useRightHandedSystem||(this.grip.position.z*=-1,this.grip.rotationQuaternion.z*=-1,this.grip.rotationQuaternion.w*=-1)}this.grip.parent=i.parent,this.grip.scaling.setAll(r.worldScalingFactor)}this.motionController&&this.motionController.updateFromXRFrame(e)}}class Qw{constructor(e,t,i={}){if(this.xrSessionManager=e,this.xrCamera=t,this._options=i,this.controllers=[],this.onControllerAddedObservable=new j,this.onControllerRemovedObservable=new j,this._onInputSourcesChange=r=>{this._addAndRemoveControllers(r.added,r.removed)},this._sessionEndedObserver=this.xrSessionManager.onXRSessionEnded.add(()=>{this._addAndRemoveControllers([],this.controllers.map(r=>r.inputSource))}),this._sessionInitObserver=this.xrSessionManager.onXRSessionInit.add(r=>{r.addEventListener("inputsourceschange",this._onInputSourcesChange)}),this._frameObserver=this.xrSessionManager.onXRFrameObservable.add(r=>{this.controllers.forEach(s=>{s.updateFromXRFrame(r,this.xrSessionManager.referenceSpace,this.xrCamera,this.xrSessionManager)})}),this._options.customControllersRepositoryURL&&(Yt.BaseRepositoryUrl=this._options.customControllersRepositoryURL),Yt.UseOnlineRepository=!this._options.disableOnlineControllerRepository,Yt.UseOnlineRepository)try{Yt.UpdateProfilesList().catch(()=>{Yt.UseOnlineRepository=!1})}catch{Yt.UseOnlineRepository=!1}}_addAndRemoveControllers(e,t){const i=this.controllers.map(n=>n.inputSource);for(const n of e)if(i.indexOf(n)===-1){const o=new qw(this.xrSessionManager.scene,n,{...this._options.controllerOptions||{},forceControllerProfile:this._options.forceInputProfile,doNotLoadControllerMesh:this._options.doNotLoadControllerMeshes,disableMotionControllerAnimation:this._options.disableControllerAnimation});this.controllers.push(o),this.onControllerAddedObservable.notifyObservers(o)}const r=[],s=[];this.controllers.forEach(n=>{t.indexOf(n.inputSource)===-1?r.push(n):s.push(n)}),this.controllers=r,s.forEach(n=>{this.onControllerRemovedObservable.notifyObservers(n),n.dispose()})}dispose(){this.controllers.forEach(e=>{e.dispose()}),this.xrSessionManager.onXRFrameObservable.remove(this._frameObserver),this.xrSessionManager.onXRSessionInit.remove(this._sessionInitObserver),this.xrSessionManager.onXRSessionEnded.remove(this._sessionEndedObserver),this.onControllerAddedObservable.clear(),this.onControllerRemovedObservable.clear(),Yt.ClearControllerCache()}}class ti{get xrNativeFeatureName(){return this._xrNativeFeatureName}set xrNativeFeatureName(e){var t;!this._xrSessionManager.isNative&&e&&this._xrSessionManager.inXRSession&&((t=this._xrSessionManager.enabledFeatures)==null?void 0:t.indexOf(e))===-1&&L.Warn(`The feature ${e} needs to be enabled before starting the XR session. Note - It is still possible it is not supported.`),this._xrNativeFeatureName=e}constructor(e){this._xrSessionManager=e,this._attached=!1,this._removeOnDetach=[],this.isDisposed=!1,this.disableAutoAttach=!1,this._xrNativeFeatureName="",this.onFeatureAttachObservable=new j,this.onFeatureDetachObservable=new j}get attached(){return this._attached}attach(e){if(this.isDisposed)return!1;if(e)this.attached&&this.detach();else if(this.attached)return!1;if(!this._xrSessionManager.enabledFeatures)L.Warn("session.enabledFeatures is not available on this device. It is possible that this feature is not supported.");else if(!this._xrSessionManager.isNative&&this.xrNativeFeatureName&&this._xrSessionManager.enabledFeatures.indexOf(this.xrNativeFeatureName)===-1)return!1;return this._attached=!0,this._addNewAttachObserver(this._xrSessionManager.onXRFrameObservable,t=>this._onXRFrame(t)),this.onFeatureAttachObservable.notifyObservers(this),!0}detach(){return this._attached?(this._attached=!1,this._removeOnDetach.forEach(e=>{e.observable.remove(e.observer)}),this.onFeatureDetachObservable.notifyObservers(this),!0):(this.disableAutoAttach=!0,!1)}dispose(){this.detach(),this.isDisposed=!0,this.onFeatureAttachObservable.clear(),this.onFeatureDetachObservable.clear()}isCompatible(){return!0}_addNewAttachObserver(e,t,i){this._removeOnDetach.push({observable:e,observer:e.add(t,void 0,i)})}}class cs extends ti{constructor(e,t){super(e),this._options=t,this._attachController=i=>{if(this._controllers[i.uniqueId])return;const{laserPointer:r,selectionMesh:s}=this._generateNewMeshPair(this._options.forceGripIfAvailable&&i.grip?i.grip:i.pointer);switch(this._controllers[i.uniqueId]={xrController:i,laserPointer:r,selectionMesh:s,meshUnderPointer:null,pick:null,tmpRay:new Zt(new m,new m),disabledByNearInteraction:!1,id:cs._IdCounter++},this._attachedController?!this._options.enablePointerSelectionOnAllControllers&&this._options.preferredHandedness&&i.inputSource.handedness===this._options.preferredHandedness&&(this._attachedController=i.uniqueId):this._options.enablePointerSelectionOnAllControllers||(this._attachedController=i.uniqueId),i.inputSource.targetRayMode){case"tracked-pointer":return this._attachTrackedPointerRayMode(i);case"gaze":return this._attachGazeMode(i);case"screen":case"transient-pointer":return this._attachScreenRayMode(i)}},this._controllers={},this._tmpVectorForPickCompare=new m,this.disablePointerLighting=!0,this.disableSelectionMeshLighting=!0,this.displayLaserPointer=!0,this.displaySelectionMesh=!0,this.laserPointerPickedColor=new ne(.9,.9,.9),this.laserPointerDefaultColor=new ne(.7,.7,.7),this.selectionMeshDefaultColor=new ne(.8,.8,.8),this.selectionMeshPickedColor=new ne(.3,.3,1),this._identityMatrix=$.Identity(),this._screenCoordinatesRef=m.Zero(),this._viewportRef=new pn(0,0,0,0),this._scene=this._xrSessionManager.scene,this._options.lookAndPickMode===void 0&&(this._scene.getEngine()._badDesktopOS||this._scene.getEngine()._badOS)&&(this._options.lookAndPickMode=!0),this._options.lookAndPickMode&&(this._options.enablePointerSelectionOnAllControllers=!0,this.displayLaserPointer=!1)}attach(){if(!super.attach())return!1;if(this._options.xrInput.controllers.forEach(this._attachController),this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable,this._attachController,!0),this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable,e=>{this._detachController(e.uniqueId)},!0),this._scene.constantlyUpdateMeshUnderPointer=!0,this._options.gazeCamera){const e=this._options.gazeCamera,{laserPointer:t,selectionMesh:i}=this._generateNewMeshPair(e);this._controllers.camera={webXRCamera:e,laserPointer:t,selectionMesh:i,meshUnderPointer:null,pick:null,tmpRay:new Zt(new m,new m),disabledByNearInteraction:!1,id:cs._IdCounter++},this._attachGazeMode()}return!0}detach(){return super.detach()?(Object.keys(this._controllers).forEach(e=>{this._detachController(e)}),!0):!1}getMeshUnderPointer(e){return this._controllers[e]?this._controllers[e].meshUnderPointer:null}getXRControllerByPointerId(e){const t=Object.keys(this._controllers);for(let i=0;i<t.length;++i)if(this._controllers[t[i]].id===e)return this._controllers[t[i]].xrController||null;return null}_getPointerSelectionDisabledByPointerId(e){const t=Object.keys(this._controllers);for(let i=0;i<t.length;++i)if(this._controllers[t[i]].id===e)return this._controllers[t[i]].disabledByNearInteraction;return!0}_setPointerSelectionDisabledByPointerId(e,t){const i=Object.keys(this._controllers);for(let r=0;r<i.length;++r)if(this._controllers[i[r]].id===e){this._controllers[i[r]].disabledByNearInteraction=t;return}}_onXRFrame(e){Object.keys(this._controllers).forEach(t=>{var l;const i=this._controllers[t];if(this._options.lookAndPickMode&&((l=i.xrController)==null?void 0:l.inputSource.targetRayMode)!=="transient-pointer")return;if(!this._options.enablePointerSelectionOnAllControllers&&t!==this._attachedController||i.disabledByNearInteraction){i.selectionMesh.isVisible=!1,i.laserPointer.isVisible=!1,i.pick=null;return}i.laserPointer.isVisible=this.displayLaserPointer;let r;if(i.xrController)r=this._options.forceGripIfAvailable&&i.xrController.grip?i.xrController.grip.position:i.xrController.pointer.position,i.xrController.getWorldPointerRayToRef(i.tmpRay,this._options.forceGripIfAvailable);else if(i.webXRCamera)r=i.webXRCamera.position,i.webXRCamera.getForwardRayToRef(i.tmpRay);else return;if(this._options.maxPointerDistance&&(i.tmpRay.length=this._options.maxPointerDistance),!this._options.disableScenePointerVectorUpdate&&r){const u=this._xrSessionManager.scene,c=this._options.xrInput.xrCamera;c&&(c.viewport.toGlobalToRef(u.getEngine().getRenderWidth()/c.rigCameras.length,u.getEngine().getRenderHeight(),this._viewportRef),m.ProjectToRef(r,this._identityMatrix,c.getTransformationMatrix(),this._viewportRef,this._screenCoordinatesRef),typeof this._screenCoordinatesRef.x=="number"&&typeof this._screenCoordinatesRef.y=="number"&&!isNaN(this._screenCoordinatesRef.x)&&!isNaN(this._screenCoordinatesRef.y)&&this._screenCoordinatesRef.x!==1/0&&this._screenCoordinatesRef.y!==1/0&&(u.pointerX=this._screenCoordinatesRef.x,u.pointerY=this._screenCoordinatesRef.y,i.screenCoordinates={x:this._screenCoordinatesRef.x,y:this._screenCoordinatesRef.y}))}let s=null;this._utilityLayerScene&&(s=this._utilityLayerScene.pickWithRay(i.tmpRay,this._utilityLayerScene.pointerMovePredicate||this.raySelectionPredicate));const n=this._scene.pickWithRay(i.tmpRay,this._scene.pointerMovePredicate||this.raySelectionPredicate);!s||!s.hit?i.pick=n:!n||!n.hit||s.distance<n.distance?i.pick=s:i.pick=n,i.pick&&i.xrController&&(i.pick.aimTransform=i.xrController.pointer,i.pick.gripTransform=i.xrController.grip||null,i.pick.originMesh=i.xrController.pointer,i.tmpRay.length=i.pick.distance);const o=i.pick;if(o&&o.pickedPoint&&o.hit){this._updatePointerDistance(i.laserPointer,o.distance),i.selectionMesh.position.copyFrom(o.pickedPoint),i.selectionMesh.scaling.x=Math.sqrt(o.distance),i.selectionMesh.scaling.y=Math.sqrt(o.distance),i.selectionMesh.scaling.z=Math.sqrt(o.distance);const u=this._convertNormalToDirectionOfRay(o.getNormal(!0),i.tmpRay),c=.001;if(i.selectionMesh.position.copyFrom(o.pickedPoint),u){const h=m.Cross(qi.Y,u),d=m.Cross(u,h);m.RotationFromAxisToRef(d,u,h,i.selectionMesh.rotation),i.selectionMesh.position.addInPlace(u.scale(c))}i.selectionMesh.isVisible=this.displaySelectionMesh,i.meshUnderPointer=o.pickedMesh}else i.selectionMesh.isVisible=!1,this._updatePointerDistance(i.laserPointer,1),i.meshUnderPointer=null})}get _utilityLayerScene(){return this._options.customUtilityLayerScene||gt.DefaultUtilityLayer.utilityLayerScene}_attachGazeMode(e){const t=this._controllers[e&&e.uniqueId||"camera"],i=this._options.timeToSelect||3e3,r=this._options.useUtilityLayer?this._utilityLayerScene:this._scene;let s=new Qi;const n=fs("selection",{diameter:.0035*15,thickness:.0025*6,tessellation:20},r);n.isVisible=!1,n.isPickable=!1,n.parent=t.selectionMesh;let o=0,l=!1;const u={pointerId:t.id,pointerType:"xr"};t.onFrameObserver=this._xrSessionManager.onXRFrameObservable.add(()=>{if(t.pick){if(this._augmentPointerInit(u,t.id,t.screenCoordinates),t.laserPointer.material.alpha=0,n.isVisible=!1,t.pick.hit)if(this._pickingMoved(s,t.pick))l&&(this._options.disablePointerUpOnTouchOut||this._scene.simulatePointerUp(t.pick,u)),l=!1,o=0;else if(o>i/10&&(n.isVisible=!0),o+=this._scene.getEngine().getDeltaTime(),o>=i)this._scene.simulatePointerDown(t.pick,u),l=!0,this._options.disablePointerUpOnTouchOut&&this._scene.simulatePointerUp(t.pick,u),n.isVisible=!1;else{const c=1-o/i;n.scaling.set(c,c,c)}else l=!1,o=0;this._scene.simulatePointerMove(t.pick,u),s=t.pick}}),this._options.renderingGroupId!==void 0&&(n.renderingGroupId=this._options.renderingGroupId),e&&e.onDisposeObservable.addOnce(()=>{t.pick&&!this._options.disablePointerUpOnTouchOut&&l&&(this._scene.simulatePointerUp(t.pick,u),t.finalPointerUpTriggered=!0),n.dispose()})}_attachScreenRayMode(e){const t=this._controllers[e.uniqueId];let i=!1;const r={pointerId:t.id,pointerType:"xr"};t.onFrameObserver=this._xrSessionManager.onXRFrameObservable.add(()=>{this._augmentPointerInit(r,t.id,t.screenCoordinates),!(!t.pick||this._options.disablePointerUpOnTouchOut&&i)&&(i?this._scene.simulatePointerMove(t.pick,r):(this._scene.simulatePointerDown(t.pick,r),t.pointerDownTriggered=!0,i=!0,this._options.disablePointerUpOnTouchOut&&this._scene.simulatePointerUp(t.pick,r)))}),e.onDisposeObservable.addOnce(()=>{this._augmentPointerInit(r,t.id,t.screenCoordinates),this._xrSessionManager.runInXRFrame(()=>{t.pick&&!t.finalPointerUpTriggered&&i&&!this._options.disablePointerUpOnTouchOut&&(this._scene.simulatePointerUp(t.pick,r),t.finalPointerUpTriggered=!0)})})}_attachTrackedPointerRayMode(e){const t=this._controllers[e.uniqueId];if(this._options.forceGazeMode)return this._attachGazeMode(e);const i={pointerId:t.id,pointerType:"xr"};if(t.onFrameObserver=this._xrSessionManager.onXRFrameObservable.add(()=>{t.laserPointer.material.disableLighting=this.disablePointerLighting,t.selectionMesh.material.disableLighting=this.disableSelectionMeshLighting,t.pick&&(this._augmentPointerInit(i,t.id,t.screenCoordinates),this._scene.simulatePointerMove(t.pick,i))}),e.inputSource.gamepad){const r=s=>{this._options.overrideButtonId&&(t.selectionComponent=s.getComponent(this._options.overrideButtonId)),t.selectionComponent||(t.selectionComponent=s.getMainComponent()),t.onButtonChangedObserver=t.selectionComponent.onButtonStateChangedObservable.add(n=>{if(n.changes.pressed){const o=n.changes.pressed.current;if(t.pick)(this._options.enablePointerSelectionOnAllControllers||e.uniqueId===this._attachedController)&&(this._augmentPointerInit(i,t.id,t.screenCoordinates),o?(this._scene.simulatePointerDown(t.pick,i),t.pointerDownTriggered=!0,t.selectionMesh.material.emissiveColor=this.selectionMeshPickedColor,t.laserPointer.material.emissiveColor=this.laserPointerPickedColor):(this._scene.simulatePointerUp(t.pick,i),t.selectionMesh.material.emissiveColor=this.selectionMeshDefaultColor,t.laserPointer.material.emissiveColor=this.laserPointerDefaultColor));else if(o&&!this._options.enablePointerSelectionOnAllControllers&&!this._options.disableSwitchOnClick){const l=this._controllers[this._attachedController];l&&l.pointerDownTriggered&&!l.finalPointerUpTriggered&&(this._augmentPointerInit(i,l.id,l.screenCoordinates),this._scene.simulatePointerUp(new Qi,{pointerId:l.id,pointerType:"xr"}),l.finalPointerUpTriggered=!0),this._attachedController=e.uniqueId}}})};e.motionController?r(e.motionController):e.onMotionControllerInitObservable.add(r)}else{const r=n=>{this._xrSessionManager.onXRFrameObservable.addOnce(()=>{this._augmentPointerInit(i,t.id,t.screenCoordinates),t.xrController&&n.inputSource===t.xrController.inputSource&&t.pick&&(this._scene.simulatePointerDown(t.pick,i),t.pointerDownTriggered=!0,t.selectionMesh.material.emissiveColor=this.selectionMeshPickedColor,t.laserPointer.material.emissiveColor=this.laserPointerPickedColor)})},s=n=>{this._xrSessionManager.onXRFrameObservable.addOnce(()=>{this._augmentPointerInit(i,t.id,t.screenCoordinates),t.xrController&&n.inputSource===t.xrController.inputSource&&t.pick&&(this._scene.simulatePointerUp(t.pick,i),t.selectionMesh.material.emissiveColor=this.selectionMeshDefaultColor,t.laserPointer.material.emissiveColor=this.laserPointerDefaultColor)})};t.eventListeners={selectend:s,selectstart:r},this._xrSessionManager.session.addEventListener("selectstart",r),this._xrSessionManager.session.addEventListener("selectend",s)}}_convertNormalToDirectionOfRay(e,t){return e&&Math.acos(m.Dot(e,t.direction))<Math.PI/2&&e.scaleInPlace(-1),e}_detachController(e){const t=this._controllers[e];if(t){if(t.selectionComponent&&t.onButtonChangedObserver&&t.selectionComponent.onButtonStateChangedObservable.remove(t.onButtonChangedObserver),t.onFrameObserver&&this._xrSessionManager.onXRFrameObservable.remove(t.onFrameObserver),t.eventListeners&&Object.keys(t.eventListeners).forEach(i=>{const r=t.eventListeners&&t.eventListeners[i];r&&this._xrSessionManager.session.removeEventListener(i,r)}),!t.finalPointerUpTriggered&&t.pointerDownTriggered){const i={pointerId:t.id,pointerType:"xr"};this._xrSessionManager.runInXRFrame(()=>{this._augmentPointerInit(i,t.id,t.screenCoordinates),this._scene.simulatePointerUp(t.pick||new Qi,i),t.finalPointerUpTriggered=!0})}this._xrSessionManager.scene.onBeforeRenderObservable.addOnce(()=>{try{if(t.selectionMesh.dispose(),t.laserPointer.dispose(),delete this._controllers[e],this._attachedController===e){const i=Object.keys(this._controllers);i.length?this._attachedController=i[0]:this._attachedController=""}}catch{ae.Warn("controller already detached.")}})}}_generateNewMeshPair(e){const t=this._options.useUtilityLayer?this._options.customUtilityLayerScene||gt.DefaultUtilityLayer.utilityLayerScene:this._scene,i=this._options.customLasterPointerMeshGenerator?this._options.customLasterPointerMeshGenerator():tr("laserPointer",{height:1,diameterTop:2e-4,diameterBottom:.004,tessellation:20,subdivisions:1},t);i.parent=e;const r=new Ut("laserPointerMat",t);r.emissiveColor=this.laserPointerDefaultColor,r.alpha=.7,i.material=r,i.rotation.x=Math.PI/2,this._updatePointerDistance(i,1),i.isPickable=!1,i.isVisible=!1;const s=this._options.customSelectionMeshGenerator?this._options.customSelectionMeshGenerator():fs("gazeTracker",{diameter:.0035*3,thickness:.0025*3,tessellation:20},t);s.bakeCurrentTransformIntoVertices(),s.isPickable=!1,s.isVisible=!1;const n=new Ut("targetMat",t);return n.specularColor=ne.Black(),n.emissiveColor=this.selectionMeshDefaultColor,n.backFaceCulling=!1,s.material=n,this._options.renderingGroupId!==void 0&&(i.renderingGroupId=this._options.renderingGroupId,s.renderingGroupId=this._options.renderingGroupId),{laserPointer:i,selectionMesh:s}}_pickingMoved(e,t){var s;if(!e.hit||!t.hit||!e.pickedMesh||!e.pickedPoint||!t.pickedMesh||!t.pickedPoint||e.pickedMesh!==t.pickedMesh)return!0;(s=e.pickedPoint)==null||s.subtractToRef(t.pickedPoint,this._tmpVectorForPickCompare),this._tmpVectorForPickCompare.set(Math.abs(this._tmpVectorForPickCompare.x),Math.abs(this._tmpVectorForPickCompare.y),Math.abs(this._tmpVectorForPickCompare.z));const i=(this._options.gazeModePointerMovedFactor||1)*.01*t.distance;return this._tmpVectorForPickCompare.length()>i}_updatePointerDistance(e,t=100){e.scaling.y=t,this._scene.useRightHandedSystem&&(t*=-1),e.position.z=t/2+.05}_augmentPointerInit(e,t,i){e.pointerId=t,e.pointerType="xr",i&&(e.screenX=i.x,e.screenY=i.y)}get lasterPointerDefaultColor(){return this.laserPointerDefaultColor}}cs._IdCounter=200;cs.Name=ke.POINTER_SELECTION;cs.Version=1;Tt.AddWebXRFeature(cs.Name,(a,e)=>()=>new cs(a,e),cs.Version,!0);var x;(function(a){a[a.Float=1]="Float",a[a.Int=2]="Int",a[a.Vector2=4]="Vector2",a[a.Vector3=8]="Vector3",a[a.Vector4=16]="Vector4",a[a.Color3=32]="Color3",a[a.Color4=64]="Color4",a[a.Matrix=128]="Matrix",a[a.Object=256]="Object",a[a.AutoDetect=1024]="AutoDetect",a[a.BasedOnInput=2048]="BasedOnInput",a[a.All=4095]="All"})(x||(x={}));var A;(function(a){a[a.Vertex=1]="Vertex",a[a.Fragment=2]="Fragment",a[a.Neutral=4]="Neutral",a[a.VertexAndFragment=3]="VertexAndFragment"})(A||(A={}));class uS{constructor(){this.supportUniformBuffers=!1,this.attributes=[],this.uniforms=[],this.constants=[],this.samplers=[],this.functions={},this.extensions={},this.prePassOutput={},this.counters={},this._terminalBlocks=new Set,this._attributeDeclaration="",this._uniformDeclaration="",this._constantDeclaration="",this._samplerDeclaration="",this._varyingTransfer="",this._injectAtEnd="",this._repeatableContentAnchorIndex=0,this._builtCompilationString="",this.compilationString=""}get shaderLanguage(){return this.sharedData.nodeMaterial.shaderLanguage}get fSuffix(){return this.shaderLanguage===1?"f":""}finalize(e){const t=e.sharedData.emitComments,i=this.target===A.Fragment;this.shaderLanguage===1?i?this.compilationString=`
${t?`//Entry point
`:""}@fragment
fn main(input: FragmentInputs) -> FragmentOutputs {
${this.sharedData.varyingInitializationsFragment}${this.compilationString}`:this.compilationString=`
${t?`//Entry point
`:""}@vertex
fn main(input: VertexInputs) -> FragmentInputs{
${this.compilationString}`:this.compilationString=`
${t?`//Entry point
`:""}void main(void) {
${this.compilationString}`,this._constantDeclaration&&(this.compilationString=`
${t?`//Constants
`:""}${this._constantDeclaration}
${this.compilationString}`);let r="";for(const s in this.functions)r+=this.functions[s]+`
`;if(this.compilationString=`
${r}
${this.compilationString}`,!i&&this._varyingTransfer&&(this.compilationString=`${this.compilationString}
${this._varyingTransfer}`),this._injectAtEnd&&(this.compilationString=`${this.compilationString}
${this._injectAtEnd}`),this.compilationString=`${this.compilationString}
}`,this.sharedData.varyingDeclaration&&(this.compilationString=`
${t?`//Varyings
`:""}${i?this.sharedData.varyingDeclarationFragment:this.sharedData.varyingDeclaration}
${this.compilationString}`),this._samplerDeclaration&&(this.compilationString=`
${t?`//Samplers
`:""}${this._samplerDeclaration}
${this.compilationString}`),this._uniformDeclaration&&(this.compilationString=`
${t?`//Uniforms
`:""}${this._uniformDeclaration}
${this.compilationString}`),this._attributeDeclaration&&!i&&(this.compilationString=`
${t?`//Attributes
`:""}${this._attributeDeclaration}
${this.compilationString}`),this.shaderLanguage!==1){this.compilationString=`precision highp float;
`+this.compilationString,this.compilationString=`#if defined(WEBGL2) || defined(WEBGPU)
precision highp sampler2DArray;
#endif
`+this.compilationString,i&&(this.compilationString=`#if defined(PREPASS)\r
#extension GL_EXT_draw_buffers : require\r
layout(location = 0) out highp vec4 glFragData[SCENE_MRT_COUNT];\r
highp vec4 gl_FragColor;\r
#endif\r
`+this.compilationString);for(const s in this.extensions){const n=this.extensions[s];this.compilationString=`
${n}
${this.compilationString}`}}this._builtCompilationString=this.compilationString}get _repeatableContentAnchor(){return`###___ANCHOR${this._repeatableContentAnchorIndex++}___###`}_getFreeVariableName(e){return e=e.replace(/[^a-zA-Z_]+/g,""),this.sharedData.variableNames[e]===void 0?(this.sharedData.variableNames[e]=0,e==="output"||e==="texture"?e+this.sharedData.variableNames[e]:e):(this.sharedData.variableNames[e]++,e+this.sharedData.variableNames[e])}_getFreeDefineName(e){return this.sharedData.defineNames[e]===void 0?this.sharedData.defineNames[e]=0:this.sharedData.defineNames[e]++,e+this.sharedData.defineNames[e]}_excludeVariableName(e){this.sharedData.variableNames[e]=0}_emit2DSampler(e,t="",i=!1){(this.samplers.indexOf(e)<0||i)&&(t&&(this._samplerDeclaration+=`#if ${t}
`),this.shaderLanguage===1?(this._samplerDeclaration+=`var ${e+"Sampler"}: sampler;
`,this._samplerDeclaration+=`var ${e}: texture_2d<f32>;
`):this._samplerDeclaration+=`uniform sampler2D ${e};
`,t&&(this._samplerDeclaration+=`#endif
`),i||this.samplers.push(e))}_emitCubeSampler(e,t="",i=!1){(this.samplers.indexOf(e)<0||i)&&(t&&(this._samplerDeclaration+=`#if ${t}
`),this.shaderLanguage===1?(this._samplerDeclaration+=`var ${e+"Sampler"}: sampler;
`,this._samplerDeclaration+=`var ${e}: texture_cube<f32>;
`):this._samplerDeclaration+=`uniform samplerCube ${e};
`,t&&(this._samplerDeclaration+=`#endif
`),i||this.samplers.push(e))}_emit2DArraySampler(e){this.samplers.indexOf(e)<0&&(this._samplerDeclaration+=`uniform sampler2DArray ${e};
`,this.samplers.push(e))}_getGLType(e){switch(e){case x.Float:return"float";case x.Int:return"int";case x.Vector2:return"vec2";case x.Color3:case x.Vector3:return"vec3";case x.Color4:case x.Vector4:return"vec4";case x.Matrix:return"mat4"}return""}_getShaderType(e){const t=this.shaderLanguage===1;switch(e){case x.Float:return t?"f32":"float";case x.Int:return t?"i32":"int";case x.Vector2:return t?"vec2f":"vec2";case x.Color3:case x.Vector3:return t?"vec3f":"vec3";case x.Color4:case x.Vector4:return t?"vec4f":"vec4";case x.Matrix:return t?"mat4x4f":"mat4"}return""}_emitExtension(e,t,i=""){this.extensions[e]||(i&&(t=`#if ${i}
${t}
#endif`),this.extensions[e]=t)}_emitFunction(e,t,i){this.functions[e]||(this.sharedData.emitComments&&(t=i+`
`+t),this.functions[e]=t)}_emitCodeFromInclude(e,t,i){const r=P.GetIncludesShadersStore(this.shaderLanguage);if(i&&i.repeatKey)return`#include<${e}>${i.substitutionVars?"("+i.substitutionVars+")":""}[0..${i.repeatKey}]
`;let s=r[e]+`
`;if(this.sharedData.emitComments&&(s=t+`
`+s),!i)return s;if(i.replaceStrings)for(let n=0;n<i.replaceStrings.length;n++){const o=i.replaceStrings[n];s=s.replace(o.search,o.replace)}return s}_emitFunctionFromInclude(e,t,i,r=""){const s=e+r;if(this.functions[s])return;const n=P.GetIncludesShadersStore(this.shaderLanguage);if(!i||!i.removeAttributes&&!i.removeUniforms&&!i.removeVaryings&&!i.removeIfDef&&!i.replaceStrings){i&&i.repeatKey?this.functions[s]=`#include<${e}>${i.substitutionVars?"("+i.substitutionVars+")":""}[0..${i.repeatKey}]
`:this.functions[s]=`#include<${e}>${i!=null&&i.substitutionVars?"("+(i==null?void 0:i.substitutionVars)+")":""}
`,this.sharedData.emitComments&&(this.functions[s]=t+`
`+this.functions[s]);return}if(this.functions[s]=n[e],this.sharedData.emitComments&&(this.functions[s]=t+`
`+this.functions[s]),i.removeIfDef&&(this.functions[s]=this.functions[s].replace(/^\s*?#ifdef.+$/gm,""),this.functions[s]=this.functions[s].replace(/^\s*?#endif.*$/gm,""),this.functions[s]=this.functions[s].replace(/^\s*?#else.*$/gm,""),this.functions[s]=this.functions[s].replace(/^\s*?#elif.*$/gm,"")),i.removeAttributes&&(this.functions[s]=this.functions[s].replace(/\s*?attribute .+?;/g,`
`)),i.removeUniforms&&(this.functions[s]=this.functions[s].replace(/\s*?uniform .*?;/g,`
`)),i.removeVaryings&&(this.functions[s]=this.functions[s].replace(/\s*?(varying|in) .+?;/g,`
`)),i.replaceStrings)for(let o=0;o<i.replaceStrings.length;o++){const l=i.replaceStrings[o];this.functions[s]=this.functions[s].replace(l.search,l.replace)}}_registerTempVariable(e){return this.sharedData.temps.indexOf(e)!==-1?!1:(this.sharedData.temps.push(e),!0)}_emitVaryingFromString(e,t,i="",r=!1){if(this.sharedData.varyings.indexOf(e)!==-1)return!1;this.sharedData.varyings.push(e);const s=this._getShaderType(t),n=(o=!1)=>{let l="";if(i&&(i.startsWith("defined(")?l+=`#if ${i}
`:l+=`${r?"#ifndef":"#ifdef"} ${i}
`),this.shaderLanguage===1)switch(s){case"mat4x4f":l+=`varying ${e}_r0: vec4f;
`,l+=`varying ${e}_r1: vec4f;
`,l+=`varying ${e}_r2: vec4f;
`,l+=`varying ${e}_r3: vec4f;
`,o&&(l+=`var<private> ${e}: mat4x4f;
`,this.sharedData.varyingInitializationsFragment+=`${e} = mat4x4f(fragmentInputs.${e}_r0, fragmentInputs.${e}_r1, fragmentInputs.${e}_r2, fragmentInputs.${e}_r3);
`);break;default:l+=`varying ${e}: ${s};
`;break}else l+=`varying ${s} ${e};
`;return i&&(l+=`#endif
`),l};if(this.shaderLanguage===1)this.sharedData.varyingDeclaration+=n(!1),this.sharedData.varyingDeclarationFragment+=n(!0);else{const o=n();this.sharedData.varyingDeclaration+=o,this.sharedData.varyingDeclarationFragment+=o}return!0}_getVaryingName(e){return this.shaderLanguage===1?(this.target!==A.Fragment?"vertexOutputs.":"fragmentInputs.")+e:e}_emitUniformFromString(e,t,i="",r=!1){if(this.uniforms.indexOf(e)!==-1)return;this.uniforms.push(e),i&&(i.startsWith("defined(")?this._uniformDeclaration+=`#if ${i}
`:this._uniformDeclaration+=`${r?"#ifndef":"#ifdef"} ${i}
`);const s=this._getShaderType(t);this.shaderLanguage===1?this._uniformDeclaration+=`uniform ${e}: ${s};
`:this._uniformDeclaration+=`uniform ${s} ${e};
`,i&&(this._uniformDeclaration+=`#endif
`)}_generateTernary(e,t,i){return this.shaderLanguage===1?`select(${t}, ${e}, ${i})`:`(${i}) ? ${e} : ${t}`}_emitFloat(e){return e.toString()===e.toFixed(0)?`${e}.0`:e.toString()}_declareOutput(e,t){return this._declareLocalVar(e.associatedVariableName,e.type,t)}_declareLocalVar(e,t,i){return this.shaderLanguage===1?`${i?"const":"var"} ${e}: ${this._getShaderType(t)}`:`${this._getShaderType(t)} ${e}`}_samplerCubeFunc(){return this.shaderLanguage===1?"textureSample":"textureCube"}_samplerFunc(){return this.shaderLanguage===1?"textureSample":"texture2D"}_samplerLODFunc(){return this.shaderLanguage===1?"textureSampleLevel":"texture2DLodEXT"}_toLinearSpace(e){return this.shaderLanguage===1?e.type===x.Color3||e.type===x.Vector3?`toLinearSpaceVec3(${e.associatedVariableName})`:`toLinearSpace(${e.associatedVariableName})`:`toLinearSpace(${e.associatedVariableName})`}_generateTextureSample(e,t){return this.shaderLanguage===1?`${this._samplerFunc()}(${t},${t+"Sampler"}, ${e})`:`${this._samplerFunc()}(${t}, ${e})`}_generateTextureSampleLOD(e,t,i){return this.shaderLanguage===1?`${this._samplerLODFunc()}(${t},${t+"Sampler"}, ${e}, ${i})`:`${this._samplerLODFunc()}(${t}, ${e}, ${i})`}_generateTextureSampleCube(e,t){return this.shaderLanguage===1?`${this._samplerCubeFunc()}(${t},${t+"Sampler"}, ${e})`:`${this._samplerCubeFunc()}(${t}, ${e})`}_generateTextureSampleCubeLOD(e,t,i){return this.shaderLanguage===1?`${this._samplerCubeFunc()}(${t},${t+"Sampler"}, ${e}, ${i})`:`${this._samplerCubeFunc()}(${t}, ${e}, ${i})`}_convertVariableDeclarationToWGSL(e,t,i){return i.replace(new RegExp(`(${e})\\s+(\\w+)`,"g"),`var $2: ${t}`)}_convertVariableConstructorsToWGSL(e,t,i){return i.replace(new RegExp(`(${e})\\(`,"g"),` ${t}(`)}_convertOutParametersToWGSL(e){return e.replace(new RegExp("out\\s+var\\s+(\\w+)\\s*:\\s*(\\w+)","g"),"$1: ptr<function, $2>")}_convertTernaryOperandsToWGSL(e){return e.replace(new RegExp("\\[(.*?)\\?(.*?):(.*)\\]","g"),(t,i,r,s)=>`select(${s}, ${r}, ${i})`)}_convertModOperatorsToWGSL(e){return e.replace(new RegExp("mod\\((.+?),\\s*(.+?)\\)","g"),(t,i,r)=>`((${i})%(${r}))`)}_convertConstToWGSL(e){return e.replace(new RegExp("const var","g"),"const")}_convertInnerFunctionsToWGSL(e){return e.replace(new RegExp("inversesqrt","g"),"inverseSqrt")}_convertFunctionsToWGSL(e){const t=/var\s+(\w+)\s*:\s*(\w+)\((.*)\)/g;let i;for(;(i=t.exec(e))!==null;){const r=i[1],s=i[2],o=i[3].replace(/var\s/g,"");e=e.replace(i[0],`fn ${r}(${o}) -> ${s}`)}return e}_babylonSLtoWGSL(e){return e=this._convertVariableDeclarationToWGSL("void","voidnull",e),e=this._convertVariableDeclarationToWGSL("bool","bool",e),e=this._convertVariableDeclarationToWGSL("int","i32",e),e=this._convertVariableDeclarationToWGSL("uint","u32",e),e=this._convertVariableDeclarationToWGSL("float","f32",e),e=this._convertVariableDeclarationToWGSL("vec2","vec2f",e),e=this._convertVariableDeclarationToWGSL("vec3","vec3f",e),e=this._convertVariableDeclarationToWGSL("vec4","vec4f",e),e=this._convertVariableDeclarationToWGSL("mat2","mat2x2f",e),e=this._convertVariableDeclarationToWGSL("mat3","mat3x3f",e),e=this._convertVariableDeclarationToWGSL("mat4","mat4x4f",e),e=this._convertVariableConstructorsToWGSL("float","f32",e),e=this._convertVariableConstructorsToWGSL("vec2","vec2f",e),e=this._convertVariableConstructorsToWGSL("vec3","vec3f",e),e=this._convertVariableConstructorsToWGSL("vec4","vec4f",e),e=this._convertVariableConstructorsToWGSL("mat2","mat2x2f",e),e=this._convertVariableConstructorsToWGSL("mat3","mat3x3f",e),e=this._convertVariableConstructorsToWGSL("mat4","mat4x4f",e),e=this._convertTernaryOperandsToWGSL(e),e=this._convertModOperatorsToWGSL(e),e=this._convertConstToWGSL(e),e=this._convertInnerFunctionsToWGSL(e),e=this._convertOutParametersToWGSL(e),e=e.replace(/\[\*\]/g,"*"),e=this._convertFunctionsToWGSL(e),e=e.replace(/\s->\svoidnull/g,""),e=e.replace(/dFdx/g,"dpdx"),e=e.replace(/dFdy/g,"dpdy"),e}_convertTernaryOperandsToGLSL(e){return e.replace(new RegExp("\\[(.+?)\\?(.+?):(.+)\\]","g"),(t,i,r,s)=>`${i} ? ${r} : ${s}`)}_babylonSLtoGLSL(e){return e=e.replace(/\[\*\]/g,""),e=this._convertTernaryOperandsToGLSL(e),e}}class Kw{constructor(){this.temps=[],this.varyings=[],this.varyingDeclaration="",this.varyingDeclarationFragment="",this.varyingInitializationsFragment="",this.inputBlocks=[],this.textureBlocks=[],this.bindableBlocks=[],this.forcedBindableBlocks=[],this.blocksWithFallbacks=[],this.blocksWithDefines=[],this.repeatableContentBlocks=[],this.dynamicUniformBlocks=[],this.blockingBlocks=[],this.animatedInputs=[],this.variableNames={},this.defineNames={},this.hints={needWorldViewMatrix:!1,needWorldViewProjectionMatrix:!1,needAlphaBlending:!1,needAlphaTesting:!1},this.checks={emitVertex:!1,emitFragment:!1,notConnectedNonOptionalInputs:new Array},this.allowEmptyVertexProgram=!1,this.variableNames.position=0,this.variableNames.normal=0,this.variableNames.tangent=0,this.variableNames.uv=0,this.variableNames.uv2=0,this.variableNames.uv3=0,this.variableNames.uv4=0,this.variableNames.uv5=0,this.variableNames.uv6=0,this.variableNames.color=0,this.variableNames.matricesIndices=0,this.variableNames.matricesWeights=0,this.variableNames.matricesIndicesExtra=0,this.variableNames.matricesWeightsExtra=0,this.variableNames.diffuseBase=0,this.variableNames.specularBase=0,this.variableNames.worldPos=0,this.variableNames.shadow=0,this.variableNames.view=0,this.variableNames.vTBN=0,this.defineNames.MAINUV0=0,this.defineNames.MAINUV1=0,this.defineNames.MAINUV2=0,this.defineNames.MAINUV3=0,this.defineNames.MAINUV4=0,this.defineNames.MAINUV5=0,this.defineNames.MAINUV6=0,this.defineNames.MAINUV7=0}emitErrors(e=null){let t="";!this.checks.emitVertex&&!this.allowEmptyVertexProgram&&(t+=`NodeMaterial does not have a vertex output. You need to at least add a block that generates a position value.
`),this.checks.emitFragment||(t+=`NodeMaterial does not have a fragment output. You need to at least add a block that generates a color value.
`);for(const i of this.checks.notConnectedNonOptionalInputs)t+=`input ${i.name} from block ${i.ownerBlock.name}[${i.ownerBlock.getClassName()}] is not connected and is not optional.
`;return t?(e&&e.notifyObservers(t),L.Error(`Build of NodeMaterial failed:
`+t),!1):!0}}var cS;(function(a){a[a.Compatible=0]="Compatible",a[a.TypeIncompatible=1]="TypeIncompatible",a[a.TargetIncompatible=2]="TargetIncompatible",a[a.HierarchyIssue=3]="HierarchyIssue"})(cS||(cS={}));var hS;(function(a){a[a.Input=0]="Input",a[a.Output=1]="Output"})(hS||(hS={}));class ka{static AreEquivalentTypes(e,t){switch(e){case x.Vector3:{if(t===x.Color3)return!0;break}case x.Vector4:{if(t===x.Color4)return!0;break}case x.Color3:{if(t===x.Vector3)return!0;break}case x.Color4:{if(t===x.Vector4)return!0;break}}return!1}get _connectedPoint(){return this._connectedPointBackingField}set _connectedPoint(e){var t;this._connectedPointBackingField!==e&&((t=this._connectedPointTypeChangedObserver)==null||t.remove(),this._updateTypeDependentState(()=>this._connectedPointBackingField=e),this._connectedPointBackingField&&(this._connectedPointTypeChangedObserver=this._connectedPointBackingField.onTypeChangedObservable.add(()=>{this._notifyTypeChanged()})))}get _typeConnectionSource(){return this._typeConnectionSourceBackingField}set _typeConnectionSource(e){var t;this._typeConnectionSourceBackingField!==e&&((t=this._typeConnectionSourceTypeChangedObserver)==null||t.remove(),this._updateTypeDependentState(()=>this._typeConnectionSourceBackingField=e),this._typeConnectionSourceBackingField&&(this._typeConnectionSourceTypeChangedObserver=this._typeConnectionSourceBackingField.onTypeChangedObservable.add(()=>{this._notifyTypeChanged()})))}get _defaultConnectionPointType(){return this._defaultConnectionPointTypeBackingField}set _defaultConnectionPointType(e){this._updateTypeDependentState(()=>this._defaultConnectionPointTypeBackingField=e)}get _linkedConnectionSource(){return this._linkedConnectionSourceBackingField}set _linkedConnectionSource(e){var t;this._linkedConnectionSourceBackingField!==e&&((t=this._linkedConnectionSourceTypeChangedObserver)==null||t.remove(),this._updateTypeDependentState(()=>this._linkedConnectionSourceBackingField=e),this._isMainLinkSource=!1,this._linkedConnectionSourceBackingField&&(this._linkedConnectionSourceTypeChangedObserver=this._linkedConnectionSourceBackingField.onTypeChangedObservable.add(()=>{this._notifyTypeChanged()})))}get direction(){return this._direction}get declarationVariableName(){return this._ownerBlock.isInput?this._ownerBlock.declarationVariableName:(!this._enforceAssociatedVariableName||!this._associatedVariableName)&&this._connectedPoint?this._connectedPoint.declarationVariableName:this._associatedVariableName}get associatedVariableName(){return this._ownerBlock.isInput?this._ownerBlock.associatedVariableName:(!this._enforceAssociatedVariableName||!this._associatedVariableName)&&this._connectedPoint?this._connectedPoint.associatedVariableName:this._associatedVariableName}set associatedVariableName(e){this._associatedVariableName=e}get innerType(){return this._linkedConnectionSource&&!this._isMainLinkSource&&this._linkedConnectionSource.isConnected?this.type:this._type}get type(){if(this._type===x.AutoDetect){if(this._ownerBlock.isInput)return this._ownerBlock.type;if(this._connectedPoint)return this._connectedPoint.type;if(this._linkedConnectionSource){if(this._linkedConnectionSource.isConnected)return this._linkedConnectionSource.connectedPoint._redirectedSource&&this._linkedConnectionSource.connectedPoint._redirectedSource.isConnected?this._linkedConnectionSource.connectedPoint._redirectedSource.type:this._linkedConnectionSource.type;if(this._linkedConnectionSource._defaultConnectionPointType)return this._linkedConnectionSource._defaultConnectionPointType}if(this._defaultConnectionPointType)return this._defaultConnectionPointType}if(this._type===x.BasedOnInput){if(this._typeConnectionSource)return!this._typeConnectionSource.isConnected&&this._defaultConnectionPointType?this._defaultConnectionPointType:this._typeConnectionSource.type;if(this._defaultConnectionPointType)return this._defaultConnectionPointType}return this._type}set type(e){this._updateTypeDependentState(()=>this._type=e)}get target(){return!this._prioritizeVertex||!this._ownerBlock?this._target:this._target!==A.VertexAndFragment?this._target:this._ownerBlock.target===A.Fragment?A.Fragment:A.Vertex}set target(e){this._target=e}get isConnected(){return this.connectedPoint!==null||this.hasEndpoints}get isConnectedToInputBlock(){return this.connectedPoint!==null&&this.connectedPoint.ownerBlock.isInput}get connectInputBlock(){return this.isConnectedToInputBlock?this.connectedPoint.ownerBlock:null}get connectedPoint(){return this._connectedPoint}get ownerBlock(){return this._ownerBlock}get sourceBlock(){return this._connectedPoint?this._connectedPoint.ownerBlock:null}get connectedBlocks(){return this._endpoints.length===0?[]:this._endpoints.map(e=>e.ownerBlock)}get endpoints(){return this._endpoints}get hasEndpoints(){return this._endpoints&&this._endpoints.length>0}get isDirectlyConnectedToVertexOutput(){if(!this.hasEndpoints)return!1;for(const e of this._endpoints)if(e.ownerBlock.target===A.Vertex||(e.ownerBlock.target===A.Neutral||e.ownerBlock.target===A.VertexAndFragment)&&e.ownerBlock.outputs.some(t=>t.isDirectlyConnectedToVertexOutput))return!0;return!1}get isConnectedInVertexShader(){if(this.target===A.Vertex)return!0;if(!this.hasEndpoints)return!1;for(const e of this._endpoints)if(e.ownerBlock.target===A.Vertex||e.target===A.Vertex||(e.ownerBlock.target===A.Neutral||e.ownerBlock.target===A.VertexAndFragment)&&e.ownerBlock.outputs.some(t=>t.isConnectedInVertexShader))return!0;return!1}get isConnectedInFragmentShader(){if(this.target===A.Fragment)return!0;if(!this.hasEndpoints)return!1;for(const e of this._endpoints)if(e.ownerBlock.target===A.Fragment||(e.ownerBlock.target===A.Neutral||e.ownerBlock.target===A.VertexAndFragment)&&e.ownerBlock.isConnectedInFragmentShader())return!0;return!1}createCustomInputBlock(){return null}constructor(e,t,i){this._preventBubbleUp=!1,this._connectedPointBackingField=null,this._endpoints=new Array,this._redirectedSource=null,this._typeConnectionSourceBackingField=null,this._defaultConnectionPointTypeBackingField=null,this._isMainLinkSource=!1,this._linkedConnectionSourceBackingField=null,this._acceptedConnectionPointType=null,this._type=x.Float,this._enforceAssociatedVariableName=!1,this._forPostBuild=!1,this.needDualDirectionValidation=!1,this.acceptedConnectionPointTypes=[],this.excludedConnectionPointTypes=[],this.onConnectionObservable=new j,this.onDisconnectionObservable=new j,this.onTypeChangedObservable=new j,this._isTypeChangeObservableNotifying=!1,this.isExposedOnFrame=!1,this.exposedPortPosition=-1,this._prioritizeVertex=!1,this._target=A.VertexAndFragment,this._ownerBlock=t,this.name=e,this._direction=i}getClassName(){return"NodeMaterialConnectionPoint"}canConnectTo(e){return this.checkCompatibilityState(e)===0}checkCompatibilityState(e){const t=this._ownerBlock,i=e.ownerBlock;if(t.target===A.Fragment){if(i.target===A.Vertex)return 2;for(const n of i.outputs)if(n.ownerBlock.target!=A.Neutral&&n.isConnectedInVertexShader)return 2}if(this.type!==e.type&&e.innerType!==x.AutoDetect)return ka.AreEquivalentTypes(this.type,e.type)||e.acceptedConnectionPointTypes&&e.acceptedConnectionPointTypes.indexOf(this.type)!==-1||e._acceptedConnectionPointType&&ka.AreEquivalentTypes(e._acceptedConnectionPointType.type,this.type)?0:1;if(e.excludedConnectionPointTypes&&e.excludedConnectionPointTypes.indexOf(this.type)!==-1)return 1;let r=i,s=t;return this.direction===0&&(r=t,s=i),r.isAnAncestorOf(s)?3:0}connectTo(e,t=!1){if(!t&&!this.canConnectTo(e))throw"Cannot connect these two connectors.";return this._endpoints.push(e),e._connectedPoint=this,this._enforceAssociatedVariableName=!1,this.onConnectionObservable.notifyObservers(e),e.onConnectionObservable.notifyObservers(this),this}disconnectFrom(e){const t=this._endpoints.indexOf(e);return t===-1?this:(this._endpoints.splice(t,1),e._connectedPoint=null,this._enforceAssociatedVariableName=!1,e._enforceAssociatedVariableName=!1,this.onDisconnectionObservable.notifyObservers(e),e.onDisconnectionObservable.notifyObservers(this),this)}addExcludedConnectionPointFromAllowedTypes(e){let t=1;for(;t<x.All;)e&t||this.excludedConnectionPointTypes.push(t),t=t<<1}serialize(e=!0){const t={};return t.name=this.name,this.displayName&&(t.displayName=this.displayName),e&&this.connectedPoint&&(t.inputName=this.name,t.targetBlockId=this.connectedPoint.ownerBlock.uniqueId,t.targetConnectionName=this.connectedPoint.name,t.isExposedOnFrame=!0,t.exposedPortPosition=this.exposedPortPosition),(this.isExposedOnFrame||this.exposedPortPosition>=0)&&(t.isExposedOnFrame=!0,t.exposedPortPosition=this.exposedPortPosition),t}dispose(){this.onConnectionObservable.clear(),this.onDisconnectionObservable.clear(),this.onTypeChangedObservable.clear(),this._connectedPoint=null,this._typeConnectionSource=null,this._linkedConnectionSource=null}_updateTypeDependentState(e){const t=this.type;e(),this.type!==t&&this._notifyTypeChanged()}_notifyTypeChanged(){this._isTypeChangeObservableNotifying||(this._isTypeChangeObservableNotifying=!0,this.onTypeChangedObservable.notifyObservers(this.type),this._isTypeChangeObservableNotifying=!1)}}class le{get _isFinalOutputAndActive(){return this._isFinalOutput}get _hasPrecedence(){return!1}get name(){return this._name}get codeIsReady(){return this._codeIsReady}set name(e){this.validateBlockName(e)&&(this._name=e)}get isUnique(){return this._isUnique}get isFinalMerger(){return this._isFinalMerger}get isInput(){return this._isInput}get isTeleportOut(){return this._isTeleportOut}get isTeleportIn(){return this._isTeleportIn}get isLoop(){return this._isLoop}get buildId(){return this._buildId}set buildId(e){this._buildId=e}get target(){return this._target}set target(e){this._target&e||(this._target=e)}get inputs(){return this._inputs}get outputs(){return this._outputs}getInputByName(e){const t=this._inputs.filter(i=>i.name===e);return t.length?t[0]:null}getOutputByName(e){const t=this._outputs.filter(i=>i.name===e);return t.length?t[0]:null}constructor(e,t=A.Vertex,i=!1,r=!1){switch(this._isFinalMerger=!1,this._isInput=!1,this._isLoop=!1,this._isTeleportOut=!1,this._isTeleportIn=!1,this._name="",this._isUnique=!1,this._codeIsReady=!0,this._isFinalOutput=!1,this.onCodeIsReadyObservable=new j,this.inputsAreExclusive=!1,this._codeVariableName="",this._inputs=new Array,this._outputs=new Array,this.comments="",this.visibleInInspector=!1,this.visibleOnFrame=!1,this._target=t,this._originalTargetIsNeutral=t===A.Neutral,this._isFinalMerger=i,this._isFinalOutput=r,this.getClassName()){case"InputBlock":this._isInput=!0;break;case"NodeMaterialTeleportOutBlock":this._isTeleportOut=!0;break;case"NodeMaterialTeleportInBlock":this._isTeleportIn=!0;break;case"LoopBlock":this._isLoop=!0;break}this._name=e,this.uniqueId=pu.UniqueId}_setInitialTarget(e){this._target=e,this._originalTargetIsNeutral=e===A.Neutral}initialize(e){}bind(e,t,i,r){}_writeVariable(e){return e.connectedPoint?`${e.associatedVariableName}`:"0."}_writeFloat(e){let t=e.toString();return t.indexOf(".")===-1&&(t+=".0"),`${t}`}getClassName(){return"NodeMaterialBlock"}isConnectedInFragmentShader(){return this.outputs.some(e=>e.isConnectedInFragmentShader)}registerInput(e,t,i=!1,r,s){return s=s??new ka(e,this,0),s.type=t,s.isOptional=i,r&&(s.target=r),this._inputs.push(s),this}registerOutput(e,t,i,r){return r=r??new ka(e,this,1),r.type=t,i&&(r.target=i),this._outputs.push(r),this}getFirstAvailableInput(e=null){for(const t of this._inputs)if(!t.connectedPoint&&(!e||e.type===t.type||t.type===x.AutoDetect||t.acceptedConnectionPointTypes.indexOf(e.type)!==-1))return t;return null}getFirstAvailableOutput(e=null){for(const t of this._outputs)if(!e||!e.target||e.target===A.Neutral||e.target&t.target)return t;return null}getSiblingOutput(e){const t=this._outputs.indexOf(e);return t===-1||t>=this._outputs.length?null:this._outputs[t+1]}isAnAncestorOf(e){for(const t of this._outputs)if(t.hasEndpoints){for(const i of t.endpoints)if(i.ownerBlock===e||i.ownerBlock.isAnAncestorOf(e))return!0}return!1}connectTo(e,t){if(this._outputs.length===0)return;let i=t&&t.output?this.getOutputByName(t.output):this.getFirstAvailableOutput(e),r=!0;for(;r;){const s=t&&t.input?e.getInputByName(t.input):e.getFirstAvailableInput(i);if(i&&s&&i.canConnectTo(s))i.connectTo(s),r=!1;else if(i)i=this.getSiblingOutput(i);else throw"Unable to find a compatible match"}return this}_buildBlock(e){}_postBuildBlock(e){}updateUniformsAndSamples(e,t,i,r){}provideFallbacks(e,t){}initializeDefines(e,t,i,r=!1){}prepareDefines(e,t,i,r=!1,s){}autoConfigure(e,t=()=>!0){}replaceRepeatableContent(e,t,i,r){}get willBeGeneratedIntoVertexShaderFromFragmentShader(){return this.isInput||this.isFinalMerger||this._outputs.some(e=>e.isDirectlyConnectedToVertexOutput)||this.target===A.Vertex?!1:!!((this.target===A.VertexAndFragment||this.target===A.Neutral)&&this._outputs.some(e=>e.isConnectedInVertexShader))}isReady(e,t,i,r=!1){return!0}_linkConnectionTypes(e,t,i=!1){i?this._inputs[t]._acceptedConnectionPointType=this._inputs[e]:(this._inputs[e]._linkedConnectionSource=this._inputs[t],this._inputs[e]._isMainLinkSource=!0),this._inputs[t]._linkedConnectionSource=this._inputs[e]}_processBuild(e,t,i,r){e.build(t,r);const s=t._vertexState!=null,n=e._buildTarget===A.Vertex&&e.target!==A.VertexAndFragment;if(s&&(!(e.target&e._buildTarget)||!(e.target&i.target)||this.target!==A.VertexAndFragment&&n)&&(!e.isInput&&t.target!==e._buildTarget||e.isInput&&e.isAttribute&&!e._noContextSwitch)){const o=i.connectedPoint;if(t._vertexState._emitVaryingFromString("v_"+o.declarationVariableName,o.type)){const u=t.shaderLanguage===1?"vertexOutputs.":"";t.shaderLanguage===1&&o.type===x.Matrix?(t._vertexState.compilationString+=`${u}${"v_"+o.declarationVariableName}_r0 = ${o.associatedVariableName}[0];
`,t._vertexState.compilationString+=`${u}${"v_"+o.declarationVariableName}_r1 = ${o.associatedVariableName}[1];
`,t._vertexState.compilationString+=`${u}${"v_"+o.declarationVariableName}_r2 = ${o.associatedVariableName}[2];
`,t._vertexState.compilationString+=`${u}${"v_"+o.declarationVariableName}_r3 = ${o.associatedVariableName}[3];
`):t._vertexState.compilationString+=`${u}${"v_"+o.declarationVariableName} = ${o.associatedVariableName};
`}const l=t.shaderLanguage===1&&o.type!==x.Matrix?"fragmentInputs.":"";i.associatedVariableName=l+"v_"+o.declarationVariableName,i._enforceAssociatedVariableName=!0}}validateBlockName(e){const t=["position","normal","tangent","particle_positionw","uv","uv2","uv3","uv4","uv5","uv6","position2d","particle_uv","matricesIndices","matricesWeights","world0","world1","world2","world3","particle_color","particle_texturemask"];for(const i of t)if(e===i)return!1;return!0}_customBuildStep(e,t){}build(e,t){if(this._buildId===e.sharedData.buildId)return!0;if(!this.isInput)for(const i of this._outputs)i.associatedVariableName||(i.associatedVariableName=e._getFreeVariableName(i.name));for(const i of this._inputs){if(!i.connectedPoint){i.isOptional||e.sharedData.checks.notConnectedNonOptionalInputs.push(i);continue}if(this.target!==A.Neutral&&(!(i.target&this.target)||!(i.target&e.target)))continue;const r=i.connectedPoint.ownerBlock;r&&r!==this&&this._processBuild(r,e,i,t)}if(this._customBuildStep(e,t),this._buildId===e.sharedData.buildId)return!0;if(e.sharedData.verbose&&L.Log(`${e.target===A.Vertex?"Vertex shader":"Fragment shader"}: Building ${this.name} [${this.getClassName()}]`),this.isFinalMerger)switch(e.target){case A.Vertex:e.sharedData.checks.emitVertex=!0;break;case A.Fragment:e.sharedData.checks.emitFragment=!0;break}!this.isInput&&e.sharedData.emitComments&&(e.compilationString+=`
//${this.name}
`),this._buildBlock(e),this._buildId=e.sharedData.buildId,this._buildTarget=e.target;for(const i of this._outputs)if(!i._forPostBuild&&i.target&e.target)for(const r of i.endpoints){const s=r.ownerBlock;s&&(s.target&e.target&&t.indexOf(s)!==-1||e._terminalBlocks.has(s))&&this._processBuild(s,e,r,t)}this._postBuildBlock(e);for(const i of this._outputs)if(i._forPostBuild&&i.target&e.target)for(const r of i.endpoints){const s=r.ownerBlock;s&&s.target&e.target&&t.indexOf(s)!==-1&&this._processBuild(s,e,r,t)}return!1}_inputRename(e){return e}_outputRename(e){return e}_dumpPropertiesCode(){const e=this._codeVariableName;return`${e}.visibleInInspector = ${this.visibleInInspector};
${e}.visibleOnFrame = ${this.visibleOnFrame};
${e}.target = ${this.target};
`}_dumpCode(e,t){t.push(this);const i=this.name.replace(/[^A-Za-z_]+/g,"");if(this._codeVariableName=i||`${this.getClassName()}_${this.uniqueId}`,e.indexOf(this._codeVariableName)!==-1){let s=0;do s++,this._codeVariableName=i+s;while(e.indexOf(this._codeVariableName)!==-1)}e.push(this._codeVariableName);let r=`
// ${this.getClassName()}
`;this.comments&&(r+=`// ${this.comments}
`),r+=`var ${this._codeVariableName} = new BABYLON.${this.getClassName()}("${this.name}");
`,r+=this._dumpPropertiesCode();for(const s of this.inputs){if(!s.isConnected)continue;const o=s.connectedPoint.ownerBlock;t.indexOf(o)===-1&&(r+=o._dumpCode(e,t))}for(const s of this.outputs)if(s.hasEndpoints)for(const n of s.endpoints){const o=n.ownerBlock;o&&t.indexOf(o)===-1&&(r+=o._dumpCode(e,t))}return r}_dumpCodeForOutputConnections(e){let t="";if(e.indexOf(this)!==-1)return t;e.push(this);for(const i of this.inputs){if(!i.isConnected)continue;const r=i.connectedPoint,s=r.ownerBlock;t+=s._dumpCodeForOutputConnections(e),t+=`${s._codeVariableName}.${s._outputRename(r.name)}.connectTo(${this._codeVariableName}.${this._inputRename(i.name)});
`}return t}clone(e,t=""){const i=this.serialize(),r=oi(i.customType);if(r){const s=new r;return s._deserialize(i,e,t),s}return null}serialize(){const e={};e.customType="BABYLON."+this.getClassName(),e.id=this.uniqueId,e.name=this.name,e.comments=this.comments,e.visibleInInspector=this.visibleInInspector,e.visibleOnFrame=this.visibleOnFrame,e.target=this.target,e.inputs=[],e.outputs=[];for(const t of this.inputs)e.inputs.push(t.serialize());for(const t of this.outputs)e.outputs.push(t.serialize(!1));return e}_deserialize(e,t,i,r){this.name=e.name,this.comments=e.comments,this.visibleInInspector=!!e.visibleInInspector,this.visibleOnFrame=!!e.visibleOnFrame,this._target=e.target??this.target,this._deserializePortDisplayNamesAndExposedOnFrame(e)}_deserializePortDisplayNamesAndExposedOnFrame(e){const t=e.inputs,i=e.outputs;t&&t.forEach((r,s)=>{r.displayName&&(this.inputs[s].displayName=r.displayName),r.isExposedOnFrame&&(this.inputs[s].isExposedOnFrame=r.isExposedOnFrame,this.inputs[s].exposedPortPosition=r.exposedPortPosition)}),i&&i.forEach((r,s)=>{r.displayName&&(this.outputs[s].displayName=r.displayName),r.isExposedOnFrame&&(this.outputs[s].isExposedOnFrame=r.isExposedOnFrame,this.outputs[s].exposedPortPosition=r.exposedPortPosition)})}dispose(){this.onCodeIsReadyObservable.clear();for(const e of this.inputs)e.dispose();for(const e of this.outputs)e.dispose()}}class Jl extends le{get transformAsDirection(){return this.complementW===0}set transformAsDirection(e){this.complementW=e?0:1}constructor(e){super(e,A.Neutral),this.complementW=1,this.complementZ=0,this.target=A.Vertex,this.registerInput("vector",x.AutoDetect),this.registerInput("transform",x.Matrix),this.registerOutput("output",x.Vector4),this.registerOutput("xyz",x.Vector3),this._inputs[0].onConnectionObservable.add(t=>{if(t.ownerBlock.isInput){const i=t.ownerBlock;(i.name==="normal"||i.name==="tangent")&&(this.complementW=0)}})}getClassName(){return"TransformBlock"}get vector(){return this._inputs[0]}get output(){return this._outputs[0]}get xyz(){return this._outputs[1]}get transform(){return this._inputs[1]}_buildBlock(e){super._buildBlock(e);const t=this.vector,i=this.transform,r=e._getShaderType(x.Vector4),s=e._getShaderType(x.Vector3);if(t.connectedPoint){if(this.complementW===0||this.transformAsDirection){const n=`//${this.name}`;e._emitFunctionFromInclude("helperFunctions",n),e.sharedData.blocksWithDefines.push(this);const o=e._getFreeVariableName(`${i.associatedVariableName}_NUS`);switch(e.shaderLanguage===1?e.compilationString+=`var ${o}: mat3x3f = mat3x3f(${i.associatedVariableName}[0].xyz, ${i.associatedVariableName}[1].xyz, ${i.associatedVariableName}[2].xyz);
`:e.compilationString+=`mat3 ${o} = mat3(${i.associatedVariableName});
`,e.compilationString+=`#ifdef NONUNIFORMSCALING
`,e.compilationString+=`${o} = transposeMat3(inverseMat3(${o}));
`,e.compilationString+=`#endif
`,t.connectedPoint.type){case x.Vector2:e.compilationString+=e._declareOutput(this.output)+` = ${r}(${o} * ${s}(${t.associatedVariableName}, ${this._writeFloat(this.complementZ)}), ${this._writeFloat(this.complementW)});
`;break;case x.Vector3:case x.Color3:e.compilationString+=e._declareOutput(this.output)+` = ${r}(${o} * ${t.associatedVariableName}, ${this._writeFloat(this.complementW)});
`;break;default:e.compilationString+=e._declareOutput(this.output)+` = ${r}(${o} * ${t.associatedVariableName}.xyz, ${this._writeFloat(this.complementW)});
`;break}}else{const n=i.associatedVariableName;switch(t.connectedPoint.type){case x.Vector2:e.compilationString+=e._declareOutput(this.output)+` = ${n} * ${r}(${t.associatedVariableName}, ${this._writeFloat(this.complementZ)}, ${this._writeFloat(this.complementW)});
`;break;case x.Vector3:case x.Color3:e.compilationString+=e._declareOutput(this.output)+` = ${n} * ${r}(${t.associatedVariableName}, ${this._writeFloat(this.complementW)});
`;break;default:e.compilationString+=e._declareOutput(this.output)+` = ${n} * ${t.associatedVariableName};
`;break}}this.xyz.hasEndpoints&&(e.compilationString+=e._declareOutput(this.xyz)+` = ${this.output.associatedVariableName}.xyz;
`)}return this}prepareDefines(e,t,i){e.nonUniformScaling&&i.setValue("NONUNIFORMSCALING",!0)}serialize(){const e=super.serialize();return e.complementZ=this.complementZ,e.complementW=this.complementW,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.complementZ=e.complementZ!==void 0?e.complementZ:0,this.complementW=e.complementW!==void 0?e.complementW:1}_dumpPropertiesCode(){let e=super._dumpPropertiesCode()+`${this._codeVariableName}.complementZ = ${this.complementZ};
`;return e+=`${this._codeVariableName}.complementW = ${this.complementW};
`,e}}C([U("Transform as direction",0,void 0,{embedded:!0})],Jl.prototype,"transformAsDirection",null);B("BABYLON.TransformBlock",Jl);class kl extends le{constructor(e){super(e,A.Vertex,!0),this.registerInput("vector",x.Vector4)}getClassName(){return"VertexOutputBlock"}get vector(){return this._inputs[0]}_isLogarithmicDepthEnabled(e,t){if(t)return!0;for(const i of e)if(i.useLogarithmicDepth)return!0;return!1}_buildBlock(e){super._buildBlock(e);const t=this.vector,i=e.shaderLanguage===1;if(e.shaderLanguage===1?e.compilationString+=`vertexOutputs.position = ${t.associatedVariableName};
`:e.compilationString+=`gl_Position = ${t.associatedVariableName};
`,this._isLogarithmicDepthEnabled(e.sharedData.fragmentOutputNodes,e.sharedData.nodeMaterial.useLogarithmicDepth)){e._emitUniformFromString("logarithmicDepthConstant",x.Float),e._emitVaryingFromString("vFragmentDepth",x.Float);const r=i?"vertexOutputs.vFragmentDepth":"vFragmentDepth",s=i?"uniforms.":"",n=i?"vertexOutputs.position":"gl_Position";e.compilationString+=`${r} = 1.0 + ${n}.w;
`,e.compilationString+=`${n}.z = log2(max(0.000001, ${r})) * ${s}logarithmicDepthConstant;
`}return this}}B("BABYLON.VertexOutputBlock",kl);var Qr;(function(a){a[a.NoColorSpace=0]="NoColorSpace",a[a.Gamma=1]="Gamma",a[a.Linear=2]="Linear"})(Qr||(Qr={}));class On extends le{constructor(e){super(e,A.Fragment,!0,!0),this.convertToGammaSpace=!1,this.convertToLinearSpace=!1,this.useLogarithmicDepth=!1,this.registerInput("rgba",x.Color4,!0),this.registerInput("rgb",x.Color3,!0),this.registerInput("a",x.Float,!0),this.registerInput("glow",x.Color3,!0),this.rgb.acceptedConnectionPointTypes.push(x.Vector3),this.rgb.acceptedConnectionPointTypes.push(x.Float),this.additionalColor.acceptedConnectionPointTypes.push(x.Vector3),this.additionalColor.acceptedConnectionPointTypes.push(x.Float)}get colorSpace(){return this.convertToGammaSpace?Qr.Gamma:this.convertToLinearSpace?Qr.Linear:Qr.NoColorSpace}set colorSpace(e){this.convertToGammaSpace=e===Qr.Gamma,this.convertToLinearSpace=e===Qr.Linear}getClassName(){return"FragmentOutputBlock"}initialize(e){e._excludeVariableName("logarithmicDepthConstant"),e._excludeVariableName("vFragmentDepth")}get rgba(){return this._inputs[0]}get rgb(){return this._inputs[1]}get a(){return this._inputs[2]}get additionalColor(){return this._inputs[3]}prepareDefines(e,t,i){i.setValue(this._linearDefineName,this.convertToLinearSpace,!0),i.setValue(this._gammaDefineName,this.convertToGammaSpace,!0),i.setValue(this._additionalColorDefineName,this.additionalColor.connectedPoint&&t._useAdditionalColor,!0)}bind(e,t,i){(this.useLogarithmicDepth||t.useLogarithmicDepth)&&i&&qa(void 0,e,i.getScene())}_buildBlock(e){super._buildBlock(e);const t=this.rgba,i=this.rgb,r=this.a,s=this.additionalColor,n=e.shaderLanguage===1;e.sharedData.hints.needAlphaBlending=t.isConnected||r.isConnected,e.sharedData.blocksWithDefines.push(this),(this.useLogarithmicDepth||e.sharedData.nodeMaterial.useLogarithmicDepth)&&(e._emitUniformFromString("logarithmicDepthConstant",x.Float),e._emitVaryingFromString("vFragmentDepth",x.Float),e.sharedData.bindableBlocks.push(this)),s.connectedPoint&&(e._excludeVariableName("useAdditionalColor"),e._emitUniformFromString("useAdditionalColor",x.Float),this._additionalColorDefineName=e._getFreeDefineName("USEADDITIONALCOLOR")),this._linearDefineName=e._getFreeDefineName("CONVERTTOLINEAR"),this._gammaDefineName=e._getFreeDefineName("CONVERTTOGAMMA");const o=`//${this.name}`;e._emitFunctionFromInclude("helperFunctions",o);let l="gl_FragColor";e.shaderLanguage===1&&(e.compilationString+=`var fragmentOutputsColor : vec4<f32>;\r
`,l="fragmentOutputsColor");const u=e._getShaderType(x.Vector4);if(s.connectedPoint){let c="1.0";r.connectedPoint&&(c=r.associatedVariableName),e.compilationString+=`#ifdef ${this._additionalColorDefineName}
`,s.connectedPoint.type===x.Float?e.compilationString+=`${l}  = ${u}(${s.associatedVariableName}, ${s.associatedVariableName}, ${s.associatedVariableName}, ${c});
`:e.compilationString+=`${l}  = ${u}(${s.associatedVariableName}, ${c});
`,e.compilationString+=`#else
`}if(t.connectedPoint)r.isConnected?e.compilationString+=`${l} = ${u}(${t.associatedVariableName}.rgb, ${r.associatedVariableName});
`:e.compilationString+=`${l}  = ${t.associatedVariableName};
`;else if(i.connectedPoint){let c="1.0";r.connectedPoint&&(c=r.associatedVariableName),i.connectedPoint.type===x.Float?e.compilationString+=`${l}  = ${u}(${i.associatedVariableName}, ${i.associatedVariableName}, ${i.associatedVariableName}, ${c});
`:e.compilationString+=`${l}  = ${u}(${i.associatedVariableName}, ${c});
`}else e.sharedData.checks.notConnectedNonOptionalInputs.push(t);if(s.connectedPoint&&(e.compilationString+=`#endif
`),e.compilationString+=`#ifdef ${this._linearDefineName}
`,e.compilationString+=`${l}  = toLinearSpace(${l});
`,e.compilationString+=`#endif
`,e.compilationString+=`#ifdef ${this._gammaDefineName}
`,e.compilationString+=`${l}  = toGammaSpace(${l});
`,e.compilationString+=`#endif
`,e.shaderLanguage===1&&(e.compilationString+=`#if !defined(PREPASS)\r
`,e.compilationString+=`fragmentOutputs.color = fragmentOutputsColor;\r
`,e.compilationString+=`#endif\r
`),this.useLogarithmicDepth||e.sharedData.nodeMaterial.useLogarithmicDepth){const c=n?"input.vFragmentDepth":"vFragmentDepth",h=n?"uniforms.":"",d=n?"fragmentOutputs.fragDepth":"gl_FragDepthEXT";e.compilationString+=`${d} = log2(${c}) * ${h}logarithmicDepthConstant * 0.5;
`}return e.compilationString+=`#if defined(PREPASS)\r
`,e.compilationString+=`${n?"fragmentOutputs.fragData0":"gl_FragData[0]"} = ${l};\r
`,e.compilationString+=`#endif\r
`,this}_dumpPropertiesCode(){let e=super._dumpPropertiesCode();return e+=`${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};
`,e+=`${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};
`,e+=`${this._codeVariableName}.useLogarithmicDepth = ${this.useLogarithmicDepth};
`,e}serialize(){const e=super.serialize();return e.convertToGammaSpace=this.convertToGammaSpace,e.convertToLinearSpace=this.convertToLinearSpace,e.useLogarithmicDepth=this.useLogarithmicDepth,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.convertToGammaSpace=!!e.convertToGammaSpace,this.convertToLinearSpace=!!e.convertToLinearSpace,this.useLogarithmicDepth=e.useLogarithmicDepth??!1}}C([U("Use logarithmic depth",0,"PROPERTIES",{embedded:!0})],On.prototype,"useLogarithmicDepth",void 0);C([U("Color space",4,"ADVANCED",{notifiers:{rebuild:!0},embedded:!0,options:[{label:"No color space",value:Qr.NoColorSpace},{label:"Gamma",value:Qr.Gamma},{label:"Linear",value:Qr.Linear}]})],On.prototype,"colorSpace",null);B("BABYLON.FragmentOutputBlock",On);var De;(function(a){a[a.World=1]="World",a[a.View=2]="View",a[a.Projection=3]="Projection",a[a.ViewProjection=4]="ViewProjection",a[a.WorldView=5]="WorldView",a[a.WorldViewProjection=6]="WorldViewProjection",a[a.CameraPosition=7]="CameraPosition",a[a.FogColor=8]="FogColor",a[a.DeltaTime=9]="DeltaTime",a[a.CameraParameters=10]="CameraParameters",a[a.MaterialAlpha=11]="MaterialAlpha"})(De||(De={}));var ys;(function(a){a[a.None=0]="None",a[a.Time=1]="Time",a[a.RealTime=2]="RealTime",a[a.MouseInfo=3]="MouseInfo"})(ys||(ys={}));const Jw={position2d:"position",particle_uv:"vUV",particle_color:"vColor",particle_texturemask:"textureMask",particle_positionw:"vPositionW"},Bc={particle_uv:!0,particle_color:!0,particle_texturemask:!0,particle_positionw:!0},dS={particle_texturemask:!0},fS={normal:"NORMAL",tangent:"TANGENT",uv:"UV1",uv2:"UV2",uv3:"UV3",uv4:"UV4",uv5:"UV5",uv6:"UV6",uv7:"UV7",uv8:"UV8"};class Ee extends le{get type(){if(this._type===x.AutoDetect){if(this.isUniform&&this.value!=null){if(!isNaN(this.value))return this._type=x.Float,this._type;switch(this.value.getClassName()){case"Vector2":return this._type=x.Vector2,this._type;case"Vector3":return this._type=x.Vector3,this._type;case"Vector4":return this._type=x.Vector4,this._type;case"Color3":return this._type=x.Color3,this._type;case"Color4":return this._type=x.Color4,this._type;case"Matrix":return this._type=x.Matrix,this._type}}if(this.isAttribute)switch(this.name){case"splatIndex":return this._type=x.Float,this._type;case"position":case"normal":case"particle_positionw":case"splatPosition":return this._type=x.Vector3,this._type;case"uv":case"uv2":case"uv3":case"uv4":case"uv5":case"uv6":case"position2d":case"particle_uv":case"splatScale":return this._type=x.Vector2,this._type;case"matricesIndices":case"matricesWeights":case"matricesIndicesExtra":case"matricesWeightsExtra":case"world0":case"world1":case"world2":case"world3":case"tangent":return this._type=x.Vector4,this._type;case"color":case"instanceColor":case"particle_color":case"particle_texturemask":case"splatColor":return this._type=x.Color4,this._type}if(this.isSystemValue)switch(this._systemValue){case De.World:case De.WorldView:case De.WorldViewProjection:case De.View:case De.ViewProjection:case De.Projection:return this._type=x.Matrix,this._type;case De.CameraPosition:return this._type=x.Vector3,this._type;case De.FogColor:return this._type=x.Color3,this._type;case De.DeltaTime:case De.MaterialAlpha:return this._type=x.Float,this._type;case De.CameraParameters:return this._type=x.Vector4,this._type}}return this._type}constructor(e,t=A.Vertex,i=x.AutoDetect){super(e,t,!1),this._mode=3,this._animationType=ys.None,this._prefix="",this.min=0,this.max=0,this.isBoolean=!1,this.matrixMode=0,this._systemValue=null,this.isConstant=!1,this.groupInInspector="",this.onValueChangedObservable=new j,this.convertToGammaSpace=!1,this.convertToLinearSpace=!1,this._type=i,this.setDefaultValue(),this.registerOutput("output",i)}validateBlockName(e){return this.isAttribute?!0:super.validateBlockName(e)}get output(){return this._outputs[0]}setAsAttribute(e){return this._mode=1,e&&(this.name=e),this}setAsSystemValue(e){return this.systemValue=e,this}get value(){return this._storedValue}set value(e){this.type===x.Float&&(this.isBoolean?e=e?1:0:this.min!==this.max&&(e=Math.max(this.min,e),e=Math.min(this.max,e))),this._storedValue=e,this._mode=0,this.onValueChangedObservable.notifyObservers(this)}get valueCallback(){return this._valueCallback}set valueCallback(e){this._valueCallback=e,this._mode=0}get declarationVariableName(){return this._associatedVariableName}get associatedVariableName(){return this._prefix+this._associatedVariableName}set associatedVariableName(e){this._associatedVariableName=e}get animationType(){return this._animationType}set animationType(e){this._animationType=e}get isUndefined(){return this._mode===3}get isUniform(){return this._mode===0}set isUniform(e){this._mode=e?0:3,this.associatedVariableName=""}get isAttribute(){return this._mode===1}set isAttribute(e){this._mode=e?1:3,this.associatedVariableName=""}get isVarying(){return this._mode===2}set isVarying(e){this._mode=e?2:3,this.associatedVariableName=""}get isSystemValue(){return this._systemValue!=null}get systemValue(){return this._systemValue}set systemValue(e){this._mode=0,this.associatedVariableName="",this._systemValue=e}getClassName(){return"InputBlock"}animate(e){switch(this._animationType){case ys.Time:{this.type===x.Float&&(this.value+=e.getAnimationRatio()*.01);break}case ys.RealTime:{this.type===x.Float&&(this.value=(Li.Now-e.getEngine().startTime)/1e3);break}case ys.MouseInfo:{if(this.type===x.Vector4){const t=e._inputManager._originMouseEvent;if(t){const i=t.offsetX,r=t.offsetY,s=t.buttons&1?1:0,n=t.buttons&2?1:0;this.value=new Ve(i,r,s,n)}else this.value=new Ve(0,0,0,0)}break}}}_emitDefine(e){return e[0]==="!"?`#ifndef ${e.substring(1)}
`:`#ifdef ${e}
`}initialize(){this.associatedVariableName=""}setDefaultValue(){switch(this.type){case x.Float:this.value=0;break;case x.Vector2:this.value=Q.Zero();break;case x.Vector3:this.value=m.Zero();break;case x.Vector4:this.value=Ve.Zero();break;case x.Color3:this.value=ne.White();break;case x.Color4:this.value=new xe(1,1,1,1);break;case x.Matrix:this.value=$.Identity();break}}_emitConstant(e){switch(this.type){case x.Float:return`${e._emitFloat(this.value)}`;case x.Vector2:return`vec2(${this.value.x}, ${this.value.y})`;case x.Vector3:return`vec3(${this.value.x}, ${this.value.y}, ${this.value.z})`;case x.Vector4:return`vec4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;case x.Color3:return _t.Color3[0].set(this.value.r,this.value.g,this.value.b),this.convertToGammaSpace&&_t.Color3[0].toGammaSpaceToRef(_t.Color3[0],e.sharedData.scene.getEngine().useExactSrgbConversions),this.convertToLinearSpace&&_t.Color3[0].toLinearSpaceToRef(_t.Color3[0],e.sharedData.scene.getEngine().useExactSrgbConversions),`vec3(${_t.Color3[0].r}, ${_t.Color3[0].g}, ${_t.Color3[0].b})`;case x.Color4:return _t.Color4[0].set(this.value.r,this.value.g,this.value.b,this.value.a),this.convertToGammaSpace&&_t.Color4[0].toGammaSpaceToRef(_t.Color4[0],e.sharedData.scene.getEngine().useExactSrgbConversions),this.convertToLinearSpace&&_t.Color4[0].toLinearSpaceToRef(_t.Color4[0],e.sharedData.scene.getEngine().useExactSrgbConversions),`vec4(${_t.Color4[0].r}, ${_t.Color4[0].g}, ${_t.Color4[0].b}, ${_t.Color4[0].a})`}return""}get _noContextSwitch(){return Bc[this.name]}_emit(e,t){if(this.isUniform){if(this._associatedVariableName||(this._associatedVariableName=e._getFreeVariableName("u_"+this.name)),this.isConstant){if(e.constants.indexOf(this.associatedVariableName)!==-1)return;e.constants.push(this.associatedVariableName),e._constantDeclaration+=e._declareOutput(this.output,!0)+` = ${this._emitConstant(e)};
`;return}if(e.uniforms.indexOf(this.associatedVariableName)!==-1)return;e.uniforms.push(this.associatedVariableName),t&&(e._uniformDeclaration+=this._emitDefine(t));const i=e._getShaderType(this.type);e.shaderLanguage===1?(e._uniformDeclaration+=`uniform ${this._associatedVariableName}: ${i};
`,this._prefix="uniforms."):e._uniformDeclaration+=`uniform ${i} ${this.associatedVariableName};
`,t&&(e._uniformDeclaration+=`#endif
`);const r=e.sharedData.hints;if(this._systemValue!==null&&this._systemValue!==void 0)switch(this._systemValue){case De.WorldView:r.needWorldViewMatrix=!0;break;case De.WorldViewProjection:r.needWorldViewProjectionMatrix=!0;break}else this._animationType!==ys.None&&e.sharedData.animatedInputs.push(this);return}if(this.isAttribute){if(this.associatedVariableName=Jw[this.name]??this.name,this.target===A.Vertex&&e._vertexState){Bc[this.name]?dS[this.name]?(e._emitUniformFromString(this.declarationVariableName,this.type,t),e.shaderLanguage===1&&(this._prefix="vertexInputs.")):e._emitVaryingFromString(this.declarationVariableName,this.type,t):this._emit(e._vertexState,t);return}const i=e.attributes.indexOf(this.declarationVariableName)!==-1;if(i||e.attributes.push(this.declarationVariableName),Bc[this.name])dS[this.name]?(i||e._emitUniformFromString(this.declarationVariableName,this.type,t),e.shaderLanguage===1&&(this._prefix="uniforms.")):(i||e._emitVaryingFromString(this.declarationVariableName,this.type,t),e.shaderLanguage===1&&(this._prefix="fragmentInputs."));else{if(t&&!i&&(e._attributeDeclaration+=this._emitDefine(t)),e.shaderLanguage===1){if(!i){const r=fS[this.name];r?(e._attributeDeclaration+=`#ifdef ${r}
`,e._attributeDeclaration+=`attribute ${this.declarationVariableName}: ${e._getShaderType(this.type)};
`,e._attributeDeclaration+=`#else
`,e._attributeDeclaration+=`var<private> ${this.declarationVariableName}: ${e._getShaderType(this.type)} = ${e._getShaderType(this.type)}(0.);
`,e._attributeDeclaration+=`#endif
`):e._attributeDeclaration+=`attribute ${this.declarationVariableName}: ${e._getShaderType(this.type)};
`}this._prefix="vertexInputs."}else if(!i){const r=fS[this.name];r?(e._attributeDeclaration+=`#ifdef ${r}
`,e._attributeDeclaration+=`attribute ${e._getShaderType(this.type)} ${this.declarationVariableName};
`,e._attributeDeclaration+=`#else
`,e._attributeDeclaration+=`${e._getShaderType(this.type)} ${this.declarationVariableName} = ${e._getShaderType(this.type)}(0.);
`,e._attributeDeclaration+=`#endif
`):e._attributeDeclaration+=`attribute ${e._getShaderType(this.type)} ${this.declarationVariableName};
`}t&&!i&&(e._attributeDeclaration+=`#endif
`)}}}_transmitWorld(e,t,i,r){if(!this._systemValue)return;const s=this._associatedVariableName;switch(this._systemValue){case De.World:e.setMatrix(s,t);break;case De.WorldView:e.setMatrix(s,i);break;case De.WorldViewProjection:e.setMatrix(s,r);break}}_transmit(e,t,i){if(this.isAttribute)return;const r=this._associatedVariableName;if(this._systemValue){switch(this._systemValue){case De.World:case De.WorldView:case De.WorldViewProjection:return;case De.View:e.setMatrix(r,t.getViewMatrix());break;case De.Projection:e.setMatrix(r,t.getProjectionMatrix());break;case De.ViewProjection:e.setMatrix(r,t.getTransformMatrix());break;case De.CameraPosition:t.bindEyePosition(e,r,!0);break;case De.FogColor:e.setColor3(r,t.fogColor);break;case De.DeltaTime:e.setFloat(r,t.deltaTime/1e3);break;case De.CameraParameters:t.activeCamera&&e.setFloat4(r,t.getEngine().hasOriginBottomLeft?-1:1,t.activeCamera.minZ,t.activeCamera.maxZ,1/t.activeCamera.maxZ);break;case De.MaterialAlpha:e.setFloat(r,i.alpha);break}return}const s=this._valueCallback?this._valueCallback():this._storedValue;if(s!==null)switch(this.type){case x.Float:e.setFloat(r,s);break;case x.Int:e.setInt(r,s);break;case x.Color3:_t.Color3[0].set(this.value.r,this.value.g,this.value.b),this.convertToGammaSpace&&_t.Color3[0].toGammaSpaceToRef(_t.Color3[0],t.getEngine().useExactSrgbConversions),this.convertToLinearSpace&&_t.Color3[0].toLinearSpaceToRef(_t.Color3[0],t.getEngine().useExactSrgbConversions),e.setColor3(r,_t.Color3[0]);break;case x.Color4:_t.Color4[0].set(this.value.r,this.value.g,this.value.b,this.value.a),this.convertToGammaSpace&&_t.Color4[0].toGammaSpaceToRef(_t.Color4[0],t.getEngine().useExactSrgbConversions),this.convertToLinearSpace&&_t.Color4[0].toLinearSpaceToRef(_t.Color4[0],t.getEngine().useExactSrgbConversions),e.setDirectColor4(r,_t.Color4[0]);break;case x.Vector2:e.setVector2(r,s);break;case x.Vector3:e.setVector3(r,s);break;case x.Vector4:e.setVector4(r,s);break;case x.Matrix:e.setMatrix(r,s);break}}_buildBlock(e){super._buildBlock(e),(this.isUniform||this.isSystemValue)&&e.sharedData.inputBlocks.push(this),this._emit(e)}_dumpPropertiesCode(){const e=this._codeVariableName;if(this.isAttribute)return super._dumpPropertiesCode()+`${e}.setAsAttribute("${this.name}");
`;if(this.isSystemValue)return super._dumpPropertiesCode()+`${e}.setAsSystemValue(BABYLON.NodeMaterialSystemValues.${De[this._systemValue]});
`;if(this.isUniform){const t=[];let i="";switch(this.type){case x.Float:i=`${this.value}`;break;case x.Vector2:i=`new BABYLON.Vector2(${this.value.x}, ${this.value.y})`;break;case x.Vector3:i=`new BABYLON.Vector3(${this.value.x}, ${this.value.y}, ${this.value.z})`;break;case x.Vector4:i=`new BABYLON.Vector4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;break;case x.Color3:i=`new BABYLON.Color3(${this.value.r}, ${this.value.g}, ${this.value.b})`,this.convertToGammaSpace&&(i+=".toGammaSpace()"),this.convertToLinearSpace&&(i+=".toLinearSpace()");break;case x.Color4:i=`new BABYLON.Color4(${this.value.r}, ${this.value.g}, ${this.value.b}, ${this.value.a})`,this.convertToGammaSpace&&(i+=".toGammaSpace()"),this.convertToLinearSpace&&(i+=".toLinearSpace()");break;case x.Matrix:i=`BABYLON.Matrix.FromArray([${this.value.m}])`;break}return t.push(`${e}.value = ${i}`),this.type===x.Float&&t.push(`${e}.min = ${this.min}`,`${e}.max = ${this.max}`,`${e}.isBoolean = ${this.isBoolean}`,`${e}.matrixMode = ${this.matrixMode}`,`${e}.animationType = BABYLON.AnimatedInputBlockTypes.${ys[this.animationType]}`),t.push(`${e}.isConstant = ${this.isConstant}`),t.push(""),super._dumpPropertiesCode()+t.join(`;
`)}return super._dumpPropertiesCode()}dispose(){this.onValueChangedObservable.clear(),super.dispose()}serialize(){const e=super.serialize();return e.type=this.type,e.mode=this._mode,e.systemValue=this._systemValue,e.animationType=this._animationType,e.min=this.min,e.max=this.max,e.isBoolean=this.isBoolean,e.matrixMode=this.matrixMode,e.isConstant=this.isConstant,e.groupInInspector=this.groupInInspector,e.convertToGammaSpace=this.convertToGammaSpace,e.convertToLinearSpace=this.convertToLinearSpace,this._storedValue!=null&&this._mode===0&&(this._storedValue.asArray?(e.valueType="BABYLON."+this._storedValue.getClassName(),e.value=this._storedValue.asArray()):(e.valueType="number",e.value=this._storedValue)),e}_deserialize(e,t,i){if(this._mode=e.mode,super._deserialize(e,t,i),this._type=e.type,this._systemValue=e.systemValue||e.wellKnownValue,this._animationType=e.animationType,this.min=e.min||0,this.max=e.max||0,this.isBoolean=!!e.isBoolean,this.matrixMode=e.matrixMode||0,this.isConstant=!!e.isConstant,this.groupInInspector=e.groupInInspector||"",this.convertToGammaSpace=!!e.convertToGammaSpace,this.convertToLinearSpace=!!e.convertToLinearSpace,e.name==="tangent"&&e.mode===1&&e.type===x.Vector3&&(this._type=x.Vector4),!!e.valueType)if(e.valueType==="number")this._storedValue=e.value;else{const r=oi(e.valueType);r&&(this._storedValue=r.FromArray(e.value))}}}B("BABYLON.InputBlock",Ee);class $0 extends le{constructor(e){super(e,A.VertexAndFragment),this._samplerName="textureSampler",this.convertToGammaSpace=!1,this.convertToLinearSpace=!1,this._isUnique=!1,this.registerInput("uv",x.AutoDetect,!1,A.VertexAndFragment),this.registerOutput("rgba",x.Color4,A.Neutral),this.registerOutput("rgb",x.Color3,A.Neutral),this.registerOutput("r",x.Float,A.Neutral),this.registerOutput("g",x.Float,A.Neutral),this.registerOutput("b",x.Float,A.Neutral),this.registerOutput("a",x.Float,A.Neutral),this._inputs[0].addExcludedConnectionPointFromAllowedTypes(x.Vector2|x.Vector3|x.Vector4),this._inputs[0]._prioritizeVertex=!1}getClassName(){return"CurrentScreenBlock"}get uv(){return this._inputs[0]}get rgba(){return this._outputs[0]}get rgb(){return this._outputs[1]}get r(){return this._outputs[2]}get g(){return this._outputs[3]}get b(){return this._outputs[4]}get a(){return this._outputs[5]}initialize(e){e._excludeVariableName(this._samplerName)}get target(){return!this.uv.isConnected||this.uv.sourceBlock.isInput?A.VertexAndFragment:A.Fragment}prepareDefines(e,t,i){i.setValue(this._linearDefineName,this.convertToGammaSpace,!0),i.setValue(this._gammaDefineName,this.convertToLinearSpace,!0)}isReady(){return!(this.texture&&!this.texture.isReadyOrNotBlocking())}_injectVertexCode(e){const t=this.uv;if(t.connectedPoint.ownerBlock.isInput&&(t.connectedPoint.ownerBlock.isAttribute||e._emitUniformFromString(t.associatedVariableName,x.Vector2)),this._mainUVName="vMain"+t.associatedVariableName,e._emitVaryingFromString(this._mainUVName,x.Vector2),e.compilationString+=`${this._mainUVName} = ${t.associatedVariableName}.xy;
`,!!this._outputs.some(i=>i.isConnectedInVertexShader)){this._writeTextureRead(e,!0);for(const i of this._outputs)i.hasEndpoints&&this._writeOutput(e,i,i.name,!0)}}_writeTextureRead(e,t=!1){const i=this.uv;if(t){if(e.target===A.Fragment)return;const s=e.shaderLanguage===0?`texture2D(${this._samplerName},`:`textureSampleLevel(${this._samplerName}, ${this._samplerName+"Sampler"},`,n=e.shaderLanguage===0?"":", 0";e.compilationString+=`${e._declareLocalVar(this._tempTextureRead,x.Vector4)} = ${s} ${i.associatedVariableName}${n});
`;return}const r=e.shaderLanguage===0?`texture2D(${this._samplerName},`:`textureSample(${this._samplerName}, ${this._samplerName+"Sampler"},`;if(this.uv.ownerBlock.target===A.Fragment){e.compilationString+=`${e._declareLocalVar(this._tempTextureRead,x.Vector4)} = ${r} ${i.associatedVariableName});
`;return}e.compilationString+=`${e._declareLocalVar(this._tempTextureRead,x.Vector4)} = ${r} ${this._mainUVName});
`}_writeOutput(e,t,i,r=!1){if(r){if(e.target===A.Fragment)return;e.compilationString+=`${e._declareOutput(t)} = ${this._tempTextureRead}.${i};
`;return}if(this.uv.ownerBlock.target===A.Fragment){e.compilationString+=`${e._declareOutput(t)} = ${this._tempTextureRead}.${i};
`;return}e.compilationString+=`${e._declareOutput(t)} = ${this._tempTextureRead}.${i};
`,e.compilationString+=`#ifdef ${this._linearDefineName}
`,e.compilationString+=`${t.associatedVariableName} = toGammaSpace(${t.associatedVariableName});
`,e.compilationString+=`#endif
`,e.compilationString+=`#ifdef ${this._gammaDefineName}
`,e.compilationString+=`${t.associatedVariableName} = toLinearSpace(${t.associatedVariableName});
`,e.compilationString+=`#endif
`}_buildBlock(e){if(super._buildBlock(e),this._tempTextureRead=e._getFreeVariableName("tempTextureRead"),e.sharedData.blockingBlocks.indexOf(this)<0&&e.sharedData.blockingBlocks.push(this),e.sharedData.textureBlocks.indexOf(this)<0&&e.sharedData.textureBlocks.push(this),e.sharedData.blocksWithDefines.indexOf(this)<0&&e.sharedData.blocksWithDefines.push(this),e.target!==A.Fragment){e._emit2DSampler(this._samplerName),this._injectVertexCode(e);return}if(!this._outputs.some(i=>i.isConnectedInFragmentShader))return;e._emit2DSampler(this._samplerName),this._linearDefineName=e._getFreeDefineName("ISLINEAR"),this._gammaDefineName=e._getFreeDefineName("ISGAMMA");const t=`//${this.name}`;e._emitFunctionFromInclude("helperFunctions",t),this._writeTextureRead(e);for(const i of this._outputs)i.hasEndpoints&&this._writeOutput(e,i,i.name);return this}serialize(){const e=super.serialize();return e.convertToGammaSpace=this.convertToGammaSpace,e.convertToLinearSpace=this.convertToLinearSpace,this.texture&&!this.texture.isRenderTarget&&(e.texture=this.texture.serialize()),e}_deserialize(e,t,i){super._deserialize(e,t,i),this.convertToGammaSpace=e.convertToGammaSpace,this.convertToLinearSpace=!!e.convertToLinearSpace,e.texture&&(i=e.texture.url.indexOf("data:")===0?"":i,this.texture=Y.Parse(e.texture,t,i))}}B("BABYLON.CurrentScreenBlock",$0);class H0 extends le{constructor(e){super(e,A.Fragment),this._samplerName="diffuseSampler",this.convertToGammaSpace=!1,this.convertToLinearSpace=!1,this._isUnique=!1,this.registerInput("uv",x.AutoDetect,!1,A.VertexAndFragment),this.registerOutput("rgba",x.Color4,A.Neutral),this.registerOutput("rgb",x.Color3,A.Neutral),this.registerOutput("r",x.Float,A.Neutral),this.registerOutput("g",x.Float,A.Neutral),this.registerOutput("b",x.Float,A.Neutral),this.registerOutput("a",x.Float,A.Neutral),this._inputs[0].addExcludedConnectionPointFromAllowedTypes(x.Vector2|x.Vector3|x.Vector4)}getClassName(){return"ParticleTextureBlock"}get uv(){return this._inputs[0]}get rgba(){return this._outputs[0]}get rgb(){return this._outputs[1]}get r(){return this._outputs[2]}get g(){return this._outputs[3]}get b(){return this._outputs[4]}get a(){return this._outputs[5]}initialize(e){e._excludeVariableName("diffuseSampler")}autoConfigure(e,t=()=>!0){if(!this.uv.isConnected){let i=e.getInputBlockByPredicate(r=>r.isAttribute&&r.name==="particle_uv"&&t(r));i||(i=new Ee("uv"),i.setAsAttribute("particle_uv")),i.output.connectTo(this.uv)}}prepareDefines(e,t,i){i.setValue(this._linearDefineName,this.convertToGammaSpace,!0),i.setValue(this._gammaDefineName,this.convertToLinearSpace,!0)}isReady(){return!(this.texture&&!this.texture.isReadyOrNotBlocking())}_writeOutput(e,t,i){e.compilationString+=`${e._declareOutput(t)} = ${this._tempTextureRead}.${i};
`,e.compilationString+=`#ifdef ${this._linearDefineName}
`,e.compilationString+=`${t.associatedVariableName} = toGammaSpace(${t.associatedVariableName});
`,e.compilationString+=`#endif
`,e.compilationString+=`#ifdef ${this._gammaDefineName}
`,e.compilationString+=`${t.associatedVariableName} = toLinearSpace(${t.associatedVariableName});
`,e.compilationString+=`#endif
`}_buildBlock(e){if(super._buildBlock(e),e.target===A.Vertex)return;this._tempTextureRead=e._getFreeVariableName("tempTextureRead"),e._emit2DSampler(this._samplerName),e.sharedData.blockingBlocks.push(this),e.sharedData.textureBlocks.push(this),e.sharedData.blocksWithDefines.push(this),this._linearDefineName=e._getFreeDefineName("ISLINEAR"),this._gammaDefineName=e._getFreeDefineName("ISGAMMA");const t=`//${this.name}`;e._emitFunctionFromInclude("helperFunctions",t),e.compilationString+=`${e._declareLocalVar(this._tempTextureRead,x.Vector4)} = ${e._generateTextureSample(this.uv.associatedVariableName,this._samplerName)};
`;for(const i of this._outputs)i.hasEndpoints&&this._writeOutput(e,i,i.name);return this}serialize(){const e=super.serialize();return e.convertToGammaSpace=this.convertToGammaSpace,e.convertToLinearSpace=this.convertToLinearSpace,this.texture&&!this.texture.isRenderTarget&&(e.texture=this.texture.serialize()),e}_deserialize(e,t,i){super._deserialize(e,t,i),this.convertToGammaSpace=e.convertToGammaSpace,this.convertToLinearSpace=!!e.convertToLinearSpace,e.texture&&(i=e.texture.url.indexOf("data:")===0?"":i,this.texture=Y.Parse(e.texture,t,i))}}B("BABYLON.ParticleTextureBlock",H0);class j0 extends le{constructor(e){super(e,A.Fragment),this._isUnique=!0,this.registerInput("color",x.Color4,!1,A.Fragment),this.registerOutput("rampColor",x.Color4,A.Fragment)}getClassName(){return"ParticleRampGradientBlock"}get color(){return this._inputs[0]}get rampColor(){return this._outputs[0]}initialize(e){e._excludeVariableName("remapRanges"),e._excludeVariableName("rampSampler"),e._excludeVariableName("baseColor"),e._excludeVariableName("alpha"),e._excludeVariableName("remappedColorIndex"),e._excludeVariableName("rampColor")}_buildBlock(e){if(super._buildBlock(e),e.target===A.Vertex)return;e._emit2DSampler("rampSampler","RAMPGRADIENT"),e._emitVaryingFromString("remapRanges",x.Vector4,"RAMPGRADIENT");const t=e.shaderLanguage===0?"":"fragmentInputs.";return e.compilationString+=`
            #ifdef RAMPGRADIENT
                ${e._declareLocalVar("baseColor",x.Vector4)} = ${this.color.associatedVariableName};
                ${e._declareLocalVar("alpha",x.Float)} = ${this.color.associatedVariableName}.a;

                ${e._declareLocalVar("remappedColorIndex",x.Float)} = clamp((alpha - ${t}remapRanges.x) / ${t}remapRanges.y, 0.0, 1.0);

                ${e._declareLocalVar("rampColor",x.Vector4)} = ${e._generateTextureSample("vec2(1.0 - remappedColorIndex, 0.)","rampSampler")};

                // Remapped alpha
                ${e._declareOutput(this.rampColor)} = vec4${e.fSuffix}(baseColor.rgb * rampColor.rgb, clamp((alpha * rampColor.a - ${t}remapRanges.z) / ${t}remapRanges.w, 0.0, 1.0));
            #else
                ${e._declareOutput(this.rampColor)} = ${this.color.associatedVariableName};
            #endif
        `,this}}B("BABYLON.ParticleRampGradientBlock",j0);class Y0 extends le{constructor(e){super(e,A.Fragment),this._isUnique=!0,this.registerInput("color",x.Color4,!1,A.Fragment),this.registerInput("alphaTexture",x.Float,!1,A.Fragment),this.registerInput("alphaColor",x.Float,!1,A.Fragment),this.registerOutput("blendColor",x.Color4,A.Fragment)}getClassName(){return"ParticleBlendMultiplyBlock"}get color(){return this._inputs[0]}get alphaTexture(){return this._inputs[1]}get alphaColor(){return this._inputs[2]}get blendColor(){return this._outputs[0]}initialize(e){e._excludeVariableName("sourceAlpha")}_buildBlock(e){if(super._buildBlock(e),e.target!==A.Vertex)return e.compilationString+=`
            #ifdef BLENDMULTIPLYMODE
                ${e._declareOutput(this.blendColor)};
                ${e._declareLocalVar("sourceAlpha",x.Float)}  = ${this.alphaColor.associatedVariableName} * ${this.alphaTexture.associatedVariableName};
                ${this.blendColor.associatedVariableName} = vec4${e.fSuffix}(${this.color.associatedVariableName}.rgb * sourceAlpha + vec3(1.0) * (1.0 - sourceAlpha), ${this.color.associatedVariableName}.a);
            #else
                ${e._declareOutput(this.blendColor)} = ${this.color.associatedVariableName};
            #endif
        `,this}}B("BABYLON.ParticleBlendMultiplyBlock",Y0);class zl extends le{constructor(e){super(e,A.Neutral),this.xSwizzle="x",this.ySwizzle="y",this.zSwizzle="z",this.wSwizzle="w",this.registerInput("xyzw ",x.Vector4,!0),this.registerInput("xyz ",x.Vector3,!0),this.registerInput("xy ",x.Vector2,!0),this.registerInput("zw ",x.Vector2,!0),this.registerInput("x",x.Float,!0),this.registerInput("y",x.Float,!0),this.registerInput("z",x.Float,!0),this.registerInput("w",x.Float,!0),this.registerOutput("xyzw",x.Vector4),this.registerOutput("xyz",x.Vector3),this.registerOutput("xy",x.Vector2),this.registerOutput("zw",x.Vector2)}getClassName(){return"VectorMergerBlock"}get xyzwIn(){return this._inputs[0]}get xyzIn(){return this._inputs[1]}get xyIn(){return this._inputs[2]}get zwIn(){return this._inputs[3]}get x(){return this._inputs[4]}get y(){return this._inputs[5]}get z(){return this._inputs[6]}get w(){return this._inputs[7]}get xyzw(){return this._outputs[0]}get xyzOut(){return this._outputs[1]}get xyOut(){return this._outputs[2]}get zwOut(){return this._outputs[3]}get xy(){return this.xyOut}get xyz(){return this.xyzOut}_inputRename(e){return e==="xyzw "?"xyzwIn":e==="xyz "?"xyzIn":e==="xy "?"xyIn":e==="zw "?"zwIn":e}_buildSwizzle(e){return"."+(this.xSwizzle+this.ySwizzle+this.zSwizzle+this.wSwizzle).substring(0,e)}_buildBlock(e){super._buildBlock(e);const t=this.x,i=this.y,r=this.z,s=this.w,n=this.xyIn,o=this.zwIn,l=this.xyzIn,u=this.xyzwIn,c=this._outputs[0],h=this._outputs[1],d=this._outputs[2],f=this._outputs[3],p=e._getShaderType(x.Vector4),g=e._getShaderType(x.Vector3),_=e._getShaderType(x.Vector2);return u.isConnected?(c.hasEndpoints&&(e.compilationString+=e._declareOutput(c)+` = ${u.associatedVariableName}${this._buildSwizzle(4)};
`),h.hasEndpoints&&(e.compilationString+=e._declareOutput(h)+` = ${u.associatedVariableName}${this._buildSwizzle(3)};
`),d.hasEndpoints&&(e.compilationString+=e._declareOutput(d)+` = ${u.associatedVariableName}${this._buildSwizzle(2)};
`)):l.isConnected?(c.hasEndpoints&&(e.compilationString+=e._declareOutput(c)+` = ${p}(${l.associatedVariableName}, ${s.isConnected?this._writeVariable(s):"0.0"})${this._buildSwizzle(4)};
`),h.hasEndpoints&&(e.compilationString+=e._declareOutput(h)+` = ${l.associatedVariableName}${this._buildSwizzle(3)};
`),d.hasEndpoints&&(e.compilationString+=e._declareOutput(d)+` = ${l.associatedVariableName}${this._buildSwizzle(2)};
`)):n.isConnected?(c.hasEndpoints&&(o.isConnected?e.compilationString+=e._declareOutput(c)+` = ${p}(${n.associatedVariableName}, ${o.associatedVariableName})${this._buildSwizzle(4)};
`:e.compilationString+=e._declareOutput(c)+` = ${p}(${n.associatedVariableName}, ${r.isConnected?this._writeVariable(r):"0.0"}, ${s.isConnected?this._writeVariable(s):"0.0"})${this._buildSwizzle(4)};
`),h.hasEndpoints&&(e.compilationString+=e._declareOutput(h)+` = ${g}(${n.associatedVariableName}, ${r.isConnected?this._writeVariable(r):"0.0"})${this._buildSwizzle(3)};
`),d.hasEndpoints&&(e.compilationString+=e._declareOutput(d)+` = ${n.associatedVariableName}${this._buildSwizzle(2)};
`),f.hasEndpoints&&(o.isConnected?e.compilationString+=e._declareOutput(f)+` = ${o.associatedVariableName}${this._buildSwizzle(2)};
`:e.compilationString+=e._declareOutput(f)+` = ${_}(${r.isConnected?this._writeVariable(r):"0.0"}, ${s.isConnected?this._writeVariable(s):"0.0"})${this._buildSwizzle(2)};
`)):(c.hasEndpoints&&(o.isConnected?e.compilationString+=e._declareOutput(c)+` = ${p}(${t.isConnected?this._writeVariable(t):"0.0"}, ${i.isConnected?this._writeVariable(i):"0.0"}, ${o.associatedVariableName})${this._buildSwizzle(4)};
`:e.compilationString+=e._declareOutput(c)+` = ${p}(${t.isConnected?this._writeVariable(t):"0.0"}, ${i.isConnected?this._writeVariable(i):"0.0"}, ${r.isConnected?this._writeVariable(r):"0.0"}, ${s.isConnected?this._writeVariable(s):"0.0"})${this._buildSwizzle(4)};
`),h.hasEndpoints&&(e.compilationString+=e._declareOutput(h)+` = ${g}(${t.isConnected?this._writeVariable(t):"0.0"}, ${i.isConnected?this._writeVariable(i):"0.0"}, ${r.isConnected?this._writeVariable(r):"0.0"})${this._buildSwizzle(3)};
`),d.hasEndpoints&&(e.compilationString+=e._declareOutput(d)+` = ${_}(${t.isConnected?this._writeVariable(t):"0.0"}, ${i.isConnected?this._writeVariable(i):"0.0"})${this._buildSwizzle(2)};
`),f.hasEndpoints&&(o.isConnected?e.compilationString+=e._declareOutput(f)+` = ${o.associatedVariableName}${this._buildSwizzle(2)};
`:e.compilationString+=e._declareOutput(f)+` = ${_}(${r.isConnected?this._writeVariable(r):"0.0"}, ${s.isConnected?this._writeVariable(s):"0.0"})${this._buildSwizzle(2)};
`)),this}serialize(){const e=super.serialize();return e.xSwizzle=this.xSwizzle,e.ySwizzle=this.ySwizzle,e.zSwizzle=this.zSwizzle,e.wSwizzle=this.wSwizzle,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.xSwizzle=e.xSwizzle??"x",this.ySwizzle=e.ySwizzle??"y",this.zSwizzle=e.zSwizzle??"z",this.wSwizzle=e.wSwizzle??"w"}_dumpPropertiesCode(){let e=super._dumpPropertiesCode();return e+=`${this._codeVariableName}.xSwizzle = "${this.xSwizzle}";
`,e+=`${this._codeVariableName}.ySwizzle = "${this.ySwizzle}";
`,e+=`${this._codeVariableName}.zSwizzle = "${this.zSwizzle}";
`,e+=`${this._codeVariableName}.wSwizzle = "${this.wSwizzle}";
`,e}}B("BABYLON.VectorMergerBlock",zl);class Hu extends le{constructor(e){super(e,A.Neutral),this.sourceRange=new Q(-1,1),this.targetRange=new Q(0,1),this.registerInput("input",x.AutoDetect),this.registerInput("sourceMin",x.Float,!0),this.registerInput("sourceMax",x.Float,!0),this.registerInput("targetMin",x.Float,!0),this.registerInput("targetMax",x.Float,!0),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0]}getClassName(){return"RemapBlock"}get input(){return this._inputs[0]}get sourceMin(){return this._inputs[1]}get sourceMax(){return this._inputs[2]}get targetMin(){return this._inputs[3]}get targetMax(){return this._inputs[4]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0],i=this.sourceMin.isConnected?this.sourceMin.associatedVariableName:this._writeFloat(this.sourceRange.x),r=this.sourceMax.isConnected?this.sourceMax.associatedVariableName:this._writeFloat(this.sourceRange.y),s=this.targetMin.isConnected?this.targetMin.associatedVariableName:this._writeFloat(this.targetRange.x),n=this.targetMax.isConnected?this.targetMax.associatedVariableName:this._writeFloat(this.targetRange.y);return e.compilationString+=e._declareOutput(t)+` = ${s} + (${this._inputs[0].associatedVariableName} - ${i}) * (${n} - ${s}) / (${r} - ${i});
`,this}_dumpPropertiesCode(){let e=super._dumpPropertiesCode()+`${this._codeVariableName}.sourceRange = new BABYLON.Vector2(${this.sourceRange.x}, ${this.sourceRange.y});
`;return e+=`${this._codeVariableName}.targetRange = new BABYLON.Vector2(${this.targetRange.x}, ${this.targetRange.y});
`,e}serialize(){const e=super.serialize();return e.sourceRange=this.sourceRange.asArray(),e.targetRange=this.targetRange.asArray(),e}_deserialize(e,t,i){super._deserialize(e,t,i),this.sourceRange=Q.FromArray(e.sourceRange),this.targetRange=Q.FromArray(e.targetRange)}}C([U("From",3)],Hu.prototype,"sourceRange",void 0);C([U("To",3)],Hu.prototype,"targetRange",void 0);B("BABYLON.RemapBlock",Hu);class ju extends le{constructor(e){super(e,A.Neutral),this.registerInput("left",x.AutoDetect),this.registerInput("right",x.AutoDetect),this.registerOutput("output",x.BasedOnInput),this.output._typeConnectionSource=this.left,this._linkConnectionTypes(0,1,!0),this.left.acceptedConnectionPointTypes.push(x.Float),this.right.acceptedConnectionPointTypes.push(x.Float),this._connectionObservers=[this.left.onTypeChangedObservable.add(()=>this._updateInputOutputTypes()),this.right.onTypeChangedObservable.add(()=>this._updateInputOutputTypes())]}get left(){return this._inputs[0]}get right(){return this._inputs[1]}get output(){return this._outputs[0]}_updateInputOutputTypes(){if(this.output._typeConnectionSource=this.left,this.left.isConnected&&this.right.isConnected?(this.left.type===x.Int||this.left.type===x.Float&&this.right.type!==x.Int)&&(this.output._typeConnectionSource=this.right):this.left.isConnected!==this.right.isConnected&&(this.output._typeConnectionSource=this.left.isConnected?this.left:this.right),this.left.isConnected||this.right.isConnected)for(const[e,t]of[[this.left,this.right],[this.right,this.left]])e.acceptedConnectionPointTypes=[x.Int,x.Float],t.isConnected&&(e.acceptedConnectionPointTypes.push(t.type),(t.type===x.Int||t.type===x.Float)&&e.acceptedConnectionPointTypes.push(x.Vector2,x.Vector3,x.Vector4,x.Color3,x.Color4,x.Matrix))}dispose(){super.dispose(),this._connectionObservers.forEach(e=>e.remove()),this._connectionObservers.length=0}}class fh extends ju{constructor(e){super(e)}getClassName(){return"MultiplyBlock"}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = ${this.left.associatedVariableName} * ${this.right.associatedVariableName};
`,this}}B("BABYLON.MultiplyBlock",fh);var bi;(function(a){a[a.Material=0]="Material",a[a.PostProcess=1]="PostProcess",a[a.Particle=2]="Particle",a[a.ProceduralTexture=3]="ProceduralTexture",a[a.GaussianSplatting=4]="GaussianSplatting"})(bi||(bi={}));class e1 extends ps{constructor(){super(),this.IMAGEPROCESSING=!1,this.VIGNETTE=!1,this.VIGNETTEBLENDMODEMULTIPLY=!1,this.VIGNETTEBLENDMODEOPAQUE=!1,this.TONEMAPPING=0,this.CONTRAST=!1,this.COLORCURVES=!1,this.COLORGRADING=!1,this.COLORGRADING3D=!1,this.SAMPLER3DGREENDEPTH=!1,this.SAMPLER3DBGRMAP=!1,this.DITHER=!1,this.IMAGEPROCESSINGPOSTPROCESS=!1,this.EXPOSURE=!1,this.SKIPFINALCOLORCLAMP=!1,this.rebuild()}}class kt{get noiseTexture(){return this._noiseTexture}set noiseTexture(e){this._noiseTexture!==e&&(this._noiseTexture=e,this._reset())}get isAnimationSheetEnabled(){return this._isAnimationSheetEnabled}set isAnimationSheetEnabled(e){this._isAnimationSheetEnabled!=e&&(this._isAnimationSheetEnabled=e,this._reset())}get useLogarithmicDepth(){return this._useLogarithmicDepth}set useLogarithmicDepth(e){this._useLogarithmicDepth=e&&this.getScene().getEngine().getCaps().fragmentDepthSupported}getScene(){return this._scene}_hasTargetStopDurationDependantGradient(){return this._startSizeGradients&&this._startSizeGradients.length>0||this._emitRateGradients&&this._emitRateGradients.length>0||this._lifeTimeGradients&&this._lifeTimeGradients.length>0}getDragGradients(){return this._dragGradients}getLimitVelocityGradients(){return this._limitVelocityGradients}getColorGradients(){return this._colorGradients}getSizeGradients(){return this._sizeGradients}getColorRemapGradients(){return this._colorRemapGradients}getAlphaRemapGradients(){return this._alphaRemapGradients}getLifeTimeGradients(){return this._lifeTimeGradients}getAngularSpeedGradients(){return this._angularSpeedGradients}getVelocityGradients(){return this._velocityGradients}getStartSizeGradients(){return this._startSizeGradients}getEmitRateGradients(){return this._emitRateGradients}get direction1(){return this.particleEmitterType.direction1?this.particleEmitterType.direction1:m.Zero()}set direction1(e){this.particleEmitterType.direction1&&(this.particleEmitterType.direction1=e)}get direction2(){return this.particleEmitterType.direction2?this.particleEmitterType.direction2:m.Zero()}set direction2(e){this.particleEmitterType.direction2&&(this.particleEmitterType.direction2=e)}get minEmitBox(){return this.particleEmitterType.minEmitBox?this.particleEmitterType.minEmitBox:m.Zero()}set minEmitBox(e){this.particleEmitterType.minEmitBox&&(this.particleEmitterType.minEmitBox=e)}get maxEmitBox(){return this.particleEmitterType.maxEmitBox?this.particleEmitterType.maxEmitBox:m.Zero()}set maxEmitBox(e){this.particleEmitterType.maxEmitBox&&(this.particleEmitterType.maxEmitBox=e)}get billboardMode(){return this._billboardMode}set billboardMode(e){this._billboardMode!==e&&(this._billboardMode=e,this._reset())}get isBillboardBased(){return this._isBillboardBased}set isBillboardBased(e){this._isBillboardBased!==e&&(this._isBillboardBased=e,this._reset())}get imageProcessingConfiguration(){return this._imageProcessingConfiguration}set imageProcessingConfiguration(e){this._attachImageProcessingConfiguration(e)}_attachImageProcessingConfiguration(e){e!==this._imageProcessingConfiguration&&(!e&&this._scene?this._imageProcessingConfiguration=this._scene.imageProcessingConfiguration:this._imageProcessingConfiguration=e)}_reset(){}_removeGradientAndTexture(e,t,i){if(!t)return this;let r=0;for(const s of t){if(s.gradient===e){t.splice(r,1);break}r++}return i&&i.dispose(),this}constructor(e){this.animations=[],this.renderingGroupId=0,this.emitter=m.Zero(),this.emitRate=10,this.manualEmitCount=-1,this.updateSpeed=.01,this.targetStopDuration=0,this.disposeOnStop=!1,this.minEmitPower=1,this.maxEmitPower=1,this.minLifeTime=1,this.maxLifeTime=1,this.minSize=1,this.maxSize=1,this.minScaleX=1,this.maxScaleX=1,this.minScaleY=1,this.maxScaleY=1,this.minInitialRotation=0,this.maxInitialRotation=0,this.minAngularSpeed=0,this.maxAngularSpeed=0,this.layerMask=268435455,this.customShader=null,this.preventAutoStart=!1,this.applyFog=!1,this._wasDispatched=!1,this._rootUrl="",this.noiseStrength=new m(10,10,10),this.onAnimationEnd=null,this.blendMode=kt.BLENDMODE_ONEONE,this.forceDepthWrite=!1,this.preWarmCycles=0,this.preWarmStepOffset=1,this.spriteCellChangeSpeed=1,this.startSpriteCellID=0,this.endSpriteCellID=0,this.spriteCellWidth=0,this.spriteCellHeight=0,this.spriteCellLoop=!0,this.spriteRandomStartCell=!1,this.translationPivot=new Q(0,0),this.beginAnimationOnStart=!1,this.beginAnimationFrom=0,this.beginAnimationTo=60,this.beginAnimationLoop=!1,this.worldOffset=new m(0,0,0),this._useLogarithmicDepth=!1,this.gravity=m.Zero(),this._colorGradients=null,this._sizeGradients=null,this._lifeTimeGradients=null,this._angularSpeedGradients=null,this._velocityGradients=null,this._limitVelocityGradients=null,this._dragGradients=null,this._emitRateGradients=null,this._startSizeGradients=null,this._rampGradients=null,this._colorRemapGradients=null,this._alphaRemapGradients=null,this.startDelay=0,this.limitVelocityDamping=.4,this.color1=new xe(1,1,1,1),this.color2=new xe(1,1,1,1),this.colorDead=new xe(0,0,0,1),this.textureMask=new xe(1,1,1,1),this._isSubEmitter=!1,this._billboardMode=7,this._isBillboardBased=!0,this._imageProcessingConfigurationDefines=new e1,this.id=e,this.name=e}createPointEmitter(e,t){throw new Error("Method not implemented.")}createHemisphericEmitter(e=1,t=1){throw new Error("Method not implemented.")}createSphereEmitter(e=1,t=1){throw new Error("Method not implemented.")}createDirectedSphereEmitter(e=1,t=new m(0,1,0),i=new m(0,1,0)){throw new Error("Method not implemented.")}createCylinderEmitter(e=1,t=1,i=1,r=0){throw new Error("Method not implemented.")}createDirectedCylinderEmitter(e=1,t=1,i=1,r=new m(0,1,0),s=new m(0,1,0)){throw new Error("Method not implemented.")}createConeEmitter(e=1,t=Math.PI/4){throw new Error("Method not implemented.")}createDirectedConeEmitter(e=1,t=Math.PI/4,i=new m(0,1,0),r=new m(0,1,0)){throw new Error("Method not implemented.")}createBoxEmitter(e,t,i,r){throw new Error("Method not implemented.")}}kt.BLENDMODE_ONEONE=0;kt.BLENDMODE_STANDARD=1;kt.BLENDMODE_ADD=2;kt.BLENDMODE_MULTIPLY=3;kt.BLENDMODE_MULTIPLYADD=4;B("BABYLON.BaseParticleSystem",kt);class X0 extends le{constructor(e){super(e,A.Neutral),this.registerInput("rgba",x.Color4,!0),this.registerInput("rgb ",x.Color3,!0),this.registerOutput("rgb",x.Color3),this.registerOutput("r",x.Float),this.registerOutput("g",x.Float),this.registerOutput("b",x.Float),this.registerOutput("a",x.Float),this.inputsAreExclusive=!0}getClassName(){return"ColorSplitterBlock"}get rgba(){return this._inputs[0]}get rgbIn(){return this._inputs[1]}get rgbOut(){return this._outputs[0]}get r(){return this._outputs[1]}get g(){return this._outputs[2]}get b(){return this._outputs[3]}get a(){return this._outputs[4]}_inputRename(e){return e==="rgb "?"rgbIn":e}_outputRename(e){return e==="rgb"?"rgbOut":e}_buildBlock(e){super._buildBlock(e);const t=this.rgba.isConnected?this.rgba:this.rgbIn;if(!t.isConnected)return;const i=this._outputs[0],r=this._outputs[1],s=this._outputs[2],n=this._outputs[3],o=this._outputs[4];return i.hasEndpoints&&(e.compilationString+=e._declareOutput(i)+` = ${t.associatedVariableName}.rgb;
`),r.hasEndpoints&&(e.compilationString+=e._declareOutput(r)+` = ${t.associatedVariableName}.r;
`),s.hasEndpoints&&(e.compilationString+=e._declareOutput(s)+` = ${t.associatedVariableName}.g;
`),n.hasEndpoints&&(e.compilationString+=e._declareOutput(n)+` = ${t.associatedVariableName}.b;
`),o.hasEndpoints&&(e.compilationString+=e._declareOutput(o)+` = ${t.associatedVariableName}.a;
`),this}}B("BABYLON.ColorSplitterBlock",X0);class t1{constructor(e){this.name=ge.NAME_PROCEDURALTEXTURE,this.scene=e}register(){this.scene._beforeClearStage.registerStep(ge.STEP_BEFORECLEAR_PROCEDURALTEXTURE,this,this._beforeClear)}rebuild(){}dispose(){}_beforeClear(){if(this.scene.proceduralTexturesEnabled){ae.StartPerformanceCounter("Procedural textures",this.scene.proceduralTextures.length>0);for(let e=0;e<this.scene.proceduralTextures.length;e++){const t=this.scene.proceduralTextures[e];t._shouldRender()&&t.render()}ae.EndPerformanceCounter("Procedural textures",this.scene.proceduralTextures.length>0)}}}class er extends Y{get shaderLanguage(){return this._shaderLanguage}constructor(e,t,i,r,s=null,n=!0,o=!1,l=0){super(null,r,!n),this.isEnabled=!0,this.autoClear=!0,this.onGeneratedObservable=new j,this.onBeforeGenerationObservable=new j,this.nodeMaterialSource=null,this.defines="",this._textures={},this._currentRefreshId=-1,this._frameId=-1,this._refreshRate=1,this._vertexBuffers={},this._uniforms=new Array,this._samplers=new Array,this._floats={},this._ints={},this._floatsArrays={},this._colors3={},this._colors4={},this._vectors2={},this._vectors3={},this._vectors4={},this._matrices={},this._fallbackTextureUsed=!1,this._cachedDefines=null,this._contentUpdateId=-1,this._rtWrapper=null,s!==null&&!(s instanceof Y)?(this._options=s,this._fallbackTexture=s.fallbackTexture??null):(this._options={},this._fallbackTexture=s),this._shaderLanguage=this._options.shaderLanguage??0,r=this.getScene()||ze.LastCreatedScene;let u=r._getComponent(ge.NAME_PROCEDURALTEXTURE);u||(u=new t1(r),r._addComponent(u)),r.proceduralTextures.push(this),this._fullEngine=r.getEngine(),this.name=e,this.isRenderTarget=!0,this._size=t,this._textureType=l,this._generateMipMaps=n,this._drawWrapper=new vi(this._fullEngine),this.setFragment(i);const c=this._createRtWrapper(o,t,n,l);this._texture=c.texture;const h=[];h.push(1,1),h.push(-1,1),h.push(-1,-1),h.push(1,-1),this._vertexBuffers[N.PositionKind]=new N(this._fullEngine,h,N.PositionKind,!1,!1,2),this._createIndexBuffer()}_createRtWrapper(e,t,i,r){return e?(this._rtWrapper=this._fullEngine.createRenderTargetCubeTexture(t,{generateMipMaps:i,generateDepthBuffer:!1,generateStencilBuffer:!1,type:r,...this._options}),this.setFloat("face",0)):(this._rtWrapper=this._fullEngine.createRenderTargetTexture(t,{generateMipMaps:i,generateDepthBuffer:!1,generateStencilBuffer:!1,type:r,...this._options}),this._rtWrapper.is3D&&(this.setFloat("layer",0),this.setInt("layerNum",0))),this._rtWrapper}getEffect(){return this._drawWrapper.effect}_setEffect(e){this._drawWrapper.effect=e}getContent(){return this._contentData&&this._frameId===this._contentUpdateId?this._contentData:(this._contentData?this._contentData.then(e=>{this._contentData=this.readPixels(0,0,e),this._contentUpdateId=this._frameId}):(this._contentData=this.readPixels(0,0),this._contentUpdateId=this._frameId),this._contentData)}_createIndexBuffer(){const e=this._fullEngine,t=[];t.push(0),t.push(1),t.push(2),t.push(0),t.push(2),t.push(3),this._indexBuffer=e.createIndexBuffer(t)}_rebuild(){const e=this._vertexBuffers[N.PositionKind];e&&e._rebuild(),this._createIndexBuffer(),this.refreshRate===Kt.REFRESHRATE_RENDER_ONCE&&(this.refreshRate=Kt.REFRESHRATE_RENDER_ONCE)}reset(){var e;(e=this._drawWrapper.effect)==null||e.dispose(),this._drawWrapper.effect=null,this._cachedDefines=null}_getDefines(){return this.defines}executeWhenReady(e){if(this.isReady()){e(this);return}const t=this.getEffect();t&&t.executeWhenCompiled(()=>{e(this)})}isReady(){const e=this._fullEngine;if(this.nodeMaterialSource)return this._drawWrapper.effect.isReady();if(!this._fragment)return!1;if(this._fallbackTextureUsed)return!0;if(!this._texture)return!1;const t=this._getDefines();if(this._drawWrapper.effect&&t===this._cachedDefines&&this._drawWrapper.effect.isReady())return!0;const i={vertex:"procedural",fragmentElement:this._fragment.fragmentElement,fragmentSource:this._fragment.fragmentSource,fragment:typeof this._fragment=="string"?this._fragment:void 0};return this._cachedDefines!==t&&(this._cachedDefines=t,this._drawWrapper.effect=e.createEffect(i,[N.PositionKind],this._uniforms,this._samplers,t,void 0,void 0,()=>{var r;(r=this._rtWrapper)==null||r.dispose(),this._rtWrapper=this._texture=null,this._fallbackTexture&&(this._texture=this._fallbackTexture._texture,this._texture&&this._texture.incrementReferences()),this._fallbackTextureUsed=!0},void 0,this._shaderLanguage,async()=>{this._options.extraInitializationsAsync?this.shaderLanguage===1?await Promise.all([k(()=>Promise.resolve().then(()=>WS),void 0),this._options.extraInitializationsAsync()]):await Promise.all([k(()=>Promise.resolve().then(()=>$S),void 0),this._options.extraInitializationsAsync()]):this.shaderLanguage===1?await k(()=>Promise.resolve().then(()=>WS),void 0):await k(()=>Promise.resolve().then(()=>$S),void 0)})),this._drawWrapper.effect.isReady()}resetRefreshCounter(){this._currentRefreshId=-1}setFragment(e){this._fragment=e}get refreshRate(){return this._refreshRate}set refreshRate(e){this._refreshRate=e,this.resetRefreshCounter()}_shouldRender(){return!this.isEnabled||!this.isReady()||!this._texture?(this._texture&&(this._texture.isReady=!1),!1):this._fallbackTextureUsed?!1:this._currentRefreshId===-1?(this._currentRefreshId=1,this._frameId++,!0):this.refreshRate===this._currentRefreshId?(this._currentRefreshId=1,this._frameId++,!0):(this._currentRefreshId++,!1)}getRenderSize(){return this._size}resize(e,t){if(this._fallbackTextureUsed||!this._rtWrapper||!this._texture)return;const i=this._texture.isCube;this._rtWrapper.dispose();const r=this._createRtWrapper(i,e,t,this._textureType);this._texture=r.texture,this._size=e,this._generateMipMaps=t}_checkUniform(e){this._uniforms.indexOf(e)===-1&&this._uniforms.push(e)}setTexture(e,t){return this._samplers.indexOf(e)===-1&&this._samplers.push(e),this._textures[e]=t,this}setFloat(e,t){return this._checkUniform(e),this._floats[e]=t,this}setInt(e,t){return this._checkUniform(e),this._ints[e]=t,this}setFloats(e,t){return this._checkUniform(e),this._floatsArrays[e]=t,this}setColor3(e,t){return this._checkUniform(e),this._colors3[e]=t,this}setColor4(e,t){return this._checkUniform(e),this._colors4[e]=t,this}setVector2(e,t){return this._checkUniform(e),this._vectors2[e]=t,this}setVector3(e,t){return this._checkUniform(e),this._vectors3[e]=t,this}setVector4(e,t){return this._checkUniform(e),this._vectors4[e]=t,this}setMatrix(e,t){return this._checkUniform(e),this._matrices[e]=t,this}render(e){var s,n,o,l;const t=this.getScene();if(!t)return;const i=this._fullEngine;if(i.enableEffect(this._drawWrapper),this.onBeforeGenerationObservable.notifyObservers(this),i.setState(!1),!this.nodeMaterialSource){for(const u in this._textures)this._drawWrapper.effect.setTexture(u,this._textures[u]);for(const u in this._ints)this._drawWrapper.effect.setInt(u,this._ints[u]);for(const u in this._floats)this._drawWrapper.effect.setFloat(u,this._floats[u]);for(const u in this._floatsArrays)this._drawWrapper.effect.setArray(u,this._floatsArrays[u]);for(const u in this._colors3)this._drawWrapper.effect.setColor3(u,this._colors3[u]);for(const u in this._colors4){const c=this._colors4[u];this._drawWrapper.effect.setFloat4(u,c.r,c.g,c.b,c.a)}for(const u in this._vectors2)this._drawWrapper.effect.setVector2(u,this._vectors2[u]);for(const u in this._vectors3)this._drawWrapper.effect.setVector3(u,this._vectors3[u]);for(const u in this._vectors4)this._drawWrapper.effect.setVector4(u,this._vectors4[u]);for(const u in this._matrices)this._drawWrapper.effect.setMatrix(u,this._matrices[u])}if(!this._texture||!this._rtWrapper)return;(s=i._debugPushGroup)==null||s.call(i,`procedural texture generation for ${this.name}`,1);const r=i.currentViewport;if(this.isCube)for(let u=0;u<6;u++)i.bindFramebuffer(this._rtWrapper,u,void 0,void 0,!0),i.bindBuffers(this._vertexBuffers,this._indexBuffer,this._drawWrapper.effect),this._drawWrapper.effect.setFloat("face",u),this.autoClear&&i.clear(t.clearColor,!0,!1,!1),i.drawElementsType(ft.TriangleFillMode,0,6),i.unBindFramebuffer(this._rtWrapper,!0);else{let u=1;this._rtWrapper.is3D?u=this._rtWrapper.depth:this._rtWrapper.is2DArray&&(u=this._rtWrapper.layers);for(let c=0;c<u;c++){if(i.bindFramebuffer(this._rtWrapper,0,void 0,void 0,!0,0,c),i.bindBuffers(this._vertexBuffers,this._indexBuffer,this._drawWrapper.effect),this._rtWrapper.is3D||this._rtWrapper.is2DArray){(n=this._drawWrapper.effect)==null||n.setFloat("layer",u!==1?c/(u-1):0),(o=this._drawWrapper.effect)==null||o.setInt("layerNum",c);for(const h in this._textures)this._drawWrapper.effect.setTexture(h,this._textures[h])}this.autoClear&&i.clear(t.clearColor,!0,!1,!1),i.drawElementsType(ft.TriangleFillMode,0,6),i.unBindFramebuffer(this._rtWrapper,!this._generateMipMaps)}}r&&i.setViewport(r),this.isCube&&i.generateMipMapsForCubemap(this._texture,!0),(l=i._debugPopGroup)==null||l.call(i,1),this.onGenerated&&this.onGenerated(),this.onGeneratedObservable.notifyObservers(this)}clone(){const e=this.getSize(),t=new er(this.name,e.width,this._fragment,this.getScene(),this._fallbackTexture,this._generateMipMaps);return t.hasAlpha=this.hasAlpha,t.level=this.level,t.coordinatesMode=this.coordinatesMode,t}dispose(){const e=this.getScene();if(!e)return;const t=e.proceduralTextures.indexOf(this);t>=0&&e.proceduralTextures.splice(t,1);const i=this._vertexBuffers[N.PositionKind];i&&(i.dispose(),this._vertexBuffers[N.PositionKind]=null),this._indexBuffer&&this._fullEngine._releaseBuffer(this._indexBuffer)&&(this._indexBuffer=null),this.onGeneratedObservable.clear(),this.onBeforeGenerationObservable.clear(),super.dispose()}}C([F()],er.prototype,"isEnabled",void 0);C([F()],er.prototype,"autoClear",void 0);C([F()],er.prototype,"_generateMipMaps",void 0);C([F()],er.prototype,"_size",void 0);C([F()],er.prototype,"refreshRate",null);B("BABYLON.ProceduralTexture",er);var Ye;(function(a){a[a.Cos=0]="Cos",a[a.Sin=1]="Sin",a[a.Abs=2]="Abs",a[a.Exp=3]="Exp",a[a.Exp2=4]="Exp2",a[a.Round=5]="Round",a[a.Floor=6]="Floor",a[a.Ceiling=7]="Ceiling",a[a.Sqrt=8]="Sqrt",a[a.Log=9]="Log",a[a.Tan=10]="Tan",a[a.ArcTan=11]="ArcTan",a[a.ArcCos=12]="ArcCos",a[a.ArcSin=13]="ArcSin",a[a.Fract=14]="Fract",a[a.Sign=15]="Sign",a[a.Radians=16]="Radians",a[a.Degrees=17]="Degrees",a[a.Set=18]="Set"})(Ye||(Ye={}));class N_ extends le{constructor(e){super(e,A.Neutral),this.operation=Ye.Cos,this.registerInput("input",x.AutoDetect),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0]}getClassName(){return"TrigonometryBlock"}get input(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];let i="";switch(this.operation){case Ye.Cos:{i="cos";break}case Ye.Sin:{i="sin";break}case Ye.Abs:{i="abs";break}case Ye.Exp:{i="exp";break}case Ye.Exp2:{i="exp2";break}case Ye.Round:{i="round";break}case Ye.Floor:{i="floor";break}case Ye.Ceiling:{i="ceil";break}case Ye.Sqrt:{i="sqrt";break}case Ye.Log:{i="log";break}case Ye.Tan:{i="tan";break}case Ye.ArcTan:{i="atan";break}case Ye.ArcCos:{i="acos";break}case Ye.ArcSin:{i="asin";break}case Ye.Fract:{i="fract";break}case Ye.Sign:{i="sign";break}case Ye.Radians:{i="radians";break}case Ye.Degrees:{i="degrees";break}case Ye.Set:{i="";break}}return e.compilationString+=e._declareOutput(t)+` = ${i}(${this.input.associatedVariableName});
`,this}serialize(){const e=super.serialize();return e.operation=this.operation,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.operation=e.operation}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.operation = BABYLON.TrigonometryBlockOperations.${Ye[this.operation]};
`}}C([U("Operation",4,"ADVANCED",{notifiers:{rebuild:!0},embedded:!0,options:[{label:"Cos",value:Ye.Cos},{label:"Sin",value:Ye.Sin},{label:"Abs",value:Ye.Abs},{label:"Exp",value:Ye.Exp},{label:"Exp2",value:Ye.Exp2},{label:"Round",value:Ye.Round},{label:"Floor",value:Ye.Floor},{label:"Ceiling",value:Ye.Ceiling},{label:"Sqrt",value:Ye.Sqrt},{label:"Log",value:Ye.Log},{label:"Tan",value:Ye.Tan},{label:"ArcTan",value:Ye.ArcTan},{label:"ArcCos",value:Ye.ArcCos},{label:"ArcSin",value:Ye.ArcSin},{label:"Fract",value:Ye.Fract},{label:"Sign",value:Ye.Sign},{label:"Radians",value:Ye.Radians},{label:"Degrees",value:Ye.Degrees},{label:"Set",value:Ye.Set}]})],N_.prototype,"operation",void 0);B("BABYLON.TrigonometryBlock",N_);const Vc={effect:null,subMesh:null};class Dl extends ps{constructor(){super(),this.NORMAL=!1,this.TANGENT=!1,this.VERTEXCOLOR_NME=!1,this.UV1=!1,this.UV2=!1,this.UV3=!1,this.UV4=!1,this.UV5=!1,this.UV6=!1,this.PREPASS=!1,this.PREPASS_NORMAL=!1,this.PREPASS_NORMAL_INDEX=-1,this.PREPASS_WORLD_NORMAL=!1,this.PREPASS_WORLD_NORMAL_INDEX=-1,this.PREPASS_POSITION=!1,this.PREPASS_POSITION_INDEX=-1,this.PREPASS_LOCAL_POSITION=!1,this.PREPASS_LOCAL_POSITION_INDEX=-1,this.PREPASS_DEPTH=!1,this.PREPASS_DEPTH_INDEX=-1,this.PREPASS_SCREENSPACE_DEPTH=!1,this.PREPASS_SCREENSPACE_DEPTH_INDEX=-1,this.SCENE_MRT_COUNT=0,this.NUM_BONE_INFLUENCERS=0,this.BonesPerMesh=0,this.BONETEXTURE=!1,this.MORPHTARGETS=!1,this.MORPHTARGETS_POSITION=!1,this.MORPHTARGETS_NORMAL=!1,this.MORPHTARGETS_TANGENT=!1,this.MORPHTARGETS_UV=!1,this.MORPHTARGETS_UV2=!1,this.MORPHTARGETS_COLOR=!1,this.MORPHTARGETTEXTURE_HASPOSITIONS=!1,this.MORPHTARGETTEXTURE_HASNORMALS=!1,this.MORPHTARGETTEXTURE_HASTANGENTS=!1,this.MORPHTARGETTEXTURE_HASUVS=!1,this.MORPHTARGETTEXTURE_HASUV2S=!1,this.MORPHTARGETTEXTURE_HASCOLORS=!1,this.NUM_MORPH_INFLUENCERS=0,this.MORPHTARGETS_TEXTURE=!1,this.IMAGEPROCESSING=!1,this.VIGNETTE=!1,this.VIGNETTEBLENDMODEMULTIPLY=!1,this.VIGNETTEBLENDMODEOPAQUE=!1,this.TONEMAPPING=0,this.CONTRAST=!1,this.EXPOSURE=!1,this.COLORCURVES=!1,this.COLORGRADING=!1,this.COLORGRADING3D=!1,this.SAMPLER3DGREENDEPTH=!1,this.SAMPLER3DBGRMAP=!1,this.DITHER=!1,this.IMAGEPROCESSINGPOSTPROCESS=!1,this.SKIPFINALCOLORCLAMP=!1,this.BUMPDIRECTUV=0,this.CAMERA_ORTHOGRAPHIC=!1,this.CAMERA_PERSPECTIVE=!1,this.AREALIGHTSUPPORTED=!0,this.AREALIGHTNOROUGHTNESS=!0,this.rebuild()}setValue(e,t,i=!1){this[e]===void 0&&this._keys.push(e),i&&this[e]!==t&&this.markAsUnprocessed(),this[e]=t}}class ht extends oy{static _BlockIsTextureBlock(e){return e.getClassName()==="TextureBlock"||e.getClassName()==="ReflectionTextureBaseBlock"||e.getClassName()==="ReflectionTextureBlock"||e.getClassName()==="ReflectionBlock"||e.getClassName()==="RefractionBlock"||e.getClassName()==="CurrentScreenBlock"||e.getClassName()==="ParticleTextureBlock"||e.getClassName()==="ImageSourceBlock"||e.getClassName()==="TriPlanarBlock"||e.getClassName()==="BiPlanarBlock"||e.getClassName()==="PrePassTextureBlock"}set _glowModeEnabled(e){this._useAdditionalColor=e}_getGlobalNodeMaterialEditor(){if(typeof NODEEDITOR<"u")return NODEEDITOR;if(typeof BABYLON<"u"&&typeof BABYLON.NodeEditor<"u")return BABYLON}get shaderLanguage(){var e;return((e=this._options)==null?void 0:e.shaderLanguage)||ht.DefaultShaderLanguage}set shaderLanguage(e){this._options.shaderLanguage=e}get options(){return this._options}set options(e){this._options=e}get imageProcessingConfiguration(){return this._imageProcessingConfiguration}set imageProcessingConfiguration(e){this._attachImageProcessingConfiguration(e),this._markAllSubMeshesAsTexturesDirty()}get mode(){return this._mode}set mode(e){this._mode=e}get buildId(){return this._buildId}set buildId(e){this._buildId=e}constructor(e,t,i={}){if(super(e,t||ze.LastCreatedScene),this._buildId=ht._BuildIdGenerator++,this._buildWasSuccessful=!1,this._cachedWorldViewMatrix=new $,this._cachedWorldViewProjectionMatrix=new $,this._optimizers=new Array,this._animationFrame=-1,this._buildIsInProgress=!1,this.BJSNODEMATERIALEDITOR=this._getGlobalNodeMaterialEditor(),this._useAdditionalColor=!1,this.editorData=null,this.ignoreAlpha=!1,this.maxSimultaneousLights=4,this.onBuildObservable=new j,this.onBuildErrorObservable=new j,this._vertexOutputNodes=new Array,this._fragmentOutputNodes=new Array,this.attachedBlocks=[],this._mode=bi.Material,this.forceAlphaBlending=!1,!ht.UseNativeShaderLanguageOfEngine&&i&&i.shaderLanguage===1&&!this.getScene().getEngine().isWebGPU)throw new Error("WebGPU shader language is only supported with WebGPU engine");this._options={emitComments:!1,shaderLanguage:ht.DefaultShaderLanguage,...i},ht.UseNativeShaderLanguageOfEngine&&(this._options.shaderLanguage=this.getScene().getEngine().isWebGPU?1:0),this._attachImageProcessingConfiguration(null)}getClassName(){return"NodeMaterial"}_attachImageProcessingConfiguration(e){e!==this._imageProcessingConfiguration&&(this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),e?this._imageProcessingConfiguration=e:this._imageProcessingConfiguration=this.getScene().imageProcessingConfiguration,this._imageProcessingConfiguration&&(this._imageProcessingObserver=this._imageProcessingConfiguration.onUpdateParameters.add(()=>{this._markAllSubMeshesAsImageProcessingDirty()})))}getBlockByName(e){let t=null;for(const i of this.attachedBlocks)if(i.name===e)if(!t)t=i;else return ae.Warn("More than one block was found with the name `"+e+"`"),t;return t}getBlockByPredicate(e){for(const t of this.attachedBlocks)if(e(t))return t;return null}getInputBlockByPredicate(e){for(const t of this.attachedBlocks)if(t.isInput&&e(t))return t;return null}getInputBlocks(){const e=[];for(const t of this.attachedBlocks)t.isInput&&e.push(t);return e}registerOptimizer(e){if(!(this._optimizers.indexOf(e)>-1))return this._optimizers.push(e),this}unregisterOptimizer(e){const t=this._optimizers.indexOf(e);if(t!==-1)return this._optimizers.splice(t,1),this}addOutputNode(e){if(e.target===null)throw"This node is not meant to be an output node. You may want to explicitly set its target value.";return e.target&A.Vertex&&this._addVertexOutputNode(e),e.target&A.Fragment&&this._addFragmentOutputNode(e),this}removeOutputNode(e){return e.target===null?this:(e.target&A.Vertex&&this._removeVertexOutputNode(e),e.target&A.Fragment&&this._removeFragmentOutputNode(e),this)}_addVertexOutputNode(e){if(this._vertexOutputNodes.indexOf(e)===-1)return e.target=A.Vertex,this._vertexOutputNodes.push(e),this}_removeVertexOutputNode(e){const t=this._vertexOutputNodes.indexOf(e);if(t!==-1)return this._vertexOutputNodes.splice(t,1),this}_addFragmentOutputNode(e){if(this._fragmentOutputNodes.indexOf(e)===-1)return e.target=A.Fragment,this._fragmentOutputNodes.push(e),this}_removeFragmentOutputNode(e){const t=this._fragmentOutputNodes.indexOf(e);if(t!==-1)return this._fragmentOutputNodes.splice(t,1),this}get _supportGlowLayer(){return this._fragmentOutputNodes.length===0?!1:!!this._fragmentOutputNodes.some(e=>e.additionalColor&&e.additionalColor.isConnected)}needAlphaBlending(){return this.ignoreAlpha?!1:this.forceAlphaBlending||this.alpha<1||this._sharedData&&this._sharedData.hints.needAlphaBlending}needAlphaTesting(){return this._sharedData&&this._sharedData.hints.needAlphaTesting}_processInitializeOnLink(e,t,i,r=!0){(e.target===A.VertexAndFragment||t.target===A.Fragment&&e.target===A.Vertex&&e._preparationId!==this._buildId)&&i.push(e),this._initializeBlock(e,t,i,r)}_attachBlock(e){if(this.attachedBlocks.indexOf(e)===-1){if(e.isUnique){const t=e.getClassName();for(const i of this.attachedBlocks)if(i.getClassName()===t)throw`Cannot have multiple blocks of type ${t} in the same NodeMaterial`}this.attachedBlocks.push(e)}}_initializeBlock(e,t,i,r=!0){e.initialize(t),r&&e.autoConfigure(this),e._preparationId=this._buildId,this._attachBlock(e);for(const s of e.inputs){s.associatedVariableName="";const n=s.connectedPoint;if(n&&!n._preventBubbleUp){const o=n.ownerBlock;o!==e&&this._processInitializeOnLink(o,t,i,r)}}if(e.isLoop){const s=e;if(s.loopID.hasEndpoints)for(const n of s.loopID.endpoints){const o=n.ownerBlock;o.outputs.length===0&&(t._terminalBlocks.add(o),this._processInitializeOnLink(o,t,i,r))}}else if(e.isTeleportOut){const s=e;s.entryPoint&&this._processInitializeOnLink(s.entryPoint,t,i,r)}for(const s of e.outputs)s.associatedVariableName=""}_resetDualBlocks(e,t){e.target===A.VertexAndFragment&&(e.buildId=t);for(const i of e.inputs){const r=i.connectedPoint;if(r&&!r._preventBubbleUp){const s=r.ownerBlock;s!==e&&this._resetDualBlocks(s,t)}}if(e.isTeleportOut){const i=e;i.entryPoint&&this._resetDualBlocks(i.entryPoint,t)}else if(e.isLoop){const i=e;if(i.loopID.hasEndpoints)for(const r of i.loopID.endpoints){const s=r.ownerBlock;s.outputs.length===0&&this._resetDualBlocks(s,t)}}}removeBlock(e){const t=this.attachedBlocks.indexOf(e);t>-1&&this.attachedBlocks.splice(t,1),e.isFinalMerger&&this.removeOutputNode(e)}build(e=!1,t=!0,i=!1){if(this._buildIsInProgress){L.Warn("Build is already in progress, You can use NodeMaterial.onBuildObservable to determine when the build is completed.");return}this._buildIsInProgress=!0,!this._vertexCompilationState&&!i&&(i=!0),this._buildWasSuccessful=!1;const r=this.getScene().getEngine(),s=this._mode===bi.Particle;if(this._vertexOutputNodes.length===0&&!s)throw"You must define at least one vertexOutputNode";if(this._fragmentOutputNodes.length===0)throw"You must define at least one fragmentOutputNode";this._vertexCompilationState=new uS,this._vertexCompilationState.supportUniformBuffers=r.supportsUniformBuffers,this._vertexCompilationState.target=A.Vertex,this._fragmentCompilationState=new uS,this._fragmentCompilationState.supportUniformBuffers=r.supportsUniformBuffers,this._fragmentCompilationState.target=A.Fragment;const n=this._fragmentOutputNodes.filter(h=>h._isFinalOutputAndActive).length>1;let o=this._fragmentOutputNodes;n&&(o=this._fragmentOutputNodes.filter(h=>!h._isFinalOutputAndActive),o.push(this._fragmentOutputNodes.filter(h=>h._isFinalOutputAndActive&&h._hasPrecedence)[0])),this._sharedData=new Kw,this._sharedData.nodeMaterial=this,this._sharedData.fragmentOutputNodes=o,this._vertexCompilationState.sharedData=this._sharedData,this._fragmentCompilationState.sharedData=this._sharedData,this._sharedData.buildId=this._buildId,this._sharedData.emitComments=this._options.emitComments,this._sharedData.verbose=e,this._sharedData.scene=this.getScene(),this._sharedData.allowEmptyVertexProgram=s;const l=[],u=[];for(const h of this._vertexOutputNodes)l.push(h),this._initializeBlock(h,this._vertexCompilationState,u,i);for(const h of o)u.push(h),this._initializeBlock(h,this._fragmentCompilationState,l,i);let c=0;for(const h of this.attachedBlocks)h.codeIsReady||(c++,h.onCodeIsReadyObservable.addOnce(()=>{c--,c===0&&this._finishBuildProcess(e,t,l,u)}));c===0&&this._finishBuildProcess(e,t,l,u)}_finishBuildProcess(e=!1,t=!0,i,r){this.optimize();for(const l of i)l.build(this._vertexCompilationState,i);this._fragmentCompilationState.uniforms=this._vertexCompilationState.uniforms.slice(0),this._fragmentCompilationState._uniformDeclaration=this._vertexCompilationState._uniformDeclaration,this._fragmentCompilationState._constantDeclaration=this._vertexCompilationState._constantDeclaration,this._fragmentCompilationState._vertexState=this._vertexCompilationState;for(const l of r)this._resetDualBlocks(l,this._buildId-1);for(const l of r)l.build(this._fragmentCompilationState,r);this._vertexCompilationState.finalize(this._vertexCompilationState),this._fragmentCompilationState.finalize(this._fragmentCompilationState),t&&(this._buildId=ht._BuildIdGenerator++);const s=this._sharedData.emitErrors(this.onBuildErrorObservable);e&&(L.Log("Vertex shader:"),L.Log(this._vertexCompilationState.compilationString),L.Log("Fragment shader:"),L.Log(this._fragmentCompilationState.compilationString)),this._buildIsInProgress=!1,this._buildWasSuccessful=!0,s&&this.onBuildObservable.notifyObservers(this);const n=this.getScene().meshes;for(const l of n)if(l.subMeshes)for(const u of l.subMeshes){if(u.getMaterial()!==this||!u.materialDefines)continue;const c=u.materialDefines;c.markAllAsDirty(),c.reset()}this.prePassTextureInputs.length&&this.getScene().enablePrePassRenderer();const o=this.getScene().prePassRenderer;o&&o.markAsDirty()}optimize(){for(const e of this._optimizers)e.optimize(this._vertexOutputNodes,this._fragmentOutputNodes)}_prepareDefinesForAttributes(e,t){const i=t.NORMAL,r=t.TANGENT,s=t.VERTEXCOLOR_NME;t.NORMAL=e.isVerticesDataPresent(N.NormalKind),t.TANGENT=e.isVerticesDataPresent(N.TangentKind);const n=e.useVertexColors&&e.isVerticesDataPresent(N.ColorKind);t.VERTEXCOLOR_NME=n;let o=!1;for(let u=1;u<=6;++u){const c=t["UV"+u];t["UV"+u]=e.isVerticesDataPresent(`uv${u===1?"":u}`),o=o||t["UV"+u]!==c}const l=this.needAlphaBlendingForMesh(e)&&this.getScene().useOrderIndependentTransparency;my(this.getScene(),t,!l),Ui.PrepareDefines(this.getScene().getEngine().currentRenderPassId,e,t),(i!==t.NORMAL||r!==t.TANGENT||s!==t.VERTEXCOLOR_NME||o)&&t.markAsAttributesDirty()}get isPrePassCapable(){return!0}get prePassTextureOutputs(){const e=this.getBlockByPredicate(i=>i.getClassName()==="PrePassOutputBlock"),t=[4];return!e||this.prePassTextureInputs.length||(e.viewDepth.isConnected&&t.push(5),e.screenDepth.isConnected&&t.push(10),e.viewNormal.isConnected&&t.push(6),e.worldNormal.isConnected&&t.push(8),e.worldPosition.isConnected&&t.push(1),e.localPosition.isConnected&&t.push(9),e.reflectivity.isConnected&&t.push(3),e.velocity.isConnected&&t.push(2),e.velocityLinear.isConnected&&t.push(11)),t}get prePassTextureInputs(){const e=this.getAllTextureBlocks().filter(i=>i.getClassName()==="PrePassTextureBlock"),t=[];for(const i of e)i.position.isConnected&&!t.includes(1)&&t.push(1),i.localPosition.isConnected&&!t.includes(9)&&t.push(9),i.depth.isConnected&&!t.includes(5)&&t.push(5),i.screenDepth.isConnected&&!t.includes(10)&&t.push(10),i.normal.isConnected&&!t.includes(6)&&t.push(6),i.worldNormal.isConnected&&!t.includes(8)&&t.push(8);return t}setPrePassRenderer(e){const t=this.prePassTextureInputs.concat(this.prePassTextureOutputs);if(e&&t.length>1){let i=e.getEffectConfiguration("nodeMaterial");i||(i=e.addEffectConfiguration({enabled:!0,needsImageProcessing:!1,name:"nodeMaterial",texturesRequired:[]}));for(const r of t)i.texturesRequired.includes(r)||i.texturesRequired.push(r);i.enabled=!0}return t.length>1}createPostProcess(e,t=1,i=1,r,s,n=0,o=5){return this.mode!==bi.PostProcess?(L.Log("Incompatible material mode"),null):this._createEffectForPostProcess(null,e,t,i,r,s,n,o)}createEffectForPostProcess(e){this._createEffectForPostProcess(e)}_createEffectForPostProcess(e,t,i=1,r=1,s,n,o=0,l=5){let u=this.name+this._buildId;const c=new Dl,h=new z(u+"PostProcess",this.getScene());let d=this._buildId;return this._processDefines(h,c),_i.RegisterShader(u,this._fragmentCompilationState._builtCompilationString,this._vertexCompilationState._builtCompilationString,this.shaderLanguage),e?e.updateEffect(c.toString(),this._fragmentCompilationState.uniforms,this._fragmentCompilationState.samplers,{maxSimultaneousLights:this.maxSimultaneousLights},void 0,void 0,u,u):e=new Ce(this.name+"PostProcess",u,this._fragmentCompilationState.uniforms,this._fragmentCompilationState.samplers,i,t,r,s,n,c.toString(),o,u,{maxSimultaneousLights:this.maxSimultaneousLights},!1,l,this.shaderLanguage),e.nodeMaterialSource=this,e.onDisposeObservable.add(()=>{h.dispose()}),e.onApplyObservable.add(f=>{d!==this._buildId&&(delete _i.ShadersStore[u+"VertexShader"],delete _i.ShadersStore[u+"PixelShader"],u=this.name+this._buildId,c.markAllAsDirty(),d=this._buildId),this._processDefines(h,c)&&(_i.RegisterShader(u,this._fragmentCompilationState._builtCompilationString,this._vertexCompilationState._builtCompilationString),fg.SetImmediate(()=>e.updateEffect(c.toString(),this._fragmentCompilationState.uniforms,this._fragmentCompilationState.samplers,{maxSimultaneousLights:this.maxSimultaneousLights},void 0,void 0,u,u))),this._checkInternals(f)}),e}createProceduralTexture(e,t){if(this.mode!==bi.ProceduralTexture)return L.Log("Incompatible material mode"),null;let i=this.name+this._buildId;const r=new er(i,e,null,t),s=new z(i+"Procedural",this.getScene());s.reservedDataStore={hidden:!0};const n=new Dl,o=this._processDefines(s,n);_i.RegisterShader(i,this._fragmentCompilationState._builtCompilationString,this._vertexCompilationState._builtCompilationString,this.shaderLanguage);let l=this.getScene().getEngine().createEffect({vertexElement:i,fragmentElement:i},[N.PositionKind],this._fragmentCompilationState.uniforms,this._fragmentCompilationState.samplers,n.toString(),o==null?void 0:o.fallbacks,void 0,void 0,void 0,this.shaderLanguage);r.nodeMaterialSource=this,r._setEffect(l);let u=this._buildId;const c=()=>{u!==this._buildId&&(delete _i.ShadersStore[i+"VertexShader"],delete _i.ShadersStore[i+"PixelShader"],i=this.name+this._buildId,n.markAllAsDirty(),u=this._buildId);const h=this._processDefines(s,n);h&&(_i.RegisterShader(i,this._fragmentCompilationState._builtCompilationString,this._vertexCompilationState._builtCompilationString,this.shaderLanguage),fg.SetImmediate(()=>{l=this.getScene().getEngine().createEffect({vertexElement:i,fragmentElement:i},[N.PositionKind],this._fragmentCompilationState.uniforms,this._fragmentCompilationState.samplers,n.toString(),h==null?void 0:h.fallbacks,void 0),r._setEffect(l)})),this._checkInternals(l)};return r.onBeforeGenerationObservable.add(()=>{c()}),this.onBuildObservable.add(()=>{c()}),r}_createEffectForParticles(e,t,i,r,s,n,o,l=""){let u=this.name+this._buildId+"_"+t;n||(n=new Dl),o||(o=this.getScene().getMeshByName(this.name+"Particle"),o||(o=new z(this.name+"Particle",this.getScene()),o.reservedDataStore={hidden:!0}));let c=this._buildId;const h=[];let d=l;if(!s){const f=this._processDefines(o,n);_i.RegisterShader(u,this._fragmentCompilationState._builtCompilationString,void 0,this.shaderLanguage),e.fillDefines(h,t,!1),d=h.join(`
`),s=this.getScene().getEngine().createEffectForParticles(u,this._fragmentCompilationState.uniforms,this._fragmentCompilationState.samplers,n.toString()+`
`+d,f==null?void 0:f.fallbacks,i,r,e,this.shaderLanguage),e.setCustomEffect(s,t)}s.onBindObservable.add(f=>{c!==this._buildId&&(delete _i.ShadersStore[u+"PixelShader"],u=this.name+this._buildId+"_"+t,n.markAllAsDirty(),c=this._buildId),h.length=0,e.fillDefines(h,t,!1);const p=h.join(`
`);p!==d&&(n.markAllAsDirty(),d=p);const g=this._processDefines(o,n);if(g){_i.RegisterShader(u,this._fragmentCompilationState._builtCompilationString,void 0,this.shaderLanguage),f=this.getScene().getEngine().createEffectForParticles(u,this._fragmentCompilationState.uniforms,this._fragmentCompilationState.samplers,n.toString()+`
`+d,g==null?void 0:g.fallbacks,i,r,e),e.setCustomEffect(f,t),this._createEffectForParticles(e,t,i,r,f,n,o,l);return}this._checkInternals(f)})}_checkInternals(e){if(this._sharedData.animatedInputs){const t=this.getScene(),i=t.getFrameId();if(this._animationFrame!==i){for(const r of this._sharedData.animatedInputs)r.animate(t);this._animationFrame=i}}for(const t of this._sharedData.bindableBlocks)t.bind(e,this);for(const t of this._sharedData.inputBlocks)t._transmit(e,this.getScene(),this)}createEffectForParticles(e,t,i){if(this.mode!==bi.Particle){L.Log("Incompatible material mode");return}this._createEffectForParticles(e,kt.BLENDMODE_ONEONE,t,i),this._createEffectForParticles(e,kt.BLENDMODE_MULTIPLY,t,i)}createAsShadowDepthWrapper(e){if(this.mode!==bi.Material){L.Log("Incompatible material mode");return}e.shadowDepthWrapper=new BABYLON.ShadowDepthWrapper(this,this.getScene())}_processDefines(e,t,i=!1,r){let s=null;const n=this.getScene();if(_y(n,t)&&t.markAsMiscDirty(),this._sharedData.blocksWithDefines.forEach(o=>{o.initializeDefines(e,this,t,i)}),this._sharedData.blocksWithDefines.forEach(o=>{o.prepareDefines(e,this,t,i,r)}),t.isDirty){const o=t._areLightsDisposed;t.markAsProcessed(),this._vertexCompilationState.compilationString=this._vertexCompilationState._builtCompilationString,this._fragmentCompilationState.compilationString=this._fragmentCompilationState._builtCompilationString,this._sharedData.repeatableContentBlocks.forEach(d=>{d.replaceRepeatableContent(this._vertexCompilationState,this._fragmentCompilationState,e,t)});const l=[];this._sharedData.dynamicUniformBlocks.forEach(d=>{d.updateUniformsAndSamples(this._vertexCompilationState,this,t,l)});const u=this._vertexCompilationState.uniforms;this._fragmentCompilationState.uniforms.forEach(d=>{u.indexOf(d)===-1&&u.push(d)});const c=this._vertexCompilationState.samplers;this._fragmentCompilationState.samplers.forEach(d=>{c.indexOf(d)===-1&&c.push(d)});const h=new Xn;this._sharedData.blocksWithFallbacks.forEach(d=>{d.provideFallbacks(e,h)}),s={lightDisposed:o,uniformBuffers:l,mergedUniforms:u,mergedSamplers:c,fallbacks:h}}return s}isReadyForSubMesh(e,t,i=!1){if(!this._buildWasSuccessful)return!1;const r=this.getScene();if(this._sharedData.animatedInputs){const u=r.getFrameId();if(this._animationFrame!==u){for(const c of this._sharedData.animatedInputs)c.animate(r);this._animationFrame=u}}const s=t._drawWrapper;if(s.effect&&this.isFrozen&&s._wasPreviouslyReady&&s._wasPreviouslyUsingInstances===i)return!0;(!t.materialDefines||typeof t.materialDefines=="string")&&(t.materialDefines=new Dl);const n=t.materialDefines;if(this._isReadyForSubMesh(t))return!0;const o=r.getEngine();if(this._prepareDefinesForAttributes(e,n),this._sharedData.blockingBlocks.some(u=>!u.isReady(e,this,n,i)))return!1;const l=this._processDefines(e,n,i,t);if(l){const u=t.effect,c=n.toString();let h=o.createEffect({vertex:"nodeMaterial"+this._buildId,fragment:"nodeMaterial"+this._buildId,vertexSource:this._vertexCompilationState.compilationString,fragmentSource:this._fragmentCompilationState.compilationString},{attributes:this._vertexCompilationState.attributes,uniformsNames:l.mergedUniforms,uniformBuffersNames:l.uniformBuffers,samplers:l.mergedSamplers,defines:c,fallbacks:l.fallbacks,onCompiled:this.onCompiled,onError:this.onError,multiTarget:n.PREPASS,indexParameters:{maxSimultaneousLights:this.maxSimultaneousLights,maxSimultaneousMorphTargets:n.NUM_MORPH_INFLUENCERS},shaderLanguage:this.shaderLanguage},o);if(h)if(this._onEffectCreatedObservable&&(Vc.effect=h,Vc.subMesh=t,this._onEffectCreatedObservable.notifyObservers(Vc)),this.allowShaderHotSwapping&&u&&!h.isReady()){if(h=u,n.markAsUnprocessed(),l.lightDisposed)return n._areLightsDisposed=!0,!1}else r.resetCachedMaterial(),t.setEffect(h,n,this._materialContext)}if(n.AREALIGHTUSED){for(let u=0;u<e.lightSources.length;u++)if(!e.lightSources[u]._isReady())return!1}return!t.effect||!t.effect.isReady()?!1:(n._renderId=r.getRenderId(),s._wasPreviouslyReady=!0,s._wasPreviouslyUsingInstances=i,this._checkScenePerformancePriority(),!0)}get compiledShaders(){return this._buildWasSuccessful||this.build(),`// Vertex shader
${this._vertexCompilationState.compilationString}

// Fragment shader
${this._fragmentCompilationState.compilationString}`}bindOnlyWorldMatrix(e){const t=this.getScene();if(!this._activeEffect)return;const i=this._sharedData.hints;i.needWorldViewMatrix&&e.multiplyToRef(t.getViewMatrix(),this._cachedWorldViewMatrix),i.needWorldViewProjectionMatrix&&e.multiplyToRef(t.getTransformMatrix(),this._cachedWorldViewProjectionMatrix);for(const r of this._sharedData.inputBlocks)r._transmitWorld(this._activeEffect,e,this._cachedWorldViewMatrix,this._cachedWorldViewProjectionMatrix)}bindForSubMesh(e,t,i){const r=this.getScene(),s=i.effect;if(!s)return;this._activeEffect=s,this.bindOnlyWorldMatrix(e);const n=this._mustRebind(r,s,i,t.visibility),o=this._sharedData;if(n){for(const l of o.bindableBlocks)l.bind(s,this,t,i);for(const l of o.forcedBindableBlocks)l.bind(s,this,t,i);for(const l of o.inputBlocks)l._transmit(s,r,this)}else if(!this.isFrozen)for(const l of o.forcedBindableBlocks)l.bind(s,this,t,i);this._afterBind(t,this._activeEffect,i)}getActiveTextures(){const e=super.getActiveTextures();return this._sharedData&&e.push(...this._sharedData.textureBlocks.filter(t=>t.texture).map(t=>t.texture)),e}getTextureBlocks(){return this._sharedData?this._sharedData.textureBlocks:[]}getAllTextureBlocks(){const e=[];for(const t of this.attachedBlocks)ht._BlockIsTextureBlock(t)&&e.push(t);return e}hasTexture(e){if(super.hasTexture(e))return!0;if(!this._sharedData)return!1;for(const t of this._sharedData.textureBlocks)if(t.texture===e)return!0;return!1}dispose(e,t,i){if(t)for(const r of this.getTextureBlocks().filter(s=>s.texture).map(s=>s.texture))r.dispose();for(const r of this.attachedBlocks)r.dispose();this.attachedBlocks.length=0,this._sharedData=null,this._vertexCompilationState=null,this._fragmentCompilationState=null,this.onBuildObservable.clear(),this.onBuildErrorObservable.clear(),this._imageProcessingObserver&&(this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),this._imageProcessingObserver=null),super.dispose(e,t,i)}_createNodeEditor(e){const t={nodeMaterial:this,...e};this.BJSNODEMATERIALEDITOR.NodeEditor.Show(t)}edit(e){return new Promise(t=>{if(this.BJSNODEMATERIALEDITOR=this.BJSNODEMATERIALEDITOR||this._getGlobalNodeMaterialEditor(),typeof this.BJSNODEMATERIALEDITOR>"u"){const i=e&&e.editorURL?e.editorURL:ht.EditorURL;ae.LoadBabylonScript(i,()=>{this.BJSNODEMATERIALEDITOR=this.BJSNODEMATERIALEDITOR||this._getGlobalNodeMaterialEditor(),this._createNodeEditor(e==null?void 0:e.nodeEditorConfig),t()})}else this._createNodeEditor(e==null?void 0:e.nodeEditorConfig),t()})}clear(){this._vertexOutputNodes.length=0,this._fragmentOutputNodes.length=0,this.attachedBlocks.length=0,this._buildIsInProgress=!1}setToDefault(){this.clear(),this.editorData=null;const e=new Ee("Position");e.setAsAttribute("position");const t=new Ee("World");t.setAsSystemValue(De.World);const i=new Jl("WorldPos");e.connectTo(i),t.connectTo(i);const r=new Ee("ViewProjection");r.setAsSystemValue(De.ViewProjection);const s=new Jl("WorldPos * ViewProjectionTransform");i.connectTo(s),r.connectTo(s);const n=new kl("VertexOutput");s.connectTo(n);const o=new Ee("color");o.value=new xe(.8,.8,.8,1);const l=new On("FragmentOutput");o.connectTo(l),this.addOutputNode(n),this.addOutputNode(l),this._mode=bi.Material}setToDefaultPostProcess(){this.clear(),this.editorData=null;const e=new Ee("Position");e.setAsAttribute("position2d");const t=new Ee("Constant1");t.isConstant=!0,t.value=1;const i=new zl("Position3D");e.connectTo(i),t.connectTo(i,{input:"w"});const r=new kl("VertexOutput");i.connectTo(r);const s=new Ee("Scale");s.visibleInInspector=!0,s.value=new Q(1,1);const n=new Hu("uv0");e.connectTo(n);const o=new fh("UV scale");n.connectTo(o),s.connectTo(o);const l=new $0("CurrentScreen");o.connectTo(l);const u=ae.GetAssetUrl("https://assets.babylonjs.com/core/nme/currentScreenPostProcess.png");l.texture=new Y(u,this.getScene());const c=new On("FragmentOutput");l.connectTo(c,{output:"rgba"}),this.addOutputNode(r),this.addOutputNode(c),this._mode=bi.PostProcess}setToDefaultProceduralTexture(){this.clear(),this.editorData=null;const e=new Ee("Position");e.setAsAttribute("position2d");const t=new Ee("Constant1");t.isConstant=!0,t.value=1;const i=new zl("Position3D");e.connectTo(i),t.connectTo(i,{input:"w"});const r=new kl("VertexOutput");i.connectTo(r);const s=new Ee("Time");s.value=0,s.min=0,s.max=0,s.isBoolean=!1,s.matrixMode=0,s.animationType=ys.Time,s.isConstant=!1;const n=new Ee("Color3");n.value=new ne(1,1,1),n.isConstant=!1;const o=new On("FragmentOutput"),l=new zl("VectorMerger");l.visibleInInspector=!1;const u=new N_("Cos");u.operation=Ye.Cos,e.connectTo(l),s.output.connectTo(u.input),u.output.connectTo(l.z),l.xyzOut.connectTo(o.rgb),this.addOutputNode(r),this.addOutputNode(o),this._mode=bi.ProceduralTexture}setToDefaultParticle(){this.clear(),this.editorData=null;const e=new Ee("uv");e.setAsAttribute("particle_uv");const t=new H0("ParticleTexture");e.connectTo(t);const i=new Ee("Color");i.setAsAttribute("particle_color");const r=new fh("Texture * Color");t.connectTo(r),i.connectTo(r);const s=new j0("ParticleRampGradient");r.connectTo(s);const n=new X0("ColorSplitter");i.connectTo(n);const o=new Y0("ParticleBlendMultiply");s.connectTo(o),t.connectTo(o,{output:"a"}),n.connectTo(o,{output:"a"});const l=new On("FragmentOutput");o.connectTo(l),this.addOutputNode(l),this._mode=bi.Particle}async loadAsync(e,t=""){return ht.ParseFromFileAsync("",e,this.getScene(),t,!0,this)}_gatherBlocks(e,t){if(t.indexOf(e)===-1){t.push(e);for(const i of e.inputs){const r=i.connectedPoint;if(r){const s=r.ownerBlock;s!==e&&this._gatherBlocks(s,t)}}if(e.isTeleportOut){const i=e;i.entryPoint&&this._gatherBlocks(i.entryPoint,t)}}}generateCode(){let e=[];const t=[],i=["const","var","let"];for(const n of this._vertexOutputNodes)this._gatherBlocks(n,t);const r=[];for(const n of this._fragmentOutputNodes)this._gatherBlocks(n,r);let s=`var nodeMaterial = new BABYLON.NodeMaterial("${this.name||"node material"}");
`;s+=`nodeMaterial.mode = BABYLON.NodeMaterialModes.${bi[this.mode]};
`;for(const n of t)n.isInput&&e.indexOf(n)===-1&&(s+=n._dumpCode(i,e));for(const n of r)n.isInput&&e.indexOf(n)===-1&&(s+=n._dumpCode(i,e));e=[],s+=`
// Connections
`;for(const n of this._vertexOutputNodes)s+=n._dumpCodeForOutputConnections(e);for(const n of this._fragmentOutputNodes)s+=n._dumpCodeForOutputConnections(e);s+=`
// Output nodes
`;for(const n of this._vertexOutputNodes)s+=`nodeMaterial.addOutputNode(${n._codeVariableName});
`;for(const n of this._fragmentOutputNodes)s+=`nodeMaterial.addOutputNode(${n._codeVariableName});
`;return s+=`nodeMaterial.build();
`,s}serialize(e){const t=e?{}:Me.Serialize(this);t.editorData=JSON.parse(JSON.stringify(this.editorData));let i=[];if(e)i=e;else{t.customType="BABYLON.NodeMaterial",t.outputNodes=[];for(const r of this._vertexOutputNodes)this._gatherBlocks(r,i),t.outputNodes.push(r.uniqueId);for(const r of this._fragmentOutputNodes)this._gatherBlocks(r,i),t.outputNodes.indexOf(r.uniqueId)===-1&&t.outputNodes.push(r.uniqueId)}t.blocks=[];for(const r of i)t.blocks.push(r.serialize());if(!e)for(const r of this.attachedBlocks)i.indexOf(r)===-1&&t.blocks.push(r.serialize());return t.uniqueId=this.uniqueId,t}_restoreConnections(e,t,i){for(const r of e.outputs)for(const s of t.blocks){const n=i[s.id];if(n){for(const o of s.inputs)if(i[o.targetBlockId]===e&&o.targetConnectionName===r.name){const l=n.getInputByName(o.inputName);if(!l||l.isConnected)continue;r.connectTo(l,!0),this._restoreConnections(n,t,i);continue}}}}parseSerializedObject(e,t="",i=!1,r){i||this.clear();const s={};for(const n of e.blocks){const o=oi(n.customType);if(o){const l=new o;l._deserialize(n,this.getScene(),t,r),s[n.id]=l,this.attachedBlocks.push(l)}}for(const n of this.attachedBlocks)if(n.isTeleportOut){const o=n,l=o._tempEntryPointUniqueId;l&&s[l].attachToEndpoint(o)}for(let n=0;n<e.blocks.length;n++){const o=e.blocks[n],l=s[o.id];l&&(l.inputs.length&&!i||this._restoreConnections(l,e,s))}if(e.outputNodes)for(const n of e.outputNodes)this.addOutputNode(s[n]);if(e.locations||e.editorData&&e.editorData.locations){const n=e.locations||e.editorData.locations;for(const l of n)s[l.blockId]&&(l.blockId=s[l.blockId].uniqueId);i&&this.editorData&&this.editorData.locations&&n.concat(this.editorData.locations),e.locations?this.editorData={locations:n}:(this.editorData=e.editorData,this.editorData.locations=n);const o=[];for(const l in s)o[l]=s[l].uniqueId;this.editorData.map=o}this.comment=e.comment,e.forceAlphaBlending!==void 0&&(this.forceAlphaBlending=e.forceAlphaBlending),e.alphaMode!==void 0&&(this.alphaMode=e.alphaMode),i||(this._mode=e.mode??bi.Material)}loadFromSerialization(e,t="",i=!1){this.parseSerializedObject(e,t,i)}clone(e,t=!1){const i=this.serialize(),r=Me.Clone(()=>new ht(e,this.getScene(),this.options),this);return r.id=e,r.name=e,r.parseSerializedObject(i),r._buildId=this._buildId,r.build(!1,!t),r}whenTexturesReadyAsync(){const e=[];return this.getActiveTextures().forEach(t=>{const i=t.getInternalTexture();i&&!i.isReady&&e.push(new Promise((r,s)=>{i.onLoadedObservable.addOnce(()=>{r()}),i.onErrorObservable.addOnce(n=>{s(n)})}))}),Promise.all(e)}static Parse(e,t,i="",r=0){const s=Me.Parse(()=>new ht(e.name,t,{shaderLanguage:r}),e,t,i);return s.parseSerializedObject(e,i),s.build(),s}static async ParseFromFileAsync(e,t,i,r="",s=!1,n,o,l){const u=n??new ht(e,i,l),c=await i._loadFileAsync(t),h=JSON.parse(c);return u.parseSerializedObject(h,r,void 0,o),s||u.build(),u}static ParseFromSnippetAsync(e,t=ze.LastCreatedScene,i="",r,s=!1,n=!1,o,l){return e==="_BLANK"?Promise.resolve(ht.CreateDefault("blank",t)):new Promise((u,c)=>{const h=new ss;h.addEventListener("readystatechange",()=>{if(h.readyState==4)if(h.status==200){const d=JSON.parse(JSON.parse(h.responseText).jsonPayload),f=JSON.parse(d.nodeMaterial);r||(r=Me.Parse(()=>new ht(e,t,l),f,t,i),r.uniqueId=t.getUniqueId()),r.parseSerializedObject(f,void 0,void 0,o),r.snippetId=e,r.sideOrientation=null;try{s||r.build()}catch(p){c(p)}n?r.whenTexturesReadyAsync().then(()=>{u(r)}).catch(p=>{c(p)}):u(r)}else c("Unable to load the snippet "+e)}),h.open("GET",this.SnippetUrl+"/"+e.replace(/#/g,"/")),h.send()})}static CreateDefault(e,t){const i=new ht(e,t);return i.setToDefault(),i.build(),i}}ht._BuildIdGenerator=0;ht.EditorURL=`${ae._DefaultCdnUrl}/v${st.Version}/nodeEditor/babylon.nodeEditor.js`;ht.SnippetUrl="https://snippet.babylonjs.com";ht.IgnoreTexturesAtLoadTime=!1;ht.DefaultShaderLanguage=0;ht.UseNativeShaderLanguageOfEngine=!1;C([F()],ht.prototype,"ignoreAlpha",void 0);C([F()],ht.prototype,"maxSimultaneousLights",void 0);C([F("mode")],ht.prototype,"_mode",void 0);C([F("comment")],ht.prototype,"comment",void 0);C([F()],ht.prototype,"forceAlphaBlending",void 0);B("BABYLON.NodeMaterial",ht);zn.prototype._projectOnTrianglesToRef=function(a,e,t,i,r,s){const n=V.Vector3[0],o=V.Vector3[1];let l=1/0;for(let u=this.indexStart;u<this.indexStart+this.indexCount-(3-i);u+=i){const c=t[u],h=t[u+1],d=t[u+2];if(r&&d===4294967295){u+=2;continue}const f=e[c],p=e[h],g=e[d];if(!f||!p||!g)continue;const _=m.ProjectOnTriangleToRef(a,f,p,g,o);_<l&&(n.copyFrom(o),l=_)}return s.copyFrom(n),l};zn.prototype._projectOnUnIndexedTrianglesToRef=function(a,e,t,i){const r=V.Vector3[0],s=V.Vector3[1];let n=1/0;for(let o=this.verticesStart;o<this.verticesStart+this.verticesCount;o+=3){const l=e[o],u=e[o+1],c=e[o+2],h=m.ProjectOnTriangleToRef(a,l,u,c,s);h<n&&(r.copyFrom(s),n=h)}return i.copyFrom(r),n};zn.prototype.projectToRef=function(a,e,t,i){const r=this.getMaterial();if(!r)return-1;let s=3,n=!1;switch(r.fillMode){case 3:case 5:case 6:case 8:return-1;case 7:s=1,n=!0;break}return r.fillMode===4?-1:!t.length&&this._mesh._unIndexed?this._projectOnUnIndexedTrianglesToRef(a,e,t,i):this._projectOnTrianglesToRef(a,e,t,s,n,i)};var Gi;(function(a){a[a.DEHYDRATED=0]="DEHYDRATED",a[a.HOVER=1]="HOVER",a[a.TOUCH=2]="TOUCH"})(Gi||(Gi={}));var pS;(function(a){a[a.DISABLED=0]="DISABLED",a[a.CENTERED_ON_CONTROLLER=1]="CENTERED_ON_CONTROLLER",a[a.CENTERED_IN_FRONT=2]="CENTERED_IN_FRONT"})(pS||(pS={}));const pa=[new m,new m,new m,new m];class hs extends ti{constructor(e,t){super(e),this._options=t,this._tmpRay=new Zt(new m,new m),this._attachController=i=>{if(this._controllers[i.uniqueId])return;const{touchCollisionMesh:r,touchCollisionMeshFunction:s,hydrateCollisionMeshFunction:n}=this._generateNewTouchPointMesh(),o=this._generateVisualCue();switch(this._controllers[i.uniqueId]={xrController:i,meshUnderPointer:null,nearInteractionTargetMesh:null,pick:null,stalePick:null,touchCollisionMesh:r,touchCollisionMeshFunction:s,hydrateCollisionMeshFunction:n,currentAnimationState:Gi.DEHYDRATED,grabRay:new Zt(new m,new m),hoverInteraction:!1,nearInteraction:!1,grabInteraction:!1,downTriggered:!1,id:hs._IdCounter++,pickedPointVisualCue:o},this._controllers[i.uniqueId]._worldScaleObserver=this._controllers[i.uniqueId]._worldScaleObserver||this._xrSessionManager.onWorldScaleFactorChangedObservable.add(l=>{if(l.newScaleFactor!==l.previousScaleFactor){this._controllers[i.uniqueId].touchCollisionMesh.dispose(),this._controllers[i.uniqueId].pickedPointVisualCue.dispose();const{touchCollisionMesh:u,touchCollisionMeshFunction:c,hydrateCollisionMeshFunction:h}=this._generateNewTouchPointMesh();this._controllers[i.uniqueId].touchCollisionMesh=u,this._controllers[i.uniqueId].touchCollisionMeshFunction=c,this._controllers[i.uniqueId].hydrateCollisionMeshFunction=h,this._controllers[i.uniqueId].pickedPointVisualCue=this._generateVisualCue()}}),this._attachedController?!this._options.enableNearInteractionOnAllControllers&&this._options.preferredHandedness&&i.inputSource.handedness===this._options.preferredHandedness&&(this._attachedController=i.uniqueId):this._options.enableNearInteractionOnAllControllers||(this._attachedController=i.uniqueId),i.inputSource.targetRayMode){case"tracked-pointer":return this._attachNearInteractionMode(i);case"gaze":return null;case"screen":return null}},this._controllers={},this._farInteractionFeature=null,this.selectionMeshDefaultColor=new ne(.8,.8,.8),this.selectionMeshPickedColor=new ne(.3,.3,1),this.alwaysHideSelectionMesh=!1,this._hoverRadius=.1,this._pickRadius=.02,this._controllerPickRadius=.03,this._nearGrabLengthScale=5,this._scene=this._xrSessionManager.scene,this._options.nearInteractionControllerMode===void 0&&(this._options.nearInteractionControllerMode=2),this._options.farInteractionFeature&&(this._farInteractionFeature=this._options.farInteractionFeature)}attach(){return super.attach()?(this._options.xrInput.controllers.forEach(this._attachController),this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable,this._attachController),this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable,e=>{this._detachController(e.uniqueId)}),this._scene.constantlyUpdateMeshUnderPointer=!0,!0):!1}detach(){return super.detach()?(Object.keys(this._controllers).forEach(e=>{this._detachController(e)}),!0):!1}getMeshUnderPointer(e){return this._controllers[e]?this._controllers[e].meshUnderPointer:null}getXRControllerByPointerId(e){const t=Object.keys(this._controllers);for(let i=0;i<t.length;++i)if(this._controllers[t[i]].id===e)return this._controllers[t[i]].xrController||null;return null}setFarInteractionFeature(e){this._farInteractionFeature=e}_nearPickPredicate(e){return e.isEnabled()&&e.isVisible&&e.isPickable&&e.isNearPickable}_nearGrabPredicate(e){return e.isEnabled()&&e.isVisible&&e.isPickable&&e.isNearGrabbable}_nearInteractionPredicate(e){return e.isEnabled()&&e.isVisible&&e.isPickable&&(e.isNearPickable||e.isNearGrabbable)}_controllerAvailablePredicate(e,t){let i=e;for(;i;){if(i.reservedDataStore&&i.reservedDataStore.nearInteraction&&i.reservedDataStore.nearInteraction.excludedControllerId===t)return!1;i=i.parent}return!0}_handleTransitionAnimation(e,t){var i;if(!(e.currentAnimationState===t||this._options.nearInteractionControllerMode!==2||(i=e.xrController)!=null&&i.inputSource.hand)){if(t>e.currentAnimationState)switch(e.currentAnimationState){case Gi.DEHYDRATED:if(e.hydrateCollisionMeshFunction(!0),t===Gi.HOVER)break;case Gi.HOVER:if(e.touchCollisionMeshFunction(!0),t===Gi.TOUCH)break}else switch(e.currentAnimationState){case Gi.TOUCH:if(e.touchCollisionMeshFunction(!1),t===Gi.HOVER)break;case Gi.HOVER:if(e.hydrateCollisionMeshFunction(!1),t===Gi.DEHYDRATED)break}e.currentAnimationState=t}}_processTouchPoint(e,t,i){var s;const r=this._controllers[e];r.grabRay.origin.copyFrom(t),i.toEulerAnglesToRef(V.Vector3[0]),r.grabRay.direction.copyFrom(V.Vector3[0]),this._options.nearInteractionControllerMode===2&&!((s=r.xrController)!=null&&s.inputSource.hand)&&(r.xrController.getWorldPointerRayToRef(this._tmpRay),r.grabRay.origin.addInPlace(this._tmpRay.direction.scale(.05))),r.grabRay.length=this._nearGrabLengthScale*this._hoverRadius*this._xrSessionManager.worldScalingFactor,r.touchCollisionMesh.position.copyFrom(r.grabRay.origin).scaleInPlace(this._xrSessionManager.worldScalingFactor)}_onXRFrame(e){Object.keys(this._controllers).forEach(t=>{var l;const i=this._controllers[t],r=(l=i.xrController)==null?void 0:l.inputSource.hand;if(!this._options.enableNearInteractionOnAllControllers&&t!==this._attachedController||!i.xrController||!r&&(!this._options.nearInteractionControllerMode||!i.xrController.inputSource.gamepad)){i.pick=null;return}if(i.hoverInteraction=!1,i.nearInteraction=!1,i.xrController){if(r){const u=r.get("index-finger-tip");if(u){const c=e.getJointPose(u,this._xrSessionManager.referenceSpace);if(c&&c.transform){const h=this._scene.useRightHandedSystem?1:-1;V.Vector3[0].set(c.transform.position.x,c.transform.position.y,c.transform.position.z*h),V.Quaternion[0].set(c.transform.orientation.x,c.transform.orientation.y,c.transform.orientation.z*h,c.transform.orientation.w*h),this._processTouchPoint(t,V.Vector3[0],V.Quaternion[0])}}}else if(i.xrController.inputSource.gamepad&&this._options.nearInteractionControllerMode!==0){let u=i.xrController.pointer;i.xrController.grip&&this._options.nearInteractionControllerMode===1&&(u=i.xrController.grip),this._processTouchPoint(t,u.position,u.rotationQuaternion)}}else return;const s=(u,c)=>{let h=null;return!c||!c.hit?h=u:!u||!u.hit||c.distance<u.distance?h=c:h=u,h},n=u=>{let c=new Qi,h=!1;const d=u&&u.pickedPoint&&u.hit;return u!=null&&u.pickedPoint&&(h=u.pickedPoint.x===0&&u.pickedPoint.y===0&&u.pickedPoint.z===0),d&&!h&&(c=u),c};if(!i.grabInteraction){let u=null,c=null;this._options.useUtilityLayer&&this._utilityLayerScene&&(c=this._pickWithSphere(i,this._hoverRadius*this._xrSessionManager.worldScalingFactor,this._utilityLayerScene,f=>this._nearInteractionPredicate(f)));const h=this._pickWithSphere(i,this._hoverRadius*this._xrSessionManager.worldScalingFactor,this._scene,f=>this._nearInteractionPredicate(f)),d=s(h,c);if(d&&d.hit&&(u=n(d),u.hit&&(i.hoverInteraction=!0)),i.hoverInteraction){let f=null;const p=(r?this._pickRadius:this._controllerPickRadius)*this._xrSessionManager.worldScalingFactor;this._options.useUtilityLayer&&this._utilityLayerScene&&(f=this._pickWithSphere(i,p,this._utilityLayerScene,b=>this._nearPickPredicate(b)));const g=this._pickWithSphere(i,p,this._scene,b=>this._nearPickPredicate(b)),_=s(g,f),S=n(_);S.hit&&(u=S,i.nearInteraction=!0)}i.stalePick=i.pick,i.pick=u,i.pick&&i.pick.pickedPoint&&i.pick.hit?(i.meshUnderPointer=i.pick.pickedMesh,i.pickedPointVisualCue.position.copyFrom(i.pick.pickedPoint),i.pickedPointVisualCue.isVisible=!this.alwaysHideSelectionMesh,this._farInteractionFeature&&this._farInteractionFeature.attached&&this._farInteractionFeature._setPointerSelectionDisabledByPointerId(i.id,!0)):(i.meshUnderPointer=null,i.pickedPointVisualCue.isVisible=!1,this._farInteractionFeature&&this._farInteractionFeature.attached&&this._farInteractionFeature._setPointerSelectionDisabledByPointerId(i.id,!1))}let o=Gi.DEHYDRATED;i.grabInteraction||i.nearInteraction?o=Gi.TOUCH:i.hoverInteraction&&(o=Gi.HOVER),this._handleTransitionAnimation(i,o)})}get _utilityLayerScene(){return this._options.customUtilityLayerScene||gt.DefaultUtilityLayer.utilityLayerScene}_generateVisualCue(){const e=this._options.useUtilityLayer?this._options.customUtilityLayerScene||gt.DefaultUtilityLayer.utilityLayerScene:this._scene,t=Ti("nearInteraction",{diameter:.0035*3*this._xrSessionManager.worldScalingFactor},e);t.bakeCurrentTransformIntoVertices(),t.isPickable=!1,t.isVisible=!1,t.rotationQuaternion=re.Identity();const i=new Ut("targetMat",e);return i.specularColor=ne.Black(),i.emissiveColor=this.selectionMeshDefaultColor,i.backFaceCulling=!1,t.material=i,t}_isControllerReadyForNearInteraction(e){return this._farInteractionFeature?this._farInteractionFeature._getPointerSelectionDisabledByPointerId(e):!0}_attachNearInteractionMode(e){const t=this._controllers[e.uniqueId],i={pointerId:t.id,pointerType:"xr-near"};t.onFrameObserver=this._xrSessionManager.onXRFrameObservable.add(()=>{!this._options.enableNearInteractionOnAllControllers&&e.uniqueId!==this._attachedController||!t.xrController||!t.xrController.inputSource.hand&&(!this._options.nearInteractionControllerMode||!t.xrController.inputSource.gamepad)||(t.pick&&(t.pick.ray=t.grabRay),t.pick&&this._isControllerReadyForNearInteraction(t.id)&&this._scene.simulatePointerMove(t.pick,i),t.nearInteraction&&t.pick&&t.pick.hit?t.nearInteractionTargetMesh||(this._scene.simulatePointerDown(t.pick,i),t.nearInteractionTargetMesh=t.meshUnderPointer,t.downTriggered=!0):t.nearInteractionTargetMesh&&t.stalePick&&(this._scene.simulatePointerUp(t.stalePick,i),t.downTriggered=!1,t.nearInteractionTargetMesh=null))});const r=s=>{this._options.enableNearInteractionOnAllControllers||e.uniqueId===this._attachedController&&this._isControllerReadyForNearInteraction(t.id)?(t.pick&&(t.pick.ray=t.grabRay),s&&t.pick&&t.meshUnderPointer&&this._nearGrabPredicate(t.meshUnderPointer)?(t.grabInteraction=!0,t.pickedPointVisualCue.isVisible=!1,this._scene.simulatePointerDown(t.pick,i),t.downTriggered=!0):!s&&t.pick&&t.grabInteraction&&(this._scene.simulatePointerUp(t.pick,i),t.downTriggered=!1,t.grabInteraction=!1,t.pickedPointVisualCue.isVisible=!this.alwaysHideSelectionMesh)):s&&!this._options.enableNearInteractionOnAllControllers&&!this._options.disableSwitchOnClick&&(this._attachedController=e.uniqueId)};if(e.inputSource.gamepad){const s=n=>{t.squeezeComponent=n.getComponent("grasp"),t.squeezeComponent?t.onSqueezeButtonChangedObserver=t.squeezeComponent.onButtonStateChangedObservable.add(o=>{if(o.changes.pressed){const l=o.changes.pressed.current;r(l)}}):(t.selectionComponent=n.getMainComponent(),t.onButtonChangedObserver=t.selectionComponent.onButtonStateChangedObservable.add(o=>{if(o.changes.pressed){const l=o.changes.pressed.current;r(l)}}))};e.motionController?s(e.motionController):e.onMotionControllerInitObservable.add(s)}else{const s=o=>{t.xrController&&o.inputSource===t.xrController.inputSource&&t.pick&&this._isControllerReadyForNearInteraction(t.id)&&t.meshUnderPointer&&this._nearGrabPredicate(t.meshUnderPointer)&&(t.grabInteraction=!0,t.pickedPointVisualCue.isVisible=!1,this._scene.simulatePointerDown(t.pick,i),t.downTriggered=!0)},n=o=>{t.xrController&&o.inputSource===t.xrController.inputSource&&t.pick&&this._isControllerReadyForNearInteraction(t.id)&&(this._scene.simulatePointerUp(t.pick,i),t.grabInteraction=!1,t.pickedPointVisualCue.isVisible=!this.alwaysHideSelectionMesh,t.downTriggered=!1)};t.eventListeners={selectend:n,selectstart:s},this._xrSessionManager.session.addEventListener("selectstart",s),this._xrSessionManager.session.addEventListener("selectend",n)}}_detachController(e){const t=this._controllers[e];if(t&&(t.squeezeComponent&&t.onSqueezeButtonChangedObserver&&t.squeezeComponent.onButtonStateChangedObservable.remove(t.onSqueezeButtonChangedObserver),t.selectionComponent&&t.onButtonChangedObserver&&t.selectionComponent.onButtonStateChangedObservable.remove(t.onButtonChangedObserver),t.onFrameObserver&&this._xrSessionManager.onXRFrameObservable.remove(t.onFrameObserver),t.eventListeners&&Object.keys(t.eventListeners).forEach(i=>{const r=t.eventListeners&&t.eventListeners[i];r&&this._xrSessionManager.session.removeEventListener(i,r)}),t.touchCollisionMesh.dispose(),t.pickedPointVisualCue.dispose(),this._xrSessionManager.runInXRFrame(()=>{if(!t.downTriggered)return;const i={pointerId:t.id,pointerType:"xr-near"};this._scene.simulatePointerUp(new Qi,i)}),t._worldScaleObserver&&this._xrSessionManager.onWorldScaleFactorChangedObservable.remove(t._worldScaleObserver),delete this._controllers[e],this._attachedController===e)){const i=Object.keys(this._controllers);i.length?this._attachedController=i[0]:this._attachedController=""}}_generateNewTouchPointMesh(){const e=this._xrSessionManager.worldScalingFactor,t=this._options.useUtilityLayer?this._options.customUtilityLayerScene||gt.DefaultUtilityLayer.utilityLayerScene:this._scene,i=Ti("PickSphere",{diameter:1*e},t);if(i.isVisible=!1,this._options.motionControllerOrbMaterial)i.material=this._options.motionControllerOrbMaterial;else{let O;this._options.motionControllerTouchMaterialSnippetUrl?O=ht.ParseFromFileAsync("motionControllerTouchMaterial",this._options.motionControllerTouchMaterialSnippetUrl,t):O=ht.ParseFromSnippetAsync("8RUNKL#3",t),O.then(w=>{i.material=w}).catch(w=>{L.Warn(`Error creating touch material in WebXRNearInteraction: ${w}`)})}const r=new Rn;r.setEasingMode(Ma.EASINGMODE_EASEINOUT);const s=new m(this._controllerPickRadius,this._controllerPickRadius,this._controllerPickRadius).scaleInPlace(e),n=this._controllerPickRadius*(4/3),o=new m(n,n,n).scaleInPlace(e),l=this._controllerPickRadius*(7/6),u=new m(l,l,l).scaleInPlace(e),c=this._controllerPickRadius*(4/5),h=new m(c,c,c).scaleInPlace(e),d=this._controllerPickRadius*(3/2),f=new m(d,d,d).scaleInPlace(e),p=[{frame:0,value:s},{frame:10,value:f},{frame:18,value:o}],g=[{frame:0,value:o},{frame:10,value:h},{frame:18,value:s}],_=[{frame:0,value:m.ZeroReadOnly},{frame:12,value:u},{frame:15,value:s}],S=[{frame:0,value:s},{frame:10,value:m.ZeroReadOnly},{frame:15,value:m.ZeroReadOnly}],b=new Le("touch","scaling",60,Le.ANIMATIONTYPE_VECTOR3,Le.ANIMATIONLOOPMODE_CONSTANT),y=new Le("release","scaling",60,Le.ANIMATIONTYPE_VECTOR3,Le.ANIMATIONLOOPMODE_CONSTANT),T=new Le("hydrate","scaling",60,Le.ANIMATIONTYPE_VECTOR3,Le.ANIMATIONLOOPMODE_CONSTANT),v=new Le("dehydrate","scaling",60,Le.ANIMATIONTYPE_VECTOR3,Le.ANIMATIONLOOPMODE_CONSTANT);return b.setEasingFunction(r),y.setEasingFunction(r),T.setEasingFunction(r),v.setEasingFunction(r),b.setKeys(p),y.setKeys(g),T.setKeys(_),v.setKeys(S),{touchCollisionMesh:i,touchCollisionMeshFunction:O=>{const w=O?b:y;t.beginDirectAnimation(i,[w],0,18,!1,1)},hydrateCollisionMeshFunction:O=>{const w=O?T:v;O&&(i.isVisible=!0),t.beginDirectAnimation(i,[w],0,15,!1,1,()=>{O||(i.isVisible=!1)})}}}_pickWithSphere(e,t,i,r){const s=new Qi;if(s.distance=1/0,e.touchCollisionMesh&&e.xrController){const n=e.touchCollisionMesh.position,o=pg.CreateFromCenterAndRadius(n,t);for(let l=0;l<i.meshes.length;l++){const u=i.meshes[l];if(!r(u)||!this._controllerAvailablePredicate(u,e.xrController.uniqueId))continue;const c=hs.PickMeshWithSphere(u,o);c&&c.hit&&c.distance<s.distance&&(s.hit=c.hit,s.pickedMesh=u,s.pickedPoint=c.pickedPoint,s.aimTransform=e.xrController.pointer,s.gripTransform=e.xrController.grip||null,s.originMesh=e.touchCollisionMesh,s.distance=c.distance,s.bu=c.bu,s.bv=c.bv,s.faceId=c.faceId,s.subMeshId=c.subMeshId)}}return s}static PickMeshWithSphere(e,t,i=!1){const r=e.subMeshes,s=new Qi,n=e.getBoundingInfo();if(!e._generatePointsArray()||!e.subMeshes||!n||!i&&!pg.Intersects(n.boundingSphere,t))return s;const o=pa[0],l=pa[1];pa[2].setAll(0),pa[3].setAll(0);const u=new Zt(pa[2],pa[3],1);let c=1/0,h,d,f,p;const g=V.Vector3[2],_=V.Matrix[0];_.copyFrom(e.getWorldMatrix()),_.invert(),m.TransformCoordinatesToRef(t.center,_,g);for(let S=0;S<r.length;S++)r[S].projectToRef(g,e._positions,e.getIndices(),l),m.TransformCoordinatesToRef(l,e.getWorldMatrix(),l),h=m.Distance(l,t.center),f=m.DistanceSquared(l,e.getAbsolutePosition()),d=m.DistanceSquared(t.center,e.getAbsolutePosition()),d!==-1&&f!==-1&&f>d&&(h=0,l.copyFrom(t.center)),h!==-1&&h<c&&(c=h,Zt.CreateFromToToRef(t.center,l,u),u.length=c*2,p=u.intersectsMesh(e),o.copyFrom(l));return c<t.radius&&(s.hit=!0,s.distance=c,s.pickedMesh=e,s.pickedPoint=o.clone(),p&&p.bu!==null&&p.bv!==null&&(s.faceId=p.faceId,s.subMeshId=p.subMeshId,s.bu=p.bu,s.bv=p.bv)),s}}hs._IdCounter=200;hs.Name=ke.NEAR_INTERACTION;hs.Version=1;Tt.AddWebXRFeature(hs.Name,(a,e)=>()=>new hs(a,e),hs.Version,!0);class i1{constructor(e,t,i){this.element=e,this.sessionMode=t,this.referenceSpaceType=i}update(e){}}class FW{}class F_{constructor(e,t){if(this._scene=e,this.options=t,this._activeButton=null,this._buttons=[],this.activeButtonChangedObservable=new j,this._onSessionGranted=r=>{this._helper&&this._enterXRWithButtonIndex(0)},this.overlay=document.createElement("div"),this.overlay.classList.add("xr-button-overlay"),!t.ignoreSessionGrantedEvent&&navigator.xr&&navigator.xr.addEventListener("sessiongranted",this._onSessionGranted),typeof window<"u"&&window.location&&window.location.protocol==="http:"&&window.location.hostname!=="localhost")throw ae.Warn("WebXR can only be served over HTTPS"),new Error("WebXR can only be served over HTTPS");if(t.customButtons)this._buttons=t.customButtons;else{this.overlay.style.cssText="z-index:11;position: absolute; right: 20px;bottom: 50px;";const r=t.sessionMode||"immersive-vr",s=t.referenceSpaceType||"local-floor";let o=".babylonVRicon { color: #868686; border-color: #868686; border-style: solid; margin-left: 10px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-image: url("+(typeof SVGSVGElement>"u"?"https://cdn.babylonjs.com/Assets/vrButton.png":"data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%222048%22%20height%3D%221152%22%20viewBox%3D%220%200%202048%201152%22%20version%3D%221.1%22%3E%3Cpath%20transform%3D%22rotate%28180%201024%2C576.0000000000001%29%22%20d%3D%22m1109%2C896q17%2C0%2030%2C-12t13%2C-30t-12.5%2C-30.5t-30.5%2C-12.5l-170%2C0q-18%2C0%20-30.5%2C12.5t-12.5%2C30.5t13%2C30t30%2C12l170%2C0zm-85%2C256q59%2C0%20132.5%2C-1.5t154.5%2C-5.5t164.5%2C-11.5t163%2C-20t150%2C-30t124.5%2C-41.5q23%2C-11%2042%2C-24t38%2C-30q27%2C-25%2041%2C-61.5t14%2C-72.5l0%2C-257q0%2C-123%20-47%2C-232t-128%2C-190t-190%2C-128t-232%2C-47l-81%2C0q-37%2C0%20-68.5%2C14t-60.5%2C34.5t-55.5%2C45t-53%2C45t-53%2C34.5t-55.5%2C14t-55.5%2C-14t-53%2C-34.5t-53%2C-45t-55.5%2C-45t-60.5%2C-34.5t-68.5%2C-14l-81%2C0q-123%2C0%20-232%2C47t-190%2C128t-128%2C190t-47%2C232l0%2C257q0%2C68%2038%2C115t97%2C73q54%2C24%20124.5%2C41.5t150%2C30t163%2C20t164.5%2C11.5t154.5%2C5.5t132.5%2C1.5zm939%2C-298q0%2C39%20-24.5%2C67t-58.5%2C42q-54%2C23%20-122%2C39.5t-143.5%2C28t-155.5%2C19t-157%2C11t-148.5%2C5t-129.5%2C1.5q-59%2C0%20-130%2C-1.5t-148%2C-5t-157%2C-11t-155.5%2C-19t-143.5%2C-28t-122%2C-39.5q-34%2C-14%20-58.5%2C-42t-24.5%2C-67l0%2C-257q0%2C-106%2040.5%2C-199t110%2C-162.5t162.5%2C-109.5t199%2C-40l81%2C0q27%2C0%2052%2C14t50%2C34.5t51%2C44.5t55.5%2C44.5t63.5%2C34.5t74%2C14t74%2C-14t63.5%2C-34.5t55.5%2C-44.5t51%2C-44.5t50%2C-34.5t52%2C-14l14%2C0q37%2C0%2070%2C0.5t64.5%2C4.5t63.5%2C12t68%2C23q71%2C30%20128.5%2C78.5t98.5%2C110t63.5%2C133.5t22.5%2C149l0%2C257z%22%20fill%3D%22white%22%20/%3E%3C/svg%3E%0A")+"); background-size: 80%; background-repeat:no-repeat; background-position: center; border: none; outline: none; transition: transform 0.125s ease-out } .babylonVRicon:hover { transform: scale(1.05) } .babylonVRicon:active {background-color: rgba(51,51,51,1) } .babylonVRicon:focus {background-color: rgba(51,51,51,1) }";o+='.babylonVRicon.vrdisplaypresenting { background-image: none;} .vrdisplaypresenting::after { content: "EXIT"} .xr-error::after { content: "ERROR"}';const l=document.createElement("style");l.appendChild(document.createTextNode(o)),document.getElementsByTagName("head")[0].appendChild(l);const u=document.createElement("button");u.className="babylonVRicon",u.title=`${r} - ${s}`,this._buttons.push(new i1(u,r,s)),this._buttons[this._buttons.length-1].update=function(c){this.element.style.display=c===null||c===this?"":"none",u.className="babylonVRicon"+(c===this?" vrdisplaypresenting":"")},this._updateButtons(null)}const i=e.getEngine().getInputElement();i&&i.parentNode&&(i.parentNode.appendChild(this.overlay),e.onDisposeObservable.addOnce(()=>{this.dispose()}))}async setHelperAsync(e,t){this._helper=e,this._renderTarget=t;const i=this._buttons.map(s=>e.sessionManager.isSessionSupportedAsync(s.sessionMode));e.onStateChangedObservable.add(s=>{s==3&&this._updateButtons(null)}),(await Promise.all(i)).forEach((s,n)=>{s?(this.overlay.appendChild(this._buttons[n].element),this._buttons[n].element.onclick=this._enterXRWithButtonIndex.bind(this,n)):ae.Warn(`Session mode "${this._buttons[n].sessionMode}" not supported in browser`)})}static async CreateAsync(e,t,i){const r=new F_(e,i);return await r.setHelperAsync(t,i.renderTarget||void 0),r}async _enterXRWithButtonIndex(e=0){if(this._helper.state==2)await this._helper.exitXRAsync(),this._updateButtons(null);else if(this._helper.state==3)try{await this._helper.enterXRAsync(this._buttons[e].sessionMode,this._buttons[e].referenceSpaceType,this._renderTarget,{optionalFeatures:this.options.optionalFeatures,requiredFeatures:this.options.requiredFeatures}),this._updateButtons(this._buttons[e])}catch(t){this._updateButtons(null);const i=this._buttons[e].element,r=i.title;i.title="Error entering XR session : "+r,i.classList.add("xr-error"),this.options.onError&&this.options.onError(t)}}dispose(){const e=this._scene.getEngine().getInputElement();e&&e.parentNode&&e.parentNode.contains(this.overlay)&&e.parentNode.removeChild(this.overlay),this.activeButtonChangedObservable.clear(),navigator.xr.removeEventListener("sessiongranted",this._onSessionGranted)}_updateButtons(e){this._activeButton=e,this._buttons.forEach(t=>{t.update(this._activeButton)}),this.activeButtonChangedObservable.notifyObservers(this._activeButton)}}var mS;(function(a){a.WRIST="wrist",a.THUMB="thumb",a.INDEX="index",a.MIDDLE="middle",a.RING="ring",a.LITTLE="little"})(mS||(mS={}));var _S;(function(a){a.WRIST="wrist",a.THUMB_METACARPAL="thumb-metacarpal",a.THUMB_PHALANX_PROXIMAL="thumb-phalanx-proximal",a.THUMB_PHALANX_DISTAL="thumb-phalanx-distal",a.THUMB_TIP="thumb-tip",a.INDEX_FINGER_METACARPAL="index-finger-metacarpal",a.INDEX_FINGER_PHALANX_PROXIMAL="index-finger-phalanx-proximal",a.INDEX_FINGER_PHALANX_INTERMEDIATE="index-finger-phalanx-intermediate",a.INDEX_FINGER_PHALANX_DISTAL="index-finger-phalanx-distal",a.INDEX_FINGER_TIP="index-finger-tip",a.MIDDLE_FINGER_METACARPAL="middle-finger-metacarpal",a.MIDDLE_FINGER_PHALANX_PROXIMAL="middle-finger-phalanx-proximal",a.MIDDLE_FINGER_PHALANX_INTERMEDIATE="middle-finger-phalanx-intermediate",a.MIDDLE_FINGER_PHALANX_DISTAL="middle-finger-phalanx-distal",a.MIDDLE_FINGER_TIP="middle-finger-tip",a.RING_FINGER_METACARPAL="ring-finger-metacarpal",a.RING_FINGER_PHALANX_PROXIMAL="ring-finger-phalanx-proximal",a.RING_FINGER_PHALANX_INTERMEDIATE="ring-finger-phalanx-intermediate",a.RING_FINGER_PHALANX_DISTAL="ring-finger-phalanx-distal",a.RING_FINGER_TIP="ring-finger-tip",a.PINKY_FINGER_METACARPAL="pinky-finger-metacarpal",a.PINKY_FINGER_PHALANX_PROXIMAL="pinky-finger-phalanx-proximal",a.PINKY_FINGER_PHALANX_INTERMEDIATE="pinky-finger-phalanx-intermediate",a.PINKY_FINGER_PHALANX_DISTAL="pinky-finger-phalanx-distal",a.PINKY_FINGER_TIP="pinky-finger-tip"})(_S||(_S={}));const Mr=["wrist","thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip","index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip","middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip","ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip","pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"],r1={wrist:["wrist"],thumb:["thumb-metacarpal","thumb-phalanx-proximal","thumb-phalanx-distal","thumb-tip"],index:["index-finger-metacarpal","index-finger-phalanx-proximal","index-finger-phalanx-intermediate","index-finger-phalanx-distal","index-finger-tip"],middle:["middle-finger-metacarpal","middle-finger-phalanx-proximal","middle-finger-phalanx-intermediate","middle-finger-phalanx-distal","middle-finger-tip"],ring:["ring-finger-metacarpal","ring-finger-phalanx-proximal","ring-finger-phalanx-intermediate","ring-finger-phalanx-distal","ring-finger-tip"],little:["pinky-finger-metacarpal","pinky-finger-phalanx-proximal","pinky-finger-phalanx-intermediate","pinky-finger-phalanx-distal","pinky-finger-tip"]};class s1{get handMesh(){return this._handMesh}getHandPartMeshes(e){return r1[e].map(t=>this._jointMeshes[Mr.indexOf(t)])}getJointMesh(e){return this._jointMeshes[Mr.indexOf(e)]}constructor(e,t,i,r,s=!1,n=!1,o=1){var l;this.xrController=e,this._jointMeshes=t,this._handMesh=i,this.rigMapping=r,this._leftHandedMeshes=s,this._jointsInvisible=n,this._jointScaleFactor=o,this.onHandMeshSetObservable=new j,this._jointTransforms=new Array(Mr.length),this._jointTransformMatrices=new Float32Array(Mr.length*16),this._tempJointMatrix=new $,this._jointRadii=new Float32Array(Mr.length),this._scene=t[0].getScene();for(let u=0;u<this._jointTransforms.length;u++)this._jointTransforms[u]=new Bi(Mr[u],this._scene),this._jointTransforms[u].rotationQuaternion=new re,t[u].rotationQuaternion?t[u].rotationQuaternion=new re:(l=t[u].rotationQuaternion)==null||l.set(0,0,0,1);i&&this.setHandMesh(i,r),this.xrController.motionController&&this.xrController.motionController.rootMesh&&this.xrController.motionController.rootMesh.dispose(!1,!0),this.xrController.onMotionControllerInitObservable.add(u=>{u._doNotLoadControllerMesh=!0})}setHandMesh(e,t,i){if(this._handMesh=e,e.alwaysSelectAsActiveMesh=!0,e.getChildMeshes().forEach(r=>{r.alwaysSelectAsActiveMesh=!0}),this._handMesh.skeleton){const r=this._handMesh.skeleton;Mr.forEach((s,n)=>{const o=r.getBoneIndexByName(t?t[s]:s);o!==-1&&r.bones[o].linkTransformNode(this._jointTransforms[n])})}this.onHandMeshSetObservable.notifyObservers(this)}updateFromXRFrame(e,t){const i=this.xrController.inputSource.hand;if(!i)return;const r=i,s=Mr.map(o=>r[o]||i.get(o));let n=!1;if(e.fillPoses&&e.fillJointRadii)n=e.fillPoses(s,t,this._jointTransformMatrices)&&e.fillJointRadii(s,this._jointRadii);else if(e.getJointPose){n=!0;for(let o=0;o<s.length;o++){const l=e.getJointPose(s[o],t);if(l)this._jointTransformMatrices.set(l.transform.matrix,o*16),this._jointRadii[o]=l.radius||.008;else{n=!1;break}}}n&&(Mr.forEach((o,l)=>{const u=this._jointTransforms[l];$.FromArrayToRef(this._jointTransformMatrices,l*16,this._tempJointMatrix),this._tempJointMatrix.decompose(void 0,u.rotationQuaternion,u.position);const c=this._jointRadii[l]*this._jointScaleFactor,h=this._jointMeshes[l];h.isVisible=!this._handMesh&&!this._jointsInvisible,h.position.copyFrom(u.position),h.rotationQuaternion.copyFrom(u.rotationQuaternion),h.scaling.setAll(c),this._scene.useRightHandedSystem||(h.position.z*=-1,h.rotationQuaternion.z*=-1,h.rotationQuaternion.w*=-1,this._leftHandedMeshes&&this._handMesh&&(u.position.z*=-1,u.rotationQuaternion.z*=-1,u.rotationQuaternion.w*=-1))}),this._handMesh&&(this._handMesh.isVisible=!0))}dispose(e=!1){var t;this._handMesh&&(e?((t=this._handMesh.skeleton)==null||t.dispose(),this._handMesh.dispose(!1,!0)):this._handMesh.isVisible=!1),this._jointTransforms.forEach(i=>i.dispose()),this._jointTransforms.length=0,this.onHandMeshSetObservable.clear()}}class je extends ti{static _GenerateTrackedJointMeshes(e,t=$o("jointParent",je._ICOSPHERE_PARAMS)){const i={};return["left","right"].map(r=>{var n,o,l,u;const s=[];t.isVisible=!!((n=e.jointMeshes)!=null&&n.keepOriginalVisible);for(let c=0;c<Mr.length;++c){let h=t.createInstance(`${r}-handJoint-${c}`);if((o=e.jointMeshes)!=null&&o.onHandJointMeshGenerated){const d=e.jointMeshes.onHandJointMeshGenerated(h,c,r);d&&d!==h&&(h.dispose(),h=d)}if(h.isPickable=!1,(l=e.jointMeshes)!=null&&l.enablePhysics){const d=((u=e.jointMeshes)==null?void 0:u.physicsProps)||{};h.scaling.setAll(.02);const f=d.impostorType!==void 0?d.impostorType:ve.SphereImpostor;h.physicsImpostor=new ve(h,f,{mass:0,...d})}h.rotationQuaternion=new re,h.isVisible=!1,s.push(h)}i[r]=s}),{left:i.left,right:i.right}}static _GenerateDefaultHandMeshesAsync(e,t,i){return new Promise(async r=>{var p,g,_,S,b,y;const s={};(g=(p=je._RightHandGLB)==null?void 0:p.meshes[1])!=null&&g.isDisposed()&&(je._RightHandGLB=null),(S=(_=je._LeftHandGLB)==null?void 0:_.meshes[1])!=null&&S.isDisposed()&&(je._LeftHandGLB=null);const n=!!(je._RightHandGLB&&je._LeftHandGLB),o=ae.GetAssetUrl(je.DEFAULT_HAND_MODEL_BASE_URL),l=await Promise.all([je._RightHandGLB||At.ImportMeshAsync("",o,je.DEFAULT_HAND_MODEL_RIGHT_FILENAME,e),je._LeftHandGLB||At.ImportMeshAsync("",o,je.DEFAULT_HAND_MODEL_LEFT_FILENAME,e)]);je._RightHandGLB=l[0],je._LeftHandGLB=l[1];const u=ae.GetAssetUrl(je.DEFAULT_HAND_MODEL_SHADER_URL),c=await ht.ParseFromFileAsync("handShader",u,e,void 0,!0);c.needDepthPrePass=!0,c.transparencyMode=ft.MATERIAL_ALPHABLEND,c.alphaMode=2,c.build(!1);const h={base:ne.FromInts(116,63,203),fresnel:ne.FromInts(149,102,229),fingerColor:ne.FromInts(177,130,255),tipFresnel:ne.FromInts(220,200,255),...(b=i==null?void 0:i.handMeshes)==null?void 0:b.customColors},d={base:c.getBlockByName("baseColor"),fresnel:c.getBlockByName("fresnelColor"),fingerColor:c.getBlockByName("fingerColor"),tipFresnel:c.getBlockByName("tipFresnelColor")};d.base.value=h.base,d.fresnel.value=h.fresnel,d.fingerColor.value=h.fingerColor,d.tipFresnel.value=h.tipFresnel;const f=(y=t._getBaseLayerWrapper())==null?void 0:y.isMultiview;["left","right"].forEach(T=>{var R;const v=T=="left"?je._LeftHandGLB:je._RightHandGLB;if(!v)throw new Error("Could not load hand model");const E=v.meshes[1];E._internalAbstractMeshDataInfo._computeBonesUsingShaders=!0,!f&&!((R=i==null?void 0:i.handMeshes)!=null&&R.disableHandShader)&&(E.material=c.clone(`${T}HandShaderClone`,!0)),E.isVisible=!1,s[T]=E,!n&&!e.useRightHandedSystem&&v.meshes[1].rotate(qi.Y,Math.PI)}),c.dispose(),r({left:s.left,right:s.right})})}static _GenerateDefaultHandMeshRigMapping(e){const t=e=="right"?"R":"L";return{wrist:`wrist_${t}`,"thumb-metacarpal":`thumb_metacarpal_${t}`,"thumb-phalanx-proximal":`thumb_proxPhalanx_${t}`,"thumb-phalanx-distal":`thumb_distPhalanx_${t}`,"thumb-tip":`thumb_tip_${t}`,"index-finger-metacarpal":`index_metacarpal_${t}`,"index-finger-phalanx-proximal":`index_proxPhalanx_${t}`,"index-finger-phalanx-intermediate":`index_intPhalanx_${t}`,"index-finger-phalanx-distal":`index_distPhalanx_${t}`,"index-finger-tip":`index_tip_${t}`,"middle-finger-metacarpal":`middle_metacarpal_${t}`,"middle-finger-phalanx-proximal":`middle_proxPhalanx_${t}`,"middle-finger-phalanx-intermediate":`middle_intPhalanx_${t}`,"middle-finger-phalanx-distal":`middle_distPhalanx_${t}`,"middle-finger-tip":`middle_tip_${t}`,"ring-finger-metacarpal":`ring_metacarpal_${t}`,"ring-finger-phalanx-proximal":`ring_proxPhalanx_${t}`,"ring-finger-phalanx-intermediate":`ring_intPhalanx_${t}`,"ring-finger-phalanx-distal":`ring_distPhalanx_${t}`,"ring-finger-tip":`ring_tip_${t}`,"pinky-finger-metacarpal":`little_metacarpal_${t}`,"pinky-finger-phalanx-proximal":`little_proxPhalanx_${t}`,"pinky-finger-phalanx-intermediate":`little_intPhalanx_${t}`,"pinky-finger-phalanx-distal":`little_distPhalanx_${t}`,"pinky-finger-tip":`little_tip_${t}`}}isCompatible(){return typeof XRHand<"u"}getHandByControllerId(e){return this._attachedHands[e]}getHandByHandedness(e){return e=="none"?null:this._trackingHands[e]}constructor(e,t){super(e),this.options=t,this._attachedHands={},this._trackingHands={left:null,right:null},this._handResources={jointMeshes:null,handMeshes:null,rigMappings:null},this._worldScaleObserver=null,this.onHandAddedObservable=new j,this.onHandRemovedObservable=new j,this._attachHand=s=>{var l,u,c;if(!s.inputSource.hand||s.inputSource.handedness=="none"||!this._handResources.jointMeshes)return;const n=s.inputSource.handedness,o=new s1(s,this._handResources.jointMeshes[n],this._handResources.handMeshes&&this._handResources.handMeshes[n],this._handResources.rigMappings&&this._handResources.rigMappings[n],(l=this.options.handMeshes)==null?void 0:l.meshesUseLeftHandedCoordinates,(u=this.options.jointMeshes)==null?void 0:u.invisible,(c=this.options.jointMeshes)==null?void 0:c.scaleFactor);this._attachedHands[s.uniqueId]=o,this._trackingHands[n]=o,this.onHandAddedObservable.notifyObservers(o)},this._detachHand=s=>{this._detachHandById(s.uniqueId)},this.xrNativeFeatureName="hand-tracking";const r=t.jointMeshes;if(r&&(typeof r.disableDefaultHandMesh<"u"&&(t.handMeshes=t.handMeshes||{},t.handMeshes.disableDefaultMeshes=r.disableDefaultHandMesh),typeof r.handMeshes<"u"&&(t.handMeshes=t.handMeshes||{},t.handMeshes.customMeshes=r.handMeshes),typeof r.leftHandedSystemMeshes<"u"&&(t.handMeshes=t.handMeshes||{},t.handMeshes.meshesUseLeftHandedCoordinates=r.leftHandedSystemMeshes),typeof r.rigMapping<"u")){t.handMeshes=t.handMeshes||{};const s={},n={};[[r.rigMapping.left,s],[r.rigMapping.right,n]].forEach(o=>{const l=o[0],u=o[1];l.forEach((c,h)=>{u[Mr[h]]=c})}),t.handMeshes.customRigMappings={left:s,right:n}}}attach(){var e,t,i,r,s;return super.attach()?(this._handResources.jointMeshes||(this._originalMesh=this._originalMesh||((e=this.options.jointMeshes)==null?void 0:e.sourceMesh)||$o("jointParent",je._ICOSPHERE_PARAMS),this._originalMesh.isVisible=!1,this._handResources.jointMeshes=je._GenerateTrackedJointMeshes(this.options,this._originalMesh)),this._handResources.handMeshes=((t=this.options.handMeshes)==null?void 0:t.customMeshes)||null,this._handResources.rigMappings=((i=this.options.handMeshes)==null?void 0:i.customRigMappings)||null,!((r=this.options.handMeshes)!=null&&r.customMeshes)&&!((s=this.options.handMeshes)!=null&&s.disableDefaultMeshes)&&(je._GenerateDefaultHandMeshesAsync(ze.LastCreatedScene,this._xrSessionManager,this.options).then(n=>{var o,l;this._handResources.handMeshes=n,this._handResources.rigMappings={left:je._GenerateDefaultHandMeshRigMapping("left"),right:je._GenerateDefaultHandMeshRigMapping("right")},(o=this._trackingHands.left)==null||o.setHandMesh(this._handResources.handMeshes.left,this._handResources.rigMappings.left,this._xrSessionManager),(l=this._trackingHands.right)==null||l.setHandMesh(this._handResources.handMeshes.right,this._handResources.rigMappings.right,this._xrSessionManager),this._handResources.handMeshes.left.scaling.setAll(this._xrSessionManager.worldScalingFactor),this._handResources.handMeshes.right.scaling.setAll(this._xrSessionManager.worldScalingFactor)}),this._worldScaleObserver=this._xrSessionManager.onWorldScaleFactorChangedObservable.add(n=>{this._handResources.handMeshes&&(this._handResources.handMeshes.left.scaling.scaleInPlace(n.newScaleFactor/n.previousScaleFactor),this._handResources.handMeshes.right.scaling.scaleInPlace(n.newScaleFactor/n.previousScaleFactor))})),this.options.xrInput.controllers.forEach(this._attachHand),this._addNewAttachObserver(this.options.xrInput.onControllerAddedObservable,this._attachHand),this._addNewAttachObserver(this.options.xrInput.onControllerRemovedObservable,this._detachHand),!0):!1}_onXRFrame(e){var t,i;(t=this._trackingHands.left)==null||t.updateFromXRFrame(e,this._xrSessionManager.referenceSpace),(i=this._trackingHands.right)==null||i.updateFromXRFrame(e,this._xrSessionManager.referenceSpace)}_detachHandById(e,t){var r;const i=this.getHandByControllerId(e);if(i){const s=i.xrController.inputSource.handedness=="left"?"left":"right";((r=this._trackingHands[s])==null?void 0:r.xrController.uniqueId)===e&&(this._trackingHands[s]=null),this.onHandRemovedObservable.notifyObservers(i),i.dispose(t),delete this._attachedHands[e]}}detach(){var e,t,i,r;return super.detach()?(Object.keys(this._attachedHands).forEach(s=>{var n;return this._detachHandById(s,(n=this.options.handMeshes)==null?void 0:n.disposeOnSessionEnd)}),(e=this.options.handMeshes)!=null&&e.disposeOnSessionEnd&&(this._handResources.jointMeshes&&(this._handResources.jointMeshes.left.forEach(s=>s.dispose()),this._handResources.jointMeshes.right.forEach(s=>s.dispose()),this._handResources.jointMeshes=null),this._handResources.handMeshes&&(this._handResources.handMeshes.left.dispose(),this._handResources.handMeshes.right.dispose(),this._handResources.handMeshes=null),(t=je._RightHandGLB)==null||t.meshes.forEach(s=>s.dispose()),(i=je._LeftHandGLB)==null||i.meshes.forEach(s=>s.dispose()),je._RightHandGLB=null,je._LeftHandGLB=null,(r=this._originalMesh)==null||r.dispose(),this._originalMesh=void 0),this._worldScaleObserver&&this._xrSessionManager.onWorldScaleFactorChangedObservable.remove(this._worldScaleObserver),!0):!1}dispose(){var e,t,i;super.dispose(),this.onHandAddedObservable.clear(),this.onHandRemovedObservable.clear(),this._handResources.handMeshes&&!((e=this.options.handMeshes)!=null&&e.customMeshes)&&(this._handResources.handMeshes.left.dispose(),this._handResources.handMeshes.right.dispose(),(t=je._RightHandGLB)==null||t.meshes.forEach(r=>r.dispose()),(i=je._LeftHandGLB)==null||i.meshes.forEach(r=>r.dispose()),je._RightHandGLB=null,je._LeftHandGLB=null),this._handResources.jointMeshes&&(this._handResources.jointMeshes.left.forEach(r=>r.dispose()),this._handResources.jointMeshes.right.forEach(r=>r.dispose()))}}je.Name=ke.HAND_TRACKING;je.Version=1;je.DEFAULT_HAND_MODEL_BASE_URL="https://assets.babylonjs.com/core/HandMeshes/";je.DEFAULT_HAND_MODEL_RIGHT_FILENAME="r_hand_rhs.glb";je.DEFAULT_HAND_MODEL_LEFT_FILENAME="l_hand_rhs.glb";je.DEFAULT_HAND_MODEL_SHADER_URL="https://assets.babylonjs.com/core/HandMeshes/handsShader.json";je._ICOSPHERE_PARAMS={radius:.5,flat:!1,subdivisions:2};je._RightHandGLB=null;je._LeftHandGLB=null;Tt.AddWebXRFeature(je.Name,(a,e)=>()=>new je(a,e),je.Version,!1);class Ta extends ti{get rotationEnabled(){return this._rotationEnabled}set rotationEnabled(e){if(this._rotationEnabled=e,this._options.teleportationTargetMesh){const t=this._options.teleportationTargetMesh.getChildMeshes(!1,i=>i.name==="rotationCone");t[0]&&t[0].setEnabled(e)}}get teleportationTargetMesh(){return this._options.teleportationTargetMesh||null}constructor(e,t){super(e),this._options=t,this._controllers={},this._snappedToPoint=!1,this._cachedColor4White=new xe(1,1,1,1),this._tmpRay=new Zt(new m,new m),this._tmpVector=new m,this._tmpQuaternion=new re,this._worldScaleObserver=null,this.skipNextTeleportation=!1,this.backwardsMovementEnabled=!0,this.backwardsTeleportationDistance=.7,this.parabolicCheckRadius=5,this.parabolicRayEnabled=!0,this.straightRayEnabled=!0,this.rotationAngle=Math.PI/8,this.onTargetMeshPositionUpdatedObservable=new j,this.teleportationEnabled=!0,this._rotationEnabled=!0,this.onBeforeCameraTeleportRotation=new j,this.onAfterCameraTeleportRotation=new j,this._attachController=i=>{if(this._controllers[i.uniqueId]||this._options.forceHandedness&&i.inputSource.handedness!==this._options.forceHandedness)return;this._controllers[i.uniqueId]={xrController:i,teleportationState:{forward:!1,backwards:!1,rotating:!1,currentRotation:0,baseRotation:0,blocked:!1,initialHit:!1,mainComponentUsed:!1}};const r=this._controllers[i.uniqueId];if(r.xrController.inputSource.targetRayMode==="tracked-pointer"&&r.xrController.inputSource.gamepad){const s=()=>{if(i.motionController){const n=i.motionController.getComponentOfType(Ji.THUMBSTICK_TYPE)||i.motionController.getComponentOfType(Ji.TOUCHPAD_TYPE);if(!n||this._options.useMainComponentOnly){const o=i.motionController.getMainComponent();if(!o)return;r.teleportationState.mainComponentUsed=!0,r.teleportationComponent=o,r.onButtonChangedObserver=o.onButtonStateChangedObservable.add(()=>{if(!this.teleportationEnabled)return;const l=()=>{r.teleportationState.forward=!0,r.teleportationState.initialHit=!1,this._currentTeleportationControllerId=r.xrController.uniqueId,r.teleportationState.baseRotation=this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y,r.teleportationState.currentRotation=0;const u=this._options.timeToTeleport||3e3;Cl({timeout:u,contextObservable:this._xrSessionManager.onXRFrameObservable,breakCondition:()=>!o.pressed,onEnded:()=>{this._currentTeleportationControllerId===r.xrController.uniqueId&&r.teleportationState.forward&&this._teleportForward(i.uniqueId)}})};o.changes.pressed&&(o.changes.pressed.current?this._options.timeToTeleportStart?Cl({timeout:this._options.timeToTeleportStart,contextObservable:this._xrSessionManager.onXRFrameObservable,onEnded:()=>{o.pressed&&l()}}):l():(r.teleportationState.forward=!1,this._currentTeleportationControllerId=""))})}else r.teleportationComponent=n,r.onAxisChangedObserver=n.onAxisValueChangedObservable.add(o=>{if(o.y<=.7&&r.teleportationState.backwards&&(r.teleportationState.backwards=!1),o.y>.7&&!r.teleportationState.forward&&this.backwardsMovementEnabled&&!this.snapPointsOnly&&!r.teleportationState.backwards){r.teleportationState.backwards=!0,this._tmpQuaternion.copyFrom(this._options.xrInput.xrCamera.rotationQuaternion),this._tmpQuaternion.toEulerAnglesToRef(this._tmpVector),this._tmpVector.x=0,this._tmpVector.z=0,re.FromEulerVectorToRef(this._tmpVector,this._tmpQuaternion),this._tmpVector.set(0,0,this.backwardsTeleportationDistance*(this._xrSessionManager.scene.useRightHandedSystem?1:-1)),this._tmpVector.rotateByQuaternionToRef(this._tmpQuaternion,this._tmpVector),this._tmpVector.addInPlace(this._options.xrInput.xrCamera.position),this._tmpRay.origin.copyFrom(this._tmpVector),this._tmpRay.length=this._options.xrInput.xrCamera.realWorldHeight+.1,this._tmpRay.direction.set(0,-1,0);const l=this._xrSessionManager.scene.pickWithRay(this._tmpRay,u=>this._floorMeshes.indexOf(u)!==-1);l&&l.pickedPoint&&(this._options.xrInput.xrCamera.position.x=l.pickedPoint.x,this._options.xrInput.xrCamera.position.z=l.pickedPoint.z)}if(o.y<-.7&&!this._currentTeleportationControllerId&&!r.teleportationState.rotating&&this.teleportationEnabled&&(r.teleportationState.forward=!0,this._currentTeleportationControllerId=r.xrController.uniqueId,r.teleportationState.baseRotation=this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y),o.x){if(r.teleportationState.forward)this._currentTeleportationControllerId===r.xrController.uniqueId&&(this.rotationEnabled?setTimeout(()=>{r.teleportationState.currentRotation=Math.atan2(o.x,o.y*(this._xrSessionManager.scene.useRightHandedSystem?1:-1))}):r.teleportationState.currentRotation=0);else if(!r.teleportationState.rotating&&Math.abs(o.x)>.7){r.teleportationState.rotating=!0;const l=this.rotationAngle*(o.x>0?1:-1)*(this._xrSessionManager.scene.useRightHandedSystem?-1:1);this.onBeforeCameraTeleportRotation.notifyObservers(l),re.FromEulerAngles(0,l,0).multiplyToRef(this._options.xrInput.xrCamera.rotationQuaternion,this._options.xrInput.xrCamera.rotationQuaternion),this.onAfterCameraTeleportRotation.notifyObservers(this._options.xrInput.xrCamera.rotationQuaternion)}}else r.teleportationState.rotating=!1;o.x===0&&o.y===0&&(r.teleportationState.blocked&&(r.teleportationState.blocked=!1,this._setTargetMeshVisibility(!1)),r.teleportationState.forward&&this._teleportForward(i.uniqueId))})}};i.motionController?s():i.onMotionControllerInitObservable.addOnce(()=>{s()})}else{r.teleportationState.mainComponentUsed=!0;let s=!1;const n=()=>{this._currentTeleportationControllerId=r.xrController.uniqueId,r.teleportationState.forward=!0,r.teleportationState.initialHit=!1,r.teleportationState.baseRotation=this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y,r.teleportationState.currentRotation=0;const o=this._options.timeToTeleport||3e3;Cl({timeout:o,contextObservable:this._xrSessionManager.onXRFrameObservable,onEnded:()=>{this._currentTeleportationControllerId===r.xrController.uniqueId&&r.teleportationState.forward&&this._teleportForward(i.uniqueId)}})};this._xrSessionManager.scene.onPointerObservable.add(o=>{o.type===Be.POINTERDOWN?(s=!1,this._options.timeToTeleportStart?Cl({timeout:this._options.timeToTeleportStart,contextObservable:this._xrSessionManager.onXRFrameObservable,onEnded:()=>{this._currentTeleportationControllerId===r.xrController.uniqueId&&n()},breakCondition:()=>s?(s=!1,!0):!1}):n()):o.type===Be.POINTERUP&&(s=!0,r.teleportationState.forward=!1,this._currentTeleportationControllerId="")})}},this._colorArray=Array(24).fill(this._cachedColor4White),this._options.teleportationTargetMesh||this._createDefaultTargetMesh(),this._floorMeshes=this._options.floorMeshes||[],this._snapToPositions=this._options.snapPositions||[],this._blockedRayColor=this._options.blockedRayColor||new xe(1,0,0,.75),this._setTargetMeshVisibility(!1),this.onBeforeCameraTeleport=t.xrInput.xrCamera.onBeforeCameraTeleport,this.onAfterCameraTeleport=t.xrInput.xrCamera.onAfterCameraTeleport,this.parabolicCheckRadius*=this._xrSessionManager.worldScalingFactor,this._worldScaleObserver=e.onWorldScaleFactorChangedObservable.add(i=>{var r;this.parabolicCheckRadius=this.parabolicCheckRadius/i.previousScaleFactor*i.newScaleFactor,(r=this._options.teleportationTargetMesh)==null||r.scaling.scaleInPlace(i.newScaleFactor/i.previousScaleFactor)})}get snapPointsOnly(){return!!this._options.snapPointsOnly}set snapPointsOnly(e){this._options.snapPointsOnly=e}addFloorMesh(e){this._floorMeshes.push(e)}addBlockerMesh(e){this._options.pickBlockerMeshes=this._options.pickBlockerMeshes||[],this._options.pickBlockerMeshes.push(e)}addSnapPoint(e){this._snapToPositions.push(e)}attach(){return super.attach()?(this._currentTeleportationControllerId="",this._options.xrInput.controllers.forEach(this._attachController),this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable,this._attachController),this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable,e=>{this._detachController(e.uniqueId)}),!0):!1}detach(){return super.detach()?(Object.keys(this._controllers).forEach(e=>{this._detachController(e)}),this._setTargetMeshVisibility(!1),this._currentTeleportationControllerId="",this._controllers={},!0):!1}dispose(){super.dispose(),this._options.teleportationTargetMesh&&this._options.teleportationTargetMesh.dispose(!1,!0),this._worldScaleObserver&&this._xrSessionManager.onWorldScaleFactorChangedObservable.remove(this._worldScaleObserver),this.onTargetMeshPositionUpdatedObservable.clear(),this.onTargetMeshPositionUpdatedObservable.clear(),this.onBeforeCameraTeleportRotation.clear(),this.onAfterCameraTeleportRotation.clear(),this.onBeforeCameraTeleport.clear(),this.onAfterCameraTeleport.clear()}removeFloorMesh(e){const t=this._floorMeshes.indexOf(e);t!==-1&&this._floorMeshes.splice(t,1)}removeBlockerMesh(e){this._options.pickBlockerMeshes=this._options.pickBlockerMeshes||[];const t=this._options.pickBlockerMeshes.indexOf(e);t!==-1&&this._options.pickBlockerMeshes.splice(t,1)}removeFloorMeshByName(e){const t=this._xrSessionManager.scene.getMeshByName(e);t&&this.removeFloorMesh(t)}removeSnapPoint(e){let t=this._snapToPositions.indexOf(e);if(t===-1){for(let i=0;i<this._snapToPositions.length;++i)if(this._snapToPositions[i].equals(e)){t=i;break}}return t!==-1?(this._snapToPositions.splice(t,1),!0):!1}setSelectionFeature(e){this._selectionFeature=e}_onXRFrame(e){const t=this._xrSessionManager.currentFrame,i=this._xrSessionManager.scene;if(!this.attach||!t)return;const r=this._options.teleportationTargetMesh;if(this._currentTeleportationControllerId){if(!r)return;r.rotationQuaternion=r.rotationQuaternion||new re;const s=this._controllers[this._currentTeleportationControllerId];if(s&&s.teleportationState.forward){re.RotationYawPitchRollToRef(s.teleportationState.currentRotation+s.teleportationState.baseRotation,0,0,r.rotationQuaternion);let n=!1;const o=s.xrController.inputSource.targetRayMode!=="transient-pointer";if(s.xrController.getWorldPointerRayToRef(this._tmpRay),this.straightRayEnabled){const l=i.pickWithRay(this._tmpRay,c=>{if(this._options.blockerMeshesPredicate&&this._options.blockerMeshesPredicate(c)||this._options.blockAllPickableMeshes&&c.isPickable||this._options.pickBlockerMeshes&&this._options.pickBlockerMeshes.indexOf(c)!==-1)return!0;const h=this._floorMeshes.indexOf(c);return h===-1?!1:this._floorMeshes[h].absolutePosition.y<this._options.xrInput.xrCamera.globalPosition.y}),u=l&&l.pickedMesh&&this._floorMeshes.indexOf(l.pickedMesh)!==-1;if(l&&l.pickedMesh&&!u){if(s.teleportationState.mainComponentUsed&&!s.teleportationState.initialHit){s.teleportationState.forward=!1;return}s.teleportationState.blocked=!0,this._setTargetMeshVisibility(!1,!1,o),this._showParabolicPath(l);return}else l&&l.pickedPoint&&(s.teleportationState.initialHit=!0,s.teleportationState.blocked=!1,n=!0,this._setTargetMeshPosition(l),this._setTargetMeshVisibility(!0,!1,o),this._showParabolicPath(l))}if(this.parabolicRayEnabled&&!n){const l=s.xrController.pointer.rotationQuaternion.toEulerAngles().x,u=1+(Math.PI/2-Math.abs(l)),c=this.parabolicCheckRadius*u;this._tmpRay.origin.addToRef(this._tmpRay.direction.scale(c*2),this._tmpVector),this._tmpVector.y=this._tmpRay.origin.y,this._tmpRay.origin.addInPlace(this._tmpRay.direction.scale(c)),this._tmpVector.subtractToRef(this._tmpRay.origin,this._tmpRay.direction),this._tmpRay.direction.normalize();const h=i.pickWithRay(this._tmpRay,f=>this._options.blockerMeshesPredicate&&this._options.blockerMeshesPredicate(f)||this._options.blockAllPickableMeshes&&f.isPickable||this._options.pickBlockerMeshes&&this._options.pickBlockerMeshes.indexOf(f)!==-1?!0:this._floorMeshes.indexOf(f)!==-1),d=h&&h.pickedMesh&&this._floorMeshes.indexOf(h.pickedMesh)!==-1;if(h&&h.pickedMesh&&!d){if(s.teleportationState.mainComponentUsed&&!s.teleportationState.initialHit){s.teleportationState.forward=!1;return}s.teleportationState.blocked=!0,this._setTargetMeshVisibility(!1,!1,o),this._showParabolicPath(h);return}else h&&h.pickedPoint&&(s.teleportationState.initialHit=!0,s.teleportationState.blocked=!1,n=!0,this._setTargetMeshPosition(h),this._setTargetMeshVisibility(!0,!1,o),this._showParabolicPath(h))}this._setTargetMeshVisibility(n,!1,o)}else this._setTargetMeshVisibility(!1,!1,!0)}else this._disposeBezierCurve(),this._setTargetMeshVisibility(!1,!1,!0)}_createDefaultTargetMesh(){this._options.defaultTargetMeshOptions=this._options.defaultTargetMeshOptions||{};const e=this._options.useUtilityLayer?this._options.customUtilityLayerScene||gt.DefaultUtilityLayer.utilityLayerScene:this._xrSessionManager.scene,t=ol("teleportationTarget",{width:2,height:2,subdivisions:2},e);if(t.isPickable=!1,this._options.defaultTargetMeshOptions.teleportationCircleMaterial)t.material=this._options.defaultTargetMeshOptions.teleportationCircleMaterial;else{const n=new Is("teleportationPlaneDynamicTexture",512,e,!0);n.hasAlpha=!0;const o=n.getContext(),l=512/2,u=512/2,c=200;o.beginPath(),o.arc(l,u,c,0,2*Math.PI,!1),o.fillStyle=this._options.defaultTargetMeshOptions.teleportationFillColor||"#444444",o.fill(),o.lineWidth=10,o.strokeStyle=this._options.defaultTargetMeshOptions.teleportationBorderColor||"#FFFFFF",o.stroke(),o.closePath(),n.update();const h=new Ut("teleportationPlaneMaterial",e);h.diffuseTexture=n,t.material=h}const i=fs("torusTeleportation",{diameter:.75,thickness:.1,tessellation:20},e);if(i.isPickable=!1,i.parent=t,!this._options.defaultTargetMeshOptions.disableAnimation){const s=new Le("animationInnerCircle","position.y",30,Le.ANIMATIONTYPE_FLOAT,Le.ANIMATIONLOOPMODE_CYCLE),n=[];n.push({frame:0,value:0}),n.push({frame:30,value:.4}),n.push({frame:60,value:0}),s.setKeys(n);const o=new vs;o.setEasingMode(Ma.EASINGMODE_EASEINOUT),s.setEasingFunction(o),i.animations=[],i.animations.push(s),e.beginAnimation(i,0,60,!0)}const r=tr("rotationCone",{diameterTop:0,tessellation:4},e);if(r.isPickable=!1,r.scaling.set(.5,.12,.2),r.rotate(qi.X,Math.PI/2),r.position.z=.6,r.parent=i,this._options.defaultTargetMeshOptions.torusArrowMaterial)i.material=this._options.defaultTargetMeshOptions.torusArrowMaterial,r.material=this._options.defaultTargetMeshOptions.torusArrowMaterial;else{const s=new Ut("torusConsMat",e);s.disableLighting=!!this._options.defaultTargetMeshOptions.disableLighting,s.disableLighting?s.emissiveColor=new ne(.3,.3,1):s.diffuseColor=new ne(.3,.3,1),s.alpha=.9,i.material=s,r.material=s,this._teleportationRingMaterial=s}this._options.renderingGroupId!==void 0&&(t.renderingGroupId=this._options.renderingGroupId,i.renderingGroupId=this._options.renderingGroupId,r.renderingGroupId=this._options.renderingGroupId),this._options.teleportationTargetMesh=t,this._options.teleportationTargetMesh.scaling.setAll(this._xrSessionManager.worldScalingFactor),this._setTargetMeshVisibility(!1)}_detachController(e){const t=this._controllers[e];t&&(t.teleportationComponent&&(t.onAxisChangedObserver&&t.teleportationComponent.onAxisValueChangedObservable.remove(t.onAxisChangedObserver),t.onButtonChangedObserver&&t.teleportationComponent.onButtonStateChangedObservable.remove(t.onButtonChangedObserver)),delete this._controllers[e])}_findClosestSnapPointWithRadius(e,t=this._options.snapToPositionRadius||.8){let i=null,r=Number.MAX_VALUE;if(this._snapToPositions.length){const s=t*t;this._snapToPositions.forEach(n=>{const o=m.DistanceSquared(n,e);o<=s&&o<r&&(r=o,i=n)})}return i}_setTargetMeshPosition(e){const t=e.pickedPoint;if(!this._options.teleportationTargetMesh||!t)return;const i=this._findClosestSnapPointWithRadius(t);this._snappedToPoint=!!i,this.snapPointsOnly&&!this._snappedToPoint&&this._teleportationRingMaterial?this._teleportationRingMaterial.diffuseColor.set(1,.3,.3):this.snapPointsOnly&&this._snappedToPoint&&this._teleportationRingMaterial&&this._teleportationRingMaterial.diffuseColor.set(.3,.3,1),this._options.teleportationTargetMesh.position.copyFrom(i||t),this._options.teleportationTargetMesh.position.y+=.01,this.onTargetMeshPositionUpdatedObservable.notifyObservers(e)}_setTargetMeshVisibility(e,t,i){this._options.teleportationTargetMesh&&(this._options.teleportationTargetMesh.isVisible===e&&!t||(this._options.teleportationTargetMesh.isVisible=e,this._options.teleportationTargetMesh.getChildren(void 0,!1).forEach(r=>{r.isVisible=e}),e?this._selectionFeature&&i&&this._selectionFeature.detach():(this._quadraticBezierCurve&&(this._quadraticBezierCurve.dispose(),this._quadraticBezierCurve=null),this._selectionFeature&&i&&this._selectionFeature.attach())))}_disposeBezierCurve(){this._quadraticBezierCurve&&(this._quadraticBezierCurve.dispose(),this._quadraticBezierCurve=null)}_showParabolicPath(e){if(!e.pickedPoint||!this._currentTeleportationControllerId)return;const t=this._options.useUtilityLayer?this._options.customUtilityLayerScene||gt.DefaultUtilityLayer.utilityLayerScene:this._xrSessionManager.scene,i=this._controllers[this._currentTeleportationControllerId],r=gy.CreateQuadraticBezier(i.xrController.pointer.absolutePosition,e.ray.origin,e.pickedPoint,25),s=i.teleportationState.blocked?this._blockedRayColor:void 0,n=this._colorArray.fill(s||this._cachedColor4White),o=r.getPoints();o.shift(),o.shift(),this._options.generateRayPathMesh?this._quadraticBezierCurve=this._options.generateRayPathMesh(r.getPoints(),e):this._quadraticBezierCurve=ai("teleportation path line",{points:o,instance:this._quadraticBezierCurve,updatable:!0,colors:n},t),this._quadraticBezierCurve.isPickable=!1,this._options.renderingGroupId!==void 0&&(this._quadraticBezierCurve.renderingGroupId=this._options.renderingGroupId)}_teleportForward(e){const t=this._controllers[e];if(!(!t||!t.teleportationState.forward||!this.teleportationEnabled)&&(t.teleportationState.forward=!1,this._currentTeleportationControllerId="",!(this.snapPointsOnly&&!this._snappedToPoint))){if(this.skipNextTeleportation){this.skipNextTeleportation=!1;return}if(this._options.teleportationTargetMesh&&this._options.teleportationTargetMesh.isVisible){const i=this._options.xrInput.xrCamera.realWorldHeight;this.onBeforeCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position),this._options.xrInput.xrCamera.position.copyFrom(this._options.teleportationTargetMesh.position),this._options.xrInput.xrCamera.position.y+=i,re.FromEulerAngles(0,t.teleportationState.currentRotation-(this._xrSessionManager.scene.useRightHandedSystem?Math.PI:0),0).multiplyToRef(this._options.xrInput.xrCamera.rotationQuaternion,this._options.xrInput.xrCamera.rotationQuaternion),this.onAfterCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position)}}}}Ta.Name=ke.TELEPORTATION;Ta.Version=1;Tt.AddWebXRFeature(Ta.Name,(a,e)=>()=>new Ta(a,e),Ta.Version,!0);class LW{}class L_{constructor(){}static CreateAsync(e,t={}){const i=new L_;if(e.onDisposeObservable.addOnce(()=>{i.dispose()}),!t.disableDefaultUI){const r={renderTarget:i.renderTarget,...t.uiOptions||{}};t.optionalFeatures&&(typeof t.optionalFeatures=="boolean"?r.optionalFeatures=["hit-test","anchors","plane-detection","hand-tracking"]:r.optionalFeatures=t.optionalFeatures),i.enterExitUI=new F_(e,r)}return w_.CreateAsync(e).then(r=>{if(i.baseExperience=r,t.ignoreNativeCameraTransformation&&(i.baseExperience.camera.compensateOnFirstFrame=!1),i.input=new Qw(r.sessionManager,r.camera,{controllerOptions:{renderingGroupId:t.renderingGroupId},...t.inputOptions||{}}),!t.disablePointerSelection){const s={...t.pointerSelectionOptions,xrInput:i.input,renderingGroupId:t.renderingGroupId};i.pointerSelection=i.baseExperience.featuresManager.enableFeature(cs.Name,t.useStablePlugins?"stable":"latest",s),t.disableTeleportation||(i.teleportation=i.baseExperience.featuresManager.enableFeature(Ta.Name,t.useStablePlugins?"stable":"latest",{floorMeshes:t.floorMeshes,xrInput:i.input,renderingGroupId:t.renderingGroupId,...t.teleportationOptions}),i.teleportation.setSelectionFeature(i.pointerSelection))}if(t.disableNearInteraction||(i.nearInteraction=i.baseExperience.featuresManager.enableFeature(hs.Name,t.useStablePlugins?"stable":"latest",{xrInput:i.input,farInteractionFeature:i.pointerSelection,renderingGroupId:t.renderingGroupId,useUtilityLayer:!0,enableNearInteractionOnAllControllers:!0,...t.nearInteractionOptions})),t.disableHandTracking||i.baseExperience.featuresManager.enableFeature(je.Name,t.useStablePlugins?"stable":"latest",{xrInput:i.input,...t.handSupportOptions},void 0,!1),i.renderTarget=i.baseExperience.sessionManager.getWebXRRenderTarget(t.outputCanvasOptions),!t.disableDefaultUI)return i.enterExitUI.setHelperAsync(i.baseExperience,i.renderTarget)}).then(()=>i).catch(r=>(L.Error("Error initializing XR"),L.Error(r),i))}dispose(){this.baseExperience&&this.baseExperience.dispose(),this.input&&this.input.dispose(),this.enterExitUI&&this.enterExitUI.dispose(),this.renderTarget&&this.renderTarget.dispose()}}var BW=!0;Te.prototype.createDefaultLight=function(a=!1){if(a&&this.lights)for(let e=0;e<this.lights.length;e++)this.lights[e].dispose();this.lights.length===0&&new wm("default light",m.Up(),this)};Te.prototype.createDefaultCamera=function(a=!1,e=!1,t=!1){if(e&&this.activeCamera&&(this.activeCamera.dispose(),this.activeCamera=null),!this.activeCamera){const i=this.getWorldExtends(l=>l.isVisible&&l.isEnabled()),r=i.max.subtract(i.min),s=i.min.add(r.scale(.5));let n,o=r.length()*1.5;if(isFinite(o)||(o=1,s.copyFromFloats(0,0,0)),a){const l=new lt("default camera",-(Math.PI/2),Math.PI/2,o,s,this);l.lowerRadiusLimit=o*.01,l.wheelPrecision=100/o,n=l}else{const l=new Ms("default camera",new m(s.x,s.y,-o),this);l.setTarget(s),n=l}n.minZ=o*.01,n.maxZ=o*1e3,n.speed=o*.2,this.activeCamera=n,t&&n.attachControl()}};Te.prototype.createDefaultCameraOrLight=function(a=!1,e=!1,t=!1){this.createDefaultLight(e),this.createDefaultCamera(a,e,t)};Te.prototype.createDefaultSkybox=function(a,e=!1,t=1e3,i=0,r=!0){if(!a)return L.Warn("Can not create default skybox without environment texture."),null;r&&a&&(this.environmentTexture=a);const s=Xi("hdrSkyBox",{size:t},this);if(e){const n=new xy("skyBox",this);n.backFaceCulling=!1,n.reflectionTexture=a.clone(),n.reflectionTexture&&(n.reflectionTexture.coordinatesMode=Y.SKYBOX_MODE),n.microSurface=1-i,n.disableLighting=!0,n.twoSidedLighting=!0,s.material=n}else{const n=new Ut("skyBox",this);n.backFaceCulling=!1,n.reflectionTexture=a.clone(),n.reflectionTexture&&(n.reflectionTexture.coordinatesMode=Y.SKYBOX_MODE),n.disableLighting=!0,s.material=n}return s.isPickable=!1,s.infiniteDistance=!0,s.ignoreCameraMaxZ=!0,s};Te.prototype.createDefaultEnvironment=function(a){return Wn?new Wn(a,this):null};Te.prototype.createDefaultVRExperience=function(a={}){return new wa(this,a)};Te.prototype.createDefaultXRExperienceAsync=function(a={}){return L_.CreateAsync(this,a).then(e=>e)};function gS(a){for(;a.firstChild;)a.removeChild(a.firstChild);a.srcObject=null,a.src="",a.removeAttribute("src")}class Ds extends Y{get onUserActionRequestedObservable(){return this._onUserActionRequestedObservable||(this._onUserActionRequestedObservable=new j),this._onUserActionRequestedObservable}_processError(e){this._errorFound=!0,this._onError?this._onError(e==null?void 0:e.message):L.Error(e==null?void 0:e.message)}_handlePlay(){this._errorFound=!1,this.video.play().catch(e=>{if((e==null?void 0:e.name)==="NotAllowedError"){if(this._onUserActionRequestedObservable&&this._onUserActionRequestedObservable.hasObservers()){this._onUserActionRequestedObservable.notifyObservers(this);return}else if(!this.video.muted){L.Warn("Unable to autoplay a video with sound. Trying again with muted turned true"),this.video.muted=!0,this._errorFound=!1,this.video.play().catch(t=>{this._processError(t)});return}}this._processError(e)})}constructor(e,t,i,r=!1,s=!1,n=Y.TRILINEAR_SAMPLINGMODE,o={},l,u=5){super(null,i,!r,s),this._externalTexture=null,this._onUserActionRequestedObservable=null,this._stillImageCaptured=!1,this._displayingPosterTexture=!1,this._frameId=-1,this._currentSrc=null,this._errorFound=!1,this.isVideo=!0,this._resizeInternalTexture=()=>{this._texture!=null&&this._texture.dispose(),!this._getEngine().needPOTTextures||ae.IsExponentOfTwo(this.video.videoWidth)&&ae.IsExponentOfTwo(this.video.videoHeight)?(this.wrapU=Y.WRAP_ADDRESSMODE,this.wrapV=Y.WRAP_ADDRESSMODE):(this.wrapU=Y.CLAMP_ADDRESSMODE,this.wrapV=Y.CLAMP_ADDRESSMODE,this._generateMipMaps=!1),this._texture=this._getEngine().createDynamicTexture(this.video.videoWidth,this.video.videoHeight,this._generateMipMaps,this.samplingMode),this._texture.format=this._format??5,this._frameId=-1,this._updateInternalTexture()},this._createInternalTexture=()=>{if(this._texture!=null)if(this._displayingPosterTexture)this._displayingPosterTexture=!1;else return;if(this.video.addEventListener("resize",this._resizeInternalTexture),this._resizeInternalTexture(),!this.video.autoplay&&!this._settings.poster&&!this._settings.independentVideoSource){const f=this.video.onplaying,p=this.video.muted;this.video.muted=!0,this.video.onplaying=()=>{this.video.muted=p,this.video.onplaying=f,this._updateInternalTexture(),this._errorFound||this.video.pause(),this.onLoadObservable.hasObservers()&&this.onLoadObservable.notifyObservers(this)},this._handlePlay()}else this._updateInternalTexture(),this.onLoadObservable.hasObservers()&&this.onLoadObservable.notifyObservers(this)},this._reset=()=>{this._texture!=null&&(this._displayingPosterTexture||(this._texture.dispose(),this._texture=null))},this._updateInternalTexture=()=>{if(this._texture==null||this.video.readyState<this.video.HAVE_CURRENT_DATA||this._displayingPosterTexture)return;const f=this.getScene().getFrameId();this._frameId!==f&&(this._frameId=f,this._getEngine().updateVideoTexture(this._texture,this._externalTexture?this._externalTexture:this.video,this._invertY))},this._settings={autoPlay:!0,loop:!0,autoUpdateTexture:!0,...o},this._onError=l,this._generateMipMaps=r,this._initialSamplingMode=n,this.autoUpdateTexture=this._settings.autoUpdateTexture,this._currentSrc=t,this.name=e||this._getName(t),this.video=this._getVideo(t);const c=this._engine,h=c==null?void 0:c.createExternalTexture;h&&(this._externalTexture=h.call(c,this.video)),this._settings.independentVideoSource||(this._settings.poster&&(this.video.poster=this._settings.poster),this._settings.autoPlay!==void 0&&(this.video.autoplay=this._settings.autoPlay),this._settings.loop!==void 0&&(this.video.loop=this._settings.loop),this._settings.muted!==void 0&&(this.video.muted=this._settings.muted),this.video.setAttribute("playsinline",""),this.video.addEventListener("paused",this._updateInternalTexture),this.video.addEventListener("seeked",this._updateInternalTexture),this.video.addEventListener("loadeddata",this._updateInternalTexture),this.video.addEventListener("emptied",this._reset),this._settings.autoPlay&&this._handlePlay()),this._createInternalTextureOnEvent=this._settings.poster&&!this._settings.autoPlay?"play":"canplay",this.video.addEventListener(this._createInternalTextureOnEvent,this._createInternalTexture),this._format=u;const d=this.video.readyState>=this.video.HAVE_CURRENT_DATA;this._settings.poster&&(!this._settings.autoPlay||!d)?(this._texture=this._getEngine().createTexture(this._settings.poster,!1,!this.invertY,i),this._displayingPosterTexture=!0):d&&this._createInternalTexture()}getClassName(){return"VideoTexture"}_getName(e){return e instanceof HTMLVideoElement?e.currentSrc:typeof e=="object"?e.toString():e}_getVideo(e){if(e.isNative)return e;if(e instanceof HTMLVideoElement)return ae.SetCorsBehavior(e.currentSrc,e),e;const t=document.createElement("video");return typeof e=="string"?(ae.SetCorsBehavior(e,t),t.src=e):(ae.SetCorsBehavior(e[0],t),e.forEach(i=>{const r=document.createElement("source");r.src=i,t.appendChild(r)})),this.onDisposeObservable.addOnce(()=>{gS(t)}),t}_rebuild(){this.update()}update(){this.autoUpdateTexture&&this.updateTexture(!0)}updateTexture(e){e&&(this.video.paused&&this._stillImageCaptured||(this._stillImageCaptured=!0,this._updateInternalTexture()))}get externalTexture(){return this._externalTexture}updateURL(e){this.video.src=e,this._currentSrc=e}clone(){return new Ds(this.name,this._currentSrc,this.getScene(),this._generateMipMaps,this.invertY,this.samplingMode,this._settings)}dispose(){var e;super.dispose(),this._currentSrc=null,this._onUserActionRequestedObservable&&(this._onUserActionRequestedObservable.clear(),this._onUserActionRequestedObservable=null),this.video.removeEventListener(this._createInternalTextureOnEvent,this._createInternalTexture),this._settings.independentVideoSource||(this.video.removeEventListener("paused",this._updateInternalTexture),this.video.removeEventListener("seeked",this._updateInternalTexture),this.video.removeEventListener("loadeddata",this._updateInternalTexture),this.video.removeEventListener("emptied",this._reset),this.video.removeEventListener("resize",this._resizeInternalTexture),this.video.pause()),(e=this._externalTexture)==null||e.dispose()}static CreateFromStreamAsync(e,t,i,r=!0){const s=e.getEngine().createVideoElement(i);return e.getEngine()._badOS&&(document.body.appendChild(s),s.style.transform="scale(0.0001, 0.0001)",s.style.opacity="0",s.style.position="fixed",s.style.bottom="0px",s.style.right="0px"),s.setAttribute("autoplay",""),s.setAttribute("muted","true"),s.setAttribute("playsinline",""),s.muted=!0,s.isNative||(typeof s.srcObject=="object"?s.srcObject=t:s.src=window.URL&&window.URL.createObjectURL(t)),new Promise(n=>{const o=()=>{const l=new Ds("video",s,e,!0,r,void 0,void 0,void 0,4);e.getEngine()._badOS&&l.onDisposeObservable.addOnce(()=>{s.remove()}),l.onDisposeObservable.addOnce(()=>{gS(s)}),n(l),s.removeEventListener("playing",o)};s.addEventListener("playing",o),s.play()})}static async CreateFromWebCamAsync(e,t,i=!1,r=!0){if(navigator.mediaDevices){const s=await navigator.mediaDevices.getUserMedia({video:t,audio:i}),n=await this.CreateFromStreamAsync(e,s,t,r);return n.onDisposeObservable.addOnce(()=>{s.getTracks().forEach(o=>{o.stop()})}),n}return Promise.reject("No support for userMedia on this device")}static CreateFromWebCam(e,t,i,r=!1,s=!0){this.CreateFromWebCamAsync(e,i,r,s).then(function(n){t&&t(n)}).catch(function(n){L.Error(n.name)})}}C([F("settings")],Ds.prototype,"_settings",void 0);C([F("src")],Ds.prototype,"_currentSrc",void 0);C([F()],Ds.prototype,"isVideo",void 0);Y._CreateVideoTexture=(a,e,t,i=!1,r=!1,s=Y.TRILINEAR_SAMPLINGMODE,n={},o,l=5)=>new Ds(a,e,t,i,r,s,n,o,l);B("BABYLON.VideoTexture",Ds);class B_ extends Ri{get videoTexture(){return this._texture}get videoMode(){return this.textureMode}set videoMode(e){this.textureMode=e}_initTexture(e,t,i){const r={loop:i.loop,autoPlay:i.autoPlay,autoUpdateTexture:!0,poster:i.poster},s=new Ds((this.name||"videoDome")+"_texture",e,t,i.generateMipMaps,this._useDirectMapping,Y.TRILINEAR_SAMPLINGMODE,r);return i.clickToPlay&&(this._pointerObserver=t.onPointerObservable.add(n=>{var o;((o=n.pickInfo)==null?void 0:o.pickedMesh)===this.mesh&&this._texture.video.play()},Be.POINTERDOWN)),this._textureObserver=s.onLoadObservable.add(()=>{this.onLoadObservable.notifyObservers()}),s}dispose(e,t=!1){this._texture.onLoadObservable.remove(this._textureObserver),this._scene.onPointerObservable.remove(this._pointerObserver),super.dispose(e,t)}}B_.MODE_MONOSCOPIC=Ri.MODE_MONOSCOPIC;B_.MODE_TOPBOTTOM=Ri.MODE_TOPBOTTOM;B_.MODE_SIDEBYSIDE=Ri.MODE_SIDEBYSIDE;class pr{get _shouldRender(){return this._thinEffectLayer._shouldRender}set _shouldRender(e){this._thinEffectLayer._shouldRender=e}get _emissiveTextureAndColor(){return this._thinEffectLayer._emissiveTextureAndColor}set _emissiveTextureAndColor(e){this._thinEffectLayer._emissiveTextureAndColor=e}get _effectIntensity(){return this._thinEffectLayer._effectIntensity}set _effectIntensity(e){this._thinEffectLayer._effectIntensity=e}static get ForceGLSL(){return sn.ForceGLSL}static set ForceGLSL(e){sn.ForceGLSL=e}get name(){return this._thinEffectLayer.name}set name(e){this._thinEffectLayer.name=e}get neutralColor(){return this._thinEffectLayer.neutralColor}set neutralColor(e){this._thinEffectLayer.neutralColor=e}get isEnabled(){return this._thinEffectLayer.isEnabled}set isEnabled(e){this._thinEffectLayer.isEnabled=e}get camera(){return this._thinEffectLayer.camera}get renderingGroupId(){return this._thinEffectLayer.renderingGroupId}set renderingGroupId(e){this._thinEffectLayer.renderingGroupId=e}get disableBoundingBoxesFromEffectLayer(){return this._thinEffectLayer.disableBoundingBoxesFromEffectLayer}set disableBoundingBoxesFromEffectLayer(e){this._thinEffectLayer.disableBoundingBoxesFromEffectLayer=e}get mainTexture(){return this._mainTexture}get _shaderLanguage(){return this._thinEffectLayer.shaderLanguage}get shaderLanguage(){return this._thinEffectLayer.shaderLanguage}setMaterialForRendering(e,t){this._thinEffectLayer.setMaterialForRendering(e,t)}getEffectIntensity(e){return this._thinEffectLayer.getEffectIntensity(e)}setEffectIntensity(e,t){this._thinEffectLayer.setEffectIntensity(e,t)}constructor(e,t,i=!1,r){this._maxSize=0,this._mainTextureDesiredSize={width:0,height:0},this._postProcesses=[],this._textures=[],this.onDisposeObservable=new j,this.onBeforeRenderMainTextureObservable=new j,this.onBeforeComposeObservable=new j,this.onBeforeRenderMeshToEffect=new j,this.onAfterRenderMeshToEffect=new j,this.onAfterComposeObservable=new j,this.onSizeChangedObservable=new j,this._internalThinEffectLayer=!r,r||(r=new sn(e,t,i,!1,this._importShadersAsync.bind(this)),r.getEffectName=this.getEffectName.bind(this),r.isReady=this.isReady.bind(this),r._createMergeEffect=this._createMergeEffect.bind(this),r._createTextureAndPostProcesses=this._createTextureAndPostProcesses.bind(this),r._internalCompose=this._internalRender.bind(this),r._setEmissiveTextureAndColor=this._setEmissiveTextureAndColor.bind(this),r._numInternalDraws=this._numInternalDraws.bind(this),r._addCustomEffectDefines=this._addCustomEffectDefines.bind(this),r.hasMesh=this.hasMesh.bind(this),r.shouldRender=this.shouldRender.bind(this),r._shouldRenderMesh=this._shouldRenderMesh.bind(this),r._canRenderMesh=this._canRenderMesh.bind(this),r._useMeshMaterial=this._useMeshMaterial.bind(this)),this._thinEffectLayer=r,this.name=e,this._scene=t||ze.LastCreatedScene,pr._SceneComponentInitialization(this._scene),this._engine=this._scene.getEngine(),this._maxSize=this._engine.getCaps().maxTextureSize,this._scene.effectLayers.push(this),this._thinEffectLayer.onDisposeObservable.add(()=>{this.onDisposeObservable.notifyObservers(this)}),this._thinEffectLayer.onBeforeRenderLayerObservable.add(()=>{this.onBeforeRenderMainTextureObservable.notifyObservers(this)}),this._thinEffectLayer.onBeforeComposeObservable.add(()=>{this.onBeforeComposeObservable.notifyObservers(this)}),this._thinEffectLayer.onBeforeRenderMeshToEffect.add(s=>{this.onBeforeRenderMeshToEffect.notifyObservers(s)}),this._thinEffectLayer.onAfterRenderMeshToEffect.add(s=>{this.onAfterRenderMeshToEffect.notifyObservers(s)}),this._thinEffectLayer.onAfterComposeObservable.add(()=>{this.onAfterComposeObservable.notifyObservers(this)})}get _shadersLoaded(){return this._thinEffectLayer._shadersLoaded}set _shadersLoaded(e){this._thinEffectLayer._shadersLoaded=e}_numInternalDraws(){return this._internalThinEffectLayer?1:this._thinEffectLayer._numInternalDraws()}_init(e){this._effectLayerOptions={mainTextureRatio:.5,alphaBlendingMode:2,camera:null,renderingGroupId:-1,mainTextureType:0,generateStencilBuffer:!1,...e},this._setMainTextureSize(),this._thinEffectLayer._init(e),this._createMainTexture(),this._createTextureAndPostProcesses()}_setMainTextureSize(){this._effectLayerOptions.mainTextureFixedSize?(this._mainTextureDesiredSize.width=this._effectLayerOptions.mainTextureFixedSize,this._mainTextureDesiredSize.height=this._effectLayerOptions.mainTextureFixedSize):(this._mainTextureDesiredSize.width=this._engine.getRenderWidth()*this._effectLayerOptions.mainTextureRatio,this._mainTextureDesiredSize.height=this._engine.getRenderHeight()*this._effectLayerOptions.mainTextureRatio,this._mainTextureDesiredSize.width=this._engine.needPOTTextures?ds(this._mainTextureDesiredSize.width,this._maxSize):this._mainTextureDesiredSize.width,this._mainTextureDesiredSize.height=this._engine.needPOTTextures?ds(this._mainTextureDesiredSize.height,this._maxSize):this._mainTextureDesiredSize.height),this._mainTextureDesiredSize.width=Math.floor(this._mainTextureDesiredSize.width),this._mainTextureDesiredSize.height=Math.floor(this._mainTextureDesiredSize.height)}_createMainTexture(){this._mainTexture=new Kt("EffectLayerMainRTT",{width:this._mainTextureDesiredSize.width,height:this._mainTextureDesiredSize.height},this._scene,{type:this._effectLayerOptions.mainTextureType,samplingMode:Y.TRILINEAR_SAMPLINGMODE,generateStencilBuffer:this._effectLayerOptions.generateStencilBuffer,existingObjectRenderer:this._thinEffectLayer.objectRenderer}),this._mainTexture.activeCamera=this._effectLayerOptions.camera,this._mainTexture.wrapU=Y.CLAMP_ADDRESSMODE,this._mainTexture.wrapV=Y.CLAMP_ADDRESSMODE,this._mainTexture.anisotropicFilteringLevel=1,this._mainTexture.updateSamplingMode(Y.BILINEAR_SAMPLINGMODE),this._mainTexture.renderParticles=!1,this._mainTexture.renderList=null,this._mainTexture.ignoreCameraViewport=!0,this._mainTexture.onClearObservable.add(e=>{e.clear(this.neutralColor,!0,!0,!0)})}_addCustomEffectDefines(e){}_isReady(e,t,i){return this._internalThinEffectLayer?this._thinEffectLayer._internalIsSubMeshReady(e,t,i):this._thinEffectLayer._isSubMeshReady(e,t,i)}async _importShadersAsync(){}_arePostProcessAndMergeReady(){return this._internalThinEffectLayer?this._thinEffectLayer._internalIsLayerReady():this._thinEffectLayer.isLayerReady()}isLayerReady(){return this._arePostProcessAndMergeReady()&&this._mainTexture.isReady()}render(){if(!this._thinEffectLayer.compose())return;const e=this._mainTexture.getSize();this._setMainTextureSize(),(e.width!==this._mainTextureDesiredSize.width||e.height!==this._mainTextureDesiredSize.height)&&this._mainTextureDesiredSize.width!==0&&this._mainTextureDesiredSize.height!==0&&(this.onSizeChangedObservable.notifyObservers(this),this._disposeTextureAndPostProcesses(),this._createMainTexture(),this._createTextureAndPostProcesses())}hasMesh(e){return this._internalThinEffectLayer?this._thinEffectLayer._internalHasMesh(e):this._thinEffectLayer.hasMesh(e)}shouldRender(){return this._internalThinEffectLayer?this._thinEffectLayer._internalShouldRender():this._thinEffectLayer.shouldRender()}_shouldRenderMesh(e){return this._internalThinEffectLayer?!0:this._thinEffectLayer._shouldRenderMesh(e)}_canRenderMesh(e,t){return this._internalThinEffectLayer?this._thinEffectLayer._internalCanRenderMesh(e,t):this._thinEffectLayer._canRenderMesh(e,t)}_shouldRenderEmissiveTextureForMesh(){return!0}_useMeshMaterial(e){return this._internalThinEffectLayer?!1:this._thinEffectLayer._useMeshMaterial(e)}_rebuild(){this._thinEffectLayer._rebuild()}_disposeTextureAndPostProcesses(){this._mainTexture.dispose();for(let e=0;e<this._postProcesses.length;e++)this._postProcesses[e]&&this._postProcesses[e].dispose();this._postProcesses=[];for(let e=0;e<this._textures.length;e++)this._textures[e]&&this._textures[e].dispose();this._textures=[]}dispose(){this._thinEffectLayer.dispose(),this._disposeTextureAndPostProcesses();const e=this._scene.effectLayers.indexOf(this,0);e>-1&&this._scene.effectLayers.splice(e,1),this.onDisposeObservable.clear(),this.onBeforeRenderMainTextureObservable.clear(),this.onBeforeComposeObservable.clear(),this.onBeforeRenderMeshToEffect.clear(),this.onAfterRenderMeshToEffect.clear(),this.onAfterComposeObservable.clear(),this.onSizeChangedObservable.clear()}getClassName(){return"EffectLayer"}static Parse(e,t,i){return ae.Instantiate(e.customType).Parse(e,t,i)}}pr._SceneComponentInitialization=a=>{throw Cr("EffectLayerSceneComponent")};C([F()],pr.prototype,"name",null);C([lM()],pr.prototype,"neutralColor",null);C([F()],pr.prototype,"isEnabled",null);C([uM()],pr.prototype,"camera",null);C([F()],pr.prototype,"renderingGroupId",null);C([F()],pr.prototype,"disableBoundingBoxesFromEffectLayer",null);rl(ge.NAME_EFFECTLAYER,(a,e,t,i)=>{if(a.effectLayers){t.effectLayers||(t.effectLayers=[]);for(let r=0;r<a.effectLayers.length;r++){const s=pr.Parse(a.effectLayers[r],e,i);t.effectLayers.push(s)}}});Te.prototype.removeEffectLayer=function(a){const e=this.effectLayers.indexOf(a);return e!==-1&&this.effectLayers.splice(e,1),e};Te.prototype.addEffectLayer=function(a){this.effectLayers.push(a)};class n1{constructor(e){this.name=ge.NAME_EFFECTLAYER,this._renderEffects=!1,this._needStencil=!1,this._previousStencilState=!1,this.scene=e||ze.LastCreatedScene,this.scene&&(this._engine=this.scene.getEngine())}register(){this.scene._isReadyForMeshStage.registerStep(ge.STEP_ISREADYFORMESH_EFFECTLAYER,this,this._isReadyForMesh),this.scene._cameraDrawRenderTargetStage.registerStep(ge.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER,this,this._renderMainTexture),this.scene._beforeCameraDrawStage.registerStep(ge.STEP_BEFORECAMERADRAW_EFFECTLAYER,this,this._setStencil),this.scene._afterRenderingGroupDrawStage.registerStep(ge.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW,this,this._drawRenderingGroup),this.scene._afterCameraDrawStage.registerStep(ge.STEP_AFTERCAMERADRAW_EFFECTLAYER,this,this._setStencilBack),this.scene._afterCameraDrawStage.registerStep(ge.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW,this,this._drawCamera)}rebuild(){const e=this.scene.effectLayers;for(const t of e)t._rebuild()}serialize(e){e.effectLayers=[];const t=this.scene.effectLayers;for(const i of t)i.serialize&&e.effectLayers.push(i.serialize())}addFromContainer(e){e.effectLayers&&e.effectLayers.forEach(t=>{this.scene.addEffectLayer(t)})}removeFromContainer(e,t){e.effectLayers&&e.effectLayers.forEach(i=>{this.scene.removeEffectLayer(i),t&&i.dispose()})}dispose(){const e=this.scene.effectLayers;for(;e.length;)e[0].dispose()}_isReadyForMesh(e,t){const i=this._engine.currentRenderPassId,r=this.scene.effectLayers;for(const s of r){if(!s.hasMesh(e))continue;const n=s._mainTexture;this._engine.currentRenderPassId=n.renderPassId;for(const o of e.subMeshes)if(!s.isReady(o,t))return this._engine.currentRenderPassId=i,!1}return this._engine.currentRenderPassId=i,!0}_renderMainTexture(e){this._renderEffects=!1,this._needStencil=!1;let t=!1;const i=this.scene.effectLayers;if(i&&i.length>0){this._previousStencilState=this._engine.getStencilBuffer();for(const r of i)if(r.shouldRender()&&(!r.camera||r.camera.cameraRigMode===Ze.RIG_MODE_NONE&&e===r.camera||r.camera.cameraRigMode!==Ze.RIG_MODE_NONE&&r.camera._rigCameras.indexOf(e)>-1)){this._renderEffects=!0,this._needStencil=this._needStencil||r.needStencil();const s=r._mainTexture;s._shouldRender()&&(this.scene.incrementRenderId(),s.render(!1,!1),t=!0)}this.scene.incrementRenderId()}return t}_setStencil(){this._needStencil&&this._engine.setStencilBuffer(!0)}_setStencilBack(){this._needStencil&&this._engine.setStencilBuffer(this._previousStencilState)}_draw(e){if(this._renderEffects){this._engine.setDepthBuffer(!1);const t=this.scene.effectLayers;for(let i=0;i<t.length;i++){const r=t[i];r.renderingGroupId===e&&r.shouldRender()&&r.render()}this._engine.setDepthBuffer(!0)}}_drawCamera(){this._renderEffects&&this._draw(-1)}_drawRenderingGroup(e){!this.scene._isInIntermediateRendering()&&this._renderEffects&&this._draw(e)}}pr._SceneComponentInitialization=a=>{let e=a._getComponent(ge.NAME_EFFECTLAYER);e||(e=new n1(a),a._addComponent(e))};Te.prototype.getGlowLayerByName=function(a){var e;for(let t=0;t<((e=this.effectLayers)==null?void 0:e.length);t++)if(this.effectLayers[t].name===a&&this.effectLayers[t].getEffectName()===Tr.EffectName)return this.effectLayers[t];return null};class Tr extends pr{static get EffectName(){return Gn.EffectName}set blurKernelSize(e){this._thinEffectLayer.blurKernelSize=e}get blurKernelSize(){return this._thinEffectLayer.blurKernelSize}set intensity(e){this._thinEffectLayer.intensity=e}get intensity(){return this._thinEffectLayer.intensity}get customEmissiveColorSelector(){return this._thinEffectLayer.customEmissiveColorSelector}set customEmissiveColorSelector(e){this._thinEffectLayer.customEmissiveColorSelector=e}get customEmissiveTextureSelector(){return this._thinEffectLayer.customEmissiveTextureSelector}set customEmissiveTextureSelector(e){this._thinEffectLayer.customEmissiveTextureSelector=e}constructor(e,t,i){super(e,t,!1,new Gn(e,t,i)),this._options={mainTextureRatio:Tr.DefaultTextureRatio,blurKernelSize:32,mainTextureFixedSize:void 0,camera:null,mainTextureSamples:1,renderingGroupId:-1,ldrMerge:!1,alphaBlendingMode:1,mainTextureType:0,generateStencilBuffer:!1,...i},this._init(this._options)}getEffectName(){return Tr.EffectName}_createMergeEffect(){return this._thinEffectLayer._createMergeEffect()}_createTextureAndPostProcesses(){this._thinEffectLayer._renderPassId=this._mainTexture.renderPassId;let e=this._mainTextureDesiredSize.width,t=this._mainTextureDesiredSize.height;e=this._engine.needPOTTextures?ds(e,this._maxSize):e,t=this._engine.needPOTTextures?ds(t,this._maxSize):t;let i=0;this._engine.getCaps().textureHalfFloatRender?i=2:i=0,this._blurTexture1=new Kt("GlowLayerBlurRTT",{width:e,height:t},this._scene,!1,!0,i),this._blurTexture1.wrapU=Y.CLAMP_ADDRESSMODE,this._blurTexture1.wrapV=Y.CLAMP_ADDRESSMODE,this._blurTexture1.updateSamplingMode(Y.BILINEAR_SAMPLINGMODE),this._blurTexture1.renderParticles=!1,this._blurTexture1.ignoreCameraViewport=!0;const r=Math.floor(e/2),s=Math.floor(t/2);this._blurTexture2=new Kt("GlowLayerBlurRTT2",{width:r,height:s},this._scene,!1,!0,i),this._blurTexture2.wrapU=Y.CLAMP_ADDRESSMODE,this._blurTexture2.wrapV=Y.CLAMP_ADDRESSMODE,this._blurTexture2.updateSamplingMode(Y.BILINEAR_SAMPLINGMODE),this._blurTexture2.renderParticles=!1,this._blurTexture2.ignoreCameraViewport=!0,this._textures=[this._blurTexture1,this._blurTexture2],this._thinEffectLayer.bindTexturesForCompose=c=>{c.setTexture("textureSampler",this._blurTexture1),c.setTexture("textureSampler2",this._blurTexture2),c.setFloat("offset",this.intensity)},this._thinEffectLayer._createTextureAndPostProcesses();const n=this._thinEffectLayer._postProcesses[0];this._horizontalBlurPostprocess1=new zt("GlowLayerHBP1",n.direction,n.kernel,{samplingMode:Y.BILINEAR_SAMPLINGMODE,engine:this._scene.getEngine(),width:e,height:t,textureType:i,effectWrapper:n}),this._horizontalBlurPostprocess1.width=e,this._horizontalBlurPostprocess1.height=t,this._horizontalBlurPostprocess1.externalTextureSamplerBinding=!0,this._horizontalBlurPostprocess1.onApplyObservable.add(c=>{c.setTexture("textureSampler",this._mainTexture)});const o=this._thinEffectLayer._postProcesses[1];this._verticalBlurPostprocess1=new zt("GlowLayerVBP1",o.direction,o.kernel,{samplingMode:Y.BILINEAR_SAMPLINGMODE,engine:this._scene.getEngine(),width:e,height:t,textureType:i,effectWrapper:o});const l=this._thinEffectLayer._postProcesses[2];this._horizontalBlurPostprocess2=new zt("GlowLayerHBP2",l.direction,l.kernel,{samplingMode:Y.BILINEAR_SAMPLINGMODE,engine:this._scene.getEngine(),width:r,height:s,textureType:i,effectWrapper:l}),this._horizontalBlurPostprocess2.width=r,this._horizontalBlurPostprocess2.height=s,this._horizontalBlurPostprocess2.externalTextureSamplerBinding=!0,this._horizontalBlurPostprocess2.onApplyObservable.add(c=>{c.setTexture("textureSampler",this._blurTexture1)});const u=this._thinEffectLayer._postProcesses[3];this._verticalBlurPostprocess2=new zt("GlowLayerVBP2",u.direction,u.kernel,{samplingMode:Y.BILINEAR_SAMPLINGMODE,engine:this._scene.getEngine(),width:r,height:s,textureType:i,effectWrapper:u}),this._postProcesses=[this._horizontalBlurPostprocess1,this._verticalBlurPostprocess1,this._horizontalBlurPostprocess2,this._verticalBlurPostprocess2],this._postProcesses1=[this._horizontalBlurPostprocess1,this._verticalBlurPostprocess1],this._postProcesses2=[this._horizontalBlurPostprocess2,this._verticalBlurPostprocess2],this._mainTexture.samples=this._options.mainTextureSamples,this._mainTexture.onAfterUnbindObservable.add(()=>{const c=this._blurTexture1.renderTarget;if(c){this._scene.postProcessManager.directRender(this._postProcesses1,c,!0);const h=this._blurTexture2.renderTarget;h&&this._scene.postProcessManager.directRender(this._postProcesses2,h,!0),this._engine.unBindFramebuffer(h??c,!0)}}),this._postProcesses.map(c=>{c.autoClear=!1})}isReady(e,t){return this._thinEffectLayer.isReady(e,t)}needStencil(){return!1}_canRenderMesh(e,t){return this._thinEffectLayer._canRenderMesh(e,t)}_internalRender(e){this._thinEffectLayer._internalCompose(e)}_setEmissiveTextureAndColor(e,t,i){this._thinEffectLayer._setEmissiveTextureAndColor(e,t,i)}_shouldRenderMesh(e){return this._thinEffectLayer._shouldRenderMesh(e)}_addCustomEffectDefines(e){this._thinEffectLayer._addCustomEffectDefines(e)}addExcludedMesh(e){this._thinEffectLayer.addExcludedMesh(e)}removeExcludedMesh(e){this._thinEffectLayer.removeExcludedMesh(e)}addIncludedOnlyMesh(e){this._thinEffectLayer.addIncludedOnlyMesh(e)}removeIncludedOnlyMesh(e){this._thinEffectLayer.removeIncludedOnlyMesh(e)}hasMesh(e){return this._thinEffectLayer.hasMesh(e)}_useMeshMaterial(e){return this._thinEffectLayer._useMeshMaterial(e)}referenceMeshToUseItsOwnMaterial(e){this._thinEffectLayer.referenceMeshToUseItsOwnMaterial(e)}unReferenceMeshFromUsingItsOwnMaterial(e){this._thinEffectLayer.unReferenceMeshFromUsingItsOwnMaterial(e,this._mainTexture.renderPassId)}_disposeMesh(e){this._thinEffectLayer._disposeMesh(e)}getClassName(){return"GlowLayer"}serialize(){const e=Me.Serialize(this);e.customType="BABYLON.GlowLayer";let t;e.includedMeshes=[];const i=this._thinEffectLayer._includedOnlyMeshes;if(i.length)for(t=0;t<i.length;t++){const s=this._scene.getMeshByUniqueId(i[t]);s&&e.includedMeshes.push(s.id)}e.excludedMeshes=[];const r=this._thinEffectLayer._excludedMeshes;if(r.length)for(t=0;t<r.length;t++){const s=this._scene.getMeshByUniqueId(r[t]);s&&e.excludedMeshes.push(s.id)}return e}static Parse(e,t,i){const r=Me.Parse(()=>new Tr(e.name,t,e.options),e,t,i);let s;for(s=0;s<e.excludedMeshes.length;s++){const n=t.getMeshById(e.excludedMeshes[s]);n&&r.addExcludedMesh(n)}for(s=0;s<e.includedMeshes.length;s++){const n=t.getMeshById(e.includedMeshes[s]);n&&r.addIncludedOnlyMesh(n)}return r}}Tr.DefaultBlurKernelSize=32;Tr.DefaultTextureRatio=.5;C([F()],Tr.prototype,"blurKernelSize",null);C([F()],Tr.prototype,"intensity",null);C([F("options")],Tr.prototype,"_options",void 0);B("BABYLON.GlowLayer",Tr);Te.prototype.getHighlightLayerByName=function(a){var e;for(let t=0;t<((e=this.effectLayers)==null?void 0:e.length);t++)if(this.effectLayers[t].name===a&&this.effectLayers[t].getEffectName()===$r.EffectName)return this.effectLayers[t];return null};class xS extends Ce{constructor(e,t,i,r,s=null,n=Y.BILINEAR_SAMPLINGMODE,o,l){const u={uniforms:kr.Uniforms,size:typeof r=="number"?r:void 0,camera:s,samplingMode:n,engine:o,reusable:l,...r};super(e,kr.FragmentUrl,{effectWrapper:typeof r=="number"||!r.effectWrapper?new kr(e,o,t,i,u):void 0,...u}),this.direction=t,this.kernel=i,this.onApplyObservable.add(()=>{this._effectWrapper.textureWidth=this.width,this._effectWrapper.textureHeight=this.height})}_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(k(()=>Promise.resolve().then(()=>Zu),void 0))):t.push(k(()=>Promise.resolve().then(()=>Xu),void 0)),super._gatherImports(e,t)}}class $r extends pr{static get NeutralColor(){return ur.NeutralColor}static set NeutralColor(e){ur.NeutralColor=e}get innerGlow(){return this._thinEffectLayer.innerGlow}set innerGlow(e){this._thinEffectLayer.innerGlow=e}get outerGlow(){return this._thinEffectLayer.outerGlow}set outerGlow(e){this._thinEffectLayer.outerGlow=e}set blurHorizontalSize(e){this._thinEffectLayer.blurHorizontalSize=e}set blurVerticalSize(e){this._thinEffectLayer.blurVerticalSize=e}get blurHorizontalSize(){return this._thinEffectLayer.blurHorizontalSize}get blurVerticalSize(){return this._thinEffectLayer.blurVerticalSize}constructor(e,t,i){super(e,t,i!==void 0?!!i.forceGLSL:!1,new ur(e,t,i)),this.onBeforeBlurObservable=new j,this.onAfterBlurObservable=new j,this._engine.isStencilEnable||L.Warn("Rendering the Highlight Layer requires the stencil to be active on the canvas. var engine = new Engine(canvas, antialias, { stencil: true }"),this._options={mainTextureRatio:.5,blurTextureSizeRatio:.5,mainTextureFixedSize:0,blurHorizontalSize:1,blurVerticalSize:1,alphaBlendingMode:2,camera:null,renderingGroupId:-1,mainTextureType:0,forceGLSL:!1,isStroke:!1,...i},this._init(this._options),this._shouldRender=!1}getEffectName(){return $r.EffectName}_numInternalDraws(){return 2}_createMergeEffect(){return this._thinEffectLayer._createMergeEffect()}_createTextureAndPostProcesses(){let e=this._mainTextureDesiredSize.width*this._options.blurTextureSizeRatio,t=this._mainTextureDesiredSize.height*this._options.blurTextureSizeRatio;e=this._engine.needPOTTextures?ds(e,this._maxSize):e,t=this._engine.needPOTTextures?ds(t,this._maxSize):t;let i=0;this._engine.getCaps().textureHalfFloatRender?i=2:i=0,this._blurTexture=new Kt("HighlightLayerBlurRTT",{width:e,height:t},this._scene,!1,!0,i),this._blurTexture.wrapU=Y.CLAMP_ADDRESSMODE,this._blurTexture.wrapV=Y.CLAMP_ADDRESSMODE,this._blurTexture.anisotropicFilteringLevel=16,this._blurTexture.updateSamplingMode(Y.TRILINEAR_SAMPLINGMODE),this._blurTexture.renderParticles=!1,this._blurTexture.ignoreCameraViewport=!0,this._textures=[this._blurTexture],this._thinEffectLayer.bindTexturesForCompose=r=>{r.setTexture("textureSampler",this._blurTexture)},this._thinEffectLayer._createTextureAndPostProcesses(),this._options.alphaBlendingMode===2?(this._downSamplePostprocess=new Za("HighlightLayerPPP",{size:this._options.blurTextureSizeRatio,samplingMode:Y.BILINEAR_SAMPLINGMODE,engine:this._scene.getEngine(),effectWrapper:this._thinEffectLayer._postProcesses[0]}),this._downSamplePostprocess.externalTextureSamplerBinding=!0,this._downSamplePostprocess.onApplyObservable.add(r=>{r.setTexture("textureSampler",this._mainTexture)}),this._horizontalBlurPostprocess=new xS("HighlightLayerHBP",new Q(1,0),this._options.blurHorizontalSize,{samplingMode:Y.BILINEAR_SAMPLINGMODE,engine:this._scene.getEngine(),effectWrapper:this._thinEffectLayer._postProcesses[1]}),this._horizontalBlurPostprocess.onApplyObservable.add(r=>{r.setFloat2("screenSize",e,t)}),this._verticalBlurPostprocess=new xS("HighlightLayerVBP",new Q(0,1),this._options.blurVerticalSize,{samplingMode:Y.BILINEAR_SAMPLINGMODE,engine:this._scene.getEngine(),effectWrapper:this._thinEffectLayer._postProcesses[2]}),this._verticalBlurPostprocess.onApplyObservable.add(r=>{r.setFloat2("screenSize",e,t)}),this._postProcesses=[this._downSamplePostprocess,this._horizontalBlurPostprocess,this._verticalBlurPostprocess]):(this._horizontalBlurPostprocess=new zt("HighlightLayerHBP",new Q(1,0),this._options.blurHorizontalSize/2,{size:{width:e,height:t},samplingMode:Y.BILINEAR_SAMPLINGMODE,engine:this._scene.getEngine(),textureType:i,effectWrapper:this._thinEffectLayer._postProcesses[0]}),this._horizontalBlurPostprocess.width=e,this._horizontalBlurPostprocess.height=t,this._horizontalBlurPostprocess.externalTextureSamplerBinding=!0,this._horizontalBlurPostprocess.onApplyObservable.add(r=>{r.setTexture("textureSampler",this._mainTexture)}),this._verticalBlurPostprocess=new zt("HighlightLayerVBP",new Q(0,1),this._options.blurVerticalSize/2,{size:{width:e,height:t},samplingMode:Y.BILINEAR_SAMPLINGMODE,engine:this._scene.getEngine(),textureType:i}),this._postProcesses=[this._horizontalBlurPostprocess,this._verticalBlurPostprocess]),this._mainTexture.onAfterUnbindObservable.add(()=>{this.onBeforeBlurObservable.notifyObservers(this);const r=this._blurTexture.renderTarget;r&&(this._scene.postProcessManager.directRender(this._postProcesses,r,!0),this._engine.unBindFramebuffer(r,!0)),this.onAfterBlurObservable.notifyObservers(this)}),this._postProcesses.map(r=>{r.autoClear=!1})}needStencil(){return this._thinEffectLayer.needStencil()}isReady(e,t){return this._thinEffectLayer.isReady(e,t)}_internalRender(e,t){this._thinEffectLayer._internalCompose(e,t)}shouldRender(){return this._thinEffectLayer.shouldRender()}_shouldRenderMesh(e){return this._thinEffectLayer._shouldRenderMesh(e)}_canRenderMesh(e,t){return this._thinEffectLayer._canRenderMesh(e,t)}_addCustomEffectDefines(e){this._thinEffectLayer._addCustomEffectDefines(e)}_setEmissiveTextureAndColor(e,t,i){this._thinEffectLayer._setEmissiveTextureAndColor(e,t,i)}addExcludedMesh(e){this._thinEffectLayer.addExcludedMesh(e)}removeExcludedMesh(e){this._thinEffectLayer.removeExcludedMesh(e)}hasMesh(e){return this._thinEffectLayer.hasMesh(e)}addMesh(e,t,i=!1){this._thinEffectLayer.addMesh(e,t,i)}removeMesh(e){this._thinEffectLayer.removeMesh(e)}removeAllMeshes(){this._thinEffectLayer.removeAllMeshes()}_disposeMesh(e){this._thinEffectLayer._disposeMesh(e)}getClassName(){return"HighlightLayer"}serialize(){const e=Me.Serialize(this);e.customType="BABYLON.HighlightLayer",e.meshes=[];const t=this._thinEffectLayer._meshes;if(t)for(const r in t){const s=t[r];s&&e.meshes.push({glowEmissiveOnly:s.glowEmissiveOnly,color:s.color.asArray(),meshId:s.mesh.id})}e.excludedMeshes=[];const i=this._thinEffectLayer._excludedMeshes;if(i)for(const r in i){const s=i[r];s&&e.excludedMeshes.push(s.mesh.id)}return e}static Parse(e,t,i){const r=Me.Parse(()=>new $r(e.name,t,e.options),e,t,i);let s;for(s=0;s<e.excludedMeshes.length;s++){const n=t.getMeshById(e.excludedMeshes[s]);n&&r.addExcludedMesh(n)}for(s=0;s<e.meshes.length;s++){const n=e.meshes[s],o=t.getMeshById(n.meshId);o&&r.addMesh(o,ne.FromArray(n.color),n.glowEmissiveOnly)}return r}}$r.EffectName="HighlightLayer";C([F()],$r.prototype,"innerGlow",null);C([F()],$r.prototype,"outerGlow",null);C([F()],$r.prototype,"blurHorizontalSize",null);C([F()],$r.prototype,"blurVerticalSize",null);C([F("options")],$r.prototype,"_options",void 0);B("BABYLON.HighlightLayer",$r);class a1{constructor(e){this.name=ge.NAME_LAYER,this.scene=e||ze.LastCreatedScene,this.scene&&(this._engine=this.scene.getEngine())}register(){this.scene._beforeCameraDrawStage.registerStep(ge.STEP_BEFORECAMERADRAW_LAYER,this,this._drawCameraBackground),this.scene._afterCameraDrawStage.registerStep(ge.STEP_AFTERCAMERADRAW_LAYER,this,this._drawCameraForegroundWithPostProcessing),this.scene._afterCameraPostProcessStage.registerStep(ge.STEP_AFTERCAMERAPOSTPROCESS_LAYER,this,this._drawCameraForegroundWithoutPostProcessing),this.scene._beforeRenderTargetDrawStage.registerStep(ge.STEP_BEFORERENDERTARGETDRAW_LAYER,this,this._drawRenderTargetBackground),this.scene._afterRenderTargetDrawStage.registerStep(ge.STEP_AFTERRENDERTARGETDRAW_LAYER,this,this._drawRenderTargetForegroundWithPostProcessing),this.scene._afterRenderTargetPostProcessStage.registerStep(ge.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER,this,this._drawRenderTargetForegroundWithoutPostProcessing)}rebuild(){const e=this.scene.layers;for(const t of e)t._rebuild()}dispose(){const e=this.scene.layers;for(;e.length;)e[0].dispose()}_draw(e){const t=this.scene.layers;if(t.length){this._engine.setDepthBuffer(!1);for(const i of t)e(i)&&i.render();this._engine.setDepthBuffer(!0)}}_drawCameraPredicate(e,t,i,r){return!e.renderOnlyInRenderTargetTextures&&e.isBackground===t&&e.applyPostProcess===i&&(e.layerMask&r)!==0}_drawCameraBackground(e){this._draw(t=>this._drawCameraPredicate(t,!0,!0,e.layerMask))}_drawCameraForegroundWithPostProcessing(e){this._draw(t=>this._drawCameraPredicate(t,!1,!0,e.layerMask))}_drawCameraForegroundWithoutPostProcessing(e){this._draw(t=>this._drawCameraPredicate(t,!1,!1,e.layerMask))}_drawRenderTargetPredicate(e,t,i,r,s){return e.renderTargetTextures.length>0&&e.isBackground===t&&e.applyPostProcess===i&&e.renderTargetTextures.indexOf(s)>-1&&(e.layerMask&r)!==0}_drawRenderTargetBackground(e){this._draw(t=>this._drawRenderTargetPredicate(t,!0,!0,this.scene.activeCamera.layerMask,e))}_drawRenderTargetForegroundWithPostProcessing(e){this._draw(t=>this._drawRenderTargetPredicate(t,!1,!0,this.scene.activeCamera.layerMask,e))}_drawRenderTargetForegroundWithoutPostProcessing(e){this._draw(t=>this._drawRenderTargetPredicate(t,!1,!1,this.scene.activeCamera.layerMask,e))}addFromContainer(e){e.layers&&e.layers.forEach(t=>{this.scene.layers.push(t)})}removeFromContainer(e,t=!1){e.layers&&e.layers.forEach(i=>{const r=this.scene.layers.indexOf(i);r!==-1&&this.scene.layers.splice(r,1),t&&i.dispose()})}}class Yu{set applyPostProcess(e){this._applyPostProcess=e}get applyPostProcess(){return this.isBackground||this._applyPostProcess}set onDispose(e){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(e)}set onBeforeRender(e){this._onBeforeRenderObserver&&this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),this._onBeforeRenderObserver=this.onBeforeRenderObservable.add(e)}set onAfterRender(e){this._onAfterRenderObserver&&this.onAfterRenderObservable.remove(this._onAfterRenderObserver),this._onAfterRenderObserver=this.onAfterRenderObservable.add(e)}get shaderLanguage(){return this._shaderLanguage}constructor(e,t,i,r,s,n=!1){this.name=e,this._applyPostProcess=!0,this.scale=new Q(1,1),this.offset=new Q(0,0),this.alphaBlendingMode=2,this.layerMask=268435455,this.renderTargetTextures=[],this.renderOnlyInRenderTargetTextures=!1,this.convertToLinearSpace=!1,this.isEnabled=!0,this._vertexBuffers={},this.onDisposeObservable=new j,this.onBeforeRenderObservable=new j,this.onAfterRenderObservable=new j,this._shaderLanguage=0,this._shadersLoaded=!1,this.texture=t?new Y(t,i,!0):null,this.isBackground=r===void 0?!0:r,this.color=s===void 0?new xe(1,1,1,1):s,this._scene=i||ze.LastCreatedScene;const o=this._scene.getEngine();o.isWebGPU&&!n&&!Yu.ForceGLSL&&(this._shaderLanguage=1);let l=this._scene._getComponent(ge.NAME_LAYER);l||(l=new a1(this._scene),this._scene._addComponent(l)),this._scene.layers.push(this),this._drawWrapper=new vi(o);const u=[];u.push(1,1),u.push(-1,1),u.push(-1,-1),u.push(1,-1);const c=new N(o,u,N.PositionKind,!1,!1,2);this._vertexBuffers[N.PositionKind]=c,this._createIndexBuffer()}_createIndexBuffer(){const e=this._scene.getEngine(),t=[];t.push(0),t.push(1),t.push(2),t.push(0),t.push(2),t.push(3),this._indexBuffer=e.createIndexBuffer(t)}_rebuild(){const e=this._vertexBuffers[N.PositionKind];e&&e._rebuild(),this._createIndexBuffer()}isReady(){const e=this._scene.getEngine();let t="";this.alphaTest&&(t="#define ALPHATEST"),this.texture&&(this.texture.gammaSpace?this.convertToLinearSpace&&(t+=`
#define CONVERT_TO_LINEAR`):this.convertToLinearSpace||(t+=`
#define CONVERT_TO_GAMMA`)),this._previousDefines!==t&&(this._previousDefines=t,this._drawWrapper.effect=e.createEffect("layer",[N.PositionKind],["textureMatrix","color","scale","offset"],["textureSampler"],t,void 0,void 0,void 0,void 0,this._shaderLanguage,this._shadersLoaded?void 0:async()=>{this._shaderLanguage===1?await Promise.all([k(()=>Promise.resolve().then(()=>R1),void 0),k(()=>Promise.resolve().then(()=>E1),void 0)]):await Promise.all([k(()=>Promise.resolve().then(()=>C1),void 0),k(()=>Promise.resolve().then(()=>y1),void 0)]),this._shadersLoaded=!0}));const i=this._drawWrapper.effect;return!!(i!=null&&i.isReady())&&(!this.texture||this.texture.isReady())}render(){if(!this.isEnabled)return;const e=this._scene.getEngine();if(!this.isReady())return;const t=this._drawWrapper.effect;this.onBeforeRenderObservable.notifyObservers(this),e.enableEffect(this._drawWrapper),e.setState(!1),this.texture&&(t.setTexture("textureSampler",this.texture),t.setMatrix("textureMatrix",this.texture.getTextureMatrix())),t.setFloat4("color",this.color.r,this.color.g,this.color.b,this.color.a),t.setVector2("offset",this.offset),t.setVector2("scale",this.scale),e.bindBuffers(this._vertexBuffers,this._indexBuffer,t),this.alphaTest?e.drawElementsType(ft.TriangleFillMode,0,6):(e.setAlphaMode(this.alphaBlendingMode),e.drawElementsType(ft.TriangleFillMode,0,6),e.setAlphaMode(0)),this.onAfterRenderObservable.notifyObservers(this)}dispose(){const e=this._vertexBuffers[N.PositionKind];e&&(e.dispose(),this._vertexBuffers[N.PositionKind]=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null),this.texture&&(this.texture.dispose(),this.texture=null),this.renderTargetTextures=[];const t=this._scene.layers.indexOf(this);this._scene.layers.splice(t,1),this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this.onAfterRenderObservable.clear(),this.onBeforeRenderObservable.clear()}}Yu.ForceGLSL=!1;const ph="glowMapGenerationPixelShader",Z0=`#if defined(DIFFUSE_ISLINEAR) || defined(EMISSIVE_ISLINEAR)
#include<helperFunctions>
#endif
#ifdef DIFFUSE
varying vec2 vUVDiffuse;uniform sampler2D diffuseSampler;
#endif
#ifdef OPACITY
varying vec2 vUVOpacity;uniform sampler2D opacitySampler;uniform float opacityIntensity;
#endif
#ifdef EMISSIVE
varying vec2 vUVEmissive;uniform sampler2D emissiveSampler;
#endif
#ifdef VERTEXALPHA
varying vec4 vColor;
#endif
uniform vec4 glowColor;uniform float glowIntensity;
#include<clipPlaneFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#include<clipPlaneFragment>
vec4 finalColor=glowColor;
#ifdef DIFFUSE
vec4 albedoTexture=texture2D(diffuseSampler,vUVDiffuse);
#ifdef DIFFUSE_ISLINEAR
albedoTexture=toGammaSpace(albedoTexture);
#endif
#ifdef GLOW
finalColor.a*=albedoTexture.a;
#endif
#ifdef HIGHLIGHT
finalColor.a=albedoTexture.a;
#endif
#endif
#ifdef OPACITY
vec4 opacityMap=texture2D(opacitySampler,vUVOpacity);
#ifdef OPACITYRGB
finalColor.a*=getLuminance(opacityMap.rgb);
#else
finalColor.a*=opacityMap.a;
#endif
finalColor.a*=opacityIntensity;
#endif
#ifdef VERTEXALPHA
finalColor.a*=vColor.a;
#endif
#ifdef ALPHATEST
if (finalColor.a<ALPHATESTVALUE)
discard;
#endif
#ifdef EMISSIVE
vec4 emissive=texture2D(emissiveSampler,vUVEmissive);
#ifdef EMISSIVE_ISLINEAR
emissive=toGammaSpace(emissive);
#endif
gl_FragColor=emissive*finalColor*glowIntensity;
#else
gl_FragColor=finalColor*glowIntensity;
#endif
#ifdef HIGHLIGHT
gl_FragColor.a=glowColor.a;
#endif
}`;P.ShadersStore[ph]||(P.ShadersStore[ph]=Z0);const o1={name:ph,shader:Z0},l1=Object.freeze(Object.defineProperty({__proto__:null,glowMapGenerationPixelShader:o1},Symbol.toStringTag,{value:"Module"})),mh="glowMapGenerationVertexShader",q0=`attribute vec3 position;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;varying vec4 vPosition;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#ifdef DIFFUSE
varying vec2 vUVDiffuse;uniform mat4 diffuseMatrix;
#endif
#ifdef OPACITY
varying vec2 vUVOpacity;uniform mat4 opacityMatrix;
#endif
#ifdef EMISSIVE
varying vec2 vUVEmissive;uniform mat4 emissiveMatrix;
#endif
#ifdef VERTEXALPHA
attribute vec4 color;varying vec4 vColor;
#endif
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{vec3 positionUpdated=position;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#ifdef UV2
vec2 uv2Updated=uv2;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#ifdef CUBEMAP
vPosition=worldPos;gl_Position=viewProjection*finalWorld*vec4(position,1.0);
#else
vPosition=viewProjection*worldPos;gl_Position=vPosition;
#endif
#ifdef DIFFUSE
#ifdef DIFFUSEUV1
vUVDiffuse=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef DIFFUSEUV2
vUVDiffuse=vec2(diffuseMatrix*vec4(uv2Updated,1.0,0.0));
#endif
#endif
#ifdef OPACITY
#ifdef OPACITYUV1
vUVOpacity=vec2(opacityMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef OPACITYUV2
vUVOpacity=vec2(opacityMatrix*vec4(uv2Updated,1.0,0.0));
#endif
#endif
#ifdef EMISSIVE
#ifdef EMISSIVEUV1
vUVEmissive=vec2(emissiveMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef EMISSIVEUV2
vUVEmissive=vec2(emissiveMatrix*vec4(uv2Updated,1.0,0.0));
#endif
#endif
#ifdef VERTEXALPHA
vColor=color;
#endif
#include<clipPlaneVertex>
}`;P.ShadersStore[mh]||(P.ShadersStore[mh]=q0);const u1={name:mh,shader:q0},c1=Object.freeze(Object.defineProperty({__proto__:null,glowMapGenerationVertexShader:u1},Symbol.toStringTag,{value:"Module"})),_h="glowMapGenerationPixelShader",Q0=`#if defined(DIFFUSE_ISLINEAR) || defined(EMISSIVE_ISLINEAR)
#include<helperFunctions>
#endif
#ifdef DIFFUSE
varying vUVDiffuse: vec2f;var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;
#endif
#ifdef OPACITY
varying vUVOpacity: vec2f;var opacitySamplerSampler: sampler;var opacitySampler: texture_2d<f32>;uniform opacityIntensity: f32;
#endif
#ifdef EMISSIVE
varying vUVEmissive: vec2f;var emissiveSamplerSampler: sampler;var emissiveSampler: texture_2d<f32>;
#endif
#ifdef VERTEXALPHA
varying vColor: vec4f;
#endif
uniform glowColor: vec4f;uniform glowIntensity: f32;
#include<clipPlaneFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#include<clipPlaneFragment>
var finalColor: vec4f=uniforms.glowColor;
#ifdef DIFFUSE
var albedoTexture: vec4f=textureSample(diffuseSampler,diffuseSamplerSampler,fragmentInputs.vUVDiffuse);
#ifdef DIFFUSE_ISLINEAR
albedoTexture=toGammaSpace(albedoTexture);
#endif
#ifdef GLOW
finalColor=vec4f(finalColor.rgb,finalColor.a*albedoTexture.a);
#endif
#ifdef HIGHLIGHT
finalColor=vec4f(finalColor.rgb,albedoTexture.a);
#endif
#endif
#ifdef OPACITY
var opacityMap: vec4f=textureSample(opacitySampler,opacitySamplerSampler,fragmentInputs.vUVOpacity);
#ifdef OPACITYRGB
finalColor=vec4f(finalColor.rgb,finalColor.a*getLuminance(opacityMap.rgb));
#else
finalColor=vec4f(finalColor.rgb,finalColor.a*opacityMap.a);
#endif
finalColor=vec4f(finalColor.rgb,finalColor.a*uniforms.opacityIntensity);
#endif
#ifdef VERTEXALPHA
finalColor=vec4f(finalColor.rgb,finalColor.a*fragmentInputs.vColor.a);
#endif
#ifdef ALPHATEST
if (finalColor.a<ALPHATESTVALUE) {discard;}
#endif
#ifdef EMISSIVE
var emissive: vec4f=textureSample(emissiveSampler,emissiveSamplerSampler,fragmentInputs.vUVEmissive);
#ifdef EMISSIVE_ISLINEAR
emissive=toGammaSpace(emissive);
#endif
fragmentOutputs.color=emissive*finalColor*uniforms.glowIntensity;
#else
fragmentOutputs.color=finalColor*uniforms.glowIntensity;
#endif
#ifdef HIGHLIGHT
fragmentOutputs.color=vec4f(fragmentOutputs.color.rgb,uniforms.glowColor.a);
#endif
}
`;P.ShadersStoreWGSL[_h]||(P.ShadersStoreWGSL[_h]=Q0);const h1={name:_h,shader:Q0},d1=Object.freeze(Object.defineProperty({__proto__:null,glowMapGenerationPixelShaderWGSL:h1},Symbol.toStringTag,{value:"Module"})),gh="glowMapGenerationVertexShader",K0=`attribute position: vec3f;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform viewProjection: mat4x4f;varying vPosition: vec4f;
#ifdef UV1
attribute uv: vec2f;
#endif
#ifdef UV2
attribute uv2: vec2f;
#endif
#ifdef DIFFUSE
varying vUVDiffuse: vec2f;uniform diffuseMatrix: mat4x4f;
#endif
#ifdef OPACITY
varying vUVOpacity: vec2f;uniform opacityMatrix: mat4x4f;
#endif
#ifdef EMISSIVE
varying vUVEmissive: vec2f;uniform emissiveMatrix: mat4x4f;
#endif
#ifdef VERTEXALPHA
attribute color: vec4f;varying vColor: vec4f;
#endif
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {var positionUpdated: vec3f=input.position;
#ifdef UV1
var uvUpdated: vec2f=input.uv;
#endif
#ifdef UV2
var uv2Updated: vec2f=input.uv2;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
var worldPos: vec4f=finalWorld* vec4f(positionUpdated,1.0);
#ifdef CUBEMAP
vertexOutputs.vPosition=worldPos;vertexOutputs.position=uniforms.viewProjection*finalWorld* vec4f(input.position,1.0);
#else
vertexOutputs.vPosition=uniforms.viewProjection*worldPos;vertexOutputs.position=vertexOutputs.vPosition;
#endif
#ifdef DIFFUSE
#ifdef DIFFUSEUV1
vertexOutputs.vUVDiffuse= (uniforms.diffuseMatrix* vec4f(uvUpdated,1.0,0.0)).xy;
#endif
#ifdef DIFFUSEUV2
vertexOutputs.vUVDiffuse= (uniforms.diffuseMatrix* vec4f(uv2Updated,1.0,0.0)).xy;
#endif
#endif
#ifdef OPACITY
#ifdef OPACITYUV1
vertexOutputs.vUVOpacity= (uniforms.opacityMatrix* vec4f(uvUpdated,1.0,0.0)).xy;
#endif
#ifdef OPACITYUV2
vertexOutputs.vUVOpacity= (uniforms.opacityMatrix* vec4f(uv2Updated,1.0,0.0)).xy;
#endif
#endif
#ifdef EMISSIVE
#ifdef EMISSIVEUV1
vertexOutputs.vUVEmissive= (uniforms.emissiveMatrix* vec4f(uvUpdated,1.0,0.0)).xy;
#endif
#ifdef EMISSIVEUV2
vertexOutputs.vUVEmissive= (uniforms.emissiveMatrix* vec4f(uv2Updated,1.0,0.0)).xy;
#endif
#endif
#ifdef VERTEXALPHA
vertexOutputs.vColor=vertexInputs.color;
#endif
#include<clipPlaneVertex>
}`;P.ShadersStoreWGSL[gh]||(P.ShadersStoreWGSL[gh]=K0);const f1={name:gh,shader:K0},p1=Object.freeze(Object.defineProperty({__proto__:null,glowMapGenerationVertexShaderWGSL:f1},Symbol.toStringTag,{value:"Module"})),xh="glowMapMergePixelShader",J0=`varying vec2 vUV;uniform sampler2D textureSampler;
#ifdef EMISSIVE
uniform sampler2D textureSampler2;
#endif
uniform float offset;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
vec4 baseColor=texture2D(textureSampler,vUV);
#ifdef EMISSIVE
baseColor+=texture2D(textureSampler2,vUV);baseColor*=offset;
#else
baseColor.a=abs(offset-baseColor.a);
#ifdef STROKE
float alpha=smoothstep(.0,.1,baseColor.a);baseColor.a=alpha;baseColor.rgb=baseColor.rgb*alpha;
#endif
#endif
#if LDR
baseColor=clamp(baseColor,0.,1.0);
#endif
gl_FragColor=baseColor;
#define CUSTOM_FRAGMENT_MAIN_END
}`;P.ShadersStore[xh]||(P.ShadersStore[xh]=J0);const m1={name:xh,shader:J0},eT=Object.freeze(Object.defineProperty({__proto__:null,glowMapMergePixelShader:m1},Symbol.toStringTag,{value:"Module"})),Sh="glowMapMergeVertexShader",tT=`attribute vec2 position;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vUV=position*madd+madd;gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStore[Sh]||(P.ShadersStore[Sh]=tT);const _1={name:Sh,shader:tT},iT=Object.freeze(Object.defineProperty({__proto__:null,glowMapMergeVertexShader:_1},Symbol.toStringTag,{value:"Module"})),vh="glowBlurPostProcessPixelShader",rT=`varying vec2 vUV;uniform sampler2D textureSampler;uniform vec2 screenSize;uniform vec2 direction;uniform float blurWidth;float getLuminance(vec3 color)
{return dot(color,vec3(0.2126,0.7152,0.0722));}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{float weights[7];weights[0]=0.05;weights[1]=0.1;weights[2]=0.2;weights[3]=0.3;weights[4]=0.2;weights[5]=0.1;weights[6]=0.05;vec2 texelSize=vec2(1.0/screenSize.x,1.0/screenSize.y);vec2 texelStep=texelSize*direction*blurWidth;vec2 start=vUV-3.0*texelStep;vec4 baseColor=vec4(0.,0.,0.,0.);vec2 texelOffset=vec2(0.,0.);for (int i=0; i<7; i++)
{vec4 texel=texture2D(textureSampler,start+texelOffset);baseColor.a+=texel.a*weights[i];float luminance=getLuminance(baseColor.rgb);float luminanceTexel=getLuminance(texel.rgb);float choice=step(luminanceTexel,luminance);baseColor.rgb=choice*baseColor.rgb+(1.0-choice)*texel.rgb;texelOffset+=texelStep;}
gl_FragColor=baseColor;}`;P.ShadersStore[vh]||(P.ShadersStore[vh]=rT);const g1={name:vh,shader:rT},Xu=Object.freeze(Object.defineProperty({__proto__:null,glowBlurPostProcessPixelShader:g1},Symbol.toStringTag,{value:"Module"})),bh="glowMapMergePixelShader",sT=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;
#ifdef EMISSIVE
var textureSampler2Sampler: sampler;var textureSampler2: texture_2d<f32>;
#endif
uniform offset: f32;
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
var baseColor: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV);
#ifdef EMISSIVE
baseColor+=textureSample(textureSampler2,textureSampler2Sampler,input.vUV);baseColor*=uniforms.offset;
#else
baseColor=vec4f(baseColor.rgb,abs(uniforms.offset-baseColor.a));
#ifdef STROKE
var alpha: f32=smoothstep(.0,.1,baseColor.a);baseColor=vec4f(baseColor.rgb*alpha,alpha);
#endif
#endif
#if LDR
baseColor=clamp(baseColor,vec4f(0.),vec4f(1.0));
#endif
fragmentOutputs.color=baseColor;
#define CUSTOM_FRAGMENT_MAIN_END
}
`;P.ShadersStoreWGSL[bh]||(P.ShadersStoreWGSL[bh]=sT);const x1={name:bh,shader:sT},nT=Object.freeze(Object.defineProperty({__proto__:null,glowMapMergePixelShaderWGSL:x1},Symbol.toStringTag,{value:"Module"})),yh="glowMapMergeVertexShader",aT=`attribute position: vec2f;varying vUV: vec2f;
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {const madd: vec2f= vec2f(0.5,0.5);
#define CUSTOM_VERTEX_MAIN_BEGIN
vertexOutputs.vUV=input.position*madd+madd;vertexOutputs.position= vec4f(input.position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStoreWGSL[yh]||(P.ShadersStoreWGSL[yh]=aT);const S1={name:yh,shader:aT},oT=Object.freeze(Object.defineProperty({__proto__:null,glowMapMergeVertexShaderWGSL:S1},Symbol.toStringTag,{value:"Module"})),Th="glowBlurPostProcessPixelShader",lT=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform screenSize: vec2f;uniform direction: vec2f;uniform blurWidth: f32;fn getLuminance(color: vec3f)->f32
{return dot(color, vec3f(0.2126,0.7152,0.0722));}
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var weights: array<f32 ,7>;weights[0]=0.05;weights[1]=0.1;weights[2]=0.2;weights[3]=0.3;weights[4]=0.2;weights[5]=0.1;weights[6]=0.05;var texelSize: vec2f= vec2f(1.0/uniforms.screenSize.x,1.0/uniforms.screenSize.y);var texelStep: vec2f=texelSize*uniforms.direction*uniforms.blurWidth;var start: vec2f=input.vUV-3.0*texelStep;var baseColor: vec4f= vec4f(0.,0.,0.,0.);var texelOffset: vec2f= vec2f(0.,0.);for (var i: i32=0; i<7; i++)
{var texel: vec4f=textureSample(textureSampler,textureSamplerSampler,start+texelOffset);baseColor=vec4f(baseColor.rgb,baseColor.a+texel.a*weights[i]);var luminance: f32=getLuminance(baseColor.rgb);var luminanceTexel: f32=getLuminance(texel.rgb);var choice: f32=step(luminanceTexel,luminance);baseColor=vec4f(choice*baseColor.rgb+(1.0-choice)*texel.rgb,baseColor.a);texelOffset+=texelStep;}
fragmentOutputs.color=baseColor;}`;P.ShadersStoreWGSL[Th]||(P.ShadersStoreWGSL[Th]=lT);const v1={name:Th,shader:lT},Zu=Object.freeze(Object.defineProperty({__proto__:null,glowBlurPostProcessPixelShaderWGSL:v1},Symbol.toStringTag,{value:"Module"})),Ch="layerPixelShader",uT=`varying vec2 vUV;uniform sampler2D textureSampler;uniform vec4 color;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
vec4 baseColor=texture2D(textureSampler,vUV);
#if defined(CONVERT_TO_GAMMA)
baseColor.rgb=toGammaSpace(baseColor.rgb);
#elif defined(CONVERT_TO_LINEAR)
baseColor.rgb=toLinearSpace(baseColor.rgb);
#endif
#ifdef ALPHATEST
if (baseColor.a<0.4)
discard;
#endif
gl_FragColor=baseColor*color;
#define CUSTOM_FRAGMENT_MAIN_END
}`;P.ShadersStore[Ch]||(P.ShadersStore[Ch]=uT);const b1={name:Ch,shader:uT},y1=Object.freeze(Object.defineProperty({__proto__:null,layerPixelShader:b1},Symbol.toStringTag,{value:"Module"})),Ph="layerVertexShader",cT=`attribute vec2 position;uniform vec2 scale;uniform vec2 offset;uniform mat4 textureMatrix;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec2 shiftedPosition=position*scale+offset;vUV=vec2(textureMatrix*vec4(shiftedPosition*madd+madd,1.0,0.0));gl_Position=vec4(shiftedPosition,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStore[Ph]||(P.ShadersStore[Ph]=cT);const T1={name:Ph,shader:cT},C1=Object.freeze(Object.defineProperty({__proto__:null,layerVertexShader:T1},Symbol.toStringTag,{value:"Module"})),Eh="layerPixelShader",hT=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform color: vec4f;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
var baseColor: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV);
#if defined(CONVERT_TO_GAMMA)
baseColor=toGammaSpace(baseColor);
#elif defined(CONVERT_TO_LINEAR)
baseColor=toLinearSpaceVec4(baseColor);
#endif
#ifdef ALPHATEST
if (baseColor.a<0.4) {discard;}
#endif
fragmentOutputs.color=baseColor*uniforms.color;
#define CUSTOM_FRAGMENT_MAIN_END
}`;P.ShadersStoreWGSL[Eh]||(P.ShadersStoreWGSL[Eh]=hT);const P1={name:Eh,shader:hT},E1=Object.freeze(Object.defineProperty({__proto__:null,layerPixelShaderWGSL:P1},Symbol.toStringTag,{value:"Module"})),Ih="layerVertexShader",dT=`attribute position: vec2f;uniform scale: vec2f;uniform offset: vec2f;uniform textureMatrix: mat4x4f;varying vUV: vec2f;const madd: vec2f= vec2f(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
var shiftedPosition: vec2f=input.position*uniforms.scale+uniforms.offset;vertexOutputs.vUV=(uniforms.textureMatrix* vec4f(shiftedPosition*madd+madd,1.0,0.0)).xy;vertexOutputs.position= vec4f(shiftedPosition,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStoreWGSL[Ih]||(P.ShadersStoreWGSL[Ih]=dT);const I1={name:Ih,shader:dT},R1=Object.freeze(Object.defineProperty({__proto__:null,layerVertexShaderWGSL:I1},Symbol.toStringTag,{value:"Module"}));class V_{static AddFlare(e,t,i,r,s){return new V_(e,t,i,r,s)}constructor(e,t,i,r,s){this.size=e,this.position=t,this.alphaMode=6,this.color=i||new ne(1,1,1),this.texture=r?new Y(r,s.getScene(),!0):null,this._system=s;const n=s.scene.getEngine();s._onShadersLoaded.addOnce(()=>{this._drawWrapper=new vi(n),this._drawWrapper.effect=n.createEffect("lensFlare",[N.PositionKind],["color","viewportMatrix"],["textureSampler"],"",void 0,void 0,void 0,void 0,s.shaderLanguage)}),s.lensFlares.push(this)}dispose(){this.texture&&this.texture.dispose();const e=this._system.lensFlares.indexOf(this);this._system.lensFlares.splice(e,1)}}class nn{get scene(){return this._scene}get shaderLanguage(){return this._shaderLanguage}constructor(e,t,i){this.name=e,this.lensFlares=[],this.borderLimit=300,this.viewportBorder=0,this.layerMask=268435455,this._shaderLanguage=0,this._vertexBuffers={},this._isEnabled=!0,this._onShadersLoaded=new j(void 0,!0),this._shadersLoaded=!1,this._scene=i||ze.LastCreatedScene,nn._SceneComponentInitialization(this._scene),this._emitter=t,this.id=e,i.lensFlareSystems.push(this),this.meshesSelectionPredicate=n=>i.activeCamera&&n.material&&n.isVisible&&n.isEnabled()&&n.isBlocker&&(n.layerMask&i.activeCamera.layerMask)!=0;const r=i.getEngine(),s=[];s.push(1,1),s.push(-1,1),s.push(-1,-1),s.push(1,-1),this._vertexBuffers[N.PositionKind]=new N(r,s,N.PositionKind,!1,!1,2),this._createIndexBuffer(),this._initShaderSourceAsync()}async _initShaderSourceAsync(){this._scene.getEngine().isWebGPU&&!nn.ForceGLSL?(this._shaderLanguage=1,await Promise.all([k(()=>Promise.resolve().then(()=>F1),void 0),k(()=>Promise.resolve().then(()=>B1),void 0)])):await Promise.all([k(()=>Promise.resolve().then(()=>D1),void 0),k(()=>Promise.resolve().then(()=>w1),void 0)]),this._shadersLoaded=!0,this._onShadersLoaded.notifyObservers()}_createIndexBuffer(){const e=[];e.push(0),e.push(1),e.push(2),e.push(0),e.push(2),e.push(3),this._indexBuffer=this._scene.getEngine().createIndexBuffer(e)}get isEnabled(){return this._isEnabled}set isEnabled(e){this._isEnabled=e}getScene(){return this._scene}getEmitter(){return this._emitter}setEmitter(e){this._emitter=e}getEmitterPosition(){return this._emitter.getAbsolutePosition?this._emitter.getAbsolutePosition():this._emitter.position}computeEffectivePosition(e){let t=this.getEmitterPosition();t=m.Project(t,$.Identity(),this._scene.getTransformMatrix(),e),this._positionX=t.x,this._positionY=t.y,t=m.TransformCoordinates(this.getEmitterPosition(),this._scene.getViewMatrix()),this.viewportBorder>0&&(e.x-=this.viewportBorder,e.y-=this.viewportBorder,e.width+=this.viewportBorder*2,e.height+=this.viewportBorder*2,t.x+=this.viewportBorder,t.y+=this.viewportBorder,this._positionX+=this.viewportBorder,this._positionY+=this.viewportBorder);const i=this._scene.useRightHandedSystem;return t.z>0&&!i||t.z<0&&i?(this._positionX>e.x&&this._positionX<e.x+e.width&&this._positionY>e.y&&this._positionY<e.y+e.height,!0):!1}_isVisible(){if(!this._isEnabled||!this._scene.activeCamera)return!1;const t=this.getEmitterPosition().subtract(this._scene.activeCamera.globalPosition),i=t.length();t.normalize();const r=new Zt(this._scene.activeCamera.globalPosition,t),s=this._scene.pickWithRay(r,this.meshesSelectionPredicate,!0);return!s||!s.hit||s.distance>i}render(){if(!this._scene.activeCamera||!this._shadersLoaded)return!1;const e=this._scene.getEngine(),i=this._scene.activeCamera.viewport.toGlobal(e.getRenderWidth(!0),e.getRenderHeight(!0));if(!this.computeEffectivePosition(i)||!this._isVisible())return!1;let r,s;this._positionX<this.borderLimit+i.x?r=this.borderLimit+i.x-this._positionX:this._positionX>i.x+i.width-this.borderLimit?r=this._positionX-i.x-i.width+this.borderLimit:r=0,this._positionY<this.borderLimit+i.y?s=this.borderLimit+i.y-this._positionY:this._positionY>i.y+i.height-this.borderLimit?s=this._positionY-i.y-i.height+this.borderLimit:s=0;let n=r>s?r:s;n-=this.viewportBorder,n>this.borderLimit&&(n=this.borderLimit);let o=1-Si(n/this.borderLimit,0,1);if(o<0)return!1;o>1&&(o=1),this.viewportBorder>0&&(i.x+=this.viewportBorder,i.y+=this.viewportBorder,i.width-=this.viewportBorder*2,i.height-=this.viewportBorder*2,this._positionX-=this.viewportBorder,this._positionY-=this.viewportBorder);const l=i.x+i.width/2,u=i.y+i.height/2,c=l-this._positionX,h=u-this._positionY;e.setState(!1),e.setDepthBuffer(!1);for(let d=0;d<this.lensFlares.length;d++){const f=this.lensFlares[d];if(!f._drawWrapper.effect.isReady()||f.texture&&!f.texture.isReady())continue;e.enableEffect(f._drawWrapper),e.bindBuffers(this._vertexBuffers,this._indexBuffer,f._drawWrapper.effect),e.setAlphaMode(f.alphaMode);const p=l-c*f.position,g=u-h*f.position,_=f.size,S=f.size*e.getAspectRatio(this._scene.activeCamera,!0),b=2*((p-i.x)/i.width)-1,y=1-2*((g-i.y)/i.height),T=$.FromValues(_/2,0,0,0,0,S/2,0,0,0,0,1,0,b,y,0,1);f._drawWrapper.effect.setMatrix("viewportMatrix",T),f._drawWrapper.effect.setTexture("textureSampler",f.texture),f._drawWrapper.effect.setFloat4("color",f.color.r*o,f.color.g*o,f.color.b*o,1),e.drawElementsType(ft.TriangleFillMode,0,6)}return e.setDepthBuffer(!0),e.setAlphaMode(0),!0}rebuild(){var e;this._createIndexBuffer();for(const t in this._vertexBuffers)(e=this._vertexBuffers[t])==null||e._rebuild()}dispose(){this._onShadersLoaded.clear();const e=this._vertexBuffers[N.PositionKind];for(e&&(e.dispose(),this._vertexBuffers[N.PositionKind]=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null);this.lensFlares.length;)this.lensFlares[0].dispose();const t=this._scene.lensFlareSystems.indexOf(this);this._scene.lensFlareSystems.splice(t,1)}static Parse(e,t,i){const r=t.getLastEntryById(e.emitterId),s=e.name||"lensFlareSystem#"+e.emitterId,n=new nn(s,r,t);n.id=e.id||s,n.borderLimit=e.borderLimit;for(let o=0;o<e.flares.length;o++){const l=e.flares[o];V_.AddFlare(l.size,l.position,ne.FromArray(l.color),l.textureName?i+l.textureName:"",n)}return n}serialize(){const e={};e.id=this.id,e.name=this.name,e.emitterId=this.getEmitter().id,e.borderLimit=this.borderLimit,e.flares=[];for(let t=0;t<this.lensFlares.length;t++){const i=this.lensFlares[t];e.flares.push({size:i.size,position:i.position,color:i.color.asArray(),textureName:ae.GetFilename(i.texture?i.texture.name:"")})}return e}}nn.ForceGLSL=!1;nn._SceneComponentInitialization=a=>{throw Cr("LensFlareSystemSceneComponent")};rl(ge.NAME_LENSFLARESYSTEM,(a,e,t,i)=>{if(a.lensFlareSystems!==void 0&&a.lensFlareSystems!==null){t.lensFlareSystems||(t.lensFlareSystems=[]);for(let r=0,s=a.lensFlareSystems.length;r<s;r++){const n=a.lensFlareSystems[r],o=nn.Parse(n,e,i);t.lensFlareSystems.push(o)}}});Te.prototype.getLensFlareSystemByName=function(a){for(let e=0;e<this.lensFlareSystems.length;e++)if(this.lensFlareSystems[e].name===a)return this.lensFlareSystems[e];return null};Te.prototype.getLensFlareSystemById=function(a){for(let e=0;e<this.lensFlareSystems.length;e++)if(this.lensFlareSystems[e].id===a)return this.lensFlareSystems[e];return null};Te.prototype.getLensFlareSystemByID=function(a){return this.getLensFlareSystemById(a)};Te.prototype.removeLensFlareSystem=function(a){const e=this.lensFlareSystems.indexOf(a);return e!==-1&&this.lensFlareSystems.splice(e,1),e};Te.prototype.addLensFlareSystem=function(a){this.lensFlareSystems.push(a)};class M1{constructor(e){this.name=ge.NAME_LENSFLARESYSTEM,this.scene=e}register(){this.scene._afterCameraDrawStage.registerStep(ge.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM,this,this._draw)}rebuild(){for(let e=0;e<this.scene.lensFlareSystems.length;e++)this.scene.lensFlareSystems[e].rebuild()}addFromContainer(e){e.lensFlareSystems&&e.lensFlareSystems.forEach(t=>{this.scene.addLensFlareSystem(t)})}removeFromContainer(e,t){e.lensFlareSystems&&e.lensFlareSystems.forEach(i=>{this.scene.removeLensFlareSystem(i),t&&i.dispose()})}serialize(e){e.lensFlareSystems=[];const t=this.scene.lensFlareSystems;for(const i of t)e.lensFlareSystems.push(i.serialize())}dispose(){const e=this.scene.lensFlareSystems;for(;e.length;)e[0].dispose()}_draw(e){if(this.scene.lensFlaresEnabled){const t=this.scene.lensFlareSystems;ae.StartPerformanceCounter("Lens flares",t.length>0);for(const i of t)e.layerMask&i.layerMask&&i.render();ae.EndPerformanceCounter("Lens flares",t.length>0)}}}nn._SceneComponentInitialization=a=>{let e=a._getComponent(ge.NAME_LENSFLARESYSTEM);e||(e=new M1(a),a._addComponent(e))};const Rh="lensFlarePixelShader",fT=`varying vec2 vUV;uniform sampler2D textureSampler;uniform vec4 color;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
vec4 baseColor=texture2D(textureSampler,vUV);gl_FragColor=baseColor*color;
#define CUSTOM_FRAGMENT_MAIN_END
}`;P.ShadersStore[Rh]||(P.ShadersStore[Rh]=fT);const A1={name:Rh,shader:fT},D1=Object.freeze(Object.defineProperty({__proto__:null,lensFlarePixelShader:A1},Symbol.toStringTag,{value:"Module"})),Mh="lensFlareVertexShader",pT=`attribute vec2 position;uniform mat4 viewportMatrix;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vUV=position*madd+madd;gl_Position=viewportMatrix*vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStore[Mh]||(P.ShadersStore[Mh]=pT);const O1={name:Mh,shader:pT},w1=Object.freeze(Object.defineProperty({__proto__:null,lensFlareVertexShader:O1},Symbol.toStringTag,{value:"Module"})),Ah="lensFlarePixelShader",mT=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform color: vec4f;
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
var baseColor: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV);fragmentOutputs.color=baseColor*uniforms.color;
#define CUSTOM_FRAGMENT_MAIN_END
}`;P.ShadersStoreWGSL[Ah]||(P.ShadersStoreWGSL[Ah]=mT);const N1={name:Ah,shader:mT},F1=Object.freeze(Object.defineProperty({__proto__:null,lensFlarePixelShaderWGSL:N1},Symbol.toStringTag,{value:"Module"})),Dh="lensFlareVertexShader",_T=`attribute position: vec2f;uniform viewportMatrix: mat4x4f;varying vUV: vec2f;const madd: vec2f= vec2f(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
vertexOutputs.vUV=input.position*madd+madd;vertexOutputs.position=uniforms.viewportMatrix* vec4f(input.position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStoreWGSL[Dh]||(P.ShadersStoreWGSL[Dh]=_T);const L1={name:Dh,shader:_T},B1=Object.freeze(Object.defineProperty({__proto__:null,lensFlareVertexShaderWGSL:L1},Symbol.toStringTag,{value:"Module"}));rl(ge.NAME_SHADOWGENERATOR,(a,e)=>{if(a.shadowGenerators!==void 0&&a.shadowGenerators!==null)for(let t=0,i=a.shadowGenerators.length;t<i;t++){const r=a.shadowGenerators[t];r.className===Vt.CLASSNAME?Vt.Parse(r,e):de.Parse(r,e)}});class V1{constructor(e){this.name=ge.NAME_SHADOWGENERATOR,this.scene=e}register(){this.scene._gatherRenderTargetsStage.registerStep(ge.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR,this,this._gatherRenderTargets)}rebuild(){}serialize(e){e.shadowGenerators=[];const t=this.scene.lights;for(const i of t){if(i.doNotSerialize)continue;const r=i.getShadowGenerators();if(r){const s=r.values();for(let n=s.next();n.done!==!0;n=s.next()){const o=n.value;o.doNotSerialize||e.shadowGenerators.push(o.serialize())}}}}addFromContainer(e){}removeFromContainer(e,t){}dispose(){}_gatherRenderTargets(e){const t=this.scene;if(this.scene.shadowsEnabled)for(let i=0;i<t.lights.length;i++){const r=t.lights[i],s=r.getShadowGenerators();if(r.isEnabled()&&r.shadowEnabled&&s){const n=s.values();for(let o=n.next();o.done!==!0;o=n.next()){const u=o.value.getShadowMap();t.textures.indexOf(u)!==-1&&e.push(u)}}}}}de._SceneComponentInitialization=a=>{let e=a._getComponent(ge.NAME_SHADOWGENERATOR);e||(e=new V1(a),a._addComponent(e))};const Oh="packingFunctions",gT=`fn pack(depth: f32)->vec4f
{const bit_shift: vec4f= vec4f(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const bit_mask: vec4f= vec4f(0.0,1.0/255.0,1.0/255.0,1.0/255.0);var res: vec4f=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}
fn unpack(color: vec4f)->f32
{const bit_shift: vec4f= vec4f(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}`;P.IncludesShadersStoreWGSL[Oh]||(P.IncludesShadersStoreWGSL[Oh]=gT);const k1={name:Oh,shader:gT},z1=Object.freeze(Object.defineProperty({__proto__:null,packingFunctionsWGSL:k1},Symbol.toStringTag,{value:"Module"})),SS="bayerDitherFunctions",U1=`fn bayerDither2(_P: vec2f)->f32 {return ((2.0*_P.y+_P.x+1.0)%(4.0));}
fn bayerDither4(_P: vec2f)->f32 {var P1: vec2f=((_P)%(2.0)); 
var P2: vec2f=floor(0.5*((_P)%(4.0))); 
return 4.0*bayerDither2(P1)+bayerDither2(P2);}
fn bayerDither8(_P: vec2f)->f32 {var P1: vec2f=((_P)%(2.0)); 
var P2: vec2f=floor(0.5 *((_P)%(4.0))); 
var P4: vec2f=floor(0.25*((_P)%(8.0))); 
return 4.0*(4.0*bayerDither2(P1)+bayerDither2(P2))+bayerDither2(P4);}
`;P.IncludesShadersStoreWGSL[SS]||(P.IncludesShadersStoreWGSL[SS]=U1);const vS="shadowMapFragmentExtraDeclaration",G1=`#if SM_FLOAT==0
#include<packingFunctions>
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#include<bayerDitherFunctions>
uniform softTransparentShadowSM: vec2f;
#endif
varying vDepthMetricSM: f32;
#if SM_USEDISTANCE==1
uniform lightDataSM: vec3f;varying vPositionWSM: vec3f;
#endif
uniform biasAndScaleSM: vec3f;uniform depthValuesSM: vec2f;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying zSM: f32;
#endif
`;P.IncludesShadersStoreWGSL[vS]||(P.IncludesShadersStoreWGSL[vS]=G1);const wh="shadowMapFragment",xT=`var depthSM: f32=fragmentInputs.vDepthMetricSM;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
#if SM_USEDISTANCE==1
depthSM=(length(fragmentInputs.vPositionWSM-uniforms.lightDataSM)+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;
#else
#ifdef USE_REVERSE_DEPTHBUFFER
depthSM=(-fragmentInputs.zSM+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;
#else
depthSM=(fragmentInputs.zSM+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;
#endif
#endif
depthSM=clamp(depthSM,0.0,1.0);
#ifdef USE_REVERSE_DEPTHBUFFER
fragmentOutputs.fragDepth=clamp(1.0-depthSM,0.0,1.0);
#else
fragmentOutputs.fragDepth=clamp(depthSM,0.0,1.0); 
#endif
#elif SM_USEDISTANCE==1
depthSM=(length(fragmentInputs.vPositionWSM-uniforms.lightDataSM)+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;
#endif
#if SM_ESM==1
depthSM=clamp(exp(-min(87.,uniforms.biasAndScaleSM.z*depthSM)),0.,1.);
#endif
#if SM_FLOAT==1
fragmentOutputs.color= vec4f(depthSM,1.0,1.0,1.0);
#else
fragmentOutputs.color=pack(depthSM);
#endif
`;P.IncludesShadersStoreWGSL[wh]||(P.IncludesShadersStoreWGSL[wh]=xT);const W1={name:wh,shader:xT},$1=Object.freeze(Object.defineProperty({__proto__:null,shadowMapFragmentWGSL:W1},Symbol.toStringTag,{value:"Module"})),Nh="shadowMapPixelShader",ST=`#include<shadowMapFragmentExtraDeclaration>
#ifdef ALPHATEXTURE
varying vUV: vec2f;var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;
#endif
#include<clipPlaneFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#include<clipPlaneFragment>
#ifdef ALPHATEXTURE
var opacityMap: vec4f=textureSample(diffuseSampler,diffuseSamplerSampler,fragmentInputs.vUV);var alphaFromAlphaTexture: f32=opacityMap.a;
#if SM_SOFTTRANSPARENTSHADOW==1
if (uniforms.softTransparentShadowSM.y==1.0) {opacityMap=vec4f(opacityMap.rgb* vec3f(0.3,0.59,0.11),opacityMap.a);alphaFromAlphaTexture=opacityMap.x+opacityMap.y+opacityMap.z;}
#endif
#ifdef ALPHATESTVALUE
if (alphaFromAlphaTexture<ALPHATESTVALUE) {discard;}
#endif
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#ifdef ALPHATEXTURE
if ((bayerDither8(floor(((fragmentInputs.position.xy)%(8.0)))))/64.0>=uniforms.softTransparentShadowSM.x*alphaFromAlphaTexture) {discard;}
#else
if ((bayerDither8(floor(((fragmentInputs.position.xy)%(8.0)))))/64.0>=uniforms.softTransparentShadowSM.x) {discard;} 
#endif
#endif
#include<shadowMapFragment>
}`;P.ShadersStoreWGSL[Nh]||(P.ShadersStoreWGSL[Nh]=ST);const H1={name:Nh,shader:ST},j1=Object.freeze(Object.defineProperty({__proto__:null,shadowMapPixelShaderWGSL:H1},Symbol.toStringTag,{value:"Module"})),bS="shadowMapVertexExtraDeclaration",Y1=`#if SM_NORMALBIAS==1
uniform lightDataSM: vec3f;
#endif
uniform biasAndScaleSM: vec3f;uniform depthValuesSM: vec2f;varying vDepthMetricSM: f32;
#if SM_USEDISTANCE==1
varying vPositionWSM: vec3f;
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying zSM: f32;
#endif
`;P.IncludesShadersStoreWGSL[bS]||(P.IncludesShadersStoreWGSL[bS]=Y1);const yS="shadowMapVertexNormalBias",X1=`#if SM_NORMALBIAS==1
#if SM_DIRECTIONINLIGHTDATA==1
var worldLightDirSM: vec3f=normalize(-uniforms.lightDataSM.xyz);
#else
var directionToLightSM: vec3f=uniforms.lightDataSM.xyz-worldPos.xyz;var worldLightDirSM: vec3f=normalize(directionToLightSM);
#endif
var ndlSM: f32=dot(vNormalW,worldLightDirSM);var sinNLSM: f32=sqrt(1.0-ndlSM*ndlSM);var normalBiasSM: f32=uniforms.biasAndScaleSM.y*sinNLSM;worldPos=vec4f(worldPos.xyz-vNormalW*normalBiasSM,worldPos.w);
#endif
`;P.IncludesShadersStoreWGSL[yS]||(P.IncludesShadersStoreWGSL[yS]=X1);const Fh="shadowMapVertexMetric",vT=`#if SM_USEDISTANCE==1
vertexOutputs.vPositionWSM=worldPos.xyz;
#endif
#if SM_DEPTHTEXTURE==1
#ifdef IS_NDC_HALF_ZRANGE
#define BIASFACTOR 0.5
#else
#define BIASFACTOR 1.0
#endif
#ifdef USE_REVERSE_DEPTHBUFFER
vertexOutputs.position.z-=uniforms.biasAndScaleSM.x*vertexOutputs.position.w*BIASFACTOR;
#else
vertexOutputs.position.z+=uniforms.biasAndScaleSM.x*vertexOutputs.position.w*BIASFACTOR;
#endif
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
vertexOutputs.zSM=vertexOutputs.position.z;vertexOutputs.position.z=0.0;
#elif SM_USEDISTANCE==0
#ifdef USE_REVERSE_DEPTHBUFFER
vertexOutputs.vDepthMetricSM=(-vertexOutputs.position.z+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;
#else
vertexOutputs.vDepthMetricSM=(vertexOutputs.position.z+uniforms.depthValuesSM.x)/uniforms.depthValuesSM.y+uniforms.biasAndScaleSM.x;
#endif
#endif
`;P.IncludesShadersStoreWGSL[Fh]||(P.IncludesShadersStoreWGSL[Fh]=vT);const Z1={name:Fh,shader:vT},q1=Object.freeze(Object.defineProperty({__proto__:null,shadowMapVertexMetricWGSL:Z1},Symbol.toStringTag,{value:"Module"})),Lh="shadowMapVertexShader",bT=`attribute position: vec3f;
#ifdef NORMAL
attribute normal: vec3f;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef INSTANCES
attribute world0: vec4f;attribute world1: vec4f;attribute world2: vec4f;attribute world3: vec4f;
#endif
#include<helperFunctions>
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
#ifdef ALPHATEXTURE
varying vUV: vec2f;uniform diffuseMatrix: mat4x4f;
#ifdef UV1
attribute uv: vec2f;
#endif
#ifdef UV2
attribute uv2: vec2f;
#endif
#endif
#include<shadowMapVertexExtraDeclaration>
#include<clipPlaneVertexDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {var positionUpdated: vec3f=input.position;
#ifdef UV1
var uvUpdated: vec2f=input.uv;
#endif
#ifdef UV2
var uv2Updated: vec2f=input.uv2;
#endif
#ifdef NORMAL
var normalUpdated: vec3f=input.normal;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
var worldPos: vec4f=finalWorld* vec4f(positionUpdated,1.0);
#ifdef NORMAL
var normWorldSM: mat3x3f= mat3x3f(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
var vNormalW: vec3f=normalUpdated/ vec3f(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));vNormalW=normalize(normWorldSM*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normWorldSM=transposeMat3(inverseMat3(normWorldSM));
#endif
var vNormalW: vec3f=normalize(normWorldSM*normalUpdated);
#endif
#endif
#include<shadowMapVertexNormalBias>
vertexOutputs.position=scene.viewProjection*worldPos;
#include<shadowMapVertexMetric>
#ifdef ALPHATEXTURE
#ifdef UV1
vertexOutputs.vUV= (uniforms.diffuseMatrix* vec4f(uvUpdated,1.0,0.0)).xy;
#endif
#ifdef UV2
vertexOutputs.vUV= (uniforms.diffuseMatrix* vec4f(uv2Updated,1.0,0.0)).xy;
#endif
#endif
#include<clipPlaneVertex>
}`;P.ShadersStoreWGSL[Lh]||(P.ShadersStoreWGSL[Lh]=bT);const Q1={name:Lh,shader:bT},K1=Object.freeze(Object.defineProperty({__proto__:null,shadowMapVertexShaderWGSL:Q1},Symbol.toStringTag,{value:"Module"})),Bh="depthBoxBlurPixelShader",yT=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform screenSize: vec2f;
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var colorDepth: vec4f=vec4f(0.0);for (var x: i32=-OFFSET; x<=OFFSET; x++) {for (var y: i32=-OFFSET; y<=OFFSET; y++) {colorDepth+=textureSample(textureSampler,textureSamplerSampler,input.vUV+ vec2f(f32(x),f32(y))/uniforms.screenSize);}}
fragmentOutputs.color=(colorDepth/ f32((OFFSET*2+1)*(OFFSET*2+1)));}`;P.ShadersStoreWGSL[Bh]||(P.ShadersStoreWGSL[Bh]=yT);const J1={name:Bh,shader:yT},eN=Object.freeze(Object.defineProperty({__proto__:null,depthBoxBlurPixelShaderWGSL:J1},Symbol.toStringTag,{value:"Module"})),Vh="shadowMapFragmentSoftTransparentShadow",TT=`#if SM_SOFTTRANSPARENTSHADOW==1
if ((bayerDither8(floor(((fragmentInputs.position.xy)%(8.0)))))/64.0>=uniforms.softTransparentShadowSM.x*alpha) {discard;}
#endif
`;P.IncludesShadersStoreWGSL[Vh]||(P.IncludesShadersStoreWGSL[Vh]=TT);const tN={name:Vh,shader:TT},iN=Object.freeze(Object.defineProperty({__proto__:null,shadowMapFragmentSoftTransparentShadowWGSL:tN},Symbol.toStringTag,{value:"Module"})),TS="bayerDitherFunctions",rN=`float bayerDither2(vec2 _P) {return mod(2.0*_P.y+_P.x+1.0,4.0);}
float bayerDither4(vec2 _P) {vec2 P1=mod(_P,2.0); 
vec2 P2=floor(0.5*mod(_P,4.0)); 
return 4.0*bayerDither2(P1)+bayerDither2(P2);}
float bayerDither8(vec2 _P) {vec2 P1=mod(_P,2.0); 
vec2 P2=floor(0.5 *mod(_P,4.0)); 
vec2 P4=floor(0.25*mod(_P,8.0)); 
return 4.0*(4.0*bayerDither2(P1)+bayerDither2(P2))+bayerDither2(P4);}
`;P.IncludesShadersStore[TS]||(P.IncludesShadersStore[TS]=rN);const CS="shadowMapFragmentExtraDeclaration",sN=`#if SM_FLOAT==0
#include<packingFunctions>
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#include<bayerDitherFunctions>
uniform vec2 softTransparentShadowSM;
#endif
varying float vDepthMetricSM;
#if SM_USEDISTANCE==1
uniform vec3 lightDataSM;varying vec3 vPositionWSM;
#endif
uniform vec3 biasAndScaleSM;uniform vec2 depthValuesSM;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying float zSM;
#endif
`;P.IncludesShadersStore[CS]||(P.IncludesShadersStore[CS]=sN);const kh="shadowMapFragment",CT=`float depthSM=vDepthMetricSM;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
#if SM_USEDISTANCE==1
depthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
#ifdef USE_REVERSE_DEPTHBUFFER
depthSM=(-zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
depthSM=(zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#endif
depthSM=clamp(depthSM,0.0,1.0);
#ifdef USE_REVERSE_DEPTHBUFFER
gl_FragDepth=clamp(1.0-depthSM,0.0,1.0);
#else
gl_FragDepth=clamp(depthSM,0.0,1.0); 
#endif
#elif SM_USEDISTANCE==1
depthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#if SM_ESM==1
depthSM=clamp(exp(-min(87.,biasAndScaleSM.z*depthSM)),0.,1.);
#endif
#if SM_FLOAT==1
gl_FragColor=vec4(depthSM,1.0,1.0,1.0);
#else
gl_FragColor=pack(depthSM);
#endif
return;`;P.IncludesShadersStore[kh]||(P.IncludesShadersStore[kh]=CT);const nN={name:kh,shader:CT},aN=Object.freeze(Object.defineProperty({__proto__:null,shadowMapFragment:nN},Symbol.toStringTag,{value:"Module"})),zh="shadowMapPixelShader",PT=`#include<shadowMapFragmentExtraDeclaration>
#ifdef ALPHATEXTURE
varying vec2 vUV;uniform sampler2D diffuseSampler;
#endif
#include<clipPlaneFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#include<clipPlaneFragment>
#ifdef ALPHATEXTURE
vec4 opacityMap=texture2D(diffuseSampler,vUV);float alphaFromAlphaTexture=opacityMap.a;
#if SM_SOFTTRANSPARENTSHADOW==1
if (softTransparentShadowSM.y==1.0) {opacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);alphaFromAlphaTexture=opacityMap.x+opacityMap.y+opacityMap.z;}
#endif
#ifdef ALPHATESTVALUE
if (alphaFromAlphaTexture<ALPHATESTVALUE)
discard;
#endif
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#ifdef ALPHATEXTURE
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM.x*alphaFromAlphaTexture) discard;
#else
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM.x) discard;
#endif
#endif
#include<shadowMapFragment>
}`;P.ShadersStore[zh]||(P.ShadersStore[zh]=PT);const oN={name:zh,shader:PT},lN=Object.freeze(Object.defineProperty({__proto__:null,shadowMapPixelShader:oN},Symbol.toStringTag,{value:"Module"})),PS="sceneVertexDeclaration",uN=`uniform mat4 viewProjection;
#ifdef MULTIVIEW
uniform mat4 viewProjectionR;
#endif
uniform mat4 view;uniform mat4 projection;uniform vec4 vEyePosition;
`;P.IncludesShadersStore[PS]||(P.IncludesShadersStore[PS]=uN);const ES="meshVertexDeclaration",cN=`uniform mat4 world;uniform float visibility;
`;P.IncludesShadersStore[ES]||(P.IncludesShadersStore[ES]=cN);const IS="shadowMapVertexDeclaration",hN=`#include<sceneVertexDeclaration>
#include<meshVertexDeclaration>
`;P.IncludesShadersStore[IS]||(P.IncludesShadersStore[IS]=hN);const RS="shadowMapUboDeclaration",dN=`layout(std140,column_major) uniform;
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;P.IncludesShadersStore[RS]||(P.IncludesShadersStore[RS]=dN);const MS="shadowMapVertexExtraDeclaration",fN=`#if SM_NORMALBIAS==1
uniform vec3 lightDataSM;
#endif
uniform vec3 biasAndScaleSM;uniform vec2 depthValuesSM;varying float vDepthMetricSM;
#if SM_USEDISTANCE==1
varying vec3 vPositionWSM;
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying float zSM;
#endif
`;P.IncludesShadersStore[MS]||(P.IncludesShadersStore[MS]=fN);const AS="shadowMapVertexNormalBias",pN=`#if SM_NORMALBIAS==1
#if SM_DIRECTIONINLIGHTDATA==1
vec3 worldLightDirSM=normalize(-lightDataSM.xyz);
#else
vec3 directionToLightSM=lightDataSM.xyz-worldPos.xyz;vec3 worldLightDirSM=normalize(directionToLightSM);
#endif
float ndlSM=dot(vNormalW,worldLightDirSM);float sinNLSM=sqrt(1.0-ndlSM*ndlSM);float normalBiasSM=biasAndScaleSM.y*sinNLSM;worldPos.xyz-=vNormalW*normalBiasSM;
#endif
`;P.IncludesShadersStore[AS]||(P.IncludesShadersStore[AS]=pN);const Uh="shadowMapVertexMetric",ET=`#if SM_USEDISTANCE==1
vPositionWSM=worldPos.xyz;
#endif
#if SM_DEPTHTEXTURE==1
#ifdef IS_NDC_HALF_ZRANGE
#define BIASFACTOR 0.5
#else
#define BIASFACTOR 1.0
#endif
#ifdef USE_REVERSE_DEPTHBUFFER
gl_Position.z-=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;
#else
gl_Position.z+=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;
#endif
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
zSM=gl_Position.z;gl_Position.z=0.0;
#elif SM_USEDISTANCE==0
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetricSM=(-gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
vDepthMetricSM=(gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#endif
`;P.IncludesShadersStore[Uh]||(P.IncludesShadersStore[Uh]=ET);const mN={name:Uh,shader:ET},_N=Object.freeze(Object.defineProperty({__proto__:null,shadowMapVertexMetric:mN},Symbol.toStringTag,{value:"Module"})),Gh="shadowMapVertexShader",IT=`attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef INSTANCES
attribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;
#endif
#include<helperFunctions>
#include<__decl__shadowMapVertex>
#ifdef ALPHATEXTURE
varying vec2 vUV;uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
#include<shadowMapVertexExtraDeclaration>
#include<clipPlaneVertexDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{vec3 positionUpdated=position;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#ifdef UV2
vec2 uv2Updated=uv2;
#endif
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#ifdef NORMAL
mat3 normWorldSM=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vec3 vNormalW=normalUpdated/vec3(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));vNormalW=normalize(normWorldSM*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normWorldSM=transposeMat3(inverseMat3(normWorldSM));
#endif
vec3 vNormalW=normalize(normWorldSM*normalUpdated);
#endif
#endif
#include<shadowMapVertexNormalBias>
gl_Position=viewProjection*worldPos;
#include<shadowMapVertexMetric>
#ifdef ALPHATEXTURE
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2Updated,1.0,0.0));
#endif
#endif
#include<clipPlaneVertex>
}`;P.ShadersStore[Gh]||(P.ShadersStore[Gh]=IT);const gN={name:Gh,shader:IT},xN=Object.freeze(Object.defineProperty({__proto__:null,shadowMapVertexShader:gN},Symbol.toStringTag,{value:"Module"})),Wh="depthBoxBlurPixelShader",RT=`varying vec2 vUV;uniform sampler2D textureSampler;uniform vec2 screenSize;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{vec4 colorDepth=vec4(0.0);for (int x=-OFFSET; x<=OFFSET; x++)
for (int y=-OFFSET; y<=OFFSET; y++)
colorDepth+=texture2D(textureSampler,vUV+vec2(x,y)/screenSize);gl_FragColor=(colorDepth/float((OFFSET*2+1)*(OFFSET*2+1)));}`;P.ShadersStore[Wh]||(P.ShadersStore[Wh]=RT);const SN={name:Wh,shader:RT},vN=Object.freeze(Object.defineProperty({__proto__:null,depthBoxBlurPixelShader:SN},Symbol.toStringTag,{value:"Module"})),$h="shadowMapFragmentSoftTransparentShadow",MT=`#if SM_SOFTTRANSPARENTSHADOW==1
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM.x*alpha) discard;
#endif
`;P.IncludesShadersStore[$h]||(P.IncludesShadersStore[$h]=MT);const bN={name:$h,shader:MT},yN=Object.freeze(Object.defineProperty({__proto__:null,shadowMapFragmentSoftTransparentShadow:bN},Symbol.toStringTag,{value:"Module"}));async function TN(){const a=new Uint16Array(16384),e=new Uint16Array(64*64*4),t=await ae.LoadFileAsync(ae.GetAssetUrl("https://assets.babylonjs.com/core/areaLights/areaLightsLTC.bin")),i=new Uint16Array(t),r=i.length/8;for(let s=0;s<r;s++)a[s*4]=i[s*8],a[s*4+1]=i[s*8+1],a[s*4+2]=i[s*8+2],a[s*4+3]=i[s*8+3],e[s*4]=i[s*8+4],e[s*4+1]=i[s*8+5],e[s*4+2]=i[s*8+6],e[s*4+3]=i[s*8+7];return[a,e]}function CN(a){const e=a.useDelayedTextureLoading;a.useDelayedTextureLoading=!1;const t=a._blockEntityCollection;a._blockEntityCollection=!1,a._ltcTextures={LTC1:qt.CreateRGBATexture(null,64,64,a.getEngine(),!1,!1,2,2,0,!1,!0),LTC2:qt.CreateRGBATexture(null,64,64,a.getEngine(),!1,!1,2,2,0,!1,!0)},a._blockEntityCollection=t,a._ltcTextures.LTC1.wrapU=Y.CLAMP_ADDRESSMODE,a._ltcTextures.LTC1.wrapV=Y.CLAMP_ADDRESSMODE,a._ltcTextures.LTC2.wrapU=Y.CLAMP_ADDRESSMODE,a._ltcTextures.LTC2.wrapV=Y.CLAMP_ADDRESSMODE,a.useDelayedTextureLoading=e,TN().then(i=>{var r,s;a._ltcTextures&&(((r=a._ltcTextures)==null?void 0:r.LTC1).update(i[0]),((s=a._ltcTextures)==null?void 0:s.LTC2).update(i[1]),a.onDisposeObservable.addOnce(()=>{var l,u;(l=a._ltcTextures)==null||l.LTC1.dispose(),(u=a._ltcTextures)==null||u.LTC2.dispose()}))}).catch(i=>{L.Error(`Area Light fail to get LTC textures data. Error: ${i}`)})}class PN extends rs{constructor(e,t,i){super(e,i),this.position=t,this._scene._ltcTextures||CN(this._scene)}transferTexturesToEffect(e){return this._scene._ltcTextures&&(e.setTexture("areaLightsLTC1Sampler",this._scene._ltcTextures.LTC1),e.setTexture("areaLightsLTC2Sampler",this._scene._ltcTextures.LTC2)),this}prepareLightSpecificDefines(e,t){e["AREALIGHT"+t]=!0,e.AREALIGHTUSED=!0}_isReady(){return this._scene._ltcTextures?this._scene._ltcTextures.LTC1.isReady()&&this._scene._ltcTextures.LTC2.isReady():!1}}li.AddNodeConstructor("Light_Type_4",(a,e)=>()=>new qu(a,m.Zero(),1,1,e));class qu extends PN{get width(){return this._width.x}set width(e){this._width.x=e}get height(){return this._height.y}set height(e){this._height.y=e}constructor(e,t,i,r,s){super(e,t,s),this._width=new m(i,0,0),this._height=new m(0,r,0),this._pointTransformedPosition=m.Zero(),this._pointTransformedWidth=m.Zero(),this._pointTransformedHeight=m.Zero()}getClassName(){return"RectAreaLight"}getTypeID(){return rs.LIGHTTYPEID_RECT_AREALIGHT}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightWidth",4),this._uniformBuffer.addUniform("vLightHeight",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}_computeTransformedInformation(){return this.parent&&this.parent.getWorldMatrix?(m.TransformCoordinatesToRef(this.position,this.parent.getWorldMatrix(),this._pointTransformedPosition),m.TransformNormalToRef(this._width,this.parent.getWorldMatrix(),this._pointTransformedWidth),m.TransformNormalToRef(this._height,this.parent.getWorldMatrix(),this._pointTransformedHeight),!0):!1}transferToEffect(e,t){return this._computeTransformedInformation()?(this._uniformBuffer.updateFloat4("vLightData",this._pointTransformedPosition.x,this._pointTransformedPosition.y,this._pointTransformedPosition.z,0,t),this._uniformBuffer.updateFloat4("vLightWidth",this._pointTransformedWidth.x/2,this._pointTransformedWidth.y/2,this._pointTransformedWidth.z/2,0,t),this._uniformBuffer.updateFloat4("vLightHeight",this._pointTransformedHeight.x/2,this._pointTransformedHeight.y/2,this._pointTransformedHeight.z/2,0,t)):(this._uniformBuffer.updateFloat4("vLightData",this.position.x,this.position.y,this.position.z,0,t),this._uniformBuffer.updateFloat4("vLightWidth",this._width.x/2,this._width.y/2,this._width.z/2,0,t),this._uniformBuffer.updateFloat4("vLightHeight",this._height.x/2,this._height.y/2,this._height.z/2,0,t)),this}transferToNodeMaterialEffect(e,t){return this._computeTransformedInformation()?e.setFloat3(t,this._pointTransformedPosition.x,this._pointTransformedPosition.y,this._pointTransformedPosition.z):e.setFloat3(t,this.position.x,this.position.y,this.position.z),this}}C([F()],qu.prototype,"width",null);C([F()],qu.prototype,"height",null);B("BABYLON.RectAreaLight",qu);class Ks{constructor(e,t="",i="black"){this._renderingCanvas=e,this._loadingText=t,this._loadingDivBackgroundColor=i,this._loadingDivToRenderingCanvasMap=new Map,this._resizeLoadingUI=()=>{this._isLoading&&this._loadingDivToRenderingCanvasMap.forEach(([r,s],n)=>{const o=r.getBoundingClientRect();if(this._isCanvasLayoutChanged(s,o)){const l=window.getComputedStyle(r).position;n.style.position=l==="fixed"?"fixed":"absolute",n.style.left=o.left+window.scrollX+"px",n.style.top=o.top+window.scrollY+"px",n.style.width=o.width+"px",n.style.height=o.height+"px",this._loadingDivToRenderingCanvasMap.set(n,[r,o])}})}}displayLoadingUI(){if(this._isLoading)return;this._isLoading=!0,this._engine=ze.Instances.find(u=>u.getRenderingCanvas()===this._renderingCanvas);const e=document.createElement("div");e.id="babylonjsLoadingDiv",e.style.opacity="0",e.style.transition="opacity 1.5s ease",e.style.pointerEvents="none",e.style.display="grid",e.style.gridTemplateRows="100%",e.style.gridTemplateColumns="100%",e.style.justifyItems="center",e.style.alignItems="center",this._loadingTextDiv=document.createElement("div"),this._loadingTextDiv.style.position="absolute",this._loadingTextDiv.style.left="0",this._loadingTextDiv.style.top="50%",this._loadingTextDiv.style.marginTop="80px",this._loadingTextDiv.style.width="100%",this._loadingTextDiv.style.height="20px",this._loadingTextDiv.style.fontFamily="Arial",this._loadingTextDiv.style.fontSize="14px",this._loadingTextDiv.style.color="white",this._loadingTextDiv.style.textAlign="center",this._loadingTextDiv.style.zIndex="1",this._loadingTextDiv.innerHTML="Loading",e.appendChild(this._loadingTextDiv),this._loadingTextDiv.innerHTML=this._loadingText,this._style=document.createElement("style"),this._style.type="text/css";const t=`@-webkit-keyframes spin1 {                            0% { -webkit-transform: rotate(0deg);}
                            100% { -webkit-transform: rotate(360deg);}
                        }                        @keyframes spin1 {                            0% { transform: rotate(0deg);}
                            100% { transform: rotate(360deg);}
                        }`;this._style.innerHTML=t,document.getElementsByTagName("head")[0].appendChild(this._style);const i=!!window.SVGSVGElement,r=new Image;Ks.DefaultLogoUrl?r.src=Ks.DefaultLogoUrl:r.src=i?"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxODAuMTcgMjA4LjA0Ij48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2ZmZjt9LmNscy0ye2ZpbGw6I2UwNjg0Yjt9LmNscy0ze2ZpbGw6I2JiNDY0Yjt9LmNscy00e2ZpbGw6I2UwZGVkODt9LmNscy01e2ZpbGw6I2Q1ZDJjYTt9PC9zdHlsZT48L2RlZnM+PHRpdGxlPkJhYnlsb25Mb2dvPC90aXRsZT48ZyBpZD0iTGF5ZXJfMiIgZGF0YS1uYW1lPSJMYXllciAyIj48ZyBpZD0iUGFnZV9FbGVtZW50cyIgZGF0YS1uYW1lPSJQYWdlIEVsZW1lbnRzIj48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Ik05MC4wOSwwLDAsNTJWMTU2bDkwLjA5LDUyLDkwLjA4LTUyVjUyWiIvPjxwb2x5Z29uIGNsYXNzPSJjbHMtMiIgcG9pbnRzPSIxODAuMTcgNTIuMDEgMTUxLjk3IDM1LjczIDEyNC44NSA1MS4zOSAxNTMuMDUgNjcuNjcgMTgwLjE3IDUyLjAxIi8+PHBvbHlnb24gY2xhc3M9ImNscy0yIiBwb2ludHM9IjI3LjEyIDY3LjY3IDExNy4yMSAxNS42NiA5MC4wOCAwIDAgNTIuMDEgMjcuMTIgNjcuNjciLz48cG9seWdvbiBjbGFzcz0iY2xzLTIiIHBvaW50cz0iNjEuODkgMTIwLjMgOTAuMDggMTM2LjU4IDExOC4yOCAxMjAuMyA5MC4wOCAxMDQuMDIgNjEuODkgMTIwLjMiLz48cG9seWdvbiBjbGFzcz0iY2xzLTMiIHBvaW50cz0iMTUzLjA1IDY3LjY3IDE1My4wNSAxNDAuMzcgOTAuMDggMTc2LjcyIDI3LjEyIDE0MC4zNyAyNy4xMiA2Ny42NyAwIDUyLjAxIDAgMTU2LjAzIDkwLjA4IDIwOC4wNCAxODAuMTcgMTU2LjAzIDE4MC4xNyA1Mi4wMSAxNTMuMDUgNjcuNjciLz48cG9seWdvbiBjbGFzcz0iY2xzLTMiIHBvaW50cz0iOTAuMDggNzEuNDYgNjEuODkgODcuNzQgNjEuODkgMTIwLjMgOTAuMDggMTA0LjAyIDExOC4yOCAxMjAuMyAxMTguMjggODcuNzQgOTAuMDggNzEuNDYiLz48cG9seWdvbiBjbGFzcz0iY2xzLTQiIHBvaW50cz0iMTUzLjA1IDY3LjY3IDExOC4yOCA4Ny43NCAxMTguMjggMTIwLjMgOTAuMDggMTM2LjU4IDkwLjA4IDE3Ni43MiAxNTMuMDUgMTQwLjM3IDE1My4wNSA2Ny42NyIvPjxwb2x5Z29uIGNsYXNzPSJjbHMtNSIgcG9pbnRzPSIyNy4xMiA2Ny42NyA2MS44OSA4Ny43NCA2MS44OSAxMjAuMyA5MC4wOCAxMzYuNTggOTAuMDggMTc2LjcyIDI3LjEyIDE0MC4zNyAyNy4xMiA2Ny42NyIvPjwvZz48L2c+PC9zdmc+":"https://cdn.babylonjs.com/Assets/babylonLogo.png",r.style.width="150px",r.style.gridColumn="1",r.style.gridRow="1",r.style.top="50%",r.style.left="50%",r.style.transform="translate(-50%, -50%)",r.style.position="absolute";const s=document.createElement("div");s.style.width="300px",s.style.gridColumn="1",s.style.gridRow="1",s.style.top="50%",s.style.left="50%",s.style.transform="translate(-50%, -50%)",s.style.position="absolute";const n=new Image;if(Ks.DefaultSpinnerUrl?n.src=Ks.DefaultSpinnerUrl:n.src=i?"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzOTIgMzkyIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2UwNjg0Yjt9LmNscy0ye2ZpbGw6bm9uZTt9PC9zdHlsZT48L2RlZnM+PHRpdGxlPlNwaW5uZXJJY29uPC90aXRsZT48ZyBpZD0iTGF5ZXJfMiIgZGF0YS1uYW1lPSJMYXllciAyIj48ZyBpZD0iU3Bpbm5lciI+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNNDAuMjEsMTI2LjQzYzMuNy03LjMxLDcuNjctMTQuNDQsMTItMjEuMzJsMy4zNi01LjEsMy41Mi01YzEuMjMtMS42MywyLjQxLTMuMjksMy42NS00LjkxczIuNTMtMy4yMSwzLjgyLTQuNzlBMTg1LjIsMTg1LjIsMCwwLDEsODMuNCw2Ny40M2EyMDgsMjA4LDAsMCwxLDE5LTE1LjY2YzMuMzUtMi40MSw2Ljc0LTQuNzgsMTAuMjUtN3M3LjExLTQuMjgsMTAuNzUtNi4zMmM3LjI5LTQsMTQuNzMtOCwyMi41My0xMS40OSwzLjktMS43Miw3Ljg4LTMuMywxMi00LjY0YTEwNC4yMiwxMDQuMjIsMCwwLDEsMTIuNDQtMy4yMyw2Mi40NCw2Mi40NCwwLDAsMSwxMi43OC0xLjM5QTI1LjkyLDI1LjkyLDAsMCwxLDE5NiwyMS40NGE2LjU1LDYuNTUsMCwwLDEsMi4wNSw5LDYuNjYsNi42NiwwLDAsMS0xLjY0LDEuNzhsLS40MS4yOWEyMi4wNywyMi4wNywwLDAsMS01Ljc4LDMsMzAuNDIsMzAuNDIsMCwwLDEtNS42NywxLjYyLDM3LjgyLDM3LjgyLDAsMCwxLTUuNjkuNzFjLTEsMC0xLjkuMTgtMi44NS4yNmwtMi44NS4yNHEtNS43Mi41MS0xMS40OCwxLjFjLTMuODQuNC03LjcxLjgyLTExLjU4LDEuNGExMTIuMzQsMTEyLjM0LDAsMCwwLTIyLjk0LDUuNjFjLTMuNzIsMS4zNS03LjM0LDMtMTAuOTQsNC42NHMtNy4xNCwzLjUxLTEwLjYsNS41MUExNTEuNiwxNTEuNiwwLDAsMCw2OC41Niw4N0M2Ny4yMyw4OC40OCw2Niw5MCw2NC42NCw5MS41NnMtMi41MSwzLjE1LTMuNzUsNC43M2wtMy41NCw0LjljLTEuMTMsMS42Ni0yLjIzLDMuMzUtMy4zMyw1YTEyNywxMjcsMCwwLDAtMTAuOTMsMjEuNDksMS41OCwxLjU4LDAsMSwxLTMtMS4xNVM0MC4xOSwxMjYuNDcsNDAuMjEsMTI2LjQzWiIvPjxyZWN0IGNsYXNzPSJjbHMtMiIgd2lkdGg9IjM5MiIgaGVpZ2h0PSIzOTIiLz48L2c+PC9nPjwvc3ZnPg==":"https://cdn.babylonjs.com/Assets/loadingIcon.png",n.style.animation="spin1 0.75s infinite linear",n.style.transformOrigin="50% 50%",!i){const u={w:16,h:18.5},c={w:30,h:30};r.style.width=`${u.w}vh`,r.style.height=`${u.h}vh`,r.style.left=`calc(50% - ${u.w/2}vh)`,r.style.top=`calc(50% - ${u.h/2}vh)`,n.style.width=`${c.w}vh`,n.style.height=`${c.h}vh`,n.style.left=`calc(50% - ${c.w/2}vh)`,n.style.top=`calc(50% - ${c.h/2}vh)`}s.appendChild(n),e.appendChild(r),e.appendChild(s),e.style.backgroundColor=this._loadingDivBackgroundColor,e.style.opacity="1";const o=[],l=this._engine.views;if(l!=null&&l.length)for(const u of l)u.enabled&&o.push(u.target);else o.push(this._renderingCanvas);o.forEach((u,c)=>{const h=e.cloneNode(!0);h.id+=`-${c}`,this._loadingDivToRenderingCanvasMap.set(h,[u,null])}),this._resizeLoadingUI(),this._resizeObserver=this._engine.onResizeObservable.add(()=>{this._resizeLoadingUI()}),this._loadingDivToRenderingCanvasMap.forEach((u,c)=>{document.body.appendChild(c)})}hideLoadingUI(){if(!this._isLoading)return;let e=0;const t=i=>{const r=i.target;this._loadingDivToRenderingCanvasMap.has(r)&&(e++,r.remove(),e===this._loadingDivToRenderingCanvasMap.size&&(this._loadingTextDiv&&(this._loadingTextDiv.remove(),this._loadingTextDiv=null),this._style&&(this._style.remove(),this._style=null),window.removeEventListener("transitionend",t),this._engine.onResizeObservable.remove(this._resizeObserver),this._loadingDivToRenderingCanvasMap.clear(),this._engine=null,this._isLoading=!1))};this._loadingDivToRenderingCanvasMap.forEach((i,r)=>{r.style.opacity="0"}),window.addEventListener("transitionend",t)}set loadingUIText(e){this._loadingText=e,this._loadingTextDiv&&this._loadingDivToRenderingCanvasMap.forEach((t,i)=>{i.children[0].innerHTML=this._loadingText})}get loadingUIText(){return this._loadingText}get loadingUIBackgroundColor(){return this._loadingDivBackgroundColor}set loadingUIBackgroundColor(e){this._loadingDivBackgroundColor=e,this._isLoading&&this._loadingDivToRenderingCanvasMap.forEach((t,i)=>{i.style.backgroundColor=this._loadingDivBackgroundColor})}_isCanvasLayoutChanged(e,t){return!e||e.left!==t.left||e.top!==t.top||e.right!==t.right||e.bottom!==t.bottom||e.width!==t.width||e.height!==t.height||e.x!==t.x||e.y!==t.y}}Ks.DefaultLogoUrl="";Ks.DefaultSpinnerUrl="";st.DefaultLoadingScreenFactory=a=>new Ks(a);class AT{constructor(e,t={}){this._lodGenerationOffset=0,this._lodGenerationScale=.8,this.quality=4096,this.hdrScale=1,this._engine=e,this.hdrScale=t.hdrScale||this.hdrScale,this.quality=t.quality||this.quality}_createRenderTarget(e){let t=0;this._engine.getCaps().textureHalfFloatRender?t=2:this._engine.getCaps().textureFloatRender&&(t=1);const i=this._engine.createRenderTargetCubeTexture(e,{format:5,type:t,createMipMaps:!0,generateMipMaps:!1,generateDepthBuffer:!1,generateStencilBuffer:!1,samplingMode:1,label:"HDR_Radiance_Filtering_Target"});return this._engine.updateTextureWrappingMode(i.texture,0,0,0),this._engine.updateTextureSamplingMode(3,i.texture,!0),i}_prefilterInternal(e){const t=e.getSize().width,i=Uo(t)+1,r=this._effectWrapper.effect,s=this._createRenderTarget(t);this._effectRenderer.saveStates(),this._effectRenderer.setViewport();const n=e.getInternalTexture();n&&this._engine.updateTextureSamplingMode(3,n,!0),this._effectRenderer.applyEffectWrapper(this._effectWrapper);const o=[[new m(0,0,-1),new m(0,-1,0),new m(1,0,0)],[new m(0,0,1),new m(0,-1,0),new m(-1,0,0)],[new m(1,0,0),new m(0,0,1),new m(0,1,0)],[new m(1,0,0),new m(0,0,-1),new m(0,-1,0)],[new m(1,0,0),new m(0,-1,0),new m(0,0,1)],[new m(-1,0,0),new m(0,-1,0),new m(0,0,-1)]];r.setFloat("hdrScale",this.hdrScale),r.setFloat2("vFilteringInfo",e.getSize().width,i),r.setTexture("inputTexture",e);for(let c=0;c<6;c++){r.setVector3("up",o[c][0]),r.setVector3("right",o[c][1]),r.setVector3("front",o[c][2]);for(let h=0;h<i;h++){this._engine.bindFramebuffer(s,c,void 0,void 0,!0,h),this._effectRenderer.applyEffectWrapper(this._effectWrapper);let d=Math.pow(2,(h-this._lodGenerationOffset)/this._lodGenerationScale)/t;h===0&&(d=0),r.setFloat("alphaG",d),this._effectRenderer.draw()}}this._effectRenderer.restoreStates(),this._engine.restoreDefaultFramebuffer(),this._engine._releaseTexture(e._texture);const l=s.texture.type,u=s.texture.format;return s._swapAndDie(e._texture),e._texture.type=l,e._texture.format=u,e.gammaSpace=!1,e.lodGenerationOffset=this._lodGenerationOffset,e.lodGenerationScale=this._lodGenerationScale,e._prefiltered=!0,e}_createEffect(e,t){const i=[];e.gammaSpace&&i.push("#define GAMMA_INPUT"),i.push("#define NUM_SAMPLES "+this.quality+"u");const r=this._engine.isWebGPU;return new Qt({engine:this._engine,name:"hdrFiltering",vertexShader:"hdrFiltering",fragmentShader:"hdrFiltering",samplerNames:["inputTexture"],uniformNames:["vSampleDirections","vWeights","up","right","front","vFilteringInfo","hdrScale","alphaG"],useShaderStore:!0,defines:i,onCompiled:t,shaderLanguage:r?1:0,extraInitializationsAsync:async()=>{r?await Promise.all([k(()=>Promise.resolve().then(()=>rF),void 0),k(()=>Promise.resolve().then(()=>nF),void 0)]):await Promise.all([k(()=>Promise.resolve().then(()=>JN),void 0),k(()=>Promise.resolve().then(()=>tF),void 0)])}})}isReady(e){return e.isReady()&&this._effectWrapper.effect.isReady()}async prefilter(e){if(!this._engine._features.allowTexturePrefiltering)throw new Error("HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.");this._effectRenderer=new il(this._engine),this._effectWrapper=this._createEffect(e),await this._effectWrapper.effect.whenCompiledAsync(),this._prefilterInternal(e),this._effectRenderer.dispose(),this._effectWrapper.dispose()}}class $n{get iblSource(){return this._iblSource}set iblSource(e){this._iblSource!==e&&(this._disposeTextures(),this._iblSource=e,e&&(e.isCube?e.isReadyOrNotBlocking()?this._recreateAssetsFromNewIbl():e.onLoadObservable.addOnce(this._recreateAssetsFromNewIbl.bind(this,e)):e.isReadyOrNotBlocking()?this._recreateAssetsFromNewIbl():e.onLoadObservable.addOnce(this._recreateAssetsFromNewIbl.bind(this,e))))}_recreateAssetsFromNewIbl(){this._debugPass&&this._debugPass.dispose(),this._createTextures(),this._debugPass&&this._createDebugPass()}getIcdfTexture(){return this._icdfPT?this._icdfPT:this._dummyTexture}setDebugDisplayParams(e,t,i,r){this._debugSizeParams.set(e,t,i,r)}get debugPassName(){return this._debugPassName}getDebugPassPP(){return this._debugPass||this._createDebugPass(),this._debugPass}constructor(e){this.debugEnabled=!1,this._debugSizeParams=new Ve(0,0,1,1),this._debugPassName="CDF Debug",this.onGeneratedObservable=new j,e?$n._IsScene(e)?this._scene=e:this._engine=e:this._scene=ze.LastCreatedScene,this._scene&&(this._engine=this._scene.getEngine());const t=new Uint16Array([0,0,0,255]);this._dummyTexture=new qt(t,1,1,mt.TEXTUREFORMAT_RGBA,e,!1,!1,void 0,2),this._scene&&$n._SceneComponentInitialization(this._scene)}_createTextures(){const e=this._iblSource?{width:this._iblSource.getSize().width,height:this._iblSource.getSize().height}:{width:1,height:1};this._iblSource||(this._iblSource=qt.CreateRTexture(new Uint8Array([255]),1,1,this._engine,!1,!1,1,0),this._iblSource.name="Placeholder IBL Source"),this._iblSource.isCube&&(e.width*=4,e.height*=2,e.width=1<<Math.floor(Math.log2(e.width)),e.height=1<<Math.floor(Math.log2(e.height)));const t=this._engine.isWebGPU,i={generateDepthBuffer:!1,generateMipMaps:!1,format:6,type:1,samplingMode:1,shaderLanguage:t?1:0,gammaSpace:!1,extraInitializationsAsync:async()=>{t?await Promise.all([k(()=>Promise.resolve().then(()=>hG),void 0),k(()=>Promise.resolve().then(()=>mG),void 0),k(()=>Promise.resolve().then(()=>IG),void 0)]):await Promise.all([k(()=>Promise.resolve().then(()=>fG),void 0),k(()=>Promise.resolve().then(()=>gG),void 0),k(()=>Promise.resolve().then(()=>MG),void 0)])}},r={generateDepthBuffer:!1,generateMipMaps:!1,format:5,type:2,samplingMode:1,shaderLanguage:t?1:0,gammaSpace:!1,extraInitializationsAsync:async()=>{t?await Promise.all([k(()=>Promise.resolve().then(()=>SG),void 0)]):await Promise.all([k(()=>Promise.resolve().then(()=>bG),void 0)])}};this._cdfyPT=new er("cdfyTexture",{width:e.width,height:e.height+1},"iblCdfy",this._scene,i,!1,!1),this._cdfyPT.autoClear=!1,this._cdfyPT.setTexture("iblSource",this._iblSource),this._cdfyPT.setInt("iblHeight",e.height),this._cdfyPT.wrapV=0,this._cdfyPT.refreshRate=0,this._iblSource.isCube&&(this._cdfyPT.defines=`#define IBL_USE_CUBE_MAP
`),this._cdfxPT=new er("cdfxTexture",{width:e.width+1,height:1},"iblCdfx",this._scene,i,!1,!1),this._cdfxPT.autoClear=!1,this._cdfxPT.setTexture("cdfy",this._cdfyPT),this._cdfxPT.refreshRate=0,this._cdfxPT.wrapU=0,this._scaledLuminancePT=new er("iblScaledLuminance",{width:e.width,height:e.height},"iblScaledLuminance",this._scene,{...i,samplingMode:3,generateMipMaps:!0},!0,!1),this._scaledLuminancePT.autoClear=!1,this._scaledLuminancePT.setTexture("iblSource",this._iblSource),this._scaledLuminancePT.setInt("iblHeight",e.height),this._scaledLuminancePT.setInt("iblWidth",e.width),this._scaledLuminancePT.refreshRate=0,this._iblSource.isCube&&(this._scaledLuminancePT.defines=`#define IBL_USE_CUBE_MAP
`),this._icdfPT=new er("icdfTexture",{width:e.width,height:e.height},"iblIcdf",this._scene,r,!1,!1),this._icdfPT.autoClear=!1,this._icdfPT.setTexture("cdfy",this._cdfyPT),this._icdfPT.setTexture("cdfx",this._cdfxPT),this._icdfPT.setTexture("iblSource",this._iblSource),this._icdfPT.setTexture("scaledLuminanceSampler",this._scaledLuminancePT),this._icdfPT.refreshRate=0,this._icdfPT.wrapV=0,this._icdfPT.wrapU=0,this._iblSource.isCube&&(this._icdfPT.defines=`#define IBL_USE_CUBE_MAP
`),this._icdfPT.onGeneratedObservable.addOnce(()=>{this.onGeneratedObservable.notifyObservers()})}_disposeTextures(){var e,t,i,r;(e=this._cdfyPT)==null||e.dispose(),(t=this._cdfxPT)==null||t.dispose(),(i=this._icdfPT)==null||i.dispose(),(r=this._scaledLuminancePT)==null||r.dispose()}_createDebugPass(){var r,s,n;this._debugPass&&this._debugPass.dispose();const e=this._engine.isWebGPU,t={width:this._engine.getRenderWidth(),height:this._engine.getRenderHeight(),samplingMode:Y.BILINEAR_SAMPLINGMODE,engine:this._engine,textureType:0,uniforms:["sizeParams"],samplers:["cdfy","icdf","cdfx","iblSource"],defines:(r=this._iblSource)!=null&&r.isCube?`#define IBL_USE_CUBE_MAP
`:"",shaderLanguage:e?1:0,extraInitializations:(o,l)=>{o?l.push(k(()=>Promise.resolve().then(()=>TG),void 0)):l.push(k(()=>Promise.resolve().then(()=>PG),void 0))}};this._debugPass=new Ce(this._debugPassName,"iblCdfDebug",t);const i=this._debugPass.getEffect();i&&(i.defines=(s=this._iblSource)!=null&&s.isCube?`#define IBL_USE_CUBE_MAP
`:""),(n=this._iblSource)!=null&&n.isCube&&this._debugPass.updateEffect(`#define IBL_USE_CUBE_MAP
`),this._debugPass.onApplyObservable.add(o=>{o.setTexture("cdfy",this._cdfyPT),o.setTexture("icdf",this._icdfPT),o.setTexture("cdfx",this._cdfxPT),o.setTexture("iblSource",this._iblSource),o.setFloat4("sizeParams",this._debugSizeParams.x,this._debugSizeParams.y,this._debugSizeParams.z,this._debugSizeParams.w)})}isReady(){return this._iblSource&&this._iblSource.name!=="Placeholder IBL Source"&&this._iblSource.isReady()&&this._cdfyPT&&this._cdfyPT.isReady()&&this._icdfPT&&this._icdfPT.isReady()&&this._cdfxPT&&this._cdfxPT.isReady()&&this._scaledLuminancePT&&this._scaledLuminancePT.isReady()}renderWhenReady(){this._icdfPT.onGeneratedObservable.addOnce(()=>{this.onGeneratedObservable.notifyObservers()});const e=[],t=[this._cdfyPT,this._cdfxPT,this._scaledLuminancePT,this._icdfPT];return t.forEach(i=>{e.push(new Promise(r=>{i.isReady()?r():i.getEffect().executeWhenCompiled(()=>{r()})}))}),Promise.all(e).then(()=>{t.forEach(i=>{i.render()})})}dispose(){this._disposeTextures(),this._dummyTexture.dispose(),this._debugPass&&this._debugPass.dispose(),this.onGeneratedObservable.clear()}static _IsScene(e){return e.getClassName()==="Scene"}}$n._SceneComponentInitialization=a=>{throw Cr("IblCdfGeneratorSceneComponentSceneComponent")};class EN{constructor(e,t={}){this.quality=4096,this.hdrScale=1,this.useCdf=!1,this._engine=e,this.hdrScale=t.hdrScale||this.hdrScale,this.quality=t.quality||this.quality,this.useCdf=t.useCdf||this.useCdf}_createRenderTarget(e){let t=0;this._engine.getCaps().textureHalfFloatRender?t=2:this._engine.getCaps().textureFloatRender&&(t=1);const i=this._engine.createRenderTargetCubeTexture(e,{format:5,type:t,createMipMaps:!1,generateMipMaps:!1,generateDepthBuffer:!1,generateStencilBuffer:!1,samplingMode:2,label:"HDR_Irradiance_Filtering_Target"});return this._engine.updateTextureWrappingMode(i.texture,0,0,0),i}_prefilterInternal(e){const t=e.getSize().width,i=Uo(t),r=this._effectWrapper.effect,s=Math.max(32,1<<Uo(t>>3)),n=this._createRenderTarget(s);this._effectRenderer.saveStates(),this._effectRenderer.setViewport(),this._effectRenderer.applyEffectWrapper(this._effectWrapper);const o=[[new m(0,0,-1),new m(0,-1,0),new m(1,0,0)],[new m(0,0,1),new m(0,-1,0),new m(-1,0,0)],[new m(1,0,0),new m(0,0,1),new m(0,1,0)],[new m(1,0,0),new m(0,0,-1),new m(0,-1,0)],[new m(1,0,0),new m(0,-1,0),new m(0,0,1)],[new m(-1,0,0),new m(0,-1,0),new m(0,0,-1)]];r.setFloat("hdrScale",this.hdrScale),r.setFloat2("vFilteringInfo",e.getSize().width,i),r.setTexture("inputTexture",e),this._cdfGenerator&&r.setTexture("icdfTexture",this._cdfGenerator.getIcdfTexture());for(let u=0;u<6;u++)r.setVector3("up",o[u][0]),r.setVector3("right",o[u][1]),r.setVector3("front",o[u][2]),this._engine.bindFramebuffer(n,u,void 0,void 0,!0),this._effectRenderer.applyEffectWrapper(this._effectWrapper),this._effectRenderer.draw();this._effectRenderer.restoreStates(),this._engine.restoreDefaultFramebuffer(),r.setTexture("inputTexture",null),r.setTexture("icdfTexture",null);const l=new Vr(e.getScene(),n.texture);return l.name=e.name+"_irradiance",l.displayName=e.name+"_irradiance",l.gammaSpace=!1,l}_createEffect(e,t){const i=[];e.gammaSpace&&i.push("#define GAMMA_INPUT"),i.push("#define NUM_SAMPLES "+this.quality+"u");const r=this._engine.isWebGPU,s=["inputTexture"];return this._cdfGenerator&&(s.push("icdfTexture"),i.push("#define IBL_CDF_FILTERING")),new Qt({engine:this._engine,name:"HDRIrradianceFiltering",vertexShader:"hdrIrradianceFiltering",fragmentShader:"hdrIrradianceFiltering",samplerNames:s,uniformNames:["vSampleDirections","vWeights","up","right","front","vFilteringInfo","hdrScale"],useShaderStore:!0,defines:i,onCompiled:t,shaderLanguage:r?1:0,extraInitializationsAsync:async()=>{r?await Promise.all([k(()=>Promise.resolve().then(()=>hF),void 0),k(()=>Promise.resolve().then(()=>fF),void 0)]):await Promise.all([k(()=>Promise.resolve().then(()=>oF),void 0),k(()=>Promise.resolve().then(()=>uF),void 0)])}})}isReady(e){return e.isReady()&&this._effectWrapper.effect.isReady()}async prefilter(e){var i;if(!this._engine._features.allowTexturePrefiltering)throw new Error("HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.");this.useCdf&&(this._cdfGenerator=new $n(this._engine),this._cdfGenerator.iblSource=e,await this._cdfGenerator.renderWhenReady()),this._effectRenderer=new il(this._engine),this._effectWrapper=this._createEffect(e),await this._effectWrapper.effect.whenCompiledAsync();const t=this._prefilterInternal(e);return this._effectRenderer.dispose(),this._effectWrapper.dispose(),(i=this._cdfGenerator)==null||i.dispose(),t}}class an extends Vr{set isBlocking(e){this._isBlocking=e}get isBlocking(){return this._isBlocking}set rotationY(e){this._rotationY=e,this.setReflectionTextureMatrix($.RotationY(this._rotationY))}get rotationY(){return this._rotationY}set boundingBoxSize(e){if(this._boundingBoxSize&&this._boundingBoxSize.equals(e))return;this._boundingBoxSize=e;const t=this.getScene();t&&t.markAllMaterialsAsDirty(1)}get boundingBoxSize(){return this._boundingBoxSize}constructor(e,t,i,r=!1,s=!0,n=!1,o=!1,l=null,u=null,c=!1,h=!1,d=!1){var f;super(t),this._generateHarmonics=!0,this._onError=null,this._isBlocking=!0,this._rotationY=0,this.boundingBoxPosition=m.Zero(),this.onLoadObservable=new j,e&&(this._coordinatesMode=Y.CUBIC_MODE,this.name=e,this.url=e,this.hasAlpha=!1,this.isCube=!0,this._textureMatrix=$.Identity(),this._prefilterOnLoad=o,this._prefilterIrradianceOnLoad=h,this._prefilterUsingCdf=d,this._onLoad=()=>{this.onLoadObservable.notifyObservers(this),l&&l()},this._onError=u,this.gammaSpace=n,this._noMipmap=r,this._size=i,this._supersample=c||d,this._generateHarmonics=s,this._texture=this._getFromCache(e,this._noMipmap,void 0,void 0,void 0,this.isCube),this._texture?this._texture.isReady?ae.SetImmediate(()=>this._onLoad()):this._texture.onLoadedObservable.add(this._onLoad):(f=this.getScene())!=null&&f.useDelayedTextureLoading?this.delayLoadState=4:this._loadTexture())}getClassName(){return"HDRCubeTexture"}_loadTexture(){const e=this._getEngine(),t=e.getCaps();let i=0;t.textureFloat&&t.textureFloatLinearFiltering?i=1:t.textureHalfFloat&&t.textureHalfFloatLinearFiltering&&(i=2);const r=s=>{this.lodGenerationOffset=0,this.lodGenerationScale=.8;const n=YM(s,this._size,this._supersample);if(this._generateHarmonics){const c=cM.ConvertCubeMapToSphericalPolynomial(n);this.sphericalPolynomial=c}const o=[];let l=null,u=null;for(let c=0;c<6;c++){i===2?u=new Uint16Array(this._size*this._size*3):i===0&&(l=new Uint8Array(this._size*this._size*3));const h=n[an._FacesMapping[c]];if(this.gammaSpace||u||l){for(let d=0;d<this._size*this._size;d++)if(this.gammaSpace&&(h[d*3+0]=Math.pow(h[d*3+0],Bl),h[d*3+1]=Math.pow(h[d*3+1],Bl),h[d*3+2]=Math.pow(h[d*3+2],Bl)),u&&(u[d*3+0]=Cc(h[d*3+0]),u[d*3+1]=Cc(h[d*3+1]),u[d*3+2]=Cc(h[d*3+2])),l){let f=Math.max(h[d*3+0]*255,0),p=Math.max(h[d*3+1]*255,0),g=Math.max(h[d*3+2]*255,0);const _=Math.max(Math.max(f,p),g);if(_>255){const S=255/_;f*=S,p*=S,g*=S}l[d*3+0]=f,l[d*3+1]=p,l[d*3+2]=g}}u?o.push(u):l?o.push(l):o.push(h)}return o};if(e._features.allowTexturePrefiltering&&(this._prefilterOnLoad||this._prefilterIrradianceOnLoad)){const s=this._onLoad,n=new AT(e);this._onLoad=()=>{let o=Promise.resolve(null),l=Promise.resolve();this._prefilterIrradianceOnLoad&&(o=new EN(e,{useCdf:this._prefilterUsingCdf}).prefilter(this)),this._prefilterOnLoad&&(l=n.prefilter(this)),Promise.all([o,l]).then(u=>{const c=u[0];if(this._prefilterIrradianceOnLoad&&c){this.irradianceTexture=c;const h=this.getScene();h&&h.markAllMaterialsAsDirty(1)}s&&s()})}}this._texture=e.createRawCubeTextureFromUrl(this.url,this.getScene(),this._size,4,i,this._noMipmap,r,null,this._onLoad,this._onError)}clone(){const e=new an(this.url,this.getScene()||this._getEngine(),this._size,this._noMipmap,this._generateHarmonics,this.gammaSpace);return e.level=this.level,e.wrapU=this.wrapU,e.wrapV=this.wrapV,e.coordinatesIndex=this.coordinatesIndex,e.coordinatesMode=this.coordinatesMode,e}delayLoad(){this.delayLoadState===4&&(this.delayLoadState=1,this._texture=this._getFromCache(this.url,this._noMipmap),this._texture||this._loadTexture())}getReflectionTextureMatrix(){return this._textureMatrix}setReflectionTextureMatrix(e){var t;this._textureMatrix=e,e.updateFlag!==this._textureMatrix.updateFlag&&e.isIdentity()!==this._textureMatrix.isIdentity()&&((t=this.getScene())==null||t.markAllMaterialsAsDirty(1,i=>i.getActiveTextures().indexOf(this)!==-1))}dispose(){this.onLoadObservable.clear(),super.dispose()}static Parse(e,t,i){let r=null;return e.name&&!e.isRenderTarget&&(r=new an(i+e.name,t,e.size,e.noMipmap,e.generateHarmonics,e.useInGammaSpace),r.name=e.name,r.hasAlpha=e.hasAlpha,r.level=e.level,r.coordinatesMode=e.coordinatesMode,r.isBlocking=e.isBlocking),r&&(e.boundingBoxPosition&&(r.boundingBoxPosition=m.FromArray(e.boundingBoxPosition)),e.boundingBoxSize&&(r.boundingBoxSize=m.FromArray(e.boundingBoxSize)),e.rotationY&&(r.rotationY=e.rotationY)),r}serialize(){if(!this.name)return null;const e={};return e.name=this.name,e.hasAlpha=this.hasAlpha,e.isCube=!0,e.level=this.level,e.size=this._size,e.coordinatesMode=this.coordinatesMode,e.useInGammaSpace=this.gammaSpace,e.generateHarmonics=this._generateHarmonics,e.customType="BABYLON.HDRCubeTexture",e.noMipmap=this._noMipmap,e.isBlocking=this._isBlocking,e.rotationY=this._rotationY,e}}an._FacesMapping=["right","left","up","down","front","back"];B("BABYLON.HDRCubeTexture",an);class IN{constructor(){this._hasHit=!1,this._hitNormal=m.Zero(),this._hitPoint=m.Zero(),this._triangleIndex=-1}get hitPoint(){return this._hitPoint}get hitNormal(){return this._hitNormal}get hasHit(){return this._hasHit}get triangleIndex(){return this._triangleIndex}setHitData(e,t,i){this._hasHit=!0,this._hitNormal.set(e.x,e.y,e.z),this._hitPoint.set(t.x,t.y,t.z),this._triangleIndex=i??-1}reset(){this._hasHit=!1,this._hitNormal.setAll(0),this._hitPoint.setAll(0),this._triangleIndex=-1,this.body=void 0,this.bodyIndex=void 0,this.shape=void 0}}class Qu extends IN{constructor(){super(...arguments),this._hitDistance=0,this._rayFromWorld=m.Zero(),this._rayToWorld=m.Zero()}get hitDistance(){return this._hitDistance}get hitNormalWorld(){return this._hitNormal}get hitPointWorld(){return this._hitPoint}get rayFromWorld(){return this._rayFromWorld}get rayToWorld(){return this._rayToWorld}setHitDistance(e){this._hitDistance=e}calculateHitDistance(){this._hitDistance=m.Distance(this._rayFromWorld,this._hitPoint)}reset(e=m.Zero(),t=m.Zero()){super.reset(),this._rayFromWorld.copyFrom(e),this._rayToWorld.copyFrom(t),this._hitDistance=0}}let DT=class OT{getPluginVersion(){return this._physicsPlugin.getPluginVersion()}static DefaultPluginFactory(){throw Cr("CannonJSPlugin")}constructor(e,t=OT.DefaultPluginFactory()){if(this._physicsPlugin=t,this._impostors=[],this._joints=[],this._subTimeStep=0,this._uniqueIdCounter=0,!this._physicsPlugin.isSupported())throw new Error("Physics Engine "+this._physicsPlugin.name+" cannot be found. Please make sure it is included.");e=e||new m(0,-9.807,0),this.setGravity(e),this.setTimeStep()}setGravity(e){this.gravity=e,this._physicsPlugin.setGravity(this.gravity)}setTimeStep(e=1/60){this._physicsPlugin.setTimeStep(e)}getTimeStep(){return this._physicsPlugin.getTimeStep()}setSubTimeStep(e=0){this._subTimeStep=e}getSubTimeStep(){return this._subTimeStep}dispose(){this._impostors.forEach(function(e){e.dispose()}),this._physicsPlugin.dispose()}getPhysicsPluginName(){return this._physicsPlugin.name}addImpostor(e){this._impostors.push(e),e.uniqueId=this._uniqueIdCounter++,e.parent||this._physicsPlugin.generatePhysicsBody(e)}removeImpostor(e){const t=this._impostors.indexOf(e);t>-1&&this._impostors.splice(t,1).length&&this.getPhysicsPlugin().removePhysicsBody(e)}addJoint(e,t,i){const r={mainImpostor:e,connectedImpostor:t,joint:i};i.physicsPlugin=this._physicsPlugin,this._joints.push(r),this._physicsPlugin.generateJoint(r)}removeJoint(e,t,i){const r=this._joints.filter(function(s){return s.connectedImpostor===t&&s.joint===i&&s.mainImpostor===e});r.length&&this._physicsPlugin.removeJoint(r[0])}_step(e){this._impostors.forEach(t=>{t.isBodyInitRequired()&&this._physicsPlugin.generatePhysicsBody(t)}),e>.1?e=.1:e<=0&&(e=1/60),this._physicsPlugin.executeStep(e,this._impostors)}getPhysicsPlugin(){return this._physicsPlugin}getImpostors(){return this._impostors}getImpostorForPhysicsObject(e){for(let t=0;t<this._impostors.length;++t)if(this._impostors[t].object===e)return this._impostors[t];return null}getImpostorWithPhysicsBody(e){for(let t=0;t<this._impostors.length;++t)if(this._impostors[t].physicsBody===e)return this._impostors[t];return null}raycast(e,t){return this._physicsPlugin.raycast(e,t)}raycastToRef(e,t,i){return this._physicsPlugin.raycastToRef(e,t,i)}};class Hh{constructor(e=!0,t=10,i=CANNON){if(this._useDeltaForWorldStep=e,this.name="CannonJSPlugin",this._physicsMaterials=new Array,this._fixedTimeStep=1/60,this._physicsBodiesToRemoveAfterStep=new Array,this._firstFrame=!0,this._tmpQuaternion=new re,this._minus90X=new re(-.7071067811865475,0,0,.7071067811865475),this._plus90X=new re(.7071067811865475,0,0,.7071067811865475),this._tmpPosition=m.Zero(),this._tmpDeltaPosition=m.Zero(),this._tmpUnityRotation=new re,this.BJSCANNON=i,!this.isSupported()){L.Error("CannonJS is not available. Please make sure you included the js file.");return}this._extendNamespace(),this.world=new this.BJSCANNON.World,this.world.broadphase=new this.BJSCANNON.NaiveBroadphase,this.world.solver.iterations=t,this._cannonRaycastResult=new this.BJSCANNON.RaycastResult,this._raycastResult=new Qu}getPluginVersion(){return 1}setGravity(e){const t=e;this.world.gravity.set(t.x,t.y,t.z)}setTimeStep(e){this._fixedTimeStep=e}getTimeStep(){return this._fixedTimeStep}executeStep(e,t){if(this._firstFrame){this._firstFrame=!1;for(const i of t)i.type==ve.HeightmapImpostor||i.type===ve.PlaneImpostor||i.beforeStep()}this.world.step(this._useDeltaForWorldStep?e:this._fixedTimeStep),this._removeMarkedPhysicsBodiesFromWorld()}_removeMarkedPhysicsBodiesFromWorld(){this._physicsBodiesToRemoveAfterStep.length>0&&(this._physicsBodiesToRemoveAfterStep.forEach(e=>{typeof this.world.removeBody=="function"?this.world.removeBody(e):this.world.remove(e)}),this._physicsBodiesToRemoveAfterStep.length=0)}applyImpulse(e,t,i){const r=new this.BJSCANNON.Vec3(i.x,i.y,i.z),s=new this.BJSCANNON.Vec3(t.x,t.y,t.z);e.physicsBody.applyImpulse(s,r)}applyForce(e,t,i){const r=new this.BJSCANNON.Vec3(i.x,i.y,i.z),s=new this.BJSCANNON.Vec3(t.x,t.y,t.z);e.physicsBody.applyForce(s,r)}generatePhysicsBody(e){if(this._removeMarkedPhysicsBodiesFromWorld(),e.parent){e.physicsBody&&(this.removePhysicsBody(e),e.forceUpdate());return}if(e.isBodyInitRequired()){const t=this._createShape(e);if(!t){L.Warn("It was not possible to create a physics body for this object.");return}const i=e.physicsBody;i&&this.removePhysicsBody(e);const r=this._addMaterial("mat-"+e.uniqueId,e.getParam("friction"),e.getParam("restitution")),s={mass:e.getParam("mass"),material:r},n=e.getParam("nativeOptions");for(const o in n)Object.prototype.hasOwnProperty.call(n,o)&&(s[o]=n[o]);e.physicsBody=new this.BJSCANNON.Body(s),e.physicsBody.addEventListener("collide",e.onCollide),this.world.addEventListener("preStep",e.beforeStep),this.world.addEventListener("postStep",e.afterStep),e.physicsBody.addShape(t),typeof this.world.addBody=="function"?this.world.addBody(e.physicsBody):this.world.add(e.physicsBody),i&&["force","torque","velocity","angularVelocity"].forEach(function(o){const l=i[o];e.physicsBody[o].set(l.x,l.y,l.z)}),this._processChildMeshes(e)}this._updatePhysicsBodyTransformation(e)}_processChildMeshes(e){const t=e.object.getChildMeshes?e.object.getChildMeshes(!0):[],i=e.object.rotationQuaternion;if(i?i.conjugateToRef(this._tmpQuaternion):this._tmpQuaternion.set(0,0,0,1),t.length){const r=s=>{if(!s.rotationQuaternion)return;const n=s.getPhysicsImpostor();if(n&&n.parent!==e&&s.parent){const l=s.getAbsolutePosition().subtract(s.parent.getAbsolutePosition()),u=s.rotationQuaternion.multiply(this._tmpQuaternion);n.physicsBody&&(this.removePhysicsBody(n),n.physicsBody=null),n.parent=e,n.resetUpdateFlags(),e.physicsBody.addShape(this._createShape(n),new this.BJSCANNON.Vec3(l.x,l.y,l.z),new this.BJSCANNON.Quaternion(u.x,u.y,u.z,u.w)),e.physicsBody.mass+=n.getParam("mass")}s.getChildMeshes(!0).filter(o=>!!o.physicsImpostor).forEach(r)};t.filter(s=>!!s.physicsImpostor).forEach(r)}}removePhysicsBody(e){e.physicsBody.removeEventListener("collide",e.onCollide),this.world.removeEventListener("preStep",e.beforeStep),this.world.removeEventListener("postStep",e.afterStep),this._physicsBodiesToRemoveAfterStep.indexOf(e.physicsBody)===-1&&this._physicsBodiesToRemoveAfterStep.push(e.physicsBody)}generateJoint(e){const t=e.mainImpostor.physicsBody,i=e.connectedImpostor.physicsBody;if(!t||!i)return;let r;const s=e.joint.jointData,n={pivotA:s.mainPivot?new this.BJSCANNON.Vec3().set(s.mainPivot.x,s.mainPivot.y,s.mainPivot.z):null,pivotB:s.connectedPivot?new this.BJSCANNON.Vec3().set(s.connectedPivot.x,s.connectedPivot.y,s.connectedPivot.z):null,axisA:s.mainAxis?new this.BJSCANNON.Vec3().set(s.mainAxis.x,s.mainAxis.y,s.mainAxis.z):null,axisB:s.connectedAxis?new this.BJSCANNON.Vec3().set(s.connectedAxis.x,s.connectedAxis.y,s.connectedAxis.z):null,maxForce:s.nativeParams.maxForce,collideConnected:!!s.collision};switch(e.joint.type){case rt.HingeJoint:case rt.Hinge2Joint:r=new this.BJSCANNON.HingeConstraint(t,i,n);break;case rt.DistanceJoint:r=new this.BJSCANNON.DistanceConstraint(t,i,s.maxDistance||2);break;case rt.SpringJoint:{const o=s;r=new this.BJSCANNON.Spring(t,i,{restLength:o.length,stiffness:o.stiffness,damping:o.damping,localAnchorA:n.pivotA,localAnchorB:n.pivotB});break}case rt.LockJoint:r=new this.BJSCANNON.LockConstraint(t,i,n);break;case rt.PointToPointJoint:case rt.BallAndSocketJoint:default:r=new this.BJSCANNON.PointToPointConstraint(t,n.pivotA,i,n.pivotB,n.maxForce);break}r.collideConnected=!!s.collision,e.joint.physicsJoint=r,e.joint.type!==rt.SpringJoint?this.world.addConstraint(r):(e.joint.jointData.forceApplicationCallback=e.joint.jointData.forceApplicationCallback||function(){r.applyForce()},e.mainImpostor.registerAfterPhysicsStep(e.joint.jointData.forceApplicationCallback))}removeJoint(e){e.joint.type!==rt.SpringJoint?this.world.removeConstraint(e.joint.physicsJoint):e.mainImpostor.unregisterAfterPhysicsStep(e.joint.jointData.forceApplicationCallback)}_addMaterial(e,t,i){let r,s;for(r=0;r<this._physicsMaterials.length;r++)if(s=this._physicsMaterials[r],s.friction===t&&s.restitution===i)return s;const n=new this.BJSCANNON.Material(e);return n.friction=t,n.restitution=i,this._physicsMaterials.push(n),n}_checkWithEpsilon(e){return e<He?He:e}_createShape(e){const t=e.object;let i;const r=e.getObjectExtents();switch(e.type){case ve.SphereImpostor:{const s=r.x,n=r.y,o=r.z;i=new this.BJSCANNON.Sphere(Math.max(this._checkWithEpsilon(s),this._checkWithEpsilon(n),this._checkWithEpsilon(o))/2);break}case ve.CylinderImpostor:{let s=e.getParam("nativeOptions");s||(s={});const n=s.radiusTop!==void 0?s.radiusTop:this._checkWithEpsilon(r.x)/2,o=s.radiusBottom!==void 0?s.radiusBottom:this._checkWithEpsilon(r.x)/2,l=s.height!==void 0?s.height:this._checkWithEpsilon(r.y),u=s.numSegments!==void 0?s.numSegments:16;i=new this.BJSCANNON.Cylinder(n,o,l,u);const c=new this.BJSCANNON.Quaternion;c.setFromAxisAngle(new this.BJSCANNON.Vec3(1,0,0),-Math.PI/2);const h=new this.BJSCANNON.Vec3(0,0,0);i.transformAllPoints(h,c);break}case ve.BoxImpostor:{const s=r.scale(.5);i=new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(this._checkWithEpsilon(s.x),this._checkWithEpsilon(s.y),this._checkWithEpsilon(s.z)));break}case ve.PlaneImpostor:L.Warn("Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead"),i=new this.BJSCANNON.Plane;break;case ve.MeshImpostor:{const s=t.getVerticesData?t.getVerticesData(N.PositionKind):[],n=t.getIndices?t.getIndices():[];if(!s){L.Warn("Tried to create a MeshImpostor for an object without vertices. This will fail.");return}const o=t.position.clone(),l=t.rotation&&t.rotation.clone(),u=t.rotationQuaternion&&t.rotationQuaternion.clone();t.position.copyFromFloats(0,0,0),t.rotation&&t.rotation.copyFromFloats(0,0,0),t.rotationQuaternion&&t.rotationQuaternion.copyFrom(e.getParentsRotation()),t.rotationQuaternion&&t.parent&&t.rotationQuaternion.conjugateInPlace();const c=t.computeWorldMatrix(!0),h=[];let d;for(d=0;d<s.length;d+=3)m.TransformCoordinates(m.FromArray(s,d),c).toArray(h,d);L.Warn("MeshImpostor only collides against spheres."),i=new this.BJSCANNON.Trimesh(h,n),t.position.copyFrom(o),l&&t.rotation&&t.rotation.copyFrom(l),u&&t.rotationQuaternion&&t.rotationQuaternion.copyFrom(u);break}case ve.HeightmapImpostor:{const s=t.position.clone(),n=t.rotation&&t.rotation.clone(),o=t.rotationQuaternion&&t.rotationQuaternion.clone();t.position.copyFromFloats(0,0,0),t.rotation&&t.rotation.copyFromFloats(0,0,0),t.rotationQuaternion&&t.rotationQuaternion.copyFrom(e.getParentsRotation()),t.rotationQuaternion&&t.parent&&t.rotationQuaternion.conjugateInPlace(),t.rotationQuaternion&&t.rotationQuaternion.multiplyInPlace(this._minus90X),i=this._createHeightmap(t),t.position.copyFrom(s),n&&t.rotation&&t.rotation.copyFrom(n),o&&t.rotationQuaternion&&t.rotationQuaternion.copyFrom(o),t.computeWorldMatrix(!0);break}case ve.ParticleImpostor:i=new this.BJSCANNON.Particle;break;case ve.NoImpostor:i=new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(0,0,0));break}return i}_createHeightmap(e,t){let i=e.getVerticesData(N.PositionKind);const r=e.computeWorldMatrix(!0),s=[];let n;for(n=0;n<i.length;n+=3)m.TransformCoordinates(m.FromArray(i,n),r).toArray(s,n);i=s;const o=new Array,l=t||~~(Math.sqrt(i.length/3)-1),u=e.getBoundingInfo(),c=Math.min(u.boundingBox.extendSizeWorld.x,u.boundingBox.extendSizeWorld.y),h=u.boundingBox.extendSizeWorld.z,d=c*2/l;for(let p=0;p<i.length;p=p+3){const g=Math.round(i[p+0]/d+l/2),_=Math.round((i[p+1]/d-l/2)*-1),S=-i[p+2]+h;o[g]||(o[g]=[]),o[g][_]||(o[g][_]=S),o[g][_]=Math.max(S,o[g][_])}for(let p=0;p<=l;++p){if(!o[p]){let g=1;for(;!o[(p+g)%l];)g++;o[p]=o[(p+g)%l].slice()}for(let g=0;g<=l;++g)if(!o[p][g]){let _=1,S;for(;S===void 0;)S=o[p][(g+_++)%l];o[p][g]=S}}const f=new this.BJSCANNON.Heightfield(o,{elementSize:d});return f.minY=h,f}_updatePhysicsBodyTransformation(e){const t=e.object;if(t.computeWorldMatrix&&t.computeWorldMatrix(!0),!t.getBoundingInfo())return;const i=e.getObjectCenter();this._tmpDeltaPosition.copyFrom(t.getAbsolutePivotPoint().subtract(i)),this._tmpDeltaPosition.divideInPlace(e.object.scaling),this._tmpPosition.copyFrom(i);let r=t.rotationQuaternion;if(r){if((e.type===ve.PlaneImpostor||e.type===ve.HeightmapImpostor)&&(r=r.multiply(this._minus90X),e.setDeltaRotation(this._plus90X)),e.type===ve.HeightmapImpostor){const s=t;let n=s.getBoundingInfo();const o=s.rotationQuaternion;s.rotationQuaternion=this._tmpUnityRotation,s.computeWorldMatrix(!0);const l=i.clone();let u=s.getPivotMatrix();u?u=u.clone():u=$.Identity();const c=$.Translation(n.boundingBox.extendSizeWorld.x,0,-n.boundingBox.extendSizeWorld.z);s.setPreTransformMatrix(c),s.computeWorldMatrix(!0),n=s.getBoundingInfo();const h=n.boundingBox.centerWorld.subtract(i).subtract(s.position).negate();this._tmpPosition.copyFromFloats(h.x,h.y-n.boundingBox.extendSizeWorld.y,h.z),this._tmpDeltaPosition.copyFrom(n.boundingBox.centerWorld.subtract(l)),this._tmpDeltaPosition.y+=n.boundingBox.extendSizeWorld.y,s.rotationQuaternion=o,s.setPreTransformMatrix(u),s.computeWorldMatrix(!0)}else e.type===ve.MeshImpostor&&this._tmpDeltaPosition.copyFromFloats(0,0,0);e.setDeltaPosition(this._tmpDeltaPosition),e.physicsBody.position.set(this._tmpPosition.x,this._tmpPosition.y,this._tmpPosition.z),e.physicsBody.quaternion.set(r.x,r.y,r.z,r.w)}}setTransformationFromPhysicsBody(e){if(e.object.position.set(e.physicsBody.position.x,e.physicsBody.position.y,e.physicsBody.position.z),e.object.rotationQuaternion){const t=e.physicsBody.quaternion;e.object.rotationQuaternion.set(t.x,t.y,t.z,t.w)}}setPhysicsBodyTransformation(e,t,i){e.physicsBody.position.set(t.x,t.y,t.z),e.physicsBody.quaternion.set(i.x,i.y,i.z,i.w)}isSupported(){return this.BJSCANNON!==void 0}setLinearVelocity(e,t){e.physicsBody.velocity.set(t.x,t.y,t.z)}setAngularVelocity(e,t){e.physicsBody.angularVelocity.set(t.x,t.y,t.z)}getLinearVelocity(e){const t=e.physicsBody.velocity;return t?new m(t.x,t.y,t.z):null}getAngularVelocity(e){const t=e.physicsBody.angularVelocity;return t?new m(t.x,t.y,t.z):null}setBodyMass(e,t){e.physicsBody.mass=t,e.physicsBody.updateMassProperties()}getBodyMass(e){return e.physicsBody.mass}getBodyFriction(e){return e.physicsBody.material.friction}setBodyFriction(e,t){e.physicsBody.material.friction=t}getBodyRestitution(e){return e.physicsBody.material.restitution}setBodyRestitution(e,t){e.physicsBody.material.restitution=t}sleepBody(e){e.physicsBody.sleep()}wakeUpBody(e){e.physicsBody.wakeUp()}updateDistanceJoint(e,t){e.physicsJoint.distance=t}setMotor(e,t,i,r){r||(e.physicsJoint.enableMotor(),e.physicsJoint.setMotorSpeed(t),i&&this.setLimit(e,i))}setLimit(e,t,i){e.physicsJoint.motorEquation.maxForce=i,e.physicsJoint.motorEquation.minForce=t===void 0?-t:t}syncMeshWithImpostor(e,t){const i=t.physicsBody;e.position.x=i.position.x,e.position.y=i.position.y,e.position.z=i.position.z,e.rotationQuaternion&&(e.rotationQuaternion.x=i.quaternion.x,e.rotationQuaternion.y=i.quaternion.y,e.rotationQuaternion.z=i.quaternion.z,e.rotationQuaternion.w=i.quaternion.w)}getRadius(e){return e.physicsBody.shapes[0].boundingSphereRadius}getBoxSizeToRef(e,t){const i=e.physicsBody.shapes[0];t.x=i.halfExtents.x*2,t.y=i.halfExtents.y*2,t.z=i.halfExtents.z*2}dispose(){}_extendNamespace(){const e=new this.BJSCANNON.Vec3,t=this.BJSCANNON;this.BJSCANNON.World.prototype.step=function(i,r,s){if(s=s||10,r=r||0,r===0)this.internalStep(i),this.time+=i;else{let n=Math.floor((this.time+r)/i)-Math.floor(this.time/i);n=Math.min(n,s)||1;const o=performance.now();for(let d=0;d!==n&&(this.internalStep(i),!(performance.now()-o>i*1e3));d++);this.time+=r;const u=this.time%i/i,c=e,h=this.bodies;for(let d=0;d!==h.length;d++){const f=h[d];f.type!==t.Body.STATIC&&f.sleepState!==t.Body.SLEEPING?(f.position.vsub(f.previousPosition,c),c.scale(u,c),f.position.vadd(c,f.interpolatedPosition)):(f.interpolatedPosition.set(f.position.x,f.position.y,f.position.z),f.interpolatedQuaternion.set(f.quaternion.x,f.quaternion.y,f.quaternion.z,f.quaternion.w))}}}}raycast(e,t){return this._raycastResult.reset(e,t),this.raycastToRef(e,t,this._raycastResult),this._raycastResult}raycastToRef(e,t,i){this._cannonRaycastResult.reset(),this.world.raycastClosest(e,t,{},this._cannonRaycastResult),i.reset(e,t),this._cannonRaycastResult.hasHit&&(i.setHitData({x:this._cannonRaycastResult.hitNormalWorld.x,y:this._cannonRaycastResult.hitNormalWorld.y,z:this._cannonRaycastResult.hitNormalWorld.z},{x:this._cannonRaycastResult.hitPointWorld.x,y:this._cannonRaycastResult.hitPointWorld.y,z:this._cannonRaycastResult.hitPointWorld.z}),i.setHitDistance(this._cannonRaycastResult.distance))}}DT.DefaultPluginFactory=()=>new Hh;class DS{constructor(e=!0,t,i=OIMO){this._useDeltaForWorldStep=e,this.name="OimoJSPlugin",this._fixedTimeStep=1/60,this._tmpImpostorsArray=[],this._tmpPositionVector=m.Zero(),this.BJSOIMO=i,this.world=new this.BJSOIMO.World({iterations:t}),this.world.clear(),this._raycastResult=new Qu}getPluginVersion(){return 1}setGravity(e){this.world.gravity.set(e.x,e.y,e.z)}setTimeStep(e){this.world.timeStep=e}getTimeStep(){return this.world.timeStep}executeStep(e,t){t.forEach(function(r){r.beforeStep()}),this.world.timeStep=this._useDeltaForWorldStep?e:this._fixedTimeStep,this.world.step(),t.forEach(r=>{r.afterStep(),this._tmpImpostorsArray[r.uniqueId]=r});let i=this.world.contacts;for(;i!==null;){if(i.touching&&!i.body1.sleeping&&!i.body2.sleeping){i=i.next;continue}const r=this._tmpImpostorsArray[+i.body1.name],s=this._tmpImpostorsArray[+i.body2.name];if(!r||!s){i=i.next;continue}r.onCollide({body:s.physicsBody,point:null,distance:0,impulse:0,normal:null}),s.onCollide({body:r.physicsBody,point:null,distance:0,impulse:0,normal:null}),i=i.next}}applyImpulse(e,t,i){const r=e.physicsBody.mass;e.physicsBody.applyImpulse(i.scale(this.world.invScale),t.scale(this.world.invScale*r))}applyForce(e,t,i){L.Warn("Oimo doesn't support applying force. Using impulse instead."),this.applyImpulse(e,t,i)}generatePhysicsBody(e){if(e.parent){e.physicsBody&&(this.removePhysicsBody(e),e.forceUpdate());return}if(e.isBodyInitRequired()){const t={name:e.uniqueId,config:[e.getParam("mass")||.001,e.getParam("friction"),e.getParam("restitution")],size:[],type:[],pos:[],posShape:[],rot:[],rotShape:[],move:e.getParam("mass")!==0,density:e.getParam("mass"),friction:e.getParam("friction"),restitution:e.getParam("restitution"),world:this.world},i=[e];(o=>{o.getChildMeshes&&o.getChildMeshes().forEach(function(l){l.physicsImpostor&&i.push(l.physicsImpostor)})})(e.object);const s=o=>Math.max(o,He),n=new re;i.forEach(o=>{if(!o.object.rotationQuaternion)return;const l=o.object.rotationQuaternion;n.copyFrom(l),o.object.rotationQuaternion.set(0,0,0,1),o.object.computeWorldMatrix(!0);const u=n.toEulerAngles(),c=o.getObjectExtents(),h=57.29577951308232;if(o===e){const d=e.getObjectCenter();e.object.getAbsolutePivotPoint().subtractToRef(d,this._tmpPositionVector),this._tmpPositionVector.divideInPlace(e.object.scaling),t.pos.push(d.x),t.pos.push(d.y),t.pos.push(d.z),t.posShape.push(0,0,0),t.rotShape.push(0,0,0)}else{const d=o.object.position.clone();t.posShape.push(d.x),t.posShape.push(d.y),t.posShape.push(d.z),t.rotShape.push(u.x*h,u.y*h,u.z*h)}switch(o.object.rotationQuaternion.copyFrom(n),o.type){case ve.ParticleImpostor:L.Warn("No Particle support in OIMO.js. using SphereImpostor instead");case ve.SphereImpostor:{const d=c.x,f=c.y,p=c.z,g=Math.max(s(d),s(f),s(p))/2;t.type.push("sphere"),t.size.push(g),t.size.push(g),t.size.push(g);break}case ve.CylinderImpostor:{const d=s(c.x)/2,f=s(c.y);t.type.push("cylinder"),t.size.push(d),t.size.push(f),t.size.push(f);break}case ve.PlaneImpostor:case ve.BoxImpostor:default:{const d=s(c.x),f=s(c.y),p=s(c.z);t.type.push("box"),t.size.push(d),t.size.push(f),t.size.push(p);break}}o.object.rotationQuaternion=l}),e.physicsBody=this.world.add(t),e.physicsBody.resetQuaternion(n),e.physicsBody.updatePosition(0)}else this._tmpPositionVector.copyFromFloats(0,0,0);e.setDeltaPosition(this._tmpPositionVector)}removePhysicsBody(e){this.world.removeRigidBody(e.physicsBody)}generateJoint(e){const t=e.mainImpostor.physicsBody,i=e.connectedImpostor.physicsBody;if(!t||!i)return;const r=e.joint.jointData,s=r.nativeParams||{};let n;const o={body1:t,body2:i,axe1:s.axe1||(r.mainAxis?r.mainAxis.asArray():null),axe2:s.axe2||(r.connectedAxis?r.connectedAxis.asArray():null),pos1:s.pos1||(r.mainPivot?r.mainPivot.asArray():null),pos2:s.pos2||(r.connectedPivot?r.connectedPivot.asArray():null),min:s.min,max:s.max,collision:s.collision||r.collision,spring:s.spring,world:this.world};switch(e.joint.type){case rt.BallAndSocketJoint:n="jointBall";break;case rt.SpringJoint:{L.Warn("OIMO.js doesn't support Spring Constraint. Simulating using DistanceJoint instead");const l=r;o.min=l.length||o.min,o.max=Math.max(o.min,o.max)}case rt.DistanceJoint:n="jointDistance",o.max=r.maxDistance;break;case rt.PrismaticJoint:n="jointPrisme";break;case rt.SliderJoint:n="jointSlide";break;case rt.WheelJoint:n="jointWheel";break;case rt.HingeJoint:default:n="jointHinge";break}o.type=n,e.joint.physicsJoint=this.world.add(o)}removeJoint(e){try{this.world.removeJoint(e.joint.physicsJoint)}catch(t){L.Warn(t)}}isSupported(){return this.BJSOIMO!==void 0}setTransformationFromPhysicsBody(e){if(!e.physicsBody.sleeping){if(e.physicsBody.shapes.next){let t=e.physicsBody.shapes;for(;t.next;)t=t.next;e.object.position.set(t.position.x,t.position.y,t.position.z)}else{const t=e.physicsBody.getPosition();e.object.position.set(t.x,t.y,t.z)}if(e.object.rotationQuaternion){const t=e.physicsBody.getQuaternion();e.object.rotationQuaternion.set(t.x,t.y,t.z,t.w)}}}setPhysicsBodyTransformation(e,t,i){const r=e.physicsBody;e.physicsBody.shapes.next||(r.position.set(t.x,t.y,t.z),r.orientation.set(i.x,i.y,i.z,i.w),r.syncShapes(),r.awake())}setLinearVelocity(e,t){e.physicsBody.linearVelocity.set(t.x,t.y,t.z)}setAngularVelocity(e,t){e.physicsBody.angularVelocity.set(t.x,t.y,t.z)}getLinearVelocity(e){const t=e.physicsBody.linearVelocity;return t?new m(t.x,t.y,t.z):null}getAngularVelocity(e){const t=e.physicsBody.angularVelocity;return t?new m(t.x,t.y,t.z):null}setBodyMass(e,t){const i=t===0;e.physicsBody.shapes.density=i?1:t,e.physicsBody.setupMass(i?2:1)}getBodyMass(e){return e.physicsBody.shapes.density}getBodyFriction(e){return e.physicsBody.shapes.friction}setBodyFriction(e,t){e.physicsBody.shapes.friction=t}getBodyRestitution(e){return e.physicsBody.shapes.restitution}setBodyRestitution(e,t){e.physicsBody.shapes.restitution=t}sleepBody(e){e.physicsBody.sleep()}wakeUpBody(e){e.physicsBody.awake()}updateDistanceJoint(e,t,i){e.physicsJoint.limitMotor.upperLimit=t,i!==void 0&&(e.physicsJoint.limitMotor.lowerLimit=i)}setMotor(e,t,i,r){i!==void 0?L.Warn("OimoJS plugin currently has unexpected behavior when using setMotor with force parameter"):i=1e6,t*=-1;const s=r?e.physicsJoint.rotationalLimitMotor2:e.physicsJoint.rotationalLimitMotor1||e.physicsJoint.rotationalLimitMotor||e.physicsJoint.limitMotor;s&&s.setMotor(t,i)}setLimit(e,t,i,r){const s=r?e.physicsJoint.rotationalLimitMotor2:e.physicsJoint.rotationalLimitMotor1||e.physicsJoint.rotationalLimitMotor||e.physicsJoint.limitMotor;s&&s.setLimit(t,i===void 0?-t:i)}syncMeshWithImpostor(e,t){const i=t.physicsBody;e.position.x=i.position.x,e.position.y=i.position.y,e.position.z=i.position.z,e.rotationQuaternion&&(e.rotationQuaternion.x=i.orientation.x,e.rotationQuaternion.y=i.orientation.y,e.rotationQuaternion.z=i.orientation.z,e.rotationQuaternion.w=i.orientation.w)}getRadius(e){return e.physicsBody.shapes.radius}getBoxSizeToRef(e,t){const i=e.physicsBody.shapes;t.x=i.halfWidth*2,t.y=i.halfHeight*2,t.z=i.halfDepth*2}dispose(){this.world.clear()}raycast(e,t){return L.Warn("raycast is not currently supported by the Oimo physics plugin"),this._raycastResult.reset(e,t),this._raycastResult}raycastToRef(e,t,i){L.Warn("raycast is not currently supported by the Oimo physics plugin"),i.reset(e,t)}}class is{constructor(e=!0,t=Ammo,i=null){if(this._useDeltaForWorldStep=e,this.bjsAMMO={},this.name="AmmoJSPlugin",this._timeStep=1/60,this._fixedTimeStep=1/60,this._maxSteps=5,this._tmpQuaternion=new re,this._tmpContactCallbackResult=!1,this._tmpContactPoint=new m,this._tmpContactNormal=new m,this._tmpVec3=new m,this._tmpMatrix=new $,typeof t=="function"){L.Error("AmmoJS is not ready. Please make sure you await Ammo() before using the plugin.");return}else this.bjsAMMO=t;if(!this.isSupported()){L.Error("AmmoJS is not available. Please make sure you included the js file.");return}this._collisionConfiguration=new this.bjsAMMO.btSoftBodyRigidBodyCollisionConfiguration,this._dispatcher=new this.bjsAMMO.btCollisionDispatcher(this._collisionConfiguration),this._overlappingPairCache=i||new this.bjsAMMO.btDbvtBroadphase,this._solver=new this.bjsAMMO.btSequentialImpulseConstraintSolver,this._softBodySolver=new this.bjsAMMO.btDefaultSoftBodySolver,this.world=new this.bjsAMMO.btSoftRigidDynamicsWorld(this._dispatcher,this._overlappingPairCache,this._solver,this._collisionConfiguration,this._softBodySolver),this._tmpAmmoConcreteContactResultCallback=new this.bjsAMMO.ConcreteContactResultCallback,this._tmpAmmoConcreteContactResultCallback.addSingleResult=r=>{r=this.bjsAMMO.wrapPointer(r,this.bjsAMMO.btManifoldPoint);const s=r.getPositionWorldOnA(),n=r.m_normalWorldOnB;this._tmpContactPoint.x=s.x(),this._tmpContactPoint.y=s.y(),this._tmpContactPoint.z=s.z(),this._tmpContactNormal.x=n.x(),this._tmpContactNormal.y=n.y(),this._tmpContactNormal.z=n.z(),this._tmpContactImpulse=r.getAppliedImpulse(),this._tmpContactDistance=r.getDistance(),this._tmpContactCallbackResult=!0},this._raycastResult=new Qu,this._tmpAmmoTransform=new this.bjsAMMO.btTransform,this._tmpAmmoTransform.setIdentity(),this._tmpAmmoQuaternion=new this.bjsAMMO.btQuaternion(0,0,0,1),this._tmpAmmoVectorA=new this.bjsAMMO.btVector3(0,0,0),this._tmpAmmoVectorB=new this.bjsAMMO.btVector3(0,0,0),this._tmpAmmoVectorC=new this.bjsAMMO.btVector3(0,0,0),this._tmpAmmoVectorD=new this.bjsAMMO.btVector3(0,0,0)}getPluginVersion(){return 1}setGravity(e){this._tmpAmmoVectorA.setValue(e.x,e.y,e.z),this.world.setGravity(this._tmpAmmoVectorA),this.world.getWorldInfo().set_m_gravity(this._tmpAmmoVectorA)}setTimeStep(e){this._timeStep=e}setFixedTimeStep(e){this._fixedTimeStep=e}setMaxSteps(e){this._maxSteps=e}getTimeStep(){return this._timeStep}_isImpostorInContact(e){return this._tmpContactCallbackResult=!1,this.world.contactTest(e.physicsBody,this._tmpAmmoConcreteContactResultCallback),this._tmpContactCallbackResult}_isImpostorPairInContact(e,t){return this._tmpContactCallbackResult=!1,this.world.contactPairTest(e.physicsBody,t.physicsBody,this._tmpAmmoConcreteContactResultCallback),this._tmpContactCallbackResult}_stepSimulation(e=1/60,t=10,i=1/60){if(t==0)this.world.stepSimulation(e,0);else for(;t>0&&e>0;)e-i<i?(this.world.stepSimulation(e,0),e=0):(e-=i,this.world.stepSimulation(i,0)),t--}executeStep(e,t){for(const i of t)i.soft||i.beforeStep();this._stepSimulation(this._useDeltaForWorldStep?e:this._timeStep,this._maxSteps,this._fixedTimeStep);for(const i of t)if(i.soft?this._afterSoftStep(i):i.afterStep(),i._onPhysicsCollideCallbacks.length>0&&this._isImpostorInContact(i))for(const r of i._onPhysicsCollideCallbacks)for(const s of r.otherImpostors)(i.physicsBody.isActive()||s.physicsBody.isActive())&&this._isImpostorPairInContact(i,s)&&(i.onCollide({body:s.physicsBody,point:this._tmpContactPoint,distance:this._tmpContactDistance,impulse:this._tmpContactImpulse,normal:this._tmpContactNormal}),s.onCollide({body:i.physicsBody,point:this._tmpContactPoint,distance:this._tmpContactDistance,impulse:this._tmpContactImpulse,normal:this._tmpContactNormal}))}_afterSoftStep(e){e.type===ve.RopeImpostor?this._ropeStep(e):this._softbodyOrClothStep(e)}_ropeStep(e){const t=e.physicsBody.get_m_nodes(),i=t.size();let r,s,n,o,l;const u=new Array;for(let d=0;d<i;d++)r=t.at(d),s=r.get_m_x(),n=s.x(),o=s.y(),l=s.z(),u.push(new m(n,o,l));const c=e.object,h=e.getParam("shape");e._isFromLine?e.object=ai("lines",{points:u,instance:c}):e.object=Fu("ext",{shape:h,path:u,instance:c})}_softbodyOrClothStep(e){const t=e.type===ve.ClothImpostor?1:-1,i=e.object;let r=i.getVerticesData(N.PositionKind);r||(r=[]);let s=i.getVerticesData(N.NormalKind);s||(s=[]);const n=r.length/3,o=e.physicsBody.get_m_nodes();let l,u,c,h,d,f,p,g;for(let S=0;S<n;S++){l=o.at(S),u=l.get_m_x(),c=u.x(),h=u.y(),d=u.z()*t;const b=l.get_m_n();f=b.x(),p=b.y(),g=b.z()*t,r[3*S]=c,r[3*S+1]=h,r[3*S+2]=d,s[3*S]=f,s[3*S+1]=p,s[3*S+2]=g}const _=new he;_.positions=r,_.normals=s,_.uvs=i.getVerticesData(N.UVKind),_.colors=i.getVerticesData(N.ColorKind),i&&i.getIndices&&(_.indices=i.getIndices()),_.applyToMesh(i)}applyImpulse(e,t,i){if(e.soft)L.Warn("Cannot be applied to a soft body");else{e.physicsBody.activate();const r=this._tmpAmmoVectorA,s=this._tmpAmmoVectorB;e.object&&e.object.getWorldMatrix&&i.subtractInPlace(e.object.getWorldMatrix().getTranslation()),r.setValue(i.x,i.y,i.z),s.setValue(t.x,t.y,t.z),e.physicsBody.applyImpulse(s,r)}}applyForce(e,t,i){if(e.soft)L.Warn("Cannot be applied to a soft body");else{e.physicsBody.activate();const r=this._tmpAmmoVectorA,s=this._tmpAmmoVectorB;if(e.object&&e.object.getWorldMatrix){const n=e.object.getWorldMatrix().getTranslation();r.setValue(i.x-n.x,i.y-n.y,i.z-n.z)}else r.setValue(i.x,i.y,i.z);s.setValue(t.x,t.y,t.z),e.physicsBody.applyForce(s,r)}}generatePhysicsBody(e){if(e._pluginData.toDispose=[],e.parent){e.physicsBody&&(this.removePhysicsBody(e),e.forceUpdate());return}if(e.isBodyInitRequired()){const t=this._createShape(e),i=e.getParam("mass");if(e._pluginData.mass=i,e.soft)t.get_m_cfg().set_collisions(17),t.get_m_cfg().set_kDP(e.getParam("damping")),this.bjsAMMO.castObject(t,this.bjsAMMO.btCollisionObject).getCollisionShape().setMargin(e.getParam("margin")),t.setActivationState(is._DISABLE_DEACTIVATION_FLAG),this.world.addSoftBody(t,1,-1),e.physicsBody=t,e._pluginData.toDispose.push(t),this.setBodyPressure(e,0),e.type===ve.SoftbodyImpostor&&this.setBodyPressure(e,e.getParam("pressure")),this.setBodyStiffness(e,e.getParam("stiffness")),this.setBodyVelocityIterations(e,e.getParam("velocityIterations")),this.setBodyPositionIterations(e,e.getParam("positionIterations"));else{const r=new this.bjsAMMO.btVector3(0,0,0),s=new this.bjsAMMO.btTransform;e.object.computeWorldMatrix(!0),s.setIdentity(),i!==0&&t.calculateLocalInertia(i,r),this._tmpAmmoVectorA.setValue(e.object.position.x,e.object.position.y,e.object.position.z),this._tmpAmmoQuaternion.setValue(e.object.rotationQuaternion.x,e.object.rotationQuaternion.y,e.object.rotationQuaternion.z,e.object.rotationQuaternion.w),s.setOrigin(this._tmpAmmoVectorA),s.setRotation(this._tmpAmmoQuaternion);const n=new this.bjsAMMO.btDefaultMotionState(s),o=new this.bjsAMMO.btRigidBodyConstructionInfo(i,n,t,r),l=new this.bjsAMMO.btRigidBody(o);if(i===0&&(l.setCollisionFlags(l.getCollisionFlags()|is._KINEMATIC_FLAG),l.setActivationState(is._DISABLE_DEACTIVATION_FLAG)),e.type==ve.NoImpostor&&!t.getChildShape&&l.setCollisionFlags(l.getCollisionFlags()|is._DISABLE_COLLISION_FLAG),e.type!==ve.MeshImpostor&&e.type!==ve.NoImpostor){const h=e.object.getBoundingInfo();this._tmpVec3.copyFrom(e.object.getAbsolutePosition()),this._tmpVec3.subtractInPlace(h.boundingBox.centerWorld),this._tmpVec3.x/=e.object.scaling.x,this._tmpVec3.y/=e.object.scaling.y,this._tmpVec3.z/=e.object.scaling.z,e.setDeltaPosition(this._tmpVec3)}const u=e.getParam("group"),c=e.getParam("mask");u&&c?this.world.addRigidBody(l,u,c):this.world.addRigidBody(l),e.physicsBody=l,e._pluginData.toDispose=e._pluginData.toDispose.concat([l,o,n,s,r,t])}this.setBodyRestitution(e,e.getParam("restitution")),this.setBodyFriction(e,e.getParam("friction"))}}removePhysicsBody(e){this.world&&(e.soft?this.world.removeSoftBody(e.physicsBody):this.world.removeRigidBody(e.physicsBody),e._pluginData&&(e._pluginData.toDispose.forEach(t=>{this.bjsAMMO.destroy(t)}),e._pluginData.toDispose=[]))}generateJoint(e){const t=e.mainImpostor.physicsBody,i=e.connectedImpostor.physicsBody;if(!t||!i||e.joint.physicsJoint)return;const r=e.joint.jointData;r.mainPivot||(r.mainPivot=new m(0,0,0)),r.connectedPivot||(r.connectedPivot=new m(0,0,0));let s;switch(e.joint.type){case rt.DistanceJoint:{const n=r.maxDistance;n&&(r.mainPivot=new m(0,-n/2,0),r.connectedPivot=new m(0,n/2,0));const o=this._tmpAmmoVectorA;o.setValue(r.mainPivot.x,r.mainPivot.y,r.mainPivot.z);const l=this._tmpAmmoVectorB;l.setValue(r.connectedPivot.x,r.connectedPivot.y,r.connectedPivot.z),s=new this.bjsAMMO.btPoint2PointConstraint(t,i,o,l);break}case rt.HingeJoint:{r.mainAxis||(r.mainAxis=new m(0,0,0)),r.connectedAxis||(r.connectedAxis=new m(0,0,0));const n=this._tmpAmmoVectorA;n.setValue(r.mainPivot.x,r.mainPivot.y,r.mainPivot.z);const o=this._tmpAmmoVectorB;o.setValue(r.connectedPivot.x,r.connectedPivot.y,r.connectedPivot.z);const l=this._tmpAmmoVectorC;l.setValue(r.mainAxis.x,r.mainAxis.y,r.mainAxis.z);const u=this._tmpAmmoVectorD;u.setValue(r.connectedAxis.x,r.connectedAxis.y,r.connectedAxis.z),s=new this.bjsAMMO.btHingeConstraint(t,i,n,o,l,u);break}case rt.BallAndSocketJoint:{const n=this._tmpAmmoVectorA;n.setValue(r.mainPivot.x,r.mainPivot.y,r.mainPivot.z);const o=this._tmpAmmoVectorB;o.setValue(r.connectedPivot.x,r.connectedPivot.y,r.connectedPivot.z),s=new this.bjsAMMO.btPoint2PointConstraint(t,i,n,o);break}default:{L.Warn("JointType not currently supported by the Ammo plugin, falling back to PhysicsJoint.BallAndSocketJoint");const n=this._tmpAmmoVectorA;n.setValue(r.mainPivot.x,r.mainPivot.y,r.mainPivot.z);const o=this._tmpAmmoVectorB;o.setValue(r.connectedPivot.x,r.connectedPivot.y,r.connectedPivot.z),s=new this.bjsAMMO.btPoint2PointConstraint(t,i,n,o);break}}this.world.addConstraint(s,!e.joint.jointData.collision),e.joint.physicsJoint=s}removeJoint(e){this.world&&this.world.removeConstraint(e.joint.physicsJoint),this.bjsAMMO.destroy(e.joint.physicsJoint)}_addMeshVerts(e,t,i){let r=0;if(i&&i.getIndices&&i.getWorldMatrix&&i.getChildMeshes){let s=i.getIndices();s||(s=[]);let n=i.getVerticesData(N.PositionKind);n||(n=[]);let o;if(t&&t!==i){let u;t.rotationQuaternion?u=t.rotationQuaternion:t.rotation?u=re.FromEulerAngles(t.rotation.x,t.rotation.y,t.rotation.z):u=re.Identity(),$.Compose(m.One(),u,t.position).invertToRef(this._tmpMatrix),o=i.computeWorldMatrix(!1).multiply(this._tmpMatrix)}else $.ScalingToRef(i.scaling.x,i.scaling.y,i.scaling.z,this._tmpMatrix),o=this._tmpMatrix;const l=s.length/3;for(let u=0;u<l;u++){const c=[];for(let h=0;h<3;h++){let d=new m(n[s[u*3+h]*3+0],n[s[u*3+h]*3+1],n[s[u*3+h]*3+2]);d=m.TransformCoordinates(d,o);let f;h==0?f=this._tmpAmmoVectorA:h==1?f=this._tmpAmmoVectorB:f=this._tmpAmmoVectorC,f.setValue(d.x,d.y,d.z),c.push(f)}e.addTriangle(c[0],c[1],c[2]),r++}i.getChildMeshes().forEach(u=>{r+=this._addMeshVerts(e,t,u)})}return r}_softVertexData(e){const t=e.object;if(t&&t.getIndices&&t.getWorldMatrix&&t.getChildMeshes){t.getIndices();let i=t.getVerticesData(N.PositionKind);i||(i=[]);let r=t.getVerticesData(N.NormalKind);r||(r=[]),t.computeWorldMatrix(!1);const s=[],n=[];for(let l=0;l<i.length;l+=3){let u=new m(i[l],i[l+1],i[l+2]),c=new m(r[l],r[l+1],r[l+2]);u=m.TransformCoordinates(u,t.getWorldMatrix()),c=m.TransformNormal(c,t.getWorldMatrix()),s.push(u.x,u.y,u.z),n.push(c.x,c.y,c.z)}const o=new he;return o.positions=s,o.normals=n,o.uvs=t.getVerticesData(N.UVKind),o.colors=t.getVerticesData(N.ColorKind),t&&t.getIndices&&(o.indices=t.getIndices()),o.applyToMesh(t),t.position=m.Zero(),t.rotationQuaternion=null,t.rotation=m.Zero(),t.computeWorldMatrix(!0),o}return he.ExtractFromMesh(t)}_createSoftbody(e){const t=e.object;if(t&&t.getIndices){let i=t.getIndices();i||(i=[]);const r=this._softVertexData(e),s=r.positions,n=r.normals;if(s===null||n===null)return new this.bjsAMMO.btCompoundShape;{const o=[],l=[];for(let p=0;p<s.length;p+=3){const g=new m(s[p],s[p+1],s[p+2]),_=new m(n[p],n[p+1],n[p+2]);o.push(g.x,g.y,-g.z),l.push(_.x,_.y,-_.z)}const u=new this.bjsAMMO.btSoftBodyHelpers().CreateFromTriMesh(this.world.getWorldInfo(),o,t.getIndices(),i.length/3,!0),c=s.length/3,h=u.get_m_nodes();let d,f;for(let p=0;p<c;p++)d=h.at(p),f=d.get_m_n(),f.setX(l[3*p]),f.setY(l[3*p+1]),f.setZ(l[3*p+2]);return u}}}_createCloth(e){const t=e.object;if(t&&t.getIndices){t.getIndices();const i=this._softVertexData(e),r=i.positions,s=i.normals;if(r===null||s===null)return new this.bjsAMMO.btCompoundShape;{const n=r.length,o=Math.sqrt(n/3);e.segments=o;const l=o-1;return this._tmpAmmoVectorA.setValue(r[0],r[1],r[2]),this._tmpAmmoVectorB.setValue(r[3*l],r[3*l+1],r[3*l+2]),this._tmpAmmoVectorD.setValue(r[n-3],r[n-2],r[n-1]),this._tmpAmmoVectorC.setValue(r[n-3-3*l],r[n-2-3*l],r[n-1-3*l]),new this.bjsAMMO.btSoftBodyHelpers().CreatePatch(this.world.getWorldInfo(),this._tmpAmmoVectorA,this._tmpAmmoVectorB,this._tmpAmmoVectorC,this._tmpAmmoVectorD,o,o,e.getParam("fixedPoints"),!0)}}}_createRope(e){let t,i;const r=this._softVertexData(e),s=r.positions,n=r.normals;if(s===null||n===null)return new this.bjsAMMO.btCompoundShape;r.applyToMesh(e.object,!0),e._isFromLine=!0;const o=n.map(d=>d*d),l=(d,f)=>d+f;if(o.reduce(l)===0)t=s.length,i=t/3-1,this._tmpAmmoVectorA.setValue(s[0],s[1],s[2]),this._tmpAmmoVectorB.setValue(s[t-3],s[t-2],s[t-1]);else{e._isFromLine=!1;const d=e.getParam("path");if(e.getParam("shape")===null)return L.Warn("No shape available for extruded mesh"),new this.bjsAMMO.btCompoundShape;t=d.length,i=t-1,this._tmpAmmoVectorA.setValue(d[0].x,d[0].y,d[0].z),this._tmpAmmoVectorB.setValue(d[t-1].x,d[t-1].y,d[t-1].z)}e.segments=i;let c=e.getParam("fixedPoints");c=c>3?3:c;const h=new this.bjsAMMO.btSoftBodyHelpers().CreateRope(this.world.getWorldInfo(),this._tmpAmmoVectorA,this._tmpAmmoVectorB,i-1,c);return h.get_m_cfg().set_collisions(17),h}_createCustom(e){let t=null;return this.onCreateCustomShape&&(t=this.onCreateCustomShape(e)),t==null&&(t=new this.bjsAMMO.btCompoundShape),t}_addHullVerts(e,t,i){let r=0;if(i&&i.getIndices&&i.getWorldMatrix&&i.getChildMeshes){let s=i.getIndices();s||(s=[]);let n=i.getVerticesData(N.PositionKind);n||(n=[]),i.computeWorldMatrix(!1);const o=s.length/3;for(let l=0;l<o;l++){const u=[];for(let c=0;c<3;c++){let h=new m(n[s[l*3+c]*3+0],n[s[l*3+c]*3+1],n[s[l*3+c]*3+2]);$.ScalingToRef(i.scaling.x,i.scaling.y,i.scaling.z,this._tmpMatrix),h=m.TransformCoordinates(h,this._tmpMatrix);let d;c==0?d=this._tmpAmmoVectorA:c==1?d=this._tmpAmmoVectorB:d=this._tmpAmmoVectorC,d.setValue(h.x,h.y,h.z),u.push(d)}e.addPoint(u[0],!0),e.addPoint(u[1],!0),e.addPoint(u[2],!0),r++}i.getChildMeshes().forEach(l=>{r+=this._addHullVerts(e,t,l)})}return r}_createShape(e,t=!1){const i=e.object;let r;const s=e.getObjectExtents();if(!t){const n=e.object.getChildMeshes?e.object.getChildMeshes(!0):[];r=new this.bjsAMMO.btCompoundShape;let o=0;if(n.forEach(l=>{const u=l.getPhysicsImpostor();if(u){if(u.type==ve.MeshImpostor)throw"A child MeshImpostor is not supported. Only primitive impostors are supported as children (eg. box or sphere)";const c=this._createShape(u),h=l.parent.getWorldMatrix().clone(),d=new m;h.decompose(d),this._tmpAmmoTransform.getOrigin().setValue(l.position.x*d.x,l.position.y*d.y,l.position.z*d.z),this._tmpAmmoQuaternion.setValue(l.rotationQuaternion.x,l.rotationQuaternion.y,l.rotationQuaternion.z,l.rotationQuaternion.w),this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion),r.addChildShape(this._tmpAmmoTransform,c),u.dispose(),o++}}),o>0){if(e.type!=ve.NoImpostor){const l=this._createShape(e,!0);l&&(this._tmpAmmoTransform.getOrigin().setValue(0,0,0),this._tmpAmmoQuaternion.setValue(0,0,0,1),this._tmpAmmoTransform.setRotation(this._tmpAmmoQuaternion),r.addChildShape(this._tmpAmmoTransform,l))}return r}else this.bjsAMMO.destroy(r),r=null}switch(e.type){case ve.SphereImpostor:if(Fn(s.x,s.y,1e-4)&&Fn(s.x,s.z,1e-4))r=new this.bjsAMMO.btSphereShape(s.x/2);else{this._tmpAmmoVectorA.setValue(0,0,0);const n=[this._tmpAmmoVectorA],o=[1];r=new this.bjsAMMO.btMultiSphereShape(n,o,1),this._tmpAmmoVectorA.setValue(s.x/2,s.y/2,s.z/2),r.setLocalScaling(this._tmpAmmoVectorA)}break;case ve.CapsuleImpostor:{const n=s.x/2;r=new this.bjsAMMO.btCapsuleShape(n,s.y-n*2)}break;case ve.CylinderImpostor:this._tmpAmmoVectorA.setValue(s.x/2,s.y/2,s.z/2),r=new this.bjsAMMO.btCylinderShape(this._tmpAmmoVectorA);break;case ve.PlaneImpostor:case ve.BoxImpostor:this._tmpAmmoVectorA.setValue(s.x/2,s.y/2,s.z/2),r=new this.bjsAMMO.btBoxShape(this._tmpAmmoVectorA);break;case ve.MeshImpostor:if(e.getParam("mass")==0){if(this.onCreateCustomMeshImpostor)r=this.onCreateCustomMeshImpostor(e);else{const n=new this.bjsAMMO.btTriangleMesh;e._pluginData.toDispose.push(n),this._addMeshVerts(n,i,i)==0?r=new this.bjsAMMO.btCompoundShape:r=new this.bjsAMMO.btBvhTriangleMeshShape(n)}break}case ve.ConvexHullImpostor:{if(this.onCreateCustomConvexHullImpostor)r=this.onCreateCustomConvexHullImpostor(e);else{const n=new this.bjsAMMO.btConvexHullShape;this._addHullVerts(n,i,i)==0?(e._pluginData.toDispose.push(n),r=new this.bjsAMMO.btCompoundShape):r=n}break}case ve.NoImpostor:r=new this.bjsAMMO.btSphereShape(s.x/2);break;case ve.CustomImpostor:r=this._createCustom(e);break;case ve.SoftbodyImpostor:r=this._createSoftbody(e);break;case ve.ClothImpostor:r=this._createCloth(e);break;case ve.RopeImpostor:r=this._createRope(e);break;default:L.Warn("The impostor type is not currently supported by the ammo plugin.");break}return r}setTransformationFromPhysicsBody(e){e.physicsBody.getMotionState().getWorldTransform(this._tmpAmmoTransform),e.object.position.set(this._tmpAmmoTransform.getOrigin().x(),this._tmpAmmoTransform.getOrigin().y(),this._tmpAmmoTransform.getOrigin().z()),e.object.rotationQuaternion?e.object.rotationQuaternion.set(this._tmpAmmoTransform.getRotation().x(),this._tmpAmmoTransform.getRotation().y(),this._tmpAmmoTransform.getRotation().z(),this._tmpAmmoTransform.getRotation().w()):e.object.rotation&&(this._tmpQuaternion.set(this._tmpAmmoTransform.getRotation().x(),this._tmpAmmoTransform.getRotation().y(),this._tmpAmmoTransform.getRotation().z(),this._tmpAmmoTransform.getRotation().w()),this._tmpQuaternion.toEulerAnglesToRef(e.object.rotation))}setPhysicsBodyTransformation(e,t,i){const r=e.physicsBody.getWorldTransform();if(Math.abs(r.getOrigin().x()-t.x)>He||Math.abs(r.getOrigin().y()-t.y)>He||Math.abs(r.getOrigin().z()-t.z)>He||Math.abs(r.getRotation().x()-i.x)>He||Math.abs(r.getRotation().y()-i.y)>He||Math.abs(r.getRotation().z()-i.z)>He||Math.abs(r.getRotation().w()-i.w)>He)if(this._tmpAmmoVectorA.setValue(t.x,t.y,t.z),r.setOrigin(this._tmpAmmoVectorA),this._tmpAmmoQuaternion.setValue(i.x,i.y,i.z,i.w),r.setRotation(this._tmpAmmoQuaternion),e.physicsBody.setWorldTransform(r),e.mass==0){const s=e.physicsBody.getMotionState();s&&s.setWorldTransform(r)}else e.physicsBody.activate()}isSupported(){return this.bjsAMMO!==void 0}setLinearVelocity(e,t){this._tmpAmmoVectorA.setValue(t.x,t.y,t.z),e.soft?e.physicsBody.linearVelocity(this._tmpAmmoVectorA):e.physicsBody.setLinearVelocity(this._tmpAmmoVectorA)}setAngularVelocity(e,t){this._tmpAmmoVectorA.setValue(t.x,t.y,t.z),e.soft?e.physicsBody.angularVelocity(this._tmpAmmoVectorA):e.physicsBody.setAngularVelocity(this._tmpAmmoVectorA)}getLinearVelocity(e){let t;if(e.soft?t=e.physicsBody.linearVelocity():t=e.physicsBody.getLinearVelocity(),!t)return null;const i=new m(t.x(),t.y(),t.z());return this.bjsAMMO.destroy(t),i}getAngularVelocity(e){let t;if(e.soft?t=e.physicsBody.angularVelocity():t=e.physicsBody.getAngularVelocity(),!t)return null;const i=new m(t.x(),t.y(),t.z());return this.bjsAMMO.destroy(t),i}setBodyMass(e,t){e.soft?e.physicsBody.setTotalMass(t,!1):e.physicsBody.setMassProps(t),e._pluginData.mass=t}getBodyMass(e){return e._pluginData.mass||0}getBodyFriction(e){return e._pluginData.friction||0}setBodyFriction(e,t){e.soft?e.physicsBody.get_m_cfg().set_kDF(t):e.physicsBody.setFriction(t),e._pluginData.friction=t}getBodyRestitution(e){return e._pluginData.restitution||0}setBodyRestitution(e,t){e.physicsBody.setRestitution(t),e._pluginData.restitution=t}getBodyPressure(e){return e.soft?e._pluginData.pressure||0:(L.Warn("Pressure is not a property of a rigid body"),0)}setBodyPressure(e,t){e.soft?e.type===ve.SoftbodyImpostor?(e.physicsBody.get_m_cfg().set_kPR(t),e._pluginData.pressure=t):(e.physicsBody.get_m_cfg().set_kPR(0),e._pluginData.pressure=0):L.Warn("Pressure can only be applied to a softbody")}getBodyStiffness(e){return e.soft?e._pluginData.stiffness||0:(L.Warn("Stiffness is not a property of a rigid body"),0)}setBodyStiffness(e,t){e.soft?(t=t<0?0:t,t=t>1?1:t,e.physicsBody.get_m_materials().at(0).set_m_kLST(t),e._pluginData.stiffness=t):L.Warn("Stiffness cannot be applied to a rigid body")}getBodyVelocityIterations(e){return e.soft?e._pluginData.velocityIterations||0:(L.Warn("Velocity iterations is not a property of a rigid body"),0)}setBodyVelocityIterations(e,t){e.soft?(t=t<0?0:t,e.physicsBody.get_m_cfg().set_viterations(t),e._pluginData.velocityIterations=t):L.Warn("Velocity iterations cannot be applied to a rigid body")}getBodyPositionIterations(e){return e.soft?e._pluginData.positionIterations||0:(L.Warn("Position iterations is not a property of a rigid body"),0)}setBodyPositionIterations(e,t){e.soft?(t=t<0?0:t,e.physicsBody.get_m_cfg().set_piterations(t),e._pluginData.positionIterations=t):L.Warn("Position iterations cannot be applied to a rigid body")}appendAnchor(e,t,i,r,s=1,n=!1){const o=e.segments,l=Math.round((o-1)*i),u=Math.round((o-1)*r),c=o-1-u,h=l+o*c;e.physicsBody.appendAnchor(h,t.physicsBody,n,s)}appendHook(e,t,i,r=1,s=!1){const n=Math.round(e.segments*i);e.physicsBody.appendAnchor(n,t.physicsBody,s,r)}sleepBody(e){e.physicsBody.forceActivationState(0)}wakeUpBody(e){e.physicsBody.activate()}updateDistanceJoint(){L.Warn("updateDistanceJoint is not currently supported by the Ammo physics plugin")}setMotor(e,t,i){e.physicsJoint.enableAngularMotor(!0,t,i)}setLimit(){L.Warn("setLimit is not currently supported by the Ammo physics plugin")}syncMeshWithImpostor(e,t){t.physicsBody.getMotionState().getWorldTransform(this._tmpAmmoTransform),e.position.x=this._tmpAmmoTransform.getOrigin().x(),e.position.y=this._tmpAmmoTransform.getOrigin().y(),e.position.z=this._tmpAmmoTransform.getOrigin().z(),e.rotationQuaternion&&(e.rotationQuaternion.x=this._tmpAmmoTransform.getRotation().x(),e.rotationQuaternion.y=this._tmpAmmoTransform.getRotation().y(),e.rotationQuaternion.z=this._tmpAmmoTransform.getRotation().z(),e.rotationQuaternion.w=this._tmpAmmoTransform.getRotation().w())}getRadius(e){return e.getObjectExtents().x/2}getBoxSizeToRef(e,t){const i=e.getObjectExtents();t.x=i.x,t.y=i.y,t.z=i.z}dispose(){this.bjsAMMO.destroy(this.world),this.bjsAMMO.destroy(this._softBodySolver),this.bjsAMMO.destroy(this._solver),this.bjsAMMO.destroy(this._overlappingPairCache),this.bjsAMMO.destroy(this._dispatcher),this.bjsAMMO.destroy(this._collisionConfiguration),this.bjsAMMO.destroy(this._tmpAmmoVectorA),this.bjsAMMO.destroy(this._tmpAmmoVectorB),this.bjsAMMO.destroy(this._tmpAmmoVectorC),this.bjsAMMO.destroy(this._tmpAmmoVectorD),this.bjsAMMO.destroy(this._tmpAmmoTransform),this.bjsAMMO.destroy(this._tmpAmmoQuaternion),this.bjsAMMO.destroy(this._tmpAmmoConcreteContactResultCallback),this.world=null}raycast(e,t){return this.raycastToRef(e,t,this._raycastResult),this._raycastResult}raycastToRef(e,t,i){this._tmpAmmoVectorRCA=new this.bjsAMMO.btVector3(e.x,e.y,e.z),this._tmpAmmoVectorRCB=new this.bjsAMMO.btVector3(t.x,t.y,t.z);const r=new this.bjsAMMO.ClosestRayResultCallback(this._tmpAmmoVectorRCA,this._tmpAmmoVectorRCB);this.world.rayTest(this._tmpAmmoVectorRCA,this._tmpAmmoVectorRCB,r),i.reset(e,t),r.hasHit()&&(i.setHitData({x:r.get_m_hitNormalWorld().x(),y:r.get_m_hitNormalWorld().y(),z:r.get_m_hitNormalWorld().z()},{x:r.get_m_hitPointWorld().x(),y:r.get_m_hitPointWorld().y(),z:r.get_m_hitPointWorld().z()}),i.calculateHitDistance()),this.bjsAMMO.destroy(r),this.bjsAMMO.destroy(this._tmpAmmoVectorRCA),this.bjsAMMO.destroy(this._tmpAmmoVectorRCB)}}is._DISABLE_COLLISION_FLAG=4;is._KINEMATIC_FLAG=2;is._DISABLE_DEACTIVATION_FLAG=4;Te.prototype.removeReflectionProbe=function(a){if(!this.reflectionProbes)return-1;const e=this.reflectionProbes.indexOf(a);return e!==-1&&this.reflectionProbes.splice(e,1),e};Te.prototype.addReflectionProbe=function(a){this.reflectionProbes||(this.reflectionProbes=[]),this.reflectionProbes.push(a)};class cl{constructor(e,t,i,r=!0,s=!1,n=!1){if(this.name=e,this._viewMatrix=$.Identity(),this._target=m.Zero(),this._add=m.Zero(),this._invertYAxis=!1,this.position=m.Zero(),this.metadata=null,this._parentContainer=null,this._scene=i,i.getEngine().supportsUniformBuffers){this._sceneUBOs=[];for(let c=0;c<6;++c)this._sceneUBOs.push(i.createSceneUniformBuffer(`Scene for Reflection Probe (name "${e}") face #${c}`))}this._scene.reflectionProbes||(this._scene.reflectionProbes=[]),this._scene.reflectionProbes.push(this);let o=0;if(s){const c=this._scene.getEngine().getCaps();c.textureHalfFloatRender?o=2:c.textureFloatRender&&(o=1)}this._renderTargetTexture=new Kt(e,t,i,r,!0,o,!0),this._renderTargetTexture.gammaSpace=!n,this._renderTargetTexture.invertZ=i.useRightHandedSystem;const l=i.getEngine().useReverseDepthBuffer;this._renderTargetTexture.onBeforeRenderObservable.add(c=>{switch(this._sceneUBOs&&(i.setSceneUniformBuffer(this._sceneUBOs[c]),i.getSceneUniformBuffer().unbindEffect()),c){case 0:this._add.copyFromFloats(1,0,0);break;case 1:this._add.copyFromFloats(-1,0,0);break;case 2:this._add.copyFromFloats(0,this._invertYAxis?1:-1,0);break;case 3:this._add.copyFromFloats(0,this._invertYAxis?-1:1,0);break;case 4:this._add.copyFromFloats(0,0,i.useRightHandedSystem?-1:1);break;case 5:this._add.copyFromFloats(0,0,i.useRightHandedSystem?1:-1);break}this._attachedMesh&&this.position.copyFrom(this._attachedMesh.getAbsolutePosition()),this.position.addToRef(this._add,this._target);const h=i.useRightHandedSystem?$.LookAtRHToRef:$.LookAtLHToRef,d=i.useRightHandedSystem?$.PerspectiveFovRH:$.PerspectiveFovLH;h(this.position,this._target,m.Up(),this._viewMatrix),i.activeCamera&&(this._projectionMatrix=d(Math.PI/2,1,l?i.activeCamera.maxZ:i.activeCamera.minZ,l?i.activeCamera.minZ:i.activeCamera.maxZ,this._scene.getEngine().isNDCHalfZRange),i.setTransformMatrix(this._viewMatrix,this._projectionMatrix),i.activeCamera.isRigCamera&&!this._renderTargetTexture.activeCamera&&(this._renderTargetTexture.activeCamera=i.activeCamera.rigParent||null)),i._forcedViewPosition=this.position});let u;this._renderTargetTexture.onBeforeBindObservable.add(()=>{var c,h;this._currentSceneUBO=i.getSceneUniformBuffer(),(h=(c=i.getEngine())._debugPushGroup)==null||h.call(c,`reflection probe generation for ${e}`,1),u=this._scene.imageProcessingConfiguration.applyByPostProcess,n&&(i.imageProcessingConfiguration.applyByPostProcess=!0)}),this._renderTargetTexture.onAfterUnbindObservable.add(()=>{var c,h;i.imageProcessingConfiguration.applyByPostProcess=u,i._forcedViewPosition=null,this._sceneUBOs&&i.setSceneUniformBuffer(this._currentSceneUBO),i.updateTransformMatrix(!0),(h=(c=i.getEngine())._debugPopGroup)==null||h.call(c,1)})}get samples(){return this._renderTargetTexture.samples}set samples(e){this._renderTargetTexture.samples=e}get refreshRate(){return this._renderTargetTexture.refreshRate}set refreshRate(e){this._renderTargetTexture.refreshRate=e}getScene(){return this._scene}get cubeTexture(){return this._renderTargetTexture}get renderList(){return this._renderTargetTexture.renderList}set renderList(e){this._renderTargetTexture.renderList=e}attachToMesh(e){this._attachedMesh=e}setRenderingAutoClearDepthStencil(e,t){this._renderTargetTexture.setRenderingAutoClearDepthStencil(e,t)}dispose(){const e=this._scene.reflectionProbes.indexOf(this);if(e!==-1&&this._scene.reflectionProbes.splice(e,1),this._parentContainer){const t=this._parentContainer.reflectionProbes.indexOf(this);t>-1&&this._parentContainer.reflectionProbes.splice(t,1),this._parentContainer=null}if(this._renderTargetTexture&&(this._renderTargetTexture.dispose(),this._renderTargetTexture=null),this._sceneUBOs){for(const t of this._sceneUBOs)t.dispose();this._sceneUBOs=[]}}toString(e){let t="Name: "+this.name;return e&&(t+=", position: "+this.position.toString(),this._attachedMesh&&(t+=", attached mesh: "+this._attachedMesh.name)),t}getClassName(){return"ReflectionProbe"}serialize(){const e=Me.Serialize(this,this._renderTargetTexture.serialize());return e.isReflectionProbe=!0,e.metadata=this.metadata,e}static Parse(e,t,i){let r=null;if(t.reflectionProbes)for(let s=0;s<t.reflectionProbes.length;s++){const n=t.reflectionProbes[s];if(n.name===e.name){r=n;break}}return r=Me.Parse(()=>r||new cl(e.name,e.renderTargetSize,t,e._generateMipMaps),e,t,i),r.cubeTexture._waitingRenderList=e.renderList,e._attachedMesh&&r.attachToMesh(t.getMeshById(e._attachedMesh)),e.metadata&&(r.metadata=e.metadata),r}}C([cu()],cl.prototype,"_attachedMesh",void 0);C([Hn()],cl.prototype,"position",void 0);class RN{get animationStarted(){return this._animationStarted}get fromIndex(){return this._fromIndex}get toIndex(){return this._toIndex}get loopAnimation(){return this._loopAnimation}get delay(){return Math.max(this._delay,1)}constructor(){this.width=1,this.height=1,this.angle=0,this.invertU=!1,this.invertV=!1,this.isVisible=!0,this._animationStarted=!1,this._loopAnimation=!1,this._fromIndex=0,this._toIndex=0,this._delay=0,this._direction=1,this._time=0,this._onBaseAnimationEnd=null,this.position={x:1,y:1,z:1},this.color={r:1,g:1,b:1,a:1}}playAnimation(e,t,i,r,s){this._fromIndex=e,this._toIndex=t,this._loopAnimation=i,this._delay=r||1,this._animationStarted=!0,this._onBaseAnimationEnd=s,e<t?this._direction=1:(this._direction=-1,this._toIndex=e,this._fromIndex=t),this.cellIndex=e,this._time=0}stopAnimation(){this._animationStarted=!1}_animate(e){this._animationStarted&&(this._time+=e,this._time>this._delay&&(this._time=this._time%this._delay,this.cellIndex+=this._direction,(this._direction>0&&this.cellIndex>this._toIndex||this._direction<0&&this.cellIndex<this._fromIndex)&&(this._loopAnimation?this.cellIndex=this._direction>0?this._fromIndex:this._toIndex:(this.cellIndex=this._toIndex,this._animationStarted=!1,this._onBaseAnimationEnd&&this._onBaseAnimationEnd()))))}}class k_ extends RN{get size(){return this.width}set size(e){this.width=e,this.height=e}get manager(){return this._manager}constructor(e,t){super(),this.name=e,this.animations=new Array,this.isPickable=!1,this.useAlphaForPicking=!1,this.onDisposeObservable=new j,this._onAnimationEnd=null,this._endAnimation=()=>{this._onAnimationEnd&&this._onAnimationEnd(),this.disposeWhenFinishedAnimating&&this.dispose()},this.color=new xe(1,1,1,1),this.position=m.Zero(),this._manager=t,this._manager.sprites.push(this),this.uniqueId=this._manager.scene.getUniqueId()}getClassName(){return"Sprite"}get fromIndex(){return this._fromIndex}set fromIndex(e){this.playAnimation(e,this._toIndex,this._loopAnimation,this._delay,this._onAnimationEnd)}get toIndex(){return this._toIndex}set toIndex(e){this.playAnimation(this._fromIndex,e,this._loopAnimation,this._delay,this._onAnimationEnd)}get loopAnimation(){return this._loopAnimation}set loopAnimation(e){this.playAnimation(this._fromIndex,this._toIndex,e,this._delay,this._onAnimationEnd)}get delay(){return Math.max(this._delay,1)}set delay(e){this.playAnimation(this._fromIndex,this._toIndex,this._loopAnimation,e,this._onAnimationEnd)}playAnimation(e,t,i,r,s=null){this._onAnimationEnd=s,super.playAnimation(e,t,i,r,this._endAnimation)}dispose(){for(let e=0;e<this._manager.sprites.length;e++)this._manager.sprites[e]==this&&this._manager.sprites.splice(e,1);this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear()}serialize(){const e={};return e.name=this.name,e.position=this.position.asArray(),e.color=this.color.asArray(),e.width=this.width,e.height=this.height,e.angle=this.angle,e.cellIndex=this.cellIndex,e.cellRef=this.cellRef,e.invertU=this.invertU,e.invertV=this.invertV,e.disposeWhenFinishedAnimating=this.disposeWhenFinishedAnimating,e.isPickable=this.isPickable,e.isVisible=this.isVisible,e.useAlphaForPicking=this.useAlphaForPicking,e.animationStarted=this.animationStarted,e.fromIndex=this.fromIndex,e.toIndex=this.toIndex,e.loopAnimation=this.loopAnimation,e.delay=this.delay,e}static Parse(e,t){const i=new k_(e.name,t);return i.position=m.FromArray(e.position),i.color=xe.FromArray(e.color),i.width=e.width,i.height=e.height,i.angle=e.angle,i.cellIndex=e.cellIndex,i.cellRef=e.cellRef,i.invertU=e.invertU,i.invertV=e.invertV,i.disposeWhenFinishedAnimating=e.disposeWhenFinishedAnimating,i.isPickable=e.isPickable,i.isVisible=e.isVisible,i.useAlphaForPicking=e.useAlphaForPicking,i._fromIndex=e.fromIndex,i._toIndex=e.toIndex,i._loopAnimation=e.loopAnimation,i._delay=e.delay,e.animationStarted&&i.playAnimation(i.fromIndex,i.toIndex,i.loopAnimation,i.delay),i}}Te.prototype._internalPickSprites=function(a,e,t,i){if(!Qi)return null;let r=null;if(!i){if(!this.activeCamera)return null;i=this.activeCamera}if(this.spriteManagers&&this.spriteManagers.length>0)for(let s=0;s<this.spriteManagers.length;s++){const n=this.spriteManagers[s];if(!n.isPickable)continue;const o=n.intersects(a,i,e,t);if(!(!o||!o.hit)&&!(!t&&r!=null&&o.distance>=r.distance)&&(r=o,t))break}return r||new Qi};Te.prototype._internalMultiPickSprites=function(a,e,t){if(!Qi)return null;let i=[];if(!t){if(!this.activeCamera)return null;t=this.activeCamera}if(this.spriteManagers&&this.spriteManagers.length>0)for(let r=0;r<this.spriteManagers.length;r++){const s=this.spriteManagers[r];if(!s.isPickable)continue;const n=s.multiIntersects(a,t,e);n!==null&&(i=i.concat(n))}return i};Te.prototype.pickSprite=function(a,e,t,i,r){if(!this._tempSpritePickingRay)return null;Sy(this,a,e,this._tempSpritePickingRay,r);const s=this._internalPickSprites(this._tempSpritePickingRay,t,i,r);return s&&(s.ray=hM(this,a,e,r)),s};Te.prototype.pickSpriteWithRay=function(a,e,t,i){if(!this._tempSpritePickingRay)return null;if(!i){if(!this.activeCamera)return null;i=this.activeCamera}Zt.TransformToRef(a,i.getViewMatrix(),this._tempSpritePickingRay);const r=this._internalPickSprites(this._tempSpritePickingRay,e,t,i);return r&&(r.ray=a),r};Te.prototype.multiPickSprite=function(a,e,t,i){return Sy(this,a,e,this._tempSpritePickingRay,i),this._internalMultiPickSprites(this._tempSpritePickingRay,t,i)};Te.prototype.multiPickSpriteWithRay=function(a,e,t){if(!this._tempSpritePickingRay)return null;if(!t){if(!this.activeCamera)return null;t=this.activeCamera}return Zt.TransformToRef(a,t.getViewMatrix(),this._tempSpritePickingRay),this._internalMultiPickSprites(this._tempSpritePickingRay,e,t)};Te.prototype.setPointerOverSprite=function(a){this._pointerOverSprite!==a&&(this._pointerOverSprite&&this._pointerOverSprite.actionManager&&this._pointerOverSprite.actionManager.processTrigger(10,jr.CreateNewFromSprite(this._pointerOverSprite,this)),this._pointerOverSprite=a,this._pointerOverSprite&&this._pointerOverSprite.actionManager&&this._pointerOverSprite.actionManager.processTrigger(9,jr.CreateNewFromSprite(this._pointerOverSprite,this)))};Te.prototype.getPointerOverSprite=function(){return this._pointerOverSprite};class MN{constructor(e){this.name=ge.NAME_SPRITE,this.scene=e,this.scene.spriteManagers=[],this.scene._tempSpritePickingRay=Zt?Zt.Zero():null,this.scene.onBeforeSpritesRenderingObservable=new j,this.scene.onAfterSpritesRenderingObservable=new j,this._spritePredicate=t=>t.actionManager?t.isPickable&&t.actionManager.hasPointerTriggers:!1}register(){this.scene._pointerMoveStage.registerStep(ge.STEP_POINTERMOVE_SPRITE,this,this._pointerMove),this.scene._pointerDownStage.registerStep(ge.STEP_POINTERDOWN_SPRITE,this,this._pointerDown),this.scene._pointerUpStage.registerStep(ge.STEP_POINTERUP_SPRITE,this,this._pointerUp)}rebuild(){}dispose(){this.scene.onBeforeSpritesRenderingObservable.clear(),this.scene.onAfterSpritesRenderingObservable.clear();const e=this.scene.spriteManagers;if(e)for(;e.length;)e[0].dispose()}_pickSpriteButKeepRay(e,t,i,r,s){const n=this.scene.pickSprite(t,i,this._spritePredicate,r,s);return n&&(n.ray=e?e.ray:null),n}_pointerMove(e,t,i,r,s){const n=this.scene;return r?n.setPointerOverSprite(null):(i=this._pickSpriteButKeepRay(i,e,t,!1,n.cameraToUseForPointers||void 0),i&&i.hit&&i.pickedSprite?(n.setPointerOverSprite(i.pickedSprite),!n.doNotHandleCursors&&s&&(n._pointerOverSprite&&n._pointerOverSprite.actionManager&&n._pointerOverSprite.actionManager.hoverCursor?s.style.cursor=n._pointerOverSprite.actionManager.hoverCursor:s.style.cursor=n.hoverCursor)):n.setPointerOverSprite(null)),i}_pointerDown(e,t,i,r){const s=this.scene;if(s._pickedDownSprite=null,s.spriteManagers&&s.spriteManagers.length>0&&(i=s.pickSprite(e,t,this._spritePredicate,!1,s.cameraToUseForPointers||void 0),i&&i.hit&&i.pickedSprite&&i.pickedSprite.actionManager)){switch(s._pickedDownSprite=i.pickedSprite,r.button){case 0:i.pickedSprite.actionManager.processTrigger(2,jr.CreateNewFromSprite(i.pickedSprite,s,r));break;case 1:i.pickedSprite.actionManager.processTrigger(4,jr.CreateNewFromSprite(i.pickedSprite,s,r));break;case 2:i.pickedSprite.actionManager.processTrigger(3,jr.CreateNewFromSprite(i.pickedSprite,s,r));break}i.pickedSprite.actionManager&&i.pickedSprite.actionManager.processTrigger(5,jr.CreateNewFromSprite(i.pickedSprite,s,r))}return i}_pointerUp(e,t,i,r,s){const n=this.scene;if(n.spriteManagers&&n.spriteManagers.length>0){const o=n.pickSprite(e,t,this._spritePredicate,!1,n.cameraToUseForPointers||void 0);o&&(o.hit&&o.pickedSprite&&o.pickedSprite.actionManager&&(o.pickedSprite.actionManager.processTrigger(7,jr.CreateNewFromSprite(o.pickedSprite,n,r)),o.pickedSprite.actionManager&&(this.scene._inputManager._isPointerSwiping()||o.pickedSprite.actionManager.processTrigger(1,jr.CreateNewFromSprite(o.pickedSprite,n,r)),s&&o.pickedSprite.actionManager.processTrigger(6,jr.CreateNewFromSprite(o.pickedSprite,n,r)))),n._pickedDownSprite&&n._pickedDownSprite.actionManager&&n._pickedDownSprite!==o.pickedSprite&&n._pickedDownSprite.actionManager.processTrigger(16,jr.CreateNewFromSprite(n._pickedDownSprite,n,r)))}return i}}class Ku{get fogEnabled(){return this._fogEnabled}set fogEnabled(e){this._fogEnabled!==e&&(this._fogEnabled=e,this._createEffects())}get useLogarithmicDepth(){return this._useLogarithmicDepth}set useLogarithmicDepth(e){var i;const t=!!((i=this._scene)!=null&&i.getEngine().getCaps().fragmentDepthSupported);e&&!t&&L.Warn("Logarithmic depth has been requested for a sprite renderer on a device that doesn't support it."),this._useLogarithmicDepth=e&&t,this._createEffects()}get capacity(){return this._capacity}get pixelPerfect(){return this._pixelPerfect}set pixelPerfect(e){this._pixelPerfect!==e&&(this._pixelPerfect=e,this._createEffects())}get shaderLanguage(){return this._shaderLanguage}constructor(e,t,i=.01,r=null,s){this.blendMode=2,this.autoResetAlpha=!0,this.disableDepthWrite=!1,this._fogEnabled=!0,this._pixelPerfect=!1,this._shaderLanguage=0,this._useVAO=!1,this._useInstancing=!1,this._vertexBuffers={},this._isDisposed=!1,this._shadersLoaded=!1,this._pixelPerfect=(s==null?void 0:s.pixelPerfect)??!1,this._capacity=t,this._epsilon=i,this._engine=e,this._useInstancing=e.getCaps().instancedArrays&&e._features.supportSpriteInstancing,this._useVAO=e.getCaps().vertexArrayObject&&!e.disableVertexArrayObjects,this._scene=r,this._useInstancing||this._buildIndexBuffer(),this._vertexBufferSize=this._useInstancing?16:18,this._vertexData=new Float32Array(t*this._vertexBufferSize*(this._useInstancing?1:4)),this._buffer=new fi(e,this._vertexData,!0,this._vertexBufferSize);const n=this._buffer.createVertexBuffer(N.PositionKind,0,4,this._vertexBufferSize,this._useInstancing),o=this._buffer.createVertexBuffer("options",4,2,this._vertexBufferSize,this._useInstancing);let l=6,u;if(this._useInstancing){const f=new Float32Array([this._epsilon,this._epsilon,1-this._epsilon,this._epsilon,this._epsilon,1-this._epsilon,1-this._epsilon,1-this._epsilon]);this._spriteBuffer=new fi(e,f,!1,2),u=this._spriteBuffer.createVertexBuffer("offsets",0,2)}else u=this._buffer.createVertexBuffer("offsets",l,2,this._vertexBufferSize,this._useInstancing),l+=2;const c=this._buffer.createVertexBuffer("inverts",l,2,this._vertexBufferSize,this._useInstancing),h=this._buffer.createVertexBuffer("cellInfo",l+2,4,this._vertexBufferSize,this._useInstancing),d=this._buffer.createVertexBuffer(N.ColorKind,l+6,4,this._vertexBufferSize,this._useInstancing);this._vertexBuffers[N.PositionKind]=n,this._vertexBuffers.options=o,this._vertexBuffers.offsets=u,this._vertexBuffers.inverts=c,this._vertexBuffers.cellInfo=h,this._vertexBuffers[N.ColorKind]=d,this._initShaderSourceAsync()}async _initShaderSourceAsync(){this._engine.isWebGPU&&!Ku.ForceGLSL?(this._shaderLanguage=1,await Promise.all([k(()=>Promise.resolve().then(()=>n4),void 0),k(()=>Promise.resolve().then(()=>r4),void 0)])):await Promise.all([k(()=>Promise.resolve().then(()=>e4),void 0),k(()=>Promise.resolve().then(()=>KG),void 0)]),this._shadersLoaded=!0,this._createEffects()}_createEffects(){var t,i;if(this._isDisposed||!this._shadersLoaded)return;(t=this._drawWrapperBase)==null||t.dispose(),(i=this._drawWrapperDepth)==null||i.dispose(),this._drawWrapperBase=new vi(this._engine),this._drawWrapperDepth=new vi(this._engine,!1),this._drawWrapperBase.drawContext&&(this._drawWrapperBase.drawContext.useInstancing=this._useInstancing),this._drawWrapperDepth.drawContext&&(this._drawWrapperDepth.drawContext.useInstancing=this._useInstancing);let e="";this._pixelPerfect&&(e+=`#define PIXEL_PERFECT
`),this._scene&&this._scene.fogEnabled&&this._scene.fogMode!==0&&this._fogEnabled&&(e+=`#define FOG
`),this._useLogarithmicDepth&&(e+=`#define LOGARITHMICDEPTH
`),this._drawWrapperBase.effect=this._engine.createEffect("sprites",[N.PositionKind,"options","offsets","inverts","cellInfo",N.ColorKind],["view","projection","textureInfos","alphaTest","vFogInfos","vFogColor","logarithmicDepthConstant"],["diffuseSampler"],e,void 0,void 0,void 0,void 0,this._shaderLanguage),this._drawWrapperDepth.effect=this._drawWrapperBase.effect,this._drawWrapperBase.effect._refCount++,this._drawWrapperDepth.materialContext=this._drawWrapperBase.materialContext}render(e,t,i,r,s=null){if(!this._shadersLoaded||!this.texture||!this.texture.isReady()||!e.length)return;const n=this._drawWrapperBase,o=this._drawWrapperDepth,l=this.fogEnabled&&this._scene&&this._scene.fogEnabled&&this._scene.fogMode!==0,u=n.effect;if(!u.isReady())return;const c=this._engine,h=!!(this._scene&&this._scene.useRightHandedSystem),d=Math.min(this._capacity,e.length);let f=0,p=!0;for(let b=0;b<d;b++){const y=e[b];if(!y||!y.isVisible)continue;p=!1,y._animate(t);const T=this.texture.getBaseSize();this._appendSpriteVertex(f++,y,0,0,T,h,s),this._useInstancing||(this._appendSpriteVertex(f++,y,1,0,T,h,s),this._appendSpriteVertex(f++,y,1,1,T,h,s),this._appendSpriteVertex(f++,y,0,1,T,h,s))}if(p)return;this._buffer.update(this._vertexData);const g=!!c.depthCullingState.cull,_=c.depthCullingState.zOffset,S=c.depthCullingState.zOffsetUnits;if(c.setState(g,_,!1,!1,void 0,void 0,S),c.enableEffect(n),u.setTexture("diffuseSampler",this.texture),u.setMatrix("view",i),u.setMatrix("projection",r),l){const b=this._scene;u.setFloat4("vFogInfos",b.fogMode,b.fogStart,b.fogEnd,b.fogDensity),u.setColor3("vFogColor",b.fogColor)}this.useLogarithmicDepth&&this._scene&&qa(n.defines,u,this._scene),this._useVAO?(this._vertexArrayObject||(this._vertexArrayObject=c.recordVertexArrayObject(this._vertexBuffers,this._indexBuffer,u)),c.bindVertexArrayObject(this._vertexArrayObject,this._indexBuffer)):c.bindBuffers(this._vertexBuffers,this._indexBuffer,u),c.depthCullingState.depthFunc=c.useReverseDepthBuffer?518:515,this.disableDepthWrite||(u.setBool("alphaTest",!0),c.setColorWrite(!1),c.enableEffect(o),this._useInstancing?c.drawArraysType(7,0,4,f):c.drawElementsType(0,0,f/4*6),c.enableEffect(n),c.setColorWrite(!0),u.setBool("alphaTest",!1)),c.setAlphaMode(this.blendMode),this._useInstancing?c.drawArraysType(7,0,4,f):c.drawElementsType(0,0,f/4*6),this.autoResetAlpha&&c.setAlphaMode(0),h&&this._scene.getEngine().setState(g,_,!1,!0,void 0,void 0,S),c.unbindInstanceAttributes()}_appendSpriteVertex(e,t,i,r,s,n,o){let l=e*this._vertexBufferSize;if(i===0?i=this._epsilon:i===1&&(i=1-this._epsilon),r===0?r=this._epsilon:r===1&&(r=1-this._epsilon),o)o(t,s);else{t.cellIndex||(t.cellIndex=0);const u=s.width/this.cellWidth,c=t.cellIndex/u>>0;t._xOffset=(t.cellIndex-c*u)*this.cellWidth/s.width,t._yOffset=c*this.cellHeight/s.height,t._xSize=this.cellWidth,t._ySize=this.cellHeight}this._vertexData[l]=t.position.x,this._vertexData[l+1]=t.position.y,this._vertexData[l+2]=t.position.z,this._vertexData[l+3]=t.angle,this._vertexData[l+4]=t.width,this._vertexData[l+5]=t.height,this._useInstancing?l-=2:(this._vertexData[l+6]=i,this._vertexData[l+7]=r),n?this._vertexData[l+8]=t.invertU?0:1:this._vertexData[l+8]=t.invertU?1:0,this._vertexData[l+9]=t.invertV?1:0,this._vertexData[l+10]=t._xOffset,this._vertexData[l+11]=t._yOffset,this._vertexData[l+12]=t._xSize/s.width,this._vertexData[l+13]=t._ySize/s.height,this._vertexData[l+14]=t.color.r,this._vertexData[l+15]=t.color.g,this._vertexData[l+16]=t.color.b,this._vertexData[l+17]=t.color.a}_buildIndexBuffer(){const e=[];let t=0;for(let i=0;i<this._capacity;i++)e.push(t),e.push(t+1),e.push(t+2),e.push(t),e.push(t+2),e.push(t+3),t+=4;this._indexBuffer=this._engine.createIndexBuffer(e)}rebuild(){var e;this._indexBuffer&&this._buildIndexBuffer(),this._useVAO&&(this._vertexArrayObject=void 0),this._buffer._rebuild();for(const t in this._vertexBuffers)this._vertexBuffers[t]._rebuild();(e=this._spriteBuffer)==null||e._rebuild()}dispose(){var e,t;this._buffer&&(this._buffer.dispose(),this._buffer=null),this._spriteBuffer&&(this._spriteBuffer.dispose(),this._spriteBuffer=null),this._indexBuffer&&(this._engine._releaseBuffer(this._indexBuffer),this._indexBuffer=null),this._vertexArrayObject&&(this._engine.releaseVertexArrayObject(this._vertexArrayObject),this._vertexArrayObject=null),this.texture&&(this.texture.dispose(),this.texture=null),(e=this._drawWrapperBase)==null||e.dispose(),(t=this._drawWrapperDepth)==null||t.dispose(),this._isDisposed=!0}}Ku.ForceGLSL=!1;class Ps{set onDispose(e){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(e)}get children(){return this.sprites}get scene(){return this._scene}get capacity(){return this._spriteRenderer.capacity}get texture(){return this._spriteRenderer.texture}set texture(e){e.wrapU=Y.CLAMP_ADDRESSMODE,e.wrapV=Y.CLAMP_ADDRESSMODE,this._spriteRenderer.texture=e,this._textureContent=null}get cellWidth(){return this._spriteRenderer.cellWidth}set cellWidth(e){this._spriteRenderer.cellWidth=e}get cellHeight(){return this._spriteRenderer.cellHeight}set cellHeight(e){this._spriteRenderer.cellHeight=e}get fogEnabled(){return this._spriteRenderer.fogEnabled}set fogEnabled(e){this._spriteRenderer.fogEnabled=e}get useLogarithmicDepth(){return this._spriteRenderer.useLogarithmicDepth}set useLogarithmicDepth(e){this._spriteRenderer.useLogarithmicDepth=e}get blendMode(){return this._spriteRenderer.blendMode}set blendMode(e){this._spriteRenderer.blendMode=e}get disableDepthWrite(){return this._disableDepthWrite}set disableDepthWrite(e){this._disableDepthWrite=e,this._spriteRenderer.disableDepthWrite=e}get pixelPerfect(){return this._spriteRenderer.pixelPerfect}set pixelPerfect(e){this._spriteRenderer.pixelPerfect=e,e&&this.texture.samplingMode!==3&&this.texture.updateSamplingMode(3)}constructor(e,t,i,r,s,n=.01,o=Y.TRILINEAR_SAMPLINGMODE,l=!1,u=null,c){this.name=e,this.sprites=[],this.renderingGroupId=0,this.layerMask=268435455,this.isPickable=!1,this.metadata=null,this._wasDispatched=!1,this.onDisposeObservable=new j,this._disableDepthWrite=!1,this._packedAndReady=!1,this._customUpdate=(d,f)=>{d.cellRef||(d.cellIndex=0);const p=d.cellIndex;typeof p=="number"&&isFinite(p)&&Math.floor(p)===p&&(d.cellRef=this._spriteMap[d.cellIndex]),d._xOffset=this._cellData[d.cellRef].frame.x/f.width,d._yOffset=this._cellData[d.cellRef].frame.y/f.height,d._xSize=this._cellData[d.cellRef].frame.w,d._ySize=this._cellData[d.cellRef].frame.h},s||(s=ze.LastCreatedScene),s._getComponent(ge.NAME_SPRITE)||s._addComponent(new MN(s)),this._fromPacked=l,this._scene=s;const h=this._scene.getEngine();if(this._spriteRenderer=new Ku(h,i,n,s,c==null?void 0:c.spriteRendererOptions),r.width&&r.height)this.cellWidth=r.width,this.cellHeight=r.height;else if(r!==void 0)this.cellWidth=r,this.cellHeight=r;else{this._spriteRenderer=null;return}this._scene.spriteManagers&&this._scene.spriteManagers.push(this),this.uniqueId=this.scene.getUniqueId(),t&&(this.texture=new Y(t,s,!0,!1,o)),this._fromPacked&&this._makePacked(t,u)}getClassName(){return"SpriteManager"}_makePacked(e,t){if(t!==null)try{let i;if(typeof t=="string"?i=JSON.parse(t):i=t,i.frames.length){const s={};for(let n=0;n<i.frames.length;n++){const o=i.frames[n];if(typeof Object.keys(o)[0]!="string")throw new Error("Invalid JSON Format.  Check the frame values and make sure the name is the first parameter.");const l=o[Object.keys(o)[0]];s[l]=o}i.frames=s}const r=Reflect.ownKeys(i.frames);this._spriteMap=r,this._packedAndReady=!0,this._cellData=i.frames}catch{throw this._fromPacked=!1,this._packedAndReady=!1,new Error("Invalid JSON from string. Spritesheet managed with constant cell size.")}else{const i=/\./g;let r;do r=i.lastIndex,i.test(e);while(i.lastIndex>0);const s=e.substring(0,r-1)+".json",n=()=>{L.Error("JSON ERROR: Unable to load JSON file."),this._fromPacked=!1,this._packedAndReady=!1},o=l=>{try{const u=JSON.parse(l),c=Reflect.ownKeys(u.frames);this._spriteMap=c,this._packedAndReady=!0,this._cellData=u.frames}catch{throw this._fromPacked=!1,this._packedAndReady=!1,new Error("Invalid JSON format. Please check documentation for format specifications.")}};ae.LoadFile(s,o,void 0,void 0,!1,n)}}_checkTextureAlpha(e,t,i,r,s){var f;if(!e.useAlphaForPicking||!((f=this.texture)!=null&&f.isReady()))return!0;const n=this.texture.getSize();this._textureContent||(this._textureContent=new Uint8Array(n.width*n.height*4),this.texture.readPixels(0,0,this._textureContent));const o=V.Vector3[0];o.copyFrom(t.direction),o.normalize(),o.scaleInPlace(i),o.addInPlace(t.origin);const l=(o.x-r.x)/(s.x-r.x),u=1-(o.y-r.y)/(s.y-r.y),c=e._xOffset*n.width+l*e._xSize|0,h=e._yOffset*n.height+u*e._ySize|0;return this._textureContent[(c+h*n.width)*4+3]>.5}intersects(e,t,i,r){const s=Math.min(this.capacity,this.sprites.length),n=m.Zero(),o=m.Zero();let l=Number.MAX_VALUE,u=null;const c=V.Vector3[0],h=V.Vector3[1],d=t.getViewMatrix();let f=e,p=e;for(let g=0;g<s;g++){const _=this.sprites[g];if(_){if(i){if(!i(_))continue}else if(!_.isPickable)continue;if(m.TransformCoordinatesToRef(_.position,d,h),_.angle?($.TranslationToRef(-h.x,-h.y,0,V.Matrix[1]),$.TranslationToRef(h.x,h.y,0,V.Matrix[2]),$.RotationZToRef(-_.angle,V.Matrix[3]),V.Matrix[1].multiplyToRef(V.Matrix[3],V.Matrix[4]),V.Matrix[4].multiplyToRef(V.Matrix[2],V.Matrix[0]),f=e.clone(),m.TransformCoordinatesToRef(e.origin,V.Matrix[0],f.origin),m.TransformNormalToRef(e.direction,V.Matrix[0],f.direction)):f=e,n.copyFromFloats(h.x-_.width/2,h.y-_.height/2,h.z),o.copyFromFloats(h.x+_.width/2,h.y+_.height/2,h.z),f.intersectsBoxMinMax(n,o)){const S=m.Distance(h,f.origin);if(l>S){if(!this._checkTextureAlpha(_,f,S,n,o))continue;if(p=f,l=S,u=_,r)break}}}}if(u){const g=new Qi;d.invertToRef(V.Matrix[0]),g.hit=!0,g.pickedSprite=u,g.distance=l;const _=V.Vector3[2];return _.copyFrom(p.direction),_.normalize(),_.scaleInPlace(l),p.origin.addToRef(_,c),g.pickedPoint=m.TransformCoordinates(c,V.Matrix[0]),g}return null}multiIntersects(e,t,i){const r=Math.min(this.capacity,this.sprites.length),s=m.Zero(),n=m.Zero();let o;const l=[],u=V.Vector3[0].copyFromFloats(0,0,0),c=V.Vector3[1].copyFromFloats(0,0,0),h=t.getViewMatrix();for(let d=0;d<r;d++){const f=this.sprites[d];if(f){if(i){if(!i(f))continue}else if(!f.isPickable)continue;if(m.TransformCoordinatesToRef(f.position,h,c),s.copyFromFloats(c.x-f.width/2,c.y-f.height/2,c.z),n.copyFromFloats(c.x+f.width/2,c.y+f.height/2,c.z),e.intersectsBoxMinMax(s,n)){if(o=m.Distance(c,e.origin),!this._checkTextureAlpha(f,e,o,s,n))continue;const p=new Qi;l.push(p),h.invertToRef(V.Matrix[0]),p.hit=!0,p.pickedSprite=f,p.distance=o;const g=V.Vector3[2];g.copyFrom(e.direction),g.normalize(),g.scaleInPlace(o),e.origin.addToRef(g,u),p.pickedPoint=m.TransformCoordinates(u,V.Matrix[0])}}}return l}render(){if(this._fromPacked&&(!this._packedAndReady||!this._spriteMap||!this._cellData))return;const t=this._scene.getEngine().getDeltaTime();this._packedAndReady?this._spriteRenderer.render(this.sprites,t,this._scene.getViewMatrix(),this._scene.getProjectionMatrix(),this._customUpdate):this._spriteRenderer.render(this.sprites,t,this._scene.getViewMatrix(),this._scene.getProjectionMatrix())}rebuild(){var e;(e=this._spriteRenderer)==null||e.rebuild()}dispose(){if(this._spriteRenderer&&(this._spriteRenderer.dispose(),this._spriteRenderer=null),this._textureContent=null,this._scene.spriteManagers){const e=this._scene.spriteManagers.indexOf(this);this._scene.spriteManagers.splice(e,1)}this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this.metadata=null}serialize(e=!1){const t={};t.name=this.name,t.capacity=this.capacity,t.cellWidth=this.cellWidth,t.cellHeight=this.cellHeight,t.fogEnabled=this.fogEnabled,t.blendMode=this.blendMode,t.disableDepthWrite=this.disableDepthWrite,t.pixelPerfect=this.pixelPerfect,t.useLogarithmicDepth=this.useLogarithmicDepth,this.texture&&(e?t.texture=this.texture.serialize():(t.textureUrl=this.texture.name,t.invertY=this.texture._invertY)),t.sprites=[];for(const i of this.sprites)t.sprites.push(i.serialize());return t.metadata=this.metadata,t}static Parse(e,t,i){const r=new Ps(e.name,"",e.capacity,{width:e.cellWidth,height:e.cellHeight},t);e.fogEnabled!==void 0&&(r.fogEnabled=e.fogEnabled),e.blendMode!==void 0&&(r.blendMode=e.blendMode),e.disableDepthWrite!==void 0&&(r.disableDepthWrite=e.disableDepthWrite),e.pixelPerfect!==void 0&&(r.pixelPerfect=e.pixelPerfect),e.useLogarithmicDepth!==void 0&&(r.useLogarithmicDepth=e.useLogarithmicDepth),e.metadata!==void 0&&(r.metadata=e.metadata),e.texture?r.texture=Y.Parse(e.texture,t,i):e.textureName&&(r.texture=new Y(i+e.textureUrl,t,!1,e.invertY!==void 0?e.invertY:!0));for(const s of e.sprites)k_.Parse(s,r);return r}static ParseFromFileAsync(e,t,i,r=""){return new Promise((s,n)=>{const o=new ss;o.addEventListener("readystatechange",()=>{if(o.readyState==4)if(o.status==200){const l=JSON.parse(o.responseText),u=Ps.Parse(l,i||ze.LastCreatedScene,r);e&&(u.name=e),s(u)}else n("Unable to load the sprite manager")}),o.open("GET",t),o.send()})}static ParseFromSnippetAsync(e,t,i=""){return e==="_BLANK"?Promise.resolve(new Ps("Default sprite manager","//playground.babylonjs.com/textures/player.png",500,64,t)):new Promise((r,s)=>{const n=new ss;n.addEventListener("readystatechange",()=>{if(n.readyState==4)if(n.status==200){const o=JSON.parse(JSON.parse(n.responseText).jsonPayload),l=JSON.parse(o.spriteManager),u=Ps.Parse(l,t||ze.LastCreatedScene,i);u.snippetId=e,r(u)}else s("Unable to load the snippet "+e)}),n.open("GET",this.SnippetUrl+"/"+e.replace(/#/g,"/")),n.send()})}}Ps.SnippetUrl="https://snippet.babylonjs.com";Ps.CreateFromSnippetAsync=Ps.ParseFromSnippetAsync;var VW=!0;class Ul{}Ul.LoaderInjectedPhysicsEngine=void 0;let ma={},Js={},Ca={};const OS=(a,e,t,i)=>{if(!e.materials)return null;for(let r=0,s=e.materials.length;r<s;r++){const n=e.materials[r];if(a(n))return{parsedMaterial:n,material:ft.Parse(n,t,i)}}return null},AN=(a,e,t)=>{for(const i in e)if(a.name===e[i])return t.push(a.id),!0;return a.parentId!==void 0&&t.indexOf(a.parentId)!==-1?(t.push(a.id),!0):!1},xa=(a,e)=>a+" of "+(e?e.file+" from "+e.name+" version: "+e.version+", exporter version: "+e.exporter_version:"unknown"),wT=(a,e)=>{const t=e;if(e._waitingData.lods){if(e._waitingData.lods.ids&&e._waitingData.lods.ids.length>0){const i=e._waitingData.lods.ids,r=t.isEnabled(!1);if(e._waitingData.lods.distances){const s=e._waitingData.lods.distances;if(s.length>=i.length){const n=s.length>i.length?s[s.length-1]:0;t.setEnabled(!1);for(let o=0;o<i.length;o++){const l=i[o],u=a.getMeshById(l);u!=null&&t.addLODLevel(s[o],u)}n>0&&t.addLODLevel(n,null),r===!0&&t.setEnabled(!0)}else ae.Warn("Invalid level of detail distances for "+e.name)}}e._waitingData.lods=null}},Ol=(a,e,t)=>{if(typeof a!="number"){const r=t.getLastEntryById(a);return r&&e!==void 0&&e!==null?r.instances[parseInt(e)]:r}const i=ma[a];return i&&e!==void 0&&e!==null?i.instances[parseInt(e)]:i},eu=(a,e)=>typeof a!="number"?e.getLastMaterialById(a,!0):Js[a],wS=(a,e,t,i,r=!1)=>{const s=new dM(a);let n="importScene has failed JSON parse";try{var o=JSON.parse(e);n="";const l=At.loggingLevel===At.DETAILED_LOGGING;let u,c;if(o.environmentTexture!==void 0&&o.environmentTexture!==null){const d=o.isPBR!==void 0?o.isPBR:!0;if(o.environmentTextureType&&o.environmentTextureType==="BABYLON.HDRCubeTexture"){const f=o.environmentTextureSize?o.environmentTextureSize:128,p=new an((o.environmentTexture.match(/https?:\/\//g)?"":t)+o.environmentTexture,a,f,!0,!d,void 0,o.environmentTexturePrefilterOnLoad);o.environmentTextureRotationY&&(p.rotationY=o.environmentTextureRotationY),a.environmentTexture=p}else if(typeof o.environmentTexture=="object"){const f=rn.Parse(o.environmentTexture,a,t);a.environmentTexture=f}else if(o.environmentTexture.endsWith(".env")){const f=new rn((o.environmentTexture.match(/https?:\/\//g)?"":t)+o.environmentTexture,a,o.environmentTextureForcedExtension);o.environmentTextureRotationY&&(f.rotationY=o.environmentTextureRotationY),a.environmentTexture=f}else{const f=rn.CreateFromPrefilteredData((o.environmentTexture.match(/https?:\/\//g)?"":t)+o.environmentTexture,a,o.environmentTextureForcedExtension);o.environmentTextureRotationY&&(f.rotationY=o.environmentTextureRotationY),a.environmentTexture=f}if(o.createDefaultSkybox===!0){const f=a.activeCamera!==void 0&&a.activeCamera!==null?(a.activeCamera.maxZ-a.activeCamera.minZ)/2:1e3,p=o.skyboxBlurLevel||0;a.createDefaultSkybox(a.environmentTexture,d,f,p)}s.environmentTexture=a.environmentTexture}if(o.environmentIntensity!==void 0&&o.environmentIntensity!==null&&(a.environmentIntensity=o.environmentIntensity),o.iblIntensity!==void 0&&o.iblIntensity!==null&&(a.iblIntensity=o.iblIntensity),o.lights!==void 0&&o.lights!==null)for(u=0,c=o.lights.length;u<c;u++){const d=o.lights[u],f=rs.Parse(d,a);f&&(ma[d.uniqueId]=f,s.lights.push(f),f._parentContainer=s,n+=u===0?`
	Lights:`:"",n+=`
		`+f.toString(l))}if(o.reflectionProbes!==void 0&&o.reflectionProbes!==null)for(u=0,c=o.reflectionProbes.length;u<c;u++){const d=o.reflectionProbes[u],f=cl.Parse(d,a,t);f&&(s.reflectionProbes.push(f),f._parentContainer=s,n+=u===0?`
	Reflection Probes:`:"",n+=`
		`+f.toString(l))}if(o.animations!==void 0&&o.animations!==null)for(u=0,c=o.animations.length;u<c;u++){const d=o.animations[u],f=oi("BABYLON.Animation");if(f){const p=f.Parse(d);a.animations.push(p),s.animations.push(p),n+=u===0?`
	Animations:`:"",n+=`
		`+p.toString(l)}}if(o.materials!==void 0&&o.materials!==null)for(u=0,c=o.materials.length;u<c;u++){const d=o.materials[u],f=ft.Parse(d,a,t);f&&(Js[d.uniqueId||d.id]=f,s.materials.push(f),f._parentContainer=s,n+=u===0?`
	Materials:`:"",n+=`
		`+f.toString(l),f.getActiveTextures().forEach(g=>{s.textures.indexOf(g)==-1&&(s.textures.push(g),g._parentContainer=s)}))}if(o.multiMaterials!==void 0&&o.multiMaterials!==null)for(u=0,c=o.multiMaterials.length;u<c;u++){const d=o.multiMaterials[u],f=xu.ParseMultiMaterial(d,a);Js[d.uniqueId||d.id]=f,s.multiMaterials.push(f),f._parentContainer=s,n+=u===0?`
	MultiMaterials:`:"",n+=`
		`+f.toString(l),f.getActiveTextures().forEach(g=>{s.textures.indexOf(g)==-1&&(s.textures.push(g),g._parentContainer=s)})}if(o.morphTargetManagers!==void 0&&o.morphTargetManagers!==null)for(const d of o.morphTargetManagers){const f=yy.Parse(d,a);Ca[d.id]=f,s.morphTargetManagers.push(f),f._parentContainer=s}if(o.skeletons!==void 0&&o.skeletons!==null)for(u=0,c=o.skeletons.length;u<c;u++){const d=o.skeletons[u],f=by.Parse(d,a);s.skeletons.push(f),f._parentContainer=s,n+=u===0?`
	Skeletons:`:"",n+=`
		`+f.toString(l)}const h=o.geometries;if(h!=null){const d=new Array,f=h.vertexData;if(f!=null)for(u=0,c=f.length;u<c;u++){const p=f[u];d.push(vy.Parse(p,a,t))}d.forEach(p=>{p&&(s.geometries.push(p),p._parentContainer=s)})}if(o.transformNodes!==void 0&&o.transformNodes!==null)for(u=0,c=o.transformNodes.length;u<c;u++){const d=o.transformNodes[u],f=Bi.Parse(d,a,t);ma[d.uniqueId]=f,s.transformNodes.push(f),f._parentContainer=s}if(o.meshes!==void 0&&o.meshes!==null)for(u=0,c=o.meshes.length;u<c;u++){const d=o.meshes[u],f=z.Parse(d,a,t);if(ma[d.uniqueId]=f,s.meshes.push(f),f._parentContainer=s,f.hasInstances)for(const p of f.instances)s.meshes.push(p),p._parentContainer=s;n+=u===0?`
	Meshes:`:"",n+=`
		`+f.toString(l)}if(o.cameras!==void 0&&o.cameras!==null)for(u=0,c=o.cameras.length;u<c;u++){const d=o.cameras[u],f=Ze.Parse(d,a);ma[d.uniqueId]=f,s.cameras.push(f),f._parentContainer=s,n+=u===0?`
	Cameras:`:"",n+=`
		`+f.toString(l)}if(o.postProcesses!==void 0&&o.postProcesses!==null)for(u=0,c=o.postProcesses.length;u<c;u++){const d=o.postProcesses[u],f=Ce.Parse(d,a,t);f&&(s.postProcesses.push(f),f._parentContainer=s,n+=u===0?`
Postprocesses:`:"",n+=`
		`+f.toString())}if(o.animationGroups!==void 0&&o.animationGroups!==null)for(u=0,c=o.animationGroups.length;u<c;u++){const d=o.animationGroups[u],f=jM.Parse(d,a);s.animationGroups.push(f),f._parentContainer=s,n+=u===0?`
	AnimationGroups:`:"",n+=`
		`+f.toString(l)}if(o.spriteManagers)for(let d=0,f=o.spriteManagers.length;d<f;d++){const p=o.spriteManagers[d],g=Ps.Parse(p,a,t);n+=`
		SpriteManager `+g.name}for(u=0,c=a.cameras.length;u<c;u++){const d=a.cameras[u];d._waitingParentId!==null&&(d.parent=Ol(d._waitingParentId,d._waitingParentInstanceIndex,a),d._waitingParentId=null,d._waitingParentInstanceIndex=null)}for(u=0,c=a.lights.length;u<c;u++){const d=a.lights[u];d&&d._waitingParentId!==null&&(d.parent=Ol(d._waitingParentId,d._waitingParentInstanceIndex,a),d._waitingParentId=null,d._waitingParentInstanceIndex=null)}for(u=0,c=a.transformNodes.length;u<c;u++){const d=a.transformNodes[u];d._waitingParentId!==null&&(d.parent=Ol(d._waitingParentId,d._waitingParentInstanceIndex,a),d._waitingParentId=null,d._waitingParentInstanceIndex=null)}for(u=0,c=a.meshes.length;u<c;u++){const d=a.meshes[u];d._waitingParentId!==null&&(d.parent=Ol(d._waitingParentId,d._waitingParentInstanceIndex,a),d._waitingParentId=null,d._waitingParentInstanceIndex=null),d._waitingData.lods&&wT(a,d)}for(a.multiMaterials.forEach(d=>{d._waitingSubMaterialsUniqueIds.forEach(f=>{d.subMaterials.push(eu(f,a))}),d._waitingSubMaterialsUniqueIds=[]}),a.meshes.forEach(d=>{d._waitingMaterialId!==null&&(d.material=eu(d._waitingMaterialId,a),d._waitingMaterialId=null)}),a.meshes.forEach(d=>{d._waitingMorphTargetManagerId!==null&&(d.morphTargetManager=Ca[d._waitingMorphTargetManagerId],d._waitingMorphTargetManagerId=null)}),u=0,c=a.skeletons.length;u<c;u++){const d=a.skeletons[u];d._hasWaitingData&&(d.bones!=null&&d.bones.forEach(f=>{if(f._waitingTransformNodeId){const p=a.getLastEntryById(f._waitingTransformNodeId);p&&f.linkTransformNode(p),f._waitingTransformNodeId=null}}),d._hasWaitingData=null)}for(u=0,c=a.meshes.length;u<c;u++){const d=a.meshes[u];d._waitingData.freezeWorldMatrix?(d.freezeWorldMatrix(),d._waitingData.freezeWorldMatrix=null):d.computeWorldMatrix(!0)}for(u=0,c=a.lights.length;u<c;u++){const d=a.lights[u];if(d._excludedMeshesIds.length>0){for(let f=0;f<d._excludedMeshesIds.length;f++){const p=a.getMeshById(d._excludedMeshesIds[f]);p&&d.excludedMeshes.push(p)}d._excludedMeshesIds=[]}if(d._includedOnlyMeshesIds.length>0){for(let f=0;f<d._includedOnlyMeshesIds.length;f++){const p=a.getMeshById(d._includedOnlyMeshesIds[f]);p&&d.includedOnlyMeshes.push(p)}d._includedOnlyMeshesIds=[]}}for(a.geometries.forEach(d=>{d._loadedUniqueId=""}),fM(o,a,s,t),u=0,c=a.meshes.length;u<c;u++){const d=a.meshes[u];d._waitingData.actions&&(Qe.Parse(d._waitingData.actions,d,a),d._waitingData.actions=null)}o.actions!==void 0&&o.actions!==null&&Qe.Parse(o.actions,null,a)}catch(l){const u=xa("loadAssets",o?o.producer:"Unknown")+n;if(i)i(u,l);else throw L.Log(u),l}finally{ma={},Js={},Ca={},r||s.removeAllFromScene(),n!==null&&At.loggingLevel!==At.NO_LOGGING&&L.Log(xa("loadAssets",o?o.producer:"Unknown")+(At.loggingLevel!==At.MINIMAL_LOGGING?n:""))}return s};At.RegisterPlugin({name:"babylon.js",extensions:".babylon",canDirectLoad:a=>a.indexOf("babylon")!==-1,importMesh:(a,e,t,i,r,s,n,o)=>{let l="importMesh has failed JSON parse";try{var u=JSON.parse(t);l="";const c=At.loggingLevel===At.DETAILED_LOGGING;a?Array.isArray(a)||(a=[a]):a=null;const h=[],d=new Map,f=[];if(u.transformNodes!==void 0&&u.transformNodes!==null)for(let p=0,g=u.transformNodes.length;p<g;p++){const _=u.transformNodes[p],S=Bi.Parse(_,e,i);f.push(S),d.set(S._waitingParsedUniqueId,S),S._waitingParsedUniqueId=null}if(u.meshes!==void 0&&u.meshes!==null){const p=[],g=[],_=[],S=[];for(let y=0,T=u.meshes.length;y<T;y++){const v=u.meshes[y];if(a===null||AN(v,a,h)){if(a!==null&&delete a[a.indexOf(v.name)],v.geometryId!==void 0&&v.geometryId!==null&&u.geometries!==void 0&&u.geometries!==null){let R=!1;["boxes","spheres","cylinders","toruses","grounds","planes","torusKnots","vertexData"].forEach(O=>{R===!0||!u.geometries[O]||!Array.isArray(u.geometries[O])||u.geometries[O].forEach(w=>{if(w.id===v.geometryId){switch(O){case"vertexData":vy.Parse(w,e,i);break}R=!0}})}),R===!1&&L.Warn("Geometry not found for mesh "+v.id)}if(v.materialUniqueId||v.materialId){const R=v.materialUniqueId?_:g;let O=R.indexOf(v.materialUniqueId||v.materialId)!==-1;if(O===!1&&u.multiMaterials!==void 0&&u.multiMaterials!==null){const w=(M,G)=>{R.push(M);const H=OS(G,u,e,i);H&&H.material&&(Js[H.parsedMaterial.uniqueId||H.parsedMaterial.id]=H.material,l+=`
	Material `+H.material.toString(c))};for(let M=0,G=u.multiMaterials.length;M<G;M++){const H=u.multiMaterials[M];if(v.materialUniqueId&&H.uniqueId===v.materialUniqueId||H.id===v.materialId){H.materialsUniqueIds?H.materialsUniqueIds.forEach(X=>w(X,ee=>ee.uniqueId===X)):H.materials.forEach(X=>w(X,ee=>ee.id===X)),R.push(H.uniqueId||H.id);const q=xu.ParseMultiMaterial(H,e);Js[H.uniqueId||H.id]=q,q&&(O=!0,l+=`
	Multi-Material `+q.toString(c));break}}}if(O===!1){R.push(v.materialUniqueId||v.materialId);const w=OS(M=>v.materialUniqueId&&M.uniqueId===v.materialUniqueId||M.id===v.materialId,u,e,i);!w||!w.material?L.Warn("Material not found for mesh "+v.id):(Js[w.parsedMaterial.uniqueId||w.parsedMaterial.id]=w.material,l+=`
	Material `+w.material.toString(c))}}if(v.skeletonId!==null&&v.skeletonId!==void 0&&u.skeletonId!==-1&&u.skeletons!==void 0&&u.skeletons!==null&&!(p.indexOf(v.skeletonId)>-1))for(let O=0,w=u.skeletons.length;O<w;O++){const M=u.skeletons[O];if(M.id===v.skeletonId){const G=by.Parse(M,e);n.push(G),p.push(M.id),l+=`
	Skeleton `+G.toString(c)}}if(v.morphTargetManagerId>-1&&u.morphTargetManagers!==void 0&&u.morphTargetManagers!==null&&!(S.indexOf(v.morphTargetManagerId)>-1))for(let O=0;O<u.morphTargetManagers.length;O++){const w=u.morphTargetManagers[O];if(w.id===v.morphTargetManagerId){const M=yy.Parse(w,e);Ca[w.id]=M,S.push(w.id),l+=`
Morph target manager`+M.toString()}}const E=z.Parse(v,e,i);r.push(E),d.set(E._waitingParsedUniqueId,E),E._waitingParsedUniqueId=null,l+=`
	Mesh `+E.toString(c)}}e.multiMaterials.forEach(y=>{y._waitingSubMaterialsUniqueIds.forEach(T=>{y.subMaterials.push(eu(T,e))}),y._waitingSubMaterialsUniqueIds=[]}),e.meshes.forEach(y=>{y._waitingMaterialId!==null&&(y.material=eu(y._waitingMaterialId,e),y._waitingMaterialId=null)}),e.meshes.forEach(y=>{y._waitingMorphTargetManagerId!==null&&(y.morphTargetManager=Ca[y._waitingMorphTargetManagerId],y._waitingMorphTargetManagerId=null)});for(let y=0,T=e.transformNodes.length;y<T;y++){const v=e.transformNodes[y];if(v._waitingParentId!==null){let E=d.get(parseInt(v._waitingParentId))||null;E===null&&(E=e.getLastEntryById(v._waitingParentId));let R=E;v._waitingParentInstanceIndex&&(R=E.instances[parseInt(v._waitingParentInstanceIndex)],v._waitingParentInstanceIndex=null),v.parent=R,v._waitingParentId=null}}let b;for(let y=0,T=e.meshes.length;y<T;y++){if(b=e.meshes[y],b._waitingParentId){let v=d.get(parseInt(b._waitingParentId))||null;v===null&&(v=e.getLastEntryById(b._waitingParentId));let E=v;b._waitingParentInstanceIndex&&(E=v.instances[parseInt(b._waitingParentInstanceIndex)],b._waitingParentInstanceIndex=null),b.parent=E,b._waitingParentId=null}b._waitingData.lods&&wT(e,b)}for(const y of f)y.getChildMeshes(!1).length||y.dispose();for(let y=0,T=e.skeletons.length;y<T;y++){const v=e.skeletons[y];v._hasWaitingData&&(v.bones!=null&&v.bones.forEach(E=>{if(E._waitingTransformNodeId){const R=e.getLastEntryById(E._waitingTransformNodeId);R&&E.linkTransformNode(R),E._waitingTransformNodeId=null}}),v._hasWaitingData=null)}for(let y=0,T=e.meshes.length;y<T;y++)b=e.meshes[y],b._waitingData.freezeWorldMatrix?(b.freezeWorldMatrix(),b._waitingData.freezeWorldMatrix=null):b.computeWorldMatrix(!0)}if(u.particleSystems!==void 0&&u.particleSystems!==null){const p=Ty(ge.NAME_PARTICLESYSTEM);if(p)for(let g=0,_=u.particleSystems.length;g<_;g++){const S=u.particleSystems[g];h.indexOf(S.emitterId)!==-1&&s.push(p(S,e,i))}}return e.geometries.forEach(p=>{p._loadedUniqueId=""}),!0}catch(c){const h=xa("importMesh",u?u.producer:"Unknown")+l;if(o)o(h,c);else throw L.Log(h),c}finally{l!==null&&At.loggingLevel!==At.NO_LOGGING&&L.Log(xa("importMesh",u?u.producer:"Unknown")+(At.loggingLevel!==At.MINIMAL_LOGGING?l:"")),Js={},Ca={}}return!1},load:(a,e,t,i)=>{let r="importScene has failed JSON parse";try{var s=JSON.parse(e);switch(r="",s.useDelayedTextureLoading!==void 0&&s.useDelayedTextureLoading!==null&&(a.useDelayedTextureLoading=s.useDelayedTextureLoading&&!At.ForceFullSceneLoadingForIncremental),s.autoClear!==void 0&&s.autoClear!==null&&(a.autoClear=s.autoClear),s.clearColor!==void 0&&s.clearColor!==null&&(a.clearColor=xe.FromArray(s.clearColor)),s.ambientColor!==void 0&&s.ambientColor!==null&&(a.ambientColor=ne.FromArray(s.ambientColor)),s.gravity!==void 0&&s.gravity!==null&&(a.gravity=m.FromArray(s.gravity)),s.useRightHandedSystem!==void 0&&(a.useRightHandedSystem=!!s.useRightHandedSystem),s.fogMode!==void 0&&s.fogMode!==null&&(a.fogMode=s.fogMode),s.fogColor!==void 0&&s.fogColor!==null&&(a.fogColor=ne.FromArray(s.fogColor)),s.fogStart!==void 0&&s.fogStart!==null&&(a.fogStart=s.fogStart),s.fogEnd!==void 0&&s.fogEnd!==null&&(a.fogEnd=s.fogEnd),s.fogDensity!==void 0&&s.fogDensity!==null&&(a.fogDensity=s.fogDensity),r+="	Fog mode for scene:  ",a.fogMode){case 0:r+=`none
`;break;case 1:r+=`exp
`;break;case 2:r+=`exp2
`;break;case 3:r+=`linear
`;break}if(s.physicsEnabled){let o;s.physicsEngine==="cannon"||s.physicsEngine===Hh.name?o=new Hh(void 0,void 0,Ul.LoaderInjectedPhysicsEngine):s.physicsEngine==="oimo"||s.physicsEngine===DS.name?o=new DS(void 0,Ul.LoaderInjectedPhysicsEngine):(s.physicsEngine==="ammo"||s.physicsEngine===is.name)&&(o=new is(void 0,Ul.LoaderInjectedPhysicsEngine,void 0)),r="	Physics engine "+(s.physicsEngine?s.physicsEngine:"oimo")+` enabled
`;const l=s.gravity?m.FromArray(s.gravity):s.physicsGravity?m.FromArray(s.physicsGravity):null;a.enablePhysics(l,o)}return s.metadata!==void 0&&s.metadata!==null&&(a.metadata=s.metadata),s.collisionsEnabled!==void 0&&s.collisionsEnabled!==null&&(a.collisionsEnabled=s.collisionsEnabled),wS(a,e,t,i,!0)?(s.autoAnimate&&a.beginAnimation(a,s.autoAnimateFrom,s.autoAnimateTo,s.autoAnimateLoop,s.autoAnimateSpeed||1),s.activeCameraID!==void 0&&s.activeCameraID!==null&&a.setActiveCameraById(s.activeCameraID),!0):!1}catch(n){const o=xa("importScene",s?s.producer:"Unknown")+r;if(i)i(o,n);else throw L.Log(o),n}finally{r!==null&&At.loggingLevel!==At.NO_LOGGING&&L.Log(xa("importScene",s?s.producer:"Unknown")+(At.loggingLevel!==At.MINIMAL_LOGGING?r:""))}return!1},loadAssetContainer:(a,e,t,i)=>wS(a,e,t,i)});const NS="backgroundUboDeclaration",DN=`uniform vPrimaryColor: vec4f;uniform vPrimaryColorShadow: vec4f;uniform vDiffuseInfos: vec2f;uniform vReflectionInfos: vec2f;uniform diffuseMatrix: mat4x4f;uniform reflectionMatrix: mat4x4f;uniform vReflectionMicrosurfaceInfos: vec3f;uniform fFovMultiplier: f32;uniform pointSize: f32;uniform shadowLevel: f32;uniform alpha: f32;uniform vBackgroundCenter: vec3f;uniform vReflectionControl: vec4f;uniform projectedGroundInfos: vec2f;
#include<sceneUboDeclaration>
`;P.IncludesShadersStoreWGSL[NS]||(P.IncludesShadersStoreWGSL[NS]=DN);const jh="backgroundVertexShader",NT=`#include<backgroundUboDeclaration>
#include<helperFunctions>
attribute position: vec3f;
#ifdef NORMAL
attribute normal: vec3f;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
varying vPositionW: vec3f;
#ifdef NORMAL
varying vNormalW: vec3f;
#endif
#ifdef UV1
attribute uv: vec2f;
#endif
#ifdef UV2
attribute uv2: vec2f;
#endif
#ifdef MAINUV1
varying vMainUV1: vec2f;
#endif
#ifdef MAINUV2
varying vMainUV2: vec2f;
#endif
#if defined(DIFFUSE) && DIFFUSEDIRECTUV==0
varying vDiffuseUV: vec2f;
#endif
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<lightVxUboDeclaration>[0..maxSimultaneousLights]
#ifdef REFLECTIONMAP_SKYBOX
varying vPositionUVW: vec3f;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vDirectionW: vec3f;
#endif
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
#ifdef REFLECTIONMAP_SKYBOX
vertexOutputs.vPositionUVW=input.position;
#endif
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {vertexOutputs.position=scene.viewProjection*finalWorld* vec4f(input.position,1.0);} else {vertexOutputs.position=scene.viewProjectionR*finalWorld* vec4f(input.position,1.0);}
#else
vertexOutputs.position=scene.viewProjection*finalWorld* vec4f(input.position,1.0);
#endif
var worldPos: vec4f=finalWorld* vec4f(input.position,1.0);vertexOutputs.vPositionW= worldPos.xyz;
#ifdef NORMAL
var normalWorld: mat3x3f=mat3x3f(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz);
#ifdef NONUNIFORMSCALING
normalWorld=transposeMat3(inverseMat3(normalWorld));
#endif
vertexOutputs.vNormalW=normalize(normalWorld*input.normal);
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
vertexOutputs.vDirectionW=normalize((finalWorld*vec4f(input.position,0.0)).xyz);
#ifdef EQUIRECTANGULAR_RELFECTION_FOV
var screenToWorld: mat3x3f=inverseMat3( mat3x3f(finalWorld*scene.viewProjection));var segment: vec3f=mix(vertexOutputs.vDirectionW,screenToWorld* vec3f(0.0,0.0,1.0),abs(fFovMultiplier-1.0));if (fFovMultiplier<=1.0) {vertexOutputs.vDirectionW=normalize(segment);} else {vertexOutputs.vDirectionW=normalize(vertexOutputs.vDirectionW+(vertexOutputs.vDirectionW-segment));}
#endif
#endif
#ifndef UV1
var uv: vec2f=vec2f(0.,0.);
#else
var uv=input.uv;
#endif
#ifndef UV2
var uv2: vec2f=vec2f(0.,0.);
#else
var uv2=input.uv2;
#endif
#ifdef MAINUV1
vertexOutputs.vMainUV1=uv;
#endif
#ifdef MAINUV2
vertexOutputs.vMainUV2=uv2;
#endif
#if defined(DIFFUSE) && DIFFUSEDIRECTUV==0
if (uniforms.vDiffuseInfos.x==0.)
{vertexOutputs.vDiffuseUV= (uniforms.diffuseMatrix* vec4f(uv,1.0,0.0)).xy;}
else
{vertexOutputs.vDiffuseUV= (uniforms.diffuseMatrix* vec4f(uv2,1.0,0.0)).xy;}
#endif
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#ifdef VERTEXCOLOR
vertexOutputs.vColor=vertexInputs.color;
#endif
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}
`;P.ShadersStoreWGSL[jh]||(P.ShadersStoreWGSL[jh]=NT);const ON={name:jh,shader:NT},wN=Object.freeze(Object.defineProperty({__proto__:null,backgroundVertexShaderWGSL:ON},Symbol.toStringTag,{value:"Module"})),FS="intersectionFunctions",NN=`fn diskIntersectWithBackFaceCulling(ro: vec3f,rd: vec3f,c: vec3f,r: f32)->f32 {var d: f32=rd.y;if(d>0.0) { return 1e6; }
var o: vec3f=ro-c;var t: f32=-o.y/d;var q: vec3f=o+rd*t;return select(1e6,t,(dot(q,q)<r*r));}
fn sphereIntersect(ro: vec3f,rd: vec3f,ce: vec3f,ra: f32)->vec2f {var oc: vec3f=ro-ce;var b: f32=dot(oc,rd);var c: f32=dot(oc,oc)-ra*ra;var h: f32=b*b-c;if(h<0.0) { return vec2f(-1.,-1.); }
h=sqrt(h);return vec2f(-b+h,-b-h);}
fn sphereIntersectFromOrigin(ro: vec3f,rd: vec3f,ra: f32)->vec2f {var b: f32=dot(ro,rd);var c: f32=dot(ro,ro)-ra*ra;var h: f32=b*b-c;if(h<0.0) { return vec2f(-1.,-1.); }
h=sqrt(h);return vec2f(-b+h,-b-h);}`;P.IncludesShadersStoreWGSL[FS]||(P.IncludesShadersStoreWGSL[FS]=NN);const Yh="backgroundPixelShader",FT=`#include<backgroundUboDeclaration>
#include<helperFunctions>
varying vPositionW: vec3f;
#ifdef MAINUV1
varying vMainUV1: vec2f;
#endif 
#ifdef MAINUV2 
varying vMainUV2: vec2f; 
#endif 
#ifdef NORMAL
varying vNormalW: vec3f;
#endif
#ifdef DIFFUSE
#if DIFFUSEDIRECTUV==1
#define vDiffuseUV vMainUV1
#elif DIFFUSEDIRECTUV==2
#define vDiffuseUV vMainUV2
#else
varying vDiffuseUV: vec2f;
#endif
var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;
#endif
#ifdef REFLECTION
#ifdef REFLECTIONMAP_3D
var reflectionSamplerSampler: sampler;var reflectionSampler: texture_cube<f32>;
#ifdef TEXTURELODSUPPORT
#else
var reflectionLowSamplerSampler: sampler;var reflectionLowSampler: texture_cube<f32>;var reflectionHighSamplerSampler: sampler;var reflectionHighSampler: texture_cube<f32>;
#endif
#else
var reflectionSamplerSampler: sampler;var reflectionSampler: texture_2d<f32>;
#ifdef TEXTURELODSUPPORT
#else
var reflectionLowSamplerSampler: sampler;var reflectionLowSampler: texture_2d<f32>;var reflectionHighSamplerSampler: sampler;var reflectionHighSampler: texture_2d<f32>;
#endif
#endif
#ifdef REFLECTIONMAP_SKYBOX
varying vPositionUVW: vec3f;
#else
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vDirectionW: vec3f;
#endif
#endif
#include<reflectionFunction>
#endif
#ifndef FROMLINEARSPACE
#define FROMLINEARSPACE;
#endif
#ifndef SHADOWONLY
#define SHADOWONLY;
#endif
#include<imageProcessingDeclaration>
#include<lightUboDeclaration>[0..maxSimultaneousLights]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<imageProcessingFunctions>
#include<logDepthDeclaration>
#include<clipPlaneFragmentDeclaration>
#include<fogFragmentDeclaration>
#ifdef REFLECTIONFRESNEL
#define FRESNEL_MAXIMUM_ON_ROUGH 0.25
fn fresnelSchlickEnvironmentGGX(VdotN: f32,reflectance0: vec3f,reflectance90: vec3f,smoothness: f32)->vec3f
{var weight: f32=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);return reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));}
#endif
#ifdef PROJECTED_GROUND
#include<intersectionFunctions>
fn project(viewDirectionW: vec3f,eyePosition: vec3f)->vec3f {var radius: f32=uniforms.projectedGroundInfos.x;var height: f32=uniforms.projectedGroundInfos.y;var camDir: vec3f=-viewDirectionW;var skySphereDistance: f32=sphereIntersectFromOrigin(eyePosition,camDir,radius).x;var skySpherePositionW: vec3f=eyePosition+camDir*skySphereDistance;var p: vec3f=normalize(skySpherePositionW);var upEyePosition=vec3f(eyePosition.x,eyePosition.y-height,eyePosition.z);var sIntersection: f32=sphereIntersectFromOrigin(upEyePosition,p,radius).x;var h: vec3f= vec3f(0.0,-height,0.0);var dIntersection: f32=diskIntersectWithBackFaceCulling(upEyePosition,p,h,radius);p=(upEyePosition+min(sIntersection,dIntersection)*p);return p;}
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
var viewDirectionW: vec3f=normalize(scene.vEyePosition.xyz-input.vPositionW);
#ifdef NORMAL
var normalW: vec3f=normalize(fragmentInputs.vNormalW);
#else
var normalW: vec3f= vec3f(0.0,1.0,0.0);
#endif
var shadow: f32=1.;var globalShadow: f32=0.;var shadowLightCount: f32=0.;var aggShadow: f32=0.;var numLights: f32=0.;
#include<lightFragment>[0..maxSimultaneousLights]
#ifdef SHADOWINUSE
globalShadow/=shadowLightCount;
#else
globalShadow=1.0;
#endif
#ifndef BACKMAT_SHADOWONLY
var reflectionColor: vec4f= vec4f(1.,1.,1.,1.);
#ifdef REFLECTION
#ifdef PROJECTED_GROUND
var reflectionVector: vec3f=project(viewDirectionW,scene.vEyePosition.xyz);reflectionVector= (uniforms.reflectionMatrix*vec4f(reflectionVector,1.)).xyz;
#else
var reflectionVector: vec3f=computeReflectionCoords( vec4f(fragmentInputs.vPositionW,1.0),normalW);
#endif
#ifdef REFLECTIONMAP_OPPOSITEZ
reflectionVector.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
var reflectionCoords: vec3f=reflectionVector;
#else
var reflectionCoords: vec2f=reflectionVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
reflectionCoords/=reflectionVector.z;
#endif
reflectionCoords.y=1.0-reflectionCoords.y;
#endif
#ifdef REFLECTIONBLUR
var reflectionLOD: f32=uniforms.vReflectionInfos.y;
#ifdef TEXTURELODSUPPORT
reflectionLOD=reflectionLOD*log2(vReflectionMicrosurfaceInfos.x)*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;reflectionColor=textureSampleLevel(reflectionSampler,reflectionSamplerSampler,reflectionCoords,reflectionLOD);
#else
var lodReflectionNormalized: f32=saturate(reflectionLOD);var lodReflectionNormalizedDoubled: f32=lodReflectionNormalized*2.0;var reflectionSpecularMid: vec4f=textureSample(reflectionSampler,reflectionSamplerSampler,reflectionCoords);if(lodReflectionNormalizedDoubled<1.0){reflectionColor=mix(
textureSample(reflectionrHighSampler,reflectionrHighSamplerSampler,reflectionCoords),
reflectionSpecularMid,
lodReflectionNormalizedDoubled
);} else {reflectionColor=mix(
reflectionSpecularMid,
textureSample(reflectionLowSampler,reflectionLowSamplerSampler,reflectionCoords),
lodReflectionNormalizedDoubled-1.0
);}
#endif
#else
var reflectionSample: vec4f=textureSample(reflectionSampler,reflectionSamplerSampler,reflectionCoords);reflectionColor=reflectionSample;
#endif
#ifdef RGBDREFLECTION
reflectionColor=vec4f(fromRGBD(reflectionColor).rgb,reflectionColor.a);
#endif
#ifdef GAMMAREFLECTION
reflectionColor=vec4f(toLinearSpaceVec3(reflectionColor.rgb),reflectionColor.a);
#endif
#ifdef REFLECTIONBGR
reflectionColor=vec4f(reflectionColor.bgr,reflectionColor.a);
#endif
reflectionColor=vec4f(reflectionColor.rgb*uniforms.vReflectionInfos.x,reflectionColor.a);
#endif
var diffuseColor: vec3f= vec3f(1.,1.,1.);var finalAlpha: f32=uniforms.alpha;
#ifdef DIFFUSE
var diffuseMap: vec4f=textureSample(diffuseSampler,diffuseSamplerSampler,input.vDiffuseUV);
#ifdef GAMMADIFFUSE
diffuseMap=vec4f(toLinearSpaceVec3(diffuseMap.rgb),diffuseMap.a);
#endif
diffuseMap=vec4f(diffuseMap.rgb *uniforms.vDiffuseInfos.y,diffuseMap.a);
#ifdef DIFFUSEHASALPHA
finalAlpha*=diffuseMap.a;
#endif
diffuseColor=diffuseMap.rgb;
#endif
#ifdef REFLECTIONFRESNEL
var colorBase: vec3f=diffuseColor;
#else
var colorBase: vec3f=reflectionColor.rgb*diffuseColor;
#endif
colorBase=max(colorBase,vec3f(0.0));
#ifdef USERGBCOLOR
var finalColor: vec3f=colorBase;
#else
#ifdef USEHIGHLIGHTANDSHADOWCOLORS
var mainColor: vec3f=mix(uniforms.vPrimaryColorShadow.rgb,uniforms.vPrimaryColor.rgb,colorBase);
#else
var mainColor: vec3f=uniforms.vPrimaryColor.rgb;
#endif
var finalColor: vec3f=colorBase*mainColor;
#endif
#ifdef REFLECTIONFRESNEL
var reflectionAmount: vec3f=uniforms.vReflectionControl.xxx;var reflectionReflectance0: vec3f=uniforms.vReflectionControl.yyy;var reflectionReflectance90: vec3f=uniforms.vReflectionControl.zzz;var VdotN: f32=dot(normalize(scene.vEyePosition.xyz),normalW);var planarReflectionFresnel: vec3f=fresnelSchlickEnvironmentGGX(saturate(VdotN),reflectionReflectance0,reflectionReflectance90,1.0);reflectionAmount*=planarReflectionFresnel;
#ifdef REFLECTIONFALLOFF
var reflectionDistanceFalloff: f32=1.0-saturate(length(vPositionW.xyz-uniforms.vBackgroundCenter)*uniforms.vReflectionControl.w);reflectionDistanceFalloff*=reflectionDistanceFalloff;reflectionAmount*=reflectionDistanceFalloff;
#endif
finalColor=mix(finalColor,reflectionColor.rgb,saturateVec3(reflectionAmount));
#endif
#ifdef OPACITYFRESNEL
var viewAngleToFloor: f32=dot(normalW,normalize(scene.vEyePosition.xyz-uniforms.vBackgroundCenter));const startAngle: f32=0.1;var fadeFactor: f32=saturate(viewAngleToFloor/startAngle);finalAlpha*=fadeFactor*fadeFactor;
#endif
#ifdef SHADOWINUSE
finalColor=mix(finalColor*uniforms.shadowLevel,finalColor,globalShadow);
#endif
var color: vec4f= vec4f(finalColor,finalAlpha);
#else
var color: vec4f= vec4f(uniforms.vPrimaryColor.rgb,(1.0-clamp(globalShadow,0.,1.))*uniforms.alpha);
#endif
#include<logDepthFragment>
#include<fogFragment>
#ifdef IMAGEPROCESSINGPOSTPROCESS
#if !defined(SKIPFINALCOLORCLAMP)
color=vec4f(clamp(color.rgb,vec3f(0.),vec3f(30.0)),color.a);
#endif
#else
color=applyImageProcessing(color);
#endif
#ifdef PREMULTIPLYALPHA
color=vec4f(color.rgb *color.a,color.a);
#endif
#ifdef NOISE
color=vec4f(color.rgb+dither(fragmentInputs.vPositionW.xy,0.5),color.a);color=max(color,vec4f(0.0));
#endif
fragmentOutputs.color=color;
#define CUSTOM_FRAGMENT_MAIN_END
}
`;P.ShadersStoreWGSL[Yh]||(P.ShadersStoreWGSL[Yh]=FT);const FN={name:Yh,shader:FT},LN=Object.freeze(Object.defineProperty({__proto__:null,backgroundPixelShaderWGSL:FN},Symbol.toStringTag,{value:"Module"})),LS="backgroundVertexDeclaration",BN=`uniform mat4 view;uniform mat4 viewProjection;
#ifdef MULTIVIEW
uniform mat4 viewProjectionR;
#endif
uniform float shadowLevel;
#ifdef DIFFUSE
uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;uniform mat4 reflectionMatrix;uniform vec3 vReflectionMicrosurfaceInfos;uniform float fFovMultiplier;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
`;P.IncludesShadersStore[LS]||(P.IncludesShadersStore[LS]=BN);const BS="backgroundUboDeclaration",VN=`layout(std140,column_major) uniform;uniform Material
{uniform vec4 vPrimaryColor;uniform vec4 vPrimaryColorShadow;uniform vec2 vDiffuseInfos;uniform vec2 vReflectionInfos;uniform mat4 diffuseMatrix;uniform mat4 reflectionMatrix;uniform vec3 vReflectionMicrosurfaceInfos;uniform float fFovMultiplier;uniform float pointSize;uniform float shadowLevel;uniform float alpha;uniform vec3 vBackgroundCenter;uniform vec4 vReflectionControl;uniform vec2 projectedGroundInfos;};
#include<sceneUboDeclaration>
`;P.IncludesShadersStore[BS]||(P.IncludesShadersStore[BS]=VN);const Xh="backgroundVertexShader",LT=`precision highp float;
#include<__decl__backgroundVertex>
#include<helperFunctions>
attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#ifdef MAINUV1
varying vec2 vMainUV1;
#endif
#ifdef MAINUV2
varying vec2 vMainUV2;
#endif
#if defined(DIFFUSE) && DIFFUSEDIRECTUV==0
varying vec2 vDiffuseUV;
#endif
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightVxFragment>[0..maxSimultaneousLights]
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#ifdef REFLECTIONMAP_SKYBOX
vPositionUVW=position;
#endif
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {gl_Position=viewProjection*finalWorld*vec4(position,1.0);} else {gl_Position=viewProjectionR*finalWorld*vec4(position,1.0);}
#else
gl_Position=viewProjection*finalWorld*vec4(position,1.0);
#endif
vec4 worldPos=finalWorld*vec4(position,1.0);vPositionW=vec3(worldPos);
#ifdef NORMAL
mat3 normalWorld=mat3(finalWorld);
#ifdef NONUNIFORMSCALING
normalWorld=transposeMat3(inverseMat3(normalWorld));
#endif
vNormalW=normalize(normalWorld*normal);
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
vDirectionW=normalize(vec3(finalWorld*vec4(position,0.0)));
#ifdef EQUIRECTANGULAR_RELFECTION_FOV
mat3 screenToWorld=inverseMat3(mat3(finalWorld*viewProjection));vec3 segment=mix(vDirectionW,screenToWorld*vec3(0.0,0.0,1.0),abs(fFovMultiplier-1.0));if (fFovMultiplier<=1.0) {vDirectionW=normalize(segment);} else {vDirectionW=normalize(vDirectionW+(vDirectionW-segment));}
#endif
#endif
#ifndef UV1
vec2 uv=vec2(0.,0.);
#endif
#ifndef UV2
vec2 uv2=vec2(0.,0.);
#endif
#ifdef MAINUV1
vMainUV1=uv;
#endif
#ifdef MAINUV2
vMainUV2=uv2;
#endif
#if defined(DIFFUSE) && DIFFUSEDIRECTUV==0
if (vDiffuseInfos.x==0.)
{vDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));}
else
{vDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));}
#endif
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#ifdef VERTEXCOLOR
vColor=colorUpdated;
#endif
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}
`;P.ShadersStore[Xh]||(P.ShadersStore[Xh]=LT);const kN={name:Xh,shader:LT},zN=Object.freeze(Object.defineProperty({__proto__:null,backgroundVertexShader:kN},Symbol.toStringTag,{value:"Module"})),VS="backgroundFragmentDeclaration",UN=`uniform vec4 vEyePosition;uniform vec4 vPrimaryColor;
#ifdef USEHIGHLIGHTANDSHADOWCOLORS
uniform vec4 vPrimaryColorShadow;
#endif
uniform float shadowLevel;uniform float alpha;
#ifdef DIFFUSE
uniform vec2 vDiffuseInfos;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;uniform mat4 reflectionMatrix;uniform vec3 vReflectionMicrosurfaceInfos;
#endif
#if defined(REFLECTIONFRESNEL) || defined(OPACITYFRESNEL)
uniform vec3 vBackgroundCenter;
#endif
#ifdef REFLECTIONFRESNEL
uniform vec4 vReflectionControl;
#endif
#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)
uniform mat4 view;
#endif
#ifdef PROJECTED_GROUND
uniform vec2 projectedGroundInfos;
#endif
`;P.IncludesShadersStore[VS]||(P.IncludesShadersStore[VS]=UN);const kS="intersectionFunctions",GN=`float diskIntersectWithBackFaceCulling(vec3 ro,vec3 rd,vec3 c,float r) {float d=rd.y;if(d>0.0) { return 1e6; }
vec3 o=ro-c;float t=-o.y/d;vec3 q=o+rd*t;return (dot(q,q)<r*r) ? t : 1e6;}
vec2 sphereIntersect(vec3 ro,vec3 rd,vec3 ce,float ra) {vec3 oc=ro-ce;float b=dot(oc,rd);float c=dot(oc,oc)-ra*ra;float h=b*b-c;if(h<0.0) { return vec2(-1.0,-1.0); }
h=sqrt(h);return vec2(-b+h,-b-h);}
vec2 sphereIntersectFromOrigin(vec3 ro,vec3 rd,float ra) {float b=dot(ro,rd);float c=dot(ro,ro)-ra*ra;float h=b*b-c;if(h<0.0) { return vec2(-1.0,-1.0); }
h=sqrt(h);return vec2(-b+h,-b-h);}`;P.IncludesShadersStore[kS]||(P.IncludesShadersStore[kS]=GN);const Zh="backgroundPixelShader",BT=`#ifdef TEXTURELODSUPPORT
#extension GL_EXT_shader_texture_lod : enable
#endif
precision highp float;
#include<__decl__backgroundFragment>
#include<helperFunctions>
varying vec3 vPositionW;
#ifdef MAINUV1
varying vec2 vMainUV1;
#endif 
#ifdef MAINUV2 
varying vec2 vMainUV2; 
#endif 
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#ifdef DIFFUSE
#if DIFFUSEDIRECTUV==1
#define vDiffuseUV vMainUV1
#elif DIFFUSEDIRECTUV==2
#define vDiffuseUV vMainUV2
#else
varying vec2 vDiffuseUV;
#endif
uniform sampler2D diffuseSampler;
#endif
#ifdef REFLECTION
#ifdef REFLECTIONMAP_3D
#define sampleReflection(s,c) textureCube(s,c)
uniform samplerCube reflectionSampler;
#ifdef TEXTURELODSUPPORT
#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)
#else
uniform samplerCube reflectionSamplerLow;uniform samplerCube reflectionSamplerHigh;
#endif
#else
#define sampleReflection(s,c) texture2D(s,c)
uniform sampler2D reflectionSampler;
#ifdef TEXTURELODSUPPORT
#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)
#else
uniform samplerCube reflectionSamplerLow;uniform samplerCube reflectionSamplerHigh;
#endif
#endif
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#else
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#endif
#include<reflectionFunction>
#endif
#ifndef FROMLINEARSPACE
#define FROMLINEARSPACE;
#endif
#ifndef SHADOWONLY
#define SHADOWONLY;
#endif
#include<imageProcessingDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<imageProcessingFunctions>
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<logDepthDeclaration>
#include<clipPlaneFragmentDeclaration>
#include<fogFragmentDeclaration>
#ifdef REFLECTIONFRESNEL
#define FRESNEL_MAXIMUM_ON_ROUGH 0.25
vec3 fresnelSchlickEnvironmentGGX(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)
{float weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);return reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));}
#endif
#ifdef PROJECTED_GROUND
#include<intersectionFunctions>
vec3 project(vec3 viewDirectionW,vec3 eyePosition) {float radius=projectedGroundInfos.x;float height=projectedGroundInfos.y;vec3 camDir=-viewDirectionW;float skySphereDistance=sphereIntersectFromOrigin(eyePosition,camDir,radius).x;vec3 skySpherePositionW=eyePosition+camDir*skySphereDistance;vec3 p=normalize(skySpherePositionW);eyePosition.y-=height;float sIntersection=sphereIntersectFromOrigin(eyePosition,p,radius).x;vec3 h=vec3(0.0,-height,0.0);float dIntersection=diskIntersectWithBackFaceCulling(eyePosition,p,h,radius);p=(eyePosition+min(sIntersection,dIntersection)*p);return p;}
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=vec3(0.0,1.0,0.0);
#endif
float shadow=1.;float globalShadow=0.;float shadowLightCount=0.;float aggShadow=0.;float numLights=0.;
#include<lightFragment>[0..maxSimultaneousLights]
#ifdef SHADOWINUSE
globalShadow/=shadowLightCount;
#else
globalShadow=1.0;
#endif
#ifndef BACKMAT_SHADOWONLY
vec4 reflectionColor=vec4(1.,1.,1.,1.);
#ifdef REFLECTION
#ifdef PROJECTED_GROUND
vec3 reflectionVector=project(viewDirectionW,vEyePosition.xyz);reflectionVector=vec3(reflectionMatrix*vec4(reflectionVector,1.));
#else
vec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);
#endif
#ifdef REFLECTIONMAP_OPPOSITEZ
reflectionVector.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
vec3 reflectionCoords=reflectionVector;
#else
vec2 reflectionCoords=reflectionVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
reflectionCoords/=reflectionVector.z;
#endif
reflectionCoords.y=1.0-reflectionCoords.y;
#endif
#ifdef REFLECTIONBLUR
float reflectionLOD=vReflectionInfos.y;
#ifdef TEXTURELODSUPPORT
reflectionLOD=reflectionLOD*log2(vReflectionMicrosurfaceInfos.x)*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;reflectionColor=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);
#else
float lodReflectionNormalized=saturate(reflectionLOD);float lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;vec4 reflectionSpecularMid=sampleReflection(reflectionSampler,reflectionCoords);if(lodReflectionNormalizedDoubled<1.0){reflectionColor=mix(
sampleReflection(reflectionSamplerHigh,reflectionCoords),
reflectionSpecularMid,
lodReflectionNormalizedDoubled
);} else {reflectionColor=mix(
reflectionSpecularMid,
sampleReflection(reflectionSamplerLow,reflectionCoords),
lodReflectionNormalizedDoubled-1.0
);}
#endif
#else
vec4 reflectionSample=sampleReflection(reflectionSampler,reflectionCoords);reflectionColor=reflectionSample;
#endif
#ifdef RGBDREFLECTION
reflectionColor.rgb=fromRGBD(reflectionColor);
#endif
#ifdef GAMMAREFLECTION
reflectionColor.rgb=toLinearSpace(reflectionColor.rgb);
#endif
#ifdef REFLECTIONBGR
reflectionColor.rgb=reflectionColor.bgr;
#endif
reflectionColor.rgb*=vReflectionInfos.x;
#endif
vec3 diffuseColor=vec3(1.,1.,1.);float finalAlpha=alpha;
#ifdef DIFFUSE
vec4 diffuseMap=texture2D(diffuseSampler,vDiffuseUV);
#ifdef GAMMADIFFUSE
diffuseMap.rgb=toLinearSpace(diffuseMap.rgb);
#endif
diffuseMap.rgb*=vDiffuseInfos.y;
#ifdef DIFFUSEHASALPHA
finalAlpha*=diffuseMap.a;
#endif
diffuseColor=diffuseMap.rgb;
#endif
#ifdef REFLECTIONFRESNEL
vec3 colorBase=diffuseColor;
#else
vec3 colorBase=reflectionColor.rgb*diffuseColor;
#endif
colorBase=max(colorBase,0.0);
#ifdef USERGBCOLOR
vec3 finalColor=colorBase;
#else
#ifdef USEHIGHLIGHTANDSHADOWCOLORS
vec3 mainColor=mix(vPrimaryColorShadow.rgb,vPrimaryColor.rgb,colorBase);
#else
vec3 mainColor=vPrimaryColor.rgb;
#endif
vec3 finalColor=colorBase*mainColor;
#endif
#ifdef REFLECTIONFRESNEL
vec3 reflectionAmount=vReflectionControl.xxx;vec3 reflectionReflectance0=vReflectionControl.yyy;vec3 reflectionReflectance90=vReflectionControl.zzz;float VdotN=dot(normalize(vEyePosition.xyz),normalW);vec3 planarReflectionFresnel=fresnelSchlickEnvironmentGGX(saturate(VdotN),reflectionReflectance0,reflectionReflectance90,1.0);reflectionAmount*=planarReflectionFresnel;
#ifdef REFLECTIONFALLOFF
float reflectionDistanceFalloff=1.0-saturate(length(vPositionW.xyz-vBackgroundCenter)*vReflectionControl.w);reflectionDistanceFalloff*=reflectionDistanceFalloff;reflectionAmount*=reflectionDistanceFalloff;
#endif
finalColor=mix(finalColor,reflectionColor.rgb,saturate(reflectionAmount));
#endif
#ifdef OPACITYFRESNEL
float viewAngleToFloor=dot(normalW,normalize(vEyePosition.xyz-vBackgroundCenter));const float startAngle=0.1;float fadeFactor=saturate(viewAngleToFloor/startAngle);finalAlpha*=fadeFactor*fadeFactor;
#endif
#ifdef SHADOWINUSE
finalColor=mix(finalColor*shadowLevel,finalColor,globalShadow);
#endif
vec4 color=vec4(finalColor,finalAlpha);
#else
vec4 color=vec4(vPrimaryColor.rgb,(1.0-clamp(globalShadow,0.,1.))*alpha);
#endif
#include<logDepthFragment>
#include<fogFragment>
#ifdef IMAGEPROCESSINGPOSTPROCESS
#if !defined(SKIPFINALCOLORCLAMP)
color.rgb=clamp(color.rgb,0.,30.0);
#endif
#else
color=applyImageProcessing(color);
#endif
#ifdef PREMULTIPLYALPHA
color.rgb*=color.a;
#endif
#ifdef NOISE
color.rgb+=dither(vPositionW.xy,0.5);color=max(color,0.0);
#endif
gl_FragColor=color;
#define CUSTOM_FRAGMENT_MAIN_END
}
`;P.ShadersStore[Zh]||(P.ShadersStore[Zh]=BT);const WN={name:Zh,shader:BT},$N=Object.freeze(Object.defineProperty({__proto__:null,backgroundPixelShader:WN},Symbol.toStringTag,{value:"Module"}));class tu{get isEnabled(){return this._isEnabled}set isEnabled(e){this._isEnabled!==e&&(this._isEnabled=e,st.MarkAllMaterialsAsDirty(20))}constructor(e={}){this._isEnabled=!0,this.bias=e.bias===void 0?0:e.bias,this.power=e.power===void 0?1:e.power,this.leftColor=e.leftColor||ne.White(),this.rightColor=e.rightColor||ne.Black(),e.isEnabled===!1&&(this.isEnabled=!1)}clone(){const e=new tu;return Ci.DeepCopy(this,e),e}equals(e){return e&&this.bias===e.bias&&this.power===e.power&&this.leftColor.equals(e.leftColor)&&this.rightColor.equals(e.rightColor)&&this.isEnabled===e.isEnabled}serialize(){return{isEnabled:this.isEnabled,leftColor:this.leftColor.asArray(),rightColor:this.rightColor.asArray(),bias:this.bias,power:this.power}}static Parse(e){return new tu({isEnabled:e.isEnabled,leftColor:ne.FromArray(e.leftColor),rightColor:ne.FromArray(e.rightColor),bias:e.bias,power:e.power||1})}}Me._FresnelParametersParser=tu.Parse;class yt{}yt.BindSceneUniformBuffer=Lm;yt.PrepareDefinesForMergedUV=Um;yt.BindTextureMatrix=Gm;yt.GetFogState=Cy;yt.PrepareDefinesForMisc=ly;yt.PrepareDefinesForCamera=_y;yt.PrepareDefinesForFrameBoundValues=uy;yt.PrepareDefinesForBones=Py;yt.PrepareDefinesForMorphTargets=Ey;yt.PrepareDefinesForBakedVertexAnimation=pM;yt.PrepareDefinesForAttributes=cy;yt.PrepareDefinesForMultiview=zm;yt.PrepareDefinesForOIT=mM;yt.PrepareDefinesForPrePass=my;yt.PrepareDefinesForLight=Wm;yt.PrepareDefinesForLights=mu;yt.PrepareUniformsAndSamplersForLight=$m;yt.PrepareUniformsAndSamplersList=py;yt.HandleFallbacksForShadows=hy;yt.PrepareAttributesForMorphTargetsInfluencers=_M;yt.PrepareAttributesForMorphTargets=gM;yt.PrepareAttributesForBakedVertexAnimation=ey;yt.PrepareAttributesForBones=dy;yt.PrepareAttributesForInstances=fy;yt.PushAttributesForInstances=qn;yt.BindLightProperties=xM;yt.BindLight=Hm;yt.BindLights=_u;yt.BindFogParameters=gu;yt.BindBonesParameters=Yn;yt.BindMorphTargetParameters=Ns;yt.BindLogDepth=qa;const qh="colorPixelShader",VT=`#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
#define VERTEXCOLOR
varying vec4 vColor;
#else
uniform vec4 color;
#endif
#include<clipPlaneFragmentDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
gl_FragColor=vColor;
#else
gl_FragColor=color;
#endif
#include<fogFragment>(color,gl_FragColor)
#define CUSTOM_FRAGMENT_MAIN_END
}`;P.ShadersStore[qh]||(P.ShadersStore[qh]=VT);const HN={name:qh,shader:VT},jN=Object.freeze(Object.defineProperty({__proto__:null,colorPixelShader:HN},Symbol.toStringTag,{value:"Module"})),Qh="colorVertexShader",kT=`attribute vec3 position;
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#ifdef FOG
uniform mat4 view;
#endif
#include<instancesDeclaration>
uniform mat4 viewProjection;
#ifdef MULTIVIEW
uniform mat4 viewProjectionR;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#ifdef VERTEXCOLOR
vec4 colorUpdated=color;
#endif
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}
#else
gl_Position=viewProjection*worldPos;
#endif
#include<clipPlaneVertex>
#include<fogVertex>
#include<vertexColorMixing>
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStore[Qh]||(P.ShadersStore[Qh]=kT);const YN={name:Qh,shader:kT},XN=Object.freeze(Object.defineProperty({__proto__:null,colorVertexShader:YN},Symbol.toStringTag,{value:"Module"}));class Ai extends hr{get doubleSided(){return this._twoSidedLighting}set doubleSided(e){this._twoSidedLighting!==e&&(this._twoSidedLighting=e,this.backFaceCulling=!e,this._markAllSubMeshesAsTexturesDirty())}constructor(e,t){super(e,t),this.maxSimultaneousLights=4,this.disableLighting=!1,this.invertNormalMapX=!1,this.invertNormalMapY=!1,this.emissiveColor=new ne(0,0,0),this.occlusionStrength=1,this.useLightmapAsShadowmap=!1,this._useAlphaFromAlbedoTexture=!0,this._useAmbientInGrayScale=!0}getClassName(){return"PBRBaseSimpleMaterial"}}C([F(),Ue("_markAllSubMeshesAsLightsDirty")],Ai.prototype,"maxSimultaneousLights",void 0);C([F(),Ue("_markAllSubMeshesAsLightsDirty")],Ai.prototype,"disableLighting",void 0);C([Mi(),Ue("_markAllSubMeshesAsTexturesDirty","_reflectionTexture")],Ai.prototype,"environmentTexture",void 0);C([F(),Ue("_markAllSubMeshesAsTexturesDirty")],Ai.prototype,"invertNormalMapX",void 0);C([F(),Ue("_markAllSubMeshesAsTexturesDirty")],Ai.prototype,"invertNormalMapY",void 0);C([Mi(),Ue("_markAllSubMeshesAsTexturesDirty","_bumpTexture")],Ai.prototype,"normalTexture",void 0);C([ir("emissive"),Ue("_markAllSubMeshesAsTexturesDirty")],Ai.prototype,"emissiveColor",void 0);C([Mi(),Ue("_markAllSubMeshesAsTexturesDirty")],Ai.prototype,"emissiveTexture",void 0);C([F(),Ue("_markAllSubMeshesAsTexturesDirty","_ambientTextureStrength")],Ai.prototype,"occlusionStrength",void 0);C([Mi(),Ue("_markAllSubMeshesAsTexturesDirty","_ambientTexture")],Ai.prototype,"occlusionTexture",void 0);C([F(),Ue("_markAllSubMeshesAsTexturesDirty","_alphaCutOff")],Ai.prototype,"alphaCutOff",void 0);C([F()],Ai.prototype,"doubleSided",null);C([Mi(),Ue("_markAllSubMeshesAsTexturesDirty",null)],Ai.prototype,"lightmapTexture",void 0);C([F(),Ue("_markAllSubMeshesAsTexturesDirty")],Ai.prototype,"useLightmapAsShadowmap",void 0);class Os extends Ai{constructor(e,t){super(e,t),this._useRoughnessFromMetallicTextureAlpha=!1,this._useRoughnessFromMetallicTextureGreen=!0,this._useMetallnessFromMetallicTextureBlue=!0,this.metallic=1,this.roughness=1}getClassName(){return"PBRMetallicRoughnessMaterial"}clone(e){const t=Me.Clone(()=>new Os(e,this.getScene()),this);return t.id=e,t.name=e,this.clearCoat.copyTo(t.clearCoat),this.anisotropy.copyTo(t.anisotropy),this.brdf.copyTo(t.brdf),this.sheen.copyTo(t.sheen),this.subSurface.copyTo(t.subSurface),t}serialize(){const e=Me.Serialize(this);return e.customType="BABYLON.PBRMetallicRoughnessMaterial",this.clearCoat.doNotSerialize||(e.clearCoat=this.clearCoat.serialize()),this.anisotropy.doNotSerialize||(e.anisotropy=this.anisotropy.serialize()),this.brdf.doNotSerialize||(e.brdf=this.brdf.serialize()),this.sheen.doNotSerialize||(e.sheen=this.sheen.serialize()),this.subSurface.doNotSerialize||(e.subSurface=this.subSurface.serialize()),this.iridescence.doNotSerialize||(e.iridescence=this.iridescence.serialize()),e}static Parse(e,t,i){const r=Me.Parse(()=>new Os(e.name,t),e,t,i);return e.clearCoat&&r.clearCoat.parse(e.clearCoat,t,i),e.anisotropy&&r.anisotropy.parse(e.anisotropy,t,i),e.brdf&&r.brdf.parse(e.brdf,t,i),e.sheen&&r.sheen.parse(e.sheen,t,i),e.subSurface&&r.subSurface.parse(e.subSurface,t,i),e.iridescence&&r.iridescence.parse(e.iridescence,t,i),r}}C([ir(),Ue("_markAllSubMeshesAsTexturesDirty","_albedoColor")],Os.prototype,"baseColor",void 0);C([Mi(),Ue("_markAllSubMeshesAsTexturesDirty","_albedoTexture")],Os.prototype,"baseTexture",void 0);C([F(),Ue("_markAllSubMeshesAsTexturesDirty")],Os.prototype,"metallic",void 0);C([F(),Ue("_markAllSubMeshesAsTexturesDirty")],Os.prototype,"roughness",void 0);C([Mi(),Ue("_markAllSubMeshesAsTexturesDirty","_metallicTexture")],Os.prototype,"metallicRoughnessTexture",void 0);B("BABYLON.PBRMetallicRoughnessMaterial",Os);class ws extends Ai{get useMicroSurfaceFromReflectivityMapAlpha(){return this._useMicroSurfaceFromReflectivityMapAlpha}constructor(e,t){super(e,t),this._useMicroSurfaceFromReflectivityMapAlpha=!0}getClassName(){return"PBRSpecularGlossinessMaterial"}clone(e){const t=Me.Clone(()=>new ws(e,this.getScene()),this);return t.id=e,t.name=e,this.clearCoat.copyTo(t.clearCoat),this.anisotropy.copyTo(t.anisotropy),this.brdf.copyTo(t.brdf),this.sheen.copyTo(t.sheen),this.subSurface.copyTo(t.subSurface),t}serialize(){const e=Me.Serialize(this);return e.customType="BABYLON.PBRSpecularGlossinessMaterial",this.clearCoat.doNotSerialize||(e.clearCoat=this.clearCoat.serialize()),this.anisotropy.doNotSerialize||(e.anisotropy=this.anisotropy.serialize()),this.brdf.doNotSerialize||(e.brdf=this.brdf.serialize()),this.sheen.doNotSerialize||(e.sheen=this.sheen.serialize()),this.subSurface.doNotSerialize||(e.subSurface=this.subSurface.serialize()),this.iridescence.doNotSerialize||(e.iridescence=this.iridescence.serialize()),e}static Parse(e,t,i){const r=Me.Parse(()=>new ws(e.name,t),e,t,i);return e.clearCoat&&r.clearCoat.parse(e.clearCoat,t,i),e.anisotropy&&r.anisotropy.parse(e.anisotropy,t,i),e.brdf&&r.brdf.parse(e.brdf,t,i),e.sheen&&r.sheen.parse(e.sheen,t,i),e.subSurface&&r.subSurface.parse(e.subSurface,t,i),e.iridescence&&r.iridescence.parse(e.iridescence,t,i),r}}C([ir("diffuse"),Ue("_markAllSubMeshesAsTexturesDirty","_albedoColor")],ws.prototype,"diffuseColor",void 0);C([Mi(),Ue("_markAllSubMeshesAsTexturesDirty","_albedoTexture")],ws.prototype,"diffuseTexture",void 0);C([ir("specular"),Ue("_markAllSubMeshesAsTexturesDirty","_reflectivityColor")],ws.prototype,"specularColor",void 0);C([F(),Ue("_markAllSubMeshesAsTexturesDirty","_microSurface")],ws.prototype,"glossiness",void 0);C([Mi(),Ue("_markAllSubMeshesAsTexturesDirty","_reflectivityTexture")],ws.prototype,"specularGlossinessTexture",void 0);B("BABYLON.PBRSpecularGlossinessMaterial",ws);var zS;(function(a){a[a.GLSL=0]="GLSL",a[a.WGSL=1]="WGSL"})(zS||(zS={}));class Pa extends Vr{constructor(e,t,i=null){if(super(t),!!e)if(this._textureMatrix=$.Identity(),this.name=e,this.url=e,this._onLoad=i,this._texture=this._getFromCache(e,!0),this._texture)this._triggerOnLoad();else{const r=this.getScene();r?r.useDelayedTextureLoading?this.delayLoadState=4:this._loadTexture():this._loadTexture()}}_triggerOnLoad(){this._onLoad&&this._onLoad()}getTextureMatrix(){return this._textureMatrix}_load3dlTexture(){const e=this._getEngine();let t;e._features.support3DTextures?t=e.createRawTexture3D(null,1,1,1,5,!1,!1,2,null,0):t=e.createRawTexture(null,1,1,5,!1,!1,2,null,0),this._texture=t,this._texture.isReady=!1,this.isCube=!1,this.is3D=e._features.support3DTextures,this.wrapU=0,this.wrapV=0,this.wrapR=0,this.anisotropicFilteringLevel=1;const i=s=>{if(typeof s!="string")return;let n=null,o=null,l;const u=s.split(`
`);let c=0,h=0,d=0,f=0,p=0;for(let g=0;g<u.length;g++){if(l=u[g],!Pa._NoneEmptyLineRegex.test(l)||l.indexOf("#")===0)continue;const _=l.split(" ");if(c===0){c=_.length,n=new Uint8Array(c*c*c*4),o=new Float32Array(c*c*c*4);continue}if(c!=0){const S=Math.max(parseInt(_[0]),0),b=Math.max(parseInt(_[1]),0),y=Math.max(parseInt(_[2]),0);p=Math.max(S,p),p=Math.max(b,p),p=Math.max(y,p);const T=(h+f*c+d*c*c)*4;o&&(o[T+0]=S,o[T+1]=b,o[T+2]=y),d++,d%c==0&&(f++,d=0,f%c==0&&(h++,f=0))}}if(o&&n)for(let g=0;g<o.length;g++)if(g>0&&(g+1)%4===0)n[g]=255;else{const _=o[g];n[g]=_/p*255}t.is3D?(t.updateSize(c,c,c),e.updateRawTexture3D(t,n,5,!1)):(t.updateSize(c*c,c),e.updateRawTexture(t,n,5,!1)),t.isReady=!0,this._triggerOnLoad()},r=this.getScene();return r?r._loadFile(this.url,i):e._loadFile(this.url,i),this._texture}_loadTexture(){if(this.url){const e=this.url.toLocaleLowerCase();(e.endsWith(".3dl")||e.startsWith("blob:"))&&this._load3dlTexture()}}clone(){const e=new Pa(this.url,this.getScene()||this._getEngine());return e.level=this.level,e}delayLoad(){this.delayLoadState===4&&(this.delayLoadState=1,this._texture=this._getFromCache(this.url,!0),this._texture||this._loadTexture())}static Parse(e,t){let i=null;return e.name&&!e.isRenderTarget&&(i=new Pa(e.name,t),i.name=e.name,i.level=e.level),i}serialize(){if(!this.name)return null;const e={};return e.name=this.name,e.level=this.level,e.customType="BABYLON.ColorGradingTexture",e}}Pa._NoneEmptyLineRegex=/\S+/;B("BABYLON.ColorGradingTexture",Pa);class Yo extends Vr{constructor(e,t,i,r=!1,s=!0,n=null,o=null,l=!1){if(super(t),this._onLoad=null,this._onError=null,!e)throw new Error("Image url is not set");this._coordinatesMode=Y.CUBIC_MODE,this.name=e,this.url=e,this._size=i,this._supersample=l,this._noMipmap=r,this.gammaSpace=s,this._onLoad=n,this._onError=o,this.hasAlpha=!1,this.isCube=!0,this._texture=this._getFromCache(e,this._noMipmap,void 0,void 0,void 0,this.isCube),this._texture?n&&(this._texture.isReady?ae.SetImmediate(()=>n()):this._texture.onLoadedObservable.add(n)):t.useDelayedTextureLoading?this.delayLoadState=4:this._loadImage(()=>this._loadTexture(),this._onError)}_loadImage(e,t){const i=this.getScene();if(!i)return;const r=i.getEngine().createRawCubeTexture(null,this._size,4,i.getEngine().getCaps().textureFloat?1:7,!this._noMipmap,!1,3);r.generateMipMaps=!this._noMipmap,i.addPendingData(r),r.url=this.url,r.isReady=!1,i.getEngine()._internalTexturesCache.push(r),this._texture=r,SM(this.url,s=>{this._width=s.width,this._height=s.height;let n;vM()?(n=document.createElement("canvas"),n.width=this._width,n.height=this._height):n=new OffscreenCanvas(this._width,this._height);const o=n.getContext("2d");o.drawImage(s,0,0);const l=o.getImageData(0,0,s.width,s.height);this._buffer=l.data.buffer,n.remove&&n.remove(),e()},(s,n)=>{i.removePendingData(r),t&&t(`${this.getClassName()} could not be loaded`,n)},i?i.offlineProvider:null)}_loadTexture(){const e=this.getScene(),t=()=>{const s=this._getFloat32ArrayFromArrayBuffer(this._buffer),n=XM.ConvertPanoramaToCubemap(s,this._width,this._height,this._size,this._supersample),o=[];for(let l=0;l<6;l++){const u=n[Yo._FacesMapping[l]];o.push(u)}return o};if(!e)return;const i=t(),r=this._texture;e.getEngine().updateRawCubeTexture(r,i,r.format,r.type,r.invertY),r.isReady=!0,e.removePendingData(r),r.onLoadedObservable.notifyObservers(r),r.onLoadedObservable.clear(),this._onLoad&&this._onLoad()}_getFloat32ArrayFromArrayBuffer(e){const t=new DataView(e),i=new Float32Array(e.byteLength*3/4);let r=0;for(let s=0;s<e.byteLength;s++)(s+1)%4!==0&&(i[r++]=t.getUint8(s)/255);return i}getClassName(){return"EquiRectangularCubeTexture"}clone(){const e=this.getScene();if(!e)return this;const t=new Yo(this.url,e,this._size,this._noMipmap,this.gammaSpace);return t.level=this.level,t.wrapU=this.wrapU,t.wrapV=this.wrapV,t.coordinatesIndex=this.coordinatesIndex,t.coordinatesMode=this.coordinatesMode,t}}Yo._FacesMapping=["right","left","up","down","front","back"];class z_ extends Vr{constructor(e,t,i){if(super(i.scene||i.engine),this.onLoadObservable=new j,!(!t||!i.engine&&!i.scene)){if(i={...z_._DefaultOptions,...i},this._generateMipMaps=i.generateMipMaps,this._samplingMode=i.samplingMode,this._textureMatrix=$.Identity(),this._format=i.format,this.name=e,this.element=t,this._isVideo=!!t.getVideoPlaybackQuality,this._isVideo){const r=this._engine,s=r==null?void 0:r.createExternalTexture;s&&(this._externalTexture=s.call(r,t))}this.anisotropicFilteringLevel=1,this._createInternalTexture()}}_createInternalTexture(){let e=0,t=0;this._isVideo?(e=this.element.videoWidth,t=this.element.videoHeight):(e=this.element.width,t=this.element.height);const i=this._getEngine();i&&(this._texture=i.createDynamicTexture(e,t,this._generateMipMaps,this._samplingMode),this._texture.format=this._format),this.update()}getTextureMatrix(){return this._textureMatrix}update(e=null){const t=this._getEngine();if(this._texture==null||t==null)return;const i=this.isReady();if(this._isVideo){const r=this.element;if(r.readyState<r.HAVE_CURRENT_DATA)return;t.updateVideoTexture(this._texture,this._externalTexture?this._externalTexture:r,e===null?!0:e)}else{const r=this.element;t.updateDynamicTexture(this._texture,r,e===null?!0:e,!1,this._format)}!i&&this.isReady()&&this.onLoadObservable.notifyObservers(this)}dispose(){this.onLoadObservable.clear(),super.dispose()}}z_._DefaultOptions={generateMipMaps:!1,samplingMode:2,format:5,engine:null,scene:null};class Zs extends Kt{get isSupported(){var e;return((e=this._engine)==null?void 0:e.getCaps().drawBuffersExtension)??!1}get textures(){return this._textures}get count(){return this._count}get depthTexture(){return this._textures[this._textures.length-1]}set wrapU(e){if(this._textures)for(let t=0;t<this._textures.length;t++)this._textures[t].wrapU=e}set wrapV(e){if(this._textures)for(let t=0;t<this._textures.length;t++)this._textures[t].wrapV=e}constructor(e,t,i,r,s,n){const o=s&&s.generateMipMaps?s.generateMipMaps:!1,l=s&&s.generateDepthTexture?s.generateDepthTexture:!1,u=s&&s.depthTextureFormat?s.depthTextureFormat:15,c=!s||s.doNotChangeAspectRatio===void 0?!0:s.doNotChangeAspectRatio,h=s&&s.drawOnlyOnFirstAttachmentByDefault?s.drawOnlyOnFirstAttachmentByDefault:!1;if(super(e,t,r,o,c,void 0,void 0,void 0,void 0,void 0,void 0,void 0,!0),!this.isSupported){this.dispose();return}this._textureNames=n;const d=[],f=[],p=[],g=[],_=[],S=[],b=[],y=[];this._initTypes(i,d,f,p,g,_,S,b,y,s);const T=!s||s.generateDepthBuffer===void 0?!0:s.generateDepthBuffer,v=!s||s.generateStencilBuffer===void 0?!1:s.generateStencilBuffer,E=s&&s.samples?s.samples:1;this._multiRenderTargetOptions={samplingModes:f,generateMipMaps:o,generateDepthBuffer:T,generateStencilBuffer:v,generateDepthTexture:l,depthTextureFormat:u,types:d,textureCount:i,useSRGBBuffers:p,samples:E,formats:g,targetTypes:_,faceIndex:S,layerIndex:b,layerCounts:y,labels:n,label:e},this._count=i,this._drawOnlyOnFirstAttachmentByDefault=h,i>0&&(this._createInternalTextures(),this._createTextures(n))}_initTypes(e,t,i,r,s,n,o,l,u,c){for(let h=0;h<e;h++)c&&c.types&&c.types[h]!==void 0?t.push(c.types[h]):t.push(c&&c.defaultType?c.defaultType:0),c&&c.samplingModes&&c.samplingModes[h]!==void 0?i.push(c.samplingModes[h]):i.push(Y.BILINEAR_SAMPLINGMODE),c&&c.useSRGBBuffers&&c.useSRGBBuffers[h]!==void 0?r.push(c.useSRGBBuffers[h]):r.push(!1),c&&c.formats&&c.formats[h]!==void 0?s.push(c.formats[h]):s.push(5),c&&c.targetTypes&&c.targetTypes[h]!==void 0?n.push(c.targetTypes[h]):n.push(3553),c&&c.faceIndex&&c.faceIndex[h]!==void 0?o.push(c.faceIndex[h]):o.push(0),c&&c.layerIndex&&c.layerIndex[h]!==void 0?l.push(c.layerIndex[h]):l.push(0),c&&c.layerCounts&&c.layerCounts[h]!==void 0?u.push(c.layerCounts[h]):u.push(1)}_createInternaTextureIndexMapping(){const e={},t=[];if(!this._renderTarget)return t;const i=this._renderTarget.textures;for(let r=0;r<i.length;r++){const s=i[r];if(!s)continue;const n=e[s.uniqueId];n!==void 0?t[r]=n:e[s.uniqueId]=r}return t}_rebuild(e=!1,t=!1,i){if(this._count<1||e)return;const r=this._createInternaTextureIndexMapping();this.releaseInternalTextures(),this._createInternalTextures(),t&&(this._releaseTextures(),this._createTextures(i));const s=this._renderTarget.textures;for(let n=0;n<s.length;n++){const o=this._textures[n];r[n]!==void 0&&this._renderTarget.setTexture(s[r[n]],n),o._texture=s[n],o._texture&&(o._noMipmap=!o._texture.useMipMaps,o._useSRGBBuffer=o._texture._useSRGBBuffer)}this.samples!==1&&this._renderTarget.setSamples(this.samples,!this._drawOnlyOnFirstAttachmentByDefault,!0)}_createInternalTextures(){this._renderTarget=this._getEngine().createMultipleRenderTarget(this._size,this._multiRenderTargetOptions,!this._drawOnlyOnFirstAttachmentByDefault),this._texture=this._renderTarget.texture}_releaseTextures(){if(this._textures)for(let e=0;e<this._textures.length;e++)this._textures[e]._texture=null,this._textures[e].dispose()}_createTextures(e){const t=this._renderTarget.textures;this._textures=[];for(let i=0;i<t.length;i++){const r=new Y(null,this.getScene());e!=null&&e[i]&&(r.name=e[i]),r._texture=t[i],r._texture&&(r._noMipmap=!r._texture.useMipMaps,r._useSRGBBuffer=r._texture._useSRGBBuffer),this._textures.push(r)}}setInternalTexture(e,t,i=!0){var r;if(this.renderTarget&&(t===0&&(this._texture=e),this.renderTarget.setTexture(e,t,i),this.textures[t]||(this.textures[t]=new Y(null,this.getScene()),this.textures[t].name=((r=this._textureNames)==null?void 0:r[t])??this.textures[t].name),this.textures[t]._texture=e,this.textures[t]._noMipmap=!e.useMipMaps,this.textures[t]._useSRGBBuffer=e._useSRGBBuffer,this._count=this.renderTarget.textures?this.renderTarget.textures.length:0,this._multiRenderTargetOptions.types&&(this._multiRenderTargetOptions.types[t]=e.type),this._multiRenderTargetOptions.samplingModes&&(this._multiRenderTargetOptions.samplingModes[t]=e.samplingMode),this._multiRenderTargetOptions.useSRGBBuffers&&(this._multiRenderTargetOptions.useSRGBBuffers[t]=e._useSRGBBuffer),this._multiRenderTargetOptions.targetTypes&&this._multiRenderTargetOptions.targetTypes[t]!==-1)){let s=0;e.is2DArray?s=35866:e.isCube?s=34067:e.is3D?s=32879:s=3553,this._multiRenderTargetOptions.targetTypes[t]=s}}setLayerAndFaceIndex(e,t=-1,i=-1){!this.textures[e]||!this.renderTarget||(this._multiRenderTargetOptions.layerIndex&&(this._multiRenderTargetOptions.layerIndex[e]=t),this._multiRenderTargetOptions.faceIndex&&(this._multiRenderTargetOptions.faceIndex[e]=i),this.renderTarget.setLayerAndFaceIndex(e,t,i))}setLayerAndFaceIndices(e,t){this.renderTarget&&(this._multiRenderTargetOptions.layerIndex=e,this._multiRenderTargetOptions.faceIndex=t,this.renderTarget.setLayerAndFaceIndices(e,t))}get samples(){return this._samples}set samples(e){this._renderTarget?this._samples=this._renderTarget.setSamples(e):this._samples=e}resize(e){this._processSizeParameter(e),this._rebuild(!1,void 0,this._textureNames)}updateCount(e,t,i){this._multiRenderTargetOptions.textureCount=e,this._count=e;const r=[],s=[],n=[],o=[],l=[],u=[],c=[],h=[];this._textureNames=i,this._initTypes(e,r,s,n,o,l,u,c,h,t),this._multiRenderTargetOptions.types=r,this._multiRenderTargetOptions.samplingModes=s,this._multiRenderTargetOptions.useSRGBBuffers=n,this._multiRenderTargetOptions.formats=o,this._multiRenderTargetOptions.targetTypes=l,this._multiRenderTargetOptions.faceIndex=u,this._multiRenderTargetOptions.layerIndex=c,this._multiRenderTargetOptions.layerCounts=h,this._multiRenderTargetOptions.labels=i,this._rebuild(!1,!0,i)}_unbindFrameBuffer(e,t){this._renderTarget&&e.unBindMultiColorAttachmentFramebuffer(this._renderTarget,this.isCube,()=>{this.onAfterRenderObservable.notifyObservers(t)})}dispose(e=!1){this._releaseTextures(),e?this._texture=null:this.releaseInternalTextures(),super.dispose()}releaseInternalTextures(){var t,i;const e=(t=this._renderTarget)==null?void 0:t.textures;if(e){for(let r=e.length-1;r>=0;r--)this._textures[r]._texture=null;(i=this._renderTarget)==null||i.dispose(),this._renderTarget=null}}}class US{constructor(e,t,i){this.id=e,this.scale=t,this.offset=i}}class Fr{constructor(e,t,i,r){return this.name=e,this.meshes=t,this.scene=r,this.options=i,this.options.map=this.options.map??["ambientTexture","bumpTexture","diffuseTexture","emissiveTexture","lightmapTexture","opacityTexture","reflectionTexture","refractionTexture","specularTexture"],this.options.uvsIn=this.options.uvsIn??N.UVKind,this.options.uvsOut=this.options.uvsOut??N.UVKind,this.options.layout=this.options.layout??Fr.LAYOUT_STRIP,this.options.layout===Fr.LAYOUT_COLNUM&&(this.options.colnum=this.options.colnum??8),this.options.updateInputMeshes=this.options.updateInputMeshes??!0,this.options.disposeSources=this.options.disposeSources??!0,this._expecting=0,this.options.fillBlanks=this.options.fillBlanks??!0,this.options.fillBlanks===!0&&(this.options.customFillColor=this.options.customFillColor??"black"),this.options.frameSize=this.options.frameSize??256,this.options.paddingRatio=this.options.paddingRatio??.0115,this._paddingValue=Math.ceil(this.options.frameSize*this.options.paddingRatio),this._paddingValue%2!==0&&this._paddingValue++,this.options.paddingMode=this.options.paddingMode??Fr.SUBUV_WRAP,this.options.paddingMode===Fr.SUBUV_COLOR&&(this.options.paddingColor=this.options.paddingColor??new xe(0,0,0,1)),this.sets={},this.frames=[],this}_createFrames(e){const t=this._calculateSize(),i=new Q(1,1).divide(t);let r=0;const s=this._expecting,n=this.meshes.length,o=Object.keys(this.sets);for(let d=0;d<o.length;d++){const f=o[d],p=new Is(this.name+".TexturePack."+f+"Set",{width:t.x,height:t.y},this.scene,!0,Y.TRILINEAR_SAMPLINGMODE,5),g=p.getContext();g.fillStyle="rgba(0,0,0,0)",g.fillRect(0,0,t.x,t.y),p.update(!1),this.sets[f]=p}const l=this.options.frameSize||256,u=this._paddingValue,c=l+2*u,h=()=>{this._calculateMeshUVFrames(l,u,t,i,this.options.updateInputMeshes||!1)};for(let d=0;d<n;d++){const p=this.meshes[d].material;for(let g=0;g<o.length;g++){const _=new Is("temp",c,this.scene,!0),S=_.getContext(),b=this._getFrameOffset(d),y=()=>{r++,_.update(!1);const v=S.getImageData(0,0,c,c),E=this.sets[T];if(E.getContext().putImageData(v,t.x*b.x,t.y*b.y),_.dispose(),E.update(!1),r==s){h(),e();return}},T=o[g]||"_blank";if(!p||p[T]===null)S.fillStyle="rgba(0,0,0,0)",this.options.fillBlanks&&(S.fillStyle=this.options.customFillColor),S.fillRect(0,0,c,c),y();else{const v=p[T],E=new Image;v instanceof Is?E.src=v.getContext().canvas.toDataURL("image/png"):E.src=v.url,ae.SetCorsBehavior(E.src,E),E.onload=()=>{S.fillStyle="rgba(0,0,0,0)",S.fillRect(0,0,c,c),_.update(!1),S.setTransform(1,0,0,-1,0,0);const R=[0,0,1,0,1,1,0,1,-1,1,-1,0,-2,0,-1,1,-1];switch(this.options.paddingMode){case 0:for(let O=0;O<9;O++)S.drawImage(E,0,0,E.width,E.height,u+l*R[O],u+l*R[O+1]-c,l,l);break;case 1:for(let O=0;O<u;O++)S.drawImage(E,0,0,E.width,E.height,O+l*R[0],u-c,l,l),S.drawImage(E,0,0,E.width,E.height,u*2-O,u-c,l,l),S.drawImage(E,0,0,E.width,E.height,u,O-c,l,l),S.drawImage(E,0,0,E.width,E.height,u,u*2-O-c,l,l);S.drawImage(E,0,0,E.width,E.height,u+l*R[0],u+l*R[1]-c,l,l);break;case 2:S.fillStyle=(this.options.paddingColor||ne.Black()).toHexString(),S.fillRect(0,0,c,-c),S.clearRect(u,u,l,l),S.drawImage(E,0,0,E.width,E.height,u+l*R[0],u+l*R[1]-c,l,l);break}S.setTransform(1,0,0,1,0,0),y()}}}}}_calculateSize(){const e=this.meshes.length||0,t=this.options.frameSize||0,i=this._paddingValue||0;switch(this.options.layout){case 0:return new Q(t*e+2*i*e,t+2*i);case 1:{const r=Math.max(2,Math.ceil(Math.sqrt(e))),s=t*r+2*i*r;return new Q(s,s)}case 2:{const r=this.options.colnum||1,s=Math.max(1,Math.ceil(e/r));return new Q(t*r+2*i*r,t*s+2*i*s)}}return Q.Zero()}_calculateMeshUVFrames(e,t,i,r,s){const n=this.meshes.length;for(let o=0;o<n;o++){const l=this.meshes[o],u=new Q(e/i.x,e/i.y),c=r.clone().scale(t),d=this._getFrameOffset(o).add(c),f=new US(o,u,d);this.frames.push(f),s&&(this._updateMeshUV(l,o),this._updateTextureReferences(l))}}_getFrameOffset(e){const t=this.meshes.length;let i,r,s;switch(this.options.layout){case 0:return i=1/t,new Q(e*i,0);case 1:{const n=Math.max(2,Math.ceil(Math.sqrt(t)));return r=Math.floor(e/n),s=e-r*n,i=1/n,new Q(s*i,r*i)}case 2:{const n=this.options.colnum||1,o=Math.max(1,Math.ceil(t/n));return s=Math.floor(e/o),r=e-s*o,i=new Q(1/n,1/o),new Q(s*i.x,r*i.y)}}return Q.Zero()}_updateMeshUV(e,t){const i=this.frames[t],r=e.getVerticesData(this.options.uvsIn||N.UVKind),s=[];let n=0;r.length&&(n=r.length||0);for(let o=0;o<n;o+=2)s.push(r[o]*i.scale.x+i.offset.x,r[o+1]*i.scale.y+i.offset.y);e.setVerticesData(this.options.uvsOut||N.UVKind,s)}_updateTextureReferences(e,t=!1){const i=e.material,r=Object.keys(this.sets),s=n=>{n.dispose&&n.dispose()};for(let n=0;n<r.length;n++){const o=r[n];if(t)i[o]!==null&&s(i[o]),i[o]=this.sets[o];else{if(!i)return;i[o]!==null&&(s(i[o]),i[o]=this.sets[o])}}}setMeshToFrame(e,t,i=!1){this._updateMeshUV(e,t),i&&this._updateTextureReferences(e,!0)}processAsync(){return new Promise((e,t)=>{try{if(this.meshes.length===0){e();return}let i=0;const r=s=>{if(i++,this.options.map){for(let n=0;n<this.options.map.length;n++){const o=this.options.map[n];s[o]!==null&&(this.sets[this.options.map[n]]||(this.sets[this.options.map[n]]=!0),this._expecting++)}i===this.meshes.length&&this._createFrames(e)}};for(let s=0;s<this.meshes.length;s++){const n=this.meshes[s],o=n.material;if(!o){if(i++,i===this.meshes.length)return this._createFrames(e);continue}o.forceCompilationAsync(n).then(()=>{r(o)})}}catch(i){return t(i)}})}dispose(){const e=Object.keys(this.sets);for(let t=0;t<e.length;t++){const i=e[t];this.sets[i].dispose()}}download(e="png",t=1){setTimeout(()=>{const i={name:this.name,sets:{},options:{},frames:[]},r=Object.keys(this.sets),s=Object.keys(this.options);try{for(let l=0;l<r.length;l++){const u=r[l],c=this.sets[u];i.sets[u]=c.getContext().canvas.toDataURL("image/"+e,t)}for(let l=0;l<s.length;l++){const u=s[l];i.options[u]=this.options[u]}for(let l=0;l<this.frames.length;l++){const u=this.frames[l];i.frames.push(u.scale.x,u.scale.y,u.offset.x,u.offset.y)}}catch(l){L.Warn("Unable to download: "+l);return}const n="data:text/json;charset=utf-8,"+encodeURIComponent(JSON.stringify(i,null,4)),o=document.createElement("a");o.setAttribute("href",n),o.setAttribute("download",this.name+"_texurePackage.json"),document.body.appendChild(o),o.click(),o.remove()},0)}updateFromJSON(e){try{const t=JSON.parse(e);this.name=t.name;const i=Object.keys(t.options);for(let s=0;s<i.length;s++)this.options[i[s]]=t.options[i[s]];for(let s=0;s<t.frames.length;s+=4){const n=new US(s/4,new Q(t.frames[s],t.frames[s+1]),new Q(t.frames[s+2],t.frames[s+3]));this.frames.push(n)}const r=Object.keys(t.sets);for(let s=0;s<r.length;s++){const n=new Y(t.sets[r[s]],this.scene,!1,!1);this.sets[r[s]]=n}}catch(t){L.Warn("Unable to update from JSON: "+t)}}}Fr.LAYOUT_STRIP=0;Fr.LAYOUT_POWER2=1;Fr.LAYOUT_COLNUM=2;Fr.SUBUV_WRAP=0;Fr.SUBUV_EXTEND=1;Fr.SUBUV_COLOR=2;const GS="noisePixelShader",ZN=`uniform float brightness;uniform float persistence;uniform float timeScale;varying vec2 vUV;vec2 hash22(vec2 p)
{p=p*mat2(127.1,311.7,269.5,183.3);p=-1.0+2.0*fract(sin(p)*43758.5453123);return sin(p*6.283+timeScale);}
float interpolationNoise(vec2 p)
{vec2 pi=floor(p);vec2 pf=p-pi;vec2 w=pf*pf*(3.-2.*pf);float f00=dot(hash22(pi+vec2(.0,.0)),pf-vec2(.0,.0));float f01=dot(hash22(pi+vec2(.0,1.)),pf-vec2(.0,1.));float f10=dot(hash22(pi+vec2(1.0,0.)),pf-vec2(1.0,0.));float f11=dot(hash22(pi+vec2(1.0,1.)),pf-vec2(1.0,1.));float xm1=mix(f00,f10,w.x);float xm2=mix(f01,f11,w.x);float ym=mix(xm1,xm2,w.y); 
return ym;}
float perlinNoise2D(float x,float y)
{float sum=0.0;float frequency=0.0;float amplitude=0.0;for(int i=0; i<OCTAVES; i++)
{frequency=pow(2.0,float(i));amplitude=pow(persistence,float(i));sum=sum+interpolationNoise(vec2(x*frequency,y*frequency))*amplitude;}
return sum;}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{float x=abs(vUV.x);float y=abs(vUV.y);float noise=brightness+(1.0-brightness)*perlinNoise2D(x,y);gl_FragColor=vec4(noise,noise,noise,1.0);}
`;P.ShadersStore[GS]||(P.ShadersStore[GS]=ZN);class iu extends er{constructor(e,t=256,i=ze.LastCreatedScene,r,s){super(e,t,"noise",i,r,s),this.time=0,this.brightness=.2,this.octaves=3,this.persistence=.8,this.animationSpeedFactor=1,this.autoClear=!1,this._updateShaderUniforms()}_updateShaderUniforms(){const e=this.getScene();e&&(this.time+=e.getAnimationRatio()*this.animationSpeedFactor*.01,this.setFloat("brightness",this.brightness),this.setFloat("persistence",this.persistence),this.setFloat("timeScale",this.time))}_getDefines(){return"#define OCTAVES "+(this.octaves|0)}render(e){this._updateShaderUniforms(),super.render(e)}serialize(){const e={};return e.customType="BABYLON.NoiseProceduralTexture",e.brightness=this.brightness,e.octaves=this.octaves,e.persistence=this.persistence,e.animationSpeedFactor=this.animationSpeedFactor,e.size=this.getSize().width,e.generateMipMaps=this._generateMipMaps,e.time=this.time,e}clone(){const e=this.getSize(),t=new iu(this.name,e.width,this.getScene(),this._fallbackTexture?this._fallbackTexture:void 0,this._generateMipMaps);return t.hasAlpha=this.hasAlpha,t.level=this.level,t.coordinatesMode=this.coordinatesMode,t.brightness=this.brightness,t.octaves=this.octaves,t.persistence=this.persistence,t.animationSpeedFactor=this.animationSpeedFactor,t.time=this.time,t}static Parse(e,t){const i=new iu(e.name,e.size,t,void 0,e.generateMipMaps);return i.brightness=e.brightness,i.octaves=e.octaves,i.persistence=e.persistence,i.animationSpeedFactor=e.animationSpeedFactor,i.time=e.time??0,i}}B("BABYLON.NoiseProceduralTexture",iu);const Kh="proceduralVertexShader",zT=`attribute position: vec2f;varying vPosition: vec2f;varying vUV: vec2f;const madd: vec2f= vec2f(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
vertexOutputs.vPosition=input.position;vertexOutputs.vUV=input.position*madd+madd;vertexOutputs.position= vec4f(input.position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStoreWGSL[Kh]||(P.ShadersStoreWGSL[Kh]=zT);const qN={name:Kh,shader:zT},WS=Object.freeze(Object.defineProperty({__proto__:null,proceduralVertexShaderWGSL:qN},Symbol.toStringTag,{value:"Module"})),Jh="proceduralVertexShader",UT=`attribute vec2 position;varying vec2 vPosition;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vPosition=position;vUV=position*madd+madd;gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStore[Jh]||(P.ShadersStore[Jh]=UT);const QN={name:Jh,shader:UT},$S=Object.freeze(Object.defineProperty({__proto__:null,proceduralVertexShader:QN},Symbol.toStringTag,{value:"Module"})),ed="hdrFilteringVertexShader",GT=`attribute vec2 position;varying vec3 direction;uniform vec3 up;uniform vec3 right;uniform vec3 front;
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
mat3 view=mat3(up,right,front);direction=view*vec3(position,1.0);gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStore[ed]||(P.ShadersStore[ed]=GT);const KN={name:ed,shader:GT},JN=Object.freeze(Object.defineProperty({__proto__:null,hdrFilteringVertexShader:KN},Symbol.toStringTag,{value:"Module"})),td="hdrFilteringPixelShader",WT=`#include<helperFunctions>
#include<importanceSampling>
#include<pbrBRDFFunctions>
#include<hdrFilteringFunctions>
uniform float alphaG;uniform samplerCube inputTexture;uniform vec2 vFilteringInfo;uniform float hdrScale;varying vec3 direction;void main() {vec3 color=radiance(alphaG,inputTexture,direction,vFilteringInfo);gl_FragColor=vec4(color*hdrScale,1.0);}`;P.ShadersStore[td]||(P.ShadersStore[td]=WT);const eF={name:td,shader:WT},tF=Object.freeze(Object.defineProperty({__proto__:null,hdrFilteringPixelShader:eF},Symbol.toStringTag,{value:"Module"})),id="hdrFilteringVertexShader",$T=`attribute position: vec2f;varying direction: vec3f;uniform up: vec3f;uniform right: vec3f;uniform front: vec3f;
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
var view: mat3x3f= mat3x3f(uniforms.up,uniforms.right,uniforms.front);vertexOutputs.direction=view*vec3f(input.position,1.0);vertexOutputs.position= vec4f(input.position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStoreWGSL[id]||(P.ShadersStoreWGSL[id]=$T);const iF={name:id,shader:$T},rF=Object.freeze(Object.defineProperty({__proto__:null,hdrFilteringVertexShaderWGSL:iF},Symbol.toStringTag,{value:"Module"})),rd="hdrFilteringPixelShader",HT=`#include<helperFunctions>
#include<importanceSampling>
#include<pbrBRDFFunctions>
#include<hdrFilteringFunctions>
uniform alphaG: f32;var inputTextureSampler: sampler;var inputTexture: texture_cube<f32>;uniform vFilteringInfo: vec2f;uniform hdrScale: f32;varying direction: vec3f;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var color: vec3f=radiance(uniforms.alphaG,inputTexture,inputTextureSampler,input.direction,uniforms.vFilteringInfo);fragmentOutputs.color= vec4f(color*uniforms.hdrScale,1.0);}`;P.ShadersStoreWGSL[rd]||(P.ShadersStoreWGSL[rd]=HT);const sF={name:rd,shader:HT},nF=Object.freeze(Object.defineProperty({__proto__:null,hdrFilteringPixelShaderWGSL:sF},Symbol.toStringTag,{value:"Module"})),sd="hdrIrradianceFilteringVertexShader",jT=`attribute vec2 position;varying vec3 direction;uniform vec3 up;uniform vec3 right;uniform vec3 front;
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
mat3 view=mat3(up,right,front);direction=view*vec3(position,1.0);gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStore[sd]||(P.ShadersStore[sd]=jT);const aF={name:sd,shader:jT},oF=Object.freeze(Object.defineProperty({__proto__:null,hdrIrradianceFilteringVertexShader:aF},Symbol.toStringTag,{value:"Module"})),nd="hdrIrradianceFilteringPixelShader",YT=`#include<helperFunctions>
#include<importanceSampling>
#include<pbrBRDFFunctions>
#include<hdrFilteringFunctions>
uniform samplerCube inputTexture;
#ifdef IBL_CDF_FILTERING
uniform sampler2D icdfTexture;
#endif
uniform vec2 vFilteringInfo;uniform float hdrScale;varying vec3 direction;void main() {vec3 color=irradiance(inputTexture,direction,vFilteringInfo
#ifdef IBL_CDF_FILTERING
,icdfTexture
#endif
);gl_FragColor=vec4(color*hdrScale,1.0);}`;P.ShadersStore[nd]||(P.ShadersStore[nd]=YT);const lF={name:nd,shader:YT},uF=Object.freeze(Object.defineProperty({__proto__:null,hdrIrradianceFilteringPixelShader:lF},Symbol.toStringTag,{value:"Module"})),ad="hdrIrradianceFilteringVertexShader",XT=`attribute position: vec2f;varying direction: vec3f;uniform up: vec3f;uniform right: vec3f;uniform front: vec3f;
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
var view: mat3x3f= mat3x3f(uniforms.up,uniforms.right,uniforms.front);vertexOutputs.direction=view*vec3f(input.position,1.0);vertexOutputs.position= vec4f(input.position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStoreWGSL[ad]||(P.ShadersStoreWGSL[ad]=XT);const cF={name:ad,shader:XT},hF=Object.freeze(Object.defineProperty({__proto__:null,hdrIrradianceFilteringVertexShaderWGSL:cF},Symbol.toStringTag,{value:"Module"})),od="hdrIrradianceFilteringPixelShader",ZT=`#include<helperFunctions>
#include<importanceSampling>
#include<pbrBRDFFunctions>
#include<hdrFilteringFunctions>
var inputTextureSampler: sampler;var inputTexture: texture_cube<f32>;
#ifdef IBL_CDF_FILTERING
var icdfTextureSampler: sampler;var icdfTexture: texture_2d<f32>;
#endif
uniform vFilteringInfo: vec2f;uniform hdrScale: f32;varying direction: vec3f;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var color: vec3f=irradiance(inputTexture,inputTextureSampler,input.direction,uniforms.vFilteringInfo
#ifdef IBL_CDF_FILTERING
,icdfTexture,icdfTextureSampler
#endif
);fragmentOutputs.color= vec4f(color*uniforms.hdrScale,1.0);}`;P.ShadersStoreWGSL[od]||(P.ShadersStoreWGSL[od]=ZT);const dF={name:od,shader:ZT},fF=Object.freeze(Object.defineProperty({__proto__:null,hdrIrradianceFilteringPixelShaderWGSL:dF},Symbol.toStringTag,{value:"Module"}));var HS;(function(a){a[a.Uniform=0]="Uniform",a[a.Attribute=1]="Attribute",a[a.Varying=2]="Varying",a[a.Undefined=3]="Undefined"})(HS||(HS={}));class dt extends ka{constructor(e,t,i,r,s){super(e,t,i),this._blockType=r,this._blockName=s,this.needDualDirectionValidation=!0}checkCompatibilityState(e){return e instanceof dt&&e._blockName===this._blockName?0:1}createCustomInputBlock(){return[new this._blockType(this._blockName),this.name]}}class pF extends le{constructor(e){super(e,A.Vertex),this._isUnique=!0,this.registerInput("splatPosition",x.Vector3,!1,A.Vertex),this.registerInput("splatScale",x.Vector2,!0,A.Vertex),this.registerInput("world",x.Matrix,!1,A.Vertex),this.registerInput("view",x.Matrix,!1,A.Vertex),this.registerInput("projection",x.Matrix,!1,A.Vertex),this.registerOutput("splatVertex",x.Vector4,A.Vertex)}getClassName(){return"GaussianSplattingBlock"}get splatPosition(){return this._inputs[0]}get splatScale(){return this._inputs[1]}get world(){return this._inputs[2]}get view(){return this._inputs[3]}get projection(){return this._inputs[4]}get splatVertex(){return this._outputs[0]}initialize(e){e._excludeVariableName("focal"),e._excludeVariableName("invViewport")}_buildBlock(e){if(super._buildBlock(e),e.target===A.Fragment)return;const t=`//${this.name}`;e._emitFunctionFromInclude("gaussianSplattingVertexDeclaration",t),e._emitFunctionFromInclude("gaussianSplatting",t),e._emitUniformFromString("focal",x.Vector2),e._emitUniformFromString("invViewport",x.Vector2),e.attributes.push(N.PositionKind),e.sharedData.nodeMaterial.backFaceCulling=!1;const i=this.splatPosition,r=this.splatScale,s=this.world,n=this.view,o=this.projection,l=this.splatVertex;let c=`vec2${e.fSuffix}(1.,1.)`;r.isConnected&&(c=r.associatedVariableName);let h="position",d="";return e.shaderLanguage===1&&(h="input.position",d=", uniforms.focal, uniforms.invViewport"),e.compilationString+=`${e._declareOutput(l)} = gaussianSplatting(${h}, ${i.associatedVariableName}, ${c}, covA, covB, ${s.associatedVariableName}, ${n.associatedVariableName}, ${o.associatedVariableName}${d});
`,this}}B("BABYLON.GaussianSplattingBlock",pF);class mF extends le{constructor(e){super(e,A.Fragment),this._isUnique=!1,this.registerInput("splatColor",x.Color4,!1,A.Fragment),this.registerOutput("rgba",x.Color4,A.Fragment)}getClassName(){return"GaussianBlock"}get splatColor(){return this._inputs[0]}get rgba(){return this._outputs[0]}initialize(e){e._excludeVariableName("vPosition")}_buildBlock(e){if(super._buildBlock(e),e.target===A.Vertex)return;const t=`//${this.name}`;e._emitFunctionFromInclude("clipPlaneFragmentDeclaration",t),e._emitFunctionFromInclude("logDepthDeclaration",t),e._emitFunctionFromInclude("fogFragmentDeclaration",t),e._emitFunctionFromInclude("gaussianSplattingFragmentDeclaration",t),e._emitVaryingFromString("vPosition",x.Vector2);const i=this.splatColor,r=this._outputs[0];return e.shaderLanguage===1?e.compilationString+=`${e._declareOutput(r)} = gaussianColor(${i.associatedVariableName}, input.vPosition);
`:e.compilationString+=`${e._declareOutput(r)} = gaussianColor(${i.associatedVariableName});
`,this}}B("BABYLON.GaussianBlock",mF);class _F extends le{constructor(e){super(e,A.Vertex),this._isUnique=!0,this.registerInput("splatIndex",x.Float,!1,A.Vertex),this.registerOutput("splatPosition",x.Vector3,A.Vertex),this.registerOutput("splatColor",x.Color4,A.Vertex)}getClassName(){return"SplatReaderBlock"}get splatIndex(){return this._inputs[0]}get splatPosition(){return this._outputs[0]}get splatColor(){return this._outputs[1]}initialize(e){e._excludeVariableName("covA"),e._excludeVariableName("covB"),e._excludeVariableName("vPosition"),e._excludeVariableName("covariancesATexture"),e._excludeVariableName("covariancesBTexture"),e._excludeVariableName("centersTexture"),e._excludeVariableName("colorsTexture"),e._excludeVariableName("dataTextureSize")}bind(e,t,i){if(!i)return;const r=i.getScene();bM.BindEffect(i,e,r)}_buildBlock(e){if(super._buildBlock(e),e.target===A.Fragment)return;e.sharedData.bindableBlocks.push(this);const t=`//${this.name}`;e._emit2DSampler("covariancesATexture"),e._emit2DSampler("covariancesBTexture"),e._emit2DSampler("centersTexture"),e._emit2DSampler("colorsTexture"),e._emitFunctionFromInclude("gaussianSplattingVertexDeclaration",t),e._emitFunctionFromInclude("gaussianSplatting",t),e._emitVaryingFromString("vPosition",x.Vector2),e._emitUniformFromString("dataTextureSize",x.Vector2);const i=this.splatIndex,r=this.splatPosition,s=this.splatColor,n=e._getFreeVariableName("splat");return e.shaderLanguage===1?(e.compilationString+=`var ${n}: Splat = readSplat(${i.associatedVariableName}, uniforms.dataTextureSize);
`,e.compilationString+=`var covA: vec3f = splat.covA.xyz; var covB: vec3f = vec3f(splat.covA.w, splat.covB.xy);
`,e.compilationString+=`vertexOutputs.vPosition = input.position;
`):(e.compilationString+=`Splat ${n} = readSplat(${i.associatedVariableName});
`,e.compilationString+=`vec3 covA = splat.covA.xyz; vec3 covB = vec3(splat.covA.w, splat.covB.xy);
`,e.compilationString+=`vPosition = position;
`),e.compilationString+=`${e._declareOutput(r)} = ${n}.center.xyz;
`,e.compilationString+=`${e._declareOutput(s)} = ${n}.color;
`,this}}B("BABYLON.SplatReaderBlock",_F);class gF extends le{constructor(e){super(e,A.Vertex),this.registerInput("matricesIndices",x.Vector4),this.registerInput("matricesWeights",x.Vector4),this.registerInput("matricesIndicesExtra",x.Vector4,!0),this.registerInput("matricesWeightsExtra",x.Vector4,!0),this.registerInput("world",x.Matrix),this.registerOutput("output",x.Matrix)}initialize(e){e._excludeVariableName("boneSampler"),e._excludeVariableName("boneTextureWidth"),e._excludeVariableName("mBones"),e._excludeVariableName("BonesPerMesh"),this._initShaderSourceAsync(e.shaderLanguage)}async _initShaderSourceAsync(e){this._codeIsReady=!1,e===1?await Promise.all([k(()=>import("./vertexColorMixing-CmRbdHdF.js").then(t=>t.f),__vite__mapDeps([0,1,2,3,4,5])),k(()=>import("./vertexColorMixing-CmRbdHdF.js").then(t=>t.k),__vite__mapDeps([0,1,2,3,4,5]))]):await Promise.all([k(()=>import("./bumpVertex-CO1be_N_.js").then(t=>t.g),__vite__mapDeps([6,1,2,3,4,5])),k(()=>import("./bumpVertex-CO1be_N_.js").then(t=>t.n),__vite__mapDeps([6,1,2,3,4,5]))]),this._codeIsReady=!0,this.onCodeIsReadyObservable.notifyObservers(this)}getClassName(){return"BonesBlock"}get matricesIndices(){return this._inputs[0]}get matricesWeights(){return this._inputs[1]}get matricesIndicesExtra(){return this._inputs[2]}get matricesWeightsExtra(){return this._inputs[3]}get world(){return this._inputs[4]}get output(){return this._outputs[0]}autoConfigure(e,t=()=>!0){if(!this.matricesIndices.isConnected){let i=e.getInputBlockByPredicate(r=>r.isAttribute&&r.name==="matricesIndices"&&t(r));i||(i=new Ee("matricesIndices"),i.setAsAttribute("matricesIndices")),i.output.connectTo(this.matricesIndices)}if(!this.matricesWeights.isConnected){let i=e.getInputBlockByPredicate(r=>r.isAttribute&&r.name==="matricesWeights"&&t(r));i||(i=new Ee("matricesWeights"),i.setAsAttribute("matricesWeights")),i.output.connectTo(this.matricesWeights)}if(!this.world.isConnected){let i=e.getInputBlockByPredicate(r=>r.systemValue===De.World&&t(r));i||(i=new Ee("world"),i.setAsSystemValue(De.World)),i.output.connectTo(this.world)}}provideFallbacks(e,t){e&&e.useBones&&e.computeBonesUsingShaders&&e.skeleton&&t.addCPUSkinningFallback(0,e)}bind(e,t,i){Yn(i,e)}prepareDefines(e,t,i){i._areAttributesDirty&&Py(e,i)}_buildBlock(e){super._buildBlock(e),e.sharedData.blocksWithFallbacks.push(this),e.sharedData.forcedBindableBlocks.push(this),e.sharedData.blocksWithDefines.push(this),e.uniforms.push("boneTextureWidth"),e.uniforms.push("mBones"),e.samplers.push("boneSampler");const t=`//${this.name}`;e._emitFunctionFromInclude("bonesDeclaration",t,{removeAttributes:!0,removeUniforms:!1,removeVaryings:!0,removeIfDef:!1});const i=e._getFreeVariableName("influence");e.compilationString+=e._emitCodeFromInclude("bonesVertex",t,{replaceStrings:[{search:/finalWorld=finalWorld\*influence;/,replace:""},{search:/influence/gm,replace:i}]});const r=this._outputs[0],s=this.world;return e.compilationString+=`#if NUM_BONE_INFLUENCERS>0
`,e.compilationString+=e._declareOutput(r)+` = ${s.associatedVariableName} * ${i};
`,e.compilationString+=`#else
`,e.compilationString+=e._declareOutput(r)+` = ${s.associatedVariableName};
`,e.compilationString+=`#endif
`,this}}B("BABYLON.BonesBlock",gF);class xF extends le{constructor(e){super(e,A.Vertex),this.registerInput("world0",x.Vector4),this.registerInput("world1",x.Vector4),this.registerInput("world2",x.Vector4),this.registerInput("world3",x.Vector4),this.registerInput("world",x.Matrix,!0),this.registerOutput("output",x.Matrix),this.registerOutput("instanceID",x.Float)}getClassName(){return"InstancesBlock"}get world0(){return this._inputs[0]}get world1(){return this._inputs[1]}get world2(){return this._inputs[2]}get world3(){return this._inputs[3]}get world(){return this._inputs[4]}get output(){return this._outputs[0]}get instanceID(){return this._outputs[1]}autoConfigure(e,t=()=>!0){if(!this.world0.connectedPoint){let i=e.getInputBlockByPredicate(r=>r.isAttribute&&r.name==="world0"&&t(r));i||(i=new Ee("world0"),i.setAsAttribute("world0")),i.output.connectTo(this.world0)}if(!this.world1.connectedPoint){let i=e.getInputBlockByPredicate(r=>r.isAttribute&&r.name==="world1"&&t(r));i||(i=new Ee("world1"),i.setAsAttribute("world1")),i.output.connectTo(this.world1)}if(!this.world2.connectedPoint){let i=e.getInputBlockByPredicate(r=>r.isAttribute&&r.name==="world2"&&t(r));i||(i=new Ee("world2"),i.setAsAttribute("world2")),i.output.connectTo(this.world2)}if(!this.world3.connectedPoint){let i=e.getInputBlockByPredicate(r=>r.isAttribute&&r.name==="world3"&&t(r));i||(i=new Ee("world3"),i.setAsAttribute("world3")),i.output.connectTo(this.world3)}if(!this.world.connectedPoint){let i=e.getInputBlockByPredicate(r=>r.isAttribute&&r.name==="world"&&t(r));i||(i=new Ee("world"),i.setAsSystemValue(De.World)),i.output.connectTo(this.world)}this.world.define="!INSTANCES || THIN_INSTANCES"}prepareDefines(e,t,i,r=!1,s){let n=!1;i.INSTANCES!==r&&(i.setValue("INSTANCES",r),n=!0),s&&i.THIN_INSTANCES!==!!(s!=null&&s.getRenderingMesh().hasThinInstances)&&(i.setValue("THIN_INSTANCES",!!(s!=null&&s.getRenderingMesh().hasThinInstances)),n=!0),n&&i.markAsUnprocessed()}_buildBlock(e){super._buildBlock(e);const t=e.sharedData.scene.getEngine();e.sharedData.blocksWithDefines.push(this);const i=this._outputs[0],r=this._outputs[1],s=this.world0,n=this.world1,o=this.world2,l=this.world3;let u="mat4",c="gl_InstanceID",h="float";return e.shaderLanguage===1&&(u="mat4x4f",c="vertexInputs.instanceIndex",h="f32"),e.compilationString+=`#ifdef INSTANCES
`,e.compilationString+=e._declareOutput(i)+` = ${u}(${s.associatedVariableName}, ${n.associatedVariableName}, ${o.associatedVariableName}, ${l.associatedVariableName});
`,e.compilationString+=`#ifdef THIN_INSTANCES
`,e.compilationString+=`${i.associatedVariableName} = ${this.world.associatedVariableName} * ${i.associatedVariableName};
`,e.compilationString+=`#endif
`,t._caps.canUseGLInstanceID?e.compilationString+=e._declareOutput(r)+` = ${h}(${c});
`:e.compilationString+=e._declareOutput(r)+` = 0.0;
`,e.compilationString+=`#else
`,e.compilationString+=e._declareOutput(i)+` = ${this.world.associatedVariableName};
`,e.compilationString+=e._declareOutput(r)+` = 0.0;
`,e.compilationString+=`#endif
`,this}}B("BABYLON.InstancesBlock",xF);class qT extends le{constructor(e){super(e,A.Vertex),this.registerInput("position",x.Vector3),this.registerInput("normal",x.Vector3),this.registerInput("tangent",x.AutoDetect),this.tangent.addExcludedConnectionPointFromAllowedTypes(x.Color4|x.Vector4|x.Vector3),this.registerInput("uv",x.Vector2),this.registerInput("uv2",x.Vector2),this.registerInput("color",x.Color4),this.registerOutput("positionOutput",x.Vector3),this.registerOutput("normalOutput",x.Vector3),this.registerOutput("tangentOutput",x.Vector4),this.registerOutput("uvOutput",x.Vector2),this.registerOutput("uv2Output",x.Vector2),this.registerOutput("colorOutput",x.Color4)}getClassName(){return"MorphTargetsBlock"}get position(){return this._inputs[0]}get normal(){return this._inputs[1]}get tangent(){return this._inputs[2]}get uv(){return this._inputs[3]}get uv2(){return this._inputs[4]}get color(){return this._inputs[5]}get positionOutput(){return this._outputs[0]}get normalOutput(){return this._outputs[1]}get tangentOutput(){return this._outputs[2]}get uvOutput(){return this._outputs[3]}get uv2Output(){return this._outputs[4]}get colorOutput(){return this._outputs[5]}initialize(e){e._excludeVariableName("morphTargetInfluences"),this._initShaderSourceAsync(e.shaderLanguage)}async _initShaderSourceAsync(e){this._codeIsReady=!1,e===1?await Promise.all([k(()=>import("./vertexColorMixing-CmRbdHdF.js").then(t=>t.j),__vite__mapDeps([0,1,2,3,4,5])),k(()=>import("./vertexColorMixing-CmRbdHdF.js").then(t=>t.h),__vite__mapDeps([0,1,2,3,4,5])),k(()=>import("./vertexColorMixing-CmRbdHdF.js").then(t=>t.i),__vite__mapDeps([0,1,2,3,4,5])),k(()=>import("./vertexColorMixing-CmRbdHdF.js").then(t=>t.g),__vite__mapDeps([0,1,2,3,4,5]))]):await Promise.all([k(()=>import("./bumpVertex-CO1be_N_.js").then(t=>t.k),__vite__mapDeps([6,1,2,3,4,5])),k(()=>import("./bumpVertex-CO1be_N_.js").then(t=>t.i),__vite__mapDeps([6,1,2,3,4,5])),k(()=>import("./bumpVertex-CO1be_N_.js").then(t=>t.j),__vite__mapDeps([6,1,2,3,4,5])),k(()=>import("./bumpVertex-CO1be_N_.js").then(t=>t.h),__vite__mapDeps([6,1,2,3,4,5]))]),this._codeIsReady=!0,this.onCodeIsReadyObservable.notifyObservers(this)}autoConfigure(e,t=()=>!0){if(!this.position.isConnected){let i=e.getInputBlockByPredicate(r=>r.isAttribute&&r.name==="position"&&t(r));i||(i=new Ee("position"),i.setAsAttribute()),i.output.connectTo(this.position)}if(!this.normal.isConnected){let i=e.getInputBlockByPredicate(r=>r.isAttribute&&r.name==="normal"&&t(r));i||(i=new Ee("normal"),i.setAsAttribute("normal")),i.output.connectTo(this.normal)}if(!this.tangent.isConnected){let i=e.getInputBlockByPredicate(r=>r.isAttribute&&r.name==="tangent"&&t(r));i||(i=new Ee("tangent"),i.setAsAttribute("tangent")),i.output.connectTo(this.tangent)}if(!this.uv.isConnected){let i=e.getInputBlockByPredicate(r=>r.isAttribute&&r.name==="uv"&&t(r));i||(i=new Ee("uv"),i.setAsAttribute("uv")),i.output.connectTo(this.uv)}if(!this.uv2.isConnected){let i=e.getInputBlockByPredicate(r=>r.isAttribute&&r.name==="uv2"&&t(r));i||(i=new Ee("uv2"),i.setAsAttribute("uv2")),i.output.connectTo(this.uv2)}if(!this.color.isConnected){let i=e.getInputBlockByPredicate(r=>r.isAttribute&&r.name==="color"&&t(r));i||(i=new Ee("color"),i.setAsAttribute("color")),i.output.connectTo(this.color)}}prepareDefines(e,t,i){if(e.morphTargetManager){const r=e.morphTargetManager;r!=null&&r.isUsingTextureForTargets&&(r.numMaxInfluencers||r.numInfluencers)!==i.NUM_MORPH_INFLUENCERS&&i.markAsAttributesDirty()}i._areAttributesDirty&&Ey(e,i)}bind(e,t,i){i&&i.morphTargetManager&&i.morphTargetManager.numInfluencers>0&&(Ns(i,e),i.morphTargetManager.isUsingTextureForTargets&&i.morphTargetManager._bind(e))}replaceRepeatableContent(e,t,i,r){const s=this.position,n=this.normal,o=this.tangent,l=this.uv,u=this.uv2,c=this.color,h=this.positionOutput,d=this.normalOutput,f=this.tangentOutput,p=this.uvOutput,g=this.uv2Output,_=this.colorOutput,S=e,b=r.NUM_MORPH_INFLUENCERS,y=i.morphTargetManager,T=y&&y.supportsPositions,v=y&&y.supportsNormals,E=y&&y.supportsTangents,R=y&&y.supportsUVs,O=y&&y.supportsUV2s,w=y&&y.supportsColors;let M="";y!=null&&y.isUsingTextureForTargets&&b>0&&(M+=`${S._declareLocalVar("vertexID",x.Float)};
`),M+=`#ifdef MORPHTARGETS
`;const G=S.shaderLanguage===1,H=G?"uniforms.":"";if(y!=null&&y.isUsingTextureForTargets)M+=`for (${G?"var":"int"} i = 0; i < NUM_MORPH_INFLUENCERS; i++) {
`,M+=`if (i >= ${H}morphTargetCount) { break; }
`,M+=`vertexID = ${G?"f32(vertexInputs.vertexIndex":"float(gl_VertexID"}) * ${H}morphTargetTextureInfo.x;
`,T&&(M+=`#ifdef MORPHTARGETS_POSITION
`,M+=`${h.associatedVariableName} += (readVector3FromRawSampler(i, vertexID) - ${s.associatedVariableName}) * ${H}morphTargetInfluences[i];
`,M+=`#endif
`),M+=`#ifdef MORPHTARGETTEXTURE_HASPOSITIONS
`,M+=`vertexID += 1.0;
`,M+=`#endif
`,v&&(M+=`#ifdef MORPHTARGETS_NORMAL
`,M+=`${d.associatedVariableName} += (readVector3FromRawSampler(i, vertexID) - ${n.associatedVariableName}) * ${H}morphTargetInfluences[i];
`,M+=`#endif
`),M+=`#ifdef MORPHTARGETTEXTURE_HASNORMALS
`,M+=`vertexID += 1.0;
`,M+=`#endif
`,R&&(M+=`#ifdef MORPHTARGETS_UV
`,M+=`${p.associatedVariableName} += (readVector3FromRawSampler(i, vertexID).xy - ${l.associatedVariableName}) * ${H}morphTargetInfluences[i];
`,M+=`#endif
`),M+=`#ifdef MORPHTARGETTEXTURE_HASUVS
`,M+=`vertexID += 1.0;
`,M+=`#endif
`,E&&(M+=`#ifdef MORPHTARGETS_TANGENT
`,M+=`${f.associatedVariableName}.xyz += (readVector3FromRawSampler(i, vertexID) - ${o.associatedVariableName}.xyz) * ${H}morphTargetInfluences[i];
`,o.type===x.Vector4?M+=`${f.associatedVariableName}.w = ${o.associatedVariableName}.w;
`:M+=`${f.associatedVariableName}.w = 1.;
`,M+=`#endif
`),M+=`#ifdef MORPHTARGETTEXTURE_HASTANGENTS
`,M+=`vertexID += 1.0;
`,M+=`#endif
`,O&&(M+=`#ifdef MORPHTARGETS_UV2
`,M+=`${g.associatedVariableName} += (readVector3FromRawSampler(i, vertexID).xy - ${u.associatedVariableName}) * morphTargetInfluences[i];
`,M+=`#endif
`),M+=`#ifdef MORPHTARGETTEXTURE_HASUV2S
`,M+=`vertexID += 1.0;
`,M+=`#endif
`,w&&(M+=`#ifdef MORPHTARGETS_COLOR
`,M+=`${_.associatedVariableName} += (readVector4FromRawSampler(i, vertexID) - ${c.associatedVariableName}) * ${H}morphTargetInfluences[i];
`,M+=`#endif
`),M+=`}
`;else for(let q=0;q<b;q++)T&&(M+=`#ifdef MORPHTARGETS_POSITION
`,M+=`${h.associatedVariableName} += (position${q} - ${s.associatedVariableName}) * ${H}morphTargetInfluences[${q}];
`,M+=`#endif
`),v&&r.NORMAL&&(M+=`#ifdef MORPHTARGETS_NORMAL
`,M+=`${d.associatedVariableName} += (normal${q} - ${n.associatedVariableName}) * ${H}morphTargetInfluences[${q}];
`,M+=`#endif
`),R&&r.UV1&&(M+=`#ifdef MORPHTARGETS_UV
`,M+=`${p.associatedVariableName}.xy += (uv_${q} - ${l.associatedVariableName}.xy) * ${H}morphTargetInfluences[${q}];
`,M+=`#endif
`),E&&r.TANGENT&&(M+=`#ifdef MORPHTARGETS_TANGENT
`,M+=`${f.associatedVariableName}.xyz += (tangent${q} - ${o.associatedVariableName}.xyz) * ${H}morphTargetInfluences[${q}];
`,o.type===x.Vector4?M+=`${f.associatedVariableName}.w = ${o.associatedVariableName}.w;
`:M+=`${f.associatedVariableName}.w = 1.;
`,M+=`#endif
`),O&&r.UV2&&(M+=`#ifdef MORPHTARGETS_UV2
`,M+=`${g.associatedVariableName}.xy += (uv2_${q} - ${u.associatedVariableName}.xy) * morphTargetInfluences[${q}];
`,M+=`#endif
`),w&&r.VERTEXCOLOR_NME&&(M+=`#ifdef MORPHTARGETS_COLOR
`,M+=`${_.associatedVariableName} += (color${q} - ${c.associatedVariableName}) * ${H}morphTargetInfluences[${q}];
`,M+=`#endif
`);if(M+=`#endif
`,S.compilationString=S.compilationString.replace(this._repeatableContentAnchor,M),b>0)for(let q=0;q<b;q++)T&&S.attributes.push(N.PositionKind+q),v&&r.NORMAL&&S.attributes.push(N.NormalKind+q),E&&r.TANGENT&&S.attributes.push(N.TangentKind+q),R&&r.UV1&&S.attributes.push(N.UVKind+"_"+q),O&&r.UV2&&S.attributes.push(N.UV2Kind+"_"+q),w&&r.VERTEXCOLOR_NME&&S.attributes.push(N.ColorKind+q)}_buildBlock(e){super._buildBlock(e),e.sharedData.blocksWithDefines.push(this),e.sharedData.bindableBlocks.push(this),e.sharedData.repeatableContentBlocks.push(this);const t=this.position,i=this.normal,r=this.tangent,s=this.uv,n=this.uv2,o=this.color,l=this.positionOutput,u=this.normalOutput,c=this.tangentOutput,h=this.uvOutput,d=this.uv2Output,f=this.colorOutput,p=`//${this.name}`;return e.uniforms.push("morphTargetInfluences"),e.uniforms.push("morphTargetCount"),e.uniforms.push("morphTargetTextureInfo"),e.uniforms.push("morphTargetTextureIndices"),e.samplers.push("morphTargets"),e._emitFunctionFromInclude("morphTargetsVertexGlobalDeclaration",p),e._emitFunctionFromInclude("morphTargetsVertexDeclaration",p,{repeatKey:"maxSimultaneousMorphTargets"}),e.compilationString+=`${e._declareOutput(l)} = ${t.associatedVariableName};
`,e.compilationString+=`#ifdef NORMAL
`,e.compilationString+=`${e._declareOutput(u)} = ${i.associatedVariableName};
`,e.compilationString+=`#else
`,e.compilationString+=`${e._declareOutput(u)} = vec3(0., 0., 0.);
`,e.compilationString+=`#endif
`,e.compilationString+=`#ifdef TANGENT
`,e.compilationString+=`${e._declareOutput(c)} = ${r.associatedVariableName};
`,e.compilationString+=`#else
`,e.compilationString+=`${e._declareOutput(c)} = vec4(0., 0., 0., 0.);
`,e.compilationString+=`#endif
`,e.compilationString+=`#ifdef UV1
`,e.compilationString+=`${e._declareOutput(h)} = ${s.associatedVariableName};
`,e.compilationString+=`#else
`,e.compilationString+=`${e._declareOutput(h)} = vec2(0., 0.);
`,e.compilationString+=`#endif
`,e.compilationString+=`#ifdef UV2
`,e.compilationString+=`${e._declareOutput(d)} = ${n.associatedVariableName};
`,e.compilationString+=`#else
`,e.compilationString+=`${e._declareOutput(d)} = vec2(0., 0.);
`,e.compilationString+=`#endif
`,e.compilationString+=`#ifdef VERTEXCOLOR_NME
`,e.compilationString+=`${e._declareOutput(f)} = ${o.associatedVariableName};
`,e.compilationString+=`#else
`,e.compilationString+=`${e._declareOutput(f)} = vec4(0., 0., 0., 0.);
`,e.compilationString+=`#endif
`,this._repeatableContentAnchor=e._repeatableContentAnchor,e.compilationString+=this._repeatableContentAnchor,this}}B("BABYLON.MorphTargetsBlock",qT);class SF extends le{constructor(e){super(e,A.Vertex),this.registerInput("worldPosition",x.Vector4,!1,A.Vertex),this.registerOutput("direction",x.Vector3),this.registerOutput("color",x.Color3),this.registerOutput("intensity",x.Float),this.registerOutput("shadowBias",x.Float),this.registerOutput("shadowNormalBias",x.Float),this.registerOutput("shadowDepthScale",x.Float),this.registerOutput("shadowDepthRange",x.Vector2)}getClassName(){return"LightInformationBlock"}get worldPosition(){return this._inputs[0]}get direction(){return this._outputs[0]}get color(){return this._outputs[1]}get intensity(){return this._outputs[2]}get shadowBias(){return this._outputs[3]}get shadowNormalBias(){return this._outputs[4]}get shadowDepthScale(){return this._outputs[5]}get shadowDepthRange(){return this._outputs[6]}bind(e,t,i){if(!i)return;this.light&&this.light.isDisposed()&&(this.light=null);let r=this.light;const s=t.getScene();if(!r&&s.lights.length&&(r=this.light=s.lights[0],this._forcePrepareDefines=!0),!r||!r.isEnabled){e.setFloat3(this._lightDataUniformName,0,0,0),e.setFloat4(this._lightColorUniformName,0,0,0,0);return}r.transferToNodeMaterialEffect(e,this._lightDataUniformName),e.setColor4(this._lightColorUniformName,r.diffuse,r.intensity);const n=r.getShadowGenerator();if((this.shadowBias.hasEndpoints||this.shadowNormalBias.hasEndpoints||this.shadowDepthScale.hasEndpoints)&&(n?e.setFloat3(this._lightShadowUniformName,n.bias,n.normalBias,n.depthScale):e.setFloat3(this._lightShadowUniformName,0,0,0)),this.shadowDepthRange)if(n&&s.activeCamera){const o=r;e.setFloat2(this._lightShadowExtraUniformName,o.getDepthMinZ(s.activeCamera),o.getDepthMinZ(s.activeCamera)+o.getDepthMaxZ(s.activeCamera))}else e.setFloat2(this._lightShadowExtraUniformName,0,0)}prepareDefines(e,t,i){if(!i._areLightsDirty&&!this._forcePrepareDefines)return;this._forcePrepareDefines=!1;const r=this.light;i.setValue(this._lightTypeDefineName,!!(r&&r instanceof yM),!0)}_buildBlock(e){super._buildBlock(e),e.sharedData.bindableBlocks.push(this),e.sharedData.blocksWithDefines.push(this);const t=this.direction,i=this.color,r=this.intensity,s=this.shadowBias,n=this.shadowNormalBias,o=this.shadowDepthScale,l=this.shadowDepthRange;this._lightDataUniformName=e._getFreeVariableName("lightData"),this._lightColorUniformName=e._getFreeVariableName("lightColor"),this._lightShadowUniformName=e._getFreeVariableName("shadowData"),this._lightShadowExtraUniformName=e._getFreeVariableName("shadowExtraData"),this._lightTypeDefineName=e._getFreeDefineName("LIGHTPOINTTYPE");const u=e.shaderLanguage===1?"uniforms.":"";return e._emitUniformFromString(this._lightDataUniformName,x.Vector3),e._emitUniformFromString(this._lightColorUniformName,x.Vector4),e.compilationString+=`#ifdef ${this._lightTypeDefineName}
`,e.compilationString+=e._declareOutput(t)+` = normalize(${this.worldPosition.associatedVariableName}.xyz - ${u}${this._lightDataUniformName});
`,e.compilationString+=`#else
`,e.compilationString+=e._declareOutput(t)+` = ${u}${this._lightDataUniformName};
`,e.compilationString+=`#endif
`,e.compilationString+=e._declareOutput(i)+` = ${u}${this._lightColorUniformName}.rgb;
`,e.compilationString+=e._declareOutput(r)+` = ${u}${this._lightColorUniformName}.a;
`,(s.hasEndpoints||n.hasEndpoints||o.hasEndpoints)&&(e._emitUniformFromString(this._lightShadowUniformName,x.Vector3),s.hasEndpoints&&(e.compilationString+=e._declareOutput(s)+` = ${u}${this._lightShadowUniformName}.x;
`),n.hasEndpoints&&(e.compilationString+=e._declareOutput(n)+` = ${u}${this._lightShadowUniformName}.y;
`),o.hasEndpoints&&(e.compilationString+=e._declareOutput(o)+` = ${u}${this._lightShadowUniformName}.z;
`)),l.hasEndpoints&&(e._emitUniformFromString(this._lightShadowExtraUniformName,x.Vector2),e.compilationString+=e._declareOutput(l)+` = ${this._lightShadowUniformName};
`),this}serialize(){const e=super.serialize();return this.light&&(e.lightId=this.light.id),e}_deserialize(e,t,i){super._deserialize(e,t,i),e.lightId&&(this.light=t.getLightById(e.lightId))}}B("BABYLON.LightInformationBlock",SF);class QT extends le{constructor(e){super(e,A.Fragment),this.convertInputToLinearSpace=!0,this.registerInput("color",x.AutoDetect),this.registerOutput("output",x.Color4),this.registerOutput("rgb",x.Color3),this._inputs[0].addExcludedConnectionPointFromAllowedTypes(x.Color3|x.Color4|x.Vector3|x.Vector4)}getClassName(){return"ImageProcessingBlock"}get color(){return this._inputs[0]}get output(){return this._outputs[0]}get rgb(){return this._outputs[1]}initialize(e){e._excludeVariableName("exposureLinear"),e._excludeVariableName("contrast"),e._excludeVariableName("vInverseScreenSize"),e._excludeVariableName("vignetteSettings1"),e._excludeVariableName("vignetteSettings2"),e._excludeVariableName("vCameraColorCurveNegative"),e._excludeVariableName("vCameraColorCurveNeutral"),e._excludeVariableName("vCameraColorCurvePositive"),e._excludeVariableName("txColorTransform"),e._excludeVariableName("colorTransformSettings"),e._excludeVariableName("ditherIntensity"),this._initShaderSourceAsync(e.shaderLanguage)}async _initShaderSourceAsync(e){this._codeIsReady=!1,e===1?await Promise.all([k(()=>import("./helperFunctions-Dt8Ez0m5.js"),__vite__mapDeps([7,1,2,3,4,5])),k(()=>import("./oitFragment-COwarqmx.js").then(t=>t.g),__vite__mapDeps([8,1,2,3,4,5])),k(()=>import("./oitFragment-COwarqmx.js").then(t=>t.k),__vite__mapDeps([8,1,2,3,4,5]))]):await Promise.all([k(()=>import("./pointsCloudSystem-2vcS-S4d.js").then(t=>t.h5),__vite__mapDeps([1,2,3,4,5])),k(()=>import("./oitFragment-C1qnXpVq.js").then(t=>t.h),__vite__mapDeps([9,1,2,3,4,5])),k(()=>import("./oitFragment-C1qnXpVq.js").then(t=>t.n),__vite__mapDeps([9,1,2,3,4,5]))]),this._codeIsReady=!0,this.onCodeIsReadyObservable.notifyObservers(this)}isReady(e,t,i){return!(i._areImageProcessingDirty&&t.imageProcessingConfiguration&&!t.imageProcessingConfiguration.isReady())}prepareDefines(e,t,i){i._areImageProcessingDirty&&t.imageProcessingConfiguration&&t.imageProcessingConfiguration.prepareDefines(i)}bind(e,t,i){i&&t.imageProcessingConfiguration&&t.imageProcessingConfiguration.bind(e)}_buildBlock(e){var n;super._buildBlock(e),e.sharedData.blocksWithDefines.push(this),e.sharedData.blockingBlocks.push(this),e.sharedData.bindableBlocks.push(this),e.uniforms.push("exposureLinear"),e.uniforms.push("contrast"),e.uniforms.push("vInverseScreenSize"),e.uniforms.push("vignetteSettings1"),e.uniforms.push("vignetteSettings2"),e.uniforms.push("vCameraColorCurveNegative"),e.uniforms.push("vCameraColorCurveNeutral"),e.uniforms.push("vCameraColorCurvePositive"),e.uniforms.push("txColorTransform"),e.uniforms.push("colorTransformSettings"),e.uniforms.push("ditherIntensity");const t=this.color,i=this._outputs[0],r=`//${this.name}`,s=e.shaderLanguage===1?"Vec3":"";return e._emitFunctionFromInclude("helperFunctions",r),e._emitFunctionFromInclude("imageProcessingDeclaration",r),e._emitFunctionFromInclude("imageProcessingFunctions",r),(n=t.connectedPoint)!=null&&n.isConnected&&(t.connectedPoint.type===x.Color4||t.connectedPoint.type===x.Vector4?e.compilationString+=`${e._declareOutput(i)} = ${t.associatedVariableName};
`:e.compilationString+=`${e._declareOutput(i)} = vec4${e.fSuffix}(${t.associatedVariableName}, 1.0);
`,e.compilationString+=`#ifdef IMAGEPROCESSINGPOSTPROCESS
`,this.convertInputToLinearSpace&&(e.compilationString+=`${i.associatedVariableName} = vec4${e.fSuffix}(toLinearSpace${s}(${t.associatedVariableName}.rgb), ${t.associatedVariableName}.a);
`),e.compilationString+=`#else
`,e.compilationString+=`#ifdef IMAGEPROCESSING
`,this.convertInputToLinearSpace&&(e.compilationString+=`${i.associatedVariableName} = vec4${e.fSuffix}(toLinearSpace${s}(${t.associatedVariableName}.rgb), ${t.associatedVariableName}.a);
`),e.compilationString+=`${i.associatedVariableName} = applyImageProcessing(${i.associatedVariableName});
`,e.compilationString+=`#endif
`,e.compilationString+=`#endif
`,this.rgb.hasEndpoints&&(e.compilationString+=e._declareOutput(this.rgb)+` = ${this.output.associatedVariableName}.xyz;
`)),this}_dumpPropertiesCode(){let e=super._dumpPropertiesCode();return e+=`${this._codeVariableName}.convertInputToLinearSpace = ${this.convertInputToLinearSpace};
`,e}serialize(){const e=super.serialize();return e.convertInputToLinearSpace=this.convertInputToLinearSpace,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.convertInputToLinearSpace=e.convertInputToLinearSpace??!0}}C([U("Convert input to linear space",0,"ADVANCED")],QT.prototype,"convertInputToLinearSpace",void 0);B("BABYLON.ImageProcessingBlock",QT);class so extends le{constructor(e){super(e,A.Fragment,!0),this.registerInput("normal",x.AutoDetect,!1),this.normal.addExcludedConnectionPointFromAllowedTypes(x.Color4|x.Vector4|x.Vector3),this.registerInput("tangent",x.Vector4,!1),this.registerInput("world",x.Matrix,!1),this.registerOutput("TBN",x.Object,A.Fragment,new dt("TBN",this,1,so,"TBNBlock")),this.registerOutput("row0",x.Vector3,A.Fragment),this.registerOutput("row1",x.Vector3,A.Fragment),this.registerOutput("row2",x.Vector3,A.Fragment)}getClassName(){return"TBNBlock"}initialize(e){e._excludeVariableName("tbnNormal"),e._excludeVariableName("tbnTangent"),e._excludeVariableName("tbnBitangent"),e._excludeVariableName("TBN")}get normal(){return this._inputs[0]}get tangent(){return this._inputs[1]}get world(){return this._inputs[2]}get TBN(){return this._outputs[0]}get row0(){return this._outputs[1]}get row1(){return this._outputs[2]}get row2(){return this._outputs[3]}get target(){return A.Fragment}set target(e){}autoConfigure(e,t=()=>!0){if(!this.world.isConnected){let i=e.getInputBlockByPredicate(r=>r.isSystemValue&&r.systemValue===De.World&&t(r));i||(i=new Ee("world"),i.setAsSystemValue(De.World)),i.output.connectTo(this.world)}if(!this.normal.isConnected){let i=e.getInputBlockByPredicate(r=>r.isAttribute&&r.name==="normal"&&t(r));i||(i=new Ee("normal"),i.setAsAttribute("normal")),i.output.connectTo(this.normal)}if(!this.tangent.isConnected){let i=e.getInputBlockByPredicate(r=>r.isAttribute&&r.name==="tangent"&&r.type===x.Vector4&&t(r));i||(i=new Ee("tangent"),i.setAsAttribute("tangent")),i.output.connectTo(this.tangent)}}prepareDefines(e,t,i){var u,c,h,d;const r=this.normal,s=this.tangent;let n=r.isConnected;(u=r.connectInputBlock)!=null&&u.isAttribute&&!e.isVerticesDataPresent((c=r.connectInputBlock)==null?void 0:c.name)&&(n=!1);let o=s.isConnected;(h=s.connectInputBlock)!=null&&h.isAttribute&&!e.isVerticesDataPresent((d=s.connectInputBlock)==null?void 0:d.name)&&(o=!1);const l=n&&o;i.setValue("TBNBLOCK",l,!0)}_buildBlock(e){super._buildBlock(e);const t=this.normal,i=this.tangent,r=this.world,s=this.TBN,n=this.row0,o=this.row1,l=this.row2,u=e.shaderLanguage===1,c=u?"mat3x3f":"mat3",h=u?"f":"";return e.target===A.Fragment&&(e.compilationString+=`
                // ${this.name}
                ${e._declareLocalVar("tbnNormal",x.Vector3)} = normalize(${t.associatedVariableName}).xyz;
                ${e._declareLocalVar("tbnTangent",x.Vector3)} = normalize(${i.associatedVariableName}.xyz);
                ${e._declareLocalVar("tbnBitangent",x.Vector3)} = cross(tbnNormal, tbnTangent) * ${i.associatedVariableName}.w;
                ${u?"var":"mat3"} ${s.associatedVariableName} = ${c}(${r.associatedVariableName}[0].xyz, ${r.associatedVariableName}[1].xyz, ${r.associatedVariableName}[2].xyz) * ${c}(tbnTangent, tbnBitangent, tbnNormal);
            `,n.hasEndpoints&&(e.compilationString+=e._declareOutput(n)+` = vec3${h}(${s.associatedVariableName}[0][0], ${s.associatedVariableName}[0][1], ${s.associatedVariableName}[0][2]);
`),o.hasEndpoints&&(e.compilationString+=e._declareOutput(o)+` = vec3${h}(${s.associatedVariableName}[1[0], ${s.associatedVariableName}[1][1], ${s.associatedVariableName}[1][2]);
`),l.hasEndpoints&&(e.compilationString+=e._declareOutput(l)+` = vec3${h}(${s.associatedVariableName}[2][0], ${s.associatedVariableName}[2][1], ${s.associatedVariableName}[2][2]);
`),e.sharedData.blocksWithDefines.push(this)),this}}B("BABYLON.TBNBlock",so);class hl extends le{constructor(e){super(e,A.Fragment),this._tangentSpaceParameterName="",this._tangentCorrectionFactorName="",this._worldMatrixName="",this.invertX=!1,this.invertY=!1,this.useParallaxOcclusion=!1,this.useObjectSpaceNormalMap=!1,this._isUnique=!0,this.registerInput("worldPosition",x.Vector4,!1),this.registerInput("worldNormal",x.Vector4,!1),this.registerInput("worldTangent",x.Vector4,!0),this.registerInput("uv",x.Vector2,!1),this.registerInput("normalMapColor",x.Color3,!1),this.registerInput("strength",x.Float,!1),this.registerInput("viewDirection",x.Vector3,!0),this.registerInput("parallaxScale",x.Float,!0),this.registerInput("parallaxHeight",x.Float,!0),this.registerInput("TBN",x.Object,!0,A.VertexAndFragment,new dt("TBN",this,0,so,"TBNBlock")),this.registerInput("world",x.Matrix,!0),this.registerOutput("output",x.Vector4),this.registerOutput("uvOffset",x.Vector2)}getClassName(){return"PerturbNormalBlock"}get worldPosition(){return this._inputs[0]}get worldNormal(){return this._inputs[1]}get worldTangent(){return this._inputs[2]}get uv(){return this._inputs[3]}get normalMapColor(){return this._inputs[4]}get strength(){return this._inputs[5]}get viewDirection(){return this._inputs[6]}get parallaxScale(){return this._inputs[7]}get parallaxHeight(){return this._inputs[8]}get TBN(){return this._inputs[9]}get world(){return this._inputs[10]}get output(){return this._outputs[0]}get uvOffset(){return this._outputs[1]}initialize(e){this._initShaderSourceAsync(e.shaderLanguage)}async _initShaderSourceAsync(e){this._codeIsReady=!1,e===1?await Promise.all([k(()=>import("./oitFragment-COwarqmx.js").then(t=>t.p),__vite__mapDeps([8,1,2,3,4,5])),k(()=>import("./oitFragment-COwarqmx.js").then(t=>t.n),__vite__mapDeps([8,1,2,3,4,5])),k(()=>import("./oitFragment-COwarqmx.js").then(t=>t.o),__vite__mapDeps([8,1,2,3,4,5]))]):await Promise.all([k(()=>import("./oitFragment-C1qnXpVq.js").then(t=>t.t),__vite__mapDeps([9,1,2,3,4,5])),k(()=>import("./oitFragment-C1qnXpVq.js").then(t=>t.p),__vite__mapDeps([9,1,2,3,4,5])),k(()=>import("./oitFragment-C1qnXpVq.js").then(t=>t.q),__vite__mapDeps([9,1,2,3,4,5]))]),this._codeIsReady=!0,this.onCodeIsReadyObservable.notifyObservers(this)}prepareDefines(e,t,i){const r=this.normalMapColor.connectedPoint._ownerBlock.samplerName,s=this.viewDirection.isConnected&&(this.useParallaxOcclusion&&r||!this.useParallaxOcclusion&&this.parallaxHeight.isConnected);i.setValue("BUMP",!0),i.setValue("PARALLAX",s,!0),i.setValue("PARALLAX_RHS",t.getScene().useRightHandedSystem,!0),i.setValue("PARALLAXOCCLUSION",this.useParallaxOcclusion,!0),i.setValue("OBJECTSPACE_NORMALMAP",this.useObjectSpaceNormalMap,!0)}bind(e,t,i){t.getScene()._mirroredCameraPosition?e.setFloat2(this._tangentSpaceParameterName,this.invertX?1:-1,this.invertY?1:-1):e.setFloat2(this._tangentSpaceParameterName,this.invertX?-1:1,this.invertY?-1:1),i&&(e.setFloat(this._tangentCorrectionFactorName,i.getWorldMatrix().determinant()<0?-1:1),this.useObjectSpaceNormalMap&&!this.world.isConnected&&e.setMatrix(this._worldMatrixName,i.getWorldMatrix()))}autoConfigure(e,t=()=>!0){if(!this.uv.isConnected){let i=e.getInputBlockByPredicate(r=>r.isAttribute&&r.name==="uv"&&t(r));i||(i=new Ee("uv"),i.setAsAttribute()),i.output.connectTo(this.uv)}if(!this.strength.isConnected){const i=new Ee("strength");i.value=1,i.output.connectTo(this.strength)}}_buildBlock(e){super._buildBlock(e);const t=`//${this.name}`,i=this.uv,r=this.worldPosition,s=this.worldNormal,n=this.worldTangent,o=e.shaderLanguage===1,l=o?"mat3x3f":"mat3",u=o?"f":"",c=o?"uniforms.":"",h=o?"fragmentInputs.":"";e.sharedData.blocksWithDefines.push(this),e.sharedData.bindableBlocks.push(this),this._tangentSpaceParameterName=e._getFreeDefineName("tangentSpaceParameter"),e._emitUniformFromString(this._tangentSpaceParameterName,x.Vector2),this._tangentCorrectionFactorName=e._getFreeDefineName("tangentCorrectionFactor"),e._emitUniformFromString(this._tangentCorrectionFactorName,x.Float),this._worldMatrixName=e._getFreeDefineName("perturbNormalWorldMatrix"),e._emitUniformFromString(this._worldMatrixName,x.Matrix);let d=null;this.normalMapColor.connectedPoint&&(d=this.normalMapColor.connectedPoint._ownerBlock.samplerName);const f=this.viewDirection.isConnected&&(this.useParallaxOcclusion&&d||!this.useParallaxOcclusion&&this.parallaxHeight.isConnected),p=this.parallaxScale.isConnectedToInputBlock?this.parallaxScale.connectInputBlock.isConstant?e._emitFloat(this.parallaxScale.connectInputBlock.value):this.parallaxScale.associatedVariableName:"0.05",g=this.strength.isConnectedToInputBlock&&this.strength.connectInputBlock.isConstant?`
#if !defined(NORMALXYSCALE)
1.0/
#endif
${e._emitFloat(this.strength.connectInputBlock.value)}`:`
#if !defined(NORMALXYSCALE)
1.0/
#endif
${this.strength.associatedVariableName}`;o||e._emitExtension("derivatives","#extension GL_OES_standard_derivatives : enable");const _={search:/defined\(TANGENT\)/g,replace:n.isConnected?"defined(TANGENT)":"defined(IGNORE)"},S={search:/varying mat3 vTBN;/g,replace:""},b={search:o?/uniform normalMatrix: mat4x4f;/g:/uniform mat4 normalMatrix;/g,replace:""},y=this.TBN;y.isConnected?e.compilationString+=`
            #ifdef TBNBLOCK
            ${o?"var":"mat3"} vTBN = ${y.associatedVariableName};
            #endif
            `:n.isConnected&&(e.compilationString+=`${e._declareLocalVar("tbnNormal",x.Vector3)} = normalize(${s.associatedVariableName}.xyz);
`,e.compilationString+=`${e._declareLocalVar("tbnTangent",x.Vector3)} = normalize(${n.associatedVariableName}.xyz);
`,e.compilationString+=`${e._declareLocalVar("tbnBitangent",x.Vector3)} = cross(tbnNormal, tbnTangent) * ${c}${this._tangentCorrectionFactorName};
`,e.compilationString+=`${o?"var":"mat3"} vTBN = ${l}(tbnTangent, tbnBitangent, tbnNormal);
`);let T=[_,S,b];o&&(T.push({search:/varying vTBN0: vec3f;/g,replace:""}),T.push({search:/varying vTBN1: vec3f;/g,replace:""}),T.push({search:/varying vTBN2: vec3f;/g,replace:""})),e._emitFunctionFromInclude("bumpFragmentMainFunctions",t,{replaceStrings:T});const v=o?"fn parallaxOcclusion(vViewDirCoT: vec3f, vNormalCoT: vec3f, texCoord: vec2f, parallaxScale:f32, bumpSampler: texture_2d<f32>, bumpSamplerSampler: sampler)":`#define inline
vec2 parallaxOcclusion(vec3 vViewDirCoT, vec3 vNormalCoT, vec2 texCoord, float parallaxScale, sampler2D bumpSampler)`,E=o?/fn parallaxOcclusion\(vViewDirCoT: vec3f,vNormalCoT: vec3f,texCoord: vec2f,parallaxScale: f32\)/g:/vec2 parallaxOcclusion\(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale\)/g,R=o?"fn parallaxOffset(viewDir: vec3f, heightScale: f32, height_: f32)":"vec2 parallaxOffset(vec3 viewDir, float heightScale, float height_)",O=o?/fn parallaxOffset\(viewDir: vec3f,heightScale: f32\)/g:/vec2 parallaxOffset\(vec3 viewDir,float heightScale\)/g;e._emitFunctionFromInclude("bumpFragmentFunctions",t,{replaceStrings:[{search:/#include<samplerFragmentDeclaration>\(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump\)/g,replace:""},{search:/uniform sampler2D bumpSampler;/g,replace:""},{search:E,replace:v},{search:O,replace:R},{search:/texture.+?bumpSampler,.*?vBumpUV\)\.w/g,replace:"height_"}]});const w=o?`textureSample(${d}, ${d+"Sampler"}`:`texture2D(${d}`,M=!f||!d?this.normalMapColor.associatedVariableName:`${w}, ${i.associatedVariableName} + uvOffset).xyz`,G=e._getFreeVariableName("tempOutput");return e.compilationString+=e._declareLocalVar(G,x.Vector3)+` = vec3${u}(0.);
`,T=[{search:new RegExp(`texture.+?bumpSampler${o?"Sampler,fragmentInputs.":","}vBumpUV\\)`,"g"),replace:`${M}`},{search:/#define CUSTOM_FRAGMENT_BUMP_FRAGMENT/g,replace:`${e._declareLocalVar("normalMatrix",x.Matrix)} = toNormalMatrix(${this.world.isConnected?this.world.associatedVariableName:c+this._worldMatrixName});`},{search:new RegExp(`perturbNormal\\(TBN,texture.+?bumpSampler${o?"Sampler,fragmentInputs.":","}vBumpUV\\+uvOffset\\).xyz,${c}vBumpInfos.y\\)`,"g"),replace:`perturbNormal(TBN, ${M}, ${c}vBumpInfos.y)`},{search:/parallaxOcclusion\(invTBN\*-viewDirectionW,invTBN\*normalW,(fragmentInputs\.)?vBumpUV,(uniforms\.)?vBumpInfos.z\)/g,replace:`parallaxOcclusion((invTBN * -viewDirectionW), (invTBN * normalW), ${h}vBumpUV, ${c}vBumpInfos.z, ${o?f&&this.useParallaxOcclusion?`${d}, ${d+"Sampler"}`:"bump, bumpSampler":f&&this.useParallaxOcclusion?d:"bumpSampler"})`},{search:/parallaxOffset\(invTBN\*viewDirectionW,vBumpInfos\.z\)/g,replace:`parallaxOffset(invTBN * viewDirectionW, ${c}vBumpInfos.z, ${f?this.parallaxHeight.associatedVariableName:"0."})`},{search:o?/uniforms.vBumpInfos.y/g:/vBumpInfos.y/g,replace:g},{search:o?/uniforms.vBumpInfos.z/g:/vBumpInfos.z/g,replace:p},{search:/normalW=/g,replace:G+" = "},o?{search:/mat3x3f\(uniforms\.normalMatrix\[0\].xyz,uniforms\.normalMatrix\[1\]\.xyz,uniforms\.normalMatrix\[2\].xyz\)\*normalW/g,replace:`${l}(normalMatrix[0].xyz, normalMatrix[1].xyz, normalMatrix[2].xyz) * `+G}:{search:/mat3\(normalMatrix\)\*normalW/g,replace:`${l}(normalMatrix) * `+G},{search:/normalW/g,replace:s.associatedVariableName+".xyz"},{search:/viewDirectionW/g,replace:f?this.viewDirection.associatedVariableName:`vec3${u}(0.)`},_],o?(T.push({search:/fragmentInputs.vBumpUV/g,replace:i.associatedVariableName}),T.push({search:/input.vPositionW/g,replace:r.associatedVariableName+".xyz"}),T.push({search:/uniforms.vTangentSpaceParams/g,replace:c+this._tangentSpaceParameterName}),T.push({search:/var TBN: mat3x3f=mat3x3<f32>\(input.vTBN0,input.vTBN1,input.vTBN2\);/g,replace:"var TBN = vTBN;"})):(T.push({search:/vBumpUV/g,replace:i.associatedVariableName}),T.push({search:/vPositionW/g,replace:r.associatedVariableName+".xyz"}),T.push({search:/vTangentSpaceParams/g,replace:c+this._tangentSpaceParameterName})),e.compilationString+=e._emitCodeFromInclude("bumpFragment",t,{replaceStrings:T}),e.compilationString+=e._declareOutput(this.output)+` = vec4${u}(${G}, 0.);
`,this}_dumpPropertiesCode(){let e=super._dumpPropertiesCode()+`${this._codeVariableName}.invertX = ${this.invertX};
`;return e+=`${this._codeVariableName}.invertY = ${this.invertY};
`,e+=`${this._codeVariableName}.useParallaxOcclusion = ${this.useParallaxOcclusion};
`,e+=`${this._codeVariableName}.useObjectSpaceNormalMap = ${this.useObjectSpaceNormalMap};
`,e}serialize(){const e=super.serialize();return e.invertX=this.invertX,e.invertY=this.invertY,e.useParallaxOcclusion=this.useParallaxOcclusion,e.useObjectSpaceNormalMap=this.useObjectSpaceNormalMap,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.invertX=e.invertX,this.invertY=e.invertY,this.useParallaxOcclusion=!!e.useParallaxOcclusion,this.useObjectSpaceNormalMap=!!e.useObjectSpaceNormalMap}}C([U("Invert X axis",0,"PROPERTIES",{embedded:!0,notifiers:{update:!0}})],hl.prototype,"invertX",void 0);C([U("Invert Y axis",0,"PROPERTIES",{embedded:!0,notifiers:{update:!0}})],hl.prototype,"invertY",void 0);C([U("Use parallax occlusion",0,void 0,{embedded:!0})],hl.prototype,"useParallaxOcclusion",void 0);C([U("Object Space Mode",0,"PROPERTIES",{embedded:!0,notifiers:{update:!0}})],hl.prototype,"useObjectSpaceNormalMap",void 0);B("BABYLON.PerturbNormalBlock",hl);class vF extends le{constructor(e){super(e,A.Fragment,!0),this.registerInput("value",x.Float,!0),this.registerInput("cutoff",x.Float,!0)}getClassName(){return"DiscardBlock"}get value(){return this._inputs[0]}get cutoff(){return this._inputs[1]}_buildBlock(e){if(super._buildBlock(e),e.sharedData.hints.needAlphaTesting=!0,!(!this.cutoff.isConnected||!this.value.isConnected))return e.compilationString+=`if (${this.value.associatedVariableName} < ${this.cutoff.associatedVariableName}) { discard; }
`,this}}B("BABYLON.DiscardBlock",vF);class bF extends le{constructor(e){super(e,A.Fragment),this.registerOutput("output",x.Float,A.Fragment)}getClassName(){return"FrontFacingBlock"}get output(){return this._outputs[0]}_buildBlock(e){if(super._buildBlock(e),e.target===A.Vertex)throw"FrontFacingBlock must only be used in a fragment shader";const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = ${e._generateTernary("1.0","0.0",e.shaderLanguage===0?"gl_FrontFacing":"fragmentInputs.frontFacing")};
`,this}}B("BABYLON.FrontFacingBlock",bF);class yF extends le{constructor(e){super(e,A.Fragment),this.registerInput("input",x.AutoDetect,!1),this.registerOutput("dx",x.BasedOnInput),this.registerOutput("dy",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._outputs[1]._typeConnectionSource=this._inputs[0]}getClassName(){return"DerivativeBlock"}get input(){return this._inputs[0]}get dx(){return this._outputs[0]}get dy(){return this._outputs[1]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0],i=this._outputs[1];e._emitExtension("derivatives","#extension GL_OES_standard_derivatives : enable");let r="dFdx",s="dFdy";return e.shaderLanguage===1&&(r="dpdx",s="dpdy"),t.hasEndpoints&&(e.compilationString+=e._declareOutput(t)+` = ${r}(${this.input.associatedVariableName});
`),i.hasEndpoints&&(e.compilationString+=e._declareOutput(i)+` = ${s}(${this.input.associatedVariableName});
`),this}}B("BABYLON.DerivativeBlock",yF);class TF extends le{constructor(e){super(e,A.Fragment),this.registerOutput("xy",x.Vector2,A.Fragment),this.registerOutput("xyz",x.Vector3,A.Fragment),this.registerOutput("xyzw",x.Vector4,A.Fragment),this.registerOutput("x",x.Float,A.Fragment),this.registerOutput("y",x.Float,A.Fragment),this.registerOutput("z",x.Float,A.Fragment),this.registerOutput("w",x.Float,A.Fragment)}getClassName(){return"FragCoordBlock"}get xy(){return this._outputs[0]}get xyz(){return this._outputs[1]}get xyzw(){return this._outputs[2]}get x(){return this._outputs[3]}get y(){return this._outputs[4]}get z(){return this._outputs[5]}get output(){return this._outputs[6]}writeOutputs(e){let t="";const i=e.shaderLanguage===1?"fragmentInputs.position":"gl_FragCoord";for(const r of this._outputs)r.hasEndpoints&&(t+=`${e._declareOutput(r)} = ${i}.${r.name};
`);return t}_buildBlock(e){if(super._buildBlock(e),e.target===A.Vertex)throw"FragCoordBlock must only be used in a fragment shader";return e.compilationString+=this.writeOutputs(e),this}}B("BABYLON.FragCoordBlock",TF);class CF extends le{constructor(e){super(e,A.Fragment),this.registerOutput("xy",x.Vector2,A.Fragment),this.registerOutput("x",x.Float,A.Fragment),this.registerOutput("y",x.Float,A.Fragment)}getClassName(){return"ScreenSizeBlock"}get xy(){return this._outputs[0]}get x(){return this._outputs[1]}get y(){return this._outputs[2]}bind(e){const t=this._scene.getEngine();e.setFloat2(this._varName,t.getRenderWidth(),t.getRenderHeight())}writeOutputs(e,t){let i="";for(const r of this._outputs)r.hasEndpoints&&(i+=`${e._declareOutput(r)} = ${t}.${r.name};
`);return i}_buildBlock(e){if(super._buildBlock(e),this._scene=e.sharedData.scene,e.target===A.Vertex)throw"ScreenSizeBlock must only be used in a fragment shader";e.sharedData.bindableBlocks.push(this),this._varName=e._getFreeVariableName("screenSize"),e._emitUniformFromString(this._varName,x.Vector2);const t=e.shaderLanguage===1?"uniforms.":"";return e.compilationString+=this.writeOutputs(e,t+this._varName),this}}B("BABYLON.ScreenSizeBlock",CF);class PF extends le{constructor(e){super(e,A.Fragment),this.registerInput("vector",x.AutoDetect),this.registerInput("worldViewProjection",x.Matrix),this.registerOutput("output",x.Vector2),this.registerOutput("x",x.Float),this.registerOutput("y",x.Float),this.inputs[0].addExcludedConnectionPointFromAllowedTypes(x.Color3|x.Vector3|x.Vector4)}getClassName(){return"ScreenSpaceBlock"}get vector(){return this._inputs[0]}get worldViewProjection(){return this._inputs[1]}get output(){return this._outputs[0]}get x(){return this._outputs[1]}get y(){return this._outputs[2]}autoConfigure(e,t=()=>!0){if(!this.worldViewProjection.isConnected){let i=e.getInputBlockByPredicate(r=>r.systemValue===De.WorldViewProjection&&t(r));i||(i=new Ee("worldViewProjection"),i.setAsSystemValue(De.WorldViewProjection)),i.output.connectTo(this.worldViewProjection)}}_buildBlock(e){super._buildBlock(e);const t=this.vector,i=this.worldViewProjection;if(!t.connectedPoint)return;const r=i.associatedVariableName,s=e._getFreeVariableName("screenSpaceTemp");switch(t.connectedPoint.type){case x.Vector3:e.compilationString+=`${e._declareLocalVar(s,x.Vector4)} = ${r} * vec4${e.fSuffix}(${t.associatedVariableName}, 1.0);
`;break;case x.Vector4:e.compilationString+=`${e._declareLocalVar(s,x.Vector4)} = ${r} * ${t.associatedVariableName};
`;break}return e.compilationString+=`${s} = vec4${e.fSuffix}(${s}.xy / ${s}.w, ${s}.zw);`,e.compilationString+=`${s} = vec4${e.fSuffix}(${s}.xy * 0.5 + vec2${e.fSuffix}(0.5, 0.5), ${s}.zw);`,this.output.hasEndpoints&&(e.compilationString+=e._declareOutput(this.output)+` = ${s}.xy;
`),this.x.hasEndpoints&&(e.compilationString+=e._declareOutput(this.x)+` = ${s}.x;
`),this.y.hasEndpoints&&(e.compilationString+=e._declareOutput(this.y)+` = ${s}.y;
`),this}}B("BABYLON.ScreenSpaceBlock",PF);class EF extends le{constructor(e){super(e,A.Fragment),this.registerInput("input",x.Vector2),this.registerInput("strength",x.Float),this.registerInput("center",x.Vector2),this.registerInput("offset",x.Vector2),this.registerOutput("output",x.Vector2),this.registerOutput("x",x.Float),this.registerOutput("y",x.Float)}getClassName(){return"TwirlBlock"}get input(){return this._inputs[0]}get strength(){return this._inputs[1]}get center(){return this._inputs[2]}get offset(){return this._inputs[3]}get output(){return this._outputs[0]}get x(){return this._outputs[1]}get y(){return this._outputs[2]}autoConfigure(){if(!this.center.isConnected){const e=new Ee("center");e.value=new Q(.5,.5),e.output.connectTo(this.center)}if(!this.strength.isConnected){const e=new Ee("strength");e.value=1,e.output.connectTo(this.strength)}if(!this.offset.isConnected){const e=new Ee("offset");e.value=new Q(0,0),e.output.connectTo(this.offset)}}_buildBlock(e){super._buildBlock(e);const t=e._getFreeVariableName("delta"),i=e._getFreeVariableName("angle"),r=e._getFreeVariableName("x"),s=e._getFreeVariableName("y"),n=e._getFreeVariableName("result");return e.compilationString+=`        
            ${e._declareLocalVar(t,x.Vector2)} = ${this.input.associatedVariableName} - ${this.center.associatedVariableName};
            ${e._declareLocalVar(i,x.Float)} = ${this.strength.associatedVariableName} * length(${t});
            ${e._declareLocalVar(r,x.Float)} = cos(${i}) * ${t}.x - sin(${i}) * ${t}.y;
            ${e._declareLocalVar(s,x.Float)} = sin(${i}) * ${t}.x + cos(${i}) * ${t}.y;
            ${e._declareLocalVar(n,x.Vector2)} = vec2(${r} + ${this.center.associatedVariableName}.x + ${this.offset.associatedVariableName}.x, ${s} + ${this.center.associatedVariableName}.y + ${this.offset.associatedVariableName}.y);
        `,this.output.hasEndpoints&&(e.compilationString+=e._declareOutput(this.output)+` = ${n};
`),this.x.hasEndpoints&&(e.compilationString+=e._declareOutput(this.x)+` = ${n}.x;
`),this.y.hasEndpoints&&(e.compilationString+=e._declareOutput(this.y)+` = ${n}.y;
`),this}}B("BABYLON.TwirlBlock",EF);class Ju extends le{constructor(e){super(e,A.Fragment),this.generateInWorldSpace=!1,this.automaticNormalizationNormal=!0,this.automaticNormalizationTangent=!0,this.registerInput("input",x.Float),this.registerInput("worldPosition",x.Vector3),this.registerInput("worldNormal",x.Vector3),this.registerInput("worldTangent",x.AutoDetect,!0),this.registerOutput("output",x.Vector4),this.registerOutput("xyz",x.Vector3),this._inputs[3].addExcludedConnectionPointFromAllowedTypes(x.Color3|x.Vector3|x.Vector4)}getClassName(){return"HeightToNormalBlock"}get input(){return this._inputs[0]}get worldPosition(){return this._inputs[1]}get worldNormal(){return this._inputs[2]}get worldTangent(){return this._inputs[3]}get output(){return this._outputs[0]}get xyz(){return this._outputs[1]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0],i=e.shaderLanguage===1,r=e.fSuffix;!this.generateInWorldSpace&&!this.worldTangent.isConnected&&L.Error(`You must connect the 'worldTangent' input of the ${this.name} block!`);const s=this.generateInWorldSpace?"":`
            vec3 biTangent = cross(norm, tgt);
            mat3 TBN = mat3(tgt, biTangent, norm);
            `,n=this.generateInWorldSpace?"":`
            result = TBN * result;
            result = result * vec3(0.5) + vec3(0.5);
            `;let o=`
            vec4 heightToNormal(float height, vec3 position, vec3 tangent, vec3 normal) {
                vec3 tgt = ${this.automaticNormalizationTangent?"normalize(tangent);":"tangent;"}
                vec3 norm = ${this.automaticNormalizationNormal?"normalize(normal);":"normal;"}
                ${s}
                vec3 worlddX = dFdx(position);
                vec3 worlddY = dFdy(position);
                vec3 crossX = cross(norm, worlddX);
                vec3 crossY = cross(worlddY, norm);
                float d = abs(dot(crossY, worlddX));
                vec3 inToNormal = vec3(((((height + dFdx(height)) - height) * crossY) + (((height + dFdy(height)) - height) * crossX)) * sign(d));
                inToNormal.y *= -1.0;
                vec3 result = normalize((d * norm) - inToNormal);
                ${n}
                return vec4(result, 0.);
            }`;return i?o=e._babylonSLtoWGSL(o):e._emitExtension("derivatives","#extension GL_OES_standard_derivatives : enable"),e._emitFunction("heightToNormal",o,"// heightToNormal"),e.compilationString+=e._declareOutput(t)+` = heightToNormal(${this.input.associatedVariableName}, ${this.worldPosition.associatedVariableName}, ${this.worldTangent.isConnected?this.worldTangent.associatedVariableName:`vec3${r}(0.)`}.xyz, ${this.worldNormal.associatedVariableName});
`,this.xyz.hasEndpoints&&(e.compilationString+=e._declareOutput(this.xyz)+` = ${this.output.associatedVariableName}.xyz;
`),this}_dumpPropertiesCode(){let e=super._dumpPropertiesCode();return e+=`${this._codeVariableName}.generateInWorldSpace = ${this.generateInWorldSpace};
`,e+=`${this._codeVariableName}.automaticNormalizationNormal = ${this.automaticNormalizationNormal};
`,e+=`${this._codeVariableName}.automaticNormalizationTangent = ${this.automaticNormalizationTangent};
`,e}serialize(){const e=super.serialize();return e.generateInWorldSpace=this.generateInWorldSpace,e.automaticNormalizationNormal=this.automaticNormalizationNormal,e.automaticNormalizationTangent=this.automaticNormalizationTangent,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.generateInWorldSpace=e.generateInWorldSpace,this.automaticNormalizationNormal=e.automaticNormalizationNormal,this.automaticNormalizationTangent=e.automaticNormalizationTangent}}C([U("Generate in world space instead of tangent space",0,"PROPERTIES",{notifiers:{update:!0}})],Ju.prototype,"generateInWorldSpace",void 0);C([U("Force normalization for the worldNormal input",0,"PROPERTIES",{notifiers:{update:!0}})],Ju.prototype,"automaticNormalizationNormal",void 0);C([U("Force normalization for the worldTangent input",0,"PROPERTIES",{notifiers:{update:!0}})],Ju.prototype,"automaticNormalizationTangent",void 0);B("BABYLON.HeightToNormalBlock",Ju);class IF extends le{constructor(e){super(e,A.Fragment,!0),this.registerInput("depth",x.Float,!0),this.registerInput("worldPos",x.Vector4,!0),this.registerInput("viewProjection",x.Matrix,!0)}getClassName(){return"FragDepthBlock"}get depth(){return this._inputs[0]}get worldPos(){return this._inputs[1]}get viewProjection(){return this._inputs[2]}_buildBlock(e){super._buildBlock(e);const t=e.shaderLanguage===0?"gl_FragDepth":"fragmentOutputs.fragDepth";return this.depth.isConnected?e.compilationString+=`${t} = ${this.depth.associatedVariableName};
`:this.worldPos.isConnected&&this.viewProjection.isConnected?e.compilationString+=`
                ${e._declareLocalVar("p",x.Vector4)} = ${this.viewProjection.associatedVariableName} * ${this.worldPos.associatedVariableName};
                ${e._declareLocalVar("v",x.Float)} = p.z / p.w;
                #ifndef IS_NDC_HALF_ZRANGE
                    v = v * 0.5 + 0.5;
                #endif
                ${t} = v;
    
            `:L.Warn("FragDepthBlock: either the depth input or both the worldPos and viewProjection inputs must be connected!"),this}}B("BABYLON.FragDepthBlock",IF);class RF extends le{constructor(e){super(e,A.Fragment),this.registerInput("worldPosition",x.Vector4,!1),this.registerInput("viewProjection",x.Matrix,!1),this.registerInput("worldNormal",x.AutoDetect,!0),this.registerOutput("depth",x.Vector3),this.worldNormal.addExcludedConnectionPointFromAllowedTypes(x.Color3|x.Vector3|x.Vector4)}getClassName(){return"ShadowMapBlock"}initialize(e){e._excludeVariableName("vPositionWSM"),e._excludeVariableName("lightDataSM"),e._excludeVariableName("biasAndScaleSM"),e._excludeVariableName("depthValuesSM"),e._excludeVariableName("clipPos"),e._excludeVariableName("worldPos"),e._excludeVariableName("zSM"),this._initShaderSourceAsync(e.shaderLanguage)}async _initShaderSourceAsync(e){this._codeIsReady=!1,e===1?await Promise.all([k(()=>Promise.resolve().then(()=>q1),void 0),k(()=>Promise.resolve().then(()=>z1),void 0),k(()=>Promise.resolve().then(()=>$1),void 0)]):await Promise.all([k(()=>Promise.resolve().then(()=>_N),void 0),k(()=>Promise.resolve().then(()=>ow),void 0),k(()=>Promise.resolve().then(()=>aN),void 0)]),this._codeIsReady=!0,this.onCodeIsReadyObservable.notifyObservers(this)}get worldPosition(){return this._inputs[0]}get viewProjection(){return this._inputs[1]}get worldNormal(){return this._inputs[2]}get depth(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=`//${this.name}`,i=e.shaderLanguage===1;e._emitUniformFromString("biasAndScaleSM",x.Vector3),e._emitUniformFromString("lightDataSM",x.Vector3),e._emitUniformFromString("depthValuesSM",x.Vector2),e._emitFunctionFromInclude("packingFunctions",t),e.compilationString+=`${e._declareLocalVar("worldPos",x.Vector4)} = ${this.worldPosition.associatedVariableName};
`,e.compilationString+=`${e._declareLocalVar("vPositionWSM",x.Vector3)};
`,e.compilationString+=`${e._declareLocalVar("vDepthMetricSM",x.Float)} = 0.0;
`,e.compilationString+=`${e._declareLocalVar("zSM",x.Float)};
`,this.worldNormal.isConnected&&(e.compilationString+=`${e._declareLocalVar("vNormalW",x.Vector3)} = ${this.worldNormal.associatedVariableName}.xyz;
`,e.compilationString+=e._emitCodeFromInclude("shadowMapVertexNormalBias",t)),e.compilationString+=`${e._declareLocalVar("clipPos",x.Vector4)} = ${this.viewProjection.associatedVariableName} * worldPos;
`,e.compilationString+=e._emitCodeFromInclude("shadowMapVertexMetric",t,{replaceStrings:[{search:/gl_Position/g,replace:"clipPos"},{search:/vertexOutputs.position/g,replace:"clipPos"},{search:/vertexOutputs\.vDepthMetricSM/g,replace:"vDepthMetricSM"}]}),e.compilationString+=e._emitCodeFromInclude("shadowMapFragment",t,{replaceStrings:[{search:/return;/g,replace:""},{search:/fragmentInputs\.vDepthMetricSM/g,replace:"vDepthMetricSM"}]});const r=i?"fragmentOutputs.fragDepth":"gl_FragDepth";return e.compilationString+=`
            #if SM_DEPTHTEXTURE == 1
                #ifdef IS_NDC_HALF_ZRANGE
                    ${r} = (clipPos.z / clipPos.w);
                #else
                    ${r} = (clipPos.z / clipPos.w) * 0.5 + 0.5;
                #endif
            #endif
        `,e.compilationString+=`${e._declareOutput(this.depth)} = vec3${e.fSuffix}(depthSM, 1., 1.);
`,this}}B("BABYLON.ShadowMapBlock",RF);class MF extends le{constructor(e){super(e,A.Fragment,!0),this.registerInput("viewDepth",x.Float,!0),this.registerInput("screenDepth",x.Float,!0),this.registerInput("worldPosition",x.AutoDetect,!0),this.registerInput("localPosition",x.AutoDetect,!0),this.registerInput("viewNormal",x.AutoDetect,!0),this.registerInput("worldNormal",x.AutoDetect,!0),this.registerInput("reflectivity",x.AutoDetect,!0),this.registerInput("velocity",x.AutoDetect,!0),this.registerInput("velocityLinear",x.AutoDetect,!0),this.inputs[2].addExcludedConnectionPointFromAllowedTypes(x.Vector3|x.Vector4),this.inputs[3].addExcludedConnectionPointFromAllowedTypes(x.Vector3|x.Vector4),this.inputs[4].addExcludedConnectionPointFromAllowedTypes(x.Vector3|x.Vector4),this.inputs[5].addExcludedConnectionPointFromAllowedTypes(x.Vector3|x.Vector4),this.inputs[6].addExcludedConnectionPointFromAllowedTypes(x.Vector3|x.Vector4|x.Color3|x.Color4),this.inputs[7].addExcludedConnectionPointFromAllowedTypes(x.Vector3|x.Vector4),this.inputs[8].addExcludedConnectionPointFromAllowedTypes(x.Vector3|x.Vector4)}getClassName(){return"PrePassOutputBlock"}get viewDepth(){return this._inputs[0]}get screenDepth(){return this._inputs[1]}get worldPosition(){return this._inputs[2]}get localPosition(){return this._inputs[3]}get viewNormal(){return this._inputs[4]}get worldNormal(){return this._inputs[5]}get reflectivity(){return this._inputs[6]}get velocity(){return this._inputs[7]}get velocityLinear(){return this._inputs[8]}_getFragData(e,t){return e?`fragmentOutputs.fragData${t}`:`gl_FragData[${t}]`}_buildBlock(e){super._buildBlock(e);const t=this.worldPosition,i=this.localPosition,r=this.viewNormal,s=this.worldNormal,n=this.viewDepth,o=this.reflectivity,l=this.screenDepth,u=this.velocity,c=this.velocityLinear;e.sharedData.blocksWithDefines.push(this);const h=`//${this.name}`,d=e._getShaderType(x.Vector4),f=e.shaderLanguage===1;return e._emitFunctionFromInclude("helperFunctions",h),e.compilationString+=`#if defined(PREPASS)\r
`,e.compilationString+=f?`var fragData: array<vec4<f32>, SCENE_MRT_COUNT>;\r
`:`vec4 fragData[SCENE_MRT_COUNT];\r
`,e.compilationString+=`#ifdef PREPASS_DEPTH\r
`,n.connectedPoint?e.compilationString+=` fragData[PREPASS_DEPTH_INDEX] = ${d}(${n.associatedVariableName}, 0.0, 0.0, 1.0);\r
`:e.compilationString+=` fragData[PREPASS_DEPTH_INDEX] = ${d}(0.0, 0.0, 0.0, 0.0);\r
`,e.compilationString+=`#endif\r
`,e.compilationString+=`#ifdef PREPASS_SCREENSPACE_DEPTH\r
`,l.connectedPoint?e.compilationString+=` gl_FragData[PREPASS_SCREENSPACE_DEPTH_INDEX] = vec4(${l.associatedVariableName}, 0.0, 0.0, 1.0);\r
`:e.compilationString+=` gl_FragData[PREPASS_SCREENSPACE_DEPTH_INDEX] = vec4(0.0, 0.0, 0.0, 0.0);\r
`,e.compilationString+=`#endif\r
`,e.compilationString+=`#ifdef PREPASS_POSITION\r
`,t.connectedPoint?e.compilationString+=`fragData[PREPASS_POSITION_INDEX] = ${d}(${t.associatedVariableName}.rgb, ${t.connectedPoint.type===x.Vector4?t.associatedVariableName+".a":"1.0"});\r
`:e.compilationString+=` fragData[PREPASS_POSITION_INDEX] = ${d}(0.0, 0.0, 0.0, 0.0);\r
`,e.compilationString+=`#endif\r
`,e.compilationString+=`#ifdef PREPASS_LOCAL_POSITION\r
`,i.connectedPoint?e.compilationString+=` gl_FragData[PREPASS_LOCAL_POSITION_INDEX] = vec4(${i.associatedVariableName}.rgb, ${i.connectedPoint.type===x.Vector4?i.associatedVariableName+".a":"1.0"});\r
`:e.compilationString+=` gl_FragData[PREPASS_LOCAL_POSITION_INDEX] = vec4(0.0, 0.0, 0.0, 0.0);\r
`,e.compilationString+=`#endif\r
`,e.compilationString+=`#ifdef PREPASS_NORMAL\r
`,r.connectedPoint?e.compilationString+=` fragData[PREPASS_NORMAL_INDEX] = ${d}(${r.associatedVariableName}.rgb, ${r.connectedPoint.type===x.Vector4?r.associatedVariableName+".a":"1.0"});\r
`:e.compilationString+=` fragData[PREPASS_NORMAL_INDEX] = ${d}(0.0, 0.0, 0.0, 0.0);\r
`,e.compilationString+=`#endif\r
`,e.compilationString+=`#ifdef PREPASS_WORLD_NORMAL\r
`,s.connectedPoint?e.compilationString+=` gl_FragData[PREPASS_WORLD_NORMAL_INDEX] = vec4(${s.associatedVariableName}.rgb, ${s.connectedPoint.type===x.Vector4?s.associatedVariableName+".a":"1.0"});\r
`:e.compilationString+=` gl_FragData[PREPASS_WORLD_NORMAL_INDEX] = vec4(0.0, 0.0, 0.0, 0.0);\r
`,e.compilationString+=`#endif\r
`,e.compilationString+=`#ifdef PREPASS_REFLECTIVITY\r
`,o.connectedPoint?e.compilationString+=` fragData[PREPASS_REFLECTIVITY_INDEX] = ${d}(${o.associatedVariableName}.rgb, ${o.connectedPoint.type===x.Vector4?o.associatedVariableName+".a":"1.0"});\r
`:e.compilationString+=` fragData[PREPASS_REFLECTIVITY_INDEX] = ${d}(0.0, 0.0, 0.0, 1.0);\r
`,e.compilationString+=`#endif\r
`,e.compilationString+=`#ifdef PREPASS_VELOCITY\r
`,u.connectedPoint?e.compilationString+=` fragData[PREPASS_VELOCITY_INDEX] = ${d}(${u.associatedVariableName}.rgb, ${u.connectedPoint.type===x.Vector4?u.associatedVariableName+".a":"1.0"});\r
`:e.compilationString+=` fragData[PREPASS_VELOCITY_INDEX] = ${d}(0.0, 0.0, 0.0, 1.0);\r
`,e.compilationString+=`#endif\r
`,e.compilationString+=`#ifdef PREPASS_VELOCITY_LINEAR\r
`,c.connectedPoint?e.compilationString+=` fragData[PREPASS_VELOCITY_LINEAR_INDEX] = ${d}(${c.associatedVariableName}.rgb, ${c.connectedPoint.type===x.Vector4?c.associatedVariableName+".a":"1.0"});\r
`:e.compilationString+=` fragData[PREPASS_VELOCITY_LINEAR_INDEX] = ${d}(0.0, 0.0, 0.0, 1.0);\r
`,e.compilationString+=`#endif\r
`,e.compilationString+=`#if SCENE_MRT_COUNT > 1\r
`,e.compilationString+=`${this._getFragData(f,1)} = fragData[1];\r
`,e.compilationString+=`#endif\r
`,e.compilationString+=`#if SCENE_MRT_COUNT > 2\r
`,e.compilationString+=`${this._getFragData(f,2)} = fragData[2];\r
`,e.compilationString+=`#endif\r
`,e.compilationString+=`#if SCENE_MRT_COUNT > 3\r
`,e.compilationString+=`${this._getFragData(f,3)} = fragData[3];\r
`,e.compilationString+=`#endif\r
`,e.compilationString+=`#if SCENE_MRT_COUNT > 4\r
`,e.compilationString+=`${this._getFragData(f,4)} = fragData[4];\r
`,e.compilationString+=`#endif\r
`,e.compilationString+=`#if SCENE_MRT_COUNT > 5\r
`,e.compilationString+=`${this._getFragData(f,5)} = fragData[5];\r
`,e.compilationString+=`#endif\r
`,e.compilationString+=`#if SCENE_MRT_COUNT > 6\r
`,e.compilationString+=`${this._getFragData(f,6)} = fragData[6];\r
`,e.compilationString+=`#endif\r
`,e.compilationString+=`#if SCENE_MRT_COUNT > 7\r
`,e.compilationString+=`${this._getFragData(f,7)} = fragData[7];\r
`,e.compilationString+=`#endif\r
`,e.compilationString+=`#endif\r
`,this}}B("BABYLON.PrePassOutputBlock",MF);class AF extends le{constructor(e){super(e,A.VertexAndFragment,!1),this.registerInput("worldPosition",x.Vector4,!1,A.Vertex),this.registerInput("view",x.Matrix,!1,A.Vertex),this.registerInput("input",x.AutoDetect,!1,A.Fragment),this.registerInput("fogColor",x.AutoDetect,!1,A.Fragment),this.registerOutput("output",x.Color3,A.Fragment),this.input.addExcludedConnectionPointFromAllowedTypes(x.Color3|x.Vector3|x.Color4),this.fogColor.addExcludedConnectionPointFromAllowedTypes(x.Color3|x.Vector3|x.Color4)}getClassName(){return"FogBlock"}get worldPosition(){return this._inputs[0]}get view(){return this._inputs[1]}get input(){return this._inputs[2]}get fogColor(){return this._inputs[3]}get output(){return this._outputs[0]}initialize(e){this._initShaderSourceAsync(e.shaderLanguage)}async _initShaderSourceAsync(e){this._codeIsReady=!1,e===1?await k(()=>import("./pointsCloudSystem-2vcS-S4d.js").then(t=>t.ha),__vite__mapDeps([1,2,3,4,5])):await k(()=>import("./pointsCloudSystem-2vcS-S4d.js").then(t=>t.hb),__vite__mapDeps([1,2,3,4,5])),this._codeIsReady=!0,this.onCodeIsReadyObservable.notifyObservers(this)}autoConfigure(e,t=()=>!0){if(!this.view.isConnected){let i=e.getInputBlockByPredicate(r=>r.systemValue===De.View&&t(r));i||(i=new Ee("view"),i.setAsSystemValue(De.View)),i.output.connectTo(this.view)}if(!this.fogColor.isConnected){let i=e.getInputBlockByPredicate(r=>r.systemValue===De.FogColor&&t(r));i||(i=new Ee("fogColor",void 0,x.Color3),i.setAsSystemValue(De.FogColor)),i.output.connectTo(this.fogColor)}}prepareDefines(e,t,i){const r=e.getScene();i.setValue("FOG",t.fogEnabled&&Cy(e,r))}bind(e,t,i){if(!i)return;const r=i.getScene();e.setFloat4(this._fogParameters,r.fogMode,r.fogStart,r.fogEnd,r.fogDensity)}_buildBlock(e){if(super._buildBlock(e),e.target===A.Fragment){e.sharedData.blocksWithDefines.push(this),e.sharedData.bindableBlocks.push(this);let t=[],i="",r="";e.shaderLanguage===1?(t=[{search:/fn CalcFogFactor\(\)/,replace:"fn CalcFogFactor(vFogDistance: vec3f, vFogInfos: vec4f)"},{search:/uniforms.vFogInfos/g,replace:"vFogInfos"},{search:/fragmentInputs.vFogDistance/g,replace:"vFogDistance"}],i="fragmentInputs.",r="uniforms."):t=[{search:/float CalcFogFactor\(\)/,replace:"float CalcFogFactor(vec3 vFogDistance, vec4 vFogInfos)"}],e._emitFunctionFromInclude("fogFragmentDeclaration",`//${this.name}`,{removeUniforms:!0,removeVaryings:!0,removeIfDef:!1,replaceStrings:t});const s=e._getFreeVariableName("fog"),n=this.input,o=this.fogColor;this._fogParameters=e._getFreeVariableName("fogParameters");const l=this._outputs[0];e._emitUniformFromString(this._fogParameters,x.Vector4),e.compilationString+=`#ifdef FOG
`,e.compilationString+=`${e._declareLocalVar(s,x.Float)} = CalcFogFactor(${i}${this._fogDistanceName}, ${r}${this._fogParameters});
`,e.compilationString+=e._declareOutput(l)+` = ${s} * ${n.associatedVariableName}.rgb + (1.0 - ${s}) * ${o.associatedVariableName}.rgb;
`,e.compilationString+=`#else
${e._declareOutput(l)} =  ${n.associatedVariableName}.rgb;
`,e.compilationString+=`#endif
`}else{const t=this.worldPosition,i=this.view;this._fogDistanceName=e._getFreeVariableName("vFogDistance"),e._emitVaryingFromString(this._fogDistanceName,x.Vector3);const r=e.shaderLanguage===1?"vertexOutputs.":"";e.compilationString+=`${r}${this._fogDistanceName} = (${i.associatedVariableName} * ${t.associatedVariableName}).xyz;
`}return this}}B("BABYLON.FogBlock",AF);class ld extends le{static _OnGenerateOnlyFragmentCodeChanged(e,t){const i=e;return i.worldPosition.isConnected?(i.generateOnlyFragmentCode=!i.generateOnlyFragmentCode,L.Error("The worldPosition input must not be connected to be able to switch!"),!1):(i._setTarget(),!0)}_setTarget(){this._setInitialTarget(this.generateOnlyFragmentCode?A.Fragment:A.VertexAndFragment),this.getInputByName("worldPosition").target=this.generateOnlyFragmentCode?A.Fragment:A.Vertex}constructor(e){super(e,A.VertexAndFragment),this._lightId=0,this.generateOnlyFragmentCode=!1,this._isUnique=!0,this.registerInput("worldPosition",x.Vector4,!1,A.Vertex),this.registerInput("worldNormal",x.Vector4,!1,A.Fragment),this.registerInput("cameraPosition",x.Vector3,!1,A.Fragment),this.registerInput("glossiness",x.Float,!0,A.Fragment),this.registerInput("glossPower",x.Float,!0,A.Fragment),this.registerInput("diffuseColor",x.Color3,!0,A.Fragment),this.registerInput("specularColor",x.Color3,!0,A.Fragment),this.registerInput("view",x.Matrix,!0),this.registerOutput("diffuseOutput",x.Color3,A.Fragment),this.registerOutput("specularOutput",x.Color3,A.Fragment),this.registerOutput("shadow",x.Float,A.Fragment)}getClassName(){return"LightBlock"}get worldPosition(){return this._inputs[0]}get worldNormal(){return this._inputs[1]}get cameraPosition(){return this._inputs[2]}get glossiness(){return this._inputs[3]}get glossPower(){return this._inputs[4]}get diffuseColor(){return this._inputs[5]}get specularColor(){return this._inputs[6]}get view(){return this._inputs[7]}get diffuseOutput(){return this._outputs[0]}get specularOutput(){return this._outputs[1]}get shadow(){return this._outputs[2]}initialize(e){this._initShaderSourceAsync(e.shaderLanguage)}async _initShaderSourceAsync(e){this._codeIsReady=!1,e===1?await Promise.all([k(()=>import("./oitFragment-COwarqmx.js").then(t=>t.m),__vite__mapDeps([8,1,2,3,4,5])),k(()=>import("./oitFragment-COwarqmx.js").then(t=>t.h),__vite__mapDeps([8,1,2,3,4,5])),k(()=>import("./vertexColorMixing-CmRbdHdF.js").then(t=>t.n),__vite__mapDeps([0,1,2,3,4,5])),k(()=>import("./helperFunctions-Dt8Ez0m5.js"),__vite__mapDeps([7,1,2,3,4,5])),k(()=>import("./default.fragment-B-kdUbSd.js").then(t=>t.a),__vite__mapDeps([10,1,2,3,4,5,11,8,12,7])),k(()=>import("./oitFragment-COwarqmx.js").then(t=>t.j),__vite__mapDeps([8,1,2,3,4,5])),k(()=>import("./vertexColorMixing-CmRbdHdF.js").then(t=>t.o),__vite__mapDeps([0,1,2,3,4,5]))]):await Promise.all([k(()=>import("./oitFragment-C1qnXpVq.js").then(t=>t.j),__vite__mapDeps([9,1,2,3,4,5])),k(()=>import("./oitFragment-C1qnXpVq.js").then(t=>t.o),__vite__mapDeps([9,1,2,3,4,5])),k(()=>import("./oitFragment-C1qnXpVq.js").then(t=>t.k),__vite__mapDeps([9,1,2,3,4,5])),k(()=>import("./bumpVertex-CO1be_N_.js").then(t=>t.p),__vite__mapDeps([6,1,2,3,4,5])),k(()=>import("./bumpVertex-CO1be_N_.js").then(t=>t.o),__vite__mapDeps([6,1,2,3,4,5])),k(()=>import("./pointsCloudSystem-2vcS-S4d.js").then(t=>t.h5),__vite__mapDeps([1,2,3,4,5])),k(()=>import("./default.fragment-CtvPXGlm.js").then(t=>t.a),__vite__mapDeps([13,1,2,3,4,5,9,14,15])),k(()=>import("./oitFragment-C1qnXpVq.js").then(t=>t.m),__vite__mapDeps([9,1,2,3,4,5])),k(()=>import("./bumpVertex-CO1be_N_.js").then(t=>t.q),__vite__mapDeps([6,1,2,3,4,5]))]),this._codeIsReady=!0,this.onCodeIsReadyObservable.notifyObservers(this)}autoConfigure(e,t=()=>!0){if(!this.cameraPosition.isConnected){let i=e.getInputBlockByPredicate(r=>r.systemValue===De.CameraPosition&&t(r));i||(i=new Ee("cameraPosition"),i.setAsSystemValue(De.CameraPosition)),i.output.connectTo(this.cameraPosition)}}prepareDefines(e,t,i){if(!i._areLightsDirty)return;const r=e.getScene();if(!this.light)mu(r,e,i,!0,t.maxSimultaneousLights);else{const s={needNormals:!1,needRebuild:!1,lightmapMode:!1,shadowEnabled:!1,specularEnabled:!1};Wm(r,e,this.light,this._lightId,i,!0,s),s.needRebuild&&i.rebuild()}}updateUniformsAndSamples(e,t,i,r){e.samplers.push("areaLightsLTC1Sampler"),e.samplers.push("areaLightsLTC2Sampler");for(let s=0;s<t.maxSimultaneousLights&&i["LIGHT"+s];s++){const n=e.uniforms.indexOf("vLightData"+s)>=0;$m(s,e.uniforms,e.samplers,i["PROJECTEDLIGHTTEXTURE"+s],r,n,i["IESLIGHTTEXTURE"+s])}}bind(e,t,i){if(!i)return;const r=i.getScene();this.light?Hm(this.light,this._lightId,r,e,!0):_u(r,i,e,!0,t.maxSimultaneousLights)}_injectVertexCode(e){const t=this.worldPosition,i=`//${this.name}`;this.light?(this._lightId=(e.counters.lightCounter!==void 0?e.counters.lightCounter:-1)+1,e.counters.lightCounter=this._lightId,e._emitFunctionFromInclude(e.supportUniformBuffers?"lightVxUboDeclaration":"lightVxFragmentDeclaration",i,{replaceStrings:[{search:/{X}/g,replace:this._lightId.toString()}]},this._lightId.toString())):(e._emitFunctionFromInclude(e.supportUniformBuffers?"lightVxUboDeclaration":"lightVxFragmentDeclaration",i,{repeatKey:"maxSimultaneousLights"}),this._lightId=0,e.sharedData.dynamicUniformBlocks.push(this));const r="v_"+t.associatedVariableName;e._emitVaryingFromString(r,x.Vector4)&&(e.compilationString+=(e.shaderLanguage===1?"vertexOutputs.":"")+`${r} = ${t.associatedVariableName};
`),this.light?e.compilationString+=e._emitCodeFromInclude("shadowsVertex",i,{replaceStrings:[{search:/{X}/g,replace:this._lightId.toString()},{search:/worldPos/g,replace:t.associatedVariableName}]}):(e.compilationString+=`${e._declareLocalVar("worldPos",x.Vector4)} = ${t.associatedVariableName};
`,this.view.isConnected&&(e.compilationString+=`${e._declareLocalVar("view",x.Matrix)} = ${this.view.associatedVariableName};
`),e.compilationString+=e._emitCodeFromInclude("shadowsVertex",i,{repeatKey:"maxSimultaneousLights"}))}_injectUBODeclaration(e){const t=`//${this.name}`;this.light?e._emitFunctionFromInclude(e.supportUniformBuffers?"lightUboDeclaration":"lightFragmentDeclaration",t,{replaceStrings:[{search:/{X}/g,replace:this._lightId.toString()}]},this._lightId.toString()):e._emitFunctionFromInclude(e.supportUniformBuffers?"lightUboDeclaration":"lightFragmentDeclaration",t,{repeatKey:"maxSimultaneousLights",substitutionVars:this.generateOnlyFragmentCode?"varying,":void 0})}_buildBlock(e){super._buildBlock(e);const t=e.shaderLanguage===1,i=t?"f":"",r=`//${this.name}`;if(e.target!==A.Fragment){this._injectVertexCode(e);return}this.generateOnlyFragmentCode&&e.sharedData.dynamicUniformBlocks.push(this);const s=t?"fragmentInputs.":"";e.sharedData.forcedBindableBlocks.push(this),e.sharedData.blocksWithDefines.push(this);const n=this.worldPosition;let o=n.associatedVariableName;this.generateOnlyFragmentCode?(o=e._getFreeVariableName("globalWorldPos"),e._emitFunction("light_globalworldpos",`${e._declareLocalVar(o,x.Vector3)};
`,r),e.compilationString+=`${o} = ${n.associatedVariableName}.xyz;
`,e.compilationString+=e._emitCodeFromInclude("shadowsVertex",r,{repeatKey:"maxSimultaneousLights",substitutionVars:this.generateOnlyFragmentCode?`worldPos,${n.associatedVariableName}`:void 0})):o=s+"v_"+o+".xyz",e._emitFunctionFromInclude("helperFunctions",r);let l={search:/vPositionW/g,replace:o};if(t&&(l={search:/fragmentInputs\.vPositionW/g,replace:o}),e._emitFunctionFromInclude("lightsFragmentFunctions",r,{replaceStrings:[l]}),e._emitFunctionFromInclude("shadowsFragmentFunctions",r,{replaceStrings:[l]}),this._injectUBODeclaration(e),this._lightId===0&&(e._registerTempVariable("viewDirectionW")&&(e.compilationString+=`${e._declareLocalVar("viewDirectionW",x.Vector3)} = normalize(${this.cameraPosition.associatedVariableName} - ${o});
`),e.compilationString+=t?`var info: lightingInfo;
`:`lightingInfo info;
`,e.compilationString+=`${e._declareLocalVar("shadow",x.Float)} = 1.;
`,e.compilationString+=`${e._declareLocalVar("aggShadow",x.Float)} = 0.;
`,e.compilationString+=`${e._declareLocalVar("numLights",x.Float)} = 0.;
`,e.compilationString+=`${e._declareLocalVar("glossiness",x.Float)} = ${this.glossiness.isConnected?this.glossiness.associatedVariableName:"1.0"} * ${this.glossPower.isConnected?this.glossPower.associatedVariableName:"1024.0"};
`,e.compilationString+=`${e._declareLocalVar("diffuseBase",x.Vector3)} = vec3${i}(0., 0., 0.);
`,e.compilationString+=`${e._declareLocalVar("specularBase",x.Vector3)}  = vec3${i}(0., 0., 0.);
`,e.compilationString+=`${e._declareLocalVar("normalW",x.Vector3)} = ${this.worldNormal.associatedVariableName}.xyz;
`),this.light){let h={search:/vPositionW/g,replace:o+".xyz"};t&&(h={search:/fragmentInputs\.vPositionW/g,replace:o+".xyz"}),e.compilationString+=e._emitCodeFromInclude("lightFragment",r,{replaceStrings:[{search:/{X}/g,replace:this._lightId.toString()},h]})}else{let h=`vPositionW,${o}.xyz`;t&&(h=`fragmentInputs.vPositionW,${o}.xyz`),e.compilationString+=e._emitCodeFromInclude("lightFragment",r,{repeatKey:"maxSimultaneousLights",substitutionVars:h})}this._lightId===0&&(e.compilationString+=`aggShadow = aggShadow / numLights;
`);const u=this.diffuseOutput,c=this.specularOutput;return e.compilationString+=e._declareOutput(u)+` = diffuseBase${this.diffuseColor.isConnected?" * "+this.diffuseColor.associatedVariableName:""};
`,c.hasEndpoints&&(e.compilationString+=e._declareOutput(c)+` = specularBase${this.specularColor.isConnected?" * "+this.specularColor.associatedVariableName:""};
`),this.shadow.hasEndpoints&&(e.compilationString+=e._declareOutput(this.shadow)+` = aggShadow;
`),this}serialize(){const e=super.serialize();return e.generateOnlyFragmentCode=this.generateOnlyFragmentCode,this.light&&(e.lightId=this.light.id),e}_deserialize(e,t,i){super._deserialize(e,t,i),e.lightId&&(this.light=t.getLightById(e.lightId)),this.generateOnlyFragmentCode=e.generateOnlyFragmentCode,this._setTarget()}}C([U("Generate only fragment code",0,"ADVANCED",{notifiers:{rebuild:!0,update:!0,onValidation:ld._OnGenerateOnlyFragmentCodeChanged}})],ld.prototype,"generateOnlyFragmentCode",void 0);B("BABYLON.LightBlock",ld);class Zi extends le{get texture(){return this._texture}set texture(e){if(this._texture===e)return;const t=(e==null?void 0:e.getScene())??ze.LastCreatedScene;!e&&t&&t.markAllMaterialsAsDirty(1,i=>i.hasTexture(this._texture)),this._texture=e,e&&t&&t.markAllMaterialsAsDirty(1,i=>i.hasTexture(e))}get samplerName(){return this._samplerName}constructor(e){super(e,A.VertexAndFragment),this.registerOutput("source",x.Object,A.VertexAndFragment,new dt("source",this,1,Zi,"ImageSourceBlock")),this.registerOutput("dimensions",x.Vector2)}bind(e){this.texture&&e.setTexture(this._samplerName,this.texture)}isReady(){return!(this.texture&&!this.texture.isReadyOrNotBlocking())}getClassName(){return"ImageSourceBlock"}get source(){return this._outputs[0]}get dimensions(){return this._outputs[1]}_buildBlock(e){if(super._buildBlock(e),e.target===A.Vertex&&(this._samplerName=e._getFreeVariableName(this.name+"Texture"),e.sharedData.blockingBlocks.push(this),e.sharedData.textureBlocks.push(this),e.sharedData.bindableBlocks.push(this)),this.dimensions.isConnected){let t="";e.shaderLanguage===1?t=`vec2f(textureDimensions(${this._samplerName}, 0).xy)`:t=`vec2(textureSize(${this._samplerName}, 0).xy)`,e.compilationString+=`${e._declareOutput(this.dimensions)} = ${t};
`}return e._emit2DSampler(this._samplerName),this}_dumpPropertiesCode(){let e=super._dumpPropertiesCode();return this.texture&&(e+=`${this._codeVariableName}.texture = new BABYLON.Texture("${this.texture.name}", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});
`,e+=`${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};
`,e+=`${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};
`,e+=`${this._codeVariableName}.texture.uAng = ${this.texture.uAng};
`,e+=`${this._codeVariableName}.texture.vAng = ${this.texture.vAng};
`,e+=`${this._codeVariableName}.texture.wAng = ${this.texture.wAng};
`,e+=`${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};
`,e+=`${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};
`,e+=`${this._codeVariableName}.texture.uScale = ${this.texture.uScale};
`,e+=`${this._codeVariableName}.texture.vScale = ${this.texture.vScale};
`,e+=`${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};
`),e}serialize(){const e=super.serialize();return this.texture&&!this.texture.isRenderTarget&&this.texture.getClassName()!=="VideoTexture"&&(e.texture=this.texture.serialize()),e}_deserialize(e,t,i,r){super._deserialize(e,t,i,r),e.texture&&!ht.IgnoreTexturesAtLoadTime&&e.texture.url!==void 0&&(e.texture.url.indexOf("data:")===0?i="":r&&(e.texture.url=r(e.texture.url),e.texture.name=e.texture.url),this.texture=Y.Parse(e.texture,t,i))}}B("BABYLON.ImageSourceBlock",Zi);class ru extends le{get texture(){var e;return this.source.isConnected?((e=this.source.connectedPoint)==null?void 0:e.ownerBlock).texture:this._texture}set texture(e){if(this._texture===e)return;const t=(e==null?void 0:e.getScene())??ze.LastCreatedScene;!e&&t&&t.markAllMaterialsAsDirty(1,i=>i.hasTexture(this._texture)),this._texture=e,e&&t&&t.markAllMaterialsAsDirty(1,i=>i.hasTexture(e))}static _IsPrePassTextureBlock(e){return(e==null?void 0:e.getClassName())==="PrePassTextureBlock"}get _isSourcePrePass(){return ru._IsPrePassTextureBlock(this._imageSource)}get samplerName(){if(this._imageSource){if(!ru._IsPrePassTextureBlock(this._imageSource))return this._imageSource.samplerName;if(this.source.connectedPoint)return this._imageSource.getSamplerName(this.source.connectedPoint)}return this._samplerName}get hasImageSource(){return this.source.isConnected}set convertToGammaSpace(e){if(e!==this._convertToGammaSpace&&(this._convertToGammaSpace=e,this.texture)){const t=this.texture.getScene()??ze.LastCreatedScene;t==null||t.markAllMaterialsAsDirty(1,i=>i.hasTexture(this.texture))}}get convertToGammaSpace(){return this._convertToGammaSpace}set convertToLinearSpace(e){if(e!==this._convertToLinearSpace&&(this._convertToLinearSpace=e,this.texture)){const t=this.texture.getScene()??ze.LastCreatedScene;t==null||t.markAllMaterialsAsDirty(1,i=>i.hasTexture(this.texture))}}get convertToLinearSpace(){return this._convertToLinearSpace}constructor(e,t=!1){super(e,t?A.Fragment:A.VertexAndFragment),this._convertToGammaSpace=!1,this._convertToLinearSpace=!1,this.disableLevelMultiplication=!1,this._fragmentOnly=t,this.registerInput("uv",x.AutoDetect,!1,A.VertexAndFragment),this.registerInput("source",x.Object,!0,A.VertexAndFragment,new dt("source",this,0,Zi,"ImageSourceBlock")),this.registerInput("layer",x.Float,!0),this.registerInput("lod",x.Float,!0),this.registerOutput("rgba",x.Color4,A.Neutral),this.registerOutput("rgb",x.Color3,A.Neutral),this.registerOutput("r",x.Float,A.Neutral),this.registerOutput("g",x.Float,A.Neutral),this.registerOutput("b",x.Float,A.Neutral),this.registerOutput("a",x.Float,A.Neutral),this.registerOutput("level",x.Float,A.Neutral),this._inputs[0].addExcludedConnectionPointFromAllowedTypes(x.Vector2|x.Vector3|x.Vector4),this._inputs[0]._prioritizeVertex=!t}getClassName(){return"TextureBlock"}get uv(){return this._inputs[0]}get source(){return this._inputs[1]}get layer(){return this._inputs[2]}get lod(){return this._inputs[3]}get rgba(){return this._outputs[0]}get rgb(){return this._outputs[1]}get r(){return this._outputs[2]}get g(){return this._outputs[3]}get b(){return this._outputs[4]}get a(){return this._outputs[5]}get level(){return this._outputs[6]}_isTiedToFragment(e){if(e.target===A.Fragment)return!0;if(e.target===A.Vertex)return!1;if(e.target===A.Neutral||e.target===A.VertexAndFragment){const t=e.ownerBlock;if(t.target===A.Fragment)return!0;for(const i of t.inputs)if(i.isConnected&&this._isTiedToFragment(i.connectedPoint))return!0}return!1}_getEffectiveTarget(){return this._fragmentOnly?A.Fragment:!this.uv.isConnected||this.uv.sourceBlock.isInput?A.VertexAndFragment:this._isTiedToFragment(this.uv.connectedPoint)?A.Fragment:A.VertexAndFragment}get target(){return this._getEffectiveTarget()}set target(e){}autoConfigure(e,t=()=>!0){if(!this.uv.isConnected){if(e.mode===bi.PostProcess){const i=e.getBlockByPredicate(r=>r.name==="uv"&&t(r));i&&i.connectTo(this)}else if(e.mode!==bi.ProceduralTexture){const i=e.mode===bi.Particle?"particle_uv":"uv";let r=e.getInputBlockByPredicate(s=>s.isAttribute&&s.name===i&&t(s));r||(r=new Ee("uv"),r.setAsAttribute(i)),r.output.connectTo(this.uv)}}}initializeDefines(e,t,i){i._areTexturesDirty&&this._mainUVDefineName!==void 0&&i.setValue(this._mainUVDefineName,!1,!0)}prepareDefines(e,t,i){if(!i._areTexturesDirty)return;if(!this.texture||!this.texture.getTextureMatrix){this._isMixed&&(i.setValue(this._defineName,!1,!0),i.setValue(this._mainUVDefineName,!0,!0));return}const r=this.convertToGammaSpace&&this.texture&&!this.texture.gammaSpace,s=this.convertToLinearSpace&&this.texture&&this.texture.gammaSpace;i.setValue(this._linearDefineName,r,!0),i.setValue(this._gammaDefineName,s,!0),this._isMixed&&(this.texture.getTextureMatrix().isIdentityAs3x2()?(i.setValue(this._defineName,!1,!0),i.setValue(this._mainUVDefineName,!0,!0)):(i.setValue(this._defineName,!0),i[this._mainUVDefineName]==null&&i.setValue(this._mainUVDefineName,!1,!0)))}isReady(){return this._isSourcePrePass?!0:!(this.texture&&!this.texture.isReadyOrNotBlocking())}bind(e){this._isSourcePrePass&&e.setFloat(this._textureInfoName,1),this.texture&&(this._isMixed&&(e.setFloat(this._textureInfoName,this.texture.level),e.setMatrix(this._textureTransformName,this.texture.getTextureMatrix())),this._imageSource||e.setTexture(this._samplerName,this.texture))}get _isMixed(){return this.target!==A.Fragment}_injectVertexCode(e){const t=this.uv;this._defineName=e._getFreeDefineName("UVTRANSFORM"),this._mainUVDefineName="VMAIN"+t.declarationVariableName.toUpperCase(),this._mainUVName="vMain"+t.declarationVariableName,this._transformedUVName=e._getFreeVariableName("transformedUV"),this._textureTransformName=e._getFreeVariableName("textureTransform"),this._textureInfoName=e._getFreeVariableName("textureInfoName"),this.level.associatedVariableName=this._textureInfoName,e._emitVaryingFromString(this._transformedUVName,x.Vector2,this._defineName),e._emitVaryingFromString(this._mainUVName,x.Vector2,this._mainUVDefineName),e._emitUniformFromString(this._textureTransformName,x.Matrix,this._defineName);const i=e._getShaderType(x.Vector4),r=e._getShaderType(x.Vector2);e.compilationString+=`#ifdef ${this._defineName}
`,e.compilationString+=`${e._getVaryingName(this._transformedUVName)} = ${r}(${this._textureTransformName} * ${i}(${t.associatedVariableName}.xy, 1.0, 0.0));
`,e.compilationString+=`#elif defined(${this._mainUVDefineName})
`;let s="";if(e.shaderLanguage===1&&t.isConnectedToInputBlock&&t.associatedVariableName.indexOf("vertexInputs.")===-1&&(s="vertexInputs."),e.compilationString+=`${e._getVaryingName(this._mainUVName)} = ${s}${t.associatedVariableName}.xy;
`,e.compilationString+=`#endif
`,!!this._outputs.some(n=>n.isConnectedInVertexShader)){this._writeTextureRead(e,!0);for(const n of this._outputs)n.hasEndpoints&&n.name!=="level"&&this._writeOutput(e,n,n.name,!0)}}_getUVW(e){var s,n,o,l;let t=e;const i=((n=(s=this._texture)==null?void 0:s._texture)==null?void 0:n.is2DArray)??!1,r=((l=(o=this._texture)==null?void 0:o._texture)==null?void 0:l.is3D)??!1;if(i){const u=this.layer.isConnected?this.layer.associatedVariableName:"0";t=`vec3(${e}, ${u})`}else if(r){const u=this.layer.isConnected?this.layer.associatedVariableName:"0";t=`vec3(${e}, ${u})`}return t}_samplerFunc(e){return e.shaderLanguage===1?e.target===A.Vertex?"textureSampleLevel":"textureSample":this.lod.isConnected?"texture2DLodEXT":"texture2D"}get _samplerLodSuffix(){return this.lod.isConnected?`, ${this.lod.associatedVariableName}`:""}_generateTextureSample(e,t){if(t.shaderLanguage===1){const i=t.target===A.Vertex;return`${this._samplerFunc(t)}(${this.samplerName},${this.samplerName+"Sampler"}, ${this._getUVW(e)}${this._samplerLodSuffix}${i?", 0":""})`}return`${this._samplerFunc(t)}(${this.samplerName}, ${this._getUVW(e)}${this._samplerLodSuffix})`}_generateTextureLookup(e){e.compilationString+=`#ifdef ${this._defineName}
`,e.compilationString+=`${e._declareLocalVar(this._tempTextureRead,x.Vector4)} = ${this._generateTextureSample(e._getVaryingName(this._transformedUVName),e)};
`,e.compilationString+=`#elif defined(${this._mainUVDefineName})
`,e.compilationString+=`${e._declareLocalVar(this._tempTextureRead,x.Vector4)} = ${this._generateTextureSample(this._mainUVName?e._getVaryingName(this._mainUVName):this.uv.associatedVariableName,e)}${this._samplerLodSuffix};
`,e.compilationString+=`#endif
`}_writeTextureRead(e,t=!1){const i=this.uv;if(t){if(e.target===A.Fragment)return;this._generateTextureLookup(e);return}if(this.uv.ownerBlock.target===A.Fragment){e.compilationString+=`${e._declareLocalVar(this._tempTextureRead,x.Vector4)} = ${this._generateTextureSample(i.associatedVariableName,e)}${this._samplerLodSuffix};
`;return}this._generateTextureLookup(e)}_generateConversionCode(e,t,i){i!=="a"&&((!this.texture||!this.texture.gammaSpace)&&(e.compilationString+=`#ifdef ${this._linearDefineName}
                    ${t.associatedVariableName} = toGammaSpace(${t.associatedVariableName});
                    #endif
                `),e.compilationString+=`#ifdef ${this._gammaDefineName}
                ${t.associatedVariableName} = ${e._toLinearSpace(t)};
                #endif
            `)}_writeOutput(e,t,i,r=!1){if(r){if(e.target===A.Fragment)return;e.compilationString+=`${e._declareOutput(t)} = ${this._tempTextureRead}.${i};
`,this._generateConversionCode(e,t,i);return}if(this.uv.ownerBlock.target===A.Fragment){e.compilationString+=`${e._declareOutput(t)} = ${this._tempTextureRead}.${i};
`,this._generateConversionCode(e,t,i);return}let s="";this.disableLevelMultiplication||(s=` * ${(e.shaderLanguage===1?"uniforms.":"")+this._textureInfoName}`),e.compilationString+=`${e._declareOutput(t)} = ${this._tempTextureRead}.${i}${s};
`,this._generateConversionCode(e,t,i)}_buildBlock(e){var i,r,s,n;if(super._buildBlock(e),this.source.isConnected?this._imageSource=this.source.connectedPoint.ownerBlock:this._imageSource=null,(e.target===A.Vertex||this._fragmentOnly||e.target===A.Fragment)&&(this._tempTextureRead=e._getFreeVariableName("tempTextureRead"),this._linearDefineName=e._getFreeDefineName("ISLINEAR"),this._gammaDefineName=e._getFreeDefineName("ISGAMMA")),!this._isMixed&&e.target===A.Fragment||this._isMixed&&e.target===A.Vertex){if(!this._imageSource){const o=e._getFreeVariableName(this.name);this._samplerName=o+"Texture",(r=(i=this._texture)==null?void 0:i._texture)!=null&&r.is2DArray?e._emit2DArraySampler(this._samplerName):e._emit2DSampler(this._samplerName)}e.sharedData.blockingBlocks.push(this),e.sharedData.textureBlocks.push(this),e.sharedData.blocksWithDefines.push(this),e.sharedData.bindableBlocks.push(this)}if(e.target!==A.Fragment){this._injectVertexCode(e);return}if(!this._outputs.some(o=>o.isConnectedInFragmentShader))return;this._isMixed&&!this._imageSource&&((n=(s=this._texture)==null?void 0:s._texture)!=null&&n.is2DArray?e._emit2DArraySampler(this._samplerName):e._emit2DSampler(this._samplerName));const t=`//${this.name}`;e._emitFunctionFromInclude("helperFunctions",t),this._isMixed&&e._emitUniformFromString(this._textureInfoName,x.Float),this._writeTextureRead(e);for(const o of this._outputs)o.hasEndpoints&&o.name!=="level"&&this._writeOutput(e,o,o.name);return this}_dumpPropertiesCode(){let e=super._dumpPropertiesCode();return e+=`${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};
`,e+=`${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};
`,e+=`${this._codeVariableName}.disableLevelMultiplication = ${this.disableLevelMultiplication};
`,this.texture&&(e+=`${this._codeVariableName}.texture = new BABYLON.Texture("${this.texture.name}", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});
`,e+=`${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};
`,e+=`${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};
`,e+=`${this._codeVariableName}.texture.uAng = ${this.texture.uAng};
`,e+=`${this._codeVariableName}.texture.vAng = ${this.texture.vAng};
`,e+=`${this._codeVariableName}.texture.wAng = ${this.texture.wAng};
`,e+=`${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};
`,e+=`${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};
`,e+=`${this._codeVariableName}.texture.uScale = ${this.texture.uScale};
`,e+=`${this._codeVariableName}.texture.vScale = ${this.texture.vScale};
`,e+=`${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};
`),e}serialize(){const e=super.serialize();return e.convertToGammaSpace=this.convertToGammaSpace,e.convertToLinearSpace=this.convertToLinearSpace,e.fragmentOnly=this._fragmentOnly,e.disableLevelMultiplication=this.disableLevelMultiplication,!this.hasImageSource&&this.texture&&!this.texture.isRenderTarget&&this.texture.getClassName()!=="VideoTexture"&&(e.texture=this.texture.serialize()),e}_deserialize(e,t,i,r){super._deserialize(e,t,i),this.convertToGammaSpace=e.convertToGammaSpace,this.convertToLinearSpace=!!e.convertToLinearSpace,this._fragmentOnly=!!e.fragmentOnly,this.disableLevelMultiplication=!!e.disableLevelMultiplication,e.texture&&!ht.IgnoreTexturesAtLoadTime&&e.texture.url!==void 0&&(e.texture.url.indexOf("data:")===0?i="":r&&(e.texture.url=r(e.texture.url),e.texture.name=e.texture.url),this.texture=Y.Parse(e.texture,t,i))}}B("BABYLON.TextureBlock",ru);class Xo extends le{get texture(){return this._texture}set texture(e){if(this._texture===e)return;const t=(e==null?void 0:e.getScene())??ze.LastCreatedScene;!e&&t&&t.markAllMaterialsAsDirty(1,i=>i.hasTexture(this._texture)),this._texture=e,e&&t&&t.markAllMaterialsAsDirty(1,i=>i.hasTexture(e))}static _OnGenerateOnlyFragmentCodeChanged(e,t){return e._onGenerateOnlyFragmentCodeChanged()}_onGenerateOnlyFragmentCodeChanged(){return this._setTarget(),!0}_setTarget(){this._setInitialTarget(this.generateOnlyFragmentCode?A.Fragment:A.VertexAndFragment)}constructor(e){super(e,A.VertexAndFragment),this.generateOnlyFragmentCode=!1}getClassName(){return"ReflectionTextureBaseBlock"}_getTexture(){return this.texture}initialize(e){this._initShaderSourceAsync(e.shaderLanguage)}async _initShaderSourceAsync(e){this._codeIsReady=!1,e===1?await k(()=>import("./oitFragment-COwarqmx.js").then(t=>t.f),__vite__mapDeps([8,1,2,3,4,5])):await k(()=>import("./oitFragment-C1qnXpVq.js").then(t=>t.g),__vite__mapDeps([9,1,2,3,4,5])),this._codeIsReady=!0,this.onCodeIsReadyObservable.notifyObservers(this)}autoConfigure(e,t=()=>!0){if(!this.position.isConnected){let i=e.getInputBlockByPredicate(r=>r.isAttribute&&r.name==="position"&&t(r));i||(i=new Ee("position"),i.setAsAttribute()),i.output.connectTo(this.position)}if(!this.world.isConnected){let i=e.getInputBlockByPredicate(r=>r.systemValue===De.World&&t(r));i||(i=new Ee("world"),i.setAsSystemValue(De.World)),i.output.connectTo(this.world)}if(this.view&&!this.view.isConnected){let i=e.getInputBlockByPredicate(r=>r.systemValue===De.View&&t(r));i||(i=new Ee("view"),i.setAsSystemValue(De.View)),i.output.connectTo(this.view)}}prepareDefines(e,t,i){if(!i._areTexturesDirty)return;const r=this._getTexture();!r||!r.getTextureMatrix||(i.setValue(this._define3DName,r.isCube,!0),i.setValue(this._defineLocalCubicName,!!r.boundingBoxSize,!0),i.setValue(this._defineExplicitName,r.coordinatesMode===0,!0),i.setValue(this._defineSkyboxName,r.coordinatesMode===5,!0),i.setValue(this._defineCubicName,r.coordinatesMode===3||r.coordinatesMode===6,!0),i.setValue("INVERTCUBICMAP",r.coordinatesMode===6,!0),i.setValue(this._defineSphericalName,r.coordinatesMode===1,!0),i.setValue(this._definePlanarName,r.coordinatesMode===2,!0),i.setValue(this._defineProjectionName,r.coordinatesMode===4,!0),i.setValue(this._defineEquirectangularName,r.coordinatesMode===7,!0),i.setValue(this._defineEquirectangularFixedName,r.coordinatesMode===8,!0),i.setValue(this._defineMirroredEquirectangularFixedName,r.coordinatesMode===9,!0))}isReady(){const e=this._getTexture();return!(e&&!e.isReadyOrNotBlocking())}bind(e,t,i,r){const s=this._getTexture();if(!(!i||!s)&&(e.setMatrix(this._reflectionMatrixName,s.getReflectionTextureMatrix()),s.isCube?e.setTexture(this._cubeSamplerName,s):e.setTexture(this._2DSamplerName,s),s.boundingBoxSize)){const n=s;e.setVector3(this._reflectionPositionName,n.boundingBoxPosition),e.setVector3(this._reflectionSizeName,n.boundingBoxSize)}}handleVertexSide(e){if(this.generateOnlyFragmentCode&&e.target===A.Vertex)return"";const t=e.shaderLanguage===1;this._define3DName=e._getFreeDefineName("REFLECTIONMAP_3D"),this._defineCubicName=e._getFreeDefineName("REFLECTIONMAP_CUBIC"),this._defineSphericalName=e._getFreeDefineName("REFLECTIONMAP_SPHERICAL"),this._definePlanarName=e._getFreeDefineName("REFLECTIONMAP_PLANAR"),this._defineProjectionName=e._getFreeDefineName("REFLECTIONMAP_PROJECTION"),this._defineExplicitName=e._getFreeDefineName("REFLECTIONMAP_EXPLICIT"),this._defineEquirectangularName=e._getFreeDefineName("REFLECTIONMAP_EQUIRECTANGULAR"),this._defineLocalCubicName=e._getFreeDefineName("USE_LOCAL_REFLECTIONMAP_CUBIC"),this._defineMirroredEquirectangularFixedName=e._getFreeDefineName("REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED"),this._defineEquirectangularFixedName=e._getFreeDefineName("REFLECTIONMAP_EQUIRECTANGULAR_FIXED"),this._defineSkyboxName=e._getFreeDefineName("REFLECTIONMAP_SKYBOX"),this._defineOppositeZ=e._getFreeDefineName("REFLECTIONMAP_OPPOSITEZ"),this._reflectionMatrixName=e._getFreeVariableName("reflectionMatrix"),e._emitUniformFromString(this._reflectionMatrixName,x.Matrix);let i="";this._worldPositionNameInFragmentOnlyMode=e._getFreeVariableName("worldPosition");const r=this.generateOnlyFragmentCode?this._worldPositionNameInFragmentOnlyMode:"v_"+this.worldPosition.associatedVariableName;return(this.generateOnlyFragmentCode||e._emitVaryingFromString(r,x.Vector4))&&(this.generateOnlyFragmentCode?i+=`${e._declareLocalVar(r,x.Vector4)} = ${this.worldPosition.associatedVariableName};
`:i+=`${t?"vertexOutputs.":""}${r} = ${this.worldPosition.associatedVariableName};
`),this._positionUVWName=e._getFreeVariableName("positionUVW"),this._directionWName=e._getFreeVariableName("directionW"),(this.generateOnlyFragmentCode||e._emitVaryingFromString(this._positionUVWName,x.Vector3,this._defineSkyboxName))&&(i+=`#ifdef ${this._defineSkyboxName}
`,this.generateOnlyFragmentCode?i+=`${e._declareLocalVar(this._positionUVWName,x.Vector3)} = ${this.position.associatedVariableName}.xyz;
`:i+=`${t?"vertexOutputs.":""}${this._positionUVWName} = ${this.position.associatedVariableName}.xyz;
`,i+=`#endif
`),(this.generateOnlyFragmentCode||e._emitVaryingFromString(this._directionWName,x.Vector3,`defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})`))&&(i+=`#if defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})
`,this.generateOnlyFragmentCode?i+=`${e._declareLocalVar(this._directionWName,x.Vector3)} = normalize(vec3${e.fSuffix}(${this.world.associatedVariableName} * vec4${e.fSuffix}(${this.position.associatedVariableName}.xyz, 0.0)));
`:i+=`${t?"vertexOutputs.":""}${this._directionWName} = normalize(vec3${e.fSuffix}(${this.world.associatedVariableName} * vec4${e.fSuffix}(${this.position.associatedVariableName}.xyz, 0.0)));
`,i+=`#endif
`),i}handleFragmentSideInits(e){e.sharedData.blockingBlocks.push(this),e.sharedData.textureBlocks.push(this),this._cubeSamplerName=e._getFreeVariableName(this.name+"CubeSampler"),e.samplers.push(this._cubeSamplerName),this._2DSamplerName=e._getFreeVariableName(this.name+"2DSampler"),e.samplers.push(this._2DSamplerName),e._samplerDeclaration+=`#ifdef ${this._define3DName}
`,e._emitCubeSampler(this._cubeSamplerName,"",!0),e._samplerDeclaration+=`#else
`,e._emit2DSampler(this._2DSamplerName,"",!0),e._samplerDeclaration+=`#endif
`,e.sharedData.blocksWithDefines.push(this),e.sharedData.bindableBlocks.push(this);const t=`//${this.name}`;e._emitFunctionFromInclude("helperFunctions",t),e._emitFunctionFromInclude("reflectionFunction",t,{replaceStrings:[{search:/vec3 computeReflectionCoords/g,replace:"void DUMMYFUNC"},{search:/fn computeReflectionCoords\(worldPos: vec4f,worldNormal: vec3f\)->vec3f/g,replace:"fn DUMMYFUNC()"}]}),this._reflectionColorName=e._getFreeVariableName("reflectionColor"),this._reflectionVectorName=e._getFreeVariableName("reflectionUVW"),this._reflectionCoordsName=e._getFreeVariableName("reflectionCoords"),this._reflectionPositionName=e._getFreeVariableName("vReflectionPosition"),e._emitUniformFromString(this._reflectionPositionName,x.Vector3),this._reflectionSizeName=e._getFreeVariableName("vReflectionPosition"),e._emitUniformFromString(this._reflectionSizeName,x.Vector3)}handleFragmentSideCodeReflectionCoords(e,t,i,r=!1,s=!1){const n=e.shaderLanguage===1,o=(n?"uniforms.":"")+this._reflectionMatrixName,l=`normalize(${this._directionWName})`,u=`${this._positionUVWName}`,c=`${this.cameraPosition.associatedVariableName}`,h=`${this.view.associatedVariableName}`,d=n?"fragmentInputs.":"";i||(i=this.generateOnlyFragmentCode?this._worldPositionNameInFragmentOnlyMode:`${d}v_${this.worldPosition.associatedVariableName}`),t+=".xyz";let f=`
            #ifdef ${this._defineMirroredEquirectangularFixedName}
               ${e._declareLocalVar(this._reflectionVectorName,x.Vector3)} = computeMirroredFixedEquirectangularCoords(${i}, ${t}, ${l});
            #endif

            #ifdef ${this._defineEquirectangularFixedName}
                ${e._declareLocalVar(this._reflectionVectorName,x.Vector3)} = computeFixedEquirectangularCoords(${i}, ${t}, ${l});
            #endif

            #ifdef ${this._defineEquirectangularName}
                ${e._declareLocalVar(this._reflectionVectorName,x.Vector3)} = computeEquirectangularCoords(${i}, ${t}, ${c}.xyz, ${o});
            #endif

            #ifdef ${this._defineSphericalName}
                ${e._declareLocalVar(this._reflectionVectorName,x.Vector3)} = computeSphericalCoords(${i}, ${t}, ${h}, ${o});
            #endif

            #ifdef ${this._definePlanarName}
                ${e._declareLocalVar(this._reflectionVectorName,x.Vector3)} = computePlanarCoords(${i}, ${t}, ${c}.xyz, ${o});
            #endif

            #ifdef ${this._defineCubicName}
                #ifdef ${this._defineLocalCubicName}
                    ${e._declareLocalVar(this._reflectionVectorName,x.Vector3)} = computeCubicLocalCoords(${i}, ${t}, ${c}.xyz, ${o}, ${this._reflectionSizeName}, ${this._reflectionPositionName});
                #else
                ${e._declareLocalVar(this._reflectionVectorName,x.Vector3)} = computeCubicCoords(${i}, ${t}, ${c}.xyz, ${o});
                #endif
            #endif

            #ifdef ${this._defineProjectionName}
                ${e._declareLocalVar(this._reflectionVectorName,x.Vector3)} = computeProjectionCoords(${i}, ${h}, ${o});
            #endif

            #ifdef ${this._defineSkyboxName}
                ${e._declareLocalVar(this._reflectionVectorName,x.Vector3)} = computeSkyBoxCoords(${u}, ${o});
            #endif

            #ifdef ${this._defineExplicitName}
                ${e._declareLocalVar(this._reflectionVectorName,x.Vector3)} = vec3(0, 0, 0);
            #endif
`;return s||(f+=`#ifdef ${this._defineOppositeZ}
                ${this._reflectionVectorName}.z *= -1.0;
            #endif
`),r||(f+=`
                #ifdef ${this._define3DName}
                    ${e._declareLocalVar(this._reflectionCoordsName,x.Vector3)} = ${this._reflectionVectorName};
                #else
                    ${e._declareLocalVar(this._reflectionCoordsName,x.Vector2)} = ${this._reflectionVectorName}.xy;
                    #ifdef ${this._defineProjectionName}
                        ${this._reflectionCoordsName} /= ${this._reflectionVectorName}.z;
                    #endif
                    ${this._reflectionCoordsName}.y = 1.0 - ${this._reflectionCoordsName}.y;
                #endif
`),f}handleFragmentSideCodeReflectionColor(e,t,i=".rgb"){let r=x.Vector4;i.length===3&&(r=x.Vector3);let s=`${e._declareLocalVar(this._reflectionColorName,r)};
            #ifdef ${this._define3DName}
`;return t?s+=`${this._reflectionColorName} = ${e._generateTextureSampleCubeLOD(this._reflectionVectorName,this._cubeSamplerName,t)}${i};
`:s+=`${this._reflectionColorName} = ${e._generateTextureSampleCube(this._reflectionVectorName,this._cubeSamplerName)}${i};
`,s+=`
            #else
`,t?s+=`${this._reflectionColorName} =${e._generateTextureSampleLOD(this._reflectionCoordsName,this._2DSamplerName,t)}${i};
`:s+=`${this._reflectionColorName} = ${e._generateTextureSample(this._reflectionCoordsName,this._2DSamplerName)}${i};
`,s+=`#endif
`,s}writeOutputs(e,t){let i="";if(e.target===A.Fragment)for(const r of this._outputs)r.hasEndpoints&&(i+=`${e._declareOutput(r)} = ${t}.${r.name};
`);return i}_buildBlock(e){return super._buildBlock(e),this}_dumpPropertiesCode(){let e=super._dumpPropertiesCode();if(!this.texture)return e;if(this.texture.isCube){const t=this.texture.forcedExtension;e+=`${this._codeVariableName}.texture = new BABYLON.CubeTexture("${this.texture.name}", undefined, undefined, ${this.texture.noMipmap}, null, undefined, undefined, undefined, ${this.texture._prefiltered}, ${t?'"'+t+'"':"null"});
`}else e+=`${this._codeVariableName}.texture = new BABYLON.Texture("${this.texture.name}", null);
`;return e+=`${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};
`,e}serialize(){const e=super.serialize();return this.texture&&!this.texture.isRenderTarget&&(e.texture=this.texture.serialize()),e.generateOnlyFragmentCode=this.generateOnlyFragmentCode,e}_deserialize(e,t,i){super._deserialize(e,t,i),e.texture&&!ht.IgnoreTexturesAtLoadTime&&(i=e.texture.url.indexOf("data:")===0?"":i,e.texture.isCube?this.texture=rn.Parse(e.texture,t,i):this.texture=Y.Parse(e.texture,t,i)),this.generateOnlyFragmentCode=e.generateOnlyFragmentCode,this._setTarget()}}C([U("Generate only fragment code",0,"ADVANCED",{notifiers:{rebuild:!0,update:!0,onValidation:Xo._OnGenerateOnlyFragmentCodeChanged}})],Xo.prototype,"generateOnlyFragmentCode",void 0);B("BABYLON.ReflectionTextureBaseBlock",Xo);class DF extends Xo{_onGenerateOnlyFragmentCodeChanged(){return this.position.isConnected?(this.generateOnlyFragmentCode=!this.generateOnlyFragmentCode,L.Error("The position input must not be connected to be able to switch!"),!1):this.worldPosition.isConnected?(this.generateOnlyFragmentCode=!this.generateOnlyFragmentCode,L.Error("The worldPosition input must not be connected to be able to switch!"),!1):(this._setTarget(),!0)}_setTarget(){super._setTarget(),this.getInputByName("position").target=this.generateOnlyFragmentCode?A.Fragment:A.Vertex,this.getInputByName("worldPosition").target=this.generateOnlyFragmentCode?A.Fragment:A.Vertex}constructor(e){super(e),this.registerInput("position",x.AutoDetect,!1,A.Vertex),this.registerInput("worldPosition",x.Vector4,!1,A.Vertex),this.registerInput("worldNormal",x.Vector4,!1,A.Fragment),this.registerInput("world",x.Matrix,!1,A.Vertex),this.registerInput("cameraPosition",x.Vector3,!1,A.Fragment),this.registerInput("view",x.Matrix,!1,A.Fragment),this.registerOutput("rgb",x.Color3,A.Fragment),this.registerOutput("rgba",x.Color4,A.Fragment),this.registerOutput("r",x.Float,A.Fragment),this.registerOutput("g",x.Float,A.Fragment),this.registerOutput("b",x.Float,A.Fragment),this.registerOutput("a",x.Float,A.Fragment),this._inputs[0].addExcludedConnectionPointFromAllowedTypes(x.Color3|x.Vector3|x.Vector4)}getClassName(){return"ReflectionTextureBlock"}get position(){return this._inputs[0]}get worldPosition(){return this._inputs[1]}get worldNormal(){return this._inputs[2]}get world(){return this._inputs[3]}get cameraPosition(){return this._inputs[4]}get view(){return this._inputs[5]}get rgb(){return this._outputs[0]}get rgba(){return this._outputs[1]}get r(){return this._outputs[2]}get g(){return this._outputs[3]}get b(){return this._outputs[4]}get a(){return this._outputs[5]}autoConfigure(e,t=()=>!0){if(super.autoConfigure(e),!this.cameraPosition.isConnected){let i=e.getInputBlockByPredicate(r=>r.systemValue===De.CameraPosition&&t(r));i||(i=new Ee("cameraPosition"),i.setAsSystemValue(De.CameraPosition)),i.output.connectTo(this.cameraPosition)}}_buildBlock(e){if(super._buildBlock(e),!this.texture)return e.compilationString+=this.writeOutputs(e,`vec4${e.fSuffix}(0.)`),this;if(e.target!==A.Fragment)return e.compilationString+=this.handleVertexSide(e),this;this.generateOnlyFragmentCode&&(e.compilationString+=this.handleVertexSide(e)),this.handleFragmentSideInits(e);const t=e._getFreeVariableName("normalWUnit");return e.compilationString+=`${e._declareLocalVar(t,x.Vector4)} = normalize(${this.worldNormal.associatedVariableName});
`,e.compilationString+=this.handleFragmentSideCodeReflectionCoords(e,t),e.compilationString+=this.handleFragmentSideCodeReflectionColor(e,void 0,""),e.compilationString+=this.writeOutputs(e,this._reflectionColorName),this}}B("BABYLON.ReflectionTextureBlock",DF);class ec extends le{constructor(e){super(e,A.VertexAndFragment),this.useNonLinearDepth=!1,this.storeCameraSpaceZ=!1,this.force32itsFloat=!1,this._isUnique=!0,this.registerInput("uv",x.AutoDetect,!1,A.VertexAndFragment),this.registerOutput("depth",x.Float,A.Neutral),this._inputs[0].addExcludedConnectionPointFromAllowedTypes(x.Vector2|x.Vector3|x.Vector4),this._inputs[0]._prioritizeVertex=!1}getClassName(){return"SceneDepthBlock"}get uv(){return this._inputs[0]}get depth(){return this._outputs[0]}initialize(e){e._excludeVariableName("textureSampler")}get target(){return!this.uv.isConnected||this.uv.sourceBlock.isInput?A.VertexAndFragment:A.Fragment}_getTexture(e){return e.enableDepthRenderer(void 0,this.useNonLinearDepth,this.force32itsFloat,void 0,this.storeCameraSpaceZ).getDepthMap()}bind(e,t){const i=this._getTexture(t.getScene());e.setTexture(this._samplerName,i)}_injectVertexCode(e){const t=this.uv;if(t.connectedPoint.ownerBlock.isInput&&(t.connectedPoint.ownerBlock.isAttribute||e._emitUniformFromString(t.associatedVariableName,t.type===x.Vector3?x.Vector3:t.type===x.Vector4?x.Vector4:x.Vector2)),this._mainUVName="vMain"+t.associatedVariableName,e._emitVaryingFromString(this._mainUVName,x.Vector2),e.compilationString+=`${this._mainUVName} = ${t.associatedVariableName}.xy;
`,!!this._outputs.some(i=>i.isConnectedInVertexShader)){this._writeTextureRead(e,!0);for(const i of this._outputs)i.hasEndpoints&&this._writeOutput(e,i,"r",!0)}}_writeTextureRead(e,t=!1){const i=this.uv;if(t){if(e.target===A.Fragment)return;const s=e.shaderLanguage===0?`texture2D(${this._samplerName},`:`textureSampleLevel(${this._samplerName}, ${this._samplerName+"Sampler"},`,n=e.shaderLanguage===0?"":", 0";e.compilationString+=`${e._declareLocalVar(this._tempTextureRead,x.Vector4)}=  ${s} ${i.associatedVariableName}.xy${n});
`;return}const r=e.shaderLanguage===0?`texture2D(${this._samplerName},`:`textureSample(${this._samplerName}, ${this._samplerName+"Sampler"},`;if(this.uv.ownerBlock.target===A.Fragment){e.compilationString+=`${e._declareLocalVar(this._tempTextureRead,x.Vector4)} = ${r} ${i.associatedVariableName}.xy);
`;return}e.compilationString+=`${e._declareLocalVar(this._tempTextureRead,x.Vector4)} = ${r} ${this._mainUVName});
`}_writeOutput(e,t,i,r=!1){if(r){if(e.target===A.Fragment)return;e.compilationString+=`${e._declareOutput(t)} = ${this._tempTextureRead}.${i};
`;return}if(this.uv.ownerBlock.target===A.Fragment){e.compilationString+=`${e._declareOutput(t)} = ${this._tempTextureRead}.${i};
`;return}e.compilationString+=`${e._declareOutput(t)} = ${this._tempTextureRead}.${i};
`}_buildBlock(e){if(super._buildBlock(e),this._samplerName=e._getFreeVariableName(this.name+"Sampler"),this._tempTextureRead=e._getFreeVariableName("tempTextureRead"),e.sharedData.bindableBlocks.indexOf(this)<0&&e.sharedData.bindableBlocks.push(this),e.target!==A.Fragment){e._emit2DSampler(this._samplerName),this._injectVertexCode(e);return}if(this._outputs.some(t=>t.isConnectedInFragmentShader)){e._emit2DSampler(this._samplerName),this._writeTextureRead(e);for(const t of this._outputs)t.hasEndpoints&&this._writeOutput(e,t,"r");return this}}serialize(){const e=super.serialize();return e.useNonLinearDepth=this.useNonLinearDepth,e.storeCameraSpaceZ=this.storeCameraSpaceZ,e.force32itsFloat=this.force32itsFloat,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.useNonLinearDepth=e.useNonLinearDepth,this.storeCameraSpaceZ=!!e.storeCameraSpaceZ,this.force32itsFloat=e.force32itsFloat}}C([U("Use non linear depth",0,"ADVANCED",{embedded:!0,notifiers:{activatePreviewCommand:!0,callback:(a,e)=>{const t=e;let i=!1;return t.useNonLinearDepth&&(t.storeCameraSpaceZ=!1,i=!0),a&&a.disableDepthRenderer(),i}}})],ec.prototype,"useNonLinearDepth",void 0);C([U("Store Camera space Z",0,"ADVANCED",{notifiers:{activatePreviewCommand:!0,callback:(a,e)=>{const t=e;let i=!1;return t.storeCameraSpaceZ&&(t.useNonLinearDepth=!1,i=!0),a&&a.disableDepthRenderer(),i}}})],ec.prototype,"storeCameraSpaceZ",void 0);C([U("Force 32 bits float",0,"ADVANCED",{notifiers:{activatePreviewCommand:!0,callback:a=>a==null?void 0:a.disableDepthRenderer()}})],ec.prototype,"force32itsFloat",void 0);B("BABYLON.SceneDepthBlock",ec);class OF extends le{constructor(e){super(e,A.VertexAndFragment,!0),this.registerInput("worldPosition",x.Vector4,!1)}getClassName(){return"ClipPlanesBlock"}initialize(e){e._excludeVariableName("vClipPlane"),e._excludeVariableName("fClipDistance"),e._excludeVariableName("vClipPlane2"),e._excludeVariableName("fClipDistance2"),e._excludeVariableName("vClipPlane3"),e._excludeVariableName("fClipDistance3"),e._excludeVariableName("vClipPlane4"),e._excludeVariableName("fClipDistance4"),e._excludeVariableName("vClipPlane5"),e._excludeVariableName("fClipDistance5"),e._excludeVariableName("vClipPlane6"),e._excludeVariableName("fClipDistance6"),this._initShaderSourceAsync(e.shaderLanguage)}async _initShaderSourceAsync(e){this._codeIsReady=!1,e===1?await Promise.all([k(()=>import("./pointsCloudSystem-2vcS-S4d.js").then(t=>t.h7),__vite__mapDeps([1,2,3,4,5])),k(()=>import("./pointsCloudSystem-2vcS-S4d.js").then(t=>t.h6),__vite__mapDeps([1,2,3,4,5])),k(()=>import("./pointsCloudSystem-2vcS-S4d.js").then(t=>t.h9),__vite__mapDeps([1,2,3,4,5])),k(()=>import("./pointsCloudSystem-2vcS-S4d.js").then(t=>t.h8),__vite__mapDeps([1,2,3,4,5]))]):await Promise.all([k(()=>import("./pointsCloudSystem-2vcS-S4d.js").then(t=>t.h2),__vite__mapDeps([1,2,3,4,5])),k(()=>import("./pointsCloudSystem-2vcS-S4d.js").then(t=>t.h1),__vite__mapDeps([1,2,3,4,5])),k(()=>import("./pointsCloudSystem-2vcS-S4d.js").then(t=>t.h4),__vite__mapDeps([1,2,3,4,5])),k(()=>import("./pointsCloudSystem-2vcS-S4d.js").then(t=>t.h3),__vite__mapDeps([1,2,3,4,5]))]),this._codeIsReady=!0,this.onCodeIsReadyObservable.notifyObservers(this)}get worldPosition(){return this._inputs[0]}get target(){return A.VertexAndFragment}set target(e){}prepareDefines(e,t,i){const r=e.getScene(),s=!!(t.clipPlane??r.clipPlane),n=!!(t.clipPlane2??r.clipPlane2),o=!!(t.clipPlane3??r.clipPlane3),l=!!(t.clipPlane4??r.clipPlane4),u=!!(t.clipPlane5??r.clipPlane5),c=!!(t.clipPlane6??r.clipPlane6);i.setValue("CLIPPLANE",s,!0),i.setValue("CLIPPLANE2",n,!0),i.setValue("CLIPPLANE3",o,!0),i.setValue("CLIPPLANE4",l,!0),i.setValue("CLIPPLANE5",u,!0),i.setValue("CLIPPLANE6",c,!0)}bind(e,t,i){if(!i)return;const r=i.getScene();Fs(e,t,r)}_buildBlock(e){super._buildBlock(e);const t=`//${this.name}`;if(e.target!==A.Fragment){const i=this.worldPosition;e._emitFunctionFromInclude("clipPlaneVertexDeclaration",t,{replaceStrings:[{search:/uniform vec4 vClipPlane\d*;/g,replace:""}]}),e.compilationString+=e._emitCodeFromInclude("clipPlaneVertex",t,{replaceStrings:[{search:/worldPos/g,replace:i.associatedVariableName}]}),e._emitUniformFromString("vClipPlane",x.Vector4),e._emitUniformFromString("vClipPlane2",x.Vector4),e._emitUniformFromString("vClipPlane3",x.Vector4),e._emitUniformFromString("vClipPlane4",x.Vector4),e._emitUniformFromString("vClipPlane5",x.Vector4),e._emitUniformFromString("vClipPlane6",x.Vector4);return}return e.sharedData.bindableBlocks.push(this),e.sharedData.blocksWithDefines.push(this),e._emitFunctionFromInclude("clipPlaneFragmentDeclaration",t),e.compilationString+=e._emitCodeFromInclude("clipPlaneFragment",t),this}}B("BABYLON.ClipPlanesBlock",OF);class wF extends le{get texture(){return null}set texture(e){}constructor(e,t=A.VertexAndFragment){super(e,t,!1),this.registerOutput("position",x.Object,A.VertexAndFragment,new dt("position",this,1,Zi,"ImageSourceBlock")),this.registerOutput("localPosition",x.Object,A.VertexAndFragment,new dt("localPosition",this,1,Zi,"ImageSourceBlock")),this.registerOutput("depth",x.Object,A.VertexAndFragment,new dt("depth",this,1,Zi,"ImageSourceBlock")),this.registerOutput("screenDepth",x.Object,A.VertexAndFragment,new dt("screenDepth",this,1,Zi,"ImageSourceBlock")),this.registerOutput("normal",x.Object,A.VertexAndFragment,new dt("normal",this,1,Zi,"ImageSourceBlock")),this.registerOutput("worldNormal",x.Object,A.VertexAndFragment,new dt("worldNormal",this,1,Zi,"ImageSourceBlock"))}getSamplerName(e){return e===this._outputs[0]?this._positionSamplerName:e===this._outputs[1]?this._localPositionSamplerName:e===this._outputs[2]?this._depthSamplerName:e===this._outputs[3]?this._screenSpaceDepthSamplerName:e===this._outputs[4]?this._normalSamplerName:e===this._outputs[5]?this._worldNormalSamplerName:""}get position(){return this._outputs[0]}get localPosition(){return this._outputs[1]}get depth(){return this._outputs[2]}get screenDepth(){return this._outputs[3]}get normal(){return this._outputs[4]}get worldNormal(){return this._outputs[5]}get positionSamplerName(){return this._positionSamplerName}get localPositionSamplerName(){return this._localPositionSamplerName}get normalSamplerName(){return this._normalSamplerName}get worldNormalSamplerName(){return this._worldNormalSamplerName}get depthSamplerName(){return this._depthSamplerName}get linearDepthSamplerName(){return this._screenSpaceDepthSamplerName}getClassName(){return"PrePassTextureBlock"}_buildBlock(e){if(super._buildBlock(e),e.target!==A.Vertex)return this._positionSamplerName="prepassPositionSampler",this._depthSamplerName="prepassDepthSampler",this._normalSamplerName="prepassNormalSampler",this._worldNormalSamplerName="prepassWorldNormalSampler",this._localPositionSamplerName="prepassLocalPositionSampler",this._screenSpaceDepthSamplerName="prepassScreenSpaceDepthSampler",e.sharedData.variableNames.prepassPositionSampler=0,e.sharedData.variableNames.prepassDepthSampler=0,e.sharedData.variableNames.prepassNormalSampler=0,e.sharedData.variableNames.prepassWorldNormalSampler=0,e.sharedData.variableNames.prepassLocalPositionSampler=0,e.sharedData.variableNames.prepassScreenSpaceDepthSampler=0,e.sharedData.textureBlocks.push(this),e.sharedData.bindableBlocks.push(this),this.position.isConnected&&e._emit2DSampler(this._positionSamplerName),this.depth.isConnected&&e._emit2DSampler(this._depthSamplerName),this.normal.isConnected&&e._emit2DSampler(this._normalSamplerName),this.worldNormal.isConnected&&e._emit2DSampler(this._worldNormalSamplerName),this.localPosition.isConnected&&e._emit2DSampler(this._localPositionSamplerName),this.screenDepth.isConnected&&e._emit2DSampler(this._screenSpaceDepthSamplerName),this}bind(e,t){const r=t.getScene().enablePrePassRenderer();if(!r)return;const s=r.defaultRT;s.textures&&(this.position.isConnected&&e.setTexture(this._positionSamplerName,s.textures[r.getIndex(1)]),this.localPosition.isConnected&&e.setTexture(this._localPositionSamplerName,s.textures[r.getIndex(9)]),this.depth.isConnected&&e.setTexture(this._depthSamplerName,s.textures[r.getIndex(5)]),this.screenDepth.isConnected&&e.setTexture(this._screenSpaceDepthSamplerName,s.textures[r.getIndex(10)]),this.normal.isConnected&&e.setTexture(this._normalSamplerName,s.textures[r.getIndex(6)]),this.worldNormal.isConnected&&e.setTexture(this._worldNormalSamplerName,s.textures[r.getIndex(8)]))}}B("BABYLON.PrePassTextureBlock",wF);class NF extends le{get endpoints(){return this._endpoints}get target(){const e=this._inputs[0];if(e.isConnected){const t=e.connectedPoint.ownerBlock;if(t.target!==A.VertexAndFragment)return t.target;if(e.connectedPoint.target!==A.VertexAndFragment)return e.connectedPoint.target}return this._target}set target(e){this._target&e||(this._target=e)}constructor(e){super(e,A.Neutral),this._endpoints=[],this.registerInput("input",x.AutoDetect)}getClassName(){return"NodeMaterialTeleportInBlock"}get input(){return this._inputs[0]}isConnectedInFragmentShader(){return this.endpoints.some(e=>e.output.isConnectedInFragmentShader)}_dumpCode(e,t){let i=super._dumpCode(e,t);for(const r of this.endpoints)t.indexOf(r)===-1&&(i+=r._dumpCode(e,t));return i}isAnAncestorOf(e){for(const t of this.endpoints)if(t===e||t.isAnAncestorOf(e))return!0;return!1}attachToEndpoint(e){e.detach(),this._endpoints.push(e),e._entryPoint=this,e._outputs[0]._typeConnectionSource=this._inputs[0],e._tempEntryPointUniqueId=null,e.name="> "+this.name,this._outputs=this._endpoints.map(t=>t.output)}detachFromEndpoint(e){const t=this._endpoints.indexOf(e);t!==-1&&(this._endpoints.splice(t,1),e._outputs[0]._typeConnectionSource=null,e._entryPoint=null,this._outputs=this._endpoints.map(i=>i.output))}dispose(){super.dispose();for(const e of this._endpoints)this.detachFromEndpoint(e);this._endpoints=[]}}B("BABYLON.NodeMaterialTeleportInBlock",NF);class FF extends le{constructor(e){super(e,A.Neutral),this._entryPoint=null,this._tempEntryPointUniqueId=null,this.registerOutput("output",x.BasedOnInput)}get entryPoint(){return this._entryPoint}getClassName(){return"NodeMaterialTeleportOutBlock"}get output(){return this._outputs[0]}get target(){return this._entryPoint?this._entryPoint.target:this._target}set target(e){this._target&e||(this._target=e)}detach(){this._entryPoint&&this._entryPoint.detachFromEndpoint(this)}_buildBlock(e){super._buildBlock(e),this.entryPoint&&(e.compilationString+=e._declareOutput(this.output)+` = ${this.entryPoint.input.associatedVariableName};
`)}clone(e,t=""){const i=super.clone(e,t);return this.entryPoint&&this.entryPoint.attachToEndpoint(i),i}_customBuildStep(e,t){this.entryPoint&&this.entryPoint.build(e,t)}_dumpCode(e,t){let i="";return this.entryPoint&&t.indexOf(this.entryPoint)===-1&&(i+=this.entryPoint._dumpCode(e,t)),i+super._dumpCode(e,t)}_dumpCodeForOutputConnections(e){let t=super._dumpCodeForOutputConnections(e);return this.entryPoint&&(t+=this.entryPoint._dumpCodeForOutputConnections(e)),t}_dumpPropertiesCode(){let e=super._dumpPropertiesCode();return this.entryPoint&&(e+=`${this.entryPoint._codeVariableName}.attachToEndpoint(${this._codeVariableName});
`),e}serialize(){var t;const e=super.serialize();return e.entryPoint=((t=this.entryPoint)==null?void 0:t.uniqueId)??"",e}_deserialize(e,t,i){super._deserialize(e,t,i),this._tempEntryPointUniqueId=e.entryPoint}}B("BABYLON.NodeMaterialTeleportOutBlock",FF);class LF extends ju{constructor(e){super(e)}getClassName(){return"AddBlock"}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = ${this.left.associatedVariableName} + ${this.right.associatedVariableName};
`,this}}B("BABYLON.AddBlock",LF);class BF extends le{constructor(e){super(e,A.Neutral),this.registerInput("input",x.AutoDetect),this.registerInput("factor",x.Float),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0]}getClassName(){return"ScaleBlock"}get input(){return this._inputs[0]}get factor(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = ${this.input.associatedVariableName} * ${this.factor.associatedVariableName};
`,this}}B("BABYLON.ScaleBlock",BF);class U_ extends le{constructor(e){super(e,A.Neutral),this.minimum=0,this.maximum=1,this.registerInput("value",x.AutoDetect),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0]}getClassName(){return"ClampBlock"}get value(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0],i=e.shaderLanguage===1?e._getShaderType(this.value.type):"";return e.compilationString+=e._declareOutput(t)+` = clamp(${this.value.associatedVariableName}, ${i}(${this._writeFloat(this.minimum)}), ${i}(${this._writeFloat(this.maximum)}));
`,this}_dumpPropertiesCode(){let e=super._dumpPropertiesCode()+`${this._codeVariableName}.minimum = ${this.minimum};
`;return e+=`${this._codeVariableName}.maximum = ${this.maximum};
`,e}serialize(){const e=super.serialize();return e.minimum=this.minimum,e.maximum=this.maximum,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.minimum=e.minimum,this.maximum=e.maximum}}C([U("Minimum",1,void 0,{embedded:!0})],U_.prototype,"minimum",void 0);C([U("Maximum",1,void 0,{embedded:!0})],U_.prototype,"maximum",void 0);B("BABYLON.ClampBlock",U_);class VF extends le{constructor(e){super(e,A.Neutral),this.registerInput("left",x.AutoDetect),this.registerInput("right",x.AutoDetect),this.registerOutput("output",x.Vector3),this._linkConnectionTypes(0,1),this._inputs[0].excludedConnectionPointTypes.push(x.Float),this._inputs[0].excludedConnectionPointTypes.push(x.Matrix),this._inputs[0].excludedConnectionPointTypes.push(x.Vector2),this._inputs[1].excludedConnectionPointTypes.push(x.Float),this._inputs[1].excludedConnectionPointTypes.push(x.Matrix),this._inputs[1].excludedConnectionPointTypes.push(x.Vector2)}getClassName(){return"CrossBlock"}get left(){return this._inputs[0]}get right(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = cross(${this.left.associatedVariableName}.xyz, ${this.right.associatedVariableName}.xyz);
`,this}}B("BABYLON.CrossBlock",VF);class kF extends le{get options(){return this._options}set options(e){this._deserializeOptions(e)}constructor(e){super(e)}getClassName(){return"CustomBlock"}_buildBlock(e){super._buildBlock(e);let t=this._code,i=this._options.functionName;this._inputs.forEach(s=>{const n=new RegExp("\\{TYPE_"+s.name+"\\}","gm"),o=e._getGLType(s.type);t=t.replace(n,o),i=i.replace(n,o)}),this._outputs.forEach(s=>{const n=new RegExp("\\{TYPE_"+s.name+"\\}","gm"),o=e._getGLType(s.type);t=t.replace(n,o),i=i.replace(n,o)}),e._emitFunction(i,t,""),this._outputs.forEach(s=>{e.compilationString+=e._declareOutput(s)+`;
`}),e.compilationString+=i+"(";let r=!1;return this._inputs.forEach((s,n)=>{var o,l;n>0&&(e.compilationString+=", "),this._inputSamplers&&this._inputSamplers.indexOf(s.name)!==-1?e.compilationString+=((l=(o=s.connectedPoint)==null?void 0:o.ownerBlock)==null?void 0:l.samplerName)??s.associatedVariableName:e.compilationString+=s.associatedVariableName,r=!0}),this._outputs.forEach((s,n)=>{(n>0||r)&&(e.compilationString+=", "),e.compilationString+=s.associatedVariableName}),e.compilationString+=`);
`,this}_dumpPropertiesCode(){let e=super._dumpPropertiesCode();return e+=`${this._codeVariableName}.options = ${JSON.stringify(this._options)};
`,e}serialize(){const e=super.serialize();return e.options=this._options,e}_deserialize(e,t,i){this._deserializeOptions(e.options),super._deserialize(e,t,i)}_deserializeOptions(e){var t,i,r;this._options=e,this._code=e.code.join(`
`)+`
`,this.name=this.name||e.name,this.target=A[e.target],(t=e.inParameters)==null||t.forEach((s,n)=>{const o=x[s.type];s.type==="sampler2D"||s.type==="samplerCube"?(this._inputSamplers=this._inputSamplers||[],this._inputSamplers.push(s.name),this.registerInput(s.name,x.Object,!0,A.VertexAndFragment,new dt(s.name,this,0,Zi,"ImageSourceBlock"))):this.registerInput(s.name,o),Object.defineProperty(this,s.name,{get:function(){return this._inputs[n]},enumerable:!0,configurable:!0})}),(i=e.outParameters)==null||i.forEach((s,n)=>{this.registerOutput(s.name,x[s.type]),Object.defineProperty(this,s.name,{get:function(){return this._outputs[n]},enumerable:!0,configurable:!0}),s.type==="BasedOnInput"&&(this._outputs[n]._typeConnectionSource=this._findInputByName(s.typeFromInput)[0])}),(r=e.inLinkedConnectionTypes)==null||r.forEach(s=>{this._linkConnectionTypes(this._findInputByName(s.input1)[1],this._findInputByName(s.input2)[1])})}_findInputByName(e){if(!e)return null;for(let t=0;t<this._inputs.length;t++)if(this._inputs[t].name===e)return[this._inputs[t],t];return null}}B("BABYLON.CustomBlock",kF);class zF extends le{constructor(e){super(e,A.Neutral),this.registerInput("left",x.AutoDetect),this.registerInput("right",x.AutoDetect),this.registerOutput("output",x.Float),this._linkConnectionTypes(0,1),this._inputs[0].excludedConnectionPointTypes.push(x.Float),this._inputs[0].excludedConnectionPointTypes.push(x.Matrix),this._inputs[1].excludedConnectionPointTypes.push(x.Float),this._inputs[1].excludedConnectionPointTypes.push(x.Matrix)}getClassName(){return"DotBlock"}get left(){return this._inputs[0]}get right(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = dot(${this.left.associatedVariableName}, ${this.right.associatedVariableName});
`,this}}B("BABYLON.DotBlock",zF);class UF extends le{constructor(e){super(e,A.Neutral),this.registerInput("input",x.AutoDetect),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._inputs[0].excludedConnectionPointTypes.push(x.Float),this._inputs[0].excludedConnectionPointTypes.push(x.Matrix)}getClassName(){return"NormalizeBlock"}get input(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0],i=this._inputs[0];return e.compilationString+=e._declareOutput(t)+` = normalize(${i.associatedVariableName});
`,this}}B("BABYLON.NormalizeBlock",UF);class GF extends le{constructor(e){super(e,A.Neutral),this.rSwizzle="r",this.gSwizzle="g",this.bSwizzle="b",this.aSwizzle="a",this.registerInput("rgb ",x.Color3,!0),this.registerInput("r",x.Float,!0),this.registerInput("g",x.Float,!0),this.registerInput("b",x.Float,!0),this.registerInput("a",x.Float,!0),this.registerOutput("rgba",x.Color4),this.registerOutput("rgb",x.Color3)}getClassName(){return"ColorMergerBlock"}get rgbIn(){return this._inputs[0]}get r(){return this._inputs[1]}get g(){return this._inputs[2]}get b(){return this._inputs[3]}get a(){return this._inputs[4]}get rgba(){return this._outputs[0]}get rgbOut(){return this._outputs[1]}get rgb(){return this.rgbOut}_inputRename(e){return e==="rgb "?"rgbIn":e}_buildSwizzle(e){return"."+(this.rSwizzle+this.gSwizzle+this.bSwizzle+this.aSwizzle).substring(0,e)}_buildBlock(e){super._buildBlock(e);const t=this.r,i=this.g,r=this.b,s=this.a,n=this.rgbIn,o=this._outputs[0],l=this._outputs[1],u=e._getShaderType(x.Vector4),c=e._getShaderType(x.Vector3);return n.isConnected?(o.hasEndpoints&&(e.compilationString+=e._declareOutput(o)+` = ${u}(${n.associatedVariableName}, ${s.isConnected?this._writeVariable(s):"0.0"})${this._buildSwizzle(4)};
`),l.hasEndpoints&&(e.compilationString+=e._declareOutput(l)+` = ${n.associatedVariableName}${this._buildSwizzle(3)};
`)):(o.hasEndpoints&&(e.compilationString+=e._declareOutput(o)+` = ${u}(${t.isConnected?this._writeVariable(t):"0.0"}, ${i.isConnected?this._writeVariable(i):"0.0"}, ${r.isConnected?this._writeVariable(r):"0.0"}, ${s.isConnected?this._writeVariable(s):"0.0"})${this._buildSwizzle(4)};
`),l.hasEndpoints&&(e.compilationString+=e._declareOutput(l)+` = ${c}(${t.isConnected?this._writeVariable(t):"0.0"}, ${i.isConnected?this._writeVariable(i):"0.0"}, ${r.isConnected?this._writeVariable(r):"0.0"})${this._buildSwizzle(3)};
`)),this}serialize(){const e=super.serialize();return e.rSwizzle=this.rSwizzle,e.gSwizzle=this.gSwizzle,e.bSwizzle=this.bSwizzle,e.aSwizzle=this.aSwizzle,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.rSwizzle=e.rSwizzle??"r",this.gSwizzle=e.gSwizzle??"g",this.bSwizzle=e.bSwizzle??"b",this.aSwizzle=e.aSwizzle??"a"}_dumpPropertiesCode(){let e=super._dumpPropertiesCode();return e+=`${this._codeVariableName}.rSwizzle = "${this.rSwizzle}";
`,e+=`${this._codeVariableName}.gSwizzle = "${this.gSwizzle}";
`,e+=`${this._codeVariableName}.bSwizzle = "${this.bSwizzle}";
`,e+=`${this._codeVariableName}.aSwizzle = "${this.aSwizzle}";
`,e}}B("BABYLON.ColorMergerBlock",GF);class WF extends le{constructor(e){super(e,A.Neutral),this.registerInput("xyzw",x.Vector4,!0),this.registerInput("xyz ",x.Vector3,!0),this.registerInput("xy ",x.Vector2,!0),this.registerOutput("xyz",x.Vector3),this.registerOutput("xy",x.Vector2),this.registerOutput("zw",x.Vector2),this.registerOutput("x",x.Float),this.registerOutput("y",x.Float),this.registerOutput("z",x.Float),this.registerOutput("w",x.Float),this.inputsAreExclusive=!0}getClassName(){return"VectorSplitterBlock"}get xyzw(){return this._inputs[0]}get xyzIn(){return this._inputs[1]}get xyIn(){return this._inputs[2]}get xyzOut(){return this._outputs[0]}get xyOut(){return this._outputs[1]}get zw(){return this._outputs[2]}get x(){return this._outputs[3]}get y(){return this._outputs[4]}get z(){return this._outputs[5]}get w(){return this._outputs[6]}_inputRename(e){switch(e){case"xy ":return"xyIn";case"xyz ":return"xyzIn";default:return e}}_outputRename(e){switch(e){case"xy":return"xyOut";case"xyz":return"xyzOut";default:return e}}_buildBlock(e){super._buildBlock(e);const t=this.xyzw.isConnected?this.xyzw:this.xyzIn.isConnected?this.xyzIn:this.xyIn,i=this._outputs[0],r=this._outputs[1],s=this._outputs[2],n=this._outputs[3],o=this._outputs[4],l=this._outputs[5],u=this._outputs[6],c=e._getShaderType(x.Vector3);return i.hasEndpoints&&(t===this.xyIn?e.compilationString+=e._declareOutput(i)+` = ${c}(${t.associatedVariableName}, 0.0);
`:e.compilationString+=e._declareOutput(i)+` = ${t.associatedVariableName}.xyz;
`),s.hasEndpoints&&this.xyzw.isConnected&&(e.compilationString+=e._declareOutput(s)+` = ${this.xyzw.associatedVariableName}.zw;
`),r.hasEndpoints&&(e.compilationString+=e._declareOutput(r)+` = ${t.associatedVariableName}.xy;
`),n.hasEndpoints&&(e.compilationString+=e._declareOutput(n)+` = ${t.associatedVariableName}.x;
`),o.hasEndpoints&&(e.compilationString+=e._declareOutput(o)+` = ${t.associatedVariableName}.y;
`),l.hasEndpoints&&(e.compilationString+=e._declareOutput(l)+` = ${t.associatedVariableName}.z;
`),u.hasEndpoints&&(e.compilationString+=e._declareOutput(u)+` = ${t.associatedVariableName}.w;
`),this}}B("BABYLON.VectorSplitterBlock",WF);class $F extends le{constructor(e){super(e,A.Neutral),this.registerInput("left",x.AutoDetect),this.registerInput("right",x.AutoDetect),this.registerInput("gradient",x.AutoDetect),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._linkConnectionTypes(0,1),this._linkConnectionTypes(1,2,!0),this._inputs[2].acceptedConnectionPointTypes.push(x.Float)}getClassName(){return"LerpBlock"}get left(){return this._inputs[0]}get right(){return this._inputs[1]}get gradient(){return this._inputs[2]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = mix(${this.left.associatedVariableName} , ${this.right.associatedVariableName}, ${this.gradient.associatedVariableName});
`,this}}B("BABYLON.LerpBlock",$F);class HF extends ju{constructor(e){super(e)}getClassName(){return"DivideBlock"}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = ${this.left.associatedVariableName} / ${this.right.associatedVariableName};
`,this}}B("BABYLON.DivideBlock",HF);class jF extends ju{constructor(e){super(e)}getClassName(){return"SubtractBlock"}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = ${this.left.associatedVariableName} - ${this.right.associatedVariableName};
`,this}}B("BABYLON.SubtractBlock",jF);class YF extends le{constructor(e){super(e,A.Neutral),this.registerInput("value",x.Float),this.registerInput("edge",x.Float),this.registerOutput("output",x.Float)}getClassName(){return"StepBlock"}get value(){return this._inputs[0]}get edge(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = step(${this.edge.associatedVariableName}, ${this.value.associatedVariableName});
`,this}}B("BABYLON.StepBlock",YF);class KT extends le{constructor(e){super(e,A.Neutral),this.registerInput("input",x.AutoDetect),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._outputs[0].excludedConnectionPointTypes.push(x.Matrix)}getClassName(){return"OneMinusBlock"}get input(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = 1. - ${this.input.associatedVariableName};
`,this}}B("BABYLON.OneMinusBlock",KT);B("BABYLON.OppositeBlock",KT);class JT extends le{constructor(e){super(e,A.Neutral),this.registerInput("worldPosition",x.Vector4),this.registerInput("cameraPosition",x.Vector3),this.registerOutput("output",x.Vector3)}getClassName(){return"ViewDirectionBlock"}get worldPosition(){return this._inputs[0]}get cameraPosition(){return this._inputs[1]}get output(){return this._outputs[0]}autoConfigure(e,t=()=>!0){if(!this.cameraPosition.isConnected){let i=e.getInputBlockByPredicate(r=>r.systemValue===De.CameraPosition&&t(r));i||(i=new Ee("cameraPosition"),i.setAsSystemValue(De.CameraPosition)),i.output.connectTo(this.cameraPosition)}}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = normalize(${this.cameraPosition.associatedVariableName} - ${this.worldPosition.associatedVariableName}.xyz);
`,this}}B("BABYLON.ViewDirectionBlock",JT);class XF extends le{constructor(e){super(e,A.Neutral),this.registerInput("worldNormal",x.Vector4),this.registerInput("viewDirection",x.Vector3),this.registerInput("bias",x.Float),this.registerInput("power",x.Float),this.registerOutput("fresnel",x.Float)}getClassName(){return"FresnelBlock"}get worldNormal(){return this._inputs[0]}get viewDirection(){return this._inputs[1]}get bias(){return this._inputs[2]}get power(){return this._inputs[3]}get fresnel(){return this._outputs[0]}autoConfigure(e){if(!this.viewDirection.isConnected){const t=new JT("View direction");t.output.connectTo(this.viewDirection),t.autoConfigure(e)}if(!this.bias.isConnected){const t=new Ee("bias");t.value=0,t.output.connectTo(this.bias)}if(!this.power.isConnected){const t=new Ee("power");t.value=1,t.output.connectTo(this.power)}}_buildBlock(e){super._buildBlock(e);const t=`//${this.name}`;return e._emitFunctionFromInclude("fresnelFunction",t,{removeIfDef:!0}),e.compilationString+=e._declareOutput(this.fresnel)+` = computeFresnelTerm(${this.viewDirection.associatedVariableName}.xyz, ${this.worldNormal.associatedVariableName}.xyz, ${this.bias.associatedVariableName}, ${this.power.associatedVariableName});
`,this}}B("BABYLON.FresnelBlock",XF);class ZF extends le{constructor(e){super(e,A.Neutral),this.registerInput("left",x.AutoDetect),this.registerInput("right",x.AutoDetect),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._linkConnectionTypes(0,1)}getClassName(){return"MaxBlock"}get left(){return this._inputs[0]}get right(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = max(${this.left.associatedVariableName}, ${this.right.associatedVariableName});
`,this}}B("BABYLON.MaxBlock",ZF);class qF extends le{constructor(e){super(e,A.Neutral),this.registerInput("left",x.AutoDetect),this.registerInput("right",x.AutoDetect),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._linkConnectionTypes(0,1)}getClassName(){return"MinBlock"}get left(){return this._inputs[0]}get right(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = min(${this.left.associatedVariableName}, ${this.right.associatedVariableName});
`,this}}B("BABYLON.MinBlock",qF);class QF extends le{constructor(e){super(e,A.Neutral),this.registerInput("left",x.AutoDetect),this.registerInput("right",x.AutoDetect),this.registerOutput("output",x.Float),this._linkConnectionTypes(0,1),this._inputs[0].excludedConnectionPointTypes.push(x.Float),this._inputs[0].excludedConnectionPointTypes.push(x.Matrix),this._inputs[1].excludedConnectionPointTypes.push(x.Float),this._inputs[1].excludedConnectionPointTypes.push(x.Matrix)}getClassName(){return"DistanceBlock"}get left(){return this._inputs[0]}get right(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = length(${this.left.associatedVariableName} - ${this.right.associatedVariableName});
`,this}}B("BABYLON.DistanceBlock",QF);class KF extends le{constructor(e){super(e,A.Neutral),this.registerInput("value",x.AutoDetect),this.registerOutput("output",x.Float),this._inputs[0].excludedConnectionPointTypes.push(x.Float),this._inputs[0].excludedConnectionPointTypes.push(x.Matrix)}getClassName(){return"LengthBlock"}get value(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = length(${this.value.associatedVariableName});
`,this}}B("BABYLON.LengthBlock",KF);class JF extends le{constructor(e){super(e,A.Neutral),this.registerInput("value",x.AutoDetect),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0]}getClassName(){return"NegateBlock"}get value(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = -1.0 * ${this.value.associatedVariableName};
`,this}}B("BABYLON.NegateBlock",JF);class e2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("value",x.AutoDetect),this.registerInput("power",x.AutoDetect),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._linkConnectionTypes(0,1)}getClassName(){return"PowBlock"}get value(){return this._inputs[0]}get power(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = pow(max(${this.value.associatedVariableName}, 0.), ${this.power.associatedVariableName});
`,this}}B("BABYLON.PowBlock",e2);class t2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("seed",x.AutoDetect),this.registerOutput("output",x.Float),this._inputs[0].addExcludedConnectionPointFromAllowedTypes(x.Vector2|x.Vector3|x.Vector4|x.Color3|x.Color4)}getClassName(){return"RandomNumberBlock"}get seed(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0],i=`//${this.name}`;return e._emitFunctionFromInclude("helperFunctions",i),e.compilationString+=e._declareOutput(t)+` = getRand(${this.seed.associatedVariableName}.xy);
`,this}}B("BABYLON.RandomNumberBlock",t2);class i2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("x",x.Float),this.registerInput("y",x.Float),this.registerOutput("output",x.Float)}getClassName(){return"ArcTan2Block"}get x(){return this._inputs[0]}get y(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0],i=e.shaderLanguage===1?"atan2":"atan";return e.compilationString+=e._declareOutput(t)+` = ${i}(${this.x.associatedVariableName}, ${this.y.associatedVariableName});
`,this}}B("BABYLON.ArcTan2Block",i2);class r2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("value",x.AutoDetect),this.registerInput("edge0",x.Float),this.registerInput("edge1",x.Float),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0]}getClassName(){return"SmoothStepBlock"}get value(){return this._inputs[0]}get edge0(){return this._inputs[1]}get edge1(){return this._inputs[2]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0],i=e._getShaderType(this.value.type);return e.compilationString+=e._declareOutput(t)+` = smoothstep(${i}(${this.edge0.associatedVariableName}), ${i}(${this.edge1.associatedVariableName}), ${this.value.associatedVariableName});
`,this}}B("BABYLON.SmoothStepBlock",r2);class s2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("input",x.AutoDetect),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0]}getClassName(){return"ReciprocalBlock"}get input(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return this.input.type===x.Matrix?e.compilationString+=e._declareOutput(t)+` = inverse(${this.input.associatedVariableName});
`:e.compilationString+=e._declareOutput(t)+` = 1. / ${this.input.associatedVariableName};
`,this}}B("BABYLON.ReciprocalBlock",s2);class n2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("value",x.AutoDetect),this.registerInput("reference",x.AutoDetect),this.registerInput("distance",x.Float),this.registerInput("replacement",x.AutoDetect),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._linkConnectionTypes(0,1),this._linkConnectionTypes(0,3),this._inputs[0].excludedConnectionPointTypes.push(x.Float),this._inputs[0].excludedConnectionPointTypes.push(x.Matrix),this._inputs[1].excludedConnectionPointTypes.push(x.Float),this._inputs[1].excludedConnectionPointTypes.push(x.Matrix),this._inputs[3].excludedConnectionPointTypes.push(x.Float),this._inputs[3].excludedConnectionPointTypes.push(x.Matrix)}getClassName(){return"ReplaceColorBlock"}get value(){return this._inputs[0]}get reference(){return this._inputs[1]}get distance(){return this._inputs[2]}get replacement(){return this._inputs[3]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+`;
`,e.compilationString+=`if (length(${this.value.associatedVariableName} - ${this.reference.associatedVariableName}) < ${this.distance.associatedVariableName}) {
`,e.compilationString+=`${t.associatedVariableName} = ${this.replacement.associatedVariableName};
`,e.compilationString+=`} else {
`,e.compilationString+=`${t.associatedVariableName} = ${this.value.associatedVariableName};
`,e.compilationString+=`}
`,this}}B("BABYLON.ReplaceColorBlock",n2);class a2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("value",x.AutoDetect),this.registerInput("steps",x.AutoDetect),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._linkConnectionTypes(0,1),this._inputs[0].excludedConnectionPointTypes.push(x.Matrix),this._inputs[1].excludedConnectionPointTypes.push(x.Matrix),this._inputs[1].acceptedConnectionPointTypes.push(x.Float)}getClassName(){return"PosterizeBlock"}get value(){return this._inputs[0]}get steps(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = floor(${this.value.associatedVariableName} / (1.0 / ${this.steps.associatedVariableName})) * (1.0 / ${this.steps.associatedVariableName});
`,this}}B("BABYLON.PosterizeBlock",a2);var jS;(function(a){a[a.SawTooth=0]="SawTooth",a[a.Square=1]="Square",a[a.Triangle=2]="Triangle"})(jS||(jS={}));class eC extends le{constructor(e){super(e,A.Neutral),this.kind=0,this.registerInput("input",x.AutoDetect),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._inputs[0].excludedConnectionPointTypes.push(x.Matrix)}getClassName(){return"WaveBlock"}get input(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];switch(this.kind){case 0:{e.compilationString+=e._declareOutput(t)+` = ${this.input.associatedVariableName} - floor(0.5 + ${this.input.associatedVariableName});
`;break}case 1:{e.compilationString+=e._declareOutput(t)+` = 1.0 - 2.0 * round(fract(${this.input.associatedVariableName}));
`;break}case 2:{e.compilationString+=e._declareOutput(t)+` = 2.0 * abs(2.0 * (${this.input.associatedVariableName} - floor(0.5 + ${this.input.associatedVariableName}))) - 1.0;
`;break}}return this}serialize(){const e=super.serialize();return e.kind=this.kind,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.kind=e.kind}}C([U("Kind",4,"ADVANCED",{notifiers:{rebuild:!0},embedded:!0,options:[{label:"SawTooth",value:0},{label:"Square",value:1},{label:"Triangle",value:2}]})],eC.prototype,"kind",void 0);B("BABYLON.WaveBlock",eC);class kc{get step(){return this._step}set step(e){this._step=e}get color(){return this._color}set color(e){this._color=e}constructor(e,t){this.step=e,this.color=t}}class o2 extends le{colorStepsUpdated(){this.onValueChangedObservable.notifyObservers(this)}constructor(e){super(e,A.Neutral),this.colorSteps=[new kc(0,ne.Black()),new kc(1,ne.White())],this.onValueChangedObservable=new j,this.registerInput("gradient",x.AutoDetect),this.registerOutput("output",x.Color3),this._inputs[0].addExcludedConnectionPointFromAllowedTypes(x.Float|x.Vector2|x.Vector3|x.Vector4|x.Color3|x.Color4)}getClassName(){return"GradientBlock"}get gradient(){return this._inputs[0]}get output(){return this._outputs[0]}_writeColorConstant(e,t){const i=this.colorSteps[e];return`${t}(${i.color.r}, ${i.color.g}, ${i.color.b})`}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0],i=e._getShaderType(x.Vector3);if(!this.colorSteps.length||!this.gradient.connectedPoint){e.compilationString+=e._declareOutput(t)+` = ${i}(0., 0., 0.);
`;return}const r=e._getFreeVariableName("gradientTempColor"),s=e._getFreeVariableName("gradientTempPosition");e.compilationString+=`${e._declareLocalVar(r,x.Vector3)} = ${this._writeColorConstant(0,i)};
`,e.compilationString+=`${e._declareLocalVar(s,x.Float)};
`;let n=this.gradient.associatedVariableName;this.gradient.connectedPoint.type!==x.Float&&(n+=".x");for(let o=1;o<this.colorSteps.length;o++){const l=this.colorSteps[o],u=this.colorSteps[o-1];e.compilationString+=`${s} = clamp((${n} - ${e._emitFloat(u.step)}) / (${e._emitFloat(l.step)} -  ${e._emitFloat(u.step)}), 0.0, 1.0) * step(${e._emitFloat(o)}, ${e._emitFloat(this.colorSteps.length-1)});
`,e.compilationString+=`${r} = mix(${r}, ${this._writeColorConstant(o,i)}, ${s});
`}return e.compilationString+=e._declareOutput(t)+` = ${r};
`,this}serialize(){const e=super.serialize();e.colorSteps=[];for(const t of this.colorSteps)e.colorSteps.push({step:t.step,color:{r:t.color.r,g:t.color.g,b:t.color.b}});return e}_deserialize(e,t,i){super._deserialize(e,t,i),this.colorSteps.length=0;for(const r of e.colorSteps)this.colorSteps.push(new kc(r.step,new ne(r.color.r,r.color.g,r.color.b)))}_dumpPropertiesCode(){let e=super._dumpPropertiesCode();e+=`${this._codeVariableName}.colorSteps = [];
`;for(const t of this.colorSteps)e+=`${this._codeVariableName}.colorSteps.push(new BABYLON.GradientBlockColorStep(${t.step}, new BABYLON.Color3(${t.color.r}, ${t.color.g}, ${t.color.b})));
`;return e}}B("BABYLON.GradientBlock",o2);class l2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("left",x.AutoDetect),this.registerInput("right",x.AutoDetect),this.registerInput("gradient",x.AutoDetect),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._linkConnectionTypes(0,1),this._linkConnectionTypes(1,2,!0),this._inputs[2].acceptedConnectionPointTypes.push(x.Float)}getClassName(){return"NLerpBlock"}get left(){return this._inputs[0]}get right(){return this._inputs[1]}get gradient(){return this._inputs[2]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = normalize(mix(${this.left.associatedVariableName} , ${this.right.associatedVariableName}, ${this.gradient.associatedVariableName}));
`,this}}B("BABYLON.NLerpBlock",l2);class tC extends le{constructor(e){super(e,A.Neutral),this.manhattanDistance=!1,this.registerInput("seed",x.Vector3),this.registerInput("jitter",x.Float),this.registerOutput("output",x.Vector2),this.registerOutput("x",x.Float),this.registerOutput("y",x.Float)}getClassName(){return"WorleyNoise3DBlock"}get seed(){return this._inputs[0]}get jitter(){return this._inputs[1]}get output(){return this._outputs[0]}get x(){return this._outputs[1]}get y(){return this._outputs[2]}_buildBlock(e){if(super._buildBlock(e),!this.seed.isConnected||!this.output.hasEndpoints&&!this.x.hasEndpoints&&!this.y.hasEndpoints)return;let t=`vec3 permute(vec3 x){
`;t+=`    return mod((34.0 * x + 1.0) * x, 289.0);
`,t+=`}

`,t+=`vec3 dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance){
`,t+=`    return [manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z)];
`,t+=`}

`,t+=`vec2 worley(vec3 P, float jitter, bool manhattanDistance){
`,t+=`    float K = 0.142857142857; // 1/7
`,t+=`    float Ko = 0.428571428571; // 1/2-K/2
`,t+=`    float  K2 = 0.020408163265306; // 1/(7*7)
`,t+=`    float Kz = 0.166666666667; // 1/6
`,t+=`    float Kzo = 0.416666666667; // 1/2-1/6*2
`,t+=`
`,t+=`    vec3 Pi = mod(floor(P), 289.0);
`,t+=`    vec3 Pf = fract(P) - 0.5;
`,t+=`
`,t+=`    vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);
`,t+=`    vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);
`,t+=`    vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);
`,t+=`
`,t+=`    vec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));
`,t+=`    vec3 p1 = permute(p + Pi.y - 1.0);
`,t+=`    vec3 p2 = permute(p + Pi.y);
`,t+=`    vec3 p3 = permute(p + Pi.y + 1.0);
`,t+=`
`,t+=`    vec3 p11 = permute(p1 + Pi.z - 1.0);
`,t+=`    vec3 p12 = permute(p1 + Pi.z);
`,t+=`    vec3 p13 = permute(p1 + Pi.z + 1.0);
`,t+=`
`,t+=`    vec3 p21 = permute(p2 + Pi.z - 1.0);
`,t+=`    vec3 p22 = permute(p2 + Pi.z);
`,t+=`    vec3 p23 = permute(p2 + Pi.z + 1.0);
`,t+=`
`,t+=`    vec3 p31 = permute(p3 + Pi.z - 1.0);
`,t+=`    vec3 p32 = permute(p3 + Pi.z);
`,t+=`    vec3 p33 = permute(p3 + Pi.z + 1.0);
`,t+=`
`,t+=`    vec3 ox11 = fract(p11*K) - Ko;
`,t+=`    vec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;
`,t+=`    vec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed
`,t+=`
`,t+=`    vec3 ox12 = fract(p12*K) - Ko;
`,t+=`    vec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;
`,t+=`    vec3 oz12 = floor(p12*K2)*Kz - Kzo;
`,t+=`
`,t+=`    vec3 ox13 = fract(p13*K) - Ko;
`,t+=`    vec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;
`,t+=`    vec3 oz13 = floor(p13*K2)*Kz - Kzo;
`,t+=`
`,t+=`    vec3 ox21 = fract(p21*K) - Ko;
`,t+=`    vec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;
`,t+=`    vec3 oz21 = floor(p21*K2)*Kz - Kzo;
`,t+=`
`,t+=`    vec3 ox22 = fract(p22*K) - Ko;
`,t+=`    vec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;
`,t+=`    vec3 oz22 = floor(p22*K2)*Kz - Kzo;
`,t+=`
`,t+=`    vec3 ox23 = fract(p23*K) - Ko;
`,t+=`    vec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;
`,t+=`    vec3 oz23 = floor(p23*K2)*Kz - Kzo;
`,t+=`
`,t+=`    vec3 ox31 = fract(p31*K) - Ko;
`,t+=`    vec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;
`,t+=`    vec3 oz31 = floor(p31*K2)*Kz - Kzo;
`,t+=`
`,t+=`    vec3 ox32 = fract(p32*K) - Ko;
`,t+=`    vec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;
`,t+=`    vec3 oz32 = floor(p32*K2)*Kz - Kzo;
`,t+=`
`,t+=`    vec3 ox33 = fract(p33*K) - Ko;
`,t+=`    vec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;
`,t+=`    vec3 oz33 = floor(p33*K2)*Kz - Kzo;
`,t+=`
`,t+=`    vec3 dx11 = Pfx + jitter*ox11;
`,t+=`    vec3 dy11 = Pfy.x + jitter*oy11;
`,t+=`    vec3 dz11 = Pfz.x + jitter*oz11;
`,t+=`
`,t+=`    vec3 dx12 = Pfx + jitter*ox12;
`,t+=`    vec3 dy12 = Pfy.x + jitter*oy12;
`,t+=`    vec3 dz12 = Pfz.y + jitter*oz12;
`,t+=`
`,t+=`    vec3 dx13 = Pfx + jitter*ox13;
`,t+=`    vec3 dy13 = Pfy.x + jitter*oy13;
`,t+=`    vec3 dz13 = Pfz.z + jitter*oz13;
`,t+=`
`,t+=`    vec3 dx21 = Pfx + jitter*ox21;
`,t+=`    vec3 dy21 = Pfy.y + jitter*oy21;
`,t+=`    vec3 dz21 = Pfz.x + jitter*oz21;
`,t+=`
`,t+=`    vec3 dx22 = Pfx + jitter*ox22;
`,t+=`    vec3 dy22 = Pfy.y + jitter*oy22;
`,t+=`    vec3 dz22 = Pfz.y + jitter*oz22;
`,t+=`
`,t+=`    vec3 dx23 = Pfx + jitter*ox23;
`,t+=`    vec3 dy23 = Pfy.y + jitter*oy23;
`,t+=`    vec3 dz23 = Pfz.z + jitter*oz23;
`,t+=`
`,t+=`    vec3 dx31 = Pfx + jitter*ox31;
`,t+=`    vec3 dy31 = Pfy.z + jitter*oy31;
`,t+=`    vec3 dz31 = Pfz.x + jitter*oz31;
`,t+=`
`,t+=`    vec3 dx32 = Pfx + jitter*ox32;
`,t+=`    vec3 dy32 = Pfy.z + jitter*oy32;
`,t+=`    vec3 dz32 = Pfz.y + jitter*oz32;
`,t+=`
`,t+=`    vec3 dx33 = Pfx + jitter*ox33;
`,t+=`    vec3 dy33 = Pfy.z + jitter*oy33;
`,t+=`    vec3 dz33 = Pfz.z + jitter*oz33;
`,t+=`
`,t+=`    vec3 d11 = dist(dx11, dy11, dz11, manhattanDistance);
`,t+=`    vec3 d12 = dist(dx12, dy12, dz12, manhattanDistance);
`,t+=`    vec3 d13 = dist(dx13, dy13, dz13, manhattanDistance);
`,t+=`    vec3 d21 = dist(dx21, dy21, dz21, manhattanDistance);
`,t+=`    vec3 d22 = dist(dx22, dy22, dz22, manhattanDistance);
`,t+=`    vec3 d23 = dist(dx23, dy23, dz23, manhattanDistance);
`,t+=`    vec3 d31 = dist(dx31, dy31, dz31, manhattanDistance);
`,t+=`    vec3 d32 = dist(dx32, dy32, dz32, manhattanDistance);
`,t+=`    vec3 d33 = dist(dx33, dy33, dz33, manhattanDistance);
`,t+=`
`,t+=`    vec3 d1a = min(d11, d12);
`,t+=`    d12 = max(d11, d12);
`,t+=`    d11 = min(d1a, d13); // Smallest now not in d12 or d13
`,t+=`    d13 = max(d1a, d13);
`,t+=`    d12 = min(d12, d13); // 2nd smallest now not in d13
`,t+=`    vec3 d2a = min(d21, d22);
`,t+=`    d22 = max(d21, d22);
`,t+=`    d21 = min(d2a, d23); // Smallest now not in d22 or d23
`,t+=`    d23 = max(d2a, d23);
`,t+=`    d22 = min(d22, d23); // 2nd smallest now not in d23
`,t+=`    vec3 d3a = min(d31, d32);
`,t+=`    d32 = max(d31, d32);
`,t+=`    d31 = min(d3a, d33); // Smallest now not in d32 or d33
`,t+=`    d33 = max(d3a, d33);
`,t+=`    d32 = min(d32, d33); // 2nd smallest now not in d33
`,t+=`    vec3 da = min(d11, d21);
`,t+=`    d21 = max(d11, d21);
`,t+=`    d11 = min(da, d31); // Smallest now in d11
`,t+=`    d31 = max(da, d31); // 2nd smallest now not in d31
`,t+=`    if (d11.x >= d11.y) { vec2 temp = d11.yx; d11.x = temp.x; d11.y = temp.y; }
`,t+=`    if (d11.x >= d11.z) { vec2 temp = d11.zx; d11.x = temp.x; d11.z = temp.y; }
`,t+=`    d12 = min(d12, d21); // 2nd smallest now not in d21
`,t+=`    d12 = min(d12, d22); // nor in d22
`,t+=`    d12 = min(d12, d31); // nor in d31
`,t+=`    d12 = min(d12, d32); // nor in d32
`,t+=`    vec2 temp2 = min(d11.yz, d12.xy); // nor in d12.yz
`,t+=`    d11.y = temp2.x;
`,t+=`    d11.z = temp2.y;
`,t+=`    d11.y = min(d11.y, d12.z); // Only two more to go
`,t+=`    d11.y = min(d11.y, d11.z); // Done! (Phew!)
`,t+=`    return sqrt(d11.xy); // F1, F2
`,t+=`}

`,e.shaderLanguage===1?t=e._babylonSLtoWGSL(t):t=e._babylonSLtoGLSL(t),e._emitFunction("worley3D",t,"// Worley3D");const i=e._getFreeVariableName("worleyTemp");return e.compilationString+=`${e._declareLocalVar(i,x.Vector2)} = worley(${this.seed.associatedVariableName}, ${this.jitter.associatedVariableName}, ${this.manhattanDistance});
`,this.output.hasEndpoints&&(e.compilationString+=e._declareOutput(this.output)+` = ${i};
`),this.x.hasEndpoints&&(e.compilationString+=e._declareOutput(this.x)+` = ${i}.x;
`),this.y.hasEndpoints&&(e.compilationString+=e._declareOutput(this.y)+` = ${i}.y;
`),this}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.manhattanDistance = ${this.manhattanDistance};
`}serialize(){const e=super.serialize();return e.manhattanDistance=this.manhattanDistance,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.manhattanDistance=e.manhattanDistance}}C([U("Use Manhattan Distance",0,"PROPERTIES",{embedded:!0,notifiers:{update:!1}})],tC.prototype,"manhattanDistance",void 0);B("BABYLON.WorleyNoise3DBlock",tC);class u2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("seed",x.Vector3),this.registerOutput("output",x.Float)}getClassName(){return"SimplexPerlin3DBlock"}get seed(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){if(super._buildBlock(e),!this.seed.isConnected||!this._outputs[0].hasEndpoints)return;let t=`const float SKEWFACTOR = 1.0/3.0;
`;return t+=`const float UNSKEWFACTOR = 1.0/6.0;
`,t+=`const float SIMPLEX_CORNER_POS = 0.5;
`,t+=`const float SIMPLEX_TETRAHADRON_HEIGHT = 0.70710678118654752440084436210485;
`,t+=`float SimplexPerlin3D( vec3 source ){
`,t+=`    vec3 P = source;
`,t+=`    P.x = [P.x == 0. && P.y == 0. && P.z == 0. ? 0.00001 : P.x];
`,t+=`    P *= SIMPLEX_TETRAHADRON_HEIGHT;
`,t+="    vec3 Pi = floor( P + dot( P, vec3( SKEWFACTOR) ) );",t+=`    vec3 x0 = P - Pi + dot(Pi, vec3( UNSKEWFACTOR ) );
`,t+=`    vec3 g = step(x0.yzx, x0.xyz);
`,t+=`    vec3 l = 1.0 - g;
`,t+=`    vec3 Pi_1 = min( g.xyz, l.zxy );
`,t+=`    vec3 Pi_2 = max( g.xyz, l.zxy );
`,t+=`    vec3 x1 = x0 - Pi_1 + UNSKEWFACTOR;
`,t+=`    vec3 x2 = x0 - Pi_2 + SKEWFACTOR;
`,t+=`    vec3 x3 = x0 - SIMPLEX_CORNER_POS;
`,t+=`    vec4 v1234_x = vec4( x0.x, x1.x, x2.x, x3.x );
`,t+=`    vec4 v1234_y = vec4( x0.y, x1.y, x2.y, x3.y );
`,t+=`    vec4 v1234_z = vec4( x0.z, x1.z, x2.z, x3.z );
`,t+=`    Pi = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;
`,t+=`    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );
`,t+=`    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;
`,t+=`    Pt *= Pt;
`,t+=`    vec4 V1xy_V2xy = mix( Pt.xyxy, Pt.zwzw, vec4( Pi_1.xy, Pi_2.xy ) );
`,t+=`    Pt = vec4( Pt.x, V1xy_V2xy.xz, Pt.z ) * vec4( Pt.y, V1xy_V2xy.yw, Pt.w );
`,t+=`    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );
`,t+=`    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );
`,t+=`    vec3 lowz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi.zzz * ZINC.xyz ) );
`,t+=`    vec3 highz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi_inc1.zzz * ZINC.xyz ) );
`,t+=`    Pi_1 = [( Pi_1.z < 0.5 ) ? lowz_mods : highz_mods];
`,t+=`    Pi_2 = [( Pi_2.z < 0.5 ) ? lowz_mods : highz_mods];
`,t+=`    vec4 hash_0 = fract( Pt * vec4( lowz_mods.x, Pi_1.x, Pi_2.x, highz_mods.x ) ) - 0.49999;
`,t+=`    vec4 hash_1 = fract( Pt * vec4( lowz_mods.y, Pi_1.y, Pi_2.y, highz_mods.y ) ) - 0.49999;
`,t+=`    vec4 hash_2 = fract( Pt * vec4( lowz_mods.z, Pi_1.z, Pi_2.z, highz_mods.z ) ) - 0.49999;
`,t+=`    vec4 grad_results = inversesqrt( hash_0 * hash_0 + hash_1 * hash_1 + hash_2 * hash_2 ) * ( hash_0 * v1234_x + hash_1 * v1234_y + hash_2 * v1234_z );
`,t+=`    const float FINAL_NORMALIZATION = 37.837227241611314102871574478976;
`,t+=`    vec4 kernel_weights = v1234_x * v1234_x + v1234_y * v1234_y + v1234_z * v1234_z;
`,t+=`    kernel_weights = max(0.5 - kernel_weights, vec4(0.));
`,t+=`    kernel_weights = kernel_weights*kernel_weights*kernel_weights;
`,t+=`    return dot( kernel_weights, grad_results ) * FINAL_NORMALIZATION;
`,t+=`}
`,e.shaderLanguage===1?t=e._babylonSLtoWGSL(t):t=e._babylonSLtoGLSL(t),e._emitFunction("SimplexPerlin3D",t,"// SimplexPerlin3D"),e.compilationString+=e._declareOutput(this._outputs[0])+` = SimplexPerlin3D(${this.seed.associatedVariableName});
`,this}}B("BABYLON.SimplexPerlin3DBlock",u2);class c2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("normalMap0",x.AutoDetect),this.registerInput("normalMap1",x.AutoDetect),this.registerOutput("output",x.Vector3),this._inputs[0].addExcludedConnectionPointFromAllowedTypes(x.Color3|x.Color4|x.Vector3|x.Vector4),this._inputs[1].addExcludedConnectionPointFromAllowedTypes(x.Color3|x.Color4|x.Vector3|x.Vector4)}getClassName(){return"NormalBlendBlock"}get normalMap0(){return this._inputs[0]}get normalMap1(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0],i=this._inputs[0],r=this._inputs[1],s=e._getFreeVariableName("stepR"),n=e._getFreeVariableName("stepG");return e.compilationString+=`${e._declareLocalVar(s,x.Float)} = step(0.5, ${i.associatedVariableName}.r);
`,e.compilationString+=`${e._declareLocalVar(n,x.Float)} = step(0.5, ${i.associatedVariableName}.g);
`,e.compilationString+=e._declareOutput(t)+`;
`,e.compilationString+=`${t.associatedVariableName}.r = (1.0 - ${s}) * ${i.associatedVariableName}.r * ${r.associatedVariableName}.r * 2.0 + ${s} * (1.0 - (1.0 - ${i.associatedVariableName}.r) * (1.0 - ${r.associatedVariableName}.r) * 2.0);
`,e.compilationString+=`${t.associatedVariableName}.g = (1.0 - ${n}) * ${i.associatedVariableName}.g * ${r.associatedVariableName}.g * 2.0 + ${n} * (1.0 - (1.0 - ${i.associatedVariableName}.g) * (1.0 - ${r.associatedVariableName}.g) * 2.0);
`,e.compilationString+=`${t.associatedVariableName}.b = ${i.associatedVariableName}.b * ${r.associatedVariableName}.b;
`,this}}B("BABYLON.NormalBlendBlock",c2);class h2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("input",x.Vector2),this.registerInput("angle",x.Float),this.registerOutput("output",x.Vector2)}getClassName(){return"Rotate2dBlock"}get input(){return this._inputs[0]}get angle(){return this._inputs[1]}get output(){return this._outputs[0]}autoConfigure(){if(!this.angle.isConnected){const e=new Ee("angle");e.value=0,e.output.connectTo(this.angle)}}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0],i=this.angle,r=this.input;return e.compilationString+=e._declareOutput(t)+` = vec2(cos(${i.associatedVariableName}) * ${r.associatedVariableName}.x - sin(${i.associatedVariableName}) * ${r.associatedVariableName}.y, sin(${i.associatedVariableName}) * ${r.associatedVariableName}.x + cos(${i.associatedVariableName}) * ${r.associatedVariableName}.y);
`,this}}B("BABYLON.Rotate2dBlock",h2);class d2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("incident",x.AutoDetect),this.registerInput("normal",x.AutoDetect),this.registerOutput("output",x.Vector3),this._inputs[0].addExcludedConnectionPointFromAllowedTypes(x.Vector3|x.Vector4|x.Color3|x.Color4),this._inputs[1].addExcludedConnectionPointFromAllowedTypes(x.Vector3|x.Vector4|x.Color3|x.Color4)}getClassName(){return"ReflectBlock"}get incident(){return this._inputs[0]}get normal(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = reflect(${this.incident.associatedVariableName}.xyz, ${this.normal.associatedVariableName}.xyz);
`,this}}B("BABYLON.ReflectBlock",d2);class f2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("incident",x.AutoDetect),this.registerInput("normal",x.AutoDetect),this.registerInput("ior",x.Float),this.registerOutput("output",x.Vector3),this._inputs[0].addExcludedConnectionPointFromAllowedTypes(x.Vector3|x.Vector4|x.Color3|x.Color4),this._inputs[1].addExcludedConnectionPointFromAllowedTypes(x.Vector3|x.Vector4|x.Color3|x.Color4)}getClassName(){return"RefractBlock"}get incident(){return this._inputs[0]}get normal(){return this._inputs[1]}get ior(){return this._inputs[2]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.compilationString+=e._declareOutput(t)+` = refract(${this.incident.associatedVariableName}.xyz, ${this.normal.associatedVariableName}.xyz, ${this.ior.associatedVariableName});
`,this}}B("BABYLON.RefractBlock",f2);class p2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("color",x.Color3),this.registerInput("level",x.Float),this.registerOutput("output",x.Color3)}getClassName(){return"DesaturateBlock"}get color(){return this._inputs[0]}get level(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0],r=this.color.associatedVariableName,s=e._getFreeVariableName("colorMin"),n=e._getFreeVariableName("colorMax"),o=e._getFreeVariableName("colorMerge");return e.compilationString+=`${e._declareLocalVar(s,x.Float)} = min(min(${r}.x, ${r}.y), ${r}.z);
`,e.compilationString+=`${e._declareLocalVar(n,x.Float)} = max(max(${r}.x, ${r}.y), ${r}.z);
`,e.compilationString+=`${e._declareLocalVar(o,x.Float)} = 0.5 * (${s} + ${n});
`,e.compilationString+=e._declareOutput(t)+` = mix(${r}, ${e._getShaderType(x.Vector3)}(${o}, ${o}, ${o}), ${this.level.associatedVariableName});
`,this}}B("BABYLON.DesaturateBlock",p2);class no extends le{constructor(e){super(e,A.Fragment),this.albedoScaling=!1,this.linkSheenWithAlbedo=!1,this._isUnique=!0,this.registerInput("intensity",x.Float,!0,A.Fragment),this.registerInput("color",x.Color3,!0,A.Fragment),this.registerInput("roughness",x.Float,!0,A.Fragment),this.registerOutput("sheen",x.Object,A.Fragment,new dt("sheen",this,1,no,"SheenBlock"))}initialize(e){e._excludeVariableName("sheenOut"),e._excludeVariableName("sheenMapData"),e._excludeVariableName("vSheenColor"),e._excludeVariableName("vSheenRoughness")}getClassName(){return"SheenBlock"}get intensity(){return this._inputs[0]}get color(){return this._inputs[1]}get roughness(){return this._inputs[2]}get sheen(){return this._outputs[0]}prepareDefines(e,t,i){super.prepareDefines(e,t,i),i.setValue("SHEEN",!0),i.setValue("SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE",!0,!0),i.setValue("SHEEN_LINKWITHALBEDO",this.linkSheenWithAlbedo,!0),i.setValue("SHEEN_ROUGHNESS",this.roughness.isConnected,!0),i.setValue("SHEEN_ALBEDOSCALING",this.albedoScaling,!0)}getCode(e,t){let i="";const r=this.color.isConnected?this.color.associatedVariableName:`vec3${t.fSuffix}(1.)`,s=this.intensity.isConnected?this.intensity.associatedVariableName:"1.",n=this.roughness.isConnected?this.roughness.associatedVariableName:"0.",o=`vec4${t.fSuffix}(0.)`,l=t.shaderLanguage===1;return i=`#ifdef SHEEN
            ${l?"var sheenOut: sheenOutParams":"sheenOutParams sheenOut"};

            ${t._declareLocalVar("vSheenColor",x.Vector4)} = vec4${t.fSuffix}(${r}, ${s});

            sheenOut = sheenBlock(
                vSheenColor
            #ifdef SHEEN_ROUGHNESS
                , ${n}
            #endif
                , roughness
            #ifdef SHEEN_TEXTURE
                , ${o}
                ${l?`, ${o}Sampler`:""}
                , 1.0
            #endif
                , reflectance
            #ifdef SHEEN_LINKWITHALBEDO
                , baseColor
                , surfaceAlbedo
            #endif
            #ifdef ENVIRONMENTBRDF
                , NdotV
                , environmentBrdf
            #endif
            #if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
                , AARoughnessFactors
                , ${l?"uniforms.":""}${e==null?void 0:e._vReflectionMicrosurfaceInfosName}
                , ${e==null?void 0:e._vReflectionInfosName}
                , ${e==null?void 0:e.reflectionColor}
                , ${l?"uniforms.":""}vLightingIntensity
                #ifdef ${e==null?void 0:e._define3DName}
                    , ${e==null?void 0:e._cubeSamplerName}                                      
                    ${l?`, ${e==null?void 0:e._cubeSamplerName}Sampler`:""}
                #else
                    , ${e==null?void 0:e._2DSamplerName}
                    ${l?`, ${e==null?void 0:e._2DSamplerName}Sampler`:""}
                #endif
                , reflectionOut.reflectionCoords
                , NdotVUnclamped
                #ifndef LODBASEDMICROSFURACE
                    #ifdef ${e==null?void 0:e._define3DName}
                        , ${e==null?void 0:e._cubeSamplerName}                        
                        ${l?`, ${e==null?void 0:e._cubeSamplerName}Sampler`:""}
                        , ${e==null?void 0:e._cubeSamplerName}
                        ${l?`, ${e==null?void 0:e._cubeSamplerName}Sampler`:""}
                    #else
                        , ${e==null?void 0:e._2DSamplerName}
                        ${l?`, ${e==null?void 0:e._2DSamplerName}Sampler`:""}
                        , ${e==null?void 0:e._2DSamplerName}
                        ${l?`, ${e==null?void 0:e._2DSamplerName}Sampler`:""}
                    #endif
                #endif
                #if !defined(${e==null?void 0:e._defineSkyboxName}) && defined(RADIANCEOCCLUSION)
                    , seo
                #endif
                #if !defined(${e==null?void 0:e._defineSkyboxName}) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(${e==null?void 0:e._define3DName})
                    , eho
                #endif
            #endif
            );

            #ifdef SHEEN_LINKWITHALBEDO
                surfaceAlbedo = sheenOut.surfaceAlbedo;
            #endif
        #endif
`,i}_buildBlock(e){return e.target===A.Fragment&&e.sharedData.blocksWithDefines.push(this),this}_dumpPropertiesCode(){let e=super._dumpPropertiesCode();return e+=`${this._codeVariableName}.albedoScaling = ${this.albedoScaling};
`,e+=`${this._codeVariableName}.linkSheenWithAlbedo = ${this.linkSheenWithAlbedo};
`,e}serialize(){const e=super.serialize();return e.albedoScaling=this.albedoScaling,e.linkSheenWithAlbedo=this.linkSheenWithAlbedo,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.albedoScaling=e.albedoScaling,this.linkSheenWithAlbedo=e.linkSheenWithAlbedo}}C([U("Albedo scaling",0,"PROPERTIES",{embedded:!0,notifiers:{update:!0}})],no.prototype,"albedoScaling",void 0);C([U("Link sheen with albedo",0,"PROPERTIES",{embedded:!0,notifiers:{update:!0}})],no.prototype,"linkSheenWithAlbedo",void 0);B("BABYLON.SheenBlock",no);class tc extends le{constructor(e){super(e,A.Fragment),this._tangentCorrectionFactorName="",this._isUnique=!0,this.registerInput("intensity",x.Float,!0,A.Fragment),this.registerInput("direction",x.Vector2,!0,A.Fragment),this.registerInput("uv",x.Vector2,!0),this.registerInput("worldTangent",x.Vector4,!0),this.registerInput("TBN",x.Object,!0,A.VertexAndFragment,new dt("TBN",this,0,so,"TBNBlock")),this.registerInput("roughness",x.Float,!0,A.Fragment),this.registerOutput("anisotropy",x.Object,A.Fragment,new dt("anisotropy",this,1,tc,"AnisotropyBlock"))}initialize(e){e._excludeVariableName("anisotropicOut"),e._excludeVariableName("TBN")}getClassName(){return"AnisotropyBlock"}get intensity(){return this._inputs[0]}get direction(){return this._inputs[1]}get uv(){return this._inputs[2]}get worldTangent(){return this._inputs[3]}get TBN(){return this._inputs[4]}get roughness(){return this._inputs[5]}get anisotropy(){return this._outputs[0]}_generateTBNSpace(e){let t="";const i=`//${this.name}`,r=this.uv,s=this.worldPositionConnectionPoint,n=this.worldNormalConnectionPoint,o=this.worldTangent,l=e.shaderLanguage===1;r.isConnected||L.Error("You must connect the 'uv' input of the Anisotropy block!"),e._emitExtension("derivatives","#extension GL_OES_standard_derivatives : enable");const u={search:/defined\(TANGENT\)/g,replace:o.isConnected?"defined(TANGENT)":"defined(IGNORE)"},c=this.TBN;return c.isConnected?e.compilationString+=`
            #ifdef TBNBLOCK
            ${l?"var TBN":"mat3 TBN"} = ${c.associatedVariableName};
            #endif
            `:o.isConnected&&(t+=`${e._declareLocalVar("tbnNormal",x.Vector3)} = normalize(${n.associatedVariableName}.xyz);
`,t+=`${e._declareLocalVar("tbnTangent",x.Vector3)} = normalize(${o.associatedVariableName}.xyz);
`,t+=`${e._declareLocalVar("tbnBitangent",x.Vector3)} = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};
`,t+=`${l?"var vTBN":"mat3 vTBN"} = ${l?"mat3x3f":"mat3"}(tbnTangent, tbnBitangent, tbnNormal);
`),t+=`
            #if defined(${o.isConnected?"TANGENT":"IGNORE"}) && defined(NORMAL)
                ${l?"var TBN":"mat3 TBN"} = vTBN;
            #else
                ${l?"var TBN":"mat3 TBN"} = cotangent_frame(${n.associatedVariableName+".xyz"}, ${"v_"+s.associatedVariableName+".xyz"}, ${r.isConnected?r.associatedVariableName:"vec2(0.)"}, vec2${e.fSuffix}(1., 1.));
            #endif
`,e._emitFunctionFromInclude("bumpFragmentMainFunctions",i,{replaceStrings:[u]}),t}getCode(e,t=!1){let i="";t&&(i+=this._generateTBNSpace(e));const r=e.shaderLanguage===1,s=this.intensity.isConnected?this.intensity.associatedVariableName:"1.0",n=this.direction.isConnected?this.direction.associatedVariableName:"vec2(1., 0.)",o=this.roughness.isConnected?this.roughness.associatedVariableName:"0.";return i+=`${r?"var anisotropicOut: anisotropicOutParams":"anisotropicOutParams anisotropicOut"};
            anisotropicOut = anisotropicBlock(
                vec3(${n}, ${s}),
                ${o},
            #ifdef ANISOTROPIC_TEXTURE
                vec3(0.),
            #endif
                TBN,
                normalW,
                viewDirectionW
            );
`,i}prepareDefines(e,t,i){super.prepareDefines(e,t,i),i.setValue("ANISOTROPIC",!0),i.setValue("ANISOTROPIC_TEXTURE",!1,!0),i.setValue("ANISOTROPIC_LEGACY",!this.roughness.isConnected)}bind(e,t,i){super.bind(e,t,i),i&&e.setFloat(this._tangentCorrectionFactorName,i.getWorldMatrix().determinant()<0?-1:1)}_buildBlock(e){return e.target===A.Fragment&&(e.sharedData.blocksWithDefines.push(this),e.sharedData.bindableBlocks.push(this),this._tangentCorrectionFactorName=e._getFreeDefineName("tangentCorrectionFactor"),e._emitUniformFromString(this._tangentCorrectionFactorName,x.Float)),this}}B("BABYLON.AnisotropyBlock",tc);class ao extends Xo{_onGenerateOnlyFragmentCodeChanged(){return this.position.isConnected?(this.generateOnlyFragmentCode=!this.generateOnlyFragmentCode,L.Error("The position input must not be connected to be able to switch!"),!1):(this._setTarget(),!0)}_setTarget(){super._setTarget(),this.getInputByName("position").target=this.generateOnlyFragmentCode?A.Fragment:A.Vertex,this.generateOnlyFragmentCode&&(this.forceIrradianceInFragment=!0)}constructor(e){super(e),this.useSphericalHarmonics=!0,this.forceIrradianceInFragment=!1,this._isUnique=!0,this.registerInput("position",x.AutoDetect,!1,A.Vertex),this.registerInput("world",x.Matrix,!1,A.Vertex),this.registerInput("color",x.Color3,!0,A.Fragment),this.registerOutput("reflection",x.Object,A.Fragment,new dt("reflection",this,1,ao,"ReflectionBlock")),this.position.addExcludedConnectionPointFromAllowedTypes(x.Color3|x.Vector3|x.Vector4)}getClassName(){return"ReflectionBlock"}get position(){return this._inputs[0]}get worldPosition(){return this.worldPositionConnectionPoint}get worldNormal(){return this.worldNormalConnectionPoint}get world(){return this._inputs[1]}get cameraPosition(){return this.cameraPositionConnectionPoint}get view(){return this.viewConnectionPoint}get color(){return this._inputs[2]}get reflection(){return this._outputs[0]}get hasTexture(){return!!this._getTexture()}get reflectionColor(){return this.color.isConnected?this.color.associatedVariableName:"vec3(1., 1., 1.)"}_getTexture(){return this.texture?this.texture:this._scene.environmentTexture}prepareDefines(e,t,i){super.prepareDefines(e,t,i);const r=this._getTexture(),s=r&&r.getTextureMatrix;i.setValue("REFLECTION",s,!0),s&&(i.setValue(this._defineLODReflectionAlpha,r.lodLevelInAlpha,!0),i.setValue(this._defineLinearSpecularReflection,r.linearSpecularLOD,!0),i.setValue(this._defineOppositeZ,this._scene.useRightHandedSystem?!r.invertZ:r.invertZ,!0),i.setValue("SPHERICAL_HARMONICS",this.useSphericalHarmonics,!0),i.setValue("GAMMAREFLECTION",r.gammaSpace,!0),i.setValue("RGBDREFLECTION",r.isRGBD,!0),r&&r.coordinatesMode!==Y.SKYBOX_MODE&&r.isCube&&(i.setValue("USESPHERICALFROMREFLECTIONMAP",!0),i.setValue("USEIRRADIANCEMAP",!1),this.forceIrradianceInFragment||this._scene.getEngine().getCaps().maxVaryingVectors<=8?i.setValue("USESPHERICALINVERTEX",!1):i.setValue("USESPHERICALINVERTEX",!0)))}bind(e,t,i,r){super.bind(e,t,i);const s=this._getTexture();if(!s||!r)return;s.isCube?e.setTexture(this._cubeSamplerName,s):e.setTexture(this._2DSamplerName,s);const n=s.getSize().width;e.setFloat3(this._vReflectionMicrosurfaceInfosName,n,s.lodGenerationScale,s.lodGenerationOffset),e.setFloat2(this._vReflectionFilteringInfoName,n,Math.log2(n));const o=r.materialDefines,l=s.sphericalPolynomial;if(o.USESPHERICALFROMREFLECTIONMAP&&l)if(o.SPHERICAL_HARMONICS){const u=l.preScaledHarmonics;e.setVector3("vSphericalL00",u.l00),e.setVector3("vSphericalL1_1",u.l1_1),e.setVector3("vSphericalL10",u.l10),e.setVector3("vSphericalL11",u.l11),e.setVector3("vSphericalL2_2",u.l2_2),e.setVector3("vSphericalL2_1",u.l2_1),e.setVector3("vSphericalL20",u.l20),e.setVector3("vSphericalL21",u.l21),e.setVector3("vSphericalL22",u.l22)}else e.setFloat3("vSphericalX",l.x.x,l.x.y,l.x.z),e.setFloat3("vSphericalY",l.y.x,l.y.y,l.y.z),e.setFloat3("vSphericalZ",l.z.x,l.z.y,l.z.z),e.setFloat3("vSphericalXX_ZZ",l.xx.x-l.zz.x,l.xx.y-l.zz.y,l.xx.z-l.zz.z),e.setFloat3("vSphericalYY_ZZ",l.yy.x-l.zz.x,l.yy.y-l.zz.y,l.yy.z-l.zz.z),e.setFloat3("vSphericalZZ",l.zz.x,l.zz.y,l.zz.z),e.setFloat3("vSphericalXY",l.xy.x,l.xy.y,l.xy.z),e.setFloat3("vSphericalYZ",l.yz.x,l.yz.y,l.yz.z),e.setFloat3("vSphericalZX",l.zx.x,l.zx.y,l.zx.z)}handleVertexSide(e){let t=super.handleVertexSide(e);const i=e.shaderLanguage===1;e._emitFunctionFromInclude("harmonicsFunctions",`//${this.name}`,{replaceStrings:[{search:/uniform vec3 vSphericalL00;[\s\S]*?uniform vec3 vSphericalL22;/g,replace:""},{search:/uniform vec3 vSphericalX;[\s\S]*?uniform vec3 vSphericalZX;/g,replace:""}]});const r=e._getFreeVariableName("reflectionVector");return this._vEnvironmentIrradianceName=e._getFreeVariableName("vEnvironmentIrradiance"),e._emitVaryingFromString(this._vEnvironmentIrradianceName,x.Vector3,"defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)"),e._emitUniformFromString("vSphericalL00",x.Vector3,"SPHERICAL_HARMONICS"),e._emitUniformFromString("vSphericalL1_1",x.Vector3,"SPHERICAL_HARMONICS"),e._emitUniformFromString("vSphericalL10",x.Vector3,"SPHERICAL_HARMONICS"),e._emitUniformFromString("vSphericalL11",x.Vector3,"SPHERICAL_HARMONICS"),e._emitUniformFromString("vSphericalL2_2",x.Vector3,"SPHERICAL_HARMONICS"),e._emitUniformFromString("vSphericalL2_1",x.Vector3,"SPHERICAL_HARMONICS"),e._emitUniformFromString("vSphericalL20",x.Vector3,"SPHERICAL_HARMONICS"),e._emitUniformFromString("vSphericalL21",x.Vector3,"SPHERICAL_HARMONICS"),e._emitUniformFromString("vSphericalL22",x.Vector3,"SPHERICAL_HARMONICS"),e._emitUniformFromString("vSphericalX",x.Vector3,"SPHERICAL_HARMONICS",!0),e._emitUniformFromString("vSphericalY",x.Vector3,"SPHERICAL_HARMONICS",!0),e._emitUniformFromString("vSphericalZ",x.Vector3,"SPHERICAL_HARMONICS",!0),e._emitUniformFromString("vSphericalXX_ZZ",x.Vector3,"SPHERICAL_HARMONICS",!0),e._emitUniformFromString("vSphericalYY_ZZ",x.Vector3,"SPHERICAL_HARMONICS",!0),e._emitUniformFromString("vSphericalZZ",x.Vector3,"SPHERICAL_HARMONICS",!0),e._emitUniformFromString("vSphericalXY",x.Vector3,"SPHERICAL_HARMONICS",!0),e._emitUniformFromString("vSphericalYZ",x.Vector3,"SPHERICAL_HARMONICS",!0),e._emitUniformFromString("vSphericalZX",x.Vector3,"SPHERICAL_HARMONICS",!0),t+=`#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
                ${e._declareLocalVar(r,x.Vector3)} = (${(i?"uniforms.":"")+this._reflectionMatrixName} * vec4${e.fSuffix}(normalize(${this.worldNormal.associatedVariableName}).xyz, 0)).xyz;
                #ifdef ${this._defineOppositeZ}
                    ${r}.z *= -1.0;
                #endif
                ${i?"vertexOutputs.":""}${this._vEnvironmentIrradianceName} = computeEnvironmentIrradiance(${r});
            #endif
`,t}getCode(e,t){let i="";this.handleFragmentSideInits(e);const r=e.shaderLanguage===1;e._emitFunctionFromInclude("harmonicsFunctions",`//${this.name}`,{replaceStrings:[{search:/uniform vec3 vSphericalL00;[\s\S]*?uniform vec3 vSphericalL22;/g,replace:""},{search:/uniform vec3 vSphericalX;[\s\S]*?uniform vec3 vSphericalZX;/g,replace:""}]}),r||(e._emitFunction("sampleReflection",`
                #ifdef ${this._define3DName}
                    #define sampleReflection(s, c) textureCube(s, c)
                #else
                    #define sampleReflection(s, c) texture2D(s, c)
                #endif
`,`//${this.name}`),e._emitFunction("sampleReflectionLod",`
                #ifdef ${this._define3DName}
                    #define sampleReflectionLod(s, c, l) textureCubeLodEXT(s, c, l)
                #else
                    #define sampleReflectionLod(s, c, l) texture2DLodEXT(s, c, l)
                #endif
`,`//${this.name}`));const s=r?`
            fn computeReflectionCoordsPBR(worldPos: vec4f, worldNormal: vec3f) -> vec3f {
                ${this.handleFragmentSideCodeReflectionCoords(e,"worldNormal","worldPos",!0,!0)}
                return ${this._reflectionVectorName};
            }
`:`
            vec3 computeReflectionCoordsPBR(vec4 worldPos, vec3 worldNormal) {
                ${this.handleFragmentSideCodeReflectionCoords(e,"worldNormal","worldPos",!0,!0)}
                return ${this._reflectionVectorName};
            }
`;return e._emitFunction("computeReflectionCoordsPBR",s,`//${this.name}`),this._vReflectionMicrosurfaceInfosName=e._getFreeVariableName("vReflectionMicrosurfaceInfos"),e._emitUniformFromString(this._vReflectionMicrosurfaceInfosName,x.Vector3),this._vReflectionInfosName=e._getFreeVariableName("vReflectionInfos"),this._vReflectionFilteringInfoName=e._getFreeVariableName("vReflectionFilteringInfo"),e._emitUniformFromString(this._vReflectionFilteringInfoName,x.Vector2),i+=`#ifdef REFLECTION
            ${e._declareLocalVar(this._vReflectionInfosName,x.Vector2)} = vec2${e.fSuffix}(1., 0.);

            ${r?"var reflectionOut: reflectionOutParams":"reflectionOutParams reflectionOut"};

            reflectionOut = reflectionBlock(
                ${this.generateOnlyFragmentCode?this._worldPositionNameInFragmentOnlyMode:(r?"input.":"")+"v_"+this.worldPosition.associatedVariableName}.xyz
                , ${t}
                , alphaG
                , ${(r?"uniforms.":"")+this._vReflectionMicrosurfaceInfosName}
                , ${this._vReflectionInfosName}
                , ${this.reflectionColor}
            #ifdef ANISOTROPIC
                ,anisotropicOut
            #endif
            #if defined(${this._defineLODReflectionAlpha}) && !defined(${this._defineSkyboxName})
                ,NdotVUnclamped
            #endif
            #ifdef ${this._defineLinearSpecularReflection}
                , roughness
            #endif
            #ifdef ${this._define3DName}
                , ${this._cubeSamplerName}
                ${r?`, ${this._cubeSamplerName}Sampler`:""}
            #else
                , ${this._2DSamplerName}
                ${r?`, ${this._2DSamplerName}Sampler`:""}
            #endif
            #if defined(NORMAL) && defined(USESPHERICALINVERTEX)
                , ${r?"input.":""}${this._vEnvironmentIrradianceName}
            #endif
            #if (defined(USESPHERICALFROMREFLECTIONMAP) && (!defined(NORMAL) || !defined(USESPHERICALINVERTEX))) || (defined(USEIRRADIANCEMAP) && defined(REFLECTIONMAP_3D))
                    , ${this._reflectionMatrixName}
            #endif
            #ifdef USEIRRADIANCEMAP
                , irradianceSampler         // ** not handled **
                ${r?", irradianceSamplerSampler":""}
            #endif
            #ifndef LODBASEDMICROSFURACE
                #ifdef ${this._define3DName}
                    , ${this._cubeSamplerName}
                    ${r?`, ${this._cubeSamplerName}Sampler`:""}
                    , ${this._cubeSamplerName}
                    ${r?`, ${this._cubeSamplerName}Sampler`:""}
                #else
                    , ${this._2DSamplerName}
                    ${r?`, ${this._2DSamplerName}Sampler`:""}
                    , ${this._2DSamplerName}                    
                    ${r?`, ${this._2DSamplerName}Sampler`:""}
                #endif
            #endif
            #ifdef REALTIME_FILTERING
                , ${this._vReflectionFilteringInfoName}
                #ifdef IBL_CDF_FILTERING
                    , icdfSampler         // ** not handled **
                    ${r?", icdfSamplerSampler":""}
                #endif
            #endif
            );
        #endif
`,i}_buildBlock(e){return this._scene=e.sharedData.scene,e.target!==A.Fragment&&(this._defineLODReflectionAlpha=e._getFreeDefineName("LODINREFLECTIONALPHA"),this._defineLinearSpecularReflection=e._getFreeDefineName("LINEARSPECULARREFLECTION")),this}_dumpPropertiesCode(){let e=super._dumpPropertiesCode();return this.texture&&(e+=`${this._codeVariableName}.texture.gammaSpace = ${this.texture.gammaSpace};
`),e+=`${this._codeVariableName}.useSphericalHarmonics = ${this.useSphericalHarmonics};
`,e+=`${this._codeVariableName}.forceIrradianceInFragment = ${this.forceIrradianceInFragment};
`,e}serialize(){var t;const e=super.serialize();return e.useSphericalHarmonics=this.useSphericalHarmonics,e.forceIrradianceInFragment=this.forceIrradianceInFragment,e.gammaSpace=((t=this.texture)==null?void 0:t.gammaSpace)??!0,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.useSphericalHarmonics=e.useSphericalHarmonics,this.forceIrradianceInFragment=e.forceIrradianceInFragment,this.texture&&(this.texture.gammaSpace=e.gammaSpace)}}C([U("Spherical Harmonics",0,"ADVANCED",{embedded:!0,notifiers:{update:!0}})],ao.prototype,"useSphericalHarmonics",void 0);C([U("Force irradiance in fragment",0,"ADVANCED",{embedded:!0,notifiers:{update:!0}})],ao.prototype,"forceIrradianceInFragment",void 0);B("BABYLON.ReflectionBlock",ao);class Vn extends le{constructor(e){super(e,A.Fragment),this._tangentCorrectionFactorName="",this.remapF0OnInterfaceChange=!0,this._isUnique=!0,this.registerInput("intensity",x.Float,!1,A.Fragment),this.registerInput("roughness",x.Float,!0,A.Fragment),this.registerInput("indexOfRefraction",x.Float,!0,A.Fragment),this.registerInput("normalMapColor",x.Color3,!0,A.Fragment),this.registerInput("uv",x.Vector2,!0,A.Fragment),this.registerInput("tintColor",x.Color3,!0,A.Fragment),this.registerInput("tintAtDistance",x.Float,!0,A.Fragment),this.registerInput("tintThickness",x.Float,!0,A.Fragment),this.registerInput("worldTangent",x.Vector4,!0),this.registerInput("worldNormal",x.AutoDetect,!0),this.worldNormal.addExcludedConnectionPointFromAllowedTypes(x.Color4|x.Vector4|x.Vector3),this.registerInput("TBN",x.Object,!0,A.VertexAndFragment,new dt("TBN",this,0,so,"TBNBlock")),this.registerOutput("clearcoat",x.Object,A.Fragment,new dt("clearcoat",this,1,Vn,"ClearCoatBlock"))}initialize(e){e._excludeVariableName("clearcoatOut"),e._excludeVariableName("vClearCoatParams"),e._excludeVariableName("vClearCoatTintParams"),e._excludeVariableName("vClearCoatRefractionParams"),e._excludeVariableName("vClearCoatTangentSpaceParams"),e._excludeVariableName("vGeometricNormaClearCoatW")}getClassName(){return"ClearCoatBlock"}get intensity(){return this._inputs[0]}get roughness(){return this._inputs[1]}get indexOfRefraction(){return this._inputs[2]}get normalMapColor(){return this._inputs[3]}get uv(){return this._inputs[4]}get tintColor(){return this._inputs[5]}get tintAtDistance(){return this._inputs[6]}get tintThickness(){return this._inputs[7]}get worldTangent(){return this._inputs[8]}get worldNormal(){return this._inputs[9]}get TBN(){return this._inputs[10]}get clearcoat(){return this._outputs[0]}autoConfigure(){if(!this.intensity.isConnected){const e=new Ee("ClearCoat intensity",A.Fragment,x.Float);e.value=1,e.output.connectTo(this.intensity)}}prepareDefines(e,t,i){super.prepareDefines(e,t,i),i.setValue("CLEARCOAT",!0),i.setValue("CLEARCOAT_TEXTURE",!1,!0),i.setValue("CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE",!0,!0),i.setValue("CLEARCOAT_TINT",this.tintColor.isConnected||this.tintThickness.isConnected||this.tintAtDistance.isConnected,!0),i.setValue("CLEARCOAT_BUMP",this.normalMapColor.isConnected,!0),i.setValue("CLEARCOAT_DEFAULTIOR",this.indexOfRefraction.isConnected?this.indexOfRefraction.connectInputBlock.value===mg._DefaultIndexOfRefraction:!0,!0),i.setValue("CLEARCOAT_REMAP_F0",this.remapF0OnInterfaceChange,!0)}bind(e,t,i){var h;super.bind(e,t,i);const r=((h=this.indexOfRefraction.connectInputBlock)==null?void 0:h.value)??mg._DefaultIndexOfRefraction,s=1-r,n=1+r,o=Math.pow(-s/n,2),l=1/r;e.setFloat4("vClearCoatRefractionParams",o,l,s,n);const u=this.clearcoat.hasEndpoints?this.clearcoat.endpoints[0].ownerBlock:null,c=u!=null&&u.perturbedNormal.isConnected?u.perturbedNormal.connectedPoint.ownerBlock:null;this._scene._mirroredCameraPosition?e.setFloat2("vClearCoatTangentSpaceParams",c!=null&&c.invertX?1:-1,c!=null&&c.invertY?1:-1):e.setFloat2("vClearCoatTangentSpaceParams",c!=null&&c.invertX?-1:1,c!=null&&c.invertY?-1:1),i&&e.setFloat(this._tangentCorrectionFactorName,i.getWorldMatrix().determinant()<0?-1:1)}_generateTBNSpace(e,t,i){let r="";const s=`//${this.name}`,n=this.worldTangent,o=e.shaderLanguage===1;o||e._emitExtension("derivatives","#extension GL_OES_standard_derivatives : enable");const l={search:/defined\(TANGENT\)/g,replace:n.isConnected?"defined(TANGENT)":"defined(IGNORE)"},u=this.TBN;return u.isConnected?e.compilationString+=`
            #ifdef TBNBLOCK
                ${o?"var TBN":"mat3 TBN"} = ${u.associatedVariableName};
            #endif
            `:n.isConnected&&(r+=`${e._declareLocalVar("tbnNormal",x.Vector3)} = normalize(${i}.xyz);
`,r+=`${e._declareLocalVar("tbnTangent",x.Vector3)} = normalize(${n.associatedVariableName}.xyz);
`,r+=`${e._declareLocalVar("tbnBitangent",x.Vector3)} = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};
`,r+=`${o?"var vTBN":"mat3 vTBN"} = ${o?"mat3x3f":"mat3"}(tbnTangent, tbnBitangent, tbnNormal);
`),e._emitFunctionFromInclude("bumpFragmentMainFunctions",s,{replaceStrings:[l]}),r}static _GetInitializationCode(e,t){let i="";const r=t!=null&&t.intensity.isConnected?t.intensity.associatedVariableName:"1.",s=t!=null&&t.roughness.isConnected?t.roughness.associatedVariableName:"0.",n=t!=null&&t.tintColor.isConnected?t.tintColor.associatedVariableName:`vec3${e.fSuffix}(1.)`,o=t!=null&&t.tintThickness.isConnected?t.tintThickness.associatedVariableName:"1.";return i+=`
            #ifdef CLEARCOAT
                ${e._declareLocalVar("vClearCoatParams",x.Vector2)} = vec2${e.fSuffix}(${r}, ${s});
                ${e._declareLocalVar("vClearCoatTintParams",x.Vector4)} = vec4${e.fSuffix}(${n}, ${o});
            #endif
`,i}static GetCode(e,t,i,r,s,n,o){let l="";const u=t!=null&&t.normalMapColor.isConnected?t.normalMapColor.associatedVariableName:`vec3${e.fSuffix}(0.)`,c=t!=null&&t.uv.isConnected?t.uv.associatedVariableName:`vec2${e.fSuffix}(0.)`,h=t!=null&&t.tintAtDistance.isConnected?t.tintAtDistance.associatedVariableName:"1.",d=`vec4${e.fSuffix}(0.)`;if(t){e._emitUniformFromString("vClearCoatRefractionParams",x.Vector4),e._emitUniformFromString("vClearCoatTangentSpaceParams",x.Vector2);const p=t.worldNormal;l+=`${e._declareLocalVar("vGeometricNormaClearCoatW",x.Vector3)} = ${p.isConnected?"normalize("+p.associatedVariableName+".xyz)":"geometricNormalW"};
`}else l+=`${e._declareLocalVar("vGeometricNormaClearCoatW",x.Vector3)} = geometricNormalW;
`;s&&t&&(l+=t._generateTBNSpace(e,r,o),n=t.worldTangent.isConnected);const f=e.shaderLanguage===1;return l+=`${f?"var clearcoatOut: clearcoatOutParams":"clearcoatOutParams clearcoatOut"};

        #ifdef CLEARCOAT
            clearcoatOut = clearcoatBlock(
                ${r}.xyz
                , vGeometricNormaClearCoatW
                , viewDirectionW
                , vClearCoatParams
                , specularEnvironmentR0
            #ifdef CLEARCOAT_TEXTURE
                , vec2${e.fSuffix}(0.)
            #endif
            #ifdef CLEARCOAT_TINT
                , vClearCoatTintParams
                , ${h}
                , ${f?"uniforms.":""}vClearCoatRefractionParams
                #ifdef CLEARCOAT_TINT_TEXTURE
                    , ${d}
                #endif
            #endif
            #ifdef CLEARCOAT_BUMP
                , vec2${e.fSuffix}(0., 1.)
                , vec4${e.fSuffix}(${u}, 0.)
                , ${c}
                #if defined(${n?"TANGENT":"IGNORE"}) && defined(NORMAL)
                    , vTBN
                #else
                    , ${f?"uniforms.":""}vClearCoatTangentSpaceParams
                #endif
                #ifdef OBJECTSPACE_NORMALMAP
                    , normalMatrix
                #endif
            #endif
            #if defined(FORCENORMALFORWARD) && defined(NORMAL)
                , faceNormal
            #endif
            #ifdef REFLECTION
                , ${f?"uniforms.":""}${i==null?void 0:i._vReflectionMicrosurfaceInfosName}
                , ${i==null?void 0:i._vReflectionInfosName}
                , ${i==null?void 0:i.reflectionColor}
                , ${f?"uniforms.":""}vLightingIntensity
                #ifdef ${i==null?void 0:i._define3DName}
                    , ${i==null?void 0:i._cubeSamplerName}       
                    ${f?`, ${i==null?void 0:i._cubeSamplerName}Sampler`:""}
                #else
                    , ${i==null?void 0:i._2DSamplerName}       
                    ${f?`, ${i==null?void 0:i._2DSamplerName}Sampler`:""}
                #endif
                #ifndef LODBASEDMICROSFURACE
                    #ifdef ${i==null?void 0:i._define3DName}
                        , ${i==null?void 0:i._cubeSamplerName}       
                        ${f?`, ${i==null?void 0:i._cubeSamplerName}Sampler`:""}
                        , ${i==null?void 0:i._cubeSamplerName}
                        ${f?`, ${i==null?void 0:i._cubeSamplerName}Sampler`:""}
                    #else
                        , ${i==null?void 0:i._2DSamplerName}
                        ${f?`, ${i==null?void 0:i._2DSamplerName}Sampler`:""}
                        , ${i==null?void 0:i._2DSamplerName}
                        ${f?`, ${i==null?void 0:i._2DSamplerName}Sampler`:""}                        
                    #endif
                #endif
            #endif
            #if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)
                , (${e._generateTernary("1.","-1.",f?"fragmentInputs.frontFacing":"gl_FrontFacing")})
            #endif
            );
        #else
            clearcoatOut.specularEnvironmentR0 = specularEnvironmentR0;
        #endif
`,l}_buildBlock(e){return this._scene=e.sharedData.scene,e.target===A.Fragment&&(e.sharedData.bindableBlocks.push(this),e.sharedData.blocksWithDefines.push(this),this._tangentCorrectionFactorName=e._getFreeDefineName("tangentCorrectionFactor"),e._emitUniformFromString(this._tangentCorrectionFactorName,x.Float)),this}_dumpPropertiesCode(){let e=super._dumpPropertiesCode();return e+=`${this._codeVariableName}.remapF0OnInterfaceChange = ${this.remapF0OnInterfaceChange};
`,e}serialize(){const e=super.serialize();return e.remapF0OnInterfaceChange=this.remapF0OnInterfaceChange,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.remapF0OnInterfaceChange=e.remapF0OnInterfaceChange??!0}}C([U("Remap F0 on interface change",0,"ADVANCED",{embedded:!0})],Vn.prototype,"remapF0OnInterfaceChange",void 0);B("BABYLON.ClearCoatBlock",Vn);class Zo extends le{constructor(e){super(e,A.Fragment),this._isUnique=!0,this.registerInput("intensity",x.Float,!0,A.Fragment),this.registerInput("indexOfRefraction",x.Float,!0,A.Fragment),this.registerInput("thickness",x.Float,!0,A.Fragment),this.registerOutput("iridescence",x.Object,A.Fragment,new dt("iridescence",this,1,Zo,"IridescenceBlock"))}initialize(e){e._excludeVariableName("iridescenceOut"),e._excludeVariableName("vIridescenceParams")}getClassName(){return"IridescenceBlock"}get intensity(){return this._inputs[0]}get indexOfRefraction(){return this._inputs[1]}get thickness(){return this._inputs[2]}get iridescence(){return this._outputs[0]}autoConfigure(){if(!this.intensity.isConnected){const e=new Ee("Iridescence intensity",A.Fragment,x.Float);e.value=1,e.output.connectTo(this.intensity);const t=new Ee("Iridescence ior",A.Fragment,x.Float);t.value=1.3,t.output.connectTo(this.indexOfRefraction);const i=new Ee("Iridescence thickness",A.Fragment,x.Float);i.value=400,i.output.connectTo(this.thickness)}}prepareDefines(e,t,i){super.prepareDefines(e,t,i),i.setValue("IRIDESCENCE",!0,!0),i.setValue("IRIDESCENCE_TEXTURE",!1,!0),i.setValue("IRIDESCENCE_THICKNESS_TEXTURE",!1,!0)}static GetCode(e,t){let i="";const r=e!=null&&e.intensity.isConnected?e.intensity.associatedVariableName:"1.",s=e!=null&&e.indexOfRefraction.isConnected?e.indexOfRefraction.associatedVariableName:_g._DefaultIndexOfRefraction,n=e!=null&&e.thickness.isConnected?e.thickness.associatedVariableName:_g._DefaultMaximumThickness,o=t.shaderLanguage===1;return i+=`${o?"var iridescenceOut: iridescenceOutParams":"iridescenceOutParams iridescenceOut"};

        #ifdef IRIDESCENCE
            iridescenceOut = iridescenceBlock(
                vec4(${r}, ${s}, 1., ${n})
                , NdotV
                , specularEnvironmentR0
                #ifdef CLEARCOAT
                    , NdotVUnclamped
                    , vClearCoatParams
                #endif                
            );

            ${o?"let":"float"} iridescenceIntensity = iridescenceOut.iridescenceIntensity;
            specularEnvironmentR0 = iridescenceOut.specularEnvironmentR0;
        #endif
`,i}_buildBlock(e){return e.target===A.Fragment&&(e.sharedData.bindableBlocks.push(this),e.sharedData.blocksWithDefines.push(this)),this}serialize(){return super.serialize()}_deserialize(e,t,i){super._deserialize(e,t,i)}}B("BABYLON.IridescenceBlock",Zo);class ta extends le{constructor(e){super(e,A.Fragment),this.linkRefractionWithTransparency=!1,this.invertRefractionY=!1,this.useThicknessAsDepth=!1,this._isUnique=!0,this.registerInput("intensity",x.Float,!1,A.Fragment),this.registerInput("tintAtDistance",x.Float,!0,A.Fragment),this.registerInput("volumeIndexOfRefraction",x.Float,!0,A.Fragment),this.registerOutput("refraction",x.Object,A.Fragment,new dt("refraction",this,1,ta,"RefractionBlock"))}initialize(e){e._excludeVariableName("vRefractionPosition"),e._excludeVariableName("vRefractionSize")}getClassName(){return"RefractionBlock"}get intensity(){return this._inputs[0]}get tintAtDistance(){return this._inputs[1]}get volumeIndexOfRefraction(){return this._inputs[2]}get view(){return this.viewConnectionPoint}get refraction(){return this._outputs[0]}get hasTexture(){return!!this._getTexture()}_getTexture(){return this.texture?this.texture:this._scene.environmentTexture}autoConfigure(e,t=()=>!0){if(!this.intensity.isConnected){const i=new Ee("Refraction intensity",A.Fragment,x.Float);i.value=1,i.output.connectTo(this.intensity)}if(this.view&&!this.view.isConnected){let i=e.getInputBlockByPredicate(r=>r.systemValue===De.View&&t(r));i||(i=new Ee("view"),i.setAsSystemValue(De.View)),i.output.connectTo(this.view)}}prepareDefines(e,t,i){super.prepareDefines(e,t,i);const r=this._getTexture(),s=r&&r.getTextureMatrix;i.setValue("SS_REFRACTION",s,!0),s&&(i.setValue(this._define3DName,r.isCube,!0),i.setValue(this._defineLODRefractionAlpha,r.lodLevelInAlpha,!0),i.setValue(this._defineLinearSpecularRefraction,r.linearSpecularLOD,!0),i.setValue(this._defineOppositeZ,this._scene.useRightHandedSystem&&r.isCube?!r.invertZ:r.invertZ,!0),i.setValue("SS_LINKREFRACTIONTOTRANSPARENCY",this.linkRefractionWithTransparency,!0),i.setValue("SS_GAMMAREFRACTION",r.gammaSpace,!0),i.setValue("SS_RGBDREFRACTION",r.isRGBD,!0),i.setValue("SS_USE_LOCAL_REFRACTIONMAP_CUBIC",!!r.boundingBoxSize,!0),i.setValue("SS_USE_THICKNESS_AS_DEPTH",this.useThicknessAsDepth,!0))}isReady(){const e=this._getTexture();return!(e&&!e.isReadyOrNotBlocking())}bind(e,t,i){var l,u;super.bind(e,t,i);const r=this._getTexture();if(!r)return;r.isCube?e.setTexture(this._cubeSamplerName,r):e.setTexture(this._2DSamplerName,r),e.setMatrix(this._refractionMatrixName,r.getRefractionTextureMatrix());let s=1;r.isCube||r.depth&&(s=r.depth);const n=((l=this.volumeIndexOfRefraction.connectInputBlock)==null?void 0:l.value)??((u=this.indexOfRefractionConnectionPoint.connectInputBlock)==null?void 0:u.value)??1.5;e.setFloat4(this._vRefractionInfosName,r.level,1/n,s,this.invertRefractionY?-1:1),e.setFloat4(this._vRefractionMicrosurfaceInfosName,r.getSize().width,r.lodGenerationScale,r.lodGenerationOffset,1/n);const o=r.getSize().width;if(e.setFloat2(this._vRefractionFilteringInfoName,o,Math.log2(o)),r.boundingBoxSize){const c=r;e.setVector3("vRefractionPosition",c.boundingBoxPosition),e.setVector3("vRefractionSize",c.boundingBoxSize)}}getCode(e){const t="";return e.sharedData.blockingBlocks.push(this),e.sharedData.textureBlocks.push(this),this._cubeSamplerName=e._getFreeVariableName(this.name+"CubeSampler"),e.samplers.push(this._cubeSamplerName),this._2DSamplerName=e._getFreeVariableName(this.name+"2DSampler"),e.samplers.push(this._2DSamplerName),this._define3DName=e._getFreeDefineName("SS_REFRACTIONMAP_3D"),this._getTexture()&&(e._samplerDeclaration+=`#ifdef ${this._define3DName}
`,e._emitCubeSampler(this._cubeSamplerName,void 0,!0),e._samplerDeclaration+=`#else
`,e._emit2DSampler(this._2DSamplerName,void 0,!0),e._samplerDeclaration+=`#endif
`),e.sharedData.blocksWithDefines.push(this),e.sharedData.bindableBlocks.push(this),this._defineLODRefractionAlpha=e._getFreeDefineName("SS_LODINREFRACTIONALPHA"),this._defineLinearSpecularRefraction=e._getFreeDefineName("SS_LINEARSPECULARREFRACTION"),this._defineOppositeZ=e._getFreeDefineName("SS_REFRACTIONMAP_OPPOSITEZ"),this._refractionMatrixName=e._getFreeVariableName("refractionMatrix"),e._emitUniformFromString(this._refractionMatrixName,x.Matrix),e.shaderLanguage!==1&&(e._emitFunction("sampleRefraction",`
                #ifdef ${this._define3DName}
                    #define sampleRefraction(s, c) textureCube(s, c)
                #else
                    #define sampleRefraction(s, c) texture2D(s, c)
                #endif
`,`//${this.name}`),e._emitFunction("sampleRefractionLod",`
                #ifdef ${this._define3DName}
                    #define sampleRefractionLod(s, c, l) textureCubeLodEXT(s, c, l)
                #else
                    #define sampleRefractionLod(s, c, l) texture2DLodEXT(s, c, l)
                #endif
`,`//${this.name}`)),this._vRefractionMicrosurfaceInfosName=e._getFreeVariableName("vRefractionMicrosurfaceInfos"),e._emitUniformFromString(this._vRefractionMicrosurfaceInfosName,x.Vector4),this._vRefractionInfosName=e._getFreeVariableName("vRefractionInfos"),e._emitUniformFromString(this._vRefractionInfosName,x.Vector4),this._vRefractionFilteringInfoName=e._getFreeVariableName("vRefractionFilteringInfo"),e._emitUniformFromString(this._vRefractionFilteringInfoName,x.Vector2),e._emitUniformFromString("vRefractionPosition",x.Vector3),e._emitUniformFromString("vRefractionSize",x.Vector3),t}_buildBlock(e){return this._scene=e.sharedData.scene,this}_dumpPropertiesCode(){let e=super._dumpPropertiesCode();return this.texture&&(this.texture.isCube?e=`${this._codeVariableName}.texture = new BABYLON.CubeTexture("${this.texture.name}");
`:e=`${this._codeVariableName}.texture = new BABYLON.Texture("${this.texture.name}");
`,e+=`${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};
`),e+=`${this._codeVariableName}.linkRefractionWithTransparency = ${this.linkRefractionWithTransparency};
`,e+=`${this._codeVariableName}.invertRefractionY = ${this.invertRefractionY};
`,e+=`${this._codeVariableName}.useThicknessAsDepth = ${this.useThicknessAsDepth};
`,e}serialize(){const e=super.serialize();return this.texture&&!this.texture.isRenderTarget&&(e.texture=this.texture.serialize()),e.linkRefractionWithTransparency=this.linkRefractionWithTransparency,e.invertRefractionY=this.invertRefractionY,e.useThicknessAsDepth=this.useThicknessAsDepth,e}_deserialize(e,t,i){super._deserialize(e,t,i),e.texture&&(i=e.texture.url.indexOf("data:")===0?"":i,e.texture.isCube?this.texture=rn.Parse(e.texture,t,i):this.texture=Y.Parse(e.texture,t,i)),this.linkRefractionWithTransparency=e.linkRefractionWithTransparency,this.invertRefractionY=e.invertRefractionY,this.useThicknessAsDepth=!!e.useThicknessAsDepth}}C([U("Link refraction to transparency",0,"ADVANCED",{embedded:!0,notifiers:{update:!0}})],ta.prototype,"linkRefractionWithTransparency",void 0);C([U("Invert refraction Y",0,"ADVANCED",{embedded:!0,notifiers:{update:!0}})],ta.prototype,"invertRefractionY",void 0);C([U("Use thickness as depth",0,"ADVANCED",{embedded:!0,notifiers:{update:!0}})],ta.prototype,"useThicknessAsDepth",void 0);B("BABYLON.RefractionBlock",ta);class qo extends le{constructor(e){super(e,A.Fragment),this._isUnique=!0,this.registerInput("thickness",x.Float,!1,A.Fragment),this.registerInput("tintColor",x.Color3,!0,A.Fragment),this.registerInput("translucencyIntensity",x.Float,!0,A.Fragment),this.registerInput("translucencyDiffusionDist",x.Color3,!0,A.Fragment),this.registerInput("refraction",x.Object,!0,A.Fragment,new dt("refraction",this,0,ta,"RefractionBlock")),this.registerInput("dispersion",x.Float,!0,A.Fragment),this.registerOutput("subsurface",x.Object,A.Fragment,new dt("subsurface",this,1,qo,"SubSurfaceBlock"))}initialize(e){e._excludeVariableName("subSurfaceOut"),e._excludeVariableName("vThicknessParam"),e._excludeVariableName("vTintColor"),e._excludeVariableName("vTranslucencyColor"),e._excludeVariableName("vSubSurfaceIntensity"),e._excludeVariableName("dispersion")}getClassName(){return"SubSurfaceBlock"}get thickness(){return this._inputs[0]}get tintColor(){return this._inputs[1]}get translucencyIntensity(){return this._inputs[2]}get translucencyDiffusionDist(){return this._inputs[3]}get refraction(){return this._inputs[4]}get dispersion(){return this._inputs[5]}get subsurface(){return this._outputs[0]}autoConfigure(){if(!this.thickness.isConnected){const e=new Ee("SubSurface thickness",A.Fragment,x.Float);e.value=0,e.output.connectTo(this.thickness)}}prepareDefines(e,t,i){super.prepareDefines(e,t,i);const r=this.translucencyDiffusionDist.isConnected||this.translucencyIntensity.isConnected;i.setValue("SUBSURFACE",r||this.refraction.isConnected,!0),i.setValue("SS_TRANSLUCENCY",r,!0),i.setValue("SS_THICKNESSANDMASK_TEXTURE",!1,!0),i.setValue("SS_REFRACTIONINTENSITY_TEXTURE",!1,!0),i.setValue("SS_TRANSLUCENCYINTENSITY_TEXTURE",!1,!0),i.setValue("SS_USE_GLTF_TEXTURES",!1,!0),i.setValue("SS_DISPERSION",this.dispersion.isConnected,!0)}static GetCode(e,t,i,r){var _;let s="";const n=t!=null&&t.thickness.isConnected?t.thickness.associatedVariableName:"0.",o=t!=null&&t.tintColor.isConnected?t.tintColor.associatedVariableName:"vec3(1.)",l=t!=null&&t.translucencyIntensity.isConnected?t==null?void 0:t.translucencyIntensity.associatedVariableName:"1.",u=t!=null&&t.translucencyDiffusionDist.isConnected?t==null?void 0:t.translucencyDiffusionDist.associatedVariableName:"vec3(1.)",c=t!=null&&t.refraction.isConnected?(_=t==null?void 0:t.refraction.connectedPoint)==null?void 0:_.ownerBlock:null,h=c!=null&&c.tintAtDistance.isConnected?c.tintAtDistance.associatedVariableName:"1.",d=c!=null&&c.intensity.isConnected?c.intensity.associatedVariableName:"1.",f=c!=null&&c.view.isConnected?c.view.associatedVariableName:"",p=t!=null&&t.dispersion.isConnected?t==null?void 0:t.dispersion.associatedVariableName:"0.0",g=e.shaderLanguage===1;return s+=(c==null?void 0:c.getCode(e))??"",s+=`${g?"var subSurfaceOut: subSurfaceOutParams":"subSurfaceOutParams subSurfaceOut"};

        #ifdef SUBSURFACE
            ${e._declareLocalVar("vThicknessParam",x.Vector2)} = vec2${e.fSuffix}(0., ${n});
            ${e._declareLocalVar("vTintColor",x.Vector4)} = vec4${e.fSuffix}(${o}, ${h});
            ${e._declareLocalVar("vSubSurfaceIntensity",x.Vector3)} = vec3(${d}, ${l}, 0.);
            ${e._declareLocalVar("dispersion",x.Float)} = ${p};
            subSurfaceOut = subSurfaceBlock(
                vSubSurfaceIntensity
                , vThicknessParam
                , vTintColor
                , normalW
                , specularEnvironmentReflectance
            #ifdef SS_THICKNESSANDMASK_TEXTURE
                , vec4${e.fSuffix}(0.)
            #endif
            #ifdef REFLECTION
                #ifdef SS_TRANSLUCENCY
                    , ${(g?"uniforms.":"")+(i==null?void 0:i._reflectionMatrixName)}
                    #ifdef USESPHERICALFROMREFLECTIONMAP
                        #if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
                            , reflectionOut.irradianceVector
                        #endif
                        #if defined(REALTIME_FILTERING)
                            , ${i==null?void 0:i._cubeSamplerName}
                            ${g?`, ${i==null?void 0:i._cubeSamplerName}Sampler`:""}
                            , ${i==null?void 0:i._vReflectionFilteringInfoName}
                        #endif
                        #endif
                    #ifdef USEIRRADIANCEMAP
                        , irradianceSampler
                        ${g?", irradianceSamplerSampler":""}
                    #endif
                #endif
            #endif
            #if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)
                , surfaceAlbedo
            #endif
            #ifdef SS_REFRACTION
                , ${r}.xyz
                , viewDirectionW
                , ${f}
                , ${(g?"uniforms.":"")+((c==null?void 0:c._vRefractionInfosName)??"")}
                , ${(g?"uniforms.":"")+((c==null?void 0:c._refractionMatrixName)??"")}
                , ${(g?"uniforms.":"")+((c==null?void 0:c._vRefractionMicrosurfaceInfosName)??"")}
                , ${g?"uniforms.":""}vLightingIntensity
                #ifdef SS_LINKREFRACTIONTOTRANSPARENCY
                    , alpha
                #endif
                #ifdef ${(c==null?void 0:c._defineLODRefractionAlpha)??"IGNORE"}
                    , NdotVUnclamped
                #endif
                #ifdef ${(c==null?void 0:c._defineLinearSpecularRefraction)??"IGNORE"}
                    , roughness
                #endif
                , alphaG
                #ifdef ${(c==null?void 0:c._define3DName)??"IGNORE"}
                    , ${(c==null?void 0:c._cubeSamplerName)??""}
                    ${g?`, ${c==null?void 0:c._cubeSamplerName}Sampler`:""}
                #else
                    , ${(c==null?void 0:c._2DSamplerName)??""}
                    ${g?`, ${c==null?void 0:c._2DSamplerName}Sampler`:""}
                #endif
                #ifndef LODBASEDMICROSFURACE
                    #ifdef ${(c==null?void 0:c._define3DName)??"IGNORE"}
                        , ${(c==null?void 0:c._cubeSamplerName)??""}                        
                        ${g?`, ${c==null?void 0:c._cubeSamplerName}Sampler`:""}
                        , ${(c==null?void 0:c._cubeSamplerName)??""}                        
                        ${g?`, ${c==null?void 0:c._cubeSamplerName}Sampler`:""}
                    #else
                        , ${(c==null?void 0:c._2DSamplerName)??""}
                        ${g?`, ${c==null?void 0:c._2DSamplerName}Sampler`:""}
                        , ${(c==null?void 0:c._2DSamplerName)??""}
                        ${g?`, ${c==null?void 0:c._2DSamplerName}Sampler`:""}
                    #endif
                #endif
                #ifdef ANISOTROPIC
                    , anisotropicOut
                #endif
                #ifdef REALTIME_FILTERING
                    , ${(c==null?void 0:c._vRefractionFilteringInfoName)??""}
                #endif
                #ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
                    , vRefractionPosition
                    , vRefractionSize
                #endif
                #ifdef SS_DISPERSION
                    , dispersion
                #endif
            #endif
            #ifdef SS_TRANSLUCENCY
                , ${u}
                , vTintColor
                #ifdef SS_TRANSLUCENCYCOLOR_TEXTURE
                    , vec4${e.fSuffix}(0.)
                #endif
            #endif                
            );

            #ifdef SS_REFRACTION
                surfaceAlbedo = subSurfaceOut.surfaceAlbedo;
                #ifdef SS_LINKREFRACTIONTOTRANSPARENCY
                    alpha = subSurfaceOut.alpha;
                #endif
            #endif
        #else
            subSurfaceOut.specularEnvironmentReflectance = specularEnvironmentReflectance;
        #endif
`,s}_buildBlock(e){return e.target===A.Fragment&&e.sharedData.blocksWithDefines.push(this),this}}B("BABYLON.SubSurfaceBlock",qo);const m2={ambientClr:["finalAmbient",""],diffuseDir:["finalDiffuse",""],specularDir:["finalSpecularScaled","!defined(UNLIT) && defined(SPECULARTERM)"],clearcoatDir:["finalClearCoatScaled","!defined(UNLIT) && defined(CLEARCOAT)"],sheenDir:["finalSheenScaled","!defined(UNLIT) && defined(SHEEN)"],diffuseInd:["finalIrradiance","!defined(UNLIT) && defined(REFLECTION)"],specularInd:["finalRadianceScaled","!defined(UNLIT) && defined(REFLECTION)"],clearcoatInd:["clearcoatOut.finalClearCoatRadianceScaled","!defined(UNLIT) && defined(REFLECTION) && defined(CLEARCOAT)"],sheenInd:["sheenOut.finalSheenRadianceScaled","!defined(UNLIT) && defined(REFLECTION) && defined(SHEEN) && defined(ENVIRONMENTBRDF)"],refraction:["subSurfaceOut.finalRefraction","!defined(UNLIT) && defined(SS_REFRACTION)"],lighting:["finalColor.rgb",""],shadow:["aggShadow",""],alpha:["alpha",""]};class Wt extends le{static _OnGenerateOnlyFragmentCodeChanged(e,t){const i=e;return i.worldPosition.isConnected||i.worldNormal.isConnected?(i.generateOnlyFragmentCode=!i.generateOnlyFragmentCode,L.Error("The worldPosition and worldNormal inputs must not be connected to be able to switch!"),!1):(i._setTarget(),!0)}_setTarget(){this._setInitialTarget(this.generateOnlyFragmentCode?A.Fragment:A.VertexAndFragment),this.getInputByName("worldPosition").target=this.generateOnlyFragmentCode?A.Fragment:A.Vertex,this.getInputByName("worldNormal").target=this.generateOnlyFragmentCode?A.Fragment:A.Vertex}constructor(e){super(e,A.VertexAndFragment),this._environmentBRDFTexture=null,this._metallicReflectanceColor=ne.White(),this._metallicF0Factor=1,this.directIntensity=1,this.environmentIntensity=1,this.specularIntensity=1,this.lightFalloff=0,this.useAlphaTest=!1,this.alphaTestCutoff=.5,this.useAlphaBlending=!1,this.useRadianceOverAlpha=!0,this.useSpecularOverAlpha=!0,this.enableSpecularAntiAliasing=!1,this.realTimeFiltering=!1,this.realTimeFilteringQuality=8,this.useEnergyConservation=!0,this.useRadianceOcclusion=!0,this.useHorizonOcclusion=!0,this.unlit=!1,this.forceNormalForward=!1,this.generateOnlyFragmentCode=!1,this.debugMode=0,this.debugLimit=0,this.debugFactor=1,this._isUnique=!0,this.registerInput("worldPosition",x.Vector4,!1,A.Vertex),this.registerInput("worldNormal",x.Vector4,!1,A.Vertex),this.registerInput("view",x.Matrix,!1),this.registerInput("cameraPosition",x.Vector3,!1,A.Fragment),this.registerInput("perturbedNormal",x.Vector4,!0,A.Fragment),this.registerInput("baseColor",x.Color3,!0,A.Fragment),this.registerInput("metallic",x.Float,!1,A.Fragment),this.registerInput("roughness",x.Float,!1,A.Fragment),this.registerInput("ambientOcc",x.Float,!0,A.Fragment),this.registerInput("opacity",x.Float,!0,A.Fragment),this.registerInput("indexOfRefraction",x.Float,!0,A.Fragment),this.registerInput("ambientColor",x.Color3,!0,A.Fragment),this.registerInput("reflection",x.Object,!0,A.Fragment,new dt("reflection",this,0,ao,"ReflectionBlock")),this.registerInput("clearcoat",x.Object,!0,A.Fragment,new dt("clearcoat",this,0,Vn,"ClearCoatBlock")),this.registerInput("sheen",x.Object,!0,A.Fragment,new dt("sheen",this,0,no,"SheenBlock")),this.registerInput("subsurface",x.Object,!0,A.Fragment,new dt("subsurface",this,0,qo,"SubSurfaceBlock")),this.registerInput("anisotropy",x.Object,!0,A.Fragment,new dt("anisotropy",this,0,tc,"AnisotropyBlock")),this.registerInput("iridescence",x.Object,!0,A.Fragment,new dt("iridescence",this,0,Zo,"IridescenceBlock")),this.registerOutput("ambientClr",x.Color3,A.Fragment),this.registerOutput("diffuseDir",x.Color3,A.Fragment),this.registerOutput("specularDir",x.Color3,A.Fragment),this.registerOutput("clearcoatDir",x.Color3,A.Fragment),this.registerOutput("sheenDir",x.Color3,A.Fragment),this.registerOutput("diffuseInd",x.Color3,A.Fragment),this.registerOutput("specularInd",x.Color3,A.Fragment),this.registerOutput("clearcoatInd",x.Color3,A.Fragment),this.registerOutput("sheenInd",x.Color3,A.Fragment),this.registerOutput("refraction",x.Color3,A.Fragment),this.registerOutput("lighting",x.Color3,A.Fragment),this.registerOutput("shadow",x.Float,A.Fragment),this.registerOutput("alpha",x.Float,A.Fragment)}initialize(e){e._excludeVariableName("vLightingIntensity"),e._excludeVariableName("geometricNormalW"),e._excludeVariableName("normalW"),e._excludeVariableName("faceNormal"),e._excludeVariableName("albedoOpacityOut"),e._excludeVariableName("surfaceAlbedo"),e._excludeVariableName("alpha"),e._excludeVariableName("aoOut"),e._excludeVariableName("baseColor"),e._excludeVariableName("reflectivityOut"),e._excludeVariableName("microSurface"),e._excludeVariableName("roughness"),e._excludeVariableName("NdotVUnclamped"),e._excludeVariableName("NdotV"),e._excludeVariableName("alphaG"),e._excludeVariableName("AARoughnessFactors"),e._excludeVariableName("environmentBrdf"),e._excludeVariableName("ambientMonochrome"),e._excludeVariableName("seo"),e._excludeVariableName("eho"),e._excludeVariableName("environmentRadiance"),e._excludeVariableName("irradianceVector"),e._excludeVariableName("environmentIrradiance"),e._excludeVariableName("diffuseBase"),e._excludeVariableName("specularBase"),e._excludeVariableName("preInfo"),e._excludeVariableName("info"),e._excludeVariableName("shadow"),e._excludeVariableName("finalDiffuse"),e._excludeVariableName("finalAmbient"),e._excludeVariableName("ambientOcclusionForDirectDiffuse"),e._excludeVariableName("finalColor"),e._excludeVariableName("vClipSpacePosition"),e._excludeVariableName("vDebugMode"),this._initShaderSourceAsync(e.shaderLanguage)}async _initShaderSourceAsync(e){this._codeIsReady=!1,e===1?await Promise.all([k(()=>import("./pbr.vertex-C6clv1jW.js"),__vite__mapDeps([16,1,2,3,4,5,17,0,12,7])),k(()=>import("./pbr.fragment-jox_Wzt1.js"),__vite__mapDeps([18,1,2,3,4,5,8,17,12,7]))]):await Promise.all([k(()=>import("./pbr.vertex-C_PHP_eE.js"),__vite__mapDeps([19,1,2,3,4,5,6,20,15])),k(()=>import("./pbr.fragment-CxtSokwZ.js"),__vite__mapDeps([21,1,2,3,4,5,9,20,15]))]),this._codeIsReady=!0,this.onCodeIsReadyObservable.notifyObservers(this)}getClassName(){return"PBRMetallicRoughnessBlock"}get worldPosition(){return this._inputs[0]}get worldNormal(){return this._inputs[1]}get view(){return this._inputs[2]}get cameraPosition(){return this._inputs[3]}get perturbedNormal(){return this._inputs[4]}get baseColor(){return this._inputs[5]}get metallic(){return this._inputs[6]}get roughness(){return this._inputs[7]}get ambientOcc(){return this._inputs[8]}get opacity(){return this._inputs[9]}get indexOfRefraction(){return this._inputs[10]}get ambientColor(){return this._inputs[11]}get reflection(){return this._inputs[12]}get clearcoat(){return this._inputs[13]}get sheen(){return this._inputs[14]}get subsurface(){return this._inputs[15]}get anisotropy(){return this._inputs[16]}get iridescence(){return this._inputs[17]}get ambientClr(){return this._outputs[0]}get diffuseDir(){return this._outputs[1]}get specularDir(){return this._outputs[2]}get clearcoatDir(){return this._outputs[3]}get sheenDir(){return this._outputs[4]}get diffuseInd(){return this._outputs[5]}get specularInd(){return this._outputs[6]}get clearcoatInd(){return this._outputs[7]}get sheenInd(){return this._outputs[8]}get refraction(){return this._outputs[9]}get lighting(){return this._outputs[10]}get shadow(){return this._outputs[11]}get alpha(){return this._outputs[12]}autoConfigure(e,t=()=>!0){if(!this.cameraPosition.isConnected){let i=e.getInputBlockByPredicate(r=>r.systemValue===De.CameraPosition&&t(r));i||(i=new Ee("cameraPosition"),i.setAsSystemValue(De.CameraPosition)),i.output.connectTo(this.cameraPosition)}if(!this.view.isConnected){let i=e.getInputBlockByPredicate(r=>r.systemValue===De.View&&t(r));i||(i=new Ee("view"),i.setAsSystemValue(De.View)),i.output.connectTo(this.view)}}prepareDefines(e,t,i){i.setValue("PBR",!0),i.setValue("METALLICWORKFLOW",!0),i.setValue("DEBUGMODE",this.debugMode,!0),i.setValue("DEBUGMODE_FORCERETURN",!0),i.setValue("NORMALXYSCALE",!0),i.setValue("BUMP",this.perturbedNormal.isConnected,!0),i.setValue("LODBASEDMICROSFURACE",this._scene.getEngine().getCaps().textureLOD),i.setValue("ALBEDO",!1,!0),i.setValue("OPACITY",this.opacity.isConnected,!0),i.setValue("AMBIENT",!0,!0),i.setValue("AMBIENTINGRAYSCALE",!1,!0),i.setValue("REFLECTIVITY",!1,!0),i.setValue("AOSTOREINMETALMAPRED",!1,!0),i.setValue("METALLNESSSTOREINMETALMAPBLUE",!1,!0),i.setValue("ROUGHNESSSTOREINMETALMAPALPHA",!1,!0),i.setValue("ROUGHNESSSTOREINMETALMAPGREEN",!1,!0),this.lightFalloff===hr.LIGHTFALLOFF_STANDARD?(i.setValue("USEPHYSICALLIGHTFALLOFF",!1),i.setValue("USEGLTFLIGHTFALLOFF",!1)):this.lightFalloff===hr.LIGHTFALLOFF_GLTF?(i.setValue("USEPHYSICALLIGHTFALLOFF",!1),i.setValue("USEGLTFLIGHTFALLOFF",!0)):(i.setValue("USEPHYSICALLIGHTFALLOFF",!0),i.setValue("USEGLTFLIGHTFALLOFF",!1));const r=this.alphaTestCutoff.toString();i.setValue("ALPHABLEND",this.useAlphaBlending,!0),i.setValue("ALPHAFROMALBEDO",!1,!0),i.setValue("ALPHATEST",this.useAlphaTest,!0),i.setValue("ALPHATESTVALUE",r.indexOf(".")<0?r+".":r,!0),i.setValue("OPACITYRGB",!1,!0),i.setValue("RADIANCEOVERALPHA",this.useRadianceOverAlpha,!0),i.setValue("SPECULAROVERALPHA",this.useSpecularOverAlpha,!0),i.setValue("SPECULARAA",this._scene.getEngine().getCaps().standardDerivatives&&this.enableSpecularAntiAliasing,!0),i.setValue("REALTIME_FILTERING",this.realTimeFiltering,!0);const s=e.getScene();if(s.getEngine()._features.needTypeSuffixInShaderConstants?i.setValue("NUM_SAMPLES",this.realTimeFilteringQuality+"u",!0):i.setValue("NUM_SAMPLES",""+this.realTimeFilteringQuality,!0),i.setValue("BRDF_V_HEIGHT_CORRELATED",!0),i.setValue("MS_BRDF_ENERGY_CONSERVATION",this.useEnergyConservation,!0),i.setValue("RADIANCEOCCLUSION",this.useRadianceOcclusion,!0),i.setValue("HORIZONOCCLUSION",this.useHorizonOcclusion,!0),i.setValue("UNLIT",this.unlit,!0),i.setValue("FORCENORMALFORWARD",this.forceNormalForward,!0),this._environmentBRDFTexture&&vr.ReflectionTextureEnabled?(i.setValue("ENVIRONMENTBRDF",!0),i.setValue("ENVIRONMENTBRDF_RGBD",this._environmentBRDFTexture.isRGBD,!0)):(i.setValue("ENVIRONMENTBRDF",!1),i.setValue("ENVIRONMENTBRDF_RGBD",!1)),i._areImageProcessingDirty&&t.imageProcessingConfiguration&&t.imageProcessingConfiguration.prepareDefines(i),!!i._areLightsDirty)if(!this.light)mu(s,e,i,!0,t.maxSimultaneousLights),i._needNormals=!0,zm(s,i);else{const o={needNormals:!1,needRebuild:!1,lightmapMode:!1,shadowEnabled:!1,specularEnabled:!1};Wm(s,e,this.light,this._lightId,i,!0,o),o.needRebuild&&i.rebuild()}}updateUniformsAndSamples(e,t,i,r){for(let s=0;s<t.maxSimultaneousLights&&i["LIGHT"+s];s++){const n=e.uniforms.indexOf("vLightData"+s)>=0;$m(s,e.uniforms,e.samplers,i["PROJECTEDLIGHTTEXTURE"+s],r,n,i["IESLIGHTTEXTURE"+s])}}isReady(e,t,i){return!(this._environmentBRDFTexture&&!this._environmentBRDFTexture.isReady()||i._areImageProcessingDirty&&t.imageProcessingConfiguration&&!t.imageProcessingConfiguration.isReady())}bind(e,t,i){var h;if(!i)return;const r=i.getScene();this.light?Hm(this.light,this._lightId,r,e,!0):_u(r,i,e,!0,t.maxSimultaneousLights),e.setTexture(this._environmentBrdfSamplerName,this._environmentBRDFTexture),e.setFloat2("vDebugMode",this.debugLimit,this.debugFactor);const s=this._scene.ambientColor;s&&e.setColor3("ambientFromScene",s);const n=r.useRightHandedSystem===(r._mirroredCameraPosition!=null);e.setFloat(this._invertNormalName,n?-1:1),e.setFloat4("vLightingIntensity",this.directIntensity,1,this.environmentIntensity*this._scene.environmentIntensity,this.specularIntensity);const o=1,l=((h=this.indexOfRefraction.connectInputBlock)==null?void 0:h.value)??1.5,u=Math.pow((l-o)/(l+o),2);this._metallicReflectanceColor.scaleToRef(u*this._metallicF0Factor,_t.Color3[0]);const c=this._metallicF0Factor;e.setColor4(this._vMetallicReflectanceFactorsName,_t.Color3[0],c),t.imageProcessingConfiguration&&t.imageProcessingConfiguration.bind(e)}_injectVertexCode(e){var u;const t=this.worldPosition,i=this.worldNormal,r=`//${this.name}`,s=e.shaderLanguage===1;this.light?(this._lightId=(e.counters.lightCounter!==void 0?e.counters.lightCounter:-1)+1,e.counters.lightCounter=this._lightId,e._emitFunctionFromInclude(e.supportUniformBuffers?"lightVxUboDeclaration":"lightVxFragmentDeclaration",r,{replaceStrings:[{search:/{X}/g,replace:this._lightId.toString()}]},this._lightId.toString())):(e._emitFunctionFromInclude(e.supportUniformBuffers?"lightVxUboDeclaration":"lightVxFragmentDeclaration",r,{repeatKey:"maxSimultaneousLights"}),this._lightId=0,e.sharedData.dynamicUniformBlocks.push(this));const n="v_"+t.associatedVariableName;e._emitVaryingFromString(n,x.Vector4)&&(e.compilationString+=(s?"vertexOutputs.":"")+`${n} = ${t.associatedVariableName};
`);const o="v_"+i.associatedVariableName;e._emitVaryingFromString(o,x.Vector4)&&(e.compilationString+=(s?"vertexOutputs.":"")+`${o} = ${i.associatedVariableName};
`);const l=this.reflection.isConnected?(u=this.reflection.connectedPoint)==null?void 0:u.ownerBlock:null;l&&(l.viewConnectionPoint=this.view),e.compilationString+=(l==null?void 0:l.handleVertexSide(e))??"",e._emitVaryingFromString("vClipSpacePosition",x.Vector4,"defined(IGNORE) || DEBUGMODE > 0")&&(e._injectAtEnd+=`#if DEBUGMODE > 0
`,e._injectAtEnd+=(s?"vertexOutputs.":"")+`vClipSpacePosition = ${s?"vertexOutputs.position":"gl_Position"};
`,e._injectAtEnd+=`#endif
`),this.light?e.compilationString+=e._emitCodeFromInclude("shadowsVertex",r,{replaceStrings:[{search:/{X}/g,replace:this._lightId.toString()},{search:/worldPos/g,replace:t.associatedVariableName}]}):(e.compilationString+=`${e._declareLocalVar("worldPos",x.Vector4)} = ${t.associatedVariableName};
`,this.view.isConnected&&(e.compilationString+=`${e._declareLocalVar("view",x.Matrix)} = ${this.view.associatedVariableName};
`),e.compilationString+=e._emitCodeFromInclude("shadowsVertex",r,{repeatKey:"maxSimultaneousLights"}))}_getAlbedoOpacityCode(e){let i=e.shaderLanguage===1?`var albedoOpacityOut: albedoOpacityOutParams;
`:`albedoOpacityOutParams albedoOpacityOut;
`;const r=this.baseColor.isConnected?this.baseColor.associatedVariableName:"vec3(1.)",s=this.opacity.isConnected?this.opacity.associatedVariableName:"1.";return i+=`albedoOpacityOut = albedoOpacityBlock(
                vec4${e.fSuffix}(${r}, 1.)
            #ifdef ALBEDO
                ,vec4${e.fSuffix}(1.)
                ,vec2${e.fSuffix}(1., 1.)
            #endif
                ,1. /* Base Weight */
            #ifdef OPACITY
                ,vec4${e.fSuffix}(${s})
                ,vec2${e.fSuffix}(1., 1.)
            #endif
            );

            ${e._declareLocalVar("surfaceAlbedo",x.Vector3)} = albedoOpacityOut.surfaceAlbedo;
            ${e._declareLocalVar("alpha",x.Float)} = albedoOpacityOut.alpha;
`,i}_getAmbientOcclusionCode(e){let i=e.shaderLanguage===1?`var aoOut: ambientOcclusionOutParams;
`:`ambientOcclusionOutParams aoOut;
`;const r=this.ambientOcc.isConnected?this.ambientOcc.associatedVariableName:"1.";return i+=`aoOut = ambientOcclusionBlock(
            #ifdef AMBIENT
                vec3${e.fSuffix}(${r}),
                vec4${e.fSuffix}(0., 1.0, 1.0, 0.)
            #endif
            );
`,i}_getReflectivityCode(e){const t=e.shaderLanguage===1;let i=t?`var reflectivityOut: reflectivityOutParams;
`:`reflectivityOutParams reflectivityOut;
`;const r="1.";return this._vMetallicReflectanceFactorsName=e._getFreeVariableName("vMetallicReflectanceFactors"),e._emitUniformFromString(this._vMetallicReflectanceFactorsName,x.Vector4),i+=`${e._declareLocalVar("baseColor",x.Vector3)} = surfaceAlbedo;

            reflectivityOut = reflectivityBlock(
                vec4${e.fSuffix}(${this.metallic.associatedVariableName}, ${this.roughness.associatedVariableName}, 0., 0.)
            #ifdef METALLICWORKFLOW
                , surfaceAlbedo
                , ${(t?"uniforms.":"")+this._vMetallicReflectanceFactorsName}
            #endif
            #ifdef REFLECTIVITY
                , vec3${e.fSuffix}(0., 0., ${r})
                , vec4${e.fSuffix}(1.)
            #endif
            #if defined(METALLICWORKFLOW) && defined(REFLECTIVITY)  && defined(AOSTOREINMETALMAPRED)
                , aoOut.ambientOcclusionColor
            #endif
            #ifdef MICROSURFACEMAP
                , microSurfaceTexel <== not handled!
            #endif
            );

            ${e._declareLocalVar("microSurface",x.Float)} = reflectivityOut.microSurface;
            ${e._declareLocalVar("roughness",x.Float)} = reflectivityOut.roughness;

            #ifdef METALLICWORKFLOW
                surfaceAlbedo = reflectivityOut.surfaceAlbedo;
            #endif
            #if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
                aoOut.ambientOcclusionColor = reflectivityOut.ambientOcclusionColor;
            #endif
`,i}_buildBlock(e){var E,R,O,w,M,G,H,q,X,ee,oe;super._buildBlock(e),this._scene=e.sharedData.scene;const t=e.shaderLanguage===1;this._environmentBRDFTexture||(this._environmentBRDFTexture=TM(this._scene));const i=this.reflection.isConnected?(E=this.reflection.connectedPoint)==null?void 0:E.ownerBlock:null;if(i&&(i.worldPositionConnectionPoint=this.worldPosition,i.cameraPositionConnectionPoint=this.cameraPosition,i.worldNormalConnectionPoint=this.worldNormal,i.viewConnectionPoint=this.view),e.target!==A.Fragment)return this._injectVertexCode(e),this;e.sharedData.forcedBindableBlocks.push(this),e.sharedData.blocksWithDefines.push(this),e.sharedData.blockingBlocks.push(this),this.generateOnlyFragmentCode&&e.sharedData.dynamicUniformBlocks.push(this);const r=`//${this.name}`,s=this.perturbedNormal;let n=this.worldPosition.associatedVariableName,o=this.worldNormal.associatedVariableName;this.generateOnlyFragmentCode?(n=e._getFreeVariableName("globalWorldPos"),e._emitFunction("pbr_globalworldpos",t?`var<private> ${n}:vec3${e.fSuffix};
`:`vec3${e.fSuffix} ${n};
`,r),e.compilationString+=`${n} = ${this.worldPosition.associatedVariableName}.xyz;
`,o=e._getFreeVariableName("globalWorldNormal"),e._emitFunction("pbr_globalworldnorm",t?`var<private> ${o}:vec4${e.fSuffix};
`:`vec4${e.fSuffix} ${o};
`,r),e.compilationString+=`${o} = ${this.worldNormal.associatedVariableName};
`,e.compilationString+=e._emitCodeFromInclude("shadowsVertex",r,{repeatKey:"maxSimultaneousLights",substitutionVars:this.generateOnlyFragmentCode?`worldPos,${this.worldPosition.associatedVariableName}`:void 0}),e.compilationString+=`#if DEBUGMODE > 0
`,e.compilationString+=`${e._declareLocalVar("vClipSpacePosition",x.Vector4)} = vec4${e.fSuffix}((vec2${e.fSuffix}(${t?"fragmentInputs.position":"gl_FragCoord.xy"}) / vec2${e.fSuffix}(1.0)) * 2.0 - 1.0, 0.0, 1.0);
`,e.compilationString+=`#endif
`):(n=(t?"input.":"")+"v_"+n,o=(t?"input.":"")+"v_"+o),this._environmentBrdfSamplerName=e._getFreeVariableName("environmentBrdfSampler"),e._emit2DSampler(this._environmentBrdfSamplerName),e.sharedData.hints.needAlphaBlending=e.sharedData.hints.needAlphaBlending||this.useAlphaBlending,e.sharedData.hints.needAlphaTesting=e.sharedData.hints.needAlphaTesting||this.useAlphaTest,e._emitExtension("lod","#extension GL_EXT_shader_texture_lod : enable","defined(LODBASEDMICROSFURACE)"),e._emitExtension("derivatives","#extension GL_OES_standard_derivatives : enable"),e._emitUniformFromString("vDebugMode",x.Vector2,"defined(IGNORE) || DEBUGMODE > 0"),e._emitUniformFromString("ambientFromScene",x.Vector3),e.uniforms.push("exposureLinear"),e.uniforms.push("contrast"),e.uniforms.push("vInverseScreenSize"),e.uniforms.push("vignetteSettings1"),e.uniforms.push("vignetteSettings2"),e.uniforms.push("vCameraColorCurveNegative"),e.uniforms.push("vCameraColorCurveNeutral"),e.uniforms.push("vCameraColorCurvePositive"),e.uniforms.push("txColorTransform"),e.uniforms.push("colorTransformSettings"),e.uniforms.push("ditherIntensity"),this.light?e._emitFunctionFromInclude(e.supportUniformBuffers?"lightUboDeclaration":"lightFragmentDeclaration",r,{replaceStrings:[{search:/{X}/g,replace:this._lightId.toString()}]},this._lightId.toString()):e._emitFunctionFromInclude(e.supportUniformBuffers?"lightUboDeclaration":"lightFragmentDeclaration",r,{repeatKey:"maxSimultaneousLights",substitutionVars:this.generateOnlyFragmentCode?"varying,":void 0}),e._emitFunctionFromInclude("helperFunctions",r),e._emitFunctionFromInclude("importanceSampling",r),e._emitFunctionFromInclude("pbrHelperFunctions",r),e._emitFunctionFromInclude("imageProcessingDeclaration",r),e._emitFunctionFromInclude("imageProcessingFunctions",r),e._emitFunctionFromInclude("shadowsFragmentFunctions",r),e._emitFunctionFromInclude("pbrDirectLightingSetupFunctions",r),e._emitFunctionFromInclude("pbrDirectLightingFalloffFunctions",r),e._emitFunctionFromInclude("pbrBRDFFunctions",r,{replaceStrings:[{search:/REFLECTIONMAP_SKYBOX/g,replace:(i==null?void 0:i._defineSkyboxName)??"REFLECTIONMAP_SKYBOX"}]}),e._emitFunctionFromInclude("hdrFilteringFunctions",r),e._emitFunctionFromInclude("pbrDirectLightingFunctions",r),e._emitFunctionFromInclude("pbrIBLFunctions",r),e._emitFunctionFromInclude("pbrBlockAlbedoOpacity",r),e._emitFunctionFromInclude("pbrBlockReflectivity",r),e._emitFunctionFromInclude("pbrBlockAmbientOcclusion",r),e._emitFunctionFromInclude("pbrBlockAlphaFresnel",r),e._emitFunctionFromInclude("pbrBlockAnisotropic",r),e._emitUniformFromString("vLightingIntensity",x.Vector4),i!=null&&i.generateOnlyFragmentCode&&(e.compilationString+=i.handleVertexSide(e)),this._vNormalWName=e._getFreeVariableName("vNormalW"),e.compilationString+=`${e._declareLocalVar(this._vNormalWName,x.Vector4)} = normalize(${o});
`,e._registerTempVariable("viewDirectionW")&&(e.compilationString+=`${e._declareLocalVar("viewDirectionW",x.Vector3)} = normalize(${this.cameraPosition.associatedVariableName} - ${n}.xyz);
`),e.compilationString+=`${e._declareLocalVar("geometricNormalW",x.Vector3)} = ${this._vNormalWName}.xyz;
`,e.compilationString+=`${e._declareLocalVar("normalW",x.Vector3)} = ${s.isConnected?"normalize("+s.associatedVariableName+".xyz)":"geometricNormalW"};
`,this._invertNormalName=e._getFreeVariableName("invertNormal"),e._emitUniformFromString(this._invertNormalName,x.Float),e.compilationString+=e._emitCodeFromInclude("pbrBlockNormalFinal",r,{replaceStrings:[{search:/vPositionW/g,replace:n+".xyz"},{search:/vEyePosition.w/g,replace:this._invertNormalName}]}),e.compilationString+=this._getAlbedoOpacityCode(e),e.compilationString+=e._emitCodeFromInclude("depthPrePass",r),e.compilationString+=this._getAmbientOcclusionCode(e),e.compilationString+=e._emitCodeFromInclude("pbrBlockLightmapInit",r),e.compilationString+=`#ifdef UNLIT
                ${e._declareLocalVar("diffuseBase",x.Vector3)} = vec3${e.fSuffix}(1., 1., 1.);
            #else
`,e.compilationString+=this._getReflectivityCode(e),e.compilationString+=e._emitCodeFromInclude("pbrBlockGeometryInfo",r,{replaceStrings:[{search:/REFLECTIONMAP_SKYBOX/g,replace:(i==null?void 0:i._defineSkyboxName)??"REFLECTIONMAP_SKYBOX"},{search:/REFLECTIONMAP_3D/g,replace:(i==null?void 0:i._define3DName)??"REFLECTIONMAP_3D"}]});const l=this.anisotropy.isConnected?(R=this.anisotropy.connectedPoint)==null?void 0:R.ownerBlock:null;l&&(l.worldPositionConnectionPoint=this.worldPosition,l.worldNormalConnectionPoint=this.worldNormal,e.compilationString+=l.getCode(e,!this.perturbedNormal.isConnected)),i&&i.hasTexture&&(e.compilationString+=i.getCode(e,l?"anisotropicOut.anisotropicNormal":"normalW")),e._emitFunctionFromInclude("pbrBlockReflection",r,{replaceStrings:[{search:/computeReflectionCoords/g,replace:"computeReflectionCoordsPBR"},{search:/REFLECTIONMAP_3D/g,replace:(i==null?void 0:i._define3DName)??"REFLECTIONMAP_3D"},{search:/REFLECTIONMAP_OPPOSITEZ/g,replace:(i==null?void 0:i._defineOppositeZ)??"REFLECTIONMAP_OPPOSITEZ"},{search:/REFLECTIONMAP_PROJECTION/g,replace:(i==null?void 0:i._defineProjectionName)??"REFLECTIONMAP_PROJECTION"},{search:/REFLECTIONMAP_SKYBOX/g,replace:(i==null?void 0:i._defineSkyboxName)??"REFLECTIONMAP_SKYBOX"},{search:/LODINREFLECTIONALPHA/g,replace:(i==null?void 0:i._defineLODReflectionAlpha)??"LODINREFLECTIONALPHA"},{search:/LINEARSPECULARREFLECTION/g,replace:(i==null?void 0:i._defineLinearSpecularReflection)??"LINEARSPECULARREFLECTION"},{search:/vReflectionFilteringInfo/g,replace:(i==null?void 0:i._vReflectionFilteringInfoName)??"vReflectionFilteringInfo"}]}),e.compilationString+=e._emitCodeFromInclude("pbrBlockReflectance0",r,{replaceStrings:[{search:/metallicReflectanceFactors/g,replace:(t?"uniforms.":"")+this._vMetallicReflectanceFactorsName}]});const u=this.sheen.isConnected?(O=this.sheen.connectedPoint)==null?void 0:O.ownerBlock:null;u&&(e.compilationString+=u.getCode(i,e)),e._emitFunctionFromInclude("pbrBlockSheen",r,{replaceStrings:[{search:/REFLECTIONMAP_3D/g,replace:(i==null?void 0:i._define3DName)??"REFLECTIONMAP_3D"},{search:/REFLECTIONMAP_SKYBOX/g,replace:(i==null?void 0:i._defineSkyboxName)??"REFLECTIONMAP_SKYBOX"},{search:/LODINREFLECTIONALPHA/g,replace:(i==null?void 0:i._defineLODReflectionAlpha)??"LODINREFLECTIONALPHA"},{search:/LINEARSPECULARREFLECTION/g,replace:(i==null?void 0:i._defineLinearSpecularReflection)??"LINEARSPECULARREFLECTION"}]});const c=this.clearcoat.isConnected?(w=this.clearcoat.connectedPoint)==null?void 0:w.ownerBlock:null;e.compilationString+=Vn._GetInitializationCode(e,c);const h=this.iridescence.isConnected?(M=this.iridescence.connectedPoint)==null?void 0:M.ownerBlock:null;e.compilationString+=Zo.GetCode(h,e),e._emitFunctionFromInclude("pbrBlockIridescence",r,{replaceStrings:[]});const d=!this.perturbedNormal.isConnected&&!this.anisotropy.isConnected,f=this.perturbedNormal.isConnected&&((H=((G=this.perturbedNormal.connectedPoint)==null?void 0:G.ownerBlock).worldTangent)==null?void 0:H.isConnected),p=this.anisotropy.isConnected&&((q=this.anisotropy.connectedPoint)==null?void 0:q.ownerBlock).worldTangent.isConnected;let g=f||!this.perturbedNormal.isConnected&&p;e.compilationString+=Vn.GetCode(e,c,i,n,d,g,o),d&&(g=(c==null?void 0:c.worldTangent.isConnected)??!1),e._emitFunctionFromInclude("pbrBlockClearcoat",r,{replaceStrings:[{search:/computeReflectionCoords/g,replace:"computeReflectionCoordsPBR"},{search:/REFLECTIONMAP_3D/g,replace:(i==null?void 0:i._define3DName)??"REFLECTIONMAP_3D"},{search:/REFLECTIONMAP_OPPOSITEZ/g,replace:(i==null?void 0:i._defineOppositeZ)??"REFLECTIONMAP_OPPOSITEZ"},{search:/REFLECTIONMAP_PROJECTION/g,replace:(i==null?void 0:i._defineProjectionName)??"REFLECTIONMAP_PROJECTION"},{search:/REFLECTIONMAP_SKYBOX/g,replace:(i==null?void 0:i._defineSkyboxName)??"REFLECTIONMAP_SKYBOX"},{search:/LODINREFLECTIONALPHA/g,replace:(i==null?void 0:i._defineLODReflectionAlpha)??"LODINREFLECTIONALPHA"},{search:/LINEARSPECULARREFLECTION/g,replace:(i==null?void 0:i._defineLinearSpecularReflection)??"LINEARSPECULARREFLECTION"},{search:/defined\(TANGENT\)/g,replace:g?"defined(TANGENT)":"defined(IGNORE)"}]}),e.compilationString+=e._emitCodeFromInclude("pbrBlockReflectance",r,{replaceStrings:[{search:/REFLECTIONMAP_SKYBOX/g,replace:(i==null?void 0:i._defineSkyboxName)??"REFLECTIONMAP_SKYBOX"},{search:/REFLECTIONMAP_3D/g,replace:(i==null?void 0:i._define3DName)??"REFLECTIONMAP_3D"}]});const _=this.subsurface.isConnected?(X=this.subsurface.connectedPoint)==null?void 0:X.ownerBlock:null,S=this.subsurface.isConnected?(oe=((ee=this.subsurface.connectedPoint)==null?void 0:ee.ownerBlock).refraction.connectedPoint)==null?void 0:oe.ownerBlock:null;S&&(S.viewConnectionPoint=this.view,S.indexOfRefractionConnectionPoint=this.indexOfRefraction),e.compilationString+=qo.GetCode(e,_,i,n),e._emitFunctionFromInclude("pbrBlockSubSurface",r,{replaceStrings:[{search:/REFLECTIONMAP_3D/g,replace:(i==null?void 0:i._define3DName)??"REFLECTIONMAP_3D"},{search:/REFLECTIONMAP_OPPOSITEZ/g,replace:(i==null?void 0:i._defineOppositeZ)??"REFLECTIONMAP_OPPOSITEZ"},{search:/REFLECTIONMAP_PROJECTION/g,replace:(i==null?void 0:i._defineProjectionName)??"REFLECTIONMAP_PROJECTION"},{search:/SS_REFRACTIONMAP_3D/g,replace:(S==null?void 0:S._define3DName)??"SS_REFRACTIONMAP_3D"},{search:/SS_LODINREFRACTIONALPHA/g,replace:(S==null?void 0:S._defineLODRefractionAlpha)??"SS_LODINREFRACTIONALPHA"},{search:/SS_LINEARSPECULARREFRACTION/g,replace:(S==null?void 0:S._defineLinearSpecularRefraction)??"SS_LINEARSPECULARREFRACTION"},{search:/SS_REFRACTIONMAP_OPPOSITEZ/g,replace:(S==null?void 0:S._defineOppositeZ)??"SS_REFRACTIONMAP_OPPOSITEZ"}]}),e.compilationString+=e._emitCodeFromInclude("pbrBlockDirectLighting",r),this.light?e.compilationString+=e._emitCodeFromInclude("lightFragment",r,{replaceStrings:[{search:/{X}/g,replace:this._lightId.toString()},{search:new RegExp(`${t?"fragmentInputs.":""}vPositionW`,"g"),replace:n+".xyz"}]}):e.compilationString+=e._emitCodeFromInclude("lightFragment",r,{repeatKey:"maxSimultaneousLights",substitutionVars:`${t?"fragmentInputs.":""}vPositionW,${n}.xyz`}),e.compilationString+=e._emitCodeFromInclude("pbrBlockFinalLitComponents",r),e.compilationString+=`#endif
`;const b=this.ambientColor.isConnected?this.ambientColor.associatedVariableName:`vec3${e.fSuffix}(0., 0., 0.)`;let y=hr.DEFAULT_AO_ON_ANALYTICAL_LIGHTS.toString();y.indexOf(".")===-1&&(y+=".");let T=[{search:/vec3 finalEmissive[\s\S]*?finalEmissive\*=vLightingIntensity\.y;/g,replace:""},{search:new RegExp(`${t?"uniforms.":""}vAmbientColor`,"g"),replace:b+` * ${t?"uniforms.":""}ambientFromScene`},{search:new RegExp(`${t?"uniforms.":""}vAmbientInfos.w`,"g"),replace:y}];t&&(T[0]={search:/var finalEmissive[\s\S]*?finalEmissive\*=uniforms.vLightingIntensity\.y;/g,replace:""}),e.compilationString+=e._emitCodeFromInclude("pbrBlockFinalUnlitComponents",r,{replaceStrings:T}),e.compilationString+=e._emitCodeFromInclude("pbrBlockFinalColorComposition",r,{replaceStrings:[{search:/finalEmissive/g,replace:`vec3${e.fSuffix}(0.)`}]}),t?T=[{search:/mesh.visibility/g,replace:"1."}]:T=[{search:/visibility/g,replace:"1."}],e.compilationString+=e._emitCodeFromInclude("pbrBlockImageProcessing",r,{replaceStrings:T});const v=t?"fragmentOutputs.color":"gl_FragColor";T=[{search:new RegExp(`${t?"fragmentInputs.":""}vNormalW`,"g"),replace:this._vNormalWName},{search:new RegExp(`${t?"fragmentInputs.":""}vPositionW`,"g"),replace:n},{search:/albedoTexture\.rgb;/g,replace:`vec3${e.fSuffix}(1.);
${v}.rgb = toGammaSpace(${v}.rgb);
`}],e.compilationString+=e._emitCodeFromInclude("pbrDebug",r,{replaceStrings:T});for(const _e of this._outputs)if(_e.hasEndpoints){const te=m2[_e.name];if(te){const[ie,Z]=te;Z&&(e.compilationString+=`#if ${Z}
`),e.compilationString+=`${e._declareOutput(_e)} = ${ie};
`,Z&&(e.compilationString+=`#else
`,e.compilationString+=`${e._declareOutput(_e)} = vec3${e.fSuffix}(0.);
`,e.compilationString+=`#endif
`)}else L.Error(`There's no remapping for the ${_e.name} end point! No code generated`)}return this}_dumpPropertiesCode(){let e=super._dumpPropertiesCode();return e+=`${this._codeVariableName}.lightFalloff = ${this.lightFalloff};
`,e+=`${this._codeVariableName}.useAlphaTest = ${this.useAlphaTest};
`,e+=`${this._codeVariableName}.alphaTestCutoff = ${this.alphaTestCutoff};
`,e+=`${this._codeVariableName}.useAlphaBlending = ${this.useAlphaBlending};
`,e+=`${this._codeVariableName}.useRadianceOverAlpha = ${this.useRadianceOverAlpha};
`,e+=`${this._codeVariableName}.useSpecularOverAlpha = ${this.useSpecularOverAlpha};
`,e+=`${this._codeVariableName}.enableSpecularAntiAliasing = ${this.enableSpecularAntiAliasing};
`,e+=`${this._codeVariableName}.realTimeFiltering = ${this.realTimeFiltering};
`,e+=`${this._codeVariableName}.realTimeFilteringQuality = ${this.realTimeFilteringQuality};
`,e+=`${this._codeVariableName}.useEnergyConservation = ${this.useEnergyConservation};
`,e+=`${this._codeVariableName}.useRadianceOcclusion = ${this.useRadianceOcclusion};
`,e+=`${this._codeVariableName}.useHorizonOcclusion = ${this.useHorizonOcclusion};
`,e+=`${this._codeVariableName}.unlit = ${this.unlit};
`,e+=`${this._codeVariableName}.forceNormalForward = ${this.forceNormalForward};
`,e+=`${this._codeVariableName}.debugMode = ${this.debugMode};
`,e+=`${this._codeVariableName}.debugLimit = ${this.debugLimit};
`,e+=`${this._codeVariableName}.debugFactor = ${this.debugFactor};
`,e}serialize(){const e=super.serialize();return this.light&&(e.lightId=this.light.id),e.lightFalloff=this.lightFalloff,e.useAlphaTest=this.useAlphaTest,e.alphaTestCutoff=this.alphaTestCutoff,e.useAlphaBlending=this.useAlphaBlending,e.useRadianceOverAlpha=this.useRadianceOverAlpha,e.useSpecularOverAlpha=this.useSpecularOverAlpha,e.enableSpecularAntiAliasing=this.enableSpecularAntiAliasing,e.realTimeFiltering=this.realTimeFiltering,e.realTimeFilteringQuality=this.realTimeFilteringQuality,e.useEnergyConservation=this.useEnergyConservation,e.useRadianceOcclusion=this.useRadianceOcclusion,e.useHorizonOcclusion=this.useHorizonOcclusion,e.unlit=this.unlit,e.forceNormalForward=this.forceNormalForward,e.debugMode=this.debugMode,e.debugLimit=this.debugLimit,e.debugFactor=this.debugFactor,e.generateOnlyFragmentCode=this.generateOnlyFragmentCode,e}_deserialize(e,t,i){super._deserialize(e,t,i),e.lightId&&(this.light=t.getLightById(e.lightId)),this.lightFalloff=e.lightFalloff??0,this.useAlphaTest=e.useAlphaTest,this.alphaTestCutoff=e.alphaTestCutoff,this.useAlphaBlending=e.useAlphaBlending,this.useRadianceOverAlpha=e.useRadianceOverAlpha,this.useSpecularOverAlpha=e.useSpecularOverAlpha,this.enableSpecularAntiAliasing=e.enableSpecularAntiAliasing,this.realTimeFiltering=!!e.realTimeFiltering,this.realTimeFilteringQuality=e.realTimeFilteringQuality??8,this.useEnergyConservation=e.useEnergyConservation,this.useRadianceOcclusion=e.useRadianceOcclusion,this.useHorizonOcclusion=e.useHorizonOcclusion,this.unlit=e.unlit,this.forceNormalForward=!!e.forceNormalForward,this.debugMode=e.debugMode,this.debugLimit=e.debugLimit,this.debugFactor=e.debugFactor,this.generateOnlyFragmentCode=!!e.generateOnlyFragmentCode,this._setTarget()}}C([U("Direct lights",1,"INTENSITY",{min:0,max:1,notifiers:{update:!0}})],Wt.prototype,"directIntensity",void 0);C([U("Environment lights",1,"INTENSITY",{min:0,max:1,notifiers:{update:!0}})],Wt.prototype,"environmentIntensity",void 0);C([U("Specular highlights",1,"INTENSITY",{min:0,max:1,notifiers:{update:!0}})],Wt.prototype,"specularIntensity",void 0);C([U("Light falloff",4,"LIGHTING & COLORS",{notifiers:{update:!0},options:[{label:"Physical",value:hr.LIGHTFALLOFF_PHYSICAL},{label:"GLTF",value:hr.LIGHTFALLOFF_GLTF},{label:"Standard",value:hr.LIGHTFALLOFF_STANDARD}]})],Wt.prototype,"lightFalloff",void 0);C([U("Alpha Testing",0,"OPACITY")],Wt.prototype,"useAlphaTest",void 0);C([U("Alpha CutOff",1,"OPACITY",{min:0,max:1,notifiers:{update:!0}})],Wt.prototype,"alphaTestCutoff",void 0);C([U("Alpha blending",0,"OPACITY")],Wt.prototype,"useAlphaBlending",void 0);C([U("Radiance over alpha",0,"RENDERING",{notifiers:{update:!0}})],Wt.prototype,"useRadianceOverAlpha",void 0);C([U("Specular over alpha",0,"RENDERING",{notifiers:{update:!0}})],Wt.prototype,"useSpecularOverAlpha",void 0);C([U("Specular anti-aliasing",0,"RENDERING",{notifiers:{update:!0}})],Wt.prototype,"enableSpecularAntiAliasing",void 0);C([U("Realtime filtering",0,"RENDERING",{notifiers:{update:!0}})],Wt.prototype,"realTimeFiltering",void 0);C([U("Realtime filtering quality",4,"RENDERING",{notifiers:{update:!0},options:[{label:"Low",value:8},{label:"Medium",value:16},{label:"High",value:64}]})],Wt.prototype,"realTimeFilteringQuality",void 0);C([U("Energy Conservation",0,"ADVANCED",{notifiers:{update:!0}})],Wt.prototype,"useEnergyConservation",void 0);C([U("Radiance occlusion",0,"ADVANCED",{notifiers:{update:!0}})],Wt.prototype,"useRadianceOcclusion",void 0);C([U("Horizon occlusion",0,"ADVANCED",{notifiers:{update:!0}})],Wt.prototype,"useHorizonOcclusion",void 0);C([U("Unlit",0,"ADVANCED",{notifiers:{update:!0}})],Wt.prototype,"unlit",void 0);C([U("Force normal forward",0,"ADVANCED",{notifiers:{update:!0}})],Wt.prototype,"forceNormalForward",void 0);C([U("Generate only fragment code",0,"ADVANCED",{notifiers:{rebuild:!0,update:!0,onValidation:Wt._OnGenerateOnlyFragmentCodeChanged}})],Wt.prototype,"generateOnlyFragmentCode",void 0);C([U("Debug mode",4,"DEBUG",{notifiers:{update:!0},options:[{label:"None",value:0},{label:"Normalized position",value:1},{label:"Normals",value:2},{label:"Tangents",value:3},{label:"Bitangents",value:4},{label:"Bump Normals",value:5},{label:"ClearCoat Normals",value:8},{label:"ClearCoat Tangents",value:9},{label:"ClearCoat Bitangents",value:10},{label:"Anisotropic Normals",value:11},{label:"Anisotropic Tangents",value:12},{label:"Anisotropic Bitangents",value:13},{label:"Env Refraction",value:40},{label:"Env Reflection",value:41},{label:"Env Clear Coat",value:42},{label:"Direct Diffuse",value:50},{label:"Direct Specular",value:51},{label:"Direct Clear Coat",value:52},{label:"Direct Sheen",value:53},{label:"Env Irradiance",value:54},{label:"Surface Albedo",value:60},{label:"Reflectance 0",value:61},{label:"Metallic",value:62},{label:"Metallic F0",value:71},{label:"Roughness",value:63},{label:"AlphaG",value:64},{label:"NdotV",value:65},{label:"ClearCoat Color",value:66},{label:"ClearCoat Roughness",value:67},{label:"ClearCoat NdotV",value:68},{label:"Transmittance",value:69},{label:"Refraction Transmittance",value:70},{label:"SEO",value:80},{label:"EHO",value:81},{label:"Energy Factor",value:82},{label:"Specular Reflectance",value:83},{label:"Clear Coat Reflectance",value:84},{label:"Sheen Reflectance",value:85},{label:"Luminance Over Alpha",value:86},{label:"Alpha",value:87},{label:"Albedo color",value:88},{label:"Ambient occlusion color",value:89}]})],Wt.prototype,"debugMode",void 0);C([U("Split position",1,"DEBUG",{min:-1,max:1,notifiers:{update:!0}})],Wt.prototype,"debugLimit",void 0);C([U("Output factor",1,"DEBUG",{min:0,max:5,notifiers:{update:!0}})],Wt.prototype,"debugFactor",void 0);B("BABYLON.PBRMetallicRoughnessBlock",Wt);class _2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("left",x.AutoDetect),this.registerInput("right",x.AutoDetect),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._linkConnectionTypes(0,1),this._inputs[1].acceptedConnectionPointTypes.push(x.Float)}getClassName(){return"ModBlock"}get left(){return this._inputs[0]}get right(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];return e.shaderLanguage===0?e.compilationString+=e._declareOutput(t)+` = mod(${this.left.associatedVariableName}, ${this.right.associatedVariableName});
`:e.compilationString+=e._declareOutput(t)+` = (${this.left.associatedVariableName} % ${this.right.associatedVariableName});
`,this}}B("BABYLON.ModBlock",_2);class g2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("row0",x.Vector4),this.registerInput("row1",x.Vector4),this.registerInput("row2",x.Vector4),this.registerInput("row3",x.Vector4),this.registerOutput("output",x.Matrix)}getClassName(){return"MatrixBuilder"}get row0(){return this._inputs[0]}get row1(){return this._inputs[1]}get row2(){return this._inputs[2]}get row3(){return this._inputs[3]}get output(){return this._outputs[0]}autoConfigure(){if(!this.row0.isConnected){const e=new Ee("row0");e.value=new Ve(1,0,0,0),e.output.connectTo(this.row0)}if(!this.row1.isConnected){const e=new Ee("row1");e.value=new Ve(0,1,0,0),e.output.connectTo(this.row1)}if(!this.row2.isConnected){const e=new Ee("row2");e.value=new Ve(0,0,1,0),e.output.connectTo(this.row2)}if(!this.row3.isConnected){const e=new Ee("row3");e.value=new Ve(0,0,0,1),e.output.connectTo(this.row3)}}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0],i=this.row0,r=this.row1,s=this.row2,n=this.row3,o=e.shaderLanguage===1?"mat4x4f":"mat4";return e.compilationString+=e._declareOutput(t)+` = ${o}(${i.associatedVariableName}, ${r.associatedVariableName}, ${s.associatedVariableName}, ${n.associatedVariableName});
`,this}}B("BABYLON.MatrixBuilder",g2);var Ht;(function(a){a[a.Equal=0]="Equal",a[a.NotEqual=1]="NotEqual",a[a.LessThan=2]="LessThan",a[a.GreaterThan=3]="GreaterThan",a[a.LessOrEqual=4]="LessOrEqual",a[a.GreaterOrEqual=5]="GreaterOrEqual",a[a.Xor=6]="Xor",a[a.Or=7]="Or",a[a.And=8]="And"})(Ht||(Ht={}));class iC extends le{constructor(e){super(e,A.Neutral),this.condition=Ht.LessThan,this.registerInput("a",x.Float),this.registerInput("b",x.Float),this.registerInput("true",x.AutoDetect,!0),this.registerInput("false",x.AutoDetect,!0),this.registerOutput("output",x.BasedOnInput),this._linkConnectionTypes(2,3),this._outputs[0]._typeConnectionSource=this._inputs[2],this._outputs[0]._defaultConnectionPointType=x.Float}getClassName(){return"ConditionalBlock"}get a(){return this._inputs[0]}get b(){return this._inputs[1]}get true(){return this._inputs[2]}get false(){return this._inputs[3]}get output(){return this._outputs[0]}autoConfigure(e){if(!this.true.isConnected){const t=e.getBlockByPredicate(i=>i.isInput&&i.value===1&&i.name==="True")||new Ee("True");t.value=1,t.output.connectTo(this.true)}if(!this.false.isConnected){const t=e.getBlockByPredicate(i=>i.isInput&&i.value===0&&i.name==="False")||new Ee("False");t.value=0,t.output.connectTo(this.false)}}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0],i=this.true.isConnected?this.true.associatedVariableName:"1.0",r=this.false.isConnected?this.false.associatedVariableName:"0.0";switch(this.condition){case Ht.Equal:{e.compilationString+=e._declareOutput(t)+` = ${e._generateTernary(i,r,`${this.a.associatedVariableName} == ${this.b.associatedVariableName}`)};
`;break}case Ht.NotEqual:{e.compilationString+=e._declareOutput(t)+` = ${e._generateTernary(i,r,`${this.a.associatedVariableName} != ${this.b.associatedVariableName}`)};
`;break}case Ht.LessThan:{e.compilationString+=e._declareOutput(t)+` = ${e._generateTernary(i,r,`${this.a.associatedVariableName} < ${this.b.associatedVariableName}`)};
`;break}case Ht.LessOrEqual:{e.compilationString+=e._declareOutput(t)+` = ${e._generateTernary(i,r,`${this.a.associatedVariableName} <= ${this.b.associatedVariableName}`)};
`;break}case Ht.GreaterThan:{e.compilationString+=e._declareOutput(t)+` = ${e._generateTernary(i,r,`${this.a.associatedVariableName} > ${this.b.associatedVariableName}`)};
`;break}case Ht.GreaterOrEqual:{e.compilationString+=e._declareOutput(t)+` = ${e._generateTernary(i,r,`${this.a.associatedVariableName} >= ${this.b.associatedVariableName}`)};
`;break}case Ht.Xor:{e.compilationString+=e._declareOutput(t)+` = ${e._generateTernary(i,r,`(((${this.a.associatedVariableName} + ${this.b.associatedVariableName}) % 2.0) > 0.0)`)};
`;break}case Ht.Or:{e.compilationString+=e._declareOutput(t)+` = ${e._generateTernary(i,r,`(min(${this.a.associatedVariableName} + ${this.b.associatedVariableName}, 1.0) > 0.0)`)};
`;break}case Ht.And:{e.compilationString+=e._declareOutput(t)+` = ${e._generateTernary(i,r,`(${this.a.associatedVariableName} * ${this.b.associatedVariableName} > 0.0)`)};
`;break}}return this}serialize(){const e=super.serialize();return e.condition=this.condition,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.condition=e.condition}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.condition = BABYLON.ConditionalBlockConditions.${Ht[this.condition]};
`}}C([U("Condition",4,"ADVANCED",{notifiers:{rebuild:!0},embedded:!0,options:[{label:"Equal",value:Ht.Equal},{label:"NotEqual",value:Ht.NotEqual},{label:"LessThan",value:Ht.LessThan},{label:"GreaterThan",value:Ht.GreaterThan},{label:"LessOrEqual",value:Ht.LessOrEqual},{label:"GreaterOrEqual",value:Ht.GreaterOrEqual},{label:"Xor",value:Ht.Xor},{label:"And",value:Ht.And},{label:"Or",value:Ht.Or}]})],iC.prototype,"condition",void 0);B("BABYLON.ConditionalBlock",iC);class rC extends le{constructor(e){super(e,A.Neutral),this.octaves=6,this.registerInput("seed",x.AutoDetect),this.registerInput("chaos",x.AutoDetect,!0),this.registerInput("offsetX",x.Float,!0),this.registerInput("offsetY",x.Float,!0),this.registerInput("offsetZ",x.Float,!0),this.registerOutput("output",x.Float),this._inputs[0].acceptedConnectionPointTypes.push(x.Vector2),this._inputs[0].acceptedConnectionPointTypes.push(x.Vector3),this._linkConnectionTypes(0,1)}getClassName(){return"CloudBlock"}get seed(){return this._inputs[0]}get chaos(){return this._inputs[1]}get offsetX(){return this._inputs[2]}get offsetY(){return this._inputs[3]}get offsetZ(){return this._inputs[4]}get output(){return this._outputs[0]}_buildBlock(e){var l,u,c;if(super._buildBlock(e),!this.seed.isConnected||!this._outputs[0].hasEndpoints)return;let t=`

        float cloudRandom(float p) { 
            float temp = fract(p * 0.011); 
            temp *= temp + 7.5; 
            temp *= temp + temp; 
            return fract(temp); 
        }

        // Based on Morgan McGuire @morgan3d
        // https://www.shadertoy.com/view/4dS3Wd
        float cloudNoise2(vec2 x, vec2 chaos) {
            vec2 step = chaos * vec2(75., 120.) + vec2(75., 120.);

            vec2 i = floor(x);
            vec2 f = fract(x);

            float n = dot(i, step);

            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(
                    mix(cloudRandom(n + dot(step, vec2(0, 0))), cloudRandom(n + dot(step, vec2(1, 0))), u.x),
                    mix(cloudRandom(n + dot(step, vec2(0, 1))), cloudRandom(n + dot(step, vec2(1, 1))), u.x),
                    u.y
                );
        }

        float cloudNoise3(vec3 x, vec3 chaos) {
            vec3 step = chaos * vec3(60., 120., 75.) + vec3(60., 120., 75.);

            vec3 i = floor(x);
            vec3 f = fract(x);

            float n = dot(i, step);

            vec3 u = f * f * (3.0 - 2.0 * f);
            return mix(mix(mix( cloudRandom(n + dot(step, vec3(0, 0, 0))), cloudRandom(n + dot(step, vec3(1, 0, 0))), u.x),
                           mix( cloudRandom(n + dot(step, vec3(0, 1, 0))), cloudRandom(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
                       mix(mix( cloudRandom(n + dot(step, vec3(0, 0, 1))), cloudRandom(n + dot(step, vec3(1, 0, 1))), u.x),
                           mix( cloudRandom(n + dot(step, vec3(0, 1, 1))), cloudRandom(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
        }`,i=`
        float fbm2(vec2 st, vec2 chaos) {
            // Initial values
            float value = 0.0;
            float amplitude = .5;
            float frequency = 0.;

            // Loop of octaves
            vec2 tempST = st;
            for (int i = 0; i < OCTAVES; i++) {
                value += amplitude * cloudNoise2(tempST, chaos);
                tempST *= 2.0;
                amplitude *= 0.5;
            }
            return value;
        }

        float fbm3(vec3 x, vec3 chaos) {
            // Initial values
            float value = 0.0;
            float amplitude = 0.5;
            vec3 tempX = x;
            for (int i = 0; i < OCTAVES; i++) {
                value += amplitude * cloudNoise3(tempX, chaos);
                tempX = tempX * 2.0;
                amplitude *= 0.5;
            }
            return value;
        }`;e.shaderLanguage===1&&(t=e._babylonSLtoWGSL(t),i=e._babylonSLtoWGSL(i));const r=`fbm${this.octaves}`;e._emitFunction("CloudBlockCode",t,"// CloudBlockCode"),e._emitFunction("CloudBlockCodeFBM"+this.octaves,i.replace(/fbm/gi,r).replace(/OCTAVES/gi,(this.octaves|0).toString()),"// CloudBlockCode FBM");const s=e._getFreeVariableName("st"),n=((l=this.seed.connectedPoint)==null?void 0:l.type)||x.Vector3;e.compilationString+=`${e._declareLocalVar(s,n)} = ${this.seed.associatedVariableName};
`,this.offsetX.isConnected&&(e.compilationString+=`${s}.x += 0.1 * ${this.offsetX.associatedVariableName};
`),this.offsetY.isConnected&&(e.compilationString+=`${s}.y += 0.1 * ${this.offsetY.associatedVariableName};
`),this.offsetZ.isConnected&&n===x.Vector3&&(e.compilationString+=`${s}.z += 0.1 * ${this.offsetZ.associatedVariableName};
`);let o="";if(this.chaos.isConnected)o=this.chaos.associatedVariableName;else{const h=e.fSuffix;o=((u=this.seed.connectedPoint)==null?void 0:u.type)===x.Vector2?`vec2${h}(0., 0.)`:`vec3${h}(0., 0., 0.)`}return e.compilationString+=e._declareOutput(this._outputs[0])+` = ${r}${((c=this.seed.connectedPoint)==null?void 0:c.type)===x.Vector2?"2":"3"}(${s}, ${o});
`,this}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.octaves = ${this.octaves};
`}serialize(){const e=super.serialize();return e.octaves=this.octaves,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.octaves=e.octaves}}C([U("Octaves",2,void 0,{embedded:!0})],rC.prototype,"octaves",void 0);B("BABYLON.CloudBlock",rC);class x2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("seed",x.Vector2),this.registerInput("offset",x.Float),this.registerInput("density",x.Float),this.registerOutput("output",x.Float),this.registerOutput("cells",x.Float)}getClassName(){return"VoronoiNoiseBlock"}get seed(){return this._inputs[0]}get offset(){return this._inputs[1]}get density(){return this._inputs[2]}get output(){return this._outputs[0]}get cells(){return this._outputs[1]}_buildBlock(e){if(super._buildBlock(e),!this.seed.isConnected)return;let t=`vec2 voronoiRandom(vec2 p){
            p = vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));
            return fract(sin(p)*18.5453);
        }
        `;e.shaderLanguage===1&&(t=e._babylonSLtoWGSL(t)),e._emitFunction("voronoiRandom",t,"// Voronoi random generator"),t=`void voronoi(vec2 seed, float offset, float density, out float outValue, out float cells){
            vec2 n = floor(seed * density);
            vec2 f = fract(seed * density);
            vec3 m = vec3( 8.0 );
            for( int j=-1; j<=1; j++ ){
                for( int i=-1; i<=1; i++ ){
                    vec2  g = vec2( float(i), float(j) );
                    vec2  o = voronoiRandom( n + g);
                    vec2  r = g - f + (0.5+0.5*sin(offset+6.2831*o));
                    float d = dot( r, r );
                    if( d<m.x ){
                        m = vec3( d, o );
                        outValue = m.x;
                        cells = m.y;
                    }
                }
			}
        }
        `,e.shaderLanguage===1?t=e._babylonSLtoWGSL(t):t=e._babylonSLtoGLSL(t),e._emitFunction("voronoi",t,"// Voronoi");const i=e._getFreeVariableName("tempOutput"),r=e._getFreeVariableName("tempCells"),s=e.shaderLanguage===1?"&":"";return e.compilationString+=`${e._declareLocalVar(i,x.Float)} = 0.0;
`,e.compilationString+=`${e._declareLocalVar(r,x.Float)} = 0.0;
`,e.compilationString+=`voronoi(${this.seed.associatedVariableName}, ${this.offset.associatedVariableName}, ${this.density.associatedVariableName}, ${s}${i}, ${s}${r});
`,this.output.hasEndpoints&&(e.compilationString+=e._declareOutput(this.output)+` = ${i};
`),this.cells.hasEndpoints&&(e.compilationString+=e._declareOutput(this.cells)+` = ${r};
`),this}}B("BABYLON.VoronoiNoiseBlock",x2);class S2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("input",x.AutoDetect),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0]}getClassName(){return"ElbowBlock"}get input(){return this._inputs[0]}get output(){return this._outputs[0]}get target(){const e=this._inputs[0];if(e.isConnected){const t=e.connectedPoint.ownerBlock;if(t.target!==A.VertexAndFragment)return t.target;if(e.connectedPoint.target!==A.VertexAndFragment)return e.connectedPoint.target}return this._target}set target(e){this._target&e||(this._target=e)}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0],i=this._inputs[0];return e.compilationString+=e._declareOutput(t)+` = ${i.associatedVariableName};
`,this}}B("BABYLON.ElbowBlock",S2);class G_ extends le{get texture(){var e;return this.source.isConnected?((e=this.source.connectedPoint)==null?void 0:e.ownerBlock).texture:this._texture}set texture(e){if(this._texture===e)return;const t=(e==null?void 0:e.getScene())??ze.LastCreatedScene;!e&&t&&t.markAllMaterialsAsDirty(1,i=>i.hasTexture(this._texture)),this._texture=e,e&&t&&t.markAllMaterialsAsDirty(1,i=>i.hasTexture(e))}get textureY(){var e;return this.sourceY.isConnected?((e=this.sourceY.connectedPoint)==null?void 0:e.ownerBlock).texture:null}get textureZ(){var e,t;return(e=this.sourceZ)!=null&&e.isConnected?((t=this.sourceY.connectedPoint)==null?void 0:t.ownerBlock).texture:null}_getImageSourceBlock(e){return e!=null&&e.isConnected?e.connectedPoint.ownerBlock:null}get samplerName(){const e=this._getImageSourceBlock(this.source);return e?e.samplerName:this._samplerName}get samplerYName(){var e;return((e=this._getImageSourceBlock(this.sourceY))==null?void 0:e.samplerName)??null}get samplerZName(){var e;return((e=this._getImageSourceBlock(this.sourceZ))==null?void 0:e.samplerName)??null}get hasImageSource(){return this.source.isConnected}set convertToGammaSpace(e){if(e!==this._convertToGammaSpace&&(this._convertToGammaSpace=e,this.texture)){const t=this.texture.getScene()??ze.LastCreatedScene;t==null||t.markAllMaterialsAsDirty(1,i=>i.hasTexture(this.texture))}}get convertToGammaSpace(){return this._convertToGammaSpace}set convertToLinearSpace(e){if(e!==this._convertToLinearSpace&&(this._convertToLinearSpace=e,this.texture)){const t=this.texture.getScene()??ze.LastCreatedScene;t==null||t.markAllMaterialsAsDirty(1,i=>i.hasTexture(this.texture))}}get convertToLinearSpace(){return this._convertToLinearSpace}constructor(e,t=!1){super(e,A.Neutral),this.projectAsCube=!1,this._convertToGammaSpace=!1,this._convertToLinearSpace=!1,this.disableLevelMultiplication=!1,this.registerInput("position",x.AutoDetect,!1),this.registerInput("normal",x.AutoDetect,!1),this.registerInput("sharpness",x.Float,!0),this.registerInput("source",x.Object,!0,A.VertexAndFragment,new dt("source",this,0,Zi,"ImageSourceBlock")),this.registerInput("sourceY",x.Object,!0,A.VertexAndFragment,new dt("sourceY",this,0,Zi,"ImageSourceBlock")),t||this.registerInput("sourceZ",x.Object,!0,A.VertexAndFragment,new dt("sourceZ",this,0,Zi,"ImageSourceBlock")),this.registerOutput("rgba",x.Color4,A.Neutral),this.registerOutput("rgb",x.Color3,A.Neutral),this.registerOutput("r",x.Float,A.Neutral),this.registerOutput("g",x.Float,A.Neutral),this.registerOutput("b",x.Float,A.Neutral),this.registerOutput("a",x.Float,A.Neutral),this.registerOutput("level",x.Float,A.Neutral),this._inputs[0].addExcludedConnectionPointFromAllowedTypes(x.Color3|x.Vector3|x.Vector4),this._inputs[1].addExcludedConnectionPointFromAllowedTypes(x.Color3|x.Vector3|x.Vector4)}getClassName(){return"TriPlanarBlock"}get position(){return this._inputs[0]}get normal(){return this._inputs[1]}get sharpness(){return this._inputs[2]}get source(){return this._inputs[3]}get sourceY(){return this._inputs[4]}get sourceZ(){return this._inputs[5]}get rgba(){return this._outputs[0]}get rgb(){return this._outputs[1]}get r(){return this._outputs[2]}get g(){return this._outputs[3]}get b(){return this._outputs[4]}get a(){return this._outputs[5]}get level(){return this._outputs[6]}prepareDefines(e,t,i){if(!i._areTexturesDirty)return;const r=this.convertToGammaSpace&&this.texture&&!this.texture.gammaSpace,s=this.convertToLinearSpace&&this.texture&&this.texture.gammaSpace;i.setValue(this._linearDefineName,r,!0),i.setValue(this._gammaDefineName,s,!0)}isReady(){return!(this.texture&&!this.texture.isReadyOrNotBlocking())}bind(e){this.texture&&(e.setFloat(this._textureInfoName,this.texture.level),this._imageSource||e.setTexture(this._samplerName,this.texture))}_samplerFunc(e){return e.shaderLanguage===1?"textureSample":"texture2D"}_generateTextureSample(e,t,i){return i.shaderLanguage===1?`${this._samplerFunc(i)}(${e},${e+"Sampler"}, ${t})`:`${this._samplerFunc(i)}(${e}, ${t})`}_generateTextureLookup(e){const t=this.samplerName,i=this.samplerYName??t,r=this.samplerZName??t,s=this.sharpness.isConnected?this.sharpness.associatedVariableName:"1.0",n=e._getFreeVariableName("x"),o=e._getFreeVariableName("y"),l=e._getFreeVariableName("z"),u=e._getFreeVariableName("w"),c=e._getFreeVariableName("n"),h=e._getFreeVariableName("uvx"),d=e._getFreeVariableName("uvy"),f=e._getFreeVariableName("uvz");e.compilationString+=`
            ${e._declareLocalVar(c,x.Vector3)} = ${this.normal.associatedVariableName}.xyz;

            ${e._declareLocalVar(h,x.Vector2)} = ${this.position.associatedVariableName}.yz;
            ${e._declareLocalVar(d,x.Vector2)} = ${this.position.associatedVariableName}.zx;
            ${e._declareLocalVar(f,x.Vector2)} = ${this.position.associatedVariableName}.xy;
        `,this.projectAsCube&&(e.compilationString+=`
                ${h}.xy = ${h}.yx;

                if (${c}.x >= 0.0) {
                    ${h}.x = -${h}.x;
                }
                if (${c}.y < 0.0) {
                    ${d}.y = -${d}.y;
                }
                if (${c}.z < 0.0) {
                    ${f}.x = -${f}.x;
                }
            `);const p=e.fSuffix;e.compilationString+=`
            ${e._declareLocalVar(n,x.Vector4)} = ${this._generateTextureSample(t,h,e)};
            ${e._declareLocalVar(o,x.Vector4)} = ${this._generateTextureSample(i,d,e)};
            ${e._declareLocalVar(l,x.Vector4)} = ${this._generateTextureSample(r,f,e)};
           
            // blend weights
            ${e._declareLocalVar(u,x.Vector3)} = pow(abs(${c}), vec3${p}(${s}));

            // blend and return
            ${e._declareLocalVar(this._tempTextureRead,x.Vector4)} = (${n}*${u}.x + ${o}*${u}.y + ${l}*${u}.z) / (${u}.x + ${u}.y + ${u}.z);        
        `}_generateConversionCode(e,t,i){let r="";e.shaderLanguage===1&&(t.type===x.Vector3||t.type===x.Color3)&&(r="Vec3"),i!=="a"&&((!this.texture||!this.texture.gammaSpace)&&(e.compilationString+=`#ifdef ${this._linearDefineName}
                    ${t.associatedVariableName} = toGammaSpace${r}(${t.associatedVariableName});
                    #endif
                `),e.compilationString+=`#ifdef ${this._gammaDefineName}
                ${t.associatedVariableName} = toLinearSpace${r}(${t.associatedVariableName});
                #endif
            `)}_writeOutput(e,t,i){let r="";this.disableLevelMultiplication||(r=` * ${e.shaderLanguage===1?"uniforms.":""}${this._textureInfoName}`),e.compilationString+=`${e._declareOutput(t)} = ${this._tempTextureRead}.${i}${r};
`,this._generateConversionCode(e,t,i)}_buildBlock(e){super._buildBlock(e),this.source.isConnected?this._imageSource=this.source.connectedPoint.ownerBlock:this._imageSource=null,this._textureInfoName=e._getFreeVariableName("textureInfoName"),this.level.associatedVariableName=(e.shaderLanguage===1?"uniforms.":"")+this._textureInfoName,this._tempTextureRead=e._getFreeVariableName("tempTextureRead"),this._linearDefineName=e._getFreeDefineName("ISLINEAR"),this._gammaDefineName=e._getFreeDefineName("ISGAMMA"),this._imageSource||(this._samplerName=e._getFreeVariableName(this.name+"Texture"),e._emit2DSampler(this._samplerName)),e.sharedData.blockingBlocks.push(this),e.sharedData.textureBlocks.push(this),e.sharedData.blocksWithDefines.push(this),e.sharedData.bindableBlocks.push(this);const t=`//${this.name}`;e._emitFunctionFromInclude("helperFunctions",t),e._emitUniformFromString(this._textureInfoName,x.Float),this._generateTextureLookup(e);for(const i of this._outputs)i.hasEndpoints&&i.name!=="level"&&this._writeOutput(e,i,i.name);return this}_dumpPropertiesCode(){let e=super._dumpPropertiesCode();return e+=`${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};
`,e+=`${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};
`,e+=`${this._codeVariableName}.disableLevelMultiplication = ${this.disableLevelMultiplication};
`,e+=`${this._codeVariableName}.projectAsCube = ${this.projectAsCube};
`,this.texture&&(e+=`${this._codeVariableName}.texture = new BABYLON.Texture("${this.texture.name}", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});
`,e+=`${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};
`,e+=`${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};
`,e+=`${this._codeVariableName}.texture.uAng = ${this.texture.uAng};
`,e+=`${this._codeVariableName}.texture.vAng = ${this.texture.vAng};
`,e+=`${this._codeVariableName}.texture.wAng = ${this.texture.wAng};
`,e+=`${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};
`,e+=`${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};
`,e+=`${this._codeVariableName}.texture.uScale = ${this.texture.uScale};
`,e+=`${this._codeVariableName}.texture.vScale = ${this.texture.vScale};
`,e+=`${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};
`),e}serialize(){const e=super.serialize();return e.convertToGammaSpace=this.convertToGammaSpace,e.convertToLinearSpace=this.convertToLinearSpace,e.disableLevelMultiplication=this.disableLevelMultiplication,e.projectAsCube=this.projectAsCube,!this.hasImageSource&&this.texture&&!this.texture.isRenderTarget&&this.texture.getClassName()!=="VideoTexture"&&(e.texture=this.texture.serialize()),e}_deserialize(e,t,i){super._deserialize(e,t,i),this.convertToGammaSpace=e.convertToGammaSpace,this.convertToLinearSpace=!!e.convertToLinearSpace,this.disableLevelMultiplication=!!e.disableLevelMultiplication,this.projectAsCube=!!e.projectAsCube,e.texture&&!ht.IgnoreTexturesAtLoadTime&&e.texture.url!==void 0&&(i=e.texture.url.indexOf("data:")===0?"":i,this.texture=Y.Parse(e.texture,t,i))}}C([U("Project as cube",0,"ADVANCED",{embedded:!0,notifiers:{update:!0}})],G_.prototype,"projectAsCube",void 0);B("BABYLON.TriPlanarBlock",G_);class v2 extends G_{constructor(e){super(e,!0)}getClassName(){return"BiPlanarBlock"}_declareLocalVarAsVec3I(e,t){return t.shaderLanguage===1?`var ${e}: vec3<i32>`:`ivec3 ${e}`}_getTextureGrad(e,t){return e.shaderLanguage===1?`textureSampleGrad(${t},${t+"Sampler"}`:`textureGrad(${t}`}_generateTextureLookup(e){const t=this.samplerName,i=this.samplerYName??this.samplerName,r=this.sharpness.isConnected?this.sharpness.associatedVariableName:"1.0",s=e._getFreeVariableName("dxValue"),n=e._getFreeVariableName("dyValue"),o=e._getFreeVariableName("n"),l=e._getFreeVariableName("ma"),u=e._getFreeVariableName("mi"),c=e._getFreeVariableName("me"),h=e._getFreeVariableName("x"),d=e._getFreeVariableName("y"),f=e._getFreeVariableName("w");let p="ivec3",g="dFdx",_="dFdy";const S=e.fSuffix;e.shaderLanguage===1&&(p="vec3<i32>",g="dpdx",_="dpdy"),e.compilationString+=`
            // grab coord derivatives for texturing
            ${e._declareLocalVar(s,x.Vector3)} = ${g}(${this.position.associatedVariableName}.xyz);
            ${e._declareLocalVar(n,x.Vector3)} = ${_}(${this.position.associatedVariableName}.xyz);
            ${e._declareLocalVar(o,x.Vector3)} = abs(${this.normal.associatedVariableName}.xyz);
        
            // determine major axis (in x; yz are following axis)
            ${this._declareLocalVarAsVec3I(l,e)} = ${e._generateTernary(`${p}(0,1,2)`,`${e._generateTernary(`${p}(1,2,0)`,`${p}(2,0,1)`,`(${o}.y>${o}.z)`)}`,`(${o}.x>${o}.y && ${o}.x>${o}.z)`)};                    

            // determine minor axis (in x; yz are following axis)
            ${this._declareLocalVarAsVec3I(u,e)} =  ${e._generateTernary(`${p}(0,1,2)`,`${e._generateTernary(`${p}(1,2,0)`,`${p}(2,0,1)`,`(${o}.y<${o}.z)`)}`,`(${o}.x<${o}.y && ${o}.x<${o}.z)`)};  
                              
            // determine median axis (in x;  yz are following axis)
            ${this._declareLocalVarAsVec3I(c,e)} = ${p}(3) - ${u} - ${l};
            
            // project+fetch
            ${e._declareLocalVar(h,x.Vector4)} = ${this._getTextureGrad(e,t)}, vec2${S}(${this.position.associatedVariableName}[${l}.y], ${this.position.associatedVariableName}[${l}.z]), 
                                    vec2${S}(${s}[${l}.y],${s}[${l}.z]), 
                                    vec2${S}(${n}[${l}.y],${n}[${l}.z]));
            ${e._declareLocalVar(d,x.Vector4)} = ${this._getTextureGrad(e,i)}, vec2${S}(${this.position.associatedVariableName}[${c}.y], ${this.position.associatedVariableName}[${c}.z]), 
                                    vec2${S}(${s}[${c}.y],${s}[${c}.z]),
                                    vec2${S}(${n}[${c}.y],${n}[${c}.z]));
            
            // blend factors
            ${e._declareLocalVar(f,x.Vector2)} = vec2${S}(${o}[${l}.x],${o}[${c}.x]);
            // make local support
            ${f} = clamp( (${f}-0.5773)/(1.0-0.5773), vec2${S}(0.0), vec2${S}(1.0) );
            // shape transition
            ${f} = pow( ${f}, vec2${S}(${r}/8.0) );
            // blend and return
            ${e._declareLocalVar(this._tempTextureRead,x.Vector4)} = (${h}*${f}.x + ${d}*${f}.y) / (${f}.x + ${f}.y);
        `}}B("BABYLON.BiPlanarBlock",v2);class b2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("input",x.Matrix),this.registerOutput("output",x.Float)}getClassName(){return"MatrixDeterminantBlock"}get input(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this.output,i=this.input;return e.compilationString+=e._declareOutput(t)+` = determinant(${i.associatedVariableName});
`,this}}B("BABYLON.MatrixDeterminantBlock",b2);class y2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("input",x.Matrix),this.registerOutput("output",x.Matrix)}getClassName(){return"MatrixTransposeBlock"}get input(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this.output,i=this.input;return e.compilationString+=e._declareOutput(t)+` = transpose(${i.associatedVariableName});
`,this}}B("BABYLON.MatrixTransposeBlock",y2);var YS;(function(a){a[a.None=0]="None",a[a.Normal=1]="Normal",a[a.Tangent=2]="Tangent",a[a.VertexColor=3]="VertexColor",a[a.UV1=4]="UV1",a[a.UV2=5]="UV2",a[a.UV3=6]="UV3",a[a.UV4=7]="UV4",a[a.UV5=8]="UV5",a[a.UV6=9]="UV6"})(YS||(YS={}));class sC extends le{constructor(e){super(e,A.Neutral),this.attributeType=0,this.registerInput("input",x.AutoDetect),this.registerInput("fallback",x.AutoDetect),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._linkConnectionTypes(0,1),this._inputs[0].onConnectionObservable.add(t=>{var r;if(this.attributeType)return;const i=t.ownerBlock;if(i instanceof Ee&&i.isAttribute)switch(i.name){case"color":this.attributeType=3;break;case"normal":this.attributeType=1;break;case"tangent":this.attributeType=2;break;case"uv":this.attributeType=4;break;case"uv2":this.attributeType=5;break;case"uv3":this.attributeType=6;break;case"uv4":this.attributeType=7;break;case"uv5":this.attributeType=8;break;case"uv6":this.attributeType=9;break}else if(i instanceof qT)switch((r=this.input.connectedPoint)==null?void 0:r.name){case"normalOutput":this.attributeType=1;break;case"tangentOutput":this.attributeType=2;break;case"uvOutput":this.attributeType=4;break;case"uv2Output":this.attributeType=5;break}})}getClassName(){return"MeshAttributeExistsBlock"}get input(){return this._inputs[0]}get fallback(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);let t=null;switch(this.attributeType){case 3:t="VERTEXCOLOR_NME";break;case 1:t="NORMAL";break;case 2:t="TANGENT";break;case 4:t="UV1";break;case 5:t="UV2";break;case 6:t="UV3";break;case 7:t="UV4";break;case 8:t="UV5";break;case 9:t="UV6";break}const i=e._declareOutput(this.output);return t&&(e.compilationString+=`#ifdef ${t}
`),e.compilationString+=`${i} = ${this.input.associatedVariableName};
`,t&&(e.compilationString+=`#else
`,e.compilationString+=`${i} = ${this.fallback.associatedVariableName};
`,e.compilationString+=`#endif
`),this}serialize(){const e=super.serialize();return e.attributeType=this.attributeType,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.attributeType=e.attributeType??0}_dumpPropertiesCode(){let e=super._dumpPropertiesCode();return e+=`${this._codeVariableName}.attributeType = ${this.attributeType};
`,e}}C([U("Attribute lookup",4,void 0,{notifiers:{update:!0},embedded:!0,options:[{label:"(None)",value:0},{label:"Normal",value:1},{label:"Tangent",value:2},{label:"Vertex Color",value:3},{label:"UV1",value:4},{label:"UV2",value:5},{label:"UV3",value:6},{label:"UV4",value:7},{label:"UV5",value:8},{label:"UV6",value:9}]})],sC.prototype,"attributeType",void 0);B("BABYLON.MeshAttributeExistsBlock",sC);var Ae;(function(a){a[a.EaseInSine=0]="EaseInSine",a[a.EaseOutSine=1]="EaseOutSine",a[a.EaseInOutSine=2]="EaseInOutSine",a[a.EaseInQuad=3]="EaseInQuad",a[a.EaseOutQuad=4]="EaseOutQuad",a[a.EaseInOutQuad=5]="EaseInOutQuad",a[a.EaseInCubic=6]="EaseInCubic",a[a.EaseOutCubic=7]="EaseOutCubic",a[a.EaseInOutCubic=8]="EaseInOutCubic",a[a.EaseInQuart=9]="EaseInQuart",a[a.EaseOutQuart=10]="EaseOutQuart",a[a.EaseInOutQuart=11]="EaseInOutQuart",a[a.EaseInQuint=12]="EaseInQuint",a[a.EaseOutQuint=13]="EaseOutQuint",a[a.EaseInOutQuint=14]="EaseInOutQuint",a[a.EaseInExpo=15]="EaseInExpo",a[a.EaseOutExpo=16]="EaseOutExpo",a[a.EaseInOutExpo=17]="EaseInOutExpo",a[a.EaseInCirc=18]="EaseInCirc",a[a.EaseOutCirc=19]="EaseOutCirc",a[a.EaseInOutCirc=20]="EaseInOutCirc",a[a.EaseInBack=21]="EaseInBack",a[a.EaseOutBack=22]="EaseOutBack",a[a.EaseInOutBack=23]="EaseInOutBack",a[a.EaseInElastic=24]="EaseInElastic",a[a.EaseOutElastic=25]="EaseOutElastic",a[a.EaseInOutElastic=26]="EaseInOutElastic"})(Ae||(Ae={}));class nC extends le{constructor(e){super(e,A.Neutral),this.type=Ae.EaseInOutSine,this.registerInput("input",x.AutoDetect),this.registerOutput("output",x.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._inputs[0].excludedConnectionPointTypes.push(x.Matrix),this._inputs[0].excludedConnectionPointTypes.push(x.Object),this._inputs[0].excludedConnectionPointTypes.push(x.Int)}getClassName(){return"CurveBlock"}get input(){return this._inputs[0]}get output(){return this._outputs[0]}_duplicateEntry(e,t){return`ret.${t} = ${e.replace(/VAL/g,"v."+t)}`}_duplicateEntryDirect(e){return`return ${e.replace(/VAL/g,"v")}`}_duplicateVector(e,t,i){if(t==="float"||t==="f32")return this._duplicateEntryDirect(e);const r=parseInt(t.replace("vec",""));let s=i?`
            var ret: vec${r}f = vec${r}f(0.0);
        `:`
            vec${r} ret = vec${r}(0.0);
        `;for(let n=1;n<=r;n++)s+=this._duplicateEntry(e,n===1?"x":n===2?"y":n===3?"z":"w")+`;
`;return s+=`return ret;
`,s}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0];let i="",r="";const s=e._getShaderType(this.input.type),n=e.shaderLanguage===1;switch(r=Ae[this.type]+"_"+s.replace("<","").replace(">",""),this.type){case Ae.EaseInSine:i="return 1.0 - cos((v * 3.1415) / 2.0)";break;case Ae.EaseOutSine:i="return sin((v * 3.1415) / 2.0)";break;case Ae.EaseInOutSine:i="return -(cos(v * 3.1415) - 1.0) / 2.0";break;case Ae.EaseInQuad:i="return v * v";break;case Ae.EaseOutQuad:i="return (1.0 - v) * (1.0 - v)";break;case Ae.EaseInOutQuad:{const o=e._generateTernary("2.0 * VAL * VAL","1.0 - pow(-2.0 * VAL + 2.0, 2.0) / 2.0","VAL < 0.5");i=this._duplicateVector(o,s,n);break}case Ae.EaseInCubic:i="return v * v * v";break;case Ae.EaseOutCubic:{i=this._duplicateVector("1.0 - pow(1.0 - VAL, 3.0)",s,n);break}case Ae.EaseInOutCubic:{const o=e._generateTernary("4.0 * VAL * VAL * VAL","1.0 - pow(-2.0 * VAL + 2.0, 3.0) / 2.0","VAL < 0.5");i=this._duplicateVector(o,s,n);break}case Ae.EaseInQuart:i="return v * v * v * v";break;case Ae.EaseOutQuart:{i=this._duplicateVector("1.0 - pow(1.0 - VAL, 4.0)",s,n);break}case Ae.EaseInOutQuart:{const o=e._generateTernary("8.0 * VAL * VAL * VAL * VAL","1.0 - pow(-2.0 * VAL + 2.0, 4.0) / 2.0","VAL < 0.5");i=this._duplicateVector(o,s,n);break}case Ae.EaseInQuint:i="return v * v * v * v * v";break;case Ae.EaseOutQuint:{i=this._duplicateVector("1.0 - pow(1.0 - VAL, 5.0)",s,n);break}case Ae.EaseInOutQuint:{const o=e._generateTernary("16.0 * VAL * VAL * VAL * VAL * VAL","1.0 - pow(-2.0 * VAL + 2.0, 5.0) / 2.0","VAL < 0.5");i=this._duplicateVector(o,s,n);break}case Ae.EaseInExpo:{const o=e._generateTernary("0.0","pow(2.0, 10.0 * VAL - 10.0)","VAL == 0.0");i=this._duplicateVector(o,s,n);break}case Ae.EaseOutExpo:{const o=e._generateTernary("1.0","1.0 - pow(2.0, -10.0 * VAL)","VAL == 1.0");i=this._duplicateVector(o,s,n);break}case Ae.EaseInOutExpo:{const o=e._generateTernary("0.0",e._generateTernary("1.0",e._generateTernary("pow(2.0, 20.0 * VAL - 10.0) / 2.0","(2.0 - pow(2.0, -20.0 * VAL + 10.0)) / 2.0","VAL < 0.5"),"VAL == 1.0"),"VAL == 0.0");i=this._duplicateVector(o,s,n);break}case Ae.EaseInCirc:{i=this._duplicateVector("1.0 - sqrt(1.0 - pow(VAL, 2.0))",s,n);break}case Ae.EaseOutCirc:{i=this._duplicateVector("sqrt(1.0 - pow(VAL - 1.0, 2.0))",s,n);break}case Ae.EaseInOutCirc:{const o=e._generateTernary("(1.0 - sqrt(1.0 - pow(2.0 * VAL, 2.0))) / 2.0","(sqrt(1.0 - pow(-2.0 * VAL + 2.0, 2.0)) + 1.0) / 2.0","VAL < 0.5");i=this._duplicateVector(o,s,n);break}case Ae.EaseInBack:{i="return 2.70158 * v * v * v - 1.70158 * v * v";break}case Ae.EaseOutBack:{i=this._duplicateVector("2.70158 * pow(VAL - 1.0, 3.0) + 1.70158 * pow(VAL - 1.0, 2.0)",s,n);break}case Ae.EaseInOutBack:{const o=e._generateTernary("(pow(2.0 * VAL, 2.0) * ((3.5949095) * 2.0 * VAL - 2.5949095)) / 2.0","(pow(2.0 * VAL - 2.0, 2.0) * (3.5949095 * (VAL * 2.0 - 2.0) + 3.5949095) + 2.0) / 2.0","VAL < 0.5");i=this._duplicateVector(o,s,n);break}case Ae.EaseInElastic:{const o=e._generateTernary("0.0",e._generateTernary("1.0","-pow(2.0, 10.0 * VAL - 10.0) * sin((VAL * 10.0 - 10.75) * ((2.0 * 3.1415) / 3.0))","VAL == 1.0"),"VAL == 0.0");i=this._duplicateVector(o,s,n);break}case Ae.EaseOutElastic:{const o=e._generateTernary("0.0",e._generateTernary("1.0","pow(2.0, -10.0 * VAL) * sin((VAL * 10.0 - 0.75) * ((2.0 * 3.1415) / 3.0)) + 1.0","VAL == 1.0"),"VAL == 0.0");i=this._duplicateVector(o,s,n);break}case Ae.EaseInOutElastic:{const o=e._generateTernary("0.0",e._generateTernary("1.0",e._generateTernary("-(pow(2.0, 20.0 * VAL - 10.0) * sin((20.0 * VAL - 11.125) * ((2.0 * 3.1415) / 4.5))) / 2.0","(pow(2.0, -20.0 * VAL + 10.0) * sin((20.0 * VAL - 11.125) * ((2.0 * 3.1415) / 4.5))) / 2.0 + 1.0","VAL < 0.5"),"VAL == 1.0"),"VAL == 0.0");i=this._duplicateVector(o,s,n);break}}return n?e._emitFunction(r,`fn ${r}(v: ${s}) -> ${s}  {${i};}
`,""):e._emitFunction(r,`${s} ${r}(${s} v) {${i};}
`,""),e.compilationString+=e._declareOutput(t)+` = ${r}(${this.input.associatedVariableName});
`,this}serialize(){const e=super.serialize();return e.curveType=this.type,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.type=e.curveType}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.type = BABYLON.CurveBlockTypes.${Ae[this.type]};
`}}C([U("Type",4,"ADVANCED",{notifiers:{rebuild:!0},embedded:!0,options:[{label:"EaseInSine",value:Ae.EaseInSine},{label:"EaseOutSine",value:Ae.EaseOutSine},{label:"EaseInOutSine",value:Ae.EaseInOutSine},{label:"EaseInQuad",value:Ae.EaseInQuad},{label:"EaseOutQuad",value:Ae.EaseOutQuad},{label:"EaseInOutQuad",value:Ae.EaseInOutQuad},{label:"EaseInCubic",value:Ae.EaseInCubic},{label:"EaseOutCubic",value:Ae.EaseOutCubic},{label:"EaseInOutCubic",value:Ae.EaseInOutCubic},{label:"EaseInQuart",value:Ae.EaseInQuart},{label:"EaseOutQuart",value:Ae.EaseOutQuart},{label:"EaseInOutQuart",value:Ae.EaseInOutQuart},{label:"EaseInQuint",value:Ae.EaseInQuint},{label:"EaseOutQuint",value:Ae.EaseOutQuint},{label:"EaseInOutQuint",value:Ae.EaseInOutQuint},{label:"EaseInExpo",value:Ae.EaseInExpo},{label:"EaseOutExpo",value:Ae.EaseOutExpo},{label:"EaseInOutExpo",value:Ae.EaseInOutExpo},{label:"EaseInCirc",value:Ae.EaseInCirc},{label:"EaseOutCirc",value:Ae.EaseOutCirc},{label:"EaseInOutCirc",value:Ae.EaseInOutCirc},{label:"EaseInBack",value:Ae.EaseInBack},{label:"EaseOutBack",value:Ae.EaseOutBack},{label:"EaseInOutBack",value:Ae.EaseInOutBack},{label:"EaseInElastic",value:Ae.EaseInElastic},{label:"EaseOutElastic",value:Ae.EaseOutElastic},{label:"EaseInOutElastic",value:Ae.EaseInOutElastic}]})],nC.prototype,"type",void 0);B("BABYLON.CurveBlock",nC);class T2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("rgb ",x.Color3,!0),this.registerInput("hsl ",x.Color3,!0),this.registerOutput("rgb",x.Color3),this.registerOutput("hsl",x.Color3)}getClassName(){return"ColorConverterBlock"}get rgbIn(){return this._inputs[0]}get hslIn(){return this._inputs[1]}get rgbOut(){return this._outputs[0]}get hslOut(){return this._outputs[1]}_inputRename(e){return e==="rgb "?"rgbIn":e==="hsl "?"hslIn":e}_buildBlock(e){super._buildBlock(e);const t=this.rgbIn,i=this.hslIn,r=this._outputs[0],s=this._outputs[1],n=e._getShaderType(x.Vector3);let o=`
            vec3 rgb2hsl(vec3 color) {
                float r = color.r;
                float g = color.g;
                float b = color.b;

                float maxc = max(r, max(g, b));
                float minc = min(r, min(g, b));
                float h = 0.0;
                float s = 0.0;
                float l = (maxc + minc) / 2.0;

                if (maxc != minc) {
                    float d = maxc - minc;
                    if (l > 0.5) {
                        s = d / (2.0 - maxc - minc);
                    } else {
                        s = d / (maxc + minc);
                    }

                    if (maxc == r) {
                        float add = 0.0;
                        if (g < b) {
                            add = 6.0;
                        }
                        h = (g - b) / d + add;
                    } else if (maxc == g) {
                        h = (b - r) / d + 2.0;
                    } else if (maxc == b) {
                        h = (r - g) / d + 4.0;
                    }
                    h /= 6.0;
                }

                return vec3(h, s, l);
            }`,l=`
            float hue2rgb(float p, float q, float tt) {
                float t = tt;
                if (t < 0.0) {
                    t += 1.0;
                }
                if (t > 1.0) {
                    t -= 1.0;
                }
                if (t < 1.0/6.0) {
                    return p + (q - p) * 6.0 * t;
                }
                if (t < 1.0/2.0) {
                    return q;
                }
                if (t < 2.0/3.0) {
                    return p + (q - p) * (2.0/3.0 - t) * 6.0;
                }
                return p;
            }`,u=`
            vec3 hsl2rgb(vec3 hsl) {
                float h = hsl.x;
                float s = hsl.y;
                float l = hsl.z;

                float r;
                float g;
                float b;

                if (s == 0.0) {
                    // Achromatic (grey)
                    r = l;
                    g = l;
                    b = l; 
                } else {
                    float q;
                
                    if (l < 0.5) {
                        q = l * (1.0 + s);
                    } else {
                        q = (l + s - l * s);
                    }

                    float p = 2.0 * l - q;

                    r = hue2rgb(p, q, h + 1.0/3.0);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1.0/3.0);
                }

                return vec3(r, g, b);
            }`;return e.shaderLanguage===1&&(o=e._babylonSLtoWGSL(o),l=e._babylonSLtoWGSL(l),u=e._babylonSLtoWGSL(u)),e._emitFunction("rgb2hsl",o,""),e._emitFunction("hue2rgb",l,""),e._emitFunction("hsl2rgb",u,""),t.isConnected?(r.hasEndpoints&&(e.compilationString+=e._declareOutput(r)+` = ${t.associatedVariableName};
`),s.hasEndpoints&&(e.compilationString+=e._declareOutput(s)+` = rgb2hsl(${t.associatedVariableName});
`)):i.isConnected?(r.hasEndpoints&&(e.compilationString+=e._declareOutput(r)+` = hsl2rgb(${i.associatedVariableName});
`),s.hasEndpoints&&(e.compilationString+=e._declareOutput(s)+` = ${i.associatedVariableName};
`)):(r.hasEndpoints&&(e.compilationString+=e._declareOutput(r)+` =  ${n}(0.);
`),s.hasEndpoints&&(e.compilationString+=e._declareOutput(s)+` =  ${n}(0.);
`)),this}}B("BABYLON.ColorConverterBlock",T2);class oo extends le{constructor(e){super(e,A.Neutral),this.iterations=4,this.registerInput("input",x.AutoDetect),this.registerInput("iterations",x.Float,!0),this.registerOutput("output",x.BasedOnInput),this.registerOutput("index",x.Float,A.Fragment),this.registerOutput("loopID",x.Object,void 0,new dt("loopID",this,1,oo,"LoopBlock")),this._outputs[0]._typeConnectionSource=this._inputs[0],this._outputs[0]._forPostBuild=!0,this._outputs[2]._redirectedSource=this._inputs[0],this._outputs[1]._preventBubbleUp=!0,this._outputs[2]._preventBubbleUp=!0}getClassName(){return"LoopBlock"}get input(){return this._inputs[0]}get iterationsInput(){return this._inputs[1]}get output(){return this._outputs[0]}get index(){return this._outputs[1]}get loopID(){return this._outputs[2]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0],i=this._outputs[1],r=e._getFreeVariableName("index"),s=e.shaderLanguage===1?"var":"int",n=e.shaderLanguage===1?"f32":"float",o=e.shaderLanguage===1?"i32":"int";e.compilationString+=e._declareOutput(t)+` = ${this.input.associatedVariableName};
`;const l=this.iterationsInput.isConnected?`${o}(${this.iterationsInput.associatedVariableName})`:this.iterations;return e.compilationString+=`for (${s} ${r} = 0; ${r} < ${l}; ${r}++){
`,e.compilationString+=`${e._declareOutput(i)} = ${n}(${r});
`,this}_postBuildBlock(e){return super._postBuildBlock(e),e.compilationString+=`}
`,this}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.iterations = ${this.iterations};
`}serialize(){const e=super.serialize();return e.iterations=this.iterations,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.iterations=e.iterations}}C([U("Iterations",2,void 0,{embedded:!0})],oo.prototype,"iterations",void 0);B("BABYLON.LoopBlock",oo);class C2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("loopID",x.Object,!1,void 0,new dt("loopID",this,0,oo,"LoopBlock")),this.registerOutput("value",x.AutoDetect),this._outputs[0]._linkedConnectionSource=this._inputs[0]}getClassName(){return"StorageReadBlock"}get loopID(){return this._inputs[0]}get value(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this.value;if(!this.loopID.isConnected)return this;const i=this.loopID.connectedPoint.ownerBlock;return e.compilationString+=e._declareOutput(t)+` = ${i.output.associatedVariableName};
`,this}}B("BABYLON.StorageReadBlock",C2);class P2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("loopID",x.Object,!1,void 0,new dt("loopID",this,0,oo,"LoopBlock")),this.registerInput("value",x.AutoDetect),this._linkConnectionTypes(0,1)}getClassName(){return"StorageWriteBlock"}get loopID(){return this._inputs[0]}get value(){return this._inputs[1]}isConnectedInFragmentShader(){return this.loopID.isConnected?this.loopID.connectedPoint.ownerBlock.output.isConnectedInFragmentShader:!1}_buildBlock(e){super._buildBlock(e);const t=this.value;if(!this.loopID.isConnected)return this;const i=this.loopID.connectedPoint.ownerBlock;return e.compilationString+=`${i.output.associatedVariableName} = ${t.associatedVariableName};
`,this}}B("BABYLON.StorageWriteBlock",P2);class E2 extends le{constructor(e){super(e,A.Neutral),this.registerInput("input",x.Matrix),this.registerOutput("row0",x.Vector4),this.registerOutput("row1",x.Vector4),this.registerOutput("row2",x.Vector4),this.registerOutput("row3",x.Vector4),this.registerOutput("col0",x.Vector4),this.registerOutput("col1",x.Vector4),this.registerOutput("col2",x.Vector4),this.registerOutput("col3",x.Vector4)}getClassName(){return"MatrixSplitterBlock"}get input(){return this._inputs[0]}get row0(){return this._outputs[0]}get row1(){return this._outputs[1]}get row2(){return this._outputs[2]}get row3(){return this._outputs[3]}get col0(){return this._outputs[4]}get col1(){return this._outputs[5]}get col2(){return this._outputs[6]}get col3(){return this._outputs[7]}_exportColumn(e,t,i,r){const s=e.shaderLanguage===1?"vec4f":"vec4";e.compilationString+=e._declareOutput(t)+` = ${s}(${i}[0][${r}], ${i}[1][${r}], ${i}[2][${r}], ${i}[3][${r}]);
`}_buildBlock(e){super._buildBlock(e);const t=this._inputs[0].associatedVariableName,i=this.row0,r=this.row1,s=this.row2,n=this.row3,o=this.col0,l=this.col1,u=this.col2,c=this.col3;return i.hasEndpoints&&(e.compilationString+=e._declareOutput(i)+` = ${t}[0];
`),r.hasEndpoints&&(e.compilationString+=e._declareOutput(r)+` = ${t}[1];
`),s.hasEndpoints&&(e.compilationString+=e._declareOutput(s)+` = ${t}[2];
`),n.hasEndpoints&&(e.compilationString+=e._declareOutput(n)+` = ${t}[3];
`),o.hasEndpoints&&this._exportColumn(e,o,t,0),l.hasEndpoints&&this._exportColumn(e,l,t,1),u.hasEndpoints&&this._exportColumn(e,u,t,2),c.hasEndpoints&&this._exportColumn(e,c,t,3),this}}B("BABYLON.MatrixSplitterBlock",E2);const ud="gaussianSplattingVertexDeclaration",aC=`attribute position: vec2f;
`;P.IncludesShadersStoreWGSL[ud]||(P.IncludesShadersStoreWGSL[ud]=aC);const kW={name:ud,shader:aC};class oC extends le{get isActive(){return this._isActive&&this.debug.isConnected}set isActive(e){this._isActive!==e&&(this._isActive=e)}constructor(e){super(e,A.Fragment,!0,!0),this._isActive=!1,this.renderAlpha=!1,this.registerInput("debug",x.AutoDetect,!0),this.debug.excludedConnectionPointTypes.push(x.Matrix)}get _isFinalOutputAndActive(){return this.isActive}get _hasPrecedence(){return!0}get debug(){return this._inputs[0]}getClassName(){return"NodeMaterialDebugBlock"}_buildBlock(e){if(super._buildBlock(e),!this._isActive)return this;let t="gl_FragColor";e.shaderLanguage===1&&(t="fragmentOutputs.color");const i=this.debug;return i.connectedPoint?(i.connectedPoint.type===x.Float?e.compilationString+=`${t}  = vec4${e.fSuffix}(${i.associatedVariableName}, ${i.associatedVariableName}, ${i.associatedVariableName}, 1.0);
`:i.connectedPoint.type===x.Vector2?e.compilationString+=`${t}  = vec4${e.fSuffix}(${i.associatedVariableName}, 0., 1.0);
`:i.connectedPoint.type===x.Color3||i.connectedPoint.type===x.Vector3?e.compilationString+=`${t}  = vec4${e.fSuffix}(${i.associatedVariableName}, 1.0);
`:this.renderAlpha?e.compilationString+=`${t}  =${i.associatedVariableName};
`:e.compilationString+=`${t}  = vec4${e.fSuffix}(${i.associatedVariableName}.rgb, 1.0);
`,this):this}serialize(){const e=super.serialize();return e.isActive=this._isActive,e.renderAlpha=this.renderAlpha,e}_deserialize(e,t,i){super._deserialize(e,t,i),this.isActive=e.isActive,this.renderAlpha=e.renderAlpha}}C([U("Render Alpha",0,void 0)],oC.prototype,"renderAlpha",void 0);B("BABYLON.NodeMaterialDebugBlock",oC);var XS;(function(a){a[a.Created=1]="Created",a[a.Disposed=2]="Disposed",a[a.GetDefineNames=4]="GetDefineNames",a[a.PrepareUniformBuffer=8]="PrepareUniformBuffer",a[a.IsReadyForSubMesh=16]="IsReadyForSubMesh",a[a.PrepareDefines=32]="PrepareDefines",a[a.BindForSubMesh=64]="BindForSubMesh",a[a.PrepareEffect=128]="PrepareEffect",a[a.GetAnimatables=256]="GetAnimatables",a[a.GetActiveTextures=512]="GetActiveTextures",a[a.HasTexture=1024]="HasTexture",a[a.FillRenderTargetTextures=2048]="FillRenderTargetTextures",a[a.HasRenderTargetTextures=4096]="HasRenderTargetTextures",a[a.HardBindForSubMesh=8192]="HardBindForSubMesh"})(XS||(XS={}));class I2 extends ps{constructor(){super(...arguments),this.DECAL=!1,this.DECALDIRECTUV=0,this.DECAL_SMOOTHALPHA=!1,this.GAMMADECAL=!1}}class dl extends Qn{_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}isCompatible(){return!0}constructor(e,t=!0){super(e,"DecalMap",150,new I2,t),this._isEnabled=!1,this.isEnabled=!1,this._smoothAlpha=!1,this.smoothAlpha=!1,this.registerForExtraEvents=!0,this._internalMarkAllSubMeshesAsTexturesDirty=e._dirtyCallbacks[1]}isReadyForSubMesh(e,t,i,r){const s=r.getMesh().decalMap;return!this._isEnabled||!(s!=null&&s.texture)||!vr.DecalMapEnabled||!t.texturesEnabled?!0:s.isReady()}prepareDefinesBeforeAttributes(e,t,i){const r=i.decalMap;!this._isEnabled||!(r!=null&&r.texture)||!vr.DecalMapEnabled||!t.texturesEnabled?(e.DECAL&&e.markAsTexturesDirty(),e.DECAL=!1):((!e.DECAL||e.GAMMADECAL!==r.texture.gammaSpace)&&e.markAsTexturesDirty(),e.DECAL=!0,e.GAMMADECAL=r.texture.gammaSpace,e.DECAL_SMOOTHALPHA=this._smoothAlpha,Um(r.texture,e,"DECAL"))}hardBindForSubMesh(e,t,i,r){const s=r.getMesh().decalMap;if(!this._isEnabled||!(s!=null&&s.texture)||!vr.DecalMapEnabled||!t.texturesEnabled)return;const n=this._material.isFrozen,o=s.texture;(!e.useUbo||!n||!e.isSync)&&(e.updateFloat4("vDecalInfos",o.coordinatesIndex,0,0,0),Gm(o,e,"decal")),e.setTexture("decalSampler",o)}getClassName(){return"DecalMapConfiguration"}getSamplers(e){e.push("decalSampler")}getUniforms(){return{ubo:[{name:"vDecalInfos",size:4,type:"vec4"},{name:"decalMatrix",size:16,type:"mat4"}]}}}C([F(),Ue("_markAllSubMeshesAsTexturesDirty")],dl.prototype,"isEnabled",void 0);C([F(),Ue("_markAllSubMeshesAsTexturesDirty")],dl.prototype,"smoothAlpha",void 0);B("BABYLON.DecalMapConfiguration",dl);class Xt{}Xt.DEFAULT_COLOR=ne.White();Xt.DEFAULT_WIDTH_ATTENUATED=1;Xt.DEFAULT_WIDTH=.1;class Je{static ConvertPoints(e,t){if(e.length&&Array.isArray(e)&&typeof e[0]=="number")return[e];if(e.length&&Array.isArray(e[0])&&typeof e[0][0]=="number")return e;if(e.length&&!Array.isArray(e[0])&&e[0]instanceof m){const i=[];for(let r=0;r<e.length;r++){const s=e[r];i.push(s.x,s.y,s.z)}return[i]}else if(e.length>0&&Array.isArray(e[0])&&e[0].length>0&&e[0][0]instanceof m){const i=[];return e.forEach(s=>{i.push(s.flatMap(n=>[n.x,n.y,n.z]))}),i}else if(e instanceof Float32Array)if(t!=null&&t.floatArrayStride){const i=[],r=t.floatArrayStride*3;for(let s=0;s<e.length;s+=r){const n=new Array(r);for(let o=0;o<r;o++)n[o]=e[s+o];i.push(n)}return i}else return[Array.from(e)];else if(e.length&&e[0]instanceof Float32Array){const i=[];return e.forEach(r=>{i.push(Array.from(r))}),i}return[]}static OmitZeroLengthPredicate(e,t,i){const r=[];return t.subtract(e).lengthSquared()>0&&r.push([e,t]),i.subtract(t).lengthSquared()>0&&r.push([t,i]),e.subtract(i).lengthSquared()>0&&r.push([i,e]),r.length===0?null:r}static OmitDuplicatesPredicate(e,t,i,r){const s=[];return Je._SearchInPoints(e,t,r)||s.push([e,t]),Je._SearchInPoints(t,i,r)||s.push([t,i]),Je._SearchInPoints(i,e,r)||s.push([i,e]),s.length===0?null:s}static _SearchInPoints(e,t,i){var r,s,n;for(const o of i)for(let l=0;l<o.length;l++)if((r=o[l])!=null&&r.equals(e)&&((s=o[l+1])!=null&&s.equals(t)||(n=o[l-1])!=null&&n.equals(t)))return!0;return!1}static MeshesToLines(e,t){const i=[];return e.forEach((r,s)=>{const n=r.getVerticesData(N.PositionKind),o=r.getIndices();if(n&&o)for(let l=0,u=0;l<o.length;l++){const c=o[u++]*3,h=o[u++]*3,d=o[u++]*3,f=new m(n[c],n[c+1],n[c+2]),p=new m(n[h],n[h+1],n[h+2]),g=new m(n[d],n[d+1],n[d+2]);if(t){const _=t(f,p,g,i,l,c,r,s,n,o);if(_)for(const S of _)i.push(S)}else i.push([f,p],[p,g],[g,f])}}),i}static ToVector3Array(e){if(Array.isArray(e[0])){const r=[],s=e;for(const n of s){const o=[];for(let l=0;l<n.length;l+=3)o.push(new m(n[l],n[l+1],n[l+2]));r.push(o)}return r}const t=e,i=[];for(let r=0;r<t.length;r+=3)i.push(new m(t[r],t[r+1],t[r+2]));return i}static ToNumberArray(e){return e.flatMap(t=>[t.x,t.y,t.z])}static GetPointsCountInfo(e){const t=new Array(e.length);let i=0;for(let r=e.length;r--;)t[r]=e[r].length/3,i+=t[r];return{total:i,counts:t}}static GetLineLength(e){if(e.length===0)return 0;let t;typeof e[0]=="number"?t=Je.ToVector3Array(e):t=e;const i=V.Vector3[0];let r=0;for(let s=0;s<t.length-1;s++){const n=t[s],o=t[s+1];r+=o.subtractToRef(n,i).length()}return r}static GetLineLengthArray(e){const t=new Float32Array(e.length/3);let i=0;for(let r=0,s=e.length/3-1;r<s;r++){let n=e[r*3+0],o=e[r*3+1],l=e[r*3+2];n-=e[r*3+3],o-=e[r*3+4],l-=e[r*3+5];const u=Math.sqrt(n*n+o*o+l*l);i+=u,t[r+1]=i}return t}static SegmentizeSegmentByCount(e,t,i){const r=[],s=t.subtract(e),n=V.Vector3[0];n.setAll(i);const o=V.Vector3[1];s.divideToRef(n,o);let l=e.clone();r.push(l);for(let u=0;u<i;u++)l=l.clone(),r.push(l.addInPlace(o));return r}static SegmentizeLineBySegmentLength(e,t){const i=e[0]instanceof m?Je.GetLineSegments(e):typeof e[0]=="number"?Je.GetLineSegments(Je.ToVector3Array(e)):e,r=[];return i.forEach(s=>{s.length>t?Je.SegmentizeSegmentByCount(s.point1,s.point2,Math.ceil(s.length/t)).forEach(o=>{r.push(o)}):(r.push(s.point1),r.push(s.point2))}),r}static SegmentizeLineBySegmentCount(e,t){const i=typeof e[0]=="number"?Je.ToVector3Array(e):e,r=Je.GetLineLength(i)/t;return Je.SegmentizeLineBySegmentLength(i,r)}static GetLineSegments(e){const t=[];for(let i=0;i<e.length-1;i++){const r=e[i],s=e[i+1],n=s.subtract(r).length();t.push({point1:r,point2:s,length:n})}return t}static GetMinMaxSegmentLength(e){const i=Je.GetLineSegments(e).sort(r=>r.length);return{min:i[0].length,max:i[i.length-1].length}}static GetPositionOnLineByVisibility(e,t,i,r=!1){const s=t*i;let n=0,o=0;const l=e.length;for(let c=0;c<l;c++){if(s<=n+e[c].length){o=c;break}n+=e[c].length}const u=(s-n)/e[o].length;return e[o].point2.subtractToRef(e[o].point1,V.Vector3[0]),V.Vector3[1]=V.Vector3[0].multiplyByFloats(u,u,u),r||V.Vector3[1].addInPlace(e[o].point1),V.Vector3[1].clone()}static GetCircleLinePoints(e,t,i=0,r=e,s=Math.PI*2/t){const n=[];for(let o=0;o<=t;o++)n.push(new m(Math.cos(o*s)*e,Math.sin(o*s)*r,i));return n}static GetBezierLinePoints(e,t,i,r){return gy.CreateQuadraticBezier(e,t,i,r).getPoints().flatMap(s=>[s.x,s.y,s.z])}static GetArrowCap(e,t,i,r,s,n=0,o=0){return{points:[e.clone(),e.add(t.multiplyByFloats(i,i,i))],widths:[r,s,n,o]}}static GetPointsFromText(e,t,i,r,s=0,n=!0){const o=[],l=g0(e,t,i,r);for(const u of l){for(const c of u.paths){const h=[],d=c.getPoints();for(const f of d)h.push(f.x,f.y,s);o.push(h)}if(n)for(const c of u.holes){const h=[],d=c.getPoints();for(const f of d)h.push(f.x,f.y,s);o.push(h)}}return o}static Color3toRGBAUint8(e){const t=new Uint8Array(e.length*4);for(let i=0,r=0;i<e.length;i++)t[r++]=e[i].r*255,t[r++]=e[i].g*255,t[r++]=e[i].b*255,t[r++]=255;return t}static CreateColorsTexture(e,t,i,r){const s=r.getEngine().getCaps().maxTextureSize??1,n=t.length>s?s:t.length,o=Math.ceil(t.length/s);o>1&&(t=[...t,...Array(n*o-t.length).fill(t[0])]);const l=Je.Color3toRGBAUint8(t),u=new qt(l,n,o,mt.TEXTUREFORMAT_RGBA,r,!1,!0,i);return u.name=e,u}static PrepareEmptyColorsTexture(e){if(!Xt.EmptyColorsTexture){const t=new Uint8Array(4);Xt.EmptyColorsTexture=new qt(t,1,1,mt.TEXTUREFORMAT_RGBA,e,!1,!1,qt.NEAREST_NEAREST),Xt.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Xt.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var e;(e=Xt.EmptyColorsTexture)==null||e.dispose(),Xt.EmptyColorsTexture=null}static BooleanToNumber(e){return e?1:0}}function R2(a,e){if(a==="vertex"){const t={CUSTOM_VERTEX_DEFINITIONS:`
                attribute float grl_widths;
                attribute vec3 grl_offsets;
                attribute float grl_colorPointers;
                varying float grlCounters;
                varying float grlColorPointer;

                #ifdef GREASED_LINE_CAMERA_FACING
                    attribute vec4 grl_previousAndSide;
                    attribute vec4 grl_nextAndCounters;

                    vec2 grlFix( vec4 i, float aspect ) {
                        vec2 res = i.xy / i.w;
                        res.x *= aspect;
                        return res;
                    }
                #else
                    attribute vec3 grl_slopes;
                    attribute float grl_counters;
                #endif
                `,CUSTOM_VERTEX_UPDATE_POSITION:`
                #ifdef GREASED_LINE_CAMERA_FACING
                    vec3 grlPositionOffset = grl_offsets;
                    positionUpdated += grlPositionOffset;
                #else
                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);
                #endif
                `,CUSTOM_VERTEX_MAIN_END:`
                grlColorPointer = grl_colorPointers;

                #ifdef GREASED_LINE_CAMERA_FACING

                    float grlAspect = grl_aspect_resolution_lineWidth.x;
                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;

                    vec3 grlPrevious = grl_previousAndSide.xyz;
                    float grlSide = grl_previousAndSide.w;

                    vec3 grlNext = grl_nextAndCounters.xyz;
                    grlCounters = grl_nextAndCounters.w;
                    float grlWidth = grlBaseWidth * grl_widths;
                    
                    vec3 worldDir = normalize(grlNext - grlPrevious);
                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);
                    mat4 grlMatrix = viewProjection * finalWorld;
                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);
                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);
                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);
                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);
                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);

                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);

                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM
                        grlNormal.xy *= -.5 * grlWidth;
                    #else
                        grlNormal.xy *= .5 * grlWidth;
                    #endif

                    grlNormal *= grl_projection;

                    #ifdef GREASED_LINE_SIZE_ATTENUATION
                        grlNormal.xy *= grlFinalPosition.w;
                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;
                    #endif

                    grlFinalPosition.xy += grlNormal.xy * grlSide;
                    gl_Position = grlFinalPosition;

                    vPositionW = vec3(grlFinalPosition);
                #else
                    grlCounters = grl_counters;
                #endif
                `};return e&&(t["!gl_Position\\=viewProjection\\*worldPos;"]="//"),t}return a==="fragment"?{CUSTOM_FRAGMENT_DEFINITIONS:`
                    #ifdef PBR
                         #define grlFinalColor finalColor
                    #else
                         #define grlFinalColor color
                    #endif

                    varying float grlCounters;
                    varying float grlColorPointer;
                    uniform sampler2D grl_colors;
                `,CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:`
                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;
                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;
                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;
                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;

                    float grlUseDash = grl_dashOptions.x;
                    float grlDashArray = grl_dashOptions.y;
                    float grlDashOffset = grl_dashOptions.z;
                    float grlDashRatio = grl_dashOptions.w;

                    grlFinalColor.a *= step(grlCounters, grlVisibility);
                    if(grlFinalColor.a == 0.) discard;

                    if(grlUseDash == 1.){
                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));
                        if (grlFinalColor.a == 0.) discard;
                    }

                    #ifdef GREASED_LINE_HAS_COLOR
                        if (grlColorMode == 0.) {
                            grlFinalColor.rgb = grl_singleColor;
                        } else if (grlColorMode == 1.) {
                            grlFinalColor.rgb += grl_singleColor;
                        } else if (grlColorMode == 2.) {
                            grlFinalColor.rgb *= grl_singleColor;
                        }
                    #else
                        if (grlUseColors == 1.) {
                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE
                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);
                            #else
                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));
                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);
                            #endif
                            if (grlColorMode == 0.) {
                                grlFinalColor = grlColor;
                            } else if (grlColorMode == 1.) {
                                grlFinalColor += grlColor;
                            } else if (grlColorMode == 2.) {
                                grlFinalColor *= grlColor;
                            }
                        }
                    #endif
                `}:null}function M2(a,e){if(a==="vertex"){const t={CUSTOM_VERTEX_DEFINITIONS:`
                attribute grl_widths: f32;
                attribute grl_colorPointers: f32;
                varying grlCounters: f32;
                varying grlColorPointer: f32;

                #ifdef GREASED_LINE_USE_OFFSETS
                    attribute grl_offsets: vec3f;   
                #endif

                #ifdef GREASED_LINE_CAMERA_FACING
                    attribute grl_previousAndSide : vec4f;
                    attribute grl_nextAndCounters : vec4f;

                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {
                        var res = i.xy / i.w;
                        res.x *= aspect;
                        return res;
                    }
                #else
                    attribute grl_slopes: f32;
                    attribute grl_counters: f32;
                #endif


                `,CUSTOM_VERTEX_UPDATE_POSITION:`
                #ifdef GREASED_LINE_USE_OFFSETS
                    var grlPositionOffset: vec3f = input.grl_offsets;
                #else
                    var grlPositionOffset = vec3f(0.);
                #endif

                #ifdef GREASED_LINE_CAMERA_FACING
                    positionUpdated += grlPositionOffset;
                #else
                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);
                #endif
                `,CUSTOM_VERTEX_MAIN_END:`
                vertexOutputs.grlColorPointer = input.grl_colorPointers;

                #ifdef GREASED_LINE_CAMERA_FACING

                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;
                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;

                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;
                    let grlSide: f32 = input.grl_previousAndSide.w;

                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;
                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;

                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;

                    let worldDir: vec3f = normalize(grlNext - grlPrevious);
                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);
                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;
                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); 
                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);
                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);
                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);
                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);

                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);

                    let grlHalfWidth: f32 = 0.5 * grlWidth;
                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)
                        grlNormal.x *= -grlHalfWidth;
                        grlNormal.y *= -grlHalfWidth;
                    #else
                        grlNormal.x *= grlHalfWidth;
                        grlNormal.y *= grlHalfWidth;
                    #endif

                    grlNormal *= uniforms.grl_projection;

                    #if defined(GREASED_LINE_SIZE_ATTENUATION)
                        grlNormal.x *= grlFinalPosition.w;
                        grlNormal.y *= grlFinalPosition.w;

                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;
                        grlNormal.x /= pr.x;
                        grlNormal.y /= pr.y;
                    #endif

                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);
                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;
                
                #else
                    vertexOutputs.grlCounters = input.grl_counters;
                #endif
                `};return e&&(t["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),t}return a==="fragment"?{CUSTOM_FRAGMENT_DEFINITIONS:`
                    #ifdef PBR
                         #define grlFinalColor finalColor
                    #else
                         #define grlFinalColor color
                    #endif

                    varying grlCounters: f32;
                    varying grlColorPointer: 32;

                    var grl_colors: texture_2d<f32>;
                    var grl_colorsSampler: sampler;
                `,CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:`
                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;
                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;
                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;
                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;

                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;
                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;
                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;
                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;

                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);
                    if (grlFinalColor.a == 0.0) {
                        discard;
                    }

                    if (grlUseDash == 1.0) {
                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;
                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));

                        if (grlFinalColor.a == 0.0) {
                            discard;
                        }
                    }

                    #ifdef GREASED_LINE_HAS_COLOR
                        if (grlColorMode == 0.) {
                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);
                        } else if (grlColorMode == 1.) {
                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);
                        } else if (grlColorMode == 2.) {
                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);
                        }
                    #else
                        if (grlUseColors == 1.) {
                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE
                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));
                            #else
                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));
                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);
                            #endif
                            if (grlColorMode == 0.) {
                                grlFinalColor = grlColor;
                            } else if (grlColorMode == 1.) {
                                grlFinalColor += grlColor;
                            } else if (grlColorMode == 2.) {
                                grlFinalColor *= grlColor;
                            }
                        }
                    #endif


                `}:null}class A2 extends ps{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Gr extends Qn{isCompatible(e){return!0}constructor(e,t,i){i=i||{color:Xt.DEFAULT_COLOR};const r=new A2;r.GREASED_LINE_HAS_COLOR=!!i.color&&!i.useColors,r.GREASED_LINE_SIZE_ATTENUATION=i.sizeAttenuation??!1,r.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=i.colorDistributionType===1,r.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(t??e.getScene()).useRightHandedSystem,r.GREASED_LINE_CAMERA_FACING=i.cameraFacing??!0,super(e,Gr.GREASED_LINE_MATERIAL_NAME,200,r,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(i==null?void 0:i.forceGLSL)||Gr.ForceGLSL,this._scene=t??e.getScene(),this._engine=this._scene.getEngine(),this._cameraFacing=i.cameraFacing??!0,this.visibility=i.visibility??1,this.useDash=i.useDash??!1,this.dashRatio=i.dashRatio??.5,this.dashOffset=i.dashOffset??0,this.width=i.width?i.width:i.sizeAttenuation?Xt.DEFAULT_WIDTH_ATTENUATED:Xt.DEFAULT_WIDTH,this._sizeAttenuation=i.sizeAttenuation??!1,this.colorMode=i.colorMode??0,this._color=i.color??null,this.useColors=i.useColors??!1,this._colorsDistributionType=i.colorDistributionType??0,this.colorsSampling=i.colorsSampling??qt.NEAREST_NEAREST,this._colors=i.colors??null,this.dashCount=i.dashCount??1,this.resolution=i.resolution??new Q(this._engine.getRenderWidth(),this._engine.getRenderHeight()),i.colorsTexture?this.colorsTexture=i.colorsTexture:this._colors?this.colorsTexture=Je.CreateColorsTexture(`${e.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Xt.DEFAULT_COLOR,Je.PrepareEmptyColorsTexture(this._scene)),this._engine.onDisposeObservable.add(()=>{Je.DisposeEmptyColorsTexture()})}getAttributes(e){e.push("grl_offsets"),e.push("grl_widths"),e.push("grl_colorPointers"),e.push("grl_counters"),this._cameraFacing?(e.push("grl_previousAndSide"),e.push("grl_nextAndCounters")):e.push("grl_slopes")}getSamplers(e){e.push("grl_colors")}getActiveTextures(e){this.colorsTexture&&e.push(this.colorsTexture)}getUniforms(e=0){const t=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&t.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),e===1&&t.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:t,vertex:this._cameraFacing&&this._isGLSL(e)?`
                    uniform vec4 grl_aspect_resolution_lineWidth;
                    uniform mat4 grl_projection;
    `:"",fragment:this._isGLSL(e)?`
                    uniform vec4 grl_dashOptions;
                    uniform vec2 grl_textureSize;
                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;
                    uniform vec3 grl_singleColor;
    `:""}}get isEnabled(){return!0}bindForSubMesh(e){if(this._cameraFacing){e.updateMatrix("grl_projection",this._scene.getProjectionMatrix()),!this._isGLSL(this._material.shaderLanguage)&&e.updateMatrix("viewProjection",this._scene.getTransformMatrix());const s=V.Vector4[0];s.x=this._aspect,s.y=this._resolution.x,s.z=this._resolution.y,s.w=this.width,e.updateVector4("grl_aspect_resolution_lineWidth",s)}const t=V.Vector4[0];t.x=Je.BooleanToNumber(this.useDash),t.y=this._dashArray,t.z=this.dashOffset,t.w=this.dashRatio,e.updateVector4("grl_dashOptions",t);const i=V.Vector4[1];i.x=this.colorMode,i.y=this.visibility,i.z=this.colorsTexture?this.colorsTexture.getSize().width:0,i.w=Je.BooleanToNumber(this.useColors),e.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",i),this._color&&e.updateColor3("grl_singleColor",this._color);const r=this.colorsTexture??Xt.EmptyColorsTexture;e.setTexture("grl_colors",r),e.updateFloat2("grl_textureSize",(r==null?void 0:r.getSize().width)??1,(r==null?void 0:r.getSize().height)??1)}prepareDefines(e,t,i){e.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,e.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,e.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=this._colorsDistributionType===1,e.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=t.useRightHandedSystem,e.GREASED_LINE_CAMERA_FACING=this._cameraFacing,e.GREASED_LINE_USE_OFFSETS=!!i.offsets}getClassName(){return Gr.GREASED_LINE_MATERIAL_NAME}getCustomCode(e,t=0){return this._isGLSL(t)?R2(e,this._cameraFacing):M2(e,this._cameraFacing)}dispose(){var e;(e=this.colorsTexture)==null||e.dispose(),super.dispose()}get colors(){return this._colors}set colors(e){this.setColors(e)}setColors(e,t=!1,i=!1){var s,n,o;const r=((s=this._colors)==null?void 0:s.length)??0;if(this._colors=e,e===null||e.length===0){(n=this.colorsTexture)==null||n.dispose();return}if(!(t&&!i))if(this.colorsTexture&&r===e.length&&!i){const l=Je.Color3toRGBAUint8(e);this.colorsTexture.update(l)}else(o=this.colorsTexture)==null||o.dispose(),this.colorsTexture=Je.CreateColorsTexture(`${this._material.name}-colors-texture`,e,this.colorsSampling,this._scene)}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(e){this._dashCount=e,this._dashArray=1/e}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(e){this._sizeAttenuation=e,this.markAllDefinesAsDirty()}get color(){return this._color}set color(e){this.setColor(e)}setColor(e,t=!1){this._color===null&&e!==null||this._color!==null&&e===null?(this._color=e,!t&&this.markAllDefinesAsDirty()):this._color=e}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(e){this._colorsDistributionType=e,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(e){this._aspect=e.x/e.y,this._resolution=e}serialize(){const e=super.serialize(),t={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(t.colors=this._colors),this._color&&(t.color=this._color),e.greasedLineMaterialOptions=t,e}parse(e,t,i){var s;super.parse(e,t,i);const r=e.greasedLineMaterialOptions;(s=this.colorsTexture)==null||s.dispose(),r.color&&this.setColor(r.color,!0),r.colorDistributionType&&(this.colorsDistributionType=r.colorDistributionType),r.colors&&(this.colors=r.colors),r.colorsSampling&&(this.colorsSampling=r.colorsSampling),r.colorMode&&(this.colorMode=r.colorMode),r.useColors&&(this.useColors=r.useColors),r.visibility&&(this.visibility=r.visibility),r.useDash&&(this.useDash=r.useDash),r.dashCount&&(this.dashCount=r.dashCount),r.dashRatio&&(this.dashRatio=r.dashRatio),r.dashOffset&&(this.dashOffset=r.dashOffset),r.width&&(this.width=r.width),r.sizeAttenuation&&(this.sizeAttenuation=r.sizeAttenuation),r.resolution&&(this.resolution=r.resolution),this.colors?this.colorsTexture=Je.CreateColorsTexture(`${this._material.name}-colors-texture`,this.colors,this.colorsSampling,t):Je.PrepareEmptyColorsTexture(t),this.markAllDefinesAsDirty()}copyTo(e){var i;const t=e;(i=t.colorsTexture)==null||i.dispose(),this._colors&&(t.colorsTexture=Je.CreateColorsTexture(`${t._material.name}-colors-texture`,this._colors,t.colorsSampling,this._scene)),t.setColor(this.color,!0),t.colorsDistributionType=this.colorsDistributionType,t.colorsSampling=this.colorsSampling,t.colorMode=this.colorMode,t.useColors=this.useColors,t.visibility=this.visibility,t.useDash=this.useDash,t.dashCount=this.dashCount,t.dashRatio=this.dashRatio,t.dashOffset=this.dashOffset,t.width=this.width,t.sizeAttenuation=this.sizeAttenuation,t.resolution=this.resolution,t.markAllDefinesAsDirty()}_isGLSL(e){return e===0||this._forceGLSL}}Gr.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial";Gr.ForceGLSL=!1;B(`BABYLON.${Gr.GREASED_LINE_MATERIAL_NAME}`,Gr);const D2="GREASED_LINE_USE_OFFSETS";class za extends Wr{constructor(e,t,i){const r=t.getEngine(),s=r.isWebGPU&&!(i.forceGLSL||za.ForceGLSL),n=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];t.useRightHandedSystem&&n.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const o=["position","grl_widths","grl_offsets","grl_colorPointers"];i.cameraFacing?(n.push("GREASED_LINE_CAMERA_FACING"),o.push("grl_previousAndSide","grl_nextAndCounters")):(o.push("grl_slopes"),o.push("grl_counters"));const l=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(s||l.push("world","viewProjection","view","projection"),super(e,t,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:s?["Scene","Mesh"]:void 0,attributes:o,uniforms:l,samplers:s?[]:["grlColors"],defines:n,extraInitializationsAsync:async()=>{s?await Promise.all([k(()=>Promise.resolve().then(()=>q2),void 0),k(()=>Promise.resolve().then(()=>X2),void 0)]):await Promise.all([k(()=>Promise.resolve().then(()=>j2),void 0),k(()=>Promise.resolve().then(()=>$2),void 0)])},shaderLanguage:s?1:0}),this._color=ne.White(),this._colorsDistributionType=0,this._colorsTexture=null,i=i||{color:Xt.DEFAULT_COLOR},this.visibility=i.visibility??1,this.useDash=i.useDash??!1,this.dashRatio=i.dashRatio??.5,this.dashOffset=i.dashOffset??0,this.dashCount=i.dashCount??1,this.width=i.width?i.width:i.sizeAttenuation&&i.cameraFacing?Xt.DEFAULT_WIDTH_ATTENUATED:Xt.DEFAULT_WIDTH,this.sizeAttenuation=i.sizeAttenuation??!1,this.color=i.color??ne.White(),this.useColors=i.useColors??!1,this.colorsDistributionType=i.colorDistributionType??0,this.colorsSampling=i.colorsSampling??qt.NEAREST_NEAREST,this.colorMode=i.colorMode??0,this._colors=i.colors??null,this._cameraFacing=i.cameraFacing??!0,this.resolution=i.resolution??new Q(r.getRenderWidth(),r.getRenderHeight()),i.colorsTexture?this.colorsTexture=i.colorsTexture:this._colors?this.colorsTexture=Je.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,t):(this._color=this._color??Xt.DEFAULT_COLOR,this.colorsTexture=Je.PrepareEmptyColorsTexture(t)),s){const u=new Jb;u.setParameters(),u.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",u)}r.onDisposeObservable.add(()=>{Je.DisposeEmptyColorsTexture()})}dispose(){var e;(e=this._colorsTexture)==null||e.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new Q(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get colors(){return this._colors}set colors(e){this.setColors(e)}setColors(e,t=!1,i=!1){var s,n,o;const r=((s=this._colors)==null?void 0:s.length)??0;if(this._colors=e,e===null||e.length===0){(n=this._colorsTexture)==null||n.dispose();return}if(!(t&&!i))if(this._colorsTexture&&r===e.length&&!i){const l=Je.Color3toRGBAUint8(e);this._colorsTexture.update(l)}else(o=this._colorsTexture)==null||o.dispose(),this.colorsTexture=Je.CreateColorsTexture(`${this.name}-colors-texture`,e,this.colorsSampling,this.getScene())}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(e){this._colorsTexture=e,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(e){this._width=e,this.setFloat("grlWidth",e)}get useColors(){return this._useColors}set useColors(e){this._useColors=e,this.setFloat("grlUseColors",Je.BooleanToNumber(e))}get colorsSampling(){return this._colorsSampling}set colorsSampling(e){this._colorsSampling=e}get visibility(){return this._visibility}set visibility(e){this._visibility=e,this.setFloat("grlVisibility",e)}get useDash(){return this._useDash}set useDash(e){this._useDash=e,this.setFloat("grlUseDash",Je.BooleanToNumber(e))}get dashOffset(){return this._dashOffset}set dashOffset(e){this._dashOffset=e,this.setFloat("grlDashOffset",e)}get dashRatio(){return this._dashRatio}set dashRatio(e){this._dashRatio=e,this.setFloat("grlDashRatio",e)}get dashCount(){return this._dashCount}set dashCount(e){this._dashCount=e,this._dashArray=1/e,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(e){this._sizeAttenuation=e,this.setFloat("grlSizeAttenuation",Je.BooleanToNumber(e))}get color(){return this._color}set color(e){this.setColor(e)}setColor(e){e=e??Xt.DEFAULT_COLOR,this._color=e,this.setColor3("grlColor",e)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(e){this._colorsDistributionType=e,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(e){this._colorMode=e,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(e){this._resolution=e,this.setVector2("grlResolution",e),this.setFloat("grlAspect",e.x/e.y)}serialize(){const e=super.serialize(),t={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(t.colors=this._colors),e.greasedLineMaterialOptions=t,e}parse(e,t,i){var s;const r=e.greasedLineMaterialOptions;(s=this._colorsTexture)==null||s.dispose(),r.color&&(this.color=r.color),r.colorDistributionType&&(this.colorsDistributionType=r.colorDistributionType),r.colorsSampling&&(this.colorsSampling=r.colorsSampling),r.colorMode&&(this.colorMode=r.colorMode),r.useColors&&(this.useColors=r.useColors),r.visibility&&(this.visibility=r.visibility),r.useDash&&(this.useDash=r.useDash),r.dashCount&&(this.dashCount=r.dashCount),r.dashRatio&&(this.dashRatio=r.dashRatio),r.dashOffset&&(this.dashOffset=r.dashOffset),r.width&&(this.width=r.width),r.sizeAttenuation&&(this.sizeAttenuation=r.sizeAttenuation),r.resolution&&(this.resolution=r.resolution),r.colors?this.colorsTexture=Je.CreateColorsTexture(`${this.name}-colors-texture`,r.colors,this.colorsSampling,this.getScene()):this.colorsTexture=Je.PrepareEmptyColorsTexture(t),this._cameraFacing=r.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}za.ForceGLSL=!1;var ZS;(function(a){a[a.MATERIAL_TYPE_STANDARD=0]="MATERIAL_TYPE_STANDARD",a[a.MATERIAL_TYPE_PBR=1]="MATERIAL_TYPE_PBR",a[a.MATERIAL_TYPE_SIMPLE=2]="MATERIAL_TYPE_SIMPLE"})(ZS||(ZS={}));var qS;(function(a){a[a.COLOR_MODE_SET=0]="COLOR_MODE_SET",a[a.COLOR_MODE_ADD=1]="COLOR_MODE_ADD",a[a.COLOR_MODE_MULTIPLY=2]="COLOR_MODE_MULTIPLY"})(qS||(qS={}));var QS;(function(a){a[a.COLOR_DISTRIBUTION_TYPE_SEGMENT=0]="COLOR_DISTRIBUTION_TYPE_SEGMENT",a[a.COLOR_DISTRIBUTION_TYPE_LINE=1]="COLOR_DISTRIBUTION_TYPE_LINE"})(QS||(QS={}));const O2=`#if defined(DBG_ENABLED)
attribute float dbg_initialPass;
varying vec3 dbg_vBarycentric;
flat varying vec3 dbg_vVertexWorldPos;
flat varying float dbg_vPass;
#endif`,w2=`#if defined(DBG_ENABLED)
attribute dbg_initialPass: f32;
varying dbg_vBarycentric: vec3f;
varying dbg_vVertexWorldPos: vec3f;
varying dbg_vPass: f32;
#endif`,N2=`#if defined(DBG_ENABLED)
float dbg_vertexIndex = mod(float(gl_VertexID), 3.);
if (dbg_vertexIndex == 0.0) { 
    dbg_vBarycentric = vec3(1.,0.,0.); 
}
else if (dbg_vertexIndex == 1.0) { 
    dbg_vBarycentric = vec3(0.,1.,0.); 
}
else { 
    dbg_vBarycentric = vec3(0.,0.,1.); 
}

dbg_vVertexWorldPos = vPositionW;
dbg_vPass = dbg_initialPass;
#endif`,F2=`#if defined(DBG_ENABLED)
var dbg_vertexIndex = f32(input.vertexIndex) % 3.;
if (dbg_vertexIndex == 0.0) { 
    vertexOutputs.dbg_vBarycentric = vec3f(1.,0.,0.); 
}
else if (dbg_vertexIndex == 1.0) { 
    vertexOutputs.dbg_vBarycentric = vec3f(0.,1.,0.); 
}
else { 
    vertexOutputs.dbg_vBarycentric = vec3f(0.,0.,1.); 
}

vertexOutputs.dbg_vVertexWorldPos = vertexOutputs.vPositionW;
vertexOutputs.dbg_vPass = input.dbg_initialPass;
#endif`,L2=`#if defined(DBG_ENABLED)
uniform vec3 dbg_shadedDiffuseColor;
uniform vec4 dbg_shadedSpecularColorPower;
uniform vec3 dbg_thicknessRadiusScale;

#if DBG_MODE == 2 || DBG_MODE == 3
    uniform vec3 dbg_vertexColor;
#endif

#if DBG_MODE == 1
    uniform vec3 dbg_wireframeTrianglesColor;
#elif DBG_MODE == 3
    uniform vec3 dbg_wireframeVerticesColor;
#elif DBG_MODE == 4 || DBG_MODE == 5
    uniform vec3 dbg_uvPrimaryColor;
    uniform vec3 dbg_uvSecondaryColor;
#elif DBG_MODE == 7
    uniform vec3 dbg_materialColor;
#endif
#endif`,B2=`#if defined(DBG_ENABLED)
uniform dbg_shadedDiffuseColor: vec3f;
uniform dbg_shadedSpecularColorPower: vec4f;
uniform dbg_thicknessRadiusScale: vec3f;

#if DBG_MODE == 2 || DBG_MODE == 3
    uniform dbg_vertexColor: vec3f;
#endif

#if DBG_MODE == 1
    uniform dbg_wireframeTrianglesColor: vec3f;
#elif DBG_MODE == 3
    uniform  dbg_wireframeVerticesColor: vec3f;
#elif DBG_MODE == 4 || DBG_MODE == 5
    uniform dbg_uvPrimaryColor: vec3f;
    uniform dbg_uvSecondaryColor: vec3f;
#elif DBG_MODE == 7
    uniform dbg_materialColor: vec3f;
#endif
#endif`,V2=`#if defined(DBG_ENABLED)
varying vec3 dbg_vBarycentric;
flat varying vec3 dbg_vVertexWorldPos;
flat varying float dbg_vPass;

#if !defined(DBG_MULTIPLY)
    vec3 dbg_applyShading(vec3 color) {
        vec3 N = vNormalW.xyz;
        vec3 L = normalize(vEyePosition.xyz - vPositionW.xyz);
        vec3 H = normalize(L + L);
        float LdotN = clamp(dot(L,N), 0., 1.);
        float HdotN = clamp(dot(H,N), 0., 1.);
        float specTerm = pow(HdotN, dbg_shadedSpecularColorPower.w);
        color *= (LdotN / PI);
        color += dbg_shadedSpecularColorPower.rgb * (specTerm / PI);
        return color;
    }
#endif

#if DBG_MODE == 1 || DBG_MODE == 3
    float dbg_edgeFactor() {
        vec3 d = fwidth(dbg_vBarycentric);
        vec3 a3 = smoothstep(vec3(0.), d * dbg_thicknessRadiusScale.x, dbg_vBarycentric);
        return min(min(a3.x, a3.y), a3.z);
    }
#endif

#if DBG_MODE == 2 || DBG_MODE == 3
    float dbg_cornerFactor() {
        vec3 worldPos = vPositionW;
        float dist = length(worldPos - dbg_vVertexWorldPos);
        float camDist = length(worldPos - vEyePosition.xyz);
        float d = sqrt(camDist) * .001;
        return smoothstep((dbg_thicknessRadiusScale.y * d), ((dbg_thicknessRadiusScale.y * 1.01) * d), dist);
    }
#endif

#if (DBG_MODE == 4 && defined(UV1)) || (DBG_MODE == 5 && defined(UV2))
    float dbg_checkerboardFactor(vec2 uv) {
        vec2 f = fract(uv * dbg_thicknessRadiusScale.z);
        f -= .5;
        return (f.x * f.y) > 0. ? 1. : 0.;
    }
#endif
#endif`,k2=`#if defined(DBG_ENABLED)
varying dbg_vBarycentric: vec3f;
varying dbg_vVertexWorldPos: vec3f;
varying dbg_vPass: f32;

#if !defined(DBG_MULTIPLY)
    fn dbg_applyShading(color: vec3f) -> vec3f {
        var N = fragmentInputs.vNormalW.xyz;
        var L = normalize(scene.vEyePosition.xyz - fragmentInputs.vPositionW.xyz);
        var H = normalize(L + L);
        var LdotN = clamp(dot(L,N), 0., 1.);
        var HdotN = clamp(dot(H,N), 0., 1.);
        var specTerm = pow(HdotN, uniforms.dbg_shadedSpecularColorPower.w);
        var result = color * (LdotN / PI);
        result += uniforms.dbg_shadedSpecularColorPower.rgb * (specTerm / PI);
        return result;
    }
#endif

#if DBG_MODE == 1 || DBG_MODE == 3
    fn dbg_edgeFactor() -> f32 {
        var d = fwidth(fragmentInputs.dbg_vBarycentric);
        var a3 = smoothstep(vec3f(0.), d * uniforms.dbg_thicknessRadiusScale.x, fragmentInputs.dbg_vBarycentric);
        return min(min(a3.x, a3.y), a3.z);
    }
#endif

#if DBG_MODE == 2 || DBG_MODE == 3
    fn dbg_cornerFactor() -> f32 {
        var worldPos = fragmentInputs.vPositionW;
        float dist = length(worldPos - fragmentInputs.dbg_vVertexWorldPos);
        float camDist = length(worldPos - scene.vEyePosition.xyz);
        float d = sqrt(camDist) * .001;
        return smoothstep((uniforms.dbg_thicknessRadiusScale.y * d), ((uniforms.dbg_thicknessRadiusScale.y * 1.01) * d), dist);
    }
#endif

#if (DBG_MODE == 4 && defined(UV1)) || (DBG_MODE == 5 && defined(UV2))
    fn dbg_checkerboardFactor(uv: vec2f) -> f32 {
        var f = fract(uv * uniforms.dbg_thicknessRadiusScale.z);
        f -= .5;
        return (f.x * f.y) > 0. ? 1. : 0.;
    }
#endif
#endif`,z2=`#if defined(DBG_ENABLED)
vec3 dbg_color = vec3(1.);
#if DBG_MODE == 1
    dbg_color = mix(dbg_wireframeTrianglesColor, vec3(1.), dbg_edgeFactor());
#elif DBG_MODE == 2 || DBG_MODE == 3
    float dbg_cornerFactor = dbg_cornerFactor();
    if (dbg_vPass == 0. && dbg_cornerFactor == 1.) discard;
    dbg_color = mix(dbg_vertexColor, vec3(1.), dbg_cornerFactor);
    #if DBG_MODE == 3
        dbg_color *= mix(dbg_wireframeVerticesColor, vec3(1.), dbg_edgeFactor());
    #endif
#elif DBG_MODE == 4 && defined(MAINUV1)
    dbg_color = mix(dbg_uvPrimaryColor, dbg_uvSecondaryColor, dbg_checkerboardFactor(vMainUV1));
#elif DBG_MODE == 5 && defined(MAINUV2)
    dbg_color = mix(dbg_uvPrimaryColor, dbg_uvSecondaryColor, dbg_checkerboardFactor(vMainUV2));
#elif DBG_MODE == 6 && defined(VERTEXCOLOR)
    dbg_color = vColor.rgb;
#elif DBG_MODE == 7
    dbg_color = dbg_materialColor;
#endif

#if defined(DBG_MULTIPLY)
    gl_FragColor *= vec4(dbg_color, 1.);
#else
    #if DBG_MODE != 6
        gl_FragColor = vec4(dbg_applyShading(dbg_shadedDiffuseColor) * dbg_color, 1.);
    #else
        gl_FragColor = vec4(dbg_color, 1.);
    #endif
#endif
#endif`,U2=`#if defined(DBG_ENABLED)
var dbg_color = vec3f(1.);
#if DBG_MODE == 1
    dbg_color = mix(uniforms.dbg_wireframeTrianglesColor, vec3f(1.), dbg_edgeFactor());
#elif DBG_MODE == 2 || DBG_MODE == 3
    var dbg_cornerFactor = dbg_cornerFactor();
    if (fragmentInputs.dbg_vPass == 0. && dbg_cornerFactor == 1.) discard;
    dbg_color = mix(uniforms.dbg_vertexColor, vec3(1.), dbg_cornerFactor);
    #if DBG_MODE == 3
        dbg_color *= mix(uniforms.dbg_wireframeVerticesColor, vec3f(1.), dbg_edgeFactor());
    #endif
#elif DBG_MODE == 4 && defined(MAINUV1)
    dbg_color = mix(uniforms.dbg_uvPrimaryColor, uniforms.dbg_uvSecondaryColor, dbg_checkerboardFactor(fragmentInputs.vMainUV1));
#elif DBG_MODE == 5 && defined(MAINUV2)
    dbg_color = mix(uniforms.dbg_uvPrimaryColor, uniforms.dbg_uvSecondaryColor, dbg_checkerboardFactor(fragmentInputs.vMainUV2));
#elif DBG_MODE == 6 && defined(VERTEXCOLOR)
    dbg_color = fragmentInputs.vColor.rgb;
#elif DBG_MODE == 7
    dbg_color = uniforms.dbg_materialColor;
#endif

#if defined(DBG_MULTIPLY)
    fragmentOutputs.color *= vec4f(dbg_color, 1.);
#else
    #if DBG_MODE != 6
        fragmentOutputs.color = vec4f(dbg_applyShading(dbg_shadedDiffuseColor) * dbg_color, 1.);
    #else
        fragmentOutputs.color = vec4f(dbg_color, 1.);
    #endif
#endif
#endif`,lC=[new ne(.98,.26,.38),new ne(.47,.75,.3),new ne(0,.26,.77),new ne(.97,.6,.76),new ne(.19,.63,.78),new ne(.98,.8,.6),new ne(.65,.43,.15),new ne(.15,.47,.22),new ne(.67,.71,.86),new ne(.09,.46,.56),new ne(.8,.98,.02),new ne(.39,.29,.13),new ne(.53,.63,.06),new ne(.95,.96,.41),new ne(1,.72,.94),new ne(.63,.08,.31),new ne(.66,.96,.95),new ne(.22,.14,.19),new ne(.14,.65,.59),new ne(.93,1,.68),new ne(.93,.14,.44),new ne(.47,.86,.67),new ne(.85,.07,.78),new ne(.53,.64,.98),new ne(.43,.37,.56),new ne(.71,.65,.25),new ne(.66,.19,.01),new ne(.94,.53,.12),new ne(.41,.44,.44),new ne(.24,.71,.96),new ne(.57,.28,.56),new ne(.44,.98,.42)];var KS;(function(a){a[a.NONE=0]="NONE",a[a.TRIANGLES=1]="TRIANGLES",a[a.VERTICES=2]="VERTICES",a[a.TRIANGLES_VERTICES=3]="TRIANGLES_VERTICES",a[a.UV0=4]="UV0",a[a.UV1=5]="UV1",a[a.VERTEXCOLORS=6]="VERTEXCOLORS",a[a.MATERIALIDS=7]="MATERIALIDS"})(KS||(KS={}));class G2 extends ps{constructor(){super(...arguments),this.DBG_MODE=0,this.DBG_MULTIPLY=!0,this.DBG_ENABLED=!0}}class ei extends Qn{_markAllDefinesAsDirty(){this._enable(this._isEnabled),this.markAllDefinesAsDirty()}isCompatible(e){switch(e){case 0:case 1:return!0;default:return!1}}constructor(e,t={}){const i=new G2;i.DBG_MODE=t.mode??i.DBG_MODE,i.DBG_MULTIPLY=t.multiply??i.DBG_MULTIPLY,super(e,"MeshDebug",200,i,!0,!0),this._mode=i.DBG_MODE,this._multiply=i.DBG_MULTIPLY,this.shadedDiffuseColor=t.shadedDiffuseColor??new ne(1,1,1),this.shadedSpecularColor=t.shadedSpecularColor??new ne(.8,.8,.8),this.shadedSpecularPower=t.shadedSpecularPower??10,this.wireframeThickness=t.wireframeThickness??.7,this.wireframeTrianglesColor=t.wireframeTrianglesColor??new ne(0,0,0),this.wireframeVerticesColor=t.wireframeVerticesColor??new ne(.8,.8,.8),this.vertexColor=t.vertexColor??new ne(0,0,0),this.vertexRadius=t.vertexRadius??1.2,this.uvScale=t.uvScale??20,this.uvPrimaryColor=t.uvPrimaryColor??new ne(1,1,1),this.uvSecondaryColor=t.uvSecondaryColor??new ne(.5,.5,.5),this._materialColor=ei.MaterialColors[ei._PluginCount++%ei.MaterialColors.length],this.isEnabled=!0}getClassName(){return"MeshDebugPluginMaterial"}get isEnabled(){return this._isEnabled}set isEnabled(e){if(this._isEnabled!==e){if(!this._material.getScene().getEngine().isWebGPU&&this._material.getScene().getEngine().version==1){L.Error("MeshDebugPluginMaterial is not supported on WebGL 1.0."),this._isEnabled=!1;return}this._isEnabled=e,this._markAllDefinesAsDirty()}}prepareDefines(e,t,i){(this._mode==2||this._mode==1||this._mode==3)&&!i.isVerticesDataPresent("dbg_initialPass")&&L.Warn("For best results with TRIANGLES, TRIANGLES_VERTICES, or VERTICES modes, please use MeshDebugPluginMaterial.PrepareMeshForTrianglesAndVerticesMode() on mesh.",1),e.DBG_MODE=this._mode,e.DBG_MULTIPLY=this._multiply,e.DBG_ENABLED=this._isEnabled}getAttributes(e){e.push("dbg_initialPass")}getUniforms(e=0){return{ubo:[{name:"dbg_shadedDiffuseColor",size:3,type:"vec3"},{name:"dbg_shadedSpecularColorPower",size:4,type:"vec4"},{name:"dbg_thicknessRadiusScale",size:3,type:"vec3"},{name:"dbg_wireframeTrianglesColor",size:3,type:"vec3"},{name:"dbg_wireframeVerticesColor",size:3,type:"vec3"},{name:"dbg_vertexColor",size:3,type:"vec3"},{name:"dbg_uvPrimaryColor",size:3,type:"vec3"},{name:"dbg_uvSecondaryColor",size:3,type:"vec3"},{name:"dbg_materialColor",size:3,type:"vec3"}],fragment:e===0?L2:B2}}bindForSubMesh(e){this._isEnabled&&(e.updateFloat3("dbg_shadedDiffuseColor",this.shadedDiffuseColor.r,this.shadedDiffuseColor.g,this.shadedDiffuseColor.b),e.updateFloat4("dbg_shadedSpecularColorPower",this.shadedSpecularColor.r,this.shadedSpecularColor.g,this.shadedSpecularColor.b,this.shadedSpecularPower),e.updateFloat3("dbg_thicknessRadiusScale",this.wireframeThickness,this.vertexRadius,this.uvScale),e.updateColor3("dbg_wireframeTrianglesColor",this.wireframeTrianglesColor),e.updateColor3("dbg_wireframeVerticesColor",this.wireframeVerticesColor),e.updateColor3("dbg_vertexColor",this.vertexColor),e.updateColor3("dbg_uvPrimaryColor",this.uvPrimaryColor),e.updateColor3("dbg_uvSecondaryColor",this.uvSecondaryColor),e.updateColor3("dbg_materialColor",this._materialColor))}getCustomCode(e,t=0){return t===1?e==="vertex"?{CUSTOM_VERTEX_DEFINITIONS:w2,CUSTOM_VERTEX_MAIN_END:F2}:{CUSTOM_FRAGMENT_DEFINITIONS:k2,CUSTOM_FRAGMENT_MAIN_END:U2}:e==="vertex"?{CUSTOM_VERTEX_DEFINITIONS:O2,CUSTOM_VERTEX_MAIN_END:N2}:{CUSTOM_FRAGMENT_DEFINITIONS:V2,CUSTOM_FRAGMENT_MAIN_END:z2}}static Reset(){this._PluginCount=0,this.MaterialColors=lC}static PrepareMeshForTrianglesAndVerticesMode(e,t=!1){let i=()=>{};if(e.getTotalIndices()==0)return i;if(t){const c=e.getVerticesDataKinds(),h=e.getIndices(),d={};for(const f of c)d[f]=e.getVerticesData(f);i=function(){e.setIndices(h);for(const f of c){const p=e.getVertexBuffer(f).getStrideSize();e.setVerticesData(f,d[f],void 0,p)}e.removeVerticesData("dbg_initialPass")}}let r=Array.from(e.getIndices());const s=[];for(let c=0;c<r.length;c+=3)s.push(r[c+1],r[c+2],r[c+0]);e.setIndices(r.concat(s)),e.convertToUnIndexedMesh(),e.isUnIndexed=!1,r=Array.from(e.getIndices());const n=[];for(let c=r.length/2;c<r.length;c+=3)n.push(r[c+1],r[c+2],r[c+0]);e.setIndices(r.concat(n));const o=e.getTotalVertices(),l=o/2,u=new Array(o).fill(1,0,l).fill(0,l,o);return e.setVerticesData("dbg_initialPass",u,!1,1),i}}ei._PluginCount=0;ei.MaterialColors=lC;C([ir()],ei.prototype,"_materialColor",void 0);C([F()],ei.prototype,"_isEnabled",void 0);C([F(),Ue("_markAllDefinesAsDirty")],ei.prototype,"mode",void 0);C([F(),Ue("_markAllDefinesAsDirty")],ei.prototype,"multiply",void 0);C([ir()],ei.prototype,"shadedDiffuseColor",void 0);C([ir()],ei.prototype,"shadedSpecularColor",void 0);C([F()],ei.prototype,"shadedSpecularPower",void 0);C([F()],ei.prototype,"wireframeThickness",void 0);C([ir()],ei.prototype,"wireframeTrianglesColor",void 0);C([ir()],ei.prototype,"wireframeVerticesColor",void 0);C([ir()],ei.prototype,"vertexColor",void 0);C([F()],ei.prototype,"vertexRadius",void 0);C([F()],ei.prototype,"uvScale",void 0);C([ir()],ei.prototype,"uvPrimaryColor",void 0);C([ir()],ei.prototype,"uvSecondaryColor",void 0);B("BABYLON.MeshDebugPluginMaterial",ei);Object.defineProperty(Ut.prototype,"decalMap",{get:function(){if(!this._decalMap){if(this._uniformBufferLayoutBuilt)return null;this._decalMap=new dl(this)}return this._decalMap},enumerable:!0,configurable:!0});Object.defineProperty(hr.prototype,"decalMap",{get:function(){if(!this._decalMap){if(this._uniformBufferLayoutBuilt)return null;this._decalMap=new dl(this)}return this._decalMap},enumerable:!0,configurable:!0});Object.defineProperty(Rt.prototype,"decalMap",{get:function(){return this._decalMap},set:function(a){this._decalMap=a},enumerable:!0,configurable:!0});const cd="greasedLinePixelShader",uC=`precision highp float;uniform sampler2D grlColors;uniform float grlUseColors;uniform float grlUseDash;uniform float grlDashArray;uniform float grlDashOffset;uniform float grlDashRatio;uniform float grlVisibility;uniform float grlColorsWidth;uniform vec2 grl_colorModeAndColorDistributionType;uniform vec3 grlColor;varying float grlCounters;varying float grlColorPointer;void main() {float grlColorMode=grl_colorModeAndColorDistributionType.x;float grlColorDistributionType=grl_colorModeAndColorDistributionType.y;gl_FragColor=vec4(grlColor,1.);gl_FragColor.a=step(grlCounters,grlVisibility);if (gl_FragColor.a==0.) discard;if( grlUseDash==1. ){gl_FragColor.a=ceil(mod(grlCounters+grlDashOffset,grlDashArray)-(grlDashArray*grlDashRatio));if (gl_FragColor.a==0.) discard;}
if (grlUseColors==1.) {vec4 textureColor;if (grlColorDistributionType==COLOR_DISTRIBUTION_TYPE_LINE) { 
textureColor=texture2D(grlColors,vec2(grlCounters,0.),0.);} else {textureColor=texture2D(grlColors,vec2(grlColorPointer/grlColorsWidth,0.),0.);}
if (grlColorMode==COLOR_MODE_SET) {gl_FragColor=textureColor;} else if (grlColorMode==COLOR_MODE_ADD) {gl_FragColor+=textureColor;} else if (grlColorMode==COLOR_MODE_MULTIPLY) {gl_FragColor*=textureColor;}}}
`;P.ShadersStore[cd]||(P.ShadersStore[cd]=uC);const W2={name:cd,shader:uC},$2=Object.freeze(Object.defineProperty({__proto__:null,greasedLinePixelShader:W2},Symbol.toStringTag,{value:"Module"})),hd="greasedLineVertexShader",cC=`precision highp float;
#include<instancesDeclaration>
attribute float grl_widths;attribute vec3 grl_offsets;attribute float grl_colorPointers;attribute vec3 position;uniform mat4 viewProjection;uniform mat4 projection;varying float grlCounters;varying float grlColorPointer;
#ifdef GREASED_LINE_CAMERA_FACING
attribute vec4 grl_nextAndCounters;attribute vec4 grl_previousAndSide;uniform vec2 grlResolution;uniform float grlAspect;uniform float grlWidth;uniform float grlSizeAttenuation;vec2 grlFix( vec4 i,float aspect ) {vec2 res=i.xy/i.w;res.x*=aspect;return res;}
#else
attribute vec3 grl_slopes;attribute float grl_counters;
#endif
void main() {
#include<instancesVertex>
grlColorPointer=grl_colorPointers;mat4 grlMatrix=viewProjection*finalWorld ;
#ifdef GREASED_LINE_CAMERA_FACING
float grlBaseWidth=grlWidth;vec3 grlPrevious=grl_previousAndSide.xyz;float grlSide=grl_previousAndSide.w;vec3 grlNext=grl_nextAndCounters.xyz;grlCounters=grl_nextAndCounters.w;float grlWidth=grlBaseWidth*grl_widths;vec3 positionUpdated=position+grl_offsets;vec3 worldDir=normalize(grlNext-grlPrevious);vec3 nearPosition=positionUpdated+(worldDir*0.001);vec4 grlFinalPosition=grlMatrix*vec4( positionUpdated ,1.0);vec4 screenNearPos=grlMatrix*vec4(nearPosition,1.0);vec2 grlLinePosition=grlFix(grlFinalPosition,grlAspect);vec2 grlLineNearPosition=grlFix(screenNearPos,grlAspect);vec2 grlDir=normalize(grlLineNearPosition-grlLinePosition);vec4 grlNormal=vec4( -grlDir.y,grlDir.x,0.,1. );
#ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM
grlNormal.xy*=-.5*grlWidth;
#else
grlNormal.xy*=.5*grlWidth;
#endif
grlNormal*=projection;if (grlSizeAttenuation==1.) {grlNormal.xy*=grlFinalPosition.w;grlNormal.xy/=( vec4( grlResolution,0.,1. )*projection ).xy;}
grlFinalPosition.xy+=grlNormal.xy*grlSide;gl_Position=grlFinalPosition;
#else
grlCounters=grl_counters;vec4 grlFinalPosition=grlMatrix*vec4( (position+grl_offsets)+grl_slopes*grl_widths ,1.0 ) ;gl_Position=grlFinalPosition;
#endif
}
`;P.ShadersStore[hd]||(P.ShadersStore[hd]=cC);const H2={name:hd,shader:cC},j2=Object.freeze(Object.defineProperty({__proto__:null,greasedLineVertexShader:H2},Symbol.toStringTag,{value:"Module"})),dd="greasedLinePixelShader",hC=`var grlColors: texture_2d<f32>;var grlColorsSampler: sampler;uniform grlUseColors: f32;uniform grlUseDash: f32;uniform grlDashArray: f32;uniform grlDashOffset: f32;uniform grlDashRatio: f32;uniform grlVisibility: f32;uniform grlColorsWidth: f32;uniform grl_colorModeAndColorDistributionType: vec2f;uniform grlColor: vec3f;varying grlCounters: f32;varying grlColorPointer: f32;
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
let grlColorMode: f32=uniforms.grl_colorModeAndColorDistributionType.x;let grlColorDistributionType: f32=uniforms.grl_colorModeAndColorDistributionType.y;var outColor=vec4(uniforms.grlColor,1.);outColor.a=step(fragmentInputs.grlCounters,uniforms.grlVisibility);if (outColor.a==0.0) {discard;}
if (uniforms.grlUseDash==1.0) {let dashPosition=(fragmentInputs.grlCounters+uniforms.grlDashOffset) % uniforms.grlDashArray;outColor.a*=ceil(dashPosition-(uniforms.grlDashArray*uniforms.grlDashRatio));if (outColor.a==0.0) {discard;}}
if (uniforms.grlUseColors==1.) {
#ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE
let grlColor: vec4f=textureSample(grlColors,grlColorsSampler,vec2f(fragmentInputs.grlCounters,0.));
#else
let lookup: vec2f=vec2(fract(fragmentInputs.grlColorPointer/uniforms.grlColorsWidth),1.0-floor(fragmentInputs.grlColorPointer/uniforms.grlColorsWidth));let grlColor: vec4f=textureSample(grlColors,grlColorsSampler,lookup);
#endif
if (grlColorMode==COLOR_MODE_SET) {outColor=grlColor;} else if (grlColorMode==COLOR_MODE_ADD) {outColor+=grlColor;} else if (grlColorMode==COLOR_MODE_MULTIPLY) {outColor*=grlColor;}}
#if !defined(PREPASS) && !defined(ORDER_INDEPENDENT_TRANSPARENCY)
fragmentOutputs.color=outColor;
#endif
#if ORDER_INDEPENDENT_TRANSPARENCY
if (fragDepth==nearestDepth) {fragmentOutputs.frontColor=vec4f(fragmentOutputs.frontColor.rgb+outColor.rgb*outColor.a*alphaMultiplier,1.0-alphaMultiplier*(1.0-outColor.a));} else {fragmentOutputs.backColor+=outColor;}
#endif
#define CUSTOM_FRAGMENT_MAIN_END
}
`;P.ShadersStoreWGSL[dd]||(P.ShadersStoreWGSL[dd]=hC);const Y2={name:dd,shader:hC},X2=Object.freeze(Object.defineProperty({__proto__:null,greasedLinePixelShaderWGSL:Y2},Symbol.toStringTag,{value:"Module"})),fd="greasedLineVertexShader",dC=`#include<instancesDeclaration>
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
attribute grl_widths: f32;
#ifdef GREASED_LINE_USE_OFFSETS
attribute grl_offsets: vec3f; 
#endif
attribute grl_colorPointers: f32;attribute position: vec3f;varying grlCounters: f32;varying grlColorPointer: f32;
#ifdef GREASED_LINE_CAMERA_FACING
attribute grl_nextAndCounters: vec4f;attribute grl_previousAndSide: vec4f;uniform grlResolution: vec2f;uniform grlAspect: f32;uniform grlWidth: f32;uniform grlSizeAttenuation: f32;fn grlFix(i: vec4f,aspect: f32)->vec2f {var res=i.xy/i.w;res.x*=aspect;return res;}
#else
attribute grl_slopes: vec3f;attribute grl_counters: f32;
#endif
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
vertexOutputs.grlColorPointer=input.grl_colorPointers;let grlMatrix: mat4x4f=scene.viewProjection*mesh.world ;
#ifdef GREASED_LINE_CAMERA_FACING
let grlBaseWidth: f32=uniforms.grlWidth;let grlPrevious: vec3f=input.grl_previousAndSide.xyz;let grlSide: f32=input.grl_previousAndSide.w;let grlNext: vec3f=input.grl_nextAndCounters.xyz;vertexOutputs.grlCounters=input.grl_nextAndCounters.w;let grlWidth:f32=grlBaseWidth*input.grl_widths;
#ifdef GREASED_LINE_USE_OFFSETS
var grlPositionOffset: vec3f=input.grl_offsets;
#else
var grlPositionOffset=vec3f(0.);
#endif
let positionUpdated: vec3f=vertexInputs.position+grlPositionOffset;let worldDir: vec3f=normalize(grlNext-grlPrevious);let nearPosition: vec3f=positionUpdated+(worldDir*0.001);let grlFinalPosition: vec4f=grlMatrix*vec4f(positionUpdated,1.0);let screenNearPos: vec4f=grlMatrix*vec4(nearPosition,1.0);let grlLinePosition: vec2f=grlFix(grlFinalPosition,uniforms.grlAspect);let grlLineNearPosition: vec2f=grlFix(screenNearPos,uniforms.grlAspect);let grlDir: vec2f=normalize(grlLineNearPosition-grlLinePosition);var grlNormal: vec4f=vec4f(-grlDir.y,grlDir.x,0.0,1.0);let grlHalfWidth: f32=0.5*grlWidth;
#if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)
grlNormal.x*=-grlHalfWidth;grlNormal.y*=-grlHalfWidth;
#else
grlNormal.x*=grlHalfWidth;grlNormal.y*=grlHalfWidth;
#endif
grlNormal*=scene.projection;if (uniforms.grlSizeAttenuation==1.) {grlNormal.x*=grlFinalPosition.w;grlNormal.y*=grlFinalPosition.w;let pr=vec4f(uniforms.grlResolution,0.0,1.0)*scene.projection;grlNormal.x/=pr.x;grlNormal.y/=pr.y;}
vertexOutputs.position=vec4f(grlFinalPosition.xy+grlNormal.xy*grlSide,grlFinalPosition.z,grlFinalPosition.w);
#else
vertexOutputs.grlCounters=input.grl_counters;vertexOutputs.position=grlMatrix*vec4f((vertexInputs.position+input.grl_offsets)+input.grl_slopes*input.grl_widths,1.0) ;
#endif
#define CUSTOM_VERTEX_MAIN_END
}
`;P.ShadersStoreWGSL[fd]||(P.ShadersStoreWGSL[fd]=dC);const Z2={name:fd,shader:dC},q2=Object.freeze(Object.defineProperty({__proto__:null,greasedLineVertexShaderWGSL:Z2},Symbol.toStringTag,{value:"Module"}));function Q2(a,e){return`{X: ${a.x.toFixed(e)} Y: ${a.y.toFixed(e)}}`}function K2(a,e){return`{X: ${a._x.toFixed(e)} Y: ${a._y.toFixed(e)} Z: ${a._z.toFixed(e)}}`}function J2(a,e){return`{X: ${a.x.toFixed(e)} Y: ${a.y.toFixed(e)} Z: ${a.z.toFixed(e)} W: ${a.w.toFixed(e)}}`}class Or{static get Configuration(){return{get decoder(){return Cn.DefaultConfiguration},set decoder(e){Cn.DefaultConfiguration=e}}}static set Configuration(e){Cn.DefaultConfiguration=e.decoder}static get DecoderAvailable(){return Iy(Cn.DefaultConfiguration)}static get Default(){return Or._Default??(Or._Default=new Or),Or._Default}static ResetDefault(e){Or._Default&&(e||Or._Default.dispose(),Or._Default=null)}constructor(e=Or.DefaultNumWorkers){const t=typeof e=="number"?{...Cn.DefaultConfiguration,numWorkers:e}:{...Cn.DefaultConfiguration,...e};this._decoder=new Cn(t)}dispose(){this._decoder.dispose()}async whenReadyAsync(){return this._decoder.whenReadyAsync()}decodeMeshToMeshDataAsync(e,t,i){return this._decoder.decodeMeshToMeshDataAsync(e,t,i)}async decodeMeshToGeometryAsync(e,t,i,r){return this._decoder.decodeMeshToGeometryAsync(e,t,i,r)}async _decodeMeshToGeometryForGltfAsync(e,t,i,r,s,n){return this._decoder._decodeMeshToGeometryForGltfAsync(e,t,i,r,s,n)}async decodeMeshAsync(e,t){const i=await this._decoder.decodeMeshToMeshDataAsync(e,t),r=new he;i.indices&&(r.indices=i.indices);for(const s of i.attributes){const n=N.GetFloatData(s.data,s.size,N.GetDataType(s.data),s.byteOffset,s.byteStride,s.normalized,i.totalVertices);r.set(n,s.kind)}return r}}Or.DefaultNumWorkers=CM();Or._Default=null;function eL(a){return a===N.PositionKind?"POSITION":a===N.NormalKind?"NORMAL":a===N.ColorKind?"COLOR":a.startsWith(N.UVKind)?"TEX_COORD":"GENERIC"}function tL(a){let e=a.getIndices(void 0,!0);return e&&!(e instanceof Uint32Array)&&!(e instanceof Uint16Array)&&(e=(RM(e,e.length)?Uint32Array:Uint16Array).from(e)),e}function iL(a,e){const t=[];for(const i of a.getVerticesDataKinds()){if(e!=null&&e.includes(i)){if(i===N.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const r=a.getVertexBuffer(i),s=r.getSize(),n=MM(r.getData(),s,r.type,r.byteOffset,r.byteStride,r.normalized,a.getTotalVertices(),!0);t.push({kind:i,dracoName:eL(i),size:s,data:n})}return t}const JS={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Sr extends PM{static get DefaultAvailable(){return Iy(Sr.DefaultConfiguration)}static get Default(){return Sr._Default??(Sr._Default=new Sr),Sr._Default}static ResetDefault(e){Sr._Default&&(e||Sr._Default.dispose(),Sr._Default=null)}_isModuleAvailable(){return typeof DracoEncoderModule<"u"}async _createModuleAsync(e,t){return{module:await(t||DracoEncoderModule)({wasmBinary:e})}}_getWorkerContent(){return`${gg}(${EM})()`}constructor(e=Sr.DefaultConfiguration){super(e)}async _encodeAsync(e,t,i){const r=i?IM(JS,i):JS;if(this._workerPoolPromise){const s=await this._workerPoolPromise;return new Promise((n,o)=>{s.push((l,u)=>{const c=f=>{l.removeEventListener("error",c),l.removeEventListener("message",h),o(f),u()},h=f=>{f.data.id==="encodeMeshDone"&&(l.removeEventListener("error",c),l.removeEventListener("message",h),n(f.data.encodedMeshData),u())};l.addEventListener("error",c),l.addEventListener("message",h);const d=[];e.forEach(f=>{d.push(f.data.buffer)}),t&&d.push(t.buffer),l.postMessage({id:"encodeMesh",attributes:e,indices:t,options:r},d)})})}if(this._modulePromise){const s=await this._modulePromise;return gg(s.module,e,t,r)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(e,t){if(e.getTotalVertices()==0)throw new Error("Cannot compress geometry with Draco. There are no vertices.");e instanceof z&&e.morphTargetManager&&(t==null?void 0:t.method)==="MESH_EDGEBREAKER_ENCODING"&&(L.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),t.method="MESH_SEQUENTIAL_ENCODING");const r=tL(e),s=iL(e,t==null?void 0:t.excludedAttributes);return this._encodeAsync(s,r,t)}}Sr.DefaultConfiguration={wasmUrl:`${ae._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${ae._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${ae._DefaultCdnUrl}/draco_encoder.js`};Sr._Default=null;let wl=0;class Qo{constructor(e,t,i,r){this.pos=e,this.normal=t,this.uv=i,this.vertColor=r}clone(){var e,t;return new Qo(this.pos.clone(),this.normal.clone(),(e=this.uv)==null?void 0:e.clone(),(t=this.vertColor)==null?void 0:t.clone())}flip(){this.normal=this.normal.scale(-1)}interpolate(e,t){return new Qo(m.Lerp(this.pos,e.pos,t),m.Lerp(this.normal,e.normal,t),this.uv&&e.uv?Q.Lerp(this.uv,e.uv,t):void 0,this.vertColor&&e.vertColor?xe.Lerp(this.vertColor,e.vertColor,t):void 0)}}class wn{constructor(e,t){this.normal=e,this.w=t}static FromPoints(e,t,i){const r=i.subtract(e),s=t.subtract(e);if(r.lengthSquared()===0||s.lengthSquared()===0)return null;const n=m.Normalize(m.Cross(r,s));return new wn(n,m.Dot(n,e))}clone(){return new wn(this.normal.clone(),this.w)}flip(){this.normal.scaleInPlace(-1),this.w=-this.w}splitPolygon(e,t,i,r,s){let c=0;const h=[];let d,f;for(d=0;d<e.vertices.length;d++){f=m.Dot(this.normal,e.vertices[d].pos)-this.w;const p=f<-wn.EPSILON?2:f>wn.EPSILON?1:0;c|=p,h.push(p)}switch(c){case 0:(m.Dot(this.normal,e.plane.normal)>0?t:i).push(e);break;case 1:r.push(e);break;case 2:s.push(e);break;case 3:{const p=[],g=[];for(d=0;d<e.vertices.length;d++){const S=(d+1)%e.vertices.length,b=h[d],y=h[S],T=e.vertices[d],v=e.vertices[S];if(b!==2&&p.push(T),b!==1&&g.push(b!==2?T.clone():T),(b|y)===3){f=(this.w-m.Dot(this.normal,T.pos))/m.Dot(this.normal,v.pos.subtract(T.pos));const E=T.interpolate(v,f);p.push(E),g.push(E.clone())}}let _;p.length>=3&&(_=new Ua(p,e.shared),_.plane&&r.push(_)),g.length>=3&&(_=new Ua(g,e.shared),_.plane&&s.push(_));break}}}}wn.EPSILON=1e-5;class Ua{constructor(e,t){this.vertices=e,this.shared=t,this.plane=wn.FromPoints(e[0].pos,e[1].pos,e[2].pos)}clone(){const e=this.vertices.map(t=>t.clone());return new Ua(e,this.shared)}flip(){this.vertices.reverse().map(e=>{e.flip()}),this.plane.flip()}}let gr=class Gl{constructor(e){this._plane=null,this._front=null,this._back=null,this._polygons=new Array,e&&this.build(e)}clone(){const e=new Gl;return e._plane=this._plane&&this._plane.clone(),e._front=this._front&&this._front.clone(),e._back=this._back&&this._back.clone(),e._polygons=this._polygons.map(t=>t.clone()),e}invert(){for(let t=0;t<this._polygons.length;t++)this._polygons[t].flip();this._plane&&this._plane.flip(),this._front&&this._front.invert(),this._back&&this._back.invert();const e=this._front;this._front=this._back,this._back=e}clipPolygons(e){if(!this._plane)return e.slice();let t=[],i=[];for(let r=0;r<e.length;r++)this._plane.splitPolygon(e[r],t,i,t,i);return this._front&&(t=this._front.clipPolygons(t)),this._back?i=this._back.clipPolygons(i):i=[],t.concat(i)}clipTo(e){this._polygons=e.clipPolygons(this._polygons),this._front&&this._front.clipTo(e),this._back&&this._back.clipTo(e)}allPolygons(){let e=this._polygons.slice();return this._front&&(e=e.concat(this._front.allPolygons())),this._back&&(e=e.concat(this._back.allPolygons())),e}build(e){if(!e.length)return;this._plane||(this._plane=e[0].plane.clone());const t=[],i=[];for(let r=0;r<e.length;r++)this._plane.splitPolygon(e[r],this._polygons,this._polygons,t,i);t.length&&(this._front||(this._front=new Gl),this._front.build(t)),i.length&&(this._back||(this._back=new Gl),this._back.build(i))}};class Xr{constructor(){this._polygons=new Array}static FromVertexData(e){let t,i,r;const s=[],n=e.indices,o=e.positions,l=e.normals,u=e.uvs,c=e.colors;if(!n||!o)throw"BABYLON.CSG: VertexData must at least contain positions and indices";for(let d=0;d<n.length;d+=3){r=[];for(let f=0;f<3;f++){const p=d+f,g=n[p],_=l?m.FromArray(l,g*3):m.Zero(),S=u?Q.FromArray(u,g*2):void 0,b=c?xe.FromArray(c,g*4):void 0,y=m.FromArray(o,g*3);t=new Qo(y,_,S,b),r.push(t)}i=new Ua(r,{subMeshId:0,meshId:wl,materialIndex:0}),i.plane&&s.push(i)}const h=Xr._FromPolygons(s);return h.matrix=$.Identity(),h.position=m.Zero(),h.rotation=m.Zero(),h.scaling=m.One(),h.rotationQuaternion=re.Identity(),wl++,h}static FromMesh(e,t=!1){let i,r,s,n,o,l,u;const c=[];let h,d,f,p=null,g,_=!1;if(e instanceof z)e.computeWorldMatrix(!0),h=e.getWorldMatrix(),d=e.position.clone(),f=e.rotation.clone(),e.rotationQuaternion&&(p=e.rotationQuaternion.clone()),g=e.scaling.clone(),e.material&&t&&(_=e.material.sideOrientation===0);else throw"BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh";const S=e.getIndices(),b=e.getVerticesData(N.PositionKind),y=e.getVerticesData(N.NormalKind),T=e.getVerticesData(N.UVKind),v=e.getVerticesData(N.ColorKind);if(S===null)throw"BABYLON.CSG: Mesh has no indices";if(b===null)throw"BABYLON.CSG: Mesh has no positions";if(y===null)throw"BABYLON.CSG: Mesh has no normals";const E=e.subMeshes;if(!E)throw"BABYLON.CSG: Mesh has no submeshes";for(let O=0,w=E.length;O<w;O++)for(let M=E[O].indexStart,G=E[O].indexCount+E[O].indexStart;M<G;M+=3){u=[];for(let H=0;H<3;H++){const q=H===0?M+H:_?M+3-H:M+H,X=new m(y[S[q]*3],y[S[q]*3+1],y[S[q]*3+2]);T&&(s=new Q(T[S[q]*2],T[S[q]*2+1])),v&&(o=new xe(v[S[q]*4],v[S[q]*4+1],v[S[q]*4+2],v[S[q]*4+3]));const ee=new m(b[S[q]*3],b[S[q]*3+1],b[S[q]*3+2]);n=m.TransformCoordinates(ee,h),r=m.TransformNormal(X,h),i=new Qo(n,r,s,o),u.push(i)}l=new Ua(u,{subMeshId:O,meshId:wl,materialIndex:E[O].materialIndex}),l.plane&&c.push(l)}const R=Xr._FromPolygons(c);return R.matrix=t?$.Identity():h,R.position=t?m.Zero():d,R.rotation=t?m.Zero():f,R.scaling=t?m.One():g,R.rotationQuaternion=t&&p?re.Identity():p,wl++,R}static _FromPolygons(e){const t=new Xr;return t._polygons=e,t}clone(){const e=new Xr;return e._polygons=this._polygons.map(t=>t.clone()),e.copyTransformAttributes(this),e}union(e){const t=new gr(this.clone()._polygons),i=new gr(e.clone()._polygons);return t.clipTo(i),i.clipTo(t),i.invert(),i.clipTo(t),i.invert(),t.build(i.allPolygons()),Xr._FromPolygons(t.allPolygons()).copyTransformAttributes(this)}unionInPlace(e){const t=new gr(this._polygons),i=new gr(e._polygons);t.clipTo(i),i.clipTo(t),i.invert(),i.clipTo(t),i.invert(),t.build(i.allPolygons()),this._polygons=t.allPolygons()}subtract(e){const t=new gr(this.clone()._polygons),i=new gr(e.clone()._polygons);return t.invert(),t.clipTo(i),i.clipTo(t),i.invert(),i.clipTo(t),i.invert(),t.build(i.allPolygons()),t.invert(),Xr._FromPolygons(t.allPolygons()).copyTransformAttributes(this)}subtractInPlace(e){const t=new gr(this._polygons),i=new gr(e._polygons);t.invert(),t.clipTo(i),i.clipTo(t),i.invert(),i.clipTo(t),i.invert(),t.build(i.allPolygons()),t.invert(),this._polygons=t.allPolygons()}intersect(e){const t=new gr(this.clone()._polygons),i=new gr(e.clone()._polygons);return t.invert(),i.clipTo(t),i.invert(),t.clipTo(i),i.clipTo(t),t.build(i.allPolygons()),t.invert(),Xr._FromPolygons(t.allPolygons()).copyTransformAttributes(this)}intersectInPlace(e){const t=new gr(this._polygons),i=new gr(e._polygons);t.invert(),i.clipTo(t),i.invert(),t.clipTo(i),i.clipTo(t),t.build(i.allPolygons()),t.invert(),this._polygons=t.allPolygons()}inverse(){const e=this.clone();return e.inverseInPlace(),e}inverseInPlace(){this._polygons.map(e=>{e.flip()})}copyTransformAttributes(e){return this.matrix=e.matrix,this.position=e.position,this.rotation=e.rotation,this.scaling=e.scaling,this.rotationQuaternion=e.rotationQuaternion,this}toVertexData(e=null,t=null){const i=this.matrix.clone();i.invert();const r=this._polygons,s=[],n=[],o=[];let l=null,u=null;const c=m.Zero(),h=m.Zero(),d=Q.Zero(),f=new xe(0,0,0,0),p=[0,0,0],g={};let _;for(let b=0,y=r.length;b<y;b++){const T=r[b];e&&e(T);for(let v=2,E=T.vertices.length;v<E;v++){p[0]=0,p[1]=v-1,p[2]=v;for(let R=0;R<3;R++){c.copyFrom(T.vertices[p[R]].pos),h.copyFrom(T.vertices[p[R]].normal),T.vertices[p[R]].uv&&(l||(l=[]),d.copyFrom(T.vertices[p[R]].uv)),T.vertices[p[R]].vertColor&&(u||(u=[]),f.copyFrom(T.vertices[p[R]].vertColor));const O=m.TransformCoordinates(c,i),w=m.TransformNormal(h,i);_=g[O.x+","+O.y+","+O.z];let M=!1;l&&!(l[_*2]===d.x||l[_*2+1]===d.y)&&(M=!0);let G=!1;u&&!(u[_*4]===f.r||u[_*4+1]===f.g||u[_*4+2]===f.b||u[_*4+3]===f.a)&&(G=!0),(!(typeof _<"u"&&o[_*3]===w.x&&o[_*3+1]===w.y&&o[_*3+2]===w.z)||M||G)&&(s.push(O.x,O.y,O.z),l&&l.push(d.x,d.y),o.push(h.x,h.y,h.z),u&&u.push(f.r,f.g,f.b,f.a),_=g[O.x+","+O.y+","+O.z]=s.length/3-1),n.push(_),t&&t()}}}const S=new he;return S.positions=s,S.normals=o,l&&(S.uvs=l),u&&(S.colors=u),S.indices=n,S}buildMeshGeometry(e,t,i){const r=new z(e,t),s=this._polygons;let n=0;const o={};let l;if(i&&s.sort((c,h)=>c.shared.meshId===h.shared.meshId?c.shared.subMeshId-h.shared.subMeshId:c.shared.meshId-h.shared.meshId),this.toVertexData(c=>{o[c.shared.meshId]||(o[c.shared.meshId]={}),o[c.shared.meshId][c.shared.subMeshId]||(o[c.shared.meshId][c.shared.subMeshId]={indexStart:1/0,indexEnd:-1/0,materialIndex:c.shared.materialIndex}),l=o[c.shared.meshId][c.shared.subMeshId]},()=>{l.indexStart=Math.min(n,l.indexStart),l.indexEnd=Math.max(n,l.indexEnd),n++}).applyToMesh(r),i){let c=0,h;r.subMeshes=[];for(const d in o){h=-1;for(const f in o[d])l=o[d][f],zn.CreateFromIndices(l.materialIndex+c,l.indexStart,l.indexEnd-l.indexStart+1,r),h=Math.max(l.materialIndex,h);c+=++h}}return r}toMesh(e,t=null,i,r){const s=this.buildMeshGeometry(e,i,r);return s.material=t,s.position.copyFrom(this.position),s.rotation.copyFrom(this.rotation),this.rotationQuaternion&&(s.rotationQuaternion=this.rotationQuaternion.clone()),s.scaling.copyFrom(this.scaling),s.computeWorldMatrix(!0),s}}z._TrailMeshParser=(a,e)=>su.Parse(a,e);class su extends z{constructor(e,t,i,r,s=60,n=!0){super(e,i),this._sectionPolygonPointsCount=4,this._running=!1,this._generator=t,typeof r=="object"&&r!==null?(this.diameter=r.diameter||1,this._length=r.length||60,this._segments=r.segments?r.segments>this._length?this._length:r.segments:this._length,this._sectionPolygonPointsCount=r.sections||4,this._doNotTaper=r.doNotTaper||!1,this._autoStart=r.autoStart||!0):(this.diameter=r||1,this._length=s,this._segments=this._length,this._doNotTaper=!1,this._autoStart=n),this._sectionVectors=[],this._sectionNormalVectors=[];for(let o=0;o<=this._sectionPolygonPointsCount;o++)this._sectionVectors[o]=m.Zero(),this._sectionNormalVectors[o]=m.Zero();this._createMesh()}getClassName(){return"TrailMesh"}_createMesh(){const e=new he,t=[],i=[],r=[],s=[];let n=m.Zero();this._generator instanceof Rt&&this._generator.hasBoundingInfo?n=this._generator.getBoundingInfo().boundingBox.centerWorld:n=this._generator.absolutePosition;const o=2*Math.PI/this._sectionPolygonPointsCount;for(let l=0;l<=this._sectionPolygonPointsCount;l++){const u=l!==this._sectionPolygonPointsCount?l*o:0;t.push(n.x+Math.cos(u)*this.diameter,n.y+Math.sin(u)*this.diameter,n.z),s.push(l/this._sectionPolygonPointsCount,0)}for(let l=1;l<=this._segments;l++){for(let c=0;c<=this._sectionPolygonPointsCount;c++){const h=c!==this._sectionPolygonPointsCount?c*o:0;t.push(n.x+Math.cos(h)*this.diameter,n.y+Math.sin(h)*this.diameter,n.z),s.push(c/this._sectionPolygonPointsCount,l/this._segments)}const u=t.length/3-2*(this._sectionPolygonPointsCount+1);for(let c=0;c<=this._sectionPolygonPointsCount;c++)r.push(u+c,u+c+this._sectionPolygonPointsCount,u+c+this._sectionPolygonPointsCount+1),r.push(u+c,u+c+this._sectionPolygonPointsCount+1,u+c+1)}he.ComputeNormals(t,r,i),e.positions=t,e.normals=i,e.indices=r,e.uvs=s,e.applyToMesh(this,!0),this._autoStart&&this.start()}_updateSectionVectors(){const e=this._generator.getWorldMatrix(),t=2*Math.PI/this._sectionPolygonPointsCount;for(let i=0;i<=this._sectionPolygonPointsCount;i++){const r=i!==this._sectionPolygonPointsCount?i*t:0;this._sectionVectors[i].copyFromFloats(Math.cos(r)*this.diameter,Math.sin(r)*this.diameter,0),this._sectionNormalVectors[i].copyFromFloats(Math.cos(r),Math.sin(r),0),m.TransformCoordinatesToRef(this._sectionVectors[i],e,this._sectionVectors[i]),m.TransformNormalToRef(this._sectionNormalVectors[i],e,this._sectionNormalVectors[i])}}start(){this._running||(this._running=!0,this._beforeRenderObserver=this.getScene().onBeforeRenderObservable.add(()=>{this.update()}))}stop(){this._beforeRenderObserver&&this._running&&(this._running=!1,this.getScene().onBeforeRenderObservable.remove(this._beforeRenderObserver))}update(){const e=this.getVerticesData(N.PositionKind),t=this.getVerticesData(N.NormalKind),i=3*(this._sectionPolygonPointsCount+1);if(e&&t){if(this._doNotTaper)for(let s=i;s<e.length;s++)e[s-i]=mi(e[s-i],e[s],this._segments/this._length);else for(let s=i;s<e.length;s++)e[s-i]=mi(e[s-i],e[s],this._segments/this._length)-t[s]/this._length*this.diameter;for(let s=i;s<t.length;s++)t[s-i]=mi(t[s-i],t[s],this._segments/this._length);this._updateSectionVectors();const r=e.length-3*(this._sectionPolygonPointsCount+1);for(let s=0;s<=this._sectionPolygonPointsCount;s++)e[r+3*s]=this._sectionVectors[s].x,e[r+3*s+1]=this._sectionVectors[s].y,e[r+3*s+2]=this._sectionVectors[s].z,t[r+3*s]=this._sectionNormalVectors[s].x,t[r+3*s+1]=this._sectionNormalVectors[s].y,t[r+3*s+2]=this._sectionNormalVectors[s].z;this.updateVerticesData(N.PositionKind,e,!0,!1),this.updateVerticesData(N.NormalKind,t,!0,!1)}}reset(){const e=this.getVerticesData(N.PositionKind),t=this.getVerticesData(N.NormalKind);if(e&&t){this._updateSectionVectors();for(let i=0;i<=this._segments;i++){const r=3*i*(this._sectionPolygonPointsCount+1);for(let s=0;s<=this._sectionPolygonPointsCount;s++)e[r+3*s]=this._sectionVectors[s].x,e[r+3*s+1]=this._sectionVectors[s].y,e[r+3*s+2]=this._sectionVectors[s].z,t[r+3*s]=this._sectionNormalVectors[s].x,t[r+3*s+1]=this._sectionNormalVectors[s].y,t[r+3*s+2]=this._sectionNormalVectors[s].z}this.updateVerticesData(N.PositionKind,e,!0,!1),this.updateVerticesData(N.NormalKind,t,!0,!1)}}clone(e="",t){const i={diameter:this.diameter,length:this._length,segments:this._segments,sections:this._sectionPolygonPointsCount,doNotTaper:this._doNotTaper,autoStart:this._autoStart};return new su(e,t??this._generator,this.getScene(),i)}serialize(e){super.serialize(e),e.generatorId=this._generator.id}static Parse(e,t){const i=t.getLastMeshById(e.generatorId)??t.getLastTransformNodeById(e.generatorId);if(!i)throw new Error("TrailMesh: generator not found with ID "+e.generatorId);const r={diameter:e.diameter??e._diameter,length:e._length,segments:e._segments,sections:e._sectionPolygonPointsCount,doNotTaper:e._doNotTaper,autoStart:e._autoStart};return new su(e.name,i,t,r)}}class zW{constructor(e,t,i){this.quality=e,this.distance=t,this.optimizeMesh=i}}class rL{constructor(){this.running=!1,this._simplificationArray=[]}addTask(e){this._simplificationArray.push(e)}executeNext(){const e=this._simplificationArray.pop();e?(this.running=!0,this.runSimplification(e)):this.running=!1}runSimplification(e){if(e.parallelProcessing)e.settings.forEach(t=>{this._getSimplifier(e).simplify(t,r=>{t.distance!==void 0&&e.mesh.addLODLevel(t.distance,r),r.isVisible=!0,t.quality===e.settings[e.settings.length-1].quality&&e.successCallback&&e.successCallback(),this.executeNext()})});else{const t=this._getSimplifier(e),i=(r,s)=>{t.simplify(r,n=>{r.distance!==void 0&&e.mesh.addLODLevel(r.distance,n),n.isVisible=!0,s()})};Hs.Run(e.settings.length,r=>{i(e.settings[r.index],()=>{r.executeNext()})},()=>{e.successCallback&&e.successCallback(),this.executeNext()})}}_getSimplifier(e){switch(e.simplificationType){case 0:default:return new oL(e.mesh)}}}var ev;(function(a){a[a.QUADRATIC=0]="QUADRATIC"})(ev||(ev={}));class sL{constructor(e){this._vertices=e,this.error=new Array(4),this.deleted=!1,this.isDirty=!1,this.deletePending=!1,this.borderFactor=0}}class nL{constructor(e,t){this.position=e,this.id=t,this.isBorder=!0,this.q=new Ea,this.triangleCount=0,this.triangleStart=0,this.originalOffsets=[]}updatePosition(e){this.position.copyFrom(e)}}class Ea{constructor(e){this.data=new Array(10);for(let t=0;t<10;++t)e&&e[t]?this.data[t]=e[t]:this.data[t]=0}det(e,t,i,r,s,n,o,l,u){return this.data[e]*this.data[s]*this.data[u]+this.data[i]*this.data[r]*this.data[l]+this.data[t]*this.data[n]*this.data[o]-this.data[i]*this.data[s]*this.data[o]-this.data[e]*this.data[n]*this.data[l]-this.data[t]*this.data[r]*this.data[u]}addInPlace(e){for(let t=0;t<10;++t)this.data[t]+=e.data[t]}addArrayInPlace(e){for(let t=0;t<10;++t)this.data[t]+=e[t]}add(e){const t=new Ea;for(let i=0;i<10;++i)t.data[i]=this.data[i]+e.data[i];return t}static FromData(e,t,i,r){return new Ea(Ea.DataFromNumbers(e,t,i,r))}static DataFromNumbers(e,t,i,r){return[e*e,e*t,e*i,e*r,t*t,t*i,t*r,i*i,i*r,r*r]}}class aL{constructor(e,t){this.vertexId=e,this.triangleId=t}}class oL{constructor(e){this._mesh=e,this.syncIterations=5e3,this.aggressiveness=7,this.decimationIterations=100,this.boundingBoxEpsilon=He}simplify(e,t){this._initDecimatedMesh(),Hs.Run(this._mesh.subMeshes.length,i=>{this._initWithMesh(i.index,()=>{this._runDecimation(e,i.index,()=>{i.executeNext()})},e.optimizeMesh)},()=>{setTimeout(()=>{t(this._reconstructedMesh)},0)})}_runDecimation(e,t,i){const r=~~(this._triangles.length*e.quality);let s=0;const n=this._triangles.length,o=(l,u)=>{setTimeout(()=>{l%5===0&&this._updateMesh(l===0);for(let d=0;d<this._triangles.length;++d)this._triangles[d].isDirty=!1;const c=1e-9*Math.pow(l+3,this.aggressiveness),h=d=>{const f=~~((this._triangles.length/2+d)%this._triangles.length),p=this._triangles[f];if(p&&!(p.error[3]>c||p.deleted||p.isDirty)){for(let g=0;g<3;++g)if(p.error[g]<c){const _=[],S=[],b=p._vertices[g],y=p._vertices[(g+1)%3];if(b.isBorder||y.isBorder)continue;const T=m.Zero();this._calculateError(b,y,T);const v=[];if(this._isFlipped(b,y,T,_,v)||this._isFlipped(y,b,T,S,v)||_.indexOf(!0)<0||S.indexOf(!0)<0)continue;const E=[];if(v.forEach(w=>{E.indexOf(w)===-1&&(w.deletePending=!0,E.push(w))}),E.length%2!==0)continue;b.q=y.q.add(b.q),b.updatePosition(T);const R=this._references.length;s=this._updateTriangles(b,b,_,s),s=this._updateTriangles(b,y,S,s);const O=this._references.length-R;if(O<=b.triangleCount){if(O)for(let w=0;w<O;w++)this._references[b.triangleStart+w]=this._references[R+w]}else b.triangleStart=R;b.triangleCount=O;break}}};Hs.SyncAsyncForLoop(this._triangles.length,this.syncIterations,h,u,()=>n-s<=r)},0)};Hs.Run(this.decimationIterations,l=>{n-s<=r?l.breakLoop():o(l.index,()=>{l.executeNext()})},()=>{setTimeout(()=>{this._reconstructMesh(t),i()},0)})}_initWithMesh(e,t,i){this._vertices=[],this._triangles=[];const r=this._mesh.getVerticesData(N.PositionKind),s=this._mesh.getIndices(),n=this._mesh.subMeshes[e],o=h=>{if(i){for(let d=0;d<this._vertices.length;++d)if(this._vertices[d].position.equalsWithEpsilon(h,1e-4))return this._vertices[d]}return null},l=[],u=h=>{if(!r)return;const d=h+n.verticesStart,f=m.FromArray(r,d*3),p=o(f)||new nL(f,this._vertices.length);p.originalOffsets.push(d),p.id===this._vertices.length&&this._vertices.push(p),l.push(p.id)},c=n.verticesCount;Hs.SyncAsyncForLoop(c,this.syncIterations/4>>0,u,()=>{const h=d=>{if(!s)return;const p=(n.indexStart/3+d)*3,g=s[p+0],_=s[p+1],S=s[p+2],b=this._vertices[l[g-n.verticesStart]],y=this._vertices[l[_-n.verticesStart]],T=this._vertices[l[S-n.verticesStart]],v=new sL([b,y,T]);v.originalOffset=p,this._triangles.push(v)};Hs.SyncAsyncForLoop(n.indexCount/3,this.syncIterations,h,()=>{this._init(t)})})}_init(e){const t=i=>{const r=this._triangles[i];r.normal=m.Cross(r._vertices[1].position.subtract(r._vertices[0].position),r._vertices[2].position.subtract(r._vertices[0].position)).normalize();for(let s=0;s<3;s++)r._vertices[s].q.addArrayInPlace(Ea.DataFromNumbers(r.normal.x,r.normal.y,r.normal.z,-m.Dot(r.normal,r._vertices[0].position)))};Hs.SyncAsyncForLoop(this._triangles.length,this.syncIterations,t,()=>{const i=r=>{const s=this._triangles[r];for(let n=0;n<3;++n)s.error[n]=this._calculateError(s._vertices[n],s._vertices[(n+1)%3]);s.error[3]=Math.min(s.error[0],s.error[1],s.error[2])};Hs.SyncAsyncForLoop(this._triangles.length,this.syncIterations,i,()=>{e()})})}_reconstructMesh(e){const t=[];let i;for(i=0;i<this._vertices.length;++i)this._vertices[i].triangleCount=0;let r,s;for(i=0;i<this._triangles.length;++i)if(!this._triangles[i].deleted){for(r=this._triangles[i],s=0;s<3;++s)r._vertices[s].triangleCount=1;t.push(r)}const n=this._reconstructedMesh.getVerticesData(N.PositionKind)||[],o=this._reconstructedMesh.getVerticesData(N.NormalKind)||[],l=this._reconstructedMesh.getVerticesData(N.UVKind)||[],u=this._reconstructedMesh.getVerticesData(N.ColorKind)||[],c=this._mesh.getVerticesData(N.NormalKind),h=this._mesh.getVerticesData(N.UVKind),d=this._mesh.getVerticesData(N.ColorKind);let f=0;for(i=0;i<this._vertices.length;++i){const T=this._vertices[i];T.id=f,T.triangleCount&&T.originalOffsets.forEach(v=>{n.push(T.position.x),n.push(T.position.y),n.push(T.position.z),c&&c.length&&(o.push(c[v*3]),o.push(c[v*3+1]),o.push(c[v*3+2])),h&&h.length&&(l.push(h[v*2]),l.push(h[v*2+1])),d&&d.length&&(u.push(d[v*4]),u.push(d[v*4+1]),u.push(d[v*4+2]),u.push(d[v*4+3])),++f})}const p=this._reconstructedMesh.getTotalIndices(),g=this._reconstructedMesh.getTotalVertices(),_=this._reconstructedMesh.subMeshes;this._reconstructedMesh.subMeshes=[];const S=this._reconstructedMesh.getIndices(),b=this._mesh.getIndices();for(i=0;i<t.length;++i)r=t[i],[0,1,2].forEach(T=>{const v=b[r.originalOffset+T];let E=r._vertices[T].originalOffsets.indexOf(v);E<0&&(E=0),S.push(r._vertices[T].id+E+g)});this._reconstructedMesh.setIndices(S),this._reconstructedMesh.setVerticesData(N.PositionKind,n),o.length>0&&this._reconstructedMesh.setVerticesData(N.NormalKind,o),l.length>0&&this._reconstructedMesh.setVerticesData(N.UVKind,l),u.length>0&&this._reconstructedMesh.setVerticesData(N.ColorKind,u);const y=this._mesh.subMeshes[e];e>0&&(this._reconstructedMesh.subMeshes=[],_.forEach(T=>{zn.AddToMesh(T.materialIndex,T.verticesStart,T.verticesCount,T.indexStart,T.indexCount,T.getMesh())}),zn.AddToMesh(y.materialIndex,g,f,p,t.length*3,this._reconstructedMesh))}_initDecimatedMesh(){this._reconstructedMesh=new z(this._mesh.name+"Decimated",this._mesh.getScene()),this._reconstructedMesh.material=this._mesh.material,this._reconstructedMesh.parent=this._mesh.parent,this._reconstructedMesh.isVisible=!1,this._reconstructedMesh.renderingGroupId=this._mesh.renderingGroupId}_isFlipped(e,t,i,r,s){for(let n=0;n<e.triangleCount;++n){const o=this._triangles[this._references[e.triangleStart+n].triangleId];if(o.deleted)continue;const l=this._references[e.triangleStart+n].vertexId,u=o._vertices[(l+1)%3],c=o._vertices[(l+2)%3];if(u===t||c===t){r[n]=!0,s.push(o);continue}let h=u.position.subtract(i);h=h.normalize();let d=c.position.subtract(i);if(d=d.normalize(),Math.abs(m.Dot(h,d))>.999)return!0;const f=m.Cross(h,d).normalize();if(r[n]=!1,m.Dot(f,o.normal)<.2)return!0}return!1}_updateTriangles(e,t,i,r){let s=r;for(let n=0;n<t.triangleCount;++n){const o=this._references[t.triangleStart+n],l=this._triangles[o.triangleId];if(!l.deleted){if(i[n]&&l.deletePending){l.deleted=!0,s++;continue}l._vertices[o.vertexId]=e,l.isDirty=!0,l.error[0]=this._calculateError(l._vertices[0],l._vertices[1])+l.borderFactor/2,l.error[1]=this._calculateError(l._vertices[1],l._vertices[2])+l.borderFactor/2,l.error[2]=this._calculateError(l._vertices[2],l._vertices[0])+l.borderFactor/2,l.error[3]=Math.min(l.error[0],l.error[1],l.error[2]),this._references.push(o)}}return s}_identifyBorder(){for(let e=0;e<this._vertices.length;++e){const t=[],i=[],r=this._vertices[e];let s;for(s=0;s<r.triangleCount;++s){const n=this._triangles[this._references[r.triangleStart+s].triangleId];for(let o=0;o<3;o++){let l=0;const u=n._vertices[o];for(;l<t.length&&i[l]!==u.id;)++l;l===t.length?(t.push(1),i.push(u.id)):t[l]++}}for(s=0;s<t.length;++s)t[s]===1?this._vertices[i[s]].isBorder=!0:this._vertices[i[s]].isBorder=!1}}_updateMesh(e=!1){let t;if(!e){const l=[];for(t=0;t<this._triangles.length;++t)this._triangles[t].deleted||l.push(this._triangles[t]);this._triangles=l}for(t=0;t<this._vertices.length;++t)this._vertices[t].triangleCount=0,this._vertices[t].triangleStart=0;let i,r,s;for(t=0;t<this._triangles.length;++t)for(i=this._triangles[t],r=0;r<3;++r)s=i._vertices[r],s.triangleCount++;let n=0;for(t=0;t<this._vertices.length;++t)this._vertices[t].triangleStart=n,n+=this._vertices[t].triangleCount,this._vertices[t].triangleCount=0;const o=new Array(this._triangles.length*3);for(t=0;t<this._triangles.length;++t)for(i=this._triangles[t],r=0;r<3;++r)s=i._vertices[r],o[s.triangleStart+s.triangleCount]=new aL(r,t),s.triangleCount++;this._references=o,e&&this._identifyBorder()}_vertexError(e,t){const i=t.x,r=t.y,s=t.z;return e.data[0]*i*i+2*e.data[1]*i*r+2*e.data[2]*i*s+2*e.data[3]*i+e.data[4]*r*r+2*e.data[5]*r*s+2*e.data[6]*r+e.data[7]*s*s+2*e.data[8]*s+e.data[9]}_calculateError(e,t,i){const r=e.q.add(t.q),s=e.isBorder&&t.isBorder;let n=0;const o=r.det(0,1,2,1,4,5,2,5,7);if(o!==0&&!s)i||(i=m.Zero()),i.x=-1/o*r.det(1,2,3,4,5,6,5,7,8),i.y=1/o*r.det(0,2,3,1,5,6,2,7,8),i.z=-1/o*r.det(0,1,3,1,4,6,2,5,8),n=this._vertexError(r,i);else{const l=e.position.add(t.position).divide(new m(2,2,2)),u=this._vertexError(r,e.position),c=this._vertexError(r,t.position),h=this._vertexError(r,l);n=Math.min(u,c,h),n===u?i&&i.copyFrom(e.position):n===c?i&&i.copyFrom(t.position):i&&i.copyFrom(l)}return n}}Object.defineProperty(Te.prototype,"simplificationQueue",{get:function(){if(!this._simplificationQueue){this._simplificationQueue=new rL;let a=this._getComponent(ge.NAME_SIMPLIFICATIONQUEUE);a||(a=new lL(this),this._addComponent(a))}return this._simplificationQueue},set:function(a){this._simplificationQueue=a},enumerable:!0,configurable:!0});z.prototype.simplify=function(a,e=!0,t=0,i){return this.getScene().simplificationQueue.addTask({settings:a,parallelProcessing:e,mesh:this,simplificationType:t,successCallback:i}),this};class lL{constructor(e){this.name=ge.NAME_SIMPLIFICATIONQUEUE,this.scene=e}register(){this.scene._beforeCameraUpdateStage.registerStep(ge.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE,this,this._beforeCameraUpdate)}rebuild(){}dispose(){}_beforeCameraUpdate(){this.scene._simplificationQueue&&!this.scene._simplificationQueue.running&&this.scene._simplificationQueue.executeNext()}}class uL{getClassName(){return"Lattice"}get resolutionX(){return this._resolutionX}get resolutionY(){return this._resolutionY}get resolutionZ(){return this._resolutionZ}get size(){return this._size}get position(){return this._position}get data(){return this._data}get cellSize(){return this._cellSize}get min(){return this._min}get max(){return this._max}constructor(e){this._cellSize=new m,this._min=new m(-.5,-.5,-.5),this._max=new m(.5,.5,.5),this._localPos=new m,this._tmpVector=new m,this._lerpVector0=new m,this._lerpVector1=new m,this._lerpVector2=new m,this._lerpVector3=new m,this._lerpVector4=new m,this._lerpVector5=new m;const t={resolutionX:3,resolutionY:3,resolutionZ:3,position:m.Zero(),size:m.One(),...e};this._resolutionX=t.resolutionX,this._resolutionY=t.resolutionY,this._resolutionZ=t.resolutionZ,this._position=t.position,this._size=t.autoAdaptToMesh?t.autoAdaptToMesh.getBoundingInfo().boundingBox.extendSize.scale(2):t.size,this._allocateData(),this.update()}_allocateData(){this._data=new Array(this.resolutionX);for(let e=0;e<this.resolutionX;e++){this._data[e]=new Array(this.resolutionY);for(let t=0;t<this.resolutionY;t++){this._data[e][t]=new Array(this.resolutionZ);for(let i=0;i<this.resolutionZ;i++)this._data[e][t][i]=m.Zero()}}}update(){for(let e=0;e<this.resolutionX;e++)for(let t=0;t<this.resolutionY;t++)for(let i=0;i<this.resolutionZ;i++){const r=-this.size.x/2+this.size.x*(e/(this.resolutionX-1)),s=-this.size.y/2+this.size.y*(t/(this.resolutionY-1)),n=-this.size.z/2+this.size.z*(i/(this.resolutionZ-1));this._data[e][t][i].set(r,s,n)}}deformMesh(e){const t=e.getVerticesData(N.PositionKind);t&&(this.deform(t),e.setVerticesData(N.PositionKind,t,!0))}updateInternals(){const e=this._resolutionX,t=this._resolutionY,i=this._resolutionZ;this._cellSize.set(this.size.x/(e-1),this.size.y/(t-1),this.size.z/(i-1)),this._min.set(this.position.x-this.size.x/2,this.position.y-this.size.y/2,this.position.z-this.size.z/2),this._min.addToRef(this._size,this._max)}deform(e,t){const i=this._resolutionX,r=this._resolutionY,s=this._resolutionZ;this.updateInternals();const n=this._min,o=this._max;for(let l=0;l<e.length;l+=3){const u=this._tmpVector.fromArray(e,l);if(Pc(u.x,n.x,o.x,He)||Pc(u.y,n.y,o.y,He)||Pc(u.z,n.z,o.z,He)){t&&u.toArray(t,l);continue}const c=this._localPos.set((u.x-n.x)/this._cellSize.x,(u.y-n.y)/this._cellSize.y,(u.z-n.z)/this._cellSize.z),h=Math.floor(c.x),d=Math.floor(c.y),f=Math.floor(c.z),p=Math.min(h+1,i-1),g=Math.min(d+1,r-1),_=Math.min(f+1,s-1),S=c.x-h,b=c.y-d,y=c.z-f,T=Si(h,0,i-1),v=Si(d,0,r-1),E=Si(f,0,s-1),R=Si(p,0,i-1),O=Si(g,0,r-1),w=Si(_,0,s-1),M=this._data[T][v][E],G=this._data[R][v][E],H=this._data[T][O][E],q=this._data[R][O][E],X=this._data[T][v][w],ee=this._data[R][v][w],oe=this._data[T][O][w],_e=this._data[R][O][w],te=m.LerpToRef(M,G,S,this._lerpVector0),ie=m.LerpToRef(X,ee,S,this._lerpVector1),Z=m.LerpToRef(H,q,S,this._lerpVector2),D=m.LerpToRef(oe,_e,S,this._lerpVector3),W=m.LerpToRef(te,Z,b,this._lerpVector4),K=m.LerpToRef(ie,D,b,this._lerpVector5),ue=m.LerpToRef(W,K,y,this._lerpVector0);ue.addInPlace(this.position),ue.toArray(t||e,l)}}}var tv;(function(a){a[a.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",a[a.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"})(tv||(tv={}));var iv;(function(a){a[a.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",a[a.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",a[a.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"})(iv||(iv={}));var rv;(function(a){a[a.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",a[a.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",a[a.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",a[a.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",a[a.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"})(rv||(rv={}));class fC extends z{constructor(e,t,i){super(e,t,null,null,!1,!1),this.name=e,this._options=i,this._lazy=!1,this._updatable=!1,this._engine=t.getEngine(),this._lazy=i.lazy??!1,this._updatable=i.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=i.colorPointers??[],this._widths=i.widths??new Array(i.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(e){let t=0;for(const r of this._points)t+=r.length;const i=t/3*2-this._widths.length;for(let r=0;r<i;r++)this._widths.push(e)}updateLazy(){var e,t;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers((e=this._options.ribbonOptions)==null?void 0:e.smoothShading),!this.doNotSyncBoundingInfo&&this.refreshBoundingInfo(),(t=this.greasedLineMaterial)==null||t.updateLazy()}addPoints(e,t){for(const i of e)this._points.push(i);this._lazy||this.setPoints(this._points,t)}dispose(e,t=!1){super.dispose(e,t)}isLazy(){return this._lazy}get uvs(){return this._uvs}set uvs(e){this._uvs=e instanceof Float32Array?e:new Float32Array(e),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(e){this.material instanceof za&&this.material.setDefine(D2,(e==null?void 0:e.length)>0),this._offsets=e,this._offsetsBuffer?this._offsetsBuffer.update(e):this._createOffsetsBuffer(e)}get widths(){return this._widths}set widths(e){this._widths=e,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(e)}get colorPointers(){return this._colorPointers}set colorPointers(e){this._colorPointers=e,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(e)}get greasedLineMaterial(){var t,i;if(this.material&&this.material instanceof za)return this.material;const e=(i=(t=this.material)==null?void 0:t.pluginManager)==null?void 0:i.getPlugin(Gr.GREASED_LINE_MATERIAL_NAME);if(e)return e}get points(){const e=[];return Ci.DeepCopy(this._points,e),e}setPoints(e,t){this._points=Je.ConvertPoints(e,(t==null?void 0:t.pointsOptions)??this._options.pointsOptions),this._updateWidths(),t!=null&&t.colorPointers||this._updateColorPointers(),this._setPoints(this._points,t)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,uvs:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(e){super.serialize(e),e.type=this.getClassName(),e.lineOptions=this._createLineOptions()}_createVertexBuffers(e=!1){const t=new he;return t.positions=this._vertexPositions,t.indices=this._indices,t.uvs=this._uvs,e&&(t.normals=[],he.ComputeNormals(this._vertexPositions,this._indices,t.normals)),t.applyToMesh(this,this._options.updatable),t}_createOffsetsBuffer(e){const t=this._scene.getEngine(),i=new fi(t,e,this._updatable,3);this.setVerticesBuffer(i.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=i}}z._GreasedLineMeshParser=(a,e)=>ii.Parse(a,e);class ii extends fC{constructor(e,t,i){super(e,t,i),this.name=e,this.intersectionThreshold=.1,this._previousAndSide=[],this._nextAndCounters=[],i.points&&this.addPoints(Je.ConvertPoints(i.points))}getClassName(){return"GreasedLineMesh"}_updateColorPointers(){if(this._options.colorPointers)return;let e=0;this._colorPointers=[],this._points.forEach(t=>{for(let i=0;i<t.length;i+=3)this._colorPointers.push(e),this._colorPointers.push(e++)})}_updateWidths(){}_setPoints(e){this._points=e,this._options.points=e,this._initGreasedLine();let t=0,i=0,r=0,s=0,n=0;e.forEach(S=>{i+=S.length*2,r+=(S.length-3)*2,s+=S.length*4/3,n+=S.length*8/3});const o=new Float32Array(i),l=i>65535?new Uint32Array(r):new Uint16Array(r),u=new Float32Array(s),c=new Float32Array(n),h=new Float32Array(n);let d=0,f=0,p=0,g=0,_=0;e.forEach(S=>{const b=Je.GetLineLengthArray(S),y=b[b.length-1];for(let M=0,G=0;G<S.length;M++,G+=3){const H=d+G*2;if(o[H+0]=S[G+0],o[H+1]=S[G+1],o[H+2]=S[G+2],o[H+3]=S[G+0],o[H+4]=S[G+1],o[H+5]=S[G+2],G<S.length-3){const q=M*2+t,X=f+G*2;l[X+0]=q,l[X+1]=q+1,l[X+2]=q+2,l[X+3]=q+2,l[X+4]=q+1,l[X+5]=q+3}}t+=S.length/3*2;const T=S.length*2,v=o.subarray(d,d+T);d+=T,f+=(S.length-3)*2;const E=new Float32Array(v.length),R=new Float32Array(v.length),O=v.length/6;let w;ii._CompareV3(0,O-1,v)?w=v.subarray((O-2)*6,(O-1)*6):w=v.subarray(0,6),E.set(w),E.set(v.subarray(0,v.length-6),6),R.set(v.subarray(6)),ii._CompareV3(O-1,0,v)?w=v.subarray(6,12):w=v.subarray((O-1)*6,O*6),R.set(w,R.length-6);for(let M=0,G=v.length/3;M<G;M++)c[g++]=E[M*3],c[g++]=E[M*3+1],c[g++]=E[M*3+2],c[g++]=1-((M&1)<<1),h[_++]=R[M*3],h[_++]=R[M*3+1],h[_++]=R[M*3+2],h[_++]=b[M>>1]/y;if(this._options.uvs)for(let M=0;M<this._options.uvs.length;M++)u[p++]=this._options.uvs[M];else for(let M=0;M<O;M++){const G=b[M]/y,H=p+M*4;u[H+0]=G,u[H+1]=0,u[H+2]=G,u[H+3]=1}}),this._vertexPositions=o,this._indices=l,this._uvs=u,this._previousAndSide=c,this._nextAndCounters=h,this._lazy||(this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(),!this.doNotSyncBoundingInfo&&this.refreshBoundingInfo())}clone(e=`${this.name}-cloned`,t){const i=this._createLineOptions(),r={};Ci.DeepCopy(i,r,["instance"],void 0,!0);const s=new ii(e,this._scene,r);return t&&(s.parent=t),s.material=this.material,s}serialize(e){super.serialize(e),e.type=this.getClassName(),e.lineOptions=this._createLineOptions()}static Parse(e,t){const i=e.lineOptions,r=e.name;return new ii(r,t,i)}_initGreasedLine(){super._initGreasedLine(),this._previousAndSide=[],this._nextAndCounters=[]}intersects(e,t,i,r=!1,s,n=!1){const o=new Qi,l=this.findAllIntersections(e,t,i,r,s,n,!0);if((l==null?void 0:l.length)===1){const u=l[0];o.hit=!0,o.distance=u.distance,o.ray=e,o.pickedMesh=this,o.pickedPoint=u.point}return o}findAllIntersections(e,t,i,r=!1,s,n=!1,o=!1){var f;if(r&&!n&&e.intersectsSphere(this._boundingSphere,this.intersectionThreshold)===!1)return;const l=this.getIndices(),u=this.getVerticesData(N.PositionKind),c=this._widths,h=((f=this.greasedLineMaterial)==null?void 0:f.width)??1,d=[];if(l&&u&&c){let p=0,g=0;for(p=0,g=l.length-1;p<g;p+=3){const _=l[p],S=l[p+1];ii._V_START.fromArray(u,_*3),ii._V_END.fromArray(u,S*3),this._offsets&&(ii._V_OFFSET_START.fromArray(this._offsets,_*3),ii._V_OFFSET_END.fromArray(this._offsets,S*3),ii._V_START.addInPlace(ii._V_OFFSET_START),ii._V_END.addInPlace(ii._V_OFFSET_END));const b=Math.floor(p/3),y=c[b]!==void 0?c[b]:1,T=this.intersectionThreshold*(h*y)/2,v=e.intersectionSegment(ii._V_START,ii._V_END,T);if(v!==-1&&(d.push({distance:v,point:e.direction.normalize().multiplyByFloats(v,v,v).add(e.origin)}),o))return d}p=g}return d}get _boundingSphere(){return this.getBoundingInfo().boundingSphere}static _CompareV3(e,t,i){const r=e*6,s=t*6;return i[r]===i[s]&&i[r+1]===i[s+1]&&i[r+2]===i[s+2]}_createVertexBuffers(){const e=super._createVertexBuffers(),t=this._scene.getEngine(),i=new fi(t,this._previousAndSide,!1,4);this.setVerticesBuffer(i.createVertexBuffer("grl_previousAndSide",0,4));const r=new fi(t,this._nextAndCounters,!1,4);this.setVerticesBuffer(r.createVertexBuffer("grl_nextAndCounters",0,4));const s=new fi(t,this._widths,this._updatable,1);this.setVerticesBuffer(s.createVertexBuffer("grl_widths",0,1)),this._widthsBuffer=s;const n=new fi(t,this._colorPointers,this._updatable,1);return this.setVerticesBuffer(n.createVertexBuffer("grl_colorPointers",0,1)),this._colorPointersBuffer=n,e}}ii._V_START=new m;ii._V_END=new m;ii._V_OFFSET_START=new m;ii._V_OFFSET_END=new m;z._GreasedLineRibbonMeshParser=(a,e)=>Et.Parse(a,e);class Et extends fC{constructor(e,t,i,r){if(super(e,t,i),this.name=e,!i.ribbonOptions)throw"'GreasedLineMeshOptions.ribbonOptions' is not set.";this._paths=[],this._counters=[],this._slopes=[],this._widths=i.widths??[],this._ribbonWidths=[],this._pathsOptions=r??[],i.points&&this.addPoints(Je.ConvertPoints(i.points),i,!!r)}addPoints(e,t,i=!1){if(!t.ribbonOptions)throw"addPoints() on GreasedLineRibbonMesh instance requires 'GreasedLineMeshOptions.ribbonOptions'.";i||this._pathsOptions.push({options:t,pathCount:e.length}),super.addPoints(e,t)}getClassName(){return"GreasedLineRibbonMesh"}get isFlatLine(){return this._paths.length<3}get slopes(){return this._slopes}set slopes(e){this._slopes=e}_updateColorPointers(){if(this._options.colorPointers)return;let e=0;this._colorPointers=[];for(let t=0;t<this._pathsOptions.length;t++){const{options:i,pathCount:r}=this._pathsOptions[t],s=this._points[t];if(i.ribbonOptions.pointsMode===0)for(let n=0;n<r;n++)for(let o=0;o<s.length;o+=3)this._colorPointers.push(e),this._colorPointers.push(e++);else for(let n=0;n<s.length;n+=3){for(let o=0;o<r;o++)this._colorPointers.push(e);e++}}}_updateWidths(){super._updateWidthsWithValue(1)}_setPoints(e,t){var s,n;if(!this._options.ribbonOptions)throw"No 'GreasedLineMeshOptions.ribbonOptions' provided.";this._points=e,this._options.points=e,this._initGreasedLine();let i=0,r;for(let o=0,l=0;o<this._pathsOptions.length;o++){const{options:u,pathCount:c}=this._pathsOptions[o],h=e.slice(l,l+c);if(l+=c,((s=u.ribbonOptions)==null?void 0:s.pointsMode)===1)i=this._preprocess(Je.ToVector3Array(h),i,u);else{if(((n=u.ribbonOptions)==null?void 0:n.directionsAutoMode)===99){if(!u.ribbonOptions.directions)throw"In GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_NONE 'GreasedLineMeshOptions.ribbonOptions.directions' must be defined.";r=Et._GetDirectionPlanesFromDirectionsOption(h.length,u.ribbonOptions.directions)}h.forEach((d,f)=>{const p=Et._ConvertToRibbonPath(d,u.ribbonOptions,this._scene.useRightHandedSystem,r&&r[f]);i=this._preprocess(p,i,u)})}}this._lazy||(this._createVertexBuffers(),!this.doNotSyncBoundingInfo&&this.refreshBoundingInfo())}static _GetDirectionPlanesFromDirectionsOption(e,t){return Array.isArray(t)?t:new Array(e).fill(t)}static _CreateRibbonVertexData(e,t){var c,h;const i=e.length;if(i<2)throw"Minimum of two paths are required to create a GreasedLineRibbonMesh.";const r=[],s=[],n=e[0];for(let d=0;d<n.length;d++)for(let f=0;f<e.length;f++){const p=e[f][d];r.push(p.x,p.y,p.z)}const o=[1,0,i],l=((c=t.ribbonOptions)==null?void 0:c.facesMode)===2,u=((h=t.ribbonOptions)==null?void 0:h.pointsMode)===1&&t.ribbonOptions.closePath;if(i>2)for(let d=0;d<n.length-1;d++){o[0]=1+i*d,o[1]=i*d,o[2]=(d+1)*i;for(let f=0;f<(i-1)*2;f++)f%2!==0&&(o[2]+=1),f%2===0&&f>0&&(o[0]+=1,o[1]+=1),s.push(o[1]+(f%2!==0?i:0),o[0],o[2]),l&&s.push(o[0],o[1]+(f%2!==0?i:0),o[2])}else for(let d=0;d<r.length/3-3;d+=2)s.push(d,d+1,d+2),s.push(d+2,d+1,d+3),l&&(s.push(d+1,d,d+2),s.push(d+1,d+2,d+3));if(u){let d=i*(n.length-1);for(let f=0;f<i-1;f++)s.push(d,f+1,f),s.push(d+1,f+1,d),l&&(s.push(f,f+1,d),s.push(d,f+1,d+1)),d++}return{positions:r,indices:s}}_preprocess(e,t,i){var f,p;this._paths=e;const r=Et._CreateRibbonVertexData(e,i),s=r.positions;if(!this._options.widths)throw"No 'GreasedLineMeshOptions.widths' table is specified.";const n=Array.isArray(this._vertexPositions)?this._vertexPositions:Array.from(this._vertexPositions);this._vertexPositions=n;const o=Array.isArray(this._uvs)?this._uvs:Array.from(this._uvs);this._uvs=o;const l=Array.isArray(this._indices)?this._indices:Array.from(this._indices);this._indices=l;for(const g of s)n.push(g);let u=e;if(((f=i.ribbonOptions)==null?void 0:f.pointsMode)===1&&i.ribbonOptions.closePath){u=[];for(let g=0;g<e.length;g++){const _=e[g].slice();_.push(e[g][0].clone()),u.push(_)}}this._calculateSegmentLengths(u);const c=u.length,h=new Array(c).fill(0);for(let g=0;g<u[0].length;g++){let _=0;for(let S=0;S<c;S++){const b=h[S]+this._vSegmentLengths[S][g]/this._vTotalLengths[S];this._counters.push(b),o.push(b,_),h[S]=b,_+=this._uSegmentLengths[g][S]/this._uTotalLengths[g]}}for(let g=0,_=0;g<u[0].length;g++){const S=this._uSegmentLengths[g][0]/2,b=this._uSegmentLengths[g][c-1]/2;this._ribbonWidths.push(((this._widths[_++]??1)-1)*S);for(let y=0;y<c-2;y++)this._ribbonWidths.push(0);this._ribbonWidths.push(((this._widths[_++]??1)-1)*b)}const d=((p=i.ribbonOptions)==null?void 0:p.pointsMode)===1?new Array(u[0].length*u.length*6).fill(0):Et._CalculateSlopes(u);for(const g of d)this._slopes.push(g);if(r.indices)for(let g=0;g<r.indices.length;g++)l.push(r.indices[g]+t);return t+=s.length/3,t}static _ConvertToRibbonPath(e,t,i,r){if(t.pointsMode===0&&!t.width)throw"'GreasedLineMeshOptions.ribbonOptiosn.width' must be specified in GreasedLineRibbonPointsMode.POINTS_MODE_POINTS.";const s=[],n=[];if(t.pointsMode===0){const o=t.width/2,l=Je.ToVector3Array(e);let u=null,c=null;if(t.directionsAutoMode===0&&(r=Et._GetDirectionFromPoints(l[0],l[1],null)),t.directionsAutoMode===3&&!(t.directions instanceof m))throw"In GreasedLineRibbonAutoDirectionMode.AUTO_DIRECTIONS_FACE_TO 'GreasedLineMeshOptions.ribbonOptions.directions' must be a Vector3.";V.Vector3[1]=t.directions instanceof m?t.directions:Et.DIRECTION_XZ;for(let h=0;h<l.length-(r?0:1);h++){const d=l[h],f=l[h+1];if(r)u=r;else if(t.directionsAutoMode===3)f.subtractToRef(d,V.Vector3[0]),u=m.CrossToRef(V.Vector3[0],V.Vector3[1],V.Vector3[2]).normalize();else if(t.directionsAutoMode===1)u=Et._GetDirectionFromPoints(d,f,u);else{const p=f.subtract(d);p.applyRotationQuaternionInPlace(p.x>p.y&&p.x>p.z?i?Et._RightHandedForwardReadOnlyQuaternion:Et._LeftHandedForwardReadOnlyQuaternion:Et._LeftReadOnlyQuaternion),u=p.normalize()}c=u.multiplyByFloats(o,o,o),s.push(d.add(c)),n.push(d.subtract(c))}r||(s.push(l[l.length-1].add(c)),n.push(l[l.length-1].subtract(c)))}return[s,n]}static _GetDirectionFromPoints(e,t,i){return e.x===t.x&&(!i||(i==null?void 0:i.x)===1)?Et.DIRECTION_YZ:e.y===t.y?Et.DIRECTION_XZ:e.z===t.z?Et.DIRECTION_XY:Et.DIRECTION_XZ}clone(e=`${this.name}-cloned`,t){const i=this._createLineOptions(),r={},s=[];Ci.DeepCopy(this._pathsOptions,s,void 0,void 0,!0),Ci.DeepCopy(i,r,["instance"],void 0,!0);const n=new Et(e,this._scene,r,s);return t&&(n.parent=t),n.material=this.material,n}serialize(e){super.serialize(e),e.type=this.getClassName(),e.lineOptions=this._createLineOptions(),e.pathsOptions=this._pathsOptions}static Parse(e,t){const i=e.lineOptions,r=e.name,s=e.pathOptions;return new Et(r,t,i,s)}_initGreasedLine(){super._initGreasedLine(),this._paths=[],this._counters=[],this._slopes=[],this._ribbonWidths=[]}_calculateSegmentLengths(e){const t=e.length;this._vSegmentLengths=new Array(t),this._vTotalLengths=new Array(t);let i=0;for(let n=0;n<t;n++){const o=e[n];this._vSegmentLengths[n]=[0],i=0;for(let l=0;l<o.length-1;l++){const u=Math.abs(o[l].subtract(o[l+1]).lengthSquared());i+=u,this._vSegmentLengths[n].push(u)}this._vTotalLengths[n]=i}const r=e[0].length;this._uSegmentLengths=new Array(r).fill([]),this._uTotalLengths=new Array(r).fill([]);const s=new m;for(let n=0;n<r;n++){i=0;for(let o=1;o<t;o++){e[o][n].subtractToRef(e[o-1][n],s);const l=s.length();i+=l,this._uSegmentLengths[n].push(l)}this._uTotalLengths[n]=i}}static _CalculateSlopes(e){const t=e[0],i=e.length===2?e[1]:e[e.length-1],r=[],s=new m;for(let n=0;n<t.length;n++)for(let o=0;o<e.length;o++)o===0||o===e.length-1?(t[n].subtract(i[n]).normalizeToRef(s),r.push(s.x,s.y,s.z),r.push(-s.x,-s.y,-s.z)):r.push(0,0,0,0,0,0);return r}_createVertexBuffers(){var n;this._uvs=this._options.uvs??this._uvs;const e=super._createVertexBuffers((n=this._options.ribbonOptions)==null?void 0:n.smoothShading),t=new fi(this._engine,this._counters,this._updatable,1);this.setVerticesBuffer(t.createVertexBuffer("grl_counters",0,1));const i=new fi(this._engine,this._colorPointers,this._updatable,1);this.setVerticesBuffer(i.createVertexBuffer("grl_colorPointers",0,1));const r=new fi(this._engine,this._slopes,this._updatable,3);this.setVerticesBuffer(r.createVertexBuffer("grl_slopes",0,3));const s=new fi(this._engine,this._ribbonWidths,this._updatable,1);return this.setVerticesBuffer(s.createVertexBuffer("grl_widths",0,1)),this._widthsBuffer=s,e}}Et.DEFAULT_WIDTH=.1;Et._RightHandedForwardReadOnlyQuaternion=re.RotationAxis(m.RightHandedForwardReadOnly,Math.PI/2);Et._LeftHandedForwardReadOnlyQuaternion=re.RotationAxis(m.LeftHandedForwardReadOnly,Math.PI/2);Et._LeftReadOnlyQuaternion=re.RotationAxis(m.LeftReadOnly,Math.PI/2);Et.DIRECTION_XY=m.LeftHandedForwardReadOnly;Et.DIRECTION_XZ=m.UpReadOnly;Et.DIRECTION_YZ=m.LeftReadOnly;var sv;(function(a){a[a.COLOR_DISTRIBUTION_NONE=0]="COLOR_DISTRIBUTION_NONE",a[a.COLOR_DISTRIBUTION_REPEAT=1]="COLOR_DISTRIBUTION_REPEAT",a[a.COLOR_DISTRIBUTION_EVEN=2]="COLOR_DISTRIBUTION_EVEN",a[a.COLOR_DISTRIBUTION_START=3]="COLOR_DISTRIBUTION_START",a[a.COLOR_DISTRIBUTION_END=4]="COLOR_DISTRIBUTION_END",a[a.COLOR_DISTRIBUTION_START_END=5]="COLOR_DISTRIBUTION_START_END"})(sv||(sv={}));var nv;(function(a){a[a.WIDTH_DISTRIBUTION_NONE=0]="WIDTH_DISTRIBUTION_NONE",a[a.WIDTH_DISTRIBUTION_REPEAT=1]="WIDTH_DISTRIBUTION_REPEAT",a[a.WIDTH_DISTRIBUTION_EVEN=2]="WIDTH_DISTRIBUTION_EVEN",a[a.WIDTH_DISTRIBUTION_START=3]="WIDTH_DISTRIBUTION_START",a[a.WIDTH_DISTRIBUTION_END=4]="WIDTH_DISTRIBUTION_END",a[a.WIDTH_DISTRIBUTION_START_END=5]="WIDTH_DISTRIBUTION_START_END"})(nv||(nv={}));function cL(a,e,t){t=t??ze.LastCreatedScene;let i;switch(e.materialType){case 1:i=new xy(a,t,e.forceGLSL),new Gr(i,t,e);break;case 2:i=new za(a,t,e);break;default:i=new Ut(a,t,e.forceGLSL),new Gr(i,t,e);break}return i}function UW(a,e,t,i){var c;i=i??ze.LastCreatedScene;let r;const s=Je.ConvertPoints(e.points,e.pointsOptions);e.widthDistribution=e.widthDistribution??3,e.ribbonOptions&&(e.ribbonOptions.facesMode=e.ribbonOptions.facesMode??1,e.ribbonOptions.pointsMode=e.ribbonOptions.pointsMode??0,e.ribbonOptions.directionsAutoMode=e.ribbonOptions.directionsAutoMode??(e.ribbonOptions.directions?99:0)),t=t??{color:Xt.DEFAULT_COLOR},t.createAndAssignMaterial=t.createAndAssignMaterial??!0,t.colorDistribution=(t==null?void 0:t.colorDistribution)??3,t.materialType=t.materialType??0;const n=hL(s),o=dL(n,e.widths??[],e.widthDistribution),l=t!=null&&t.colors?fL(n,t.colors,t.colorDistribution,t.color??Xt.DEFAULT_COLOR):void 0,u={points:s,updatable:e.updatable,widths:o,lazy:e.lazy,ribbonOptions:e.ribbonOptions,uvs:e.uvs,colorPointers:e.colorPointers};if(u.ribbonOptions&&u.ribbonOptions.pointsMode===0&&(u.ribbonOptions.width=t.width??u.ribbonOptions.width??Xt.DEFAULT_WIDTH),e.instance)if(r=e.instance,r instanceof Et)r.addPoints(s,u);else{const h=r.widths;if(h){const d=h.slice();for(const f of o)d.push(f);r.widths=d}else r.widths=o;if(r.addPoints(s),e.uvs){const d=r.uvs;if(d){const f=new Float32Array(d.length+e.uvs.length);f.set(d,0),f.set(e.uvs,d.length),r.uvs=f}else r.uvs=e.uvs}}else if(r=u.ribbonOptions?new Et(a,i,u):new ii(a,i,u),t){const h={materialType:t.materialType,dashCount:t.dashCount,dashOffset:t.dashOffset,dashRatio:t.dashRatio,resolution:t.resolution,sizeAttenuation:t.sizeAttenuation,useColors:t.useColors,useDash:t.useDash,visibility:t.visibility,width:t.width,color:t.color,colorMode:t.colorMode,colorsSampling:t.colorsSampling,colorDistributionType:t.colorDistributionType,colors:l,cameraFacing:!e.ribbonOptions,colorsTexture:t.colorsTexture};if(t.createAndAssignMaterial){const d=cL(a,h,i);r.material=d,((c=e.ribbonOptions)==null?void 0:c.facesMode)===1&&(d.backFaceCulling=!1)}}if(l&&e.instance&&e.instance.greasedLineMaterial){const h=e.instance.greasedLineMaterial.colors;if(h){const d=h.concat(l);e.instance.greasedLineMaterial.setColors(d,r.isLazy())}}return r}function hL(a){let e=0;for(const t of a)e+=t.length/3;return e}function dL(a,e,t,i=1,r=1){const s=a-e.length/2,n=[];if(s<0)return e.slice(0,a*2);if(s>0){if(e.length%2!=0&&e.push(i),t===5){const o=Math.floor(e.length/2);for(let c=0,h=0;c<o-1;c++)n.push(e[h++]),n.push(e[h++]);const l=e[o/2],u=e[o/2+1];for(let c=0;c<s;c++)n.push(u),n.push(l);for(let c=o;c<e.length;c+=2)n.push(e[c]),n.push(e[c+1])}else if(t===3){for(let o=0;o<e.length;o+=2)n.push(e[o]),n.push(e[o+1]);for(let o=0;o<s;o++)n.push(i),n.push(r)}else if(t===4){for(let o=0;o<s;o++)n.push(i),n.push(r);for(let o=0;o<e.length;o+=2)n.push(e[o]),n.push(e[o+1])}else if(t===1){let o=0;for(let l=0;l<a;l++)n.push(e[o++]),n.push(e[o++]),o===e.length&&(o=0)}else if(t===2){let o=0;const l=e.length/((a-1)*2);for(let u=0;u<a;u++){const c=Math.floor(o);n.push(e[c]),n.push(e[c+1]),o+=l}}}else for(let o=0;o<e.length;o++)n.push(e[o]);return n}function fL(a,e,t,i){a=Math.max(e.length,a);const r=a-e.length;if(r<0)return e.slice(0,a);const s=[];if(r>0){if(t===5){const n=Math.floor(e.length/2);for(let o=0;o<n;o++)s.push(e[o]);for(let o=0;o<r-1;o++)s.push(i);for(let o=n;o<e.length;o++)s.push(e[o])}else if(t===3){for(let n=0;n<e.length;n++)s.push(e[n]);for(let n=0;n<r;n++)s.push(i)}else if(t===4){for(let n=0;n<r-1;n++)s.push(i);for(let n=0;n<e.length;n++)s.push(e[n])}else if(t===1){let n=0;for(let o=0;o<a;o++)s.push(e[n]),n++,n===e.length&&(n=0)}else if(t===2){let n=0;const o=e.length/(a-1);for(let l=0;l<a-1;l++){const u=Math.floor(n);s.push(e[u]),n+=o}}else if(t===0)for(let n=0;n<e.length;n++)s.push(e[n])}else for(let n=0;n<a;n++)s.push(e[n]);return s}let Nl=0;function pL(a,e){return new Promise((t,i)=>{let r,s;if(Om())r=window,s="window";else if(typeof self<"u")r=self,s="self";else{i(new Error("Cannot load script module outside of a window or a worker"));return}r._LoadScriptModuleResolve||(r._LoadScriptModuleResolve={}),r._LoadScriptModuleResolve[Nl]=t,a+=`
            ${s}._LoadScriptModuleResolve[${Nl}](returnedValue);
            ${s}._LoadScriptModuleResolve[${Nl}] = undefined;
        `,Nl++,ae.LoadScript(a,void 0,(n,o)=>{i(o||new Error(n))},e,!0)})}let Nn,Fl,pd,Wl;class Ko{get numProp(){return this._numProp}constructor(e,t,i){this._manifold=e,this._numProp=t,this._vertexStructure=i}_process(e,t){if(this.numProp!==t.numProp)throw new Error("CSG must be used with geometries having the same number of properties");return new Ko(Nn[e](this._manifold,t._manifold),this.numProp,this._vertexStructure)}subtract(e){return this._process("difference",e)}intersect(e){return this._process("intersection",e)}add(e){return this._process("union",e)}printDebug(){L.Log("Genus:"+this._manifold.genus());const e=this._manifold.getProperties();L.Log("Volume:"+e.volume),L.Log("surface area:"+e.surfaceArea)}toVertexData(e){const t={rebuildNormals:!1,...e},i=new he,r=this._vertexStructure.find(l=>l.kind===N.NormalKind),s=this._manifold.getMesh(t.rebuildNormals&&r?[3,4,5]:void 0);i.indices=s.triVerts.length>65535?new Uint32Array(s.triVerts):new Uint16Array(s.triVerts);for(let l=0;l<s.triVerts.length;l+=3)i.indices[l]=s.triVerts[l+2],i.indices[l+1]=s.triVerts[l+1],i.indices[l+2]=s.triVerts[l];const n=s.vertProperties.length/s.numProp;let o=0;for(let l=0;l<this._vertexStructure.length;l++){const u=this._vertexStructure[l],c=new Float32Array(n*u.stride);for(let h=0;h<n;h++)for(let d=0;d<u.stride;d++)c[h*u.stride+d]=s.vertProperties[h*s.numProp+o+d];i.set(c,u.kind),o+=u.stride}return i}toMesh(e,t,i){const r={rebuildNormals:!1,centerMesh:!0,...i},s=this.toVertexData({rebuildNormals:r.rebuildNormals}),n=this._vertexStructure.find(p=>p.kind===N.NormalKind),o=this._manifold.getMesh(r.rebuildNormals&&n?[3,4,5]:void 0),l=o.vertProperties.length/o.numProp,u=new z(e,t);if(s.applyToMesh(u),r.centerMesh){const p=u.getBoundingInfo().boundingSphere.center;u.position.set(-p.x,-p.y,-p.z),u.bakeCurrentTransformIntoVertices()}let c=o.runOriginalID[0],h=o.runIndex[0],d=0;const f=[];t=u.getScene();for(let p=0;p<o.numRun;++p){const g=o.runOriginalID[p+1];if(g!==c){const _=o.runIndex[p+1];new zn(d,0,l,h,_-h,u),f.push(t.getMaterialByUniqueID(c-Wl)||t.defaultMaterial),c=g,h=_,d++}}if(r.materialToUse)u.material=r.materialToUse;else if(f.length>1){const p=new xu(e,t);p.subMaterials=f,u.material=p}else u.subMeshes.length>1&&u._createGlobalSubMesh(!0),u.material=f[0];return u}dispose(){this._manifold&&(this._manifold.delete(),this._manifold=null)}static _ProcessData(e,t,i,r,s,n){const o=new Float32Array(e*i.reduce((c,h)=>c+h.stride,0));for(let c=0;c<e;c++){let h=0;for(let d=0;d<i.length;d++){const f=i[d];for(let p=0;p<f.stride;p++)o[c*r+h+p]=f.data[c*f.stride+p];h+=f.stride}}const l=new pd({numProp:r,vertProperties:o,triVerts:t,runIndex:s,runOriginalID:n});l.merge();let u;try{u=new Ko(new Nn(l),r,i)}catch(c){throw new Error("Error while creating the CSG: "+c.message)}return u}static _Construct(e,t,i,r){const s=new Uint32Array(e.indices.length);for(let h=0;h<e.indices.length;h+=3)s[h]=e.indices[h+2],s[h+1]=e.indices[h+1],s[h+2]=e.indices[h];const n=new m;let o=3;const l=[{stride:3,kind:N.PositionKind}];if(!t)l[0].data=e.positions;else{const h=new Float32Array(e.positions.length);for(let d=0;d<e.positions.length;d+=3)m.TransformCoordinatesFromFloatsToRef(e.positions[d],e.positions[d+1],e.positions[d+2],t,n),n.toArray(h,d);l[0].data=h}const u=e.normals;if(u)if(o+=3,l.push({stride:3,kind:N.NormalKind}),!t)l[1].data=u;else{const h=new Float32Array(u.length);for(let d=0;d<u.length;d+=3)m.TransformNormalFromFloatsToRef(u[d],u[d+1],u[d+2],t,n),n.toArray(h,d);l[1].data=h}for(const h of[N.UVKind,N.UV2Kind,N.UV3Kind,N.UV4Kind,N.UV5Kind,N.UV6Kind]){const d=e[h===N.UVKind?"uvs":h];d&&(o+=2,l.push({stride:2,kind:h,data:d}))}const c=e.colors;return c&&(o+=4,l.push({stride:4,kind:N.ColorKind,data:c})),this._ProcessData(e.positions.length/3,s,l,o,i,r)}static FromVertexData(e){const t=e.positions,i=e.indices;if(!t||!i)throw new Error("The vertexData must at least have positions and indices");return this._Construct(e,null)}static FromMesh(e,t=!1){const i=e.getVerticesData(N.PositionKind),r=e.getIndices(),s=e.computeWorldMatrix(!0);if(!i||!r)throw new Error("The mesh must at least have positions and indices");const n=[...Array(e.subMeshes.length)].map((p,g)=>e.subMeshes[g].indexStart),o=e.material||e.getScene().defaultMaterial,l=o.getClassName()==="MultiMaterial",u=[...Array(e.subMeshes.length)].map((p,g)=>l?Wl+o.subMaterials[e.subMeshes[g].materialIndex].uniqueId:Wl+o.uniqueId),c=Array.from(n.keys());c.sort((p,g)=>n[p]-n[g]);const h=new Uint32Array(c.map(p=>n[p])),d=new Uint32Array(c.map(p=>u[p])),f={positions:i,indices:r,normals:e.getVerticesData(N.NormalKind),colors:e.getVerticesData(N.ColorKind),uvs:e.getVerticesData(N.UVKind),uvs2:e.getVerticesData(N.UV2Kind),uvs3:e.getVerticesData(N.UV3Kind),uvs4:e.getVerticesData(N.UV4Kind),uvs5:e.getVerticesData(N.UV5Kind),uvs6:e.getVerticesData(N.UV6Kind)};return this._Construct(f,t?null:s,h,d)}}function mL(){return Nn!==void 0}async function _L(a){const e={manifoldUrl:"https://unpkg.com/manifold-3d@3.0.1",...a};if(!Nn){if(Fl){await Fl;return}if(e.manifoldInstance)Nn=e.manifoldInstance,pd=e.manifoldMeshInstance;else{Fl=pL(`
            import Module from '${e.manifoldUrl}/manifold.js';
            const wasm = await Module();
            wasm.setup();
            const {Manifold, Mesh} = wasm;
            const returnedValue =  {Manifold, Mesh};
        `);const t=await Fl;Nn=t.Manifold,pd=t.Mesh}Wl=Nn.reserveIDs(65536)}}const pC=Math.pow(10,4);function gL(a){return a+(a>0?.5:-.5)<<0}function zc(a,e=pC){let t=gL(a*e);return t===0&&(t=0),`${t}`}function Oi(a,e=pC){return`${zc(a.x,e)},${zc(a.y,e)},${zc(a.z,e)}`}function xL(a){const e=["positions","normals","uvs"],t=Object.keys(a).filter(i=>Array.isArray(a[i]));return Array.from(new Set([...e,...t]))}function SL(a,e,t,i,r,s){for(let n=0;n<t;n++)a[e+n]=i[n],a[e+t+n]=r[n],a[e+2*t+n]=s[n]}function mC(a){if(!a.indices||a.indices.length===0)return a;const e=[],t=[],i=[],r=a.indices,s=a.positions,n=a.normals,o=a.uvs;for(let u=0;u<r.length;u++){const c=r[u];e.push(s[3*c],s[3*c+1],s[3*c+2]),n&&t.push(n[3*c],n[3*c+1],n[3*c+2]),o&&i.push(o[2*c],o[2*c+1])}const l=new he;return l.positions=e,t.length&&(l.normals=t),i.length&&(l.uvs=i),l}function xr(a,e,t,i){if(i===3){a.fromArray(e,t*3);return}a.set(e[t*2],e[t*2+1],0)}function av(a,e,t){const i=new m,r=new m,s=new m,n=new m,o=new m,l=new m;for(let u=0;u<e;u+=3){const c=u*3;i.set(a[c],a[c+1],a[c+2]),r.set(a[c+3],a[c+4],a[c+5]),s.set(a[c+6],a[c+7],a[c+8]),i.addToRef(r,n),n.scaleInPlace(.5),r.addToRef(s,o),o.scaleInPlace(.5),s.addToRef(i,l),l.scaleInPlace(.5),t.push(i.x,i.y,i.z,n.x,n.y,n.z,l.x,l.y,l.z),t.push(r.x,r.y,r.z,o.x,o.y,o.z,n.x,n.y,n.z),t.push(s.x,s.y,s.z,l.x,l.y,l.z,o.x,o.y,o.z),t.push(n.x,n.y,n.z,o.x,o.y,o.z,l.x,l.y,l.z)}}function _C(a){const e=mC(a),t=e.positions,i=e.normals,r=e.uvs,s=t.length/3,n=[],o=[],l=[];if(av(t,s,n),i&&i.length&&av(i,s,o),r&&r.length)for(let d=0;d<s;d+=3){const f=d*2,p=[r[f],r[f+1]],g=[r[f+2],r[f+3]],_=[r[f+4],r[f+5]],S=[(p[0]+g[0])/2,(p[1]+g[1])/2],b=[(g[0]+_[0])/2,(g[1]+_[1])/2],y=[(_[0]+p[0])/2,(_[1]+p[1])/2];l.push(...p,...S,...y),l.push(...g,...b,...S),l.push(..._,...y,...b),l.push(...S,...b,...y)}const u=n.length/3,c=[];for(let d=0;d<u;d++)c.push(d);const h=new he;return h.positions=n,o.length&&(h.normals=o),l.length&&(h.uvs=l),h.indices=c,h}function vL(a,e){const t=mC(a),i=_C(t),r=xL(t),s=t.positions,n=i.positions,o=s.length/3,l={},u={},c={},h={};function d(X,ee,oe){u[X]||(u[X]={}),u[X][ee]||(u[X][ee]=[]),u[X][ee].push(oe)}function f(X,ee){c[X]||(c[X]=[]),c[X].push(ee)}function p(X,ee){h[X]||(h[X]=new Set),h[X].add(ee)}const g=new m,_=new m,S=new m,b=new m,y=new m,T=new m,v=new m;for(let X=0;X<o;X+=3){xr(_,s,X,3),xr(S,s,X+1,3),xr(b,s,X+2,3);const ee=Oi(_),oe=Oi(S),_e=Oi(b);d(ee,oe,X+1),d(ee,_e,X+2),d(oe,ee,X),d(oe,_e,X+2),d(_e,ee,X),d(_e,oe,X+1),_.addToRef(S,y),y.scaleInPlace(.5),S.addToRef(b,T),T.scaleInPlace(.5),b.addToRef(_,v),v.scaleInPlace(.5),f(Oi(y),X+2),f(Oi(T),X),f(Oi(v),X+1),p(ee,Oi(y)),p(ee,Oi(v)),p(oe,Oi(y)),p(oe,Oi(T)),p(_e,Oi(T)),p(_e,Oi(v))}for(let X=0;X<n.length/3;X++){xr(g,n,X,3);const ee=Oi(g);l[ee]||(l[ee]=[]),l[ee].push(X)}const E=[new m,new m,new m],R=[new m,new m,new m],O=new m,w=new m;function M(X,ee,oe){const _e=X==="uvs"?2:3,te=n.length/3,ie=new Array(te*_e);let Z=0;for(let D=0;D<te;D+=3){for(let W=0;W<3;W++)if(X==="uvs"&&!e.uvSmooth)xr(E[W],oe,D+W,2);else if(X==="normals"){xr(R[W],n,D+W,3);const K=Oi(R[W]),ue=l[K]||[],ye=ue.length,se=.75/ye,ce=1-se*ye;xr(E[W],oe,D+W,3),E[W].scaleInPlace(ce),ue.forEach(fe=>{xr(O,oe,fe,3),O.scaleInPlace(se),E[W].addInPlace(O)})}else{xr(E[W],oe,D+W,_e),xr(R[W],n,D+W,3);const K=Oi(R[W]),ue=u[K],ye=c[K];if(ue){if(e.preserveEdges){const Se=h[K];let Ge=!0;if(Se.forEach(Pe=>{c[Pe]&&c[Pe].length%2!==0&&(Ge=!1)}),!Ge)continue}const ce=Object.keys(ue).length,fe=1/ce*(5/8-Math.pow(3/8+1/4*Math.cos(2*Math.PI/ce),2)),pe=1/ce/ce,Ie=AM.Lerp(pe,fe,e.weight),vt=1-Ie*ce;E[W].scaleInPlace(vt);for(const Se in ue){const Ge=ue[Se];O.set(0,0,0),Ge.forEach(Pe=>{xr(w,ee,Pe,_e),O.addInPlace(w)}),O.scaleInPlace(1/Ge.length),O.scaleInPlace(Ie),E[W].addInPlace(O)}}else if(ye&&ye.length===2){const se=ye.length,ce=.125,fe=1-ce*se;E[W].scaleInPlace(fe),ye.forEach(pe=>{xr(O,ee,pe,_e),O.scaleInPlace(ce),E[W].addInPlace(O)})}}SL(ie,Z,_e,E[0].asArray(),E[1].asArray(),E[2].asArray()),Z+=_e*3}return ie}const G=new he;r.forEach(X=>{if(X==="indices")return;const ee=t[X],oe=i[X];if(!ee||!oe)return;const _e=M(X,ee,oe);G[X]=_e});const H=G.positions,q=[];for(let X=0;X<H.length/3;X++)q.push(X);return G.indices=q,G}function bL(a,e,t){if(t={flatOnly:!1,uvSmooth:!1,preserveEdges:!1,weight:1,...t},!a.positions||a.positions.length===0||e<=0)return a;let i=a.clone();for(let r=0;r<e;r++)t.flatOnly?i=_C(i):i=vL(i,t);return i}var I;(function(a){a[a.Int=1]="Int",a[a.Float=2]="Float",a[a.Vector2=4]="Vector2",a[a.Vector3=8]="Vector3",a[a.Vector4=16]="Vector4",a[a.Matrix=32]="Matrix",a[a.Geometry=64]="Geometry",a[a.Texture=128]="Texture",a[a.AutoDetect=1024]="AutoDetect",a[a.BasedOnInput=2048]="BasedOnInput",a[a.Undefined=4096]="Undefined",a[a.All=4095]="All"})(I||(I={}));var ov;(function(a){a[a.Compatible=0]="Compatible",a[a.TypeIncompatible=1]="TypeIncompatible",a[a.HierarchyIssue=2]="HierarchyIssue"})(ov||(ov={}));var lv;(function(a){a[a.Input=0]="Input",a[a.Output=1]="Output"})(lv||(lv={}));class uv{get direction(){return this._direction}get type(){if(this._type===I.AutoDetect){if(this._ownerBlock.isInput)return this._ownerBlock.type;if(this._connectedPoint)return this._connectedPoint.type;if(this._linkedConnectionSource){if(this._linkedConnectionSource.isConnected)return this._linkedConnectionSource.type;if(this._linkedConnectionSource._defaultConnectionPointType)return this._linkedConnectionSource._defaultConnectionPointType}if(this._defaultConnectionPointType)return this._defaultConnectionPointType}if(this._type===I.BasedOnInput){if(this._typeConnectionSource)return!this._typeConnectionSource.isConnected&&this._defaultConnectionPointType?this._defaultConnectionPointType:this._typeConnectionSource.type;if(this._defaultConnectionPointType)return this._defaultConnectionPointType}return this._type}set type(e){this._type=e}get isConnected(){return this.connectedPoint!==null||this.hasEndpoints}get connectedPoint(){return this._connectedPoint}get ownerBlock(){return this._ownerBlock}get sourceBlock(){return this._connectedPoint?this._connectedPoint.ownerBlock:null}get connectedBlocks(){return this._endpoints.length===0?[]:this._endpoints.map(e=>e.ownerBlock)}get endpoints(){return this._endpoints}get hasEndpoints(){return this._endpoints&&this._endpoints.length>0}get innerType(){return this._linkedConnectionSource&&!this._isMainLinkSource&&this._linkedConnectionSource.isConnected?this.type:this._type}_resetCounters(){this._callCount=0,this._executionCount=0}get callCount(){return this._callCount}get executionCount(){return this._executionCount}getConnectedValue(e){var t;return this.isConnected?(t=this._connectedPoint)!=null&&t._storedFunction?(this._connectedPoint._callCount++,this._connectedPoint._executionCount++,this._connectedPoint._storedFunction(e)):(this._connectedPoint._callCount++,this._connectedPoint._executionCount=1,this._connectedPoint._storedValue):(this._callCount++,this._executionCount=1,this.value)}constructor(e,t,i){this._connectedPoint=null,this._storedValue=null,this._storedFunction=null,this._acceptedConnectionPointType=null,this._endpoints=new Array,this._type=I.Geometry,this._linkedConnectionSource=null,this._typeConnectionSource=null,this._defaultConnectionPointType=null,this._isMainLinkSource=!1,this.acceptedConnectionPointTypes=[],this.excludedConnectionPointTypes=[],this.onConnectionObservable=new j,this.onDisconnectionObservable=new j,this.isExposedOnFrame=!1,this.exposedPortPosition=-1,this.defaultValue=null,this.value=null,this.valueMin=null,this.valueMax=null,this._callCount=0,this._executionCount=0,this._ownerBlock=t,this.name=e,this._direction=i}getClassName(){return"NodeGeometryConnectionPoint"}canConnectTo(e){return this.checkCompatibilityState(e)===0}checkCompatibilityState(e){const t=this._ownerBlock,i=e.ownerBlock;if(this.type!==e.type&&e.innerType!==I.AutoDetect)return e.acceptedConnectionPointTypes&&e.acceptedConnectionPointTypes.indexOf(this.type)!==-1?0:1;if(e.excludedConnectionPointTypes&&e.excludedConnectionPointTypes.indexOf(this.type)!==-1)return 1;let r=i,s=t;return this.direction===0&&(r=t,s=i),r.isAnAncestorOf(s)?2:0}connectTo(e,t=!1){if(!t&&!this.canConnectTo(e))throw"Cannot connect these two connectors.";return this._endpoints.push(e),e._connectedPoint=this,this.onConnectionObservable.notifyObservers(e),e.onConnectionObservable.notifyObservers(this),this}disconnectFrom(e){const t=this._endpoints.indexOf(e);return t===-1?this:(this._endpoints.splice(t,1),e._connectedPoint=null,this.onDisconnectionObservable.notifyObservers(e),e.onDisconnectionObservable.notifyObservers(this),this)}addExcludedConnectionPointFromAllowedTypes(e){let t=1;for(;t<I.All;)e&t||this.excludedConnectionPointTypes.push(t),t=t<<1}serialize(e=!0){const t={};return t.name=this.name,t.displayName=this.displayName,this.value!==void 0&&this.value!==null&&(this.value.asArray?(t.valueType="BABYLON."+this.value.getClassName(),t.value=this.value.asArray()):(t.valueType="number",t.value=this.value)),e&&this.connectedPoint&&(t.inputName=this.name,t.targetBlockId=this.connectedPoint.ownerBlock.uniqueId,t.targetConnectionName=this.connectedPoint.name,t.isExposedOnFrame=!0,t.exposedPortPosition=this.exposedPortPosition),(this.isExposedOnFrame||this.exposedPortPosition>=0)&&(t.isExposedOnFrame=!0,t.exposedPortPosition=this.exposedPortPosition),t}dispose(){this.onConnectionObservable.clear(),this.onDisconnectionObservable.clear()}}class be{get buildExecutionTime(){return this._buildExecutionTime}get inputs(){return this._inputs}get outputs(){return this._outputs}get name(){return this._name}set name(e){this._name=e}get isInput(){return this._isInput}get isTeleportOut(){return this._isTeleportOut}get isTeleportIn(){return this._isTeleportIn}get isDebug(){return this._isDebug}get isUnique(){return this._isUnique}getClassName(){return"NodeGeometryBlock"}_inputRename(e){return e}_outputRename(e){return e}isAnAncestorOf(e){for(const t of this._outputs)if(t.hasEndpoints){for(const i of t.endpoints)if(i.ownerBlock===e||i.ownerBlock.isAnAncestorOf(e))return!0}return!1}isAnAncestorOfType(e){if(this.getClassName()===e)return!0;for(const t of this._outputs)if(t.hasEndpoints){for(const i of t.endpoints)if(i.ownerBlock.isAnAncestorOfType(e))return!0}return!1}getDescendantOfPredicate(e){if(e(this))return this;for(const t of this._outputs)if(t.hasEndpoints)for(const i of t.endpoints){const r=i.ownerBlock.getDescendantOfPredicate(e);if(r)return r}return null}get _isReadyState(){return null}constructor(e){this._name="",this._isInput=!1,this._isTeleportOut=!1,this._isTeleportIn=!1,this._isDebug=!1,this._isUnique=!1,this._buildExecutionTime=0,this.onBuildObservable=new j,this._inputs=new Array,this._outputs=new Array,this._codeVariableName="",this.visibleOnFrame=!1,this._name=e,this.uniqueId=pu.UniqueId}registerInput(e,t,i=!1,r,s,n){const o=new uv(e,this,0);return o.type=t,o.isOptional=i,o.defaultValue=r,o.value=r,o.valueMin=s,o.valueMax=n,this._inputs.push(o),this}registerOutput(e,t,i){return i=i??new uv(e,this,1),i.type=t,this._outputs.push(i),this}_buildBlock(e){}_customBuildStep(e){}build(e){if(this._buildId===e.buildId)return!0;if(this._outputs.length>0){if(!this._outputs.some(i=>i.hasEndpoints)&&!this.isDebug)return!1;this.outputs.forEach(i=>i._resetCounters())}this._buildId=e.buildId;for(const i of this._inputs){if(!i.connectedPoint){i.isOptional||e.notConnectedNonOptionalInputs.push(i);continue}const r=i.connectedPoint.ownerBlock;r&&r!==this&&r.build(e)}this._customBuildStep(e),e.verbose&&L.Log(`Building ${this.name} [${this.getClassName()}]`);const t=Li.Now;return this._buildBlock(e),this._buildExecutionTime=Li.Now-t,this.onBuildObservable.notifyObservers(this),!1}_linkConnectionTypes(e,t,i=!1){i?this._inputs[t]._acceptedConnectionPointType=this._inputs[e]:(this._inputs[e]._linkedConnectionSource=this._inputs[t],this._inputs[e]._isMainLinkSource=!0),this._inputs[t]._linkedConnectionSource=this._inputs[e]}initialize(){}autoConfigure(e){}getInputByName(e){const t=this._inputs.filter(i=>i.name===e);return t.length?t[0]:null}getOutputByName(e){const t=this._outputs.filter(i=>i.name===e);return t.length?t[0]:null}serialize(){const e={};e.customType="BABYLON."+this.getClassName(),e.id=this.uniqueId,e.name=this.name,e.visibleOnFrame=this.visibleOnFrame,e.inputs=[],e.outputs=[];for(const t of this.inputs)e.inputs.push(t.serialize());for(const t of this.outputs)e.outputs.push(t.serialize(!1));return e}_deserialize(e){this._name=e.name,this.comments=e.comments,this.visibleOnFrame=!!e.visibleOnFrame,this._deserializePortDisplayNamesAndExposedOnFrame(e)}_deserializePortDisplayNamesAndExposedOnFrame(e){const t=e.inputs,i=e.outputs;t&&t.forEach(r=>{const s=this.inputs.find(n=>n.name===r.name);if(s&&(r.displayName&&(s.displayName=r.displayName),r.isExposedOnFrame&&(s.isExposedOnFrame=r.isExposedOnFrame,s.exposedPortPosition=r.exposedPortPosition),r.value!==void 0&&r.value!==null))if(r.valueType==="number")s.value=r.value;else{const n=oi(r.valueType);n&&(s.value=n.FromArray(r.value))}}),i&&i.forEach((r,s)=>{r.displayName&&(this.outputs[s].displayName=r.displayName),r.isExposedOnFrame&&(this.outputs[s].isExposedOnFrame=r.isExposedOnFrame,this.outputs[s].exposedPortPosition=r.exposedPortPosition)})}_dumpPropertiesCode(){return`${this._codeVariableName}.visibleOnFrame = ${this.visibleOnFrame};
`}_dumpCodeForOutputConnections(e){let t="";if(e.indexOf(this)!==-1)return t;e.push(this);for(const i of this.inputs){if(!i.isConnected)continue;const r=i.connectedPoint,s=r.ownerBlock;t+=s._dumpCodeForOutputConnections(e),t+=`${s._codeVariableName}.${s._outputRename(r.name)}.connectTo(${this._codeVariableName}.${this._inputRename(i.name)});
`}return t}_dumpCode(e,t){t.push(this);const i=this.name.replace(/[^A-Za-z_]+/g,"");if(this._codeVariableName=i||`${this.getClassName()}_${this.uniqueId}`,e.indexOf(this._codeVariableName)!==-1){let n=0;do n++,this._codeVariableName=i+n;while(e.indexOf(this._codeVariableName)!==-1)}e.push(this._codeVariableName);let r=`
// ${this.getClassName()}
`;this.comments&&(r+=`// ${this.comments}
`);const s=this.getClassName();if(s==="GeometryInputBlock"){const o=this.type;r+=`var ${this._codeVariableName} = new BABYLON.GeometryInputBlock("${this.name}", ${o});
`}else r+=`var ${this._codeVariableName} = new BABYLON.${s}("${this.name}");
`;r+=this._dumpPropertiesCode();for(const n of this.inputs){if(!n.isConnected)continue;const l=n.connectedPoint.ownerBlock;t.indexOf(l)===-1&&(r+=l._dumpCode(e,t))}for(const n of this.outputs)if(n.hasEndpoints)for(const o of n.endpoints){const l=o.ownerBlock;l&&t.indexOf(l)===-1&&(r+=l._dumpCode(e,t))}return r}clone(){const e=this.serialize(),t=oi(e.customType);if(t){const i=new t;return i._deserialize(e),i}return null}dispose(){for(const e of this.inputs)e.dispose();for(const e of this.outputs)e.dispose();this.onBuildObservable.clear()}}C([F("comment")],be.prototype,"comments",void 0);class gC extends be{get currentVertexData(){return this._vertexData}constructor(e){super(e),this._vertexData=null,this._isUnique=!0,this.registerInput("geometry",I.Geometry)}getClassName(){return"GeometryOutputBlock"}get geometry(){return this._inputs[0]}_buildBlock(e){e.vertexData=this.geometry.getConnectedValue(e),this._vertexData=e.vertexData}}B("BABYLON.GeometryOutputBlock",gC);var $e;(function(a){a[a.None=0]="None",a[a.Positions=1]="Positions",a[a.Normals=2]="Normals",a[a.Tangents=3]="Tangents",a[a.UV=4]="UV",a[a.UV2=5]="UV2",a[a.UV3=6]="UV3",a[a.UV4=7]="UV4",a[a.UV5=8]="UV5",a[a.UV6=9]="UV6",a[a.Colors=10]="Colors",a[a.VertexID=11]="VertexID",a[a.FaceID=12]="FaceID",a[a.GeometryID=13]="GeometryID",a[a.CollectionID=14]="CollectionID",a[a.LoopID=15]="LoopID",a[a.InstanceID=16]="InstanceID",a[a.LatticeID=17]="LatticeID",a[a.LatticeControl=18]="LatticeControl"})($e||($e={}));class yL{constructor(){this._rotationMatrix=new $,this._scalingMatrix=new $,this._positionMatrix=new $,this._scalingRotationMatrix=new $,this._transformMatrix=new $,this._tempVector3=new m,this.notConnectedNonOptionalInputs=[],this.noContextualData=[],this.vertexData=null,this._geometryContext=null,this._executionContext=null,this._instancingContext=null,this._geometryContextStack=[],this._executionContextStack=[],this._instancingContextStack=[]}get geometryContext(){return this._geometryContext}get executionContext(){return this._executionContext}get instancingContext(){return this._instancingContext}pushGeometryContext(e){this._geometryContext=e,this._geometryContextStack.push(this._geometryContext)}pushExecutionContext(e){this._executionContext=e,this._executionContextStack.push(this._executionContext)}pushInstancingContext(e){this._instancingContext=e,this._instancingContextStack.push(this._instancingContext)}restoreGeometryContext(){this._geometryContextStack.pop(),this._geometryContext=this._geometryContextStack.length>0?this._geometryContextStack[this._geometryContextStack.length-1]:null}restoreExecutionContext(){this._executionContextStack.pop(),this._executionContext=this._executionContextStack.length>0?this._executionContextStack[this._executionContextStack.length-1]:null}restoreInstancingContext(){this._instancingContextStack.pop(),this._instancingContext=this._instancingContextStack.length>0?this._instancingContextStack[this._instancingContextStack.length-1]:null}getContextualValue(e,t=!1){if(!this.executionContext)return t||this.noContextualData.push(e),null;const i=this.executionContext.getExecutionIndex();switch(e){case $e.Positions:return this.executionContext.getOverridePositionsContextualValue?this.executionContext.getOverridePositionsContextualValue():!this.geometryContext||!this.geometryContext.positions?m.Zero():m.FromArray(this.geometryContext.positions,i*3);case $e.Normals:return this.executionContext.getOverrideNormalsContextualValue?this.executionContext.getOverrideNormalsContextualValue():!this.geometryContext||!this.geometryContext.normals?m.Zero():m.FromArray(this.geometryContext.normals,i*3);case $e.Colors:return!this.geometryContext||!this.geometryContext.colors?Ve.Zero():Ve.FromArray(this.geometryContext.colors,i*4);case $e.Tangents:return!this.geometryContext||!this.geometryContext.tangents?Ve.Zero():Ve.FromArray(this.geometryContext.tangents,i*4);case $e.UV:return this.executionContext.getOverrideUVs1ContextualValue?this.executionContext.getOverrideUVs1ContextualValue():!this.geometryContext||!this.geometryContext.uvs?Q.Zero():Q.FromArray(this.geometryContext.uvs,i*2);case $e.UV2:return!this.geometryContext||!this.geometryContext.uvs2?Q.Zero():Q.FromArray(this.geometryContext.uvs2,i*2);case $e.UV3:return!this.geometryContext||!this.geometryContext.uvs3?Q.Zero():Q.FromArray(this.geometryContext.uvs3,i*2);case $e.UV4:return!this.geometryContext||!this.geometryContext.uvs4?Q.Zero():Q.FromArray(this.geometryContext.uvs4,i*2);case $e.UV5:return!this.geometryContext||!this.geometryContext.uvs5?Q.Zero():Q.FromArray(this.geometryContext.uvs5,i*2);case $e.UV6:return!this.geometryContext||!this.geometryContext.uvs6?Q.Zero():Q.FromArray(this.geometryContext.uvs6,i*2);case $e.VertexID:return i;case $e.FaceID:return this.executionContext.getExecutionFaceIndex();case $e.LoopID:return this.executionContext.getExecutionLoopIndex();case $e.InstanceID:return this.instancingContext?this.instancingContext.getInstanceIndex():0;case $e.GeometryID:return this.geometryContext?this.geometryContext.uniqueId:0;case $e.CollectionID:return!this.geometryContext||!this.geometryContext.metadata?0:this.geometryContext.metadata.collectionId||0;case $e.LatticeID:return this.executionContext.getOverridePositionsContextualValue?this.executionContext.getOverridePositionsContextualValue():m.Zero();case $e.LatticeControl:return this.executionContext.getOverrideNormalsContextualValue?this.executionContext.getOverrideNormalsContextualValue():m.Zero()}return null}adapt(e,t){const i=e.getConnectedValue(this)||0;if(e.type===t)return i;switch(t){case I.Vector2:return new Q(i,i);case I.Vector3:return new m(i,i,i);case I.Vector4:return new Ve(i,i,i,i)}return null}adaptInput(e,t,i){var s;if(!e.isConnected)return e.value||i;const r=e.getConnectedValue(this);if(((s=e._connectedPoint)==null?void 0:s.type)===t)return r;switch(t){case I.Vector2:return new Q(r,r);case I.Vector3:return new m(r,r,r);case I.Vector4:return new Ve(r,r,r,r)}return null}emitErrors(){let e="";for(const t of this.notConnectedNonOptionalInputs)e+=`input ${t.name} from block ${t.ownerBlock.name}[${t.ownerBlock.getClassName()}] is not connected and is not optional.
`;for(const t of this.noContextualData)e+=`Contextual input ${$e[t]} has no context to pull data from (must be connected to a setXXX block or a instantiateXXX block).
`;if(e)throw`Build of NodeGeometry failed:
`+e}_instantiate(e,t,i,r,s){$.ScalingToRef(r.x,r.y,r.z,this._scalingMatrix),$.RotationYawPitchRollToRef(i.y,i.x,i.z,this._rotationMatrix),$.TranslationToRef(t.x,t.y,t.z,this._positionMatrix),this._scalingMatrix.multiplyToRef(this._rotationMatrix,this._scalingRotationMatrix),this._scalingRotationMatrix.multiplyToRef(this._positionMatrix,this._transformMatrix);for(let n=0;n<e.positions.length;n+=3)this._tempVector3.fromArray(e.positions,n),m.TransformCoordinatesToRef(this._tempVector3,this._transformMatrix,this._tempVector3),this._tempVector3.toArray(e.positions,n),e.normals&&(this._tempVector3.fromArray(e.normals,n),m.TransformNormalToRef(this._tempVector3,this._scalingRotationMatrix,this._tempVector3),this._tempVector3.toArray(e.normals,n));s.push(e)}_instantiateWithMatrix(e,t,i){for(let r=0;r<e.positions.length;r+=3)this._tempVector3.fromArray(e.positions,r),m.TransformCoordinatesToRef(this._tempVector3,t,this._tempVector3),this._tempVector3.toArray(e.positions,r),e.normals&&(this._tempVector3.fromArray(e.normals,r),m.TransformNormalToRef(this._tempVector3,t,this._tempVector3),this._tempVector3.toArray(e.normals,r));i.push(e)}_instantiateWithPositionAndMatrix(e,t,i,r){$.TranslationToRef(t.x,t.y,t.z,this._positionMatrix),i.multiplyToRef(this._positionMatrix,this._transformMatrix);for(let s=0;s<e.positions.length;s+=3)this._tempVector3.fromArray(e.positions,s),m.TransformCoordinatesToRef(this._tempVector3,this._transformMatrix,this._tempVector3),this._tempVector3.toArray(e.positions,s),e.normals&&(this._tempVector3.fromArray(e.normals,s),m.TransformNormalToRef(this._tempVector3,this._transformMatrix,this._tempVector3),this._tempVector3.toArray(e.normals,s));r.push(e)}}class Ft extends be{get type(){if(this._type===I.AutoDetect&&this.value!=null){if(!isNaN(this.value))return this._type=I.Float,this._type;switch(this.value.getClassName()){case"Vector2":return this._type=I.Vector2,this._type;case"Vector3":return this._type=I.Vector3,this._type;case"Vector4":return this._type=I.Vector4,this._type;case"Matrix":return this._type=I.Matrix,this._type}}return this._type}get isContextual(){return this._contextualSource!==$e.None}get contextualValue(){return this._contextualSource}set contextualValue(e){switch(this._contextualSource=e,e){case $e.Positions:case $e.Normals:case $e.LatticeID:case $e.LatticeControl:this._type=I.Vector3;break;case $e.Colors:case $e.Tangents:this._type=I.Vector4;break;case $e.UV:case $e.UV2:case $e.UV3:case $e.UV4:case $e.UV5:case $e.UV6:this._type=I.Vector2;break;case $e.VertexID:case $e.GeometryID:case $e.CollectionID:case $e.FaceID:case $e.LoopID:case $e.InstanceID:this._type=I.Int;break}this.output&&(this.output.type=this._type)}constructor(e,t=I.AutoDetect){super(e),this._type=I.Undefined,this._contextualSource=$e.None,this.min=0,this.max=0,this.groupInInspector="",this.displayInInspector=!0,this.onValueChangedObservable=new j,this._type=t,this._isInput=!0,this.setDefaultValue(),this.registerOutput("output",t)}get value(){return this._storedValue}set value(e){this.type===I.Float&&this.min!==this.max&&(e=Math.max(this.min,e),e=Math.min(this.max,e)),this._storedValue=e,this.onValueChangedObservable.notifyObservers(this)}get valueCallback(){return this._valueCallback}set valueCallback(e){this._valueCallback=e}getClassName(){return"GeometryInputBlock"}get output(){return this._outputs[0]}setDefaultValue(){switch(this.contextualValue=$e.None,this.type){case I.Int:case I.Float:this.value=0;break;case I.Vector2:this.value=Q.Zero();break;case I.Vector3:this.value=m.Zero();break;case I.Vector4:this.value=Ve.Zero();break;case I.Matrix:this.value=$.Identity();break}}_buildBlock(e){super._buildBlock(e),this.isContextual?(this.output._storedValue=null,this.output._storedFunction=t=>t.getContextualValue(this._contextualSource)):(this.output._storedFunction=null,this.output._storedValue=this.value)}dispose(){this.onValueChangedObservable.clear(),super.dispose()}_dumpPropertiesCode(){const e=this._codeVariableName;if(this.isContextual)return super._dumpPropertiesCode()+`${e}.contextualValue = BABYLON.NodeGeometryContextualSources.${$e[this._contextualSource]};
`;const t=[];let i="";switch(this.type){case I.Float:case I.Int:i=`${this.value}`;break;case I.Vector2:i=`new BABYLON.Vector2(${this.value.x}, ${this.value.y})`;break;case I.Vector3:i=`new BABYLON.Vector3(${this.value.x}, ${this.value.y}, ${this.value.z})`;break;case I.Vector4:i=`new BABYLON.Vector4(${this.value.x}, ${this.value.y}, ${this.value.z}, ${this.value.w})`;break}return t.push(`${e}.value = ${i}`),(this.type===I.Float||this.type===I.Int)&&t.push(`${e}.min = ${this.min}`,`${e}.max = ${this.max}`),t.push(""),super._dumpPropertiesCode()+t.join(`;
`)}serialize(){const e=super.serialize();return e.type=this.type,e.contextualValue=this.contextualValue,e.min=this.min,e.max=this.max,e.groupInInspector=this.groupInInspector,e.displayInInspector=this.displayInInspector,this._storedValue!==null&&!this.isContextual&&(this._storedValue.asArray?(e.valueType="BABYLON."+this._storedValue.getClassName(),e.value=this._storedValue.asArray()):(e.valueType="number",e.value=this._storedValue)),e}_deserialize(e){if(super._deserialize(e),this._type=e.type,this.contextualValue=e.contextualValue,this.min=e.min||0,this.max=e.max||0,this.groupInInspector=e.groupInInspector||"",e.displayInInspector!==void 0&&(this.displayInInspector=e.displayInInspector),!!e.valueType)if(e.valueType==="number")this._storedValue=e.value;else{const t=oi(e.valueType);t&&(this._storedValue=t.FromArray(e.value))}}}B("BABYLON.GeometryInputBlock",Ft);class W_ extends be{constructor(e){super(e),this.evaluateContext=!1,this.registerInput("size",I.Float,!0,1),this.registerInput("width",I.Float,!0,0),this.registerInput("height",I.Float,!0,0),this.registerInput("depth",I.Float,!0,0),this.registerInput("subdivisions",I.Int,!0,1,0),this.registerInput("subdivisionsX",I.Int,!0,0,0),this.registerInput("subdivisionsY",I.Int,!0,0,0),this.registerInput("subdivisionsZ",I.Int,!0,0,0),this.registerOutput("geometry",I.Geometry)}getClassName(){return"BoxBlock"}get size(){return this._inputs[0]}get width(){return this._inputs[1]}get height(){return this._inputs[2]}get depth(){return this._inputs[3]}get subdivisions(){return this._inputs[4]}get subdivisionsX(){return this._inputs[5]}get subdivisionsY(){return this._inputs[6]}get subdivisionsZ(){return this._inputs[7]}get geometry(){return this._outputs[0]}autoConfigure(){if(!this.size.isConnected){if(!this.width.isConnected&&!this.height.isConnected&&!this.depth.isConnected){const e=new Ft("Size");e.value=1,e.output.connectTo(this.size);return}if(!this.width.isConnected){const e=new Ft("Width");e.value=1,e.output.connectTo(this.width)}if(!this.height.isConnected){const e=new Ft("Height");e.value=1,e.output.connectTo(this.height)}if(!this.depth.isConnected){const e=new Ft("Depth");e.value=1,e.output.connectTo(this.depth)}}}_buildBlock(e){const t={},i=r=>{t.size=this.size.getConnectedValue(r),t.width=this.width.getConnectedValue(r),t.height=this.height.getConnectedValue(r),t.depth=this.depth.getConnectedValue(r);const s=this.subdivisions.getConnectedValue(r),n=this.subdivisionsX.getConnectedValue(r),o=this.subdivisionsY.getConnectedValue(r),l=this.subdivisionsZ.getConnectedValue(r);return s&&(t.segments=s),n&&(t.widthSegments=n),o&&(t.heightSegments=o),l&&(t.depthSegments=l),LD(t)};if(this.evaluateContext)this.geometry._storedFunction=i;else{const r=i(e);this.geometry._storedFunction=()=>(this.geometry._executionCount=1,r.clone())}}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),this.evaluateContext=e.evaluateContext}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],W_.prototype,"evaluateContext",void 0);B("BABYLON.BoxBlock",W_);class Yi{_getGlobalNodeGeometryEditor(){if(typeof NODEGEOMETRYEDITOR<"u")return NODEGEOMETRYEDITOR;if(typeof BABYLON<"u"&&typeof BABYLON.NodeGeometryEditor<"u")return BABYLON}get buildExecutionTime(){return this._buildExecutionTime}constructor(e){this._buildId=Yi._BuildIdGenerator++,this._buildWasSuccessful=!1,this._vertexData=null,this._buildExecutionTime=0,this.BJSNODEGEOMETRYEDITOR=this._getGlobalNodeGeometryEditor(),this.editorData=null,this.attachedBlocks=[],this.onBuildObservable=new j,this.outputBlock=null,this.name=e}getClassName(){return"NodeGeometry"}get vertexData(){return this._vertexData}getBlockByName(e){let t=null;for(const i of this.attachedBlocks)if(i.name===e)if(!t)t=i;else return ae.Warn("More than one block was found with the name `"+e+"`"),t;return t}getBlockByPredicate(e){for(const t of this.attachedBlocks)if(e(t))return t;return null}getInputBlocks(){const e=[];for(const t of this.attachedBlocks)t.isInput&&e.push(t);return e}edit(e){return new Promise(t=>{if(this.BJSNODEGEOMETRYEDITOR=this.BJSNODEGEOMETRYEDITOR||this._getGlobalNodeGeometryEditor(),typeof this.BJSNODEGEOMETRYEDITOR>"u"){const i=e&&e.editorURL?e.editorURL:Yi.EditorURL;ae.LoadBabylonScript(i,()=>{this.BJSNODEGEOMETRYEDITOR=this.BJSNODEGEOMETRYEDITOR||this._getGlobalNodeGeometryEditor(),this._createNodeEditor(e==null?void 0:e.nodeGeometryEditorConfig),t()})}else this._createNodeEditor(e==null?void 0:e.nodeGeometryEditorConfig),t()})}_createNodeEditor(e){const t={nodeGeometry:this,...e};this.BJSNODEGEOMETRYEDITOR.NodeGeometryEditor.Show(t)}build(e=!1,t=!0,i=!1){if(this._buildWasSuccessful=!1,!this.outputBlock)throw"You must define the outputBlock property before building the geometry";const r=Li.Now;this._initializeBlock(this.outputBlock,i);const s=[];for(const o of this.attachedBlocks)o._isReadyState&&s.push(o._isReadyState);if(s.length){Promise.all(s).then(()=>{this.build(e,t,i)});return}const n=new yL;n.buildId=this._buildId,n.verbose=e;try{this.outputBlock.build(n)}finally{t&&(this._buildId=Yi._BuildIdGenerator++)}this._buildExecutionTime=Li.Now-r,n.emitErrors(),this._buildWasSuccessful=!0,this._vertexData=n.vertexData,this.onBuildObservable.notifyObservers(this)}createMesh(e,t=null){if(this._buildWasSuccessful||this.build(),!this._vertexData)return null;const i=new z(e,t);return this._vertexData.applyToMesh(i),i._internalMetadata=i._internalMetadata||{},i._internalMetadata.nodeGeometry=this,i}updateMesh(e){return this._buildWasSuccessful||this.build(),this._vertexData?(this._vertexData.applyToMesh(e),e._internalMetadata=e._internalMetadata||{},e._internalMetadata.nodeGeometry=this,e):!1}_initializeBlock(e,t=!0){e.initialize(),t&&e.autoConfigure(this),e._preparationId=this._buildId,this.attachedBlocks.indexOf(e)===-1&&this.attachedBlocks.push(e);for(const i of e.inputs){const r=i.connectedPoint;if(r){const s=r.ownerBlock;s!==e&&this._initializeBlock(s,t)}}}clear(){this.outputBlock=null,this.attachedBlocks.length=0}removeBlock(e){const t=this.attachedBlocks.indexOf(e);t>-1&&this.attachedBlocks.splice(t,1),e===this.outputBlock&&(this.outputBlock=null)}parseSerializedObject(e,t=!1){t||this.clear();const i={};for(const r of e.blocks){const s=oi(r.customType);if(s){const n=new s;n._deserialize(r),i[r.id]=n,this.attachedBlocks.push(n)}}for(const r of this.attachedBlocks)if(r.isTeleportOut){const s=r,n=s._tempEntryPointUniqueId;if(n){const o=i[n];o&&o.attachToEndpoint(s)}}for(let r=0;r<e.blocks.length;r++){const s=e.blocks[r],n=i[s.id];n&&(n.inputs.length&&s.inputs.some(o=>o.targetConnectionName)&&!t||this._restoreConnections(n,e,i))}if(e.outputNodeId&&(this.outputBlock=i[e.outputNodeId]),e.locations||e.editorData&&e.editorData.locations){const r=e.locations||e.editorData.locations;for(const n of r)i[n.blockId]&&(n.blockId=i[n.blockId].uniqueId);t&&this.editorData&&this.editorData.locations&&r.concat(this.editorData.locations),e.locations?this.editorData={locations:r}:(this.editorData=e.editorData,this.editorData.locations=r);const s=[];for(const n in i)s[n]=i[n].uniqueId;this.editorData.map=s}this.comment=e.comment}_restoreConnections(e,t,i){for(const r of e.outputs)for(const s of t.blocks){const n=i[s.id];if(n){for(const o of s.inputs)if(i[o.targetBlockId]===e&&o.targetConnectionName===r.name){const l=n.getInputByName(o.inputName);if(!l||l.isConnected)continue;r.connectTo(l,!0),this._restoreConnections(n,t,i);continue}}}}generateCode(){let e=[];const t=[],i=["const","var","let"];this.outputBlock&&this._gatherBlocks(this.outputBlock,t);let r=`let nodeGeometry = new BABYLON.NodeGeometry("${this.name||"node geometry"}");
`;for(const s of t)s.isInput&&e.indexOf(s)===-1&&(r+=s._dumpCode(i,e));return this.outputBlock&&(e=[],r+=`// Connections
`,r+=this.outputBlock._dumpCodeForOutputConnections(e),r+=`// Output nodes
`,r+=`nodeGeometry.outputBlock = ${this.outputBlock._codeVariableName};
`,r+=`nodeGeometry.build();
`),r}_gatherBlocks(e,t){if(t.indexOf(e)===-1){t.push(e);for(const i of e.inputs){const r=i.connectedPoint;if(r){const s=r.ownerBlock;s!==e&&this._gatherBlocks(s,t)}}if(e.isTeleportOut){const i=e;i.entryPoint&&this._gatherBlocks(i.entryPoint,t)}}}setToDefault(){this.clear(),this.editorData=null;const e=new W_("Box");e.autoConfigure();const t=new gC("Geometry Output");e.geometry.connectTo(t.geometry),this.outputBlock=t}clone(e){const t=this.serialize(),i=Me.Clone(()=>new Yi(e),this);return i.name=e,i.parseSerializedObject(t),i._buildId=this._buildId,i.build(!1),i}serialize(e){const t=e?{}:Me.Serialize(this);t.editorData=JSON.parse(JSON.stringify(this.editorData));let i=[];e?i=e:(t.customType="BABYLON.NodeGeometry",this.outputBlock&&(t.outputNodeId=this.outputBlock.uniqueId)),t.blocks=[];for(const r of i)t.blocks.push(r.serialize());if(!e)for(const r of this.attachedBlocks)i.indexOf(r)===-1&&t.blocks.push(r.serialize());return t}dispose(){for(const e of this.attachedBlocks)e.dispose();this.attachedBlocks.length=0,this.onBuildObservable.clear()}static CreateDefault(e){const t=new Yi(e);return t.setToDefault(),t.build(),t}static Parse(e){const t=Me.Parse(()=>new Yi(e.name),e,null);return t.parseSerializedObject(e),t.build(),t}static ParseFromSnippetAsync(e,t,i=!1){return e==="_BLANK"?Promise.resolve(Yi.CreateDefault("blank")):new Promise((r,s)=>{const n=new ss;n.addEventListener("readystatechange",()=>{if(n.readyState==4)if(n.status==200){const o=JSON.parse(JSON.parse(n.responseText).jsonPayload),l=JSON.parse(o.nodeGeometry);t||(t=Me.Parse(()=>new Yi(e),l,null)),t.parseSerializedObject(l),t.snippetId=e;try{i||t.build(),r(t)}catch(u){s(u)}}else s("Unable to load the snippet "+e)}),n.open("GET",this.SnippetUrl+"/"+e.replace(/#/g,"/")),n.send()})}}Yi._BuildIdGenerator=0;Yi.EditorURL=`${ae._DefaultCdnUrl}/v${st.Version}/nodeGeometryEditor/babylon.nodeGeometryEditor.js`;Yi.SnippetUrl="https://snippet.babylonjs.com";C([F()],Yi.prototype,"name",void 0);C([F("comment")],Yi.prototype,"comment",void 0);class ic extends be{getExecutionIndex(){return this._currentIndex}getExecutionLoopIndex(){return this._currentIndex}getExecutionFaceIndex(){return 0}constructor(e){super(e),this.evaluateContext=!0,this.epsilon=He,this.optimizeFaces=!1,this.registerInput("geometry",I.Geometry),this.registerInput("selector",I.Int,!0),this.registerOutput("output",I.Geometry)}getClassName(){return"GeometryOptimizeBlock"}get geometry(){return this._inputs[0]}get selector(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){const t=i=>{if(!this.geometry.isConnected)return null;const r=this.geometry.getConnectedValue(i),s=[],n={};i.pushExecutionContext(this),i.pushGeometryContext(r);for(let c=0;c<r.positions.length;c+=3){if(this._currentIndex=c/3,this.selector.isConnected&&!this.selector.getConnectedValue(i))continue;const h=r.positions[c],d=r.positions[c+1],f=r.positions[c+2];let p=!1;for(let g=0;g<s.length;g+=3)if(Fn(h,s[g],this.epsilon)&&Fn(d,s[g+1],this.epsilon)&&Fn(f,s[g+2],this.epsilon)){n[c/3]=g/3,p=!0;continue}p||(n[c/3]=s.length/3,s.push(h,d,f))}const o=new he;o.positions=s;const l=r.indices.map(c=>n[c]),u=[];if(this.optimizeFaces){for(let c=0;c<l.length;c+=3){const h=l[c],d=l[c+1],f=l[c+2];if(h===d||d==f||f===h)continue;let p=!1;for(let g=0;g<u.length;g+=3){if(h===u[g]&&d===u[g+1]&&f===u[g+2]){p=!0;continue}if(h===u[g+1]&&d===u[g+2]&&f===u[g]){p=!0;continue}if(h===u[g+2]&&d===u[g]&&f===u[g+1]){p=!0;continue}}p||u.push(h,d,f)}o.indices=u}else o.indices=l;return o};e.restoreGeometryContext(),e.restoreExecutionContext(),this.evaluateContext?this.output._storedFunction=t:(this.output._storedFunction=null,this.output._storedValue=t(e))}_dumpPropertiesCode(){let e=super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`;return e+=`${this._codeVariableName}.epsilon = ${this.epsilon};
`,e+=`${this._codeVariableName}.optimizeFaces = ${this.optimizeFaces?"true":"false"};
`,e}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e.epsilon=this.epsilon,e.optimizeFaces=this.optimizeFaces,e}_deserialize(e){super._deserialize(e),this.evaluateContext=e.evaluateContext,this.epsilon=e.epsilon,this.optimizeFaces=e.optimizeFaces}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],ic.prototype,"evaluateContext",void 0);C([U("Epsilon",1,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],ic.prototype,"epsilon",void 0);C([U("Optimize faces",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],ic.prototype,"optimizeFaces",void 0);B("BABYLON.GeometryOptimizeBlock",ic);class xC extends be{constructor(e){super(e),this._rotationMatrix=new $,this.evaluateContext=!1,this.registerInput("size",I.Float,!0,1),this.registerInput("width",I.Float,!0,0),this.registerInput("height",I.Float,!0,0),this.registerInput("subdivisions",I.Int,!0,1,0),this.registerInput("subdivisionsX",I.Int,!0,0,0),this.registerInput("subdivisionsY",I.Int,!0,0,0),this.registerOutput("geometry",I.Geometry)}getClassName(){return"PlaneBlock"}get size(){return this._inputs[0]}get width(){return this._inputs[1]}get height(){return this._inputs[2]}get subdivisions(){return this._inputs[3]}get subdivisionsX(){return this._inputs[4]}get subdivisionsY(){return this._inputs[5]}get geometry(){return this._outputs[0]}autoConfigure(){if(!this.size.isConnected){if(!this.width.isConnected&&!this.height.isConnected){const e=new Ft("Size");e.value=1,e.output.connectTo(this.size);return}if(!this.width.isConnected){const e=new Ft("Width");e.value=1,e.output.connectTo(this.width)}if(!this.height.isConnected){const e=new Ft("Height");e.value=1,e.output.connectTo(this.height)}}}_buildBlock(e){const t={},i=r=>{t.size=this.size.getConnectedValue(r),t.width=this.width.getConnectedValue(r),t.height=this.height.getConnectedValue(r);const s=this.subdivisions.getConnectedValue(r),n=this.subdivisionsX.getConnectedValue(r),o=this.subdivisionsY.getConnectedValue(r);s&&(t.subdivisions=s),n&&(t.subdivisionsX=n),o&&(t.subdivisionsY=o);const l=Zr(t);return $.RotationYawPitchRollToRef(-Math.PI/2,0,Math.PI/2,this._rotationMatrix),l.transform(this._rotationMatrix),l};if(this.evaluateContext)this.geometry._storedFunction=i;else{const r=i(e);this.geometry._storedFunction=()=>(this.geometry._executionCount=1,r.clone())}}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),this.evaluateContext=e.evaluateContext}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],xC.prototype,"evaluateContext",void 0);B("BABYLON.PlaneBlock",xC);class SC extends be{get mesh(){return this._mesh}set mesh(e){this._mesh=e}constructor(e){super(e),this._cachedVertexData=null,this.reverseWindingOrder=!1,this.serializedCachedData=!1,this.registerOutput("geometry",I.Geometry)}getClassName(){return"MeshBlock"}get isUsingCachedData(){return!this.mesh&&!!this._cachedVertexData}get geometry(){return this._outputs[0]}cleanData(){this._mesh=null,this._cachedVertexData=null}_buildBlock(){if(!this._mesh){this._cachedVertexData?this.geometry._storedValue=this._cachedVertexData.clone():this.geometry._storedValue=null;return}const e=he.ExtractFromMesh(this._mesh,!1,!0);if(this._cachedVertexData=null,this.reverseWindingOrder&&e.indices)for(let t=0;t<e.indices.length;t+=3){const i=e.indices[t];e.indices[t]=e.indices[t+2],e.indices[t+2]=i}this.geometry._storedFunction=()=>e.clone()}serialize(){const e=super.serialize();return e.serializedCachedData=this.serializedCachedData,this.serializedCachedData&&(this._mesh?e.cachedVertexData=he.ExtractFromMesh(this._mesh,!1,!0).serialize():this._cachedVertexData&&(e.cachedVertexData=this._cachedVertexData.serialize())),e.reverseWindingOrder=this.reverseWindingOrder,e}_deserialize(e){super._deserialize(e),e.cachedVertexData&&(this._cachedVertexData=he.Parse(e.cachedVertexData)),this.serializedCachedData=!!e.serializedCachedData,this.reverseWindingOrder=e.reverseWindingOrder}}C([U("Serialize cached data",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],SC.prototype,"serializedCachedData",void 0);B("BABYLON.MeshBlock",SC);class vC extends be{constructor(e){super(e),this.evaluateContext=!1,this.registerInput("radius",I.Float,!0,1),this.registerInput("radiusX",I.Float,!0,0),this.registerInput("radiusY",I.Float,!0,0),this.registerInput("radiusZ",I.Float,!0,0),this.registerInput("subdivisions",I.Int,!0,4),this.registerOutput("geometry",I.Geometry)}getClassName(){return"IcoSphereBlock"}get radius(){return this._inputs[0]}get radiusX(){return this._inputs[1]}get radiusY(){return this._inputs[2]}get radiusZ(){return this._inputs[3]}get subdivisions(){return this._inputs[4]}get geometry(){return this._outputs[0]}autoConfigure(){if(!this.radius.isConnected){const e=new Ft("Radius");e.value=.2,e.output.connectTo(this.radius)}}_buildBlock(e){const t={},i=r=>(t.radius=this.radius.getConnectedValue(r),t.subdivisions=this.subdivisions.getConnectedValue(r),t.radiusX=this.radiusX.getConnectedValue(r),t.radiusY=this.radiusY.getConnectedValue(r),t.radiusZ=this.radiusZ.getConnectedValue(r),S_(t));if(this.evaluateContext)this.geometry._storedFunction=i;else{const r=i(e);this.geometry._storedFunction=()=>(this.geometry._executionCount=1,r.clone())}}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),this.evaluateContext=e.evaluateContext}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],vC.prototype,"evaluateContext",void 0);B("BABYLON.IcoSphereBlock",vC);class bC extends be{constructor(e){super(e),this.evaluateContext=!1,this.registerInput("segments",I.Int,!0,32),this.registerInput("diameter",I.Float,!0,1),this.registerInput("diameterX",I.Float,!0,0),this.registerInput("diameterY",I.Float,!0,0),this.registerInput("diameterZ",I.Float,!0,0),this.registerInput("arc",I.Float,!0,1),this.registerInput("slice",I.Float,!0,1),this.registerOutput("geometry",I.Geometry)}getClassName(){return"SphereBlock"}get segments(){return this._inputs[0]}get diameter(){return this._inputs[1]}get diameterX(){return this._inputs[2]}get diameterY(){return this._inputs[3]}get diameterZ(){return this._inputs[4]}get arc(){return this._inputs[5]}get slice(){return this._inputs[6]}get geometry(){return this._outputs[0]}autoConfigure(){if(!this.diameter.isConnected){const e=new Ft("Diameter");e.value=1,e.output.connectTo(this.diameter)}}_buildBlock(e){const t={},i=r=>(t.segments=this.segments.getConnectedValue(r),t.diameter=this.diameter.getConnectedValue(r),t.diameterX=this.diameterX.getConnectedValue(r),t.diameterY=this.diameterY.getConnectedValue(r),t.diameterZ=this.diameterZ.getConnectedValue(r),t.arc=this.arc.getConnectedValue(r),t.slice=this.slice.getConnectedValue(r),h_(t));if(this.evaluateContext)this.geometry._storedFunction=i;else{const r=i(e);this.geometry._storedFunction=()=>(this.geometry._executionCount=1,r.clone())}}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),this.evaluateContext=e.evaluateContext}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],bC.prototype,"evaluateContext",void 0);B("BABYLON.SphereBlock",bC);class yC extends be{constructor(e){super(e),this.evaluateContext=!1,this.registerInput("width",I.Float,!0,1),this.registerInput("height",I.Float,!0,1),this.registerInput("subdivisions",I.Int,!0,1,0),this.registerInput("subdivisionsX",I.Int,!0,0,0),this.registerInput("subdivisionsY",I.Int,!0,0,0),this.registerOutput("geometry",I.Geometry)}getClassName(){return"GridBlock"}get width(){return this._inputs[0]}get height(){return this._inputs[1]}get subdivisions(){return this._inputs[2]}get subdivisionsX(){return this._inputs[3]}get subdivisionsY(){return this._inputs[4]}get geometry(){return this._outputs[0]}autoConfigure(){if(!this.width.isConnected){const e=new Ft("Width");e.value=1,e.output.connectTo(this.width)}if(!this.height.isConnected){const e=new Ft("Height");e.value=1,e.output.connectTo(this.height)}}_buildBlock(e){const t={},i=r=>(t.width=this.width.getConnectedValue(r),t.height=this.height.getConnectedValue(r),t.subdivisions=this.subdivisions.getConnectedValue(r),t.subdivisionsX=this.subdivisionsX.getConnectedValue(r),t.subdivisionsY=this.subdivisionsY.getConnectedValue(r),Zr(t));if(this.evaluateContext)this.geometry._storedFunction=i;else{const r=i(e);this.geometry._storedFunction=()=>(this.geometry._executionCount=1,r.clone())}}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),this.evaluateContext=e.evaluateContext}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],yC.prototype,"evaluateContext",void 0);B("BABYLON.GridBlock",yC);class TC extends be{constructor(e){super(e),this.evaluateContext=!1,this.registerInput("diameter",I.Float,!0,1),this.registerInput("thickness",I.Float,!0,.5),this.registerInput("tessellation",I.Int,!0,16),this.registerOutput("geometry",I.Geometry)}getClassName(){return"TorusBlock"}get diameter(){return this._inputs[0]}get thickness(){return this._inputs[1]}get tessellation(){return this._inputs[2]}get geometry(){return this._outputs[0]}autoConfigure(){if(!this.diameter.isConnected){const e=new Ft("Diameter");e.value=1,e.output.connectTo(this.diameter)}}_buildBlock(e){const t={},i=r=>(t.thickness=this.thickness.getConnectedValue(r),t.diameter=this.diameter.getConnectedValue(r),t.tessellation=this.tessellation.getConnectedValue(r),o_(t));if(this.evaluateContext)this.geometry._storedFunction=i;else{const r=i(e);this.geometry._storedFunction=()=>(this.geometry._executionCount=1,r.clone())}}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),this.evaluateContext=e.evaluateContext}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],TC.prototype,"evaluateContext",void 0);B("BABYLON.TorusBlock",TC);class CC extends be{constructor(e){super(e),this.evaluateContext=!1,this.registerInput("height",I.Float,!0,25),this.registerInput("diameter",I.Float,!0,1),this.registerInput("diameterTop",I.Float,!0,-1),this.registerInput("diameterBottom",I.Float,!0,-1),this.registerInput("subdivisions",I.Int,!0,1),this.registerInput("tessellation",I.Int,!0,24),this.registerInput("arc",I.Float,!0,1),this.registerOutput("geometry",I.Geometry)}getClassName(){return"CylinderBlock"}get height(){return this._inputs[0]}get diameter(){return this._inputs[1]}get diameterTop(){return this._inputs[2]}get diameterBottom(){return this._inputs[3]}get subdivisions(){return this._inputs[4]}get tessellation(){return this._inputs[5]}get arc(){return this._inputs[6]}get geometry(){return this._outputs[0]}autoConfigure(){if(!this.diameter.isConnected){const e=new Ft("Diameter");e.value=1,e.output.connectTo(this.diameter)}if(!this.height.isConnected){const e=new Ft("Height");e.value=1,e.output.connectTo(this.height)}}_buildBlock(e){const t={},i=r=>(t.height=this.height.getConnectedValue(r),t.diameter=this.diameter.getConnectedValue(r),t.diameterTop=this.diameterTop.getConnectedValue(r),t.diameterBottom=this.diameterBottom.getConnectedValue(r),t.diameterTop===-1&&(t.diameterTop=t.diameter),t.diameterBottom===-1&&(t.diameterBottom=t.diameter),t.tessellation=this.tessellation.getConnectedValue(r),t.subdivisions=this.subdivisions.getConnectedValue(r),t.arc=this.arc.getConnectedValue(r),u_(t));if(this.evaluateContext)this.geometry._storedFunction=i;else{const r=i(e);this.geometry._storedFunction=()=>(this.geometry._executionCount=1,r.clone())}}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),this.evaluateContext=e.evaluateContext}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],CC.prototype,"evaluateContext",void 0);B("BABYLON.CylinderBlock",CC);class PC extends be{constructor(e){super(e),this.evaluateContext=!1,this.registerInput("height",I.Float,!0,1),this.registerInput("radius",I.Float,!0,.25),this.registerInput("tessellation",I.Int,!0,16),this.registerInput("subdivisions",I.Int,!0,2),this.registerOutput("geometry",I.Geometry)}getClassName(){return"CapsuleBlock"}get height(){return this._inputs[0]}get radius(){return this._inputs[1]}get tessellation(){return this._inputs[2]}get subdivisions(){return this._inputs[3]}get geometry(){return this._outputs[0]}autoConfigure(){if(!this.height.isConnected){const e=new Ft("Height");e.value=1,e.output.connectTo(this.height)}if(!this.radius.isConnected){const e=new Ft("Radius");e.value=.2,e.output.connectTo(this.radius)}}_buildBlock(e){const t={},i=r=>(t.height=this.height.getConnectedValue(r),t.radius=this.radius.getConnectedValue(r),t.tessellation=this.tessellation.getConnectedValue(r),t.subdivisions=this.subdivisions.getConnectedValue(r),d_(t));if(this.evaluateContext)this.geometry._storedFunction=i;else{const r=i(e);this.geometry._storedFunction=()=>(this.geometry._executionCount=1,r.clone())}}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),this.evaluateContext=e.evaluateContext}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],PC.prototype,"evaluateContext",void 0);B("BABYLON.CapsuleBlock",PC);class EC extends be{constructor(e){super(e),this.evaluateContext=!1,this.registerInput("radius",I.Float,!0,.5),this.registerInput("tessellation",I.Int,!0,64),this.registerInput("arc",I.Float,!0,1),this.registerOutput("geometry",I.Geometry)}getClassName(){return"DiscBlock"}get radius(){return this._inputs[0]}get tessellation(){return this._inputs[1]}get arc(){return this._inputs[2]}get geometry(){return this._outputs[0]}autoConfigure(){if(!this.radius.isConnected){const e=new Ft("Radius");e.value=.2,e.output.connectTo(this.radius)}}_buildBlock(e){const t={},i=r=>(t.radius=this.radius.getConnectedValue(r),t.tessellation=this.tessellation.getConnectedValue(r),t.arc=this.arc.getConnectedValue(r),p_(t));if(this.evaluateContext)this.geometry._storedFunction=i;else{const r=i(e);this.geometry._storedFunction=()=>(this.geometry._executionCount=1,r.clone())}}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),this.evaluateContext=e.evaluateContext}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],EC.prototype,"evaluateContext",void 0);B("BABYLON.DiscBlock",EC);class TL extends be{constructor(e){super(e),this.registerOutput("geometry",I.Geometry),this.registerOutput("vector",I.Vector3)}getClassName(){return"NullBlock"}get geometry(){return this._outputs[0]}get vector(){return this._outputs[1]}_buildBlock(){this.geometry._storedValue=null,this.vector._storedValue=null}}B("BABYLON.NullBlock",TL);class CL extends be{constructor(e){super(e),this.points=[],this.registerOutput("geometry",I.Geometry)}getClassName(){return"PointListBlock"}get geometry(){return this._outputs[0]}_buildBlock(e){this.geometry._storedFunction=()=>{if(this.geometry._executionCount=1,this.points.length===0)return null;const t=new he;return t.positions=this.points.reduce((i,r)=>(i.push(r.x,r.y,r.z),i),[]),t}}_dumpPropertiesCode(){let e=super._dumpPropertiesCode()+`${this._codeVariableName}.points = [];
`;for(let t=0;t<this.points.length;t++){const i=this.points[t];e+=`${this._codeVariableName}.points.push(new BABYLON.Vector3(${i.x}, ${i.y}, ${i.z}));
`}return e}serialize(){const e=super.serialize();return e.points=this.points.map(t=>t.asArray()),e}_deserialize(e){super._deserialize(e),this.points=e.points.map(t=>m.FromArray(t))}}B("BABYLON.PointListBlock",CL);class IC extends be{constructor(e){super(e),this.evaluateContext=!0,this.registerInput("geometry",I.Geometry),this.registerInput("positions",I.Vector3),this.registerOutput("output",I.Geometry)}getExecutionIndex(){return this._currentIndex}getExecutionLoopIndex(){return this._currentIndex}getExecutionFaceIndex(){return 0}getClassName(){return"SetPositionsBlock"}get geometry(){return this._inputs[0]}get positions(){return this._inputs[1]}get output(){return this._outputs[0]}_remapVector3Data(e,t){const i=[];for(let r=0;r<e.length;r+=3)t[r/3]!==void 0&&i.push(e[r],e[r+1],e[r+2]);return i}_remapVector4Data(e,t){const i=[];for(let r=0;r<e.length;r+=4)t[r/4]!==void 0&&i.push(e[r],e[r+1],e[r+2],e[r+3]);return i}_remapVector2Data(e,t){const i=[];for(let r=0;r<e.length;r+=2)t[r/2]!==void 0&&i.push(e[r],e[r+1]);return i}_buildBlock(e){const t=i=>{if(i.pushExecutionContext(this),this._vertexData=this.geometry.getConnectedValue(i),this._vertexData&&(this._vertexData=this._vertexData.clone()),i.pushGeometryContext(this._vertexData),!this._vertexData||!this._vertexData.positions||!this.positions.isConnected){i.restoreGeometryContext(),i.restoreExecutionContext(),this.output._storedValue=null;return}const r={},s=this._vertexData.positions.length/3,n=[];let o=0,l=!1;for(this._currentIndex=0;this._currentIndex<s;this._currentIndex++){const u=this.positions.getConnectedValue(i);u?(u.toArray(n,o*3),r[this._currentIndex]=o,o++):l=!0}if(l){if(this._vertexData.indices){const u=[];for(let c=0;c<this._vertexData.indices.length;c+=3){const h=this._vertexData.indices[c],d=this._vertexData.indices[c+1],f=this._vertexData.indices[c+2],p=r[h],g=r[d],_=r[f];p!==void 0&&g!==void 0&&_!==void 0&&(u.push(p),u.push(g),u.push(_))}this._vertexData.indices=u}this._vertexData.normals&&(this._vertexData.normals=this._remapVector3Data(this._vertexData.normals,r)),this._vertexData.tangents&&(this._vertexData.tangents=this._remapVector4Data(this._vertexData.tangents,r)),this._vertexData.colors&&(this._vertexData.colors=this._remapVector4Data(this._vertexData.colors,r)),this._vertexData.uvs&&(this._vertexData.uvs=this._remapVector2Data(this._vertexData.uvs,r)),this._vertexData.uvs2&&(this._vertexData.uvs2=this._remapVector2Data(this._vertexData.uvs2,r)),this._vertexData.uvs3&&(this._vertexData.uvs3=this._remapVector2Data(this._vertexData.uvs3,r)),this._vertexData.uvs4&&(this._vertexData.uvs4=this._remapVector2Data(this._vertexData.uvs4,r)),this._vertexData.uvs5&&(this._vertexData.uvs5=this._remapVector2Data(this._vertexData.uvs5,r)),this._vertexData.uvs6&&(this._vertexData.uvs6=this._remapVector2Data(this._vertexData.uvs6,r))}return this._vertexData.positions=n,i.restoreGeometryContext(),i.restoreExecutionContext(),this._vertexData};this.evaluateContext?this.output._storedFunction=t:(this.output._storedFunction=null,this.output._storedValue=t(e))}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),e.evaluateContext!==void 0&&(this.evaluateContext=e.evaluateContext)}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],IC.prototype,"evaluateContext",void 0);B("BABYLON.SetPositionsBlock",IC);class RC extends be{constructor(e){super(e),this.evaluateContext=!0,this.registerInput("geometry",I.Geometry),this.registerInput("normals",I.Vector3),this.registerOutput("output",I.Geometry)}getExecutionIndex(){return this._currentIndex}getExecutionLoopIndex(){return this._currentIndex}getExecutionFaceIndex(){return 0}getClassName(){return"SetNormalsBlock"}get geometry(){return this._inputs[0]}get normals(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){const t=i=>{if(i.pushExecutionContext(this),this._vertexData=this.geometry.getConnectedValue(i),this._vertexData&&(this._vertexData=this._vertexData.clone()),i.pushGeometryContext(this._vertexData),!this._vertexData||!this._vertexData.positions){i.restoreGeometryContext(),i.restoreExecutionContext(),this.output._storedValue=null;return}if(!this.normals.isConnected){i.restoreGeometryContext(),i.restoreExecutionContext(),this.output._storedValue=this._vertexData;return}this._vertexData.normals||(this._vertexData.normals=[]);const r=this._vertexData.positions.length/3;for(this._currentIndex=0;this._currentIndex<r;this._currentIndex++){const s=this.normals.getConnectedValue(i);s&&s.toArray(this._vertexData.normals,this._currentIndex*3)}return i.restoreGeometryContext(),i.restoreExecutionContext(),this._vertexData};this.evaluateContext?this.output._storedFunction=t:(this.output._storedFunction=null,this.output._storedValue=t(e))}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),e.evaluateContext!==void 0&&(this.evaluateContext=e.evaluateContext)}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],RC.prototype,"evaluateContext",void 0);B("BABYLON.SetNormalsBlock",RC);class $_ extends be{constructor(e){super(e),this.evaluateContext=!0,this.textureCoordinateIndex=0,this.registerInput("geometry",I.Geometry),this.registerInput("uvs",I.Vector2),this.registerOutput("output",I.Geometry)}getExecutionIndex(){return this._currentIndex}getExecutionLoopIndex(){return this._currentIndex}getExecutionFaceIndex(){return 0}getClassName(){return"SetUVsBlock"}get geometry(){return this._inputs[0]}get uvs(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){const t=i=>{if(i.pushExecutionContext(this),this._vertexData=this.geometry.getConnectedValue(i),this._vertexData&&(this._vertexData=this._vertexData.clone()),i.pushGeometryContext(this._vertexData),!this._vertexData||!this._vertexData.positions){i.restoreGeometryContext(),i.restoreExecutionContext(),this.output._storedValue=null;return}if(!this.uvs.isConnected){i.restoreGeometryContext(),i.restoreExecutionContext(),this.output._storedValue=this._vertexData;return}const r=[],s=this._vertexData.positions.length/3;for(this._currentIndex=0;this._currentIndex<s;this._currentIndex++){const n=this.uvs.getConnectedValue(i);n&&n.toArray(r,this._currentIndex*2)}switch(this.textureCoordinateIndex){case 0:this._vertexData.uvs=r;break;case 1:this._vertexData.uvs2=r;break;case 2:this._vertexData.uvs3=r;break;case 3:this._vertexData.uvs4=r;break;case 4:this._vertexData.uvs5=r;break;case 5:this._vertexData.uvs6=r;break}return i.restoreGeometryContext(),i.restoreExecutionContext(),this._vertexData};this.evaluateContext?this.output._storedFunction=t:(this.output._storedFunction=null,this.output._storedValue=t(e))}_dumpPropertiesCode(){let e=super._dumpPropertiesCode()+`${this._codeVariableName}.textureCoordinateIndex};
`;return e+=`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`,e}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e.textureCoordinateIndex=this.textureCoordinateIndex,e}_deserialize(e){super._deserialize(e),this.textureCoordinateIndex=e.textureCoordinateIndex,e.evaluateContext!==void 0&&(this.evaluateContext=e.evaluateContext)}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],$_.prototype,"evaluateContext",void 0);C([U("Texture coordinates index",4,"ADVANCED",{notifiers:{update:!0},embedded:!0,options:[{label:"UV1",value:0},{label:"UV2",value:1},{label:"UV3",value:2},{label:"UV4",value:3},{label:"UV5",value:4},{label:"UV6",value:5}]})],$_.prototype,"textureCoordinateIndex",void 0);B("BABYLON.SetUVsBlock",$_);class MC extends be{constructor(e){super(e),this.evaluateContext=!0,this.registerInput("geometry",I.Geometry),this.registerInput("colors",I.AutoDetect),this.registerOutput("output",I.Geometry),this._inputs[1].excludedConnectionPointTypes.push(I.Int),this._inputs[1].excludedConnectionPointTypes.push(I.Float),this._inputs[1].excludedConnectionPointTypes.push(I.Vector2),this._inputs[1].excludedConnectionPointTypes.push(I.Texture),this._inputs[1].excludedConnectionPointTypes.push(I.Texture)}getExecutionIndex(){return this._currentIndex}getExecutionLoopIndex(){return this._currentIndex}getExecutionFaceIndex(){return 0}getClassName(){return"SetColorsBlock"}get geometry(){return this._inputs[0]}get colors(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){const t=i=>{var s;if(i.pushExecutionContext(this),this._vertexData=this.geometry.getConnectedValue(i),this._vertexData&&(this._vertexData=this._vertexData.clone()),i.pushGeometryContext(this._vertexData),!this._vertexData||!this._vertexData.positions){i.restoreGeometryContext(),i.restoreExecutionContext(),this.output._storedValue=null;return}if(!this.colors.isConnected){i.restoreGeometryContext(),i.restoreExecutionContext(),this.output._storedValue=this._vertexData;return}this._vertexData.colors||(this._vertexData.colors=[]);const r=this._vertexData.positions.length/3;for(this._currentIndex=0;this._currentIndex<r;this._currentIndex++)if(((s=this.colors.connectedPoint)==null?void 0:s.type)===I.Vector3){const n=this.colors.getConnectedValue(i);n&&(n.toArray(this._vertexData.colors,this._currentIndex*4),this._vertexData.colors[this._currentIndex*4+3]=1,this._vertexData.hasVertexAlpha=!1)}else{const n=this.colors.getConnectedValue(i);n&&(n.toArray(this._vertexData.colors,this._currentIndex*4),this._vertexData.hasVertexAlpha=!0)}return i.restoreGeometryContext(),i.restoreExecutionContext(),this._vertexData};this.evaluateContext?this.output._storedFunction=t:(this.output._storedFunction=null,this.output._storedValue=t(e))}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),e.evaluateContext!==void 0&&(this.evaluateContext=e.evaluateContext)}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],MC.prototype,"evaluateContext",void 0);B("BABYLON.SetColorsBlock",MC);class AC extends be{constructor(e){super(e),this.evaluateContext=!0,this.registerInput("geometry",I.Geometry),this.registerInput("tangents",I.Vector4),this.registerOutput("output",I.Geometry)}getExecutionIndex(){return this._currentIndex}getExecutionLoopIndex(){return this._currentIndex}getExecutionFaceIndex(){return 0}getClassName(){return"SetTangentsBlock"}get geometry(){return this._inputs[0]}get tangents(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){const t=i=>{if(i.pushExecutionContext(this),this._vertexData=this.geometry.getConnectedValue(i),this._vertexData&&(this._vertexData=this._vertexData.clone()),i.pushGeometryContext(this._vertexData),!this._vertexData||!this._vertexData.positions){i.restoreGeometryContext(),i.restoreExecutionContext(),this.output._storedValue=null;return}if(!this.tangents.isConnected){i.restoreGeometryContext(),i.restoreExecutionContext(),this.output._storedValue=this._vertexData;return}this._vertexData.tangents||(this._vertexData.tangents=[]);const r=this._vertexData.positions.length/3;for(this._currentIndex=0;this._currentIndex<r;this._currentIndex++){const s=this.tangents.getConnectedValue(i);s&&s.toArray(this._vertexData.tangents,this._currentIndex*4)}return i.restoreGeometryContext(),i.restoreExecutionContext(),this._vertexData};this.evaluateContext?this.output._storedFunction=t:(this.output._storedFunction=null,this.output._storedValue=t(e))}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),e.evaluateContext!==void 0&&(this.evaluateContext=e.evaluateContext)}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],AC.prototype,"evaluateContext",void 0);B("BABYLON.SetTangentsBlock",AC);var Ei;(function(a){a[a.Add=0]="Add",a[a.Subtract=1]="Subtract",a[a.Multiply=2]="Multiply",a[a.Divide=3]="Divide",a[a.Max=4]="Max",a[a.Min=5]="Min"})(Ei||(Ei={}));class DC extends be{constructor(e){super(e),this.operation=Ei.Add,this.registerInput("left",I.AutoDetect),this.registerInput("right",I.AutoDetect),this.registerOutput("output",I.BasedOnInput),this.output._typeConnectionSource=this.left;const t=[I.Matrix,I.Geometry,I.Texture];this.left.excludedConnectionPointTypes.push(...t),this.right.excludedConnectionPointTypes.push(...t),this._linkConnectionTypes(0,1),this._connectionObservers=[this.left.onConnectionObservable.add(()=>this._updateInputOutputTypes()),this.left.onDisconnectionObservable.add(()=>this._updateInputOutputTypes()),this.right.onConnectionObservable.add(()=>this._updateInputOutputTypes()),this.right.onDisconnectionObservable.add(()=>this._updateInputOutputTypes())]}getClassName(){return"MathBlock"}get left(){return this._inputs[0]}get right(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(){let e;const t=this.left,i=this.right;if(!t.isConnected||!i.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}const r=t.type===I.Float||t.type===I.Int,s=i.type===I.Float||i.type===I.Int,n=r&&s;switch(this.operation){case Ei.Add:{n?e=o=>t.getConnectedValue(o)+i.getConnectedValue(o):r?e=o=>o.adapt(t,i.type).add(i.getConnectedValue(o)):e=o=>t.getConnectedValue(o).add(o.adapt(i,t.type));break}case Ei.Subtract:{n?e=o=>t.getConnectedValue(o)-i.getConnectedValue(o):r?e=o=>o.adapt(t,i.type).subtract(i.getConnectedValue(o)):e=o=>t.getConnectedValue(o).subtract(o.adapt(i,t.type));break}case Ei.Multiply:{n?e=o=>t.getConnectedValue(o)*i.getConnectedValue(o):r?e=o=>o.adapt(t,i.type).multiply(i.getConnectedValue(o)):e=o=>t.getConnectedValue(o).multiply(o.adapt(i,t.type));break}case Ei.Divide:{n?e=o=>t.getConnectedValue(o)/i.getConnectedValue(o):r?e=o=>o.adapt(t,i.type).divide(i.getConnectedValue(o)):e=o=>t.getConnectedValue(o).divide(o.adapt(i,t.type));break}case Ei.Min:{if(n)e=o=>Math.min(t.getConnectedValue(o),i.getConnectedValue(o));else{const[o,l]=r?[i,t]:[t,i];switch(o.type){case I.Vector2:{e=u=>Q.Minimize(o.getConnectedValue(u),u.adapt(l,o.type));break}case I.Vector3:{e=u=>m.Minimize(o.getConnectedValue(u),u.adapt(l,o.type));break}case I.Vector4:{e=u=>Ve.Minimize(o.getConnectedValue(u),u.adapt(l,o.type));break}}}break}case Ei.Max:if(n)e=o=>Math.max(t.getConnectedValue(o),i.getConnectedValue(o));else{const[o,l]=r?[i,t]:[t,i];switch(o.type){case I.Vector2:{e=u=>Q.Maximize(o.getConnectedValue(u),u.adapt(l,o.type));break}case I.Vector3:{e=u=>m.Maximize(o.getConnectedValue(u),u.adapt(l,o.type));break}case I.Vector4:{e=u=>Ve.Maximize(o.getConnectedValue(u),u.adapt(l,o.type));break}}break}}this.output._storedFunction=o=>t.type===I.Int?e(o)|0:e(o)}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.operation = BABYLON.MathBlockOperations.${Ei[this.operation]};
`}_updateInputOutputTypes(){if(this.output._typeConnectionSource=this.left,this.left.isConnected&&this.right.isConnected?(this.left.type===I.Int||this.left.type===I.Float&&this.right.type!==I.Int)&&(this.output._typeConnectionSource=this.right):this.left.isConnected!==this.right.isConnected&&(this.output._typeConnectionSource=this.left.isConnected?this.left:this.right),this.left.isConnected||this.right.isConnected)for(const[e,t]of[[this.left,this.right],[this.right,this.left]])e.acceptedConnectionPointTypes=[I.Int,I.Float],t.isConnected&&(e.acceptedConnectionPointTypes.push(t.type),(t.type===I.Int||t.type===I.Float)&&e.acceptedConnectionPointTypes.push(I.Vector2,I.Vector3,I.Vector4))}dispose(){super.dispose(),this._connectionObservers.forEach(e=>e.remove()),this._connectionObservers.length=0}serialize(){const e=super.serialize();return e.operation=this.operation,e}_deserialize(e){super._deserialize(e),this.operation=e.operation}}C([U("Operation",4,"ADVANCED",{notifiers:{rebuild:!0},embedded:!0,options:[{label:"Add",value:Ei.Add},{label:"Subtract",value:Ei.Subtract},{label:"Multiply",value:Ei.Multiply},{label:"Divide",value:Ei.Divide},{label:"Max",value:Ei.Max},{label:"Min",value:Ei.Min}]})],DC.prototype,"operation",void 0);B("BABYLON.MathBlock",DC);class PL extends be{constructor(e){super(e),this.registerInput("value",I.AutoDetect),this.registerInput("fromMin",I.Float,!0,0),this.registerInput("fromMax",I.Float,!0,1),this.registerInput("toMin",I.Float,!0,0),this.registerInput("toMax",I.Float,!0,1),this.registerOutput("output",I.BasedOnInput),this._inputs[0].excludedConnectionPointTypes.push(I.Vector2),this._inputs[0].excludedConnectionPointTypes.push(I.Vector3),this._inputs[0].excludedConnectionPointTypes.push(I.Vector4),this._inputs[0].excludedConnectionPointTypes.push(I.Matrix),this._inputs[0].excludedConnectionPointTypes.push(I.Geometry),this._inputs[0].excludedConnectionPointTypes.push(I.Texture),this._outputs[0]._typeConnectionSource=this._inputs[0]}getClassName(){return"MapRangeBlock"}get value(){return this._inputs[0]}get fromMin(){return this._inputs[1]}get fromMax(){return this._inputs[2]}get toMin(){return this._inputs[3]}get toMax(){return this._inputs[4]}get output(){return this._outputs[0]}_buildBlock(){if(!this.value.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}this.output._storedFunction=e=>{const t=this.value.getConnectedValue(e),i=this.fromMin.getConnectedValue(e),r=this.fromMax.getConnectedValue(e),s=this.toMin.getConnectedValue(e),n=this.toMax.getConnectedValue(e),o=(t-i)/(r-i)*(n-s)+s;return this.output.type===I.Int?Math.floor(o):o}}}B("BABYLON.MapRangeBlock",PL);var jt;(function(a){a[a.Equal=0]="Equal",a[a.NotEqual=1]="NotEqual",a[a.LessThan=2]="LessThan",a[a.GreaterThan=3]="GreaterThan",a[a.LessOrEqual=4]="LessOrEqual",a[a.GreaterOrEqual=5]="GreaterOrEqual",a[a.Xor=6]="Xor",a[a.Or=7]="Or",a[a.And=8]="And"})(jt||(jt={}));class H_ extends be{constructor(e){super(e),this.test=jt.Equal,this.epsilon=0,this.registerInput("left",I.Float),this.registerInput("right",I.Float,!0,0),this.registerInput("ifTrue",I.AutoDetect,!0,1),this.registerInput("ifFalse",I.AutoDetect,!0,0),this.registerOutput("output",I.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[2],this._outputs[0]._defaultConnectionPointType=I.Float,this._inputs[0].acceptedConnectionPointTypes.push(I.Int),this._inputs[1].acceptedConnectionPointTypes.push(I.Int),this._linkConnectionTypes(2,3)}getClassName(){return"ConditionBlock"}get left(){return this._inputs[0]}get right(){return this._inputs[1]}get ifTrue(){return this._inputs[2]}get ifFalse(){return this._inputs[3]}get output(){return this._outputs[0]}autoConfigure(e){if(!this.ifTrue.isConnected){const t=e.getBlockByPredicate(i=>i.isInput&&i.value===1&&i.name==="True")||new Ft("True");t.value=1,t.output.connectTo(this.ifTrue)}if(!this.ifFalse.isConnected){const t=e.getBlockByPredicate(i=>i.isInput&&i.value===0&&i.name==="False")||new Ft("False");t.value=0,t.output.connectTo(this.ifFalse)}}_buildBlock(){if(!this.left.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}const e=t=>{const i=this.left.getConnectedValue(t),r=this.right.getConnectedValue(t);let s=!1;switch(this.test){case jt.Equal:s=Fn(i,r,this.epsilon);break;case jt.NotEqual:s=!Fn(i,r,this.epsilon);break;case jt.LessThan:s=i<r+this.epsilon;break;case jt.GreaterThan:s=i>r-this.epsilon;break;case jt.LessOrEqual:s=i<=r+this.epsilon;break;case jt.GreaterOrEqual:s=i>=r-this.epsilon;break;case jt.Xor:s=!!i&&!r||!i&&!!r;break;case jt.Or:s=!!i||!!r;break;case jt.And:s=!!i&&!!r;break}return s};this.output._storedFunction=t=>e(t)?this.ifTrue.getConnectedValue(t):this.ifFalse.getConnectedValue(t)}_dumpPropertiesCode(){let e=super._dumpPropertiesCode()+`${this._codeVariableName}.test = BABYLON.ConditionBlockTests.${jt[this.test]};
`;return e+=`${this._codeVariableName}.epsilon = ${this.epsilon};
`,e}serialize(){const e=super.serialize();return e.test=this.test,e.epsilon=this.epsilon,e}_deserialize(e){super._deserialize(e),this.test=e.test,e.epsilon!==void 0&&(this.epsilon=e.epsilon)}}C([U("Test",4,"ADVANCED",{notifiers:{rebuild:!0},embedded:!0,options:[{label:"Equal",value:jt.Equal},{label:"NotEqual",value:jt.NotEqual},{label:"LessThan",value:jt.LessThan},{label:"GreaterThan",value:jt.GreaterThan},{label:"LessOrEqual",value:jt.LessOrEqual},{label:"GreaterOrEqual",value:jt.GreaterOrEqual},{label:"Xor",value:jt.Xor},{label:"Or",value:jt.Or},{label:"And",value:jt.And}]})],H_.prototype,"test",void 0);C([U("Epsilon",1,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],H_.prototype,"epsilon",void 0);B("BABYLON.ConditionBlock",H_);var lr;(function(a){a[a.None=0]="None",a[a.LoopID=1]="LoopID",a[a.InstanceID=2]="InstanceID",a[a.Once=3]="Once"})(lr||(lr={}));class OC extends be{constructor(e){super(e),this._currentLockId=-1,this.lockMode=lr.None,this.registerInput("min",I.AutoDetect),this.registerInput("max",I.AutoDetect),this.registerOutput("output",I.BasedOnInput),this._inputs[0].excludedConnectionPointTypes.push(I.Matrix),this._inputs[0].excludedConnectionPointTypes.push(I.Geometry),this._inputs[0].excludedConnectionPointTypes.push(I.Texture),this._inputs[1].excludedConnectionPointTypes.push(I.Matrix),this._inputs[1].excludedConnectionPointTypes.push(I.Geometry),this._inputs[1].excludedConnectionPointTypes.push(I.Texture),this._outputs[0]._typeConnectionSource=this._inputs[0],this._linkConnectionTypes(0,1)}getClassName(){return"RandomBlock"}get min(){return this._inputs[0]}get max(){return this._inputs[1]}get output(){return this._outputs[0]}autoConfigure(){if(!this.min.isConnected){const e=new Ft("Min");e.value=0,e.output.connectTo(this.min)}if(!this.max.isConnected){const e=new Ft("Max");e.value=1,e.output.connectTo(this.max)}}_buildBlock(){let e=null;switch(this._currentLockId=-1,this.min.type){case I.Int:case I.Float:{e=t=>{const i=this.min.getConnectedValue(t)||0,r=this.max.getConnectedValue(t)||0;return i+Math.random()*(r-i)};break}case I.Vector2:{e=t=>{const i=this.min.getConnectedValue(t)||Q.Zero(),r=this.max.getConnectedValue(t)||Q.Zero();return new Q(i.x+Math.random()*(r.x-i.x),i.y+Math.random()*(r.y-i.y))};break}case I.Vector3:{e=t=>{const i=this.min.getConnectedValue(t)||m.Zero(),r=this.max.getConnectedValue(t)||m.Zero();return new m(i.x+Math.random()*(r.x-i.x),i.y+Math.random()*(r.y-i.y),i.z+Math.random()*(r.z-i.z))};break}case I.Vector4:{e=t=>{const i=this.min.getConnectedValue(t)||Ve.Zero(),r=this.max.getConnectedValue(t)||Ve.Zero();return new Ve(i.x+Math.random()*(r.x-i.x),i.y+Math.random()*(r.y-i.y),i.z+Math.random()*(r.z-i.z),i.w+Math.random()*(r.w-i.w))};break}}this.lockMode===lr.None||!e?this.output._storedFunction=e:this.output._storedFunction=t=>{let i=0;switch(this.lockMode){case lr.InstanceID:i=t.getContextualValue($e.InstanceID,!0)||0;break;case lr.LoopID:i=t.getContextualValue($e.LoopID,!0)||0;break;case lr.Once:i=t.buildId||0;break}return(this._currentLockId!==i||this.lockMode===lr.None)&&(this._currentLockId=i,this.output._storedValue=e(t)),this.output._storedValue}}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.lockMode = BABYLON.RandomBlockLocks.${lr[this.lockMode]};
`}serialize(){const e=super.serialize();return e.lockMode=this.lockMode,e}_deserialize(e){super._deserialize(e),this.lockMode=e.lockMode}}C([U("LockMode",4,"ADVANCED",{notifiers:{rebuild:!0},embedded:!0,options:[{label:"None",value:lr.None},{label:"LoopID",value:lr.LoopID},{label:"InstanceID",value:lr.InstanceID},{label:"Once",value:lr.Once}]})],OC.prototype,"lockMode",void 0);B("BABYLON.RandomBlock",OC);class EL extends be{constructor(e){super(e),this.registerInput("offset",I.Vector3,!0,m.Zero()),this.registerInput("scale",I.Float,!0,1),this.registerInput("octaves",I.Float,!0,2,0,16),this.registerInput("roughness",I.Float,!0,.5,0,1),this.registerOutput("output",I.Float)}getClassName(){return"NoiseBlock"}get offset(){return this._inputs[0]}get scale(){return this._inputs[1]}get octaves(){return this._inputs[2]}get roughness(){return this._inputs[3]}get output(){return this._outputs[0]}_negateIf(e,t){return t!==0?-e:e}_noiseGrad(e,t,i,r){const s=e&15,n=s<8?t:i,o=s===12||s==14?t:r,l=s<4?i:o;return this._negateIf(n,s&n)+this._negateIf(l,s&2)}_fade(e){return e*e*e*(e*(e*6-15)+10)}_hashBitRotate(e,t){return e<<t|e>>32-t}_hash(e,t,i){let r,s,n;return r=s=n=3735928584,n+=i,s+=t,r+=e,n^=s,n-=this._hashBitRotate(s,14),r^=n,r-=this._hashBitRotate(n,11),s^=r,s-=this._hashBitRotate(r,25),n^=s,n-=this._hashBitRotate(s,16),r^=n,r-=this._hashBitRotate(n,4),s^=r,s-=this._hashBitRotate(r,14),n^=s,n-=this._hashBitRotate(s,24),n}_mix(e,t,i,r,s,n,o,l,u,c,h){const d=1-u,f=1-c;return(1-h)*(f*(e*d+t*u)+c*(i*d+r*u))+h*(f*(s*d+n*u)+c*(o*d+l*u))}_perlinNoise(e){const t=(e.x|0)-(e.x<0?1:0),i=(e.y|0)-(e.y<0?1:0),r=(e.z|0)-(e.z<0?1:0),s=e.x-t,n=e.y-i,o=e.z-r,l=this._fade(s),u=this._fade(n),c=this._fade(o);return this._mix(this._noiseGrad(this._hash(t,i,r),s,n,o),this._noiseGrad(this._hash(t+1,i,r),s-1,n,o),this._noiseGrad(this._hash(t,i+1,r),s,n-1,o),this._noiseGrad(this._hash(t+1,i+1,r),s-1,n-1,o),this._noiseGrad(this._hash(t,i,r+1),s,n,o-1),this._noiseGrad(this._hash(t+1,i,r+1),s-1,n,o-1),this._noiseGrad(this._hash(t,i+1,r+1),s,n-1,o-1),this._noiseGrad(this._hash(t+1,i+1,r+1),s-1,n-1,o-1),l,u,c)}_perlinSigned(e){return this._perlinNoise(e)*.982}_perlin(e){return this._perlinSigned(e)/2+.5}noise(e,t,i,r,s){const n=new m(i.x*s+r.x,i.y*s+r.y,i.z*s+r.z);let o=1,l=1,u=0,c=0;e=Si(e,0,15);const h=e|0;for(let g=0;g<=h;g++){const _=this._perlin(n.scale(o));c+=_*l,u+=l,l*=Si(t,0,1),o*=2}const d=e-Math.floor(e);if(d==0)return c/u;const f=this._perlin(n.scale(o));let p=c+f*l;return c/=u,p/=u+l,(1-d)*c+d*p}_buildBlock(){this.output._storedFunction=e=>{const t=e.getContextualValue($e.Positions),i=this.octaves.getConnectedValue(e),r=this.roughness.getConnectedValue(e),s=this.offset.getConnectedValue(e),n=this.scale.getConnectedValue(e);return this.noise(i,r,t,s,n)}}}B("BABYLON.NoiseBlock",EL);class wC extends be{constructor(e){super(e),this.evaluateContext=!1,this.registerInput("geometry0",I.Geometry),this.registerInput("geometry1",I.Geometry,!0),this.registerInput("geometry2",I.Geometry,!0),this.registerInput("geometry3",I.Geometry,!0),this.registerInput("geometry4",I.Geometry,!0),this.registerOutput("output",I.Geometry)}getClassName(){return"MergeGeometryBlock"}get geometry0(){return this._inputs[0]}get geometry1(){return this._inputs[1]}get geometry2(){return this._inputs[2]}get geometry3(){return this._inputs[3]}get geometry4(){return this._inputs[4]}get output(){return this._outputs[0]}_buildBlock(e){const t=i=>{const r=[];if(this.geometry0.isConnected){const o=this.geometry0.getConnectedValue(i);o&&r.push(o)}if(this.geometry1.isConnected){const o=this.geometry1.getConnectedValue(i);o&&r.push(o)}if(this.geometry2.isConnected){const o=this.geometry2.getConnectedValue(i);o&&r.push(o)}if(this.geometry3.isConnected){const o=this.geometry3.getConnectedValue(i);o&&r.push(o)}if(this.geometry4.isConnected){const o=this.geometry4.getConnectedValue(i);o&&r.push(o)}if(r.length===0)return null;let s=r[0].clone();const n=r.slice(1);return n.length&&s&&(s=s.merge(n,!0,!1,!0,!0)),s};this.evaluateContext?this.output._storedFunction=t:(this.output._storedFunction=null,this.output._storedValue=t(e))}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),this.evaluateContext=e.evaluateContext}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],wC.prototype,"evaluateContext",void 0);B("BABYLON.MergeGeometryBlock",wC);class NC extends be{constructor(e){super(e),this.evaluateContext=!0,this.registerInput("geometry0",I.Geometry,!0),this.registerInput("geometry1",I.Geometry,!0),this.registerInput("geometry2",I.Geometry,!0),this.registerInput("geometry3",I.Geometry,!0),this.registerInput("geometry4",I.Geometry,!0),this.registerInput("geometry5",I.Geometry,!0),this.registerInput("geometry6",I.Geometry,!0),this.registerInput("geometry7",I.Geometry,!0),this.registerInput("geometry8",I.Geometry,!0),this.registerInput("geometry9",I.Geometry,!0),this.registerOutput("output",I.Geometry),this._outputs[0]._typeConnectionSource=this._inputs[0],this._linkConnectionTypes(0,1)}getClassName(){return"GeometryCollectionBlock"}get geometry0(){return this._inputs[0]}get geometry1(){return this._inputs[1]}get geometry2(){return this._inputs[2]}get geometry3(){return this._inputs[3]}get geometry4(){return this._inputs[4]}get geometry5(){return this._inputs[5]}get geometry6(){return this._inputs[6]}get geometry7(){return this._inputs[7]}get geometry8(){return this._inputs[8]}get geometry9(){return this._inputs[9]}get output(){return this._outputs[0]}_storeGeometry(e,t,i,r){if(e.isConnected){const s=e.getConnectedValue(t);if(!s)return;s.metadata=s.metadata||{},s.metadata.collectionId=i,r.push(s)}}_buildBlock(e){const t=i=>{const r=[];return this._storeGeometry(this.geometry0,i,0,r),this._storeGeometry(this.geometry1,i,1,r),this._storeGeometry(this.geometry2,i,2,r),this._storeGeometry(this.geometry3,i,3,r),this._storeGeometry(this.geometry4,i,4,r),this._storeGeometry(this.geometry5,i,5,r),this._storeGeometry(this.geometry6,i,6,r),this._storeGeometry(this.geometry7,i,7,r),this._storeGeometry(this.geometry8,i,8,r),this._storeGeometry(this.geometry9,i,9,r),r.length?r[Math.round(Math.random()*(r.length-1))]:null};this.evaluateContext?this.output._storedFunction=t:(this.output._storedFunction=null,this.output._storedValue=t(e))}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),this.evaluateContext=e.evaluateContext}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],NC.prototype,"evaluateContext",void 0);B("BABYLON.GeometryCollectionBlock",NC);class FC extends be{constructor(e){super(e),this.evaluateContext=!0,this.registerInput("geometry",I.Geometry),this.registerOutput("output",I.Geometry)}getClassName(){return"CleanGeometryBlock"}get geometry(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){const t=i=>{if(!this.geometry.isConnected)return null;const r=this.geometry.getConnectedValue(i).clone();if(!r.positions||!r.indices||!r.normals)return r;const s=r.indices,n=r.positions;return DM(n,s),r};this.evaluateContext?this.output._storedFunction=t:(this.output._storedFunction=null,this.output._storedValue=t(e))}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),this.evaluateContext=e.evaluateContext}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],FC.prototype,"evaluateContext",void 0);B("BABYLON.CleanGeometryBlock",FC);class IL extends be{constructor(e){super(e),this.registerInput("input",I.AutoDetect),this.registerOutput("output",I.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0]}get buildExecutionTime(){return-1}getClassName(){return"GeometryElbowBlock"}get input(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0],i=this._inputs[0];t._storedFunction=r=>i.getConnectedValue(r)}}B("BABYLON.GeometryElbowBlock",IL);class RL extends be{constructor(e){super(e),this.registerInput("geometry",I.Geometry),this.registerOutput("output",I.Geometry)}getClassName(){return"ComputeNormalsBlock"}get geometry(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(){this.output._storedFunction=e=>{if(!this.geometry.isConnected)return null;const t=this.geometry.getConnectedValue(e);return t?(t.normals||(t.normals=[]),he.ComputeNormals(t.positions,t.indices,t.normals),t):null}}}B("BABYLON.ComputeNormalsBlock",RL);class ML extends be{constructor(e){super(e),this.registerInput("xyzw ",I.Vector4,!0),this.registerInput("xyz ",I.Vector3,!0),this.registerInput("xy ",I.Vector2,!0),this.registerInput("zw ",I.Vector2,!0),this.registerInput("x ",I.Float,!0),this.registerInput("y ",I.Float,!0),this.registerInput("z ",I.Float,!0),this.registerInput("w ",I.Float,!0),this.registerOutput("xyzw",I.Vector4),this.registerOutput("xyz",I.Vector3),this.registerOutput("xy",I.Vector2),this.registerOutput("zw",I.Vector2),this.registerOutput("x",I.Float),this.registerOutput("y",I.Float),this.registerOutput("z",I.Float),this.registerOutput("w",I.Float)}getClassName(){return"VectorConverterBlock"}get xyzwIn(){return this._inputs[0]}get xyzIn(){return this._inputs[1]}get xyIn(){return this._inputs[2]}get zwIn(){return this._inputs[3]}get xIn(){return this._inputs[4]}get yIn(){return this._inputs[5]}get zIn(){return this._inputs[6]}get wIn(){return this._inputs[7]}get xyzwOut(){return this._outputs[0]}get xyzOut(){return this._outputs[1]}get xyOut(){return this._outputs[2]}get zwOut(){return this._outputs[3]}get xOut(){return this._outputs[4]}get yOut(){return this._outputs[5]}get zOut(){return this._outputs[6]}get wOut(){return this._outputs[7]}_inputRename(e){return e==="xyzw "?"xyzwIn":e==="xyz "?"xyzIn":e==="xy "?"xyIn":e==="zw "?"zwIn":e==="x "?"xIn":e==="y "?"yIn":e==="z "?"zIn":e==="w "?"wIn":e}_outputRename(e){switch(e){case"x":return"xOut";case"y":return"yOut";case"z":return"zOut";case"w":return"wOut";case"xy":return"xyOut";case"zw":return"zwOut";case"xyz":return"xyzOut";case"xyzw":return"xyzwOut";default:return e}}_buildBlock(e){super._buildBlock(e);const t=this.xIn,i=this.yIn,r=this.zIn,s=this.wIn,n=this.xyIn,o=this.zwIn,l=this.xyzIn,u=this.xyzwIn,c=this.xyzwOut,h=this.xyzOut,d=this.xyOut,f=this.zwOut,p=this.xOut,g=this.yOut,_=this.zOut,S=this.wOut,b=y=>{if(u.isConnected)return u.getConnectedValue(y);let T=0,v=0,E=0,R=0;if(t.isConnected&&(T=t.getConnectedValue(y)),i.isConnected&&(v=i.getConnectedValue(y)),r.isConnected&&(E=r.getConnectedValue(y)),s.isConnected&&(R=s.getConnectedValue(y)),n.isConnected){const O=n.getConnectedValue(y);O&&(T=O.x,v=O.y)}if(o.isConnected){const O=o.getConnectedValue(y);O&&(E=O.x,R=O.y)}if(l.isConnected){const O=l.getConnectedValue(y);O&&(T=O.x,v=O.y,E=O.z)}return new Ve(T,v,E,R)};c._storedFunction=y=>b(y),h._storedFunction=y=>{const T=b(y);return new m(T.x,T.y,T.z)},d._storedFunction=y=>{const T=b(y);return new Q(T.x,T.y)},f._storedFunction=y=>{const T=b(y);return new Q(T.z,T.w)},p._storedFunction=y=>b(y).x,g._storedFunction=y=>b(y).y,_._storedFunction=y=>b(y).z,S._storedFunction=y=>b(y).w}}B("BABYLON.VectorConverterBlock",ML);class AL extends be{constructor(e){super(e),this.registerInput("input",I.AutoDetect),this.registerOutput("output",I.BasedOnInput),this._inputs[0].excludedConnectionPointTypes.push(I.Float),this._inputs[0].excludedConnectionPointTypes.push(I.Matrix),this._inputs[0].excludedConnectionPointTypes.push(I.Geometry),this._inputs[0].excludedConnectionPointTypes.push(I.Texture),this._outputs[0]._typeConnectionSource=this._inputs[0]}getClassName(){return"NormalizeVectorBlock"}get input(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){if(super._buildBlock(e),this.output._storedFunction=null,!this.input.isConnected){this.output._storedValue=null;return}this.output._storedFunction=t=>this.input.getConnectedValue(t).normalize()}}B("BABYLON.NormalizeVectorBlock",AL);class LC extends be{constructor(e){super(e),this.evaluateContext=!0,this.registerInput("geometry",I.Geometry),this.registerInput("id",I.Int,!0,0),this.registerOutput("output",I.Geometry),this.id.acceptedConnectionPointTypes.push(I.Float)}getClassName(){return"SetMaterialIDBlock"}get geometry(){return this._inputs[0]}get id(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){if(!this.geometry.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}const t=i=>{const r=this.geometry.getConnectedValue(i);if(!r||!r.indices||!r.positions)return r;const s=new OM;return s.materialIndex=this.id.getConnectedValue(i)|0,s.indexStart=0,s.indexCount=r.indices.length,s.verticesStart=0,s.verticesCount=r.positions.length/3,r.materialInfos=[s],r};this.evaluateContext?this.output._storedFunction=t:(this.output._storedFunction=null,this.output._storedValue=t(e))}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),e.evaluateContext!==void 0&&(this.evaluateContext=e.evaluateContext)}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],LC.prototype,"evaluateContext",void 0);B("BABYLON.SetMaterialIDBlock",LC);class fl extends be{constructor(e){super(e),this._indexVector3=new m,this._currentControl=new m,this.evaluateContext=!0,this.resolutionX=3,this.resolutionY=3,this.resolutionZ=3,this.registerInput("geometry",I.Geometry),this.registerInput("controls",I.Vector3),this.registerOutput("output",I.Geometry)}getExecutionIndex(){return this._currentIndexX+this.resolutionX*(this._currentIndexY+this.resolutionY*this._currentIndexZ)}getExecutionLoopIndex(){return this.getExecutionIndex()}getExecutionFaceIndex(){return 0}getClassName(){return"LatticeBlock"}get geometry(){return this._inputs[0]}get controls(){return this._inputs[1]}get output(){return this._outputs[0]}getOverridePositionsContextualValue(){return this._indexVector3}getOverrideNormalsContextualValue(){return this._currentControl}_buildBlock(e){const t=i=>{if(i.pushExecutionContext(this),this._vertexData=this.geometry.getConnectedValue(i),this._vertexData&&(this._vertexData=this._vertexData.clone()),!this._vertexData||!this._vertexData.positions){i.restoreExecutionContext(),this.output._storedValue=null;return}const r=this._vertexData.positions,s=zo(r,0,r.length/3),n=s.maximum.subtract(s.minimum);for(this._lattice=new uL({resolutionX:this.resolutionX,resolutionY:this.resolutionY,resolutionZ:this.resolutionZ,size:n,position:s.minimum.add(n.scale(.5))}),this._currentIndexX=0;this._currentIndexX<this.resolutionX;this._currentIndexX++)for(this._currentIndexY=0;this._currentIndexY<this.resolutionY;this._currentIndexY++)for(this._currentIndexZ=0;this._currentIndexZ<this.resolutionZ;this._currentIndexZ++){this._indexVector3.set(this._currentIndexX,this._currentIndexY,this._currentIndexZ);const o=this._lattice.data[this._currentIndexX][this._currentIndexY][this._currentIndexZ];this._currentControl.copyFrom(o);const l=this.controls.getConnectedValue(i);l&&o.set(l.x,l.y,l.z)}return this._lattice.deform(r),i.restoreExecutionContext(),this._vertexData};this.evaluateContext?this.output._storedFunction=t:(this.output._storedFunction=null,this.output._storedValue=t(e))}_dumpPropertiesCode(){let e=super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`;return e+=`${this._codeVariableName}.resolutionX = ${this.resolutionX};
`,e+=`${this._codeVariableName}.resolutionY = ${this.resolutionY};
`,e+=`${this._codeVariableName}.resolutionZ = ${this.resolutionZ};
`,e}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e.resolutionX=this.resolutionX,e.resolutionY=this.resolutionY,e.resolutionZ=this.resolutionZ,e}_deserialize(e){super._deserialize(e),e.evaluateContext!==void 0&&(this.evaluateContext=e.evaluateContext,this.resolutionX=e.resolutionX,this.resolutionY=e.resolutionY,this.resolutionZ=e.resolutionZ)}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],fl.prototype,"evaluateContext",void 0);C([U("resolutionX",2,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0},min:1,max:10})],fl.prototype,"resolutionX",void 0);C([U("resolutionY",2,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0},min:1,max:10})],fl.prototype,"resolutionY",void 0);C([U("resolutionZ",2,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0},min:1,max:10})],fl.prototype,"resolutionZ",void 0);B("BABYLON.LatticeBlock",fl);var We;(function(a){a[a.Cos=0]="Cos",a[a.Sin=1]="Sin",a[a.Abs=2]="Abs",a[a.Exp=3]="Exp",a[a.Round=4]="Round",a[a.Floor=5]="Floor",a[a.Ceiling=6]="Ceiling",a[a.Sqrt=7]="Sqrt",a[a.Log=8]="Log",a[a.Tan=9]="Tan",a[a.ArcTan=10]="ArcTan",a[a.ArcCos=11]="ArcCos",a[a.ArcSin=12]="ArcSin",a[a.Sign=13]="Sign",a[a.Negate=14]="Negate",a[a.OneMinus=15]="OneMinus",a[a.Reciprocal=16]="Reciprocal",a[a.ToDegrees=17]="ToDegrees",a[a.ToRadians=18]="ToRadians",a[a.Fract=19]="Fract",a[a.Exp2=20]="Exp2"})(We||(We={}));class BC extends be{constructor(e){super(e),this.operation=We.Cos,this.registerInput("input",I.AutoDetect),this.registerOutput("output",I.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._inputs[0].excludedConnectionPointTypes.push(I.Matrix),this._inputs[0].excludedConnectionPointTypes.push(I.Geometry),this._inputs[0].excludedConnectionPointTypes.push(I.Texture)}getClassName(){return"GeometryTrigonometryBlock"}get input(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);let t=null;switch(this.operation){case We.Cos:{t=i=>Math.cos(i);break}case We.Sin:{t=i=>Math.sin(i);break}case We.Abs:{t=i=>Math.abs(i);break}case We.Exp:{t=i=>Math.exp(i);break}case We.Exp2:{t=i=>Math.pow(2,i);break}case We.Round:{t=i=>Math.round(i);break}case We.Floor:{t=i=>Math.floor(i);break}case We.Ceiling:{t=i=>Math.ceil(i);break}case We.Sqrt:{t=i=>Math.sqrt(i);break}case We.Log:{t=i=>Math.log(i);break}case We.Tan:{t=i=>Math.tan(i);break}case We.ArcTan:{t=i=>Math.atan(i);break}case We.ArcCos:{t=i=>Math.acos(i);break}case We.ArcSin:{t=i=>Math.asin(i);break}case We.Sign:{t=i=>Math.sign(i);break}case We.Negate:{t=i=>-i;break}case We.OneMinus:{t=i=>1-i;break}case We.Reciprocal:{t=i=>1/i;break}case We.ToRadians:{t=i=>i*Math.PI/180;break}case We.ToDegrees:{t=i=>i*180/Math.PI;break}case We.Fract:{t=i=>i>=0?i-Math.floor(i):i-Math.ceil(i);break}}if(!t){this.output._storedFunction=null,this.output._storedValue=null;return}switch(this.input.type){case I.Int:case I.Float:{this.output._storedFunction=i=>{const r=this.input.getConnectedValue(i);return t(r)};break}case I.Vector2:{this.output._storedFunction=i=>{const r=this.input.getConnectedValue(i);return new Q(t(r.x),t(r.y))};break}case I.Vector3:{this.output._storedFunction=i=>{const r=this.input.getConnectedValue(i);return new m(t(r.x),t(r.y),t(r.z))};break}case I.Vector4:{this.output._storedFunction=i=>{const r=this.input.getConnectedValue(i);return new Ve(t(r.x),t(r.y),t(r.z),t(r.w))};break}}return this}serialize(){const e=super.serialize();return e.operation=this.operation,e}_deserialize(e){super._deserialize(e),this.operation=e.operation}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.operation = BABYLON.GeometryTrigonometryBlockOperations.${We[this.operation]};
`}}C([U("Operation",4,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0},options:[{label:"Cos",value:We.Cos},{label:"Sin",value:We.Sin},{label:"Abs",value:We.Abs},{label:"Exp",value:We.Exp},{label:"Exp2",value:We.Exp2},{label:"Round",value:We.Round},{label:"Floor",value:We.Floor},{label:"Ceiling",value:We.Ceiling},{label:"Sqrt",value:We.Sqrt},{label:"Log",value:We.Log},{label:"Tan",value:We.Tan},{label:"ArcTan",value:We.ArcTan},{label:"ArcCos",value:We.ArcCos},{label:"ArcSin",value:We.ArcSin},{label:"Sign",value:We.Sign},{label:"Negate",value:We.Negate},{label:"OneMinus",value:We.OneMinus},{label:"Reciprocal",value:We.Reciprocal},{label:"ToDegrees",value:We.ToDegrees},{label:"ToRadians",value:We.ToRadians},{label:"Fract",value:We.Fract}]})],BC.prototype,"operation",void 0);B("BABYLON.GeometryTrigonometryBlock",BC);class VC extends be{constructor(e){super(e),this._rotationMatrix=new $,this._scalingMatrix=new $,this._translationMatrix=new $,this._scalingRotationMatrix=new $,this._pivotMatrix=new $,this._backPivotMatrix=new $,this._transformMatrix=new $,this.evaluateContext=!0,this.registerInput("value",I.AutoDetect),this.registerInput("matrix",I.Matrix,!0),this.registerInput("translation",I.Vector3,!0,m.Zero()),this.registerInput("rotation",I.Vector3,!0,m.Zero()),this.registerInput("scaling",I.Vector3,!0,m.One()),this.registerInput("pivot",I.Vector3,!0,m.Zero()),this.registerOutput("output",I.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._inputs[0].excludedConnectionPointTypes.push(I.Float),this._inputs[0].excludedConnectionPointTypes.push(I.Matrix),this._inputs[0].excludedConnectionPointTypes.push(I.Texture)}getClassName(){return"GeometryTransformBlock"}get value(){return this._inputs[0]}get matrix(){return this._inputs[1]}get translation(){return this._inputs[2]}get rotation(){return this._inputs[3]}get scaling(){return this._inputs[4]}get pivot(){return this._inputs[5]}get output(){return this._outputs[0]}_buildBlock(e){if(!this.value.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}const t=i=>{const r=this.value.getConnectedValue(i);if(!r)return null;let s;if(this.matrix.isConnected)s=this.matrix.getConnectedValue(i);else{const n=this.scaling.getConnectedValue(i)||m.OneReadOnly,o=this.rotation.getConnectedValue(i)||m.ZeroReadOnly,l=this.translation.getConnectedValue(i)||m.ZeroReadOnly,u=this.pivot.getConnectedValue(i)||m.ZeroReadOnly;$.TranslationToRef(-u.x,-u.y,-u.z,this._pivotMatrix),$.ScalingToRef(n.x,n.y,n.z,this._scalingMatrix),$.RotationYawPitchRollToRef(o.y,o.x,o.z,this._rotationMatrix),$.TranslationToRef(l.x+u.x,l.y+u.y,l.z+u.z,this._translationMatrix),this._pivotMatrix.multiplyToRef(this._scalingMatrix,this._backPivotMatrix),this._backPivotMatrix.multiplyToRef(this._rotationMatrix,this._scalingRotationMatrix),this._scalingRotationMatrix.multiplyToRef(this._translationMatrix,this._transformMatrix),s=this._transformMatrix}switch(this.value.type){case I.Geometry:{const n=r.clone();return n.transform(s),n}case I.Vector2:return Q.Transform(r,s);case I.Vector3:return m.TransformCoordinates(r,s);case I.Vector4:return Ve.TransformCoordinates(r,s)}return null};this.evaluateContext?this.output._storedFunction=t:(this.output._storedFunction=null,this.output._storedValue=t(e))}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),e.evaluateContext!==void 0&&(this.evaluateContext=e.evaluateContext)}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],VC.prototype,"evaluateContext",void 0);B("BABYLON.GeometryTransformBlock",VC);class DL extends be{constructor(e){super(e),this.registerInput("angle",I.Float,!0,0),this.registerOutput("matrix",I.Matrix)}getClassName(){return"RotationXBlock"}get angle(){return this._inputs[0]}get matrix(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e),this.matrix._storedFunction=t=>$.RotationX(this.angle.getConnectedValue(t))}}B("BABYLON.RotationXBlock",DL);class OL extends be{constructor(e){super(e),this.registerInput("angle",I.Float,!0,0),this.registerOutput("matrix",I.Matrix)}getClassName(){return"RotationYBlock"}get angle(){return this._inputs[0]}get matrix(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e),this.matrix._storedFunction=t=>$.RotationY(this.angle.getConnectedValue(t))}}B("BABYLON.RotationYBlock",OL);class wL extends be{constructor(e){super(e),this.registerInput("angle",I.Float,!0,0),this.registerOutput("matrix",I.Matrix)}getClassName(){return"RotationZBlock"}get angle(){return this._inputs[0]}get matrix(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e),this.matrix._storedFunction=t=>$.RotationZ(this.angle.getConnectedValue(t))}}B("BABYLON.RotationZBlock",wL);class NL extends be{constructor(e){super(e),this.registerInput("scale",I.Vector3,!1,m.One()),this.registerOutput("matrix",I.Matrix)}getClassName(){return"ScalingBlock"}get scale(){return this._inputs[0]}get matrix(){return this._outputs[0]}autoConfigure(){if(!this.scale.isConnected){const e=new Ft("Scale");e.value=new m(1,1,1),e.output.connectTo(this.scale)}}_buildBlock(e){super._buildBlock(e),this.matrix._storedFunction=t=>{const i=this.scale.getConnectedValue(t);return $.Scaling(i.x,i.y,i.z)}}}B("BABYLON.ScalingBlock",NL);class FL extends be{constructor(e){super(e),this.registerInput("source",I.Vector3,!0,m.Up()),this.registerInput("target",I.Vector3,!0,m.Left()),this.registerOutput("matrix",I.Matrix)}getClassName(){return"AlignBlock"}get source(){return this._inputs[0]}get target(){return this._inputs[1]}get matrix(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e),this.matrix._storedFunction=t=>{const i=this.source.getConnectedValue(t).clone(),r=this.target.getConnectedValue(t).clone(),s=new $;return i.normalize(),r.normalize(),$.RotationAlignToRef(i,r,s,!0),s}}}B("BABYLON.AlignBlock",FL);class LL extends be{constructor(e){super(e),this.registerInput("translation",I.Vector3,!1,m.Zero()),this.registerOutput("matrix",I.Matrix)}getClassName(){return"TranslationBlock"}get translation(){return this._inputs[0]}get matrix(){return this._outputs[0]}autoConfigure(){if(!this.translation.isConnected){const e=new Ft("Translation");e.value=new m(0,0,0),e.output.connectTo(this.translation)}}_buildBlock(e){super._buildBlock(e),this.matrix._storedFunction=t=>{const i=this.translation.getConnectedValue(t);return $.Translation(i.x,i.y,i.z)}}}B("BABYLON.TranslationBlock",LL);class j_ extends be{constructor(e){super(e),this._indexTranslation=null,this.evaluateContext=!0,this.removeDuplicatedPositions=!0,this.registerInput("geometry",I.Geometry),this.registerInput("instance",I.Geometry,!0),this.registerInput("density",I.Float,!0,1,0,1),this.registerInput("matrix",I.Matrix,!0),this.registerInput("offset",I.Vector3,!0,m.Zero()),this.registerInput("rotation",I.Vector3,!0,m.Zero()),this.registerInput("scaling",I.Vector3,!0,m.One()),this.scaling.acceptedConnectionPointTypes.push(I.Float),this.registerOutput("output",I.Geometry)}getInstanceIndex(){return this._currentLoopIndex}getExecutionIndex(){return this._indexTranslation?this._indexTranslation[this._currentIndex]:this._currentIndex}getExecutionLoopIndex(){return this._currentLoopIndex}getExecutionFaceIndex(){return 0}getClassName(){return"InstantiateOnVerticesBlock"}get geometry(){return this._inputs[0]}get instance(){return this._inputs[1]}get density(){return this._inputs[2]}get matrix(){return this._inputs[3]}get offset(){return this._inputs[4]}get rotation(){return this._inputs[5]}get scaling(){return this._inputs[6]}get output(){return this._outputs[0]}_buildBlock(e){const t=i=>{if(i.pushExecutionContext(this),i.pushInstancingContext(this),this._vertexData=this.geometry.getConnectedValue(i),i.pushGeometryContext(this._vertexData),!this._vertexData||!this._vertexData.positions||!this.instance.isConnected){i.restoreExecutionContext(),i.restoreInstancingContext(),i.restoreGeometryContext(),this.output._storedValue=null;return}let r=this._vertexData.positions.length/3;const s=[],n=new m,o=[];let l=this._vertexData.positions;if(this._currentLoopIndex=0,this.removeDuplicatedPositions){for(this._indexTranslation={},this._currentIndex=0;this._currentIndex<r;this._currentIndex++){const u=l[this._currentIndex*3],c=l[this._currentIndex*3+1],h=l[this._currentIndex*3+2];let d=!1;for(let f=0;f<o.length;f+=3)if(Math.abs(o[f]-u)<He&&Math.abs(o[f+1]-c)<He&&Math.abs(o[f+2]-h)<He){d=!0;break}d||(this._indexTranslation[o.length/3]=this._currentIndex,o.push(u,c,h))}l=o,r=l.length/3}else this._indexTranslation=null;for(this._currentIndex=0;this._currentIndex<r;this._currentIndex++){const u=this.instance.getConnectedValue(i);if(!u||!u.positions||u.positions.length===0)continue;const c=this.density.getConnectedValue(i);if(c<1&&Math.random()>c)continue;n.fromArray(l,this._currentIndex*3);const h=u.clone();if(this.matrix.isConnected){const d=this.matrix.getConnectedValue(i);i._instantiateWithPositionAndMatrix(h,n,d,s)}else{const d=i.adaptInput(this.offset,I.Vector3,m.ZeroReadOnly),f=i.adaptInput(this.scaling,I.Vector3,m.OneReadOnly),p=this.rotation.getConnectedValue(i)||m.ZeroReadOnly;n.addInPlace(d),i._instantiate(h,n,p,f,s)}this._currentLoopIndex++}if(i.restoreGeometryContext(),i.restoreExecutionContext(),i.restoreInstancingContext(),s.length)if(s.length===1)this._vertexData=s[0];else{const u=s.splice(0,1)[0];this._vertexData=u.merge(s,!0,!1,!0,!0)}else return null;return this._vertexData};this.evaluateContext?this.output._storedFunction=t:(this.output._storedFunction=null,this.output._storedValue=t(e))}_dumpPropertiesCode(){let e=super._dumpPropertiesCode()+`${this._codeVariableName}.removeDuplicatedPositions = ${this.removeDuplicatedPositions?"true":"false"};
`;return e+=`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`,e}serialize(){const e=super.serialize();return e.removeDuplicatedPositions=this.removeDuplicatedPositions,e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),this.removeDuplicatedPositions=e.removeDuplicatedPositions,e.evaluateContext!==void 0&&(this.evaluateContext=e.evaluateContext)}}C([U("Evaluate context",0,"ADVANCED",{notifiers:{rebuild:!0}})],j_.prototype,"evaluateContext",void 0);C([U("Remove duplicated positions",0,"ADVANCED",{notifiers:{update:!0}})],j_.prototype,"removeDuplicatedPositions",void 0);B("BABYLON.InstantiateOnVerticesBlock",j_);class kC extends be{constructor(e){super(e),this._currentPosition=new m,this._currentUV=new Q,this._vertex0=new m,this._vertex1=new m,this._vertex2=new m,this._tempVector0=new m,this._tempVector1=new m,this._uv0=new Q,this._uv1=new Q,this._uv2=new Q,this.evaluateContext=!0,this.registerInput("geometry",I.Geometry),this.registerInput("instance",I.Geometry,!0),this.registerInput("count",I.Int,!0,256),this.registerInput("matrix",I.Matrix,!0),this.registerInput("offset",I.Vector3,!0,m.Zero()),this.registerInput("rotation",I.Vector3,!0,m.Zero()),this.registerInput("scaling",I.Vector3,!0,m.One()),this.scaling.acceptedConnectionPointTypes.push(I.Float),this.registerOutput("output",I.Geometry)}getInstanceIndex(){return this._currentLoopIndex}getExecutionIndex(){return 0}getExecutionFaceIndex(){return this._currentFaceIndex}getExecutionLoopIndex(){return this._currentLoopIndex}getOverridePositionsContextualValue(){return this._currentPosition}getOverrideNormalsContextualValue(){return this._vertex1.subtractToRef(this._vertex0,this._tempVector0),this._vertex2.subtractToRef(this._vertex1,this._tempVector1),this._tempVector0.normalize(),this._tempVector1.normalize(),m.Cross(this._tempVector1,this._tempVector0)}getOverrideUVs1ContextualValue(){return this._currentUV}getClassName(){return"InstantiateOnFacesBlock"}get geometry(){return this._inputs[0]}get instance(){return this._inputs[1]}get count(){return this._inputs[2]}get matrix(){return this._inputs[3]}get offset(){return this._inputs[4]}get rotation(){return this._inputs[5]}get scaling(){return this._inputs[6]}get output(){return this._outputs[0]}_buildBlock(e){const t=i=>{if(i.pushExecutionContext(this),i.pushInstancingContext(this),this._vertexData=this.geometry.getConnectedValue(i),i.pushGeometryContext(this._vertexData),!this._vertexData||!this._vertexData.positions||!this._vertexData.indices||!this.instance.isConnected){i.restoreExecutionContext(),i.restoreInstancingContext(),i.restoreGeometryContext(),this.output._storedValue=null;return}let r=null;const s=this.count.getConnectedValue(i),n=this._vertexData.indices.length/3,o=s/n;let l=0;const u=[];let c=0;for(this._currentLoopIndex=0,this._currentFaceIndex=0;this._currentFaceIndex<n;this._currentFaceIndex++){l+=o;const h=(l|0)-c;if(h<1)continue;const d=this._vertexData.indices[this._currentFaceIndex*3],f=this._vertexData.indices[this._currentFaceIndex*3+1],p=this._vertexData.indices[this._currentFaceIndex*3+2];this._vertex0.fromArray(this._vertexData.positions,d*3),this._vertex1.fromArray(this._vertexData.positions,f*3),this._vertex2.fromArray(this._vertexData.positions,p*3),this._vertexData.uvs&&(this._uv0.fromArray(this._vertexData.uvs,d*2),this._uv1.fromArray(this._vertexData.uvs,f*2),this._uv2.fromArray(this._vertexData.uvs,p*2));for(let g=0;g<h&&!(c>=s);g++){let _=Math.random(),S=Math.random();if(_>S){const E=_;_=S,S=E}const b=_,y=S-_,T=1-b-y;if(this._currentPosition.set(b*this._vertex0.x+y*this._vertex1.x+T*this._vertex2.x,b*this._vertex0.y+y*this._vertex1.y+T*this._vertex2.y,b*this._vertex0.z+y*this._vertex1.z+T*this._vertex2.z),this._vertexData.uvs&&this._currentUV.set(b*this._uv0.x+y*this._uv1.x+T*this._uv2.x,b*this._uv0.y+y*this._uv1.y+T*this._uv2.y),r=this.instance.getConnectedValue(i),!r||!r.positions||r.positions.length===0){l-=o;continue}const v=r.clone();if(this.matrix.isConnected){const E=this.matrix.getConnectedValue(i);i._instantiateWithPositionAndMatrix(v,this._currentPosition,E,u)}else{const E=i.adaptInput(this.offset,I.Vector3,m.ZeroReadOnly),R=i.adaptInput(this.scaling,I.Vector3,m.OneReadOnly),O=this.rotation.getConnectedValue(i)||m.ZeroReadOnly;this._currentPosition.addInPlace(E),i._instantiate(v,this._currentPosition,O,R,u)}c++,this._currentLoopIndex++}}if(u.length)if(u.length===1)this._vertexData=u[0];else{const h=u.splice(0,1)[0];this._vertexData=h.merge(u,!0,!1,!0,!0)}return i.restoreExecutionContext(),i.restoreInstancingContext(),i.restoreGeometryContext(),this._vertexData};this.evaluateContext?this.output._storedFunction=t:(this.output._storedFunction=null,this.output._storedValue=t(e))}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),e.evaluateContext!==void 0&&(this.evaluateContext=e.evaluateContext)}}C([U("Evaluate context",0,"ADVANCED",{notifiers:{rebuild:!0}})],kC.prototype,"evaluateContext",void 0);B("BABYLON.InstantiateOnFacesBlock",kC);class Y_ extends be{constructor(e){super(e),this._currentPosition=new m,this._vertex0=new m,this._vertex1=new m,this._vertex2=new m,this.evaluateContext=!0,this.gridMode=!1,this.registerInput("geometry",I.Geometry),this.registerInput("instance",I.Geometry,!0),this.registerInput("count",I.Int,!0,256),this.registerInput("matrix",I.Matrix,!0),this.registerInput("offset",I.Vector3,!0,m.Zero()),this.registerInput("rotation",I.Vector3,!0,m.Zero()),this.registerInput("scaling",I.Vector3,!0,m.One()),this.registerInput("gridSize",I.Int,!0,10),this.scaling.acceptedConnectionPointTypes.push(I.Float),this.registerOutput("output",I.Geometry)}getInstanceIndex(){return this._currentLoopIndex}getExecutionIndex(){return 0}getExecutionFaceIndex(){return 0}getExecutionLoopIndex(){return this._currentLoopIndex}getOverridePositionsContextualValue(){return this._currentPosition}getClassName(){return"InstantiateOnVolumeBlock"}get geometry(){return this._inputs[0]}get instance(){return this._inputs[1]}get count(){return this._inputs[2]}get matrix(){return this._inputs[3]}get offset(){return this._inputs[4]}get rotation(){return this._inputs[5]}get scaling(){return this._inputs[6]}get gridSize(){return this._inputs[6]}get output(){return this._outputs[0]}_getValueOnGrid(e,t,i,r){const s=(r-i)/t;return i+s/2+e*s}_getIndexinGrid(e,t,i,r){return e+t*r+i*r*r}_buildBlock(e){const t=i=>{if(i.pushExecutionContext(this),i.pushInstancingContext(this),this._vertexData=this.geometry.getConnectedValue(i),i.pushGeometryContext(this._vertexData),!this._vertexData||!this._vertexData.positions||!this._vertexData.indices||!this.instance.isConnected){i.restoreExecutionContext(),i.restoreInstancingContext(),i.restoreGeometryContext(),this.output._storedValue=null;return}let r=null;const s=this.count.getConnectedValue(i),n=[],o=zo(this._vertexData.positions,0,this._vertexData.positions.length/3),l=o.minimum,u=o.maximum,c=new m(.5,.8,.2),h=this._vertexData.indices.length/3,d=this.gridSize.getConnectedValue(i);this._currentLoopIndex=0;let f;if(this.gridMode){f=[];for(let p=0;p<d*d*d;p++)f[p]=!1}for(let p=0;p<s;p++){if(this.gridMode){let b=Math.floor(Math.random()*d),y=Math.floor(Math.random()*d),T=Math.floor(Math.random()*d),v=this._getIndexinGrid(b,y,T,d);if(f[v]){let E=!1;for(let R=0;R<d*d*d;R++)if(!f[R]){T=Math.floor(R/(d*d)),y=Math.floor((R-T*d*d)/d),b=R-T*d*d-y*d,v=this._getIndexinGrid(b,y,T,d),E=!0;break}if(!E)break}if(!f[v]){const E=this._getValueOnGrid(b,d,l.x,u.x),R=this._getValueOnGrid(y,d,l.y,u.y),O=this._getValueOnGrid(T,d,l.z,u.z);this._currentPosition.set(E,R,O),f[v]=!0}}else this._currentPosition.set(Math.random()*(u.x-l.x)+l.x,Math.random()*(u.y-l.y)+l.y,Math.random()*(u.z-l.z)+l.z);const g=new Zt(this._currentPosition,c);let _=0;for(let b=0;b<h;b++){this._vertex0.fromArray(this._vertexData.positions,this._vertexData.indices[b*3]*3),this._vertex1.fromArray(this._vertexData.positions,this._vertexData.indices[b*3+1]*3),this._vertex2.fromArray(this._vertexData.positions,this._vertexData.indices[b*3+2]*3);const y=g.intersectsTriangle(this._vertex0,this._vertex1,this._vertex2);y&&y.distance>0&&_++}if(_%2===0){p--;continue}if(r=this.instance.getConnectedValue(i),!r||!r.positions||r.positions.length===0)continue;const S=r.clone();if(this.matrix.isConnected){const b=this.matrix.getConnectedValue(i);i._instantiateWithPositionAndMatrix(S,this._currentPosition,b,n)}else{const b=i.adaptInput(this.offset,I.Vector3,m.ZeroReadOnly),y=i.adaptInput(this.scaling,I.Vector3,m.OneReadOnly),T=this.rotation.getConnectedValue(i)||m.ZeroReadOnly;this._currentPosition.addInPlace(b),i._instantiate(S,this._currentPosition,T,y,n)}this._currentLoopIndex++}if(n.length)if(n.length===1)this._vertexData=n[0];else{const p=n.splice(0,1)[0];this._vertexData=p.merge(n,!0,!1,!0,!0)}return i.restoreGeometryContext(),i.restoreExecutionContext(),i.restoreInstancingContext(),this._vertexData};this.evaluateContext?this.output._storedFunction=t:(this.output._storedFunction=null,this.output._storedValue=t(e))}_dumpPropertiesCode(){let e=super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`;return e+=`${this._codeVariableName}.gridMode = ${this.gridMode?"true":"false"};
`,e}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e.gridMode=this.gridMode,e}_deserialize(e){super._deserialize(e),e.evaluateContext!==void 0&&(this.evaluateContext=e.evaluateContext),e.gridMode!==void 0&&(this.gridMode=e.gridMode)}}C([U("Evaluate context",0,"ADVANCED",{notifiers:{rebuild:!0}})],Y_.prototype,"evaluateContext",void 0);C([U("Grid mode",0,"MODES",{notifiers:{rebuild:!0}})],Y_.prototype,"gridMode",void 0);B("BABYLON.InstantiateOnVolumeBlock",Y_);class rc extends be{constructor(e){super(e),this.evaluateContext=!0,this.registerInput("instance",I.Geometry,!0),this.registerInput("count",I.Int,!0,1),this.registerOutput("output",I.Geometry)}getInstanceIndex(){return this._currentIndex}getExecutionIndex(){return this._currentIndex}getExecutionLoopIndex(){return this._currentIndex}getExecutionFaceIndex(){return 0}getClassName(){return"InstantiateBaseBlock"}get instance(){return this._inputs[0]}get count(){return this._inputs[1]}get output(){return this._outputs[0]}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e}_deserialize(e){super._deserialize(e),e.evaluateContext!==void 0&&(this.evaluateContext=e.evaluateContext)}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],rc.prototype,"evaluateContext",void 0);class BL extends rc{constructor(e){super(e),this.registerInput("matrix",I.Matrix,!0),this.registerInput("position",I.Vector3,!0,m.Zero()),this.registerInput("rotation",I.Vector3,!0,m.Zero()),this.registerInput("scaling",I.Vector3,!0,m.One()),this.scaling.acceptedConnectionPointTypes.push(I.Float)}getInstanceIndex(){return this._currentIndex}getExecutionIndex(){return this._currentIndex}getExecutionLoopIndex(){return this._currentIndex}getExecutionFaceIndex(){return 0}getClassName(){return"InstantiateBlock"}get matrix(){return this._inputs[2]}get position(){return this._inputs[3]}get rotation(){return this._inputs[4]}get scaling(){return this._inputs[5]}_buildBlock(e){const t=i=>{i.pushExecutionContext(this),i.pushInstancingContext(this);const r=this.count.getConnectedValue(i),s=[];for(this._currentIndex=0;this._currentIndex<r;this._currentIndex++){const n=this.instance.getConnectedValue(i);if(!n||!n.positions||n.positions.length===0)continue;const o=n.clone();if(this.matrix.isConnected){const l=this.matrix.getConnectedValue(i);i._instantiateWithMatrix(o,l,s)}else{const l=this.position.getConnectedValue(i)||m.ZeroReadOnly,u=i.adaptInput(this.scaling,I.Vector3,m.OneReadOnly),c=this.rotation.getConnectedValue(i)||m.ZeroReadOnly;i._instantiate(o,l,c,u,s)}}if(s.length)if(s.length===1)this._vertexData=s[0];else{const n=s.splice(0,1)[0];this._vertexData=n.merge(s,!0,!1,!0,!0)}return i.restoreExecutionContext(),i.restoreInstancingContext(),this._vertexData};this.evaluateContext?this.output._storedFunction=t:(this.output._storedFunction=null,this.output._storedValue=t(e))}}B("BABYLON.InstantiateBlock",BL);class VL extends rc{constructor(e){super(e),this.registerInput("direction",I.Vector3,!0,new m(1,0,0)),this.registerInput("rotation",I.Vector3,!0,new m(0,0,0)),this.registerInput("scaling",I.Vector3,!0,new m(0,0,0)),this.scaling.acceptedConnectionPointTypes.push(I.Float)}getClassName(){return"InstantiateLinearBlock"}get direction(){return this._inputs[2]}get rotation(){return this._inputs[3]}get scaling(){return this._inputs[4]}_buildBlock(e){const t=i=>{i.pushExecutionContext(this),i.pushInstancingContext(this);const r=this.count.getConnectedValue(i),s=[],n=$.Identity(),o=m.Zero(),l=m.Zero(),u=m.Zero();for(this._currentIndex=0;this._currentIndex<r;this._currentIndex++){const c=this.instance.getConnectedValue(i);if(!c||!c.positions||c.positions.length===0)continue;const h=c.clone(),d=this.direction.getConnectedValue(i),f=this.rotation.getConnectedValue(i),p=i.adaptInput(this.scaling,I.Vector3,m.OneReadOnly);o.copyFrom(d.clone().scale(this._currentIndex)),l.copyFrom(f.clone().scale(this._currentIndex)),u.copyFrom(p.clone().scale(this._currentIndex)),u.addInPlaceFromFloats(1,1,1),$.ComposeToRef(u,re.FromEulerAngles(l.x,l.y,l.z),o,n),i._instantiateWithMatrix(h,n,s)}if(s.length)if(s.length===1)this._vertexData=s[0];else{const c=s.splice(0,1)[0];this._vertexData=c.merge(s,!0,!1,!0,!0)}return i.restoreExecutionContext(),i.restoreInstancingContext(),this._vertexData};this.evaluateContext?this.output._storedFunction=t:(this.output._storedFunction=null,this.output._storedValue=t(e))}}B("BABYLON.InstantiateLinearBlock",VL);class kL extends rc{constructor(e){super(e),this.registerInput("radius",I.Int,!0,0,0),this.registerInput("angleStart",I.Float,!0,0),this.registerInput("angleEnd",I.Float,!0,Math.PI*2),this.registerInput("transform",I.Vector3,!0,new m(0,0,0)),this.registerInput("rotation",I.Vector3,!0,new m(0,0,0)),this.registerInput("scaling",I.Vector3,!0,new m(0,0,0)),this.scaling.acceptedConnectionPointTypes.push(I.Float)}getClassName(){return"InstantiateRadialBlock"}get radius(){return this._inputs[2]}get angleStart(){return this._inputs[3]}get angleEnd(){return this._inputs[4]}get transform(){return this._inputs[5]}get rotation(){return this._inputs[6]}get scaling(){return this._inputs[7]}_buildBlock(e){const t=i=>{i.pushExecutionContext(this),i.pushInstancingContext(this);const r=this.count.getConnectedValue(i),s=[],n=$.Identity(),o=$.Identity(),l=$.Identity(),u=m.Zero(),c=m.Zero(),h=m.Zero();for(this._currentIndex=0;this._currentIndex<r;this._currentIndex++){const d=this.instance.getConnectedValue(i);if(!d||!d.positions||d.positions.length===0)continue;const f=d.clone(),p=this.radius.getConnectedValue(i),g=this.angleStart.getConnectedValue(i),_=this.angleEnd.getConnectedValue(i),S=this.transform.getConnectedValue(i),b=this.rotation.getConnectedValue(i),y=i.adaptInput(this.scaling,I.Vector3,m.OneReadOnly),v=(_-g)/r,E=g+v*this._currentIndex,R=re.FromEulerAngles(0,E,0);u.copyFrom(S.clone().scale(this._currentIndex)),c.copyFrom(b.clone().scale(this._currentIndex)),h.copyFrom(y.clone().scale(this._currentIndex)),h.addInPlaceFromFloats(1,1,1),$.RotationYawPitchRollToRef(c.y,c.x,c.z,n),o.setTranslationFromFloats(0,0,p),$.ComposeToRef(h,R,u,l),n.multiplyToRef(o,o),o.multiplyToRef(l,l),i._instantiateWithMatrix(f,l,s)}if(s.length)if(s.length===1)this._vertexData=s[0];else{const d=s.splice(0,1)[0];this._vertexData=d.merge(s,!0,!1,!0,!0)}return i.restoreExecutionContext(),i.restoreInstancingContext(),this._vertexData};this.evaluateContext?this.output._storedFunction=t:(this.output._storedFunction=null,this.output._storedValue=t(e))}}B("BABYLON.InstantiateRadialBlock",kL);class zL extends be{constructor(e){super(e),this.registerInput("float ",I.Float,!0),this.registerInput("int ",I.Int,!0),this.registerOutput("float",I.Float),this.registerOutput("int",I.Int)}getClassName(){return"IntFloatConverterBlock"}get floatIn(){return this._inputs[0]}get intIn(){return this._inputs[1]}get floatOut(){return this._outputs[0]}get intOut(){return this._outputs[1]}_inputRename(e){return e==="float "?"floatIn":e==="int "?"intIn":e}_buildBlock(){this.floatOut._storedFunction=e=>this.floatIn.isConnected?this.floatIn.getConnectedValue(e):this.intIn.isConnected?this.intIn.getConnectedValue(e):0,this.intOut._storedFunction=e=>this.floatIn.isConnected?Math.floor(this.floatIn.getConnectedValue(e)):this.intIn.isConnected?Math.floor(this.intIn.getConnectedValue(e)):0}}B("BABYLON.IntFloatConverterBlock",zL);class UL extends be{constructor(e){super(e),this.log=[],this._isDebug=!0,this.registerInput("input",I.AutoDetect),this.registerOutput("output",I.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._inputs[0].excludedConnectionPointTypes.push(I.Geometry),this._inputs[0].excludedConnectionPointTypes.push(I.Texture)}get buildExecutionTime(){return-1}getClassName(){return"DebugBlock"}get input(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){if(!this.input.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}this.log=[];const t=i=>{const r=this.input.getConnectedValue(i);if(r==null)return this.log.push(["null",""]),r;switch(this.input.type){case I.Vector2:this.log.push([Q2(r,4),r.toString()]);break;case I.Vector3:this.log.push([K2(r,4),r.toString()]);break;case I.Vector4:this.log.push([J2(r,4),r.toString()]);break;default:this.log.push([r.toString(),r.toString()]);break}return r};this.output.isConnected?this.output._storedFunction=t:this.output._storedValue=t(e)}}B("BABYLON.DebugBlock",UL);class GL extends be{constructor(e){super(e),this.registerInput("geometry",I.Geometry),this.registerOutput("output",I.Geometry),this.registerOutput("id",I.Int),this.registerOutput("collectionId",I.Int),this.registerOutput("verticesCount",I.Int),this.registerOutput("facesCount",I.Int)}getClassName(){return"GeometryInfoBlock"}get geometry(){return this._inputs[0]}get output(){return this._outputs[0]}get id(){return this._outputs[1]}get collectionId(){return this._outputs[2]}get verticesCount(){return this._outputs[3]}get facesCount(){return this._outputs[4]}_buildBlock(){if(!this.geometry.isConnected){this.id._storedValue=0,this.collectionId._storedValue=0,this.verticesCount._storedValue=0,this.facesCount._storedValue=0,this.output._storedValue=0,this.id._storedFunction=null,this.collectionId._storedFunction=null,this.verticesCount._storedFunction=null,this.facesCount._storedFunction=null,this.output._storedFunction=null;return}this.output._storedFunction=e=>(this._currentVertexData=this.geometry.getConnectedValue(e),this._currentVertexData),this.id._storedFunction=e=>(this._currentVertexData=this._currentVertexData||this.geometry.getConnectedValue(e),this._currentVertexData.uniqueId),this.collectionId._storedFunction=e=>(this._currentVertexData=this._currentVertexData||this.geometry.getConnectedValue(e),this._currentVertexData.metadata?this._currentVertexData.metadata.collectionId:0),this.verticesCount._storedFunction=e=>(this._currentVertexData=this._currentVertexData||this.geometry.getConnectedValue(e),this._currentVertexData.positions?this._currentVertexData.positions.length/3:0),this.facesCount._storedFunction=e=>(this._currentVertexData=this._currentVertexData||this.geometry.getConnectedValue(e),this._currentVertexData.indices?this._currentVertexData.indices.length/3:0)}}B("BABYLON.GeometryInfoBlock",GL);var Kr;(function(a){a[a.Spherical=0]="Spherical",a[a.Cylindrical=1]="Cylindrical",a[a.Cubic=2]="Cubic"})(Kr||(Kr={}));class zC extends be{constructor(e){super(e),this.mapping=Kr.Spherical,this.registerInput("position",I.Vector3),this.registerInput("normal",I.Vector3),this.registerInput("center",I.Vector3,!0,m.Zero()),this.registerOutput("uv",I.Vector2)}getClassName(){return"MappingBlock"}get position(){return this._inputs[0]}get normal(){return this._inputs[1]}get center(){return this._inputs[2]}get uv(){return this._outputs[0]}_buildBlock(){if(!this.position.isConnected){this.uv._storedFunction=null,this.uv._storedValue=null;return}const e=m.Zero(),t=i=>{const r=this.position.getConnectedValue(i)||m.Zero(),s=this.normal.getConnectedValue(i)||m.Zero(),n=this.center.getConnectedValue(i),o=Q.Zero();switch(this.mapping){case Kr.Spherical:{r.subtractToRef(n,e);const l=e.length();l>0&&(o.x=Math.acos(e.y/l)/Math.PI,(e.x!==0||e.z!==0)&&(o.y=Math.atan2(e.x,e.z)/(Math.PI*2)));break}case Kr.Cylindrical:{r.subtractToRef(n,e);const l=e.length();l>0&&(o.x=Math.atan2(e.x/l,e.z/l)/(Math.PI*2),o.y=(e.y+1)/2);break}case Kr.Cubic:{const l=Math.abs(s.x),u=Math.abs(s.y),c=Math.abs(s.z),h=Math.max(Math.abs(r.x),Math.abs(r.y),Math.abs(r.z));let d=0,f=0;l>=u&&l>=c?(d=r.y/h-n.y,f=r.z/h-n.z):u>=l&&u>=c?(d=r.x/h-n.x,f=r.z/h-n.z):(d=r.x/h-n.x,f=r.y/h-n.y),o.x=(d+1)/2,o.y=(f+1)/2}}return o};this.uv._storedFunction=i=>t(i)}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.mapping = BABYLON.MappingTypes.${Kr[this.mapping]};
`}serialize(){const e=super.serialize();return e.mapping=this.mapping,e}_deserialize(e){super._deserialize(e),this.mapping=e.mapping}}C([U("Mapping",4,"ADVANCED",{notifiers:{rebuild:!0},embedded:!0,options:[{label:"Spherical",value:Kr.Spherical},{label:"Cylindrical",value:Kr.Cylindrical},{label:"Cubic",value:Kr.Cubic}]})],zC.prototype,"mapping",void 0);B("BABYLON.MappingBlock",zC);class WL extends be{constructor(e){super(e),this.registerInput("matrix0",I.Matrix),this.registerInput("matrix1",I.Matrix),this.registerOutput("output",I.Matrix)}getClassName(){return"MatrixComposeBlock"}get matrix0(){return this._inputs[0]}get matrix1(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(){this.output._storedFunction=e=>{if(!this.matrix0.isConnected||!this.matrix1.isConnected)return null;const t=this.matrix0.getConnectedValue(e),i=this.matrix1.getConnectedValue(e);return!t||!i?null:t.multiply(i)}}}B("BABYLON.MatrixComposeBlock",WL);class $L extends be{get endpoints(){return this._endpoints}constructor(e){super(e),this._endpoints=[],this._isTeleportIn=!0,this.registerInput("input",I.AutoDetect)}getClassName(){return"TeleportInBlock"}get input(){return this._inputs[0]}_dumpCode(e,t){let i=super._dumpCode(e,t);for(const r of this.endpoints)t.indexOf(r)===-1&&(i+=r._dumpCode(e,t));return i}isAnAncestorOfType(e){if(this.getClassName()===e)return!0;for(const t of this.endpoints)if(t.isAnAncestorOfType(e))return!0;return!1}isAnAncestorOf(e){for(const t of this.endpoints)if(t===e||t.isAnAncestorOf(e))return!0;return!1}getDescendantOfPredicate(e){if(e(this))return this;for(const t of this.endpoints){const i=t.getDescendantOfPredicate(e);if(i)return i}return null}attachToEndpoint(e){e.detach(),this._endpoints.push(e),e._entryPoint=this,e._outputs[0]._typeConnectionSource=this._inputs[0],e._tempEntryPointUniqueId=null,e.name="> "+this.name}detachFromEndpoint(e){const t=this._endpoints.indexOf(e);t!==-1&&(this._endpoints.splice(t,1),e._outputs[0]._typeConnectionSource=null,e._entryPoint=null)}_buildBlock(){for(const e of this._endpoints)e.output._storedFunction=t=>this.input.getConnectedValue(t)}}B("BABYLON.TeleportInBlock",$L);class HL extends be{constructor(e){super(e),this._entryPoint=null,this._tempEntryPointUniqueId=null,this._isTeleportOut=!0,this.registerOutput("output",I.BasedOnInput)}get entryPoint(){return this._entryPoint}getClassName(){return"TeleportOutBlock"}get output(){return this._outputs[0]}detach(){this._entryPoint&&this._entryPoint.detachFromEndpoint(this)}_buildBlock(){}_customBuildStep(e){this.entryPoint&&this.entryPoint.build(e)}_dumpCode(e,t){let i="";return this.entryPoint&&t.indexOf(this.entryPoint)===-1&&(i+=this.entryPoint._dumpCode(e,t)),i+super._dumpCode(e,t)}_dumpCodeForOutputConnections(e){let t=super._dumpCodeForOutputConnections(e);return this.entryPoint&&(t+=this.entryPoint._dumpCodeForOutputConnections(e)),t}clone(){const e=super.clone();return this.entryPoint&&this.entryPoint.attachToEndpoint(e),e}_dumpPropertiesCode(){let e=super._dumpPropertiesCode();return this.entryPoint&&(e+=`${this.entryPoint._codeVariableName}.attachToEndpoint(${this._codeVariableName});
`),e}serialize(){var t;const e=super.serialize();return e.entryPoint=((t=this.entryPoint)==null?void 0:t.uniqueId)??"",e}_deserialize(e){super._deserialize(e),this._tempEntryPointUniqueId=e.entryPoint}}B("BABYLON.TeleportOutBlock",HL);class UC extends be{get textureData(){return this._data}get textureWidth(){return this._width}get textureHeight(){return this._height}constructor(e){super(e),this._data=null,this.serializedCachedData=!1,this.registerOutput("texture",I.Texture)}getClassName(){return"GeometryTextureBlock"}get texture(){return this._outputs[0]}_prepareImgToLoadAsync(e){return new Promise((t,i)=>{const r=new Image,s=document.createElement("canvas"),n=s.getContext("2d");r.onload=()=>{s.width=r.width,s.height=r.height,n.drawImage(r,0,0);const l=n.getImageData(0,0,r.width,r.height).data,u=new Float32Array(l.length);for(let c=0;c<l.length;c++)u[c]=l[c]/255;this._data=u,this._width=r.width,this._height=r.height,t()},r.onerror=()=>{this._data=null,i()},r.src=e})}cleanData(){this._data=null}loadTextureFromFileAsync(e){return this._prepareImgToLoadAsync(URL.createObjectURL(e))}loadTextureFromUrlAsync(e){return this._prepareImgToLoadAsync(e)}extractFromTextureAsync(e){return new Promise((t,i)=>{if(!e.isReady()){e.onLoadObservable.addOnce(()=>this.extractFromTextureAsync(e).then(t).catch(i));return}const r=e.getSize();wM.GetTextureDataAsync(e,r.width,r.height).then(async s=>{const n=new Float32Array(s.length);for(let o=0;o<s.length;o++)n[o]=s[o]/255;this._data=n,this._width=r.width,this._height=r.height,t()}).catch(i)})}_buildBlock(){if(!this._data){this.texture._storedValue=null;return}const e={data:this._data,width:this._width,height:this._height};this.texture._storedValue=e}serialize(){const e=super.serialize();return e.width=this._width,e.height=this._height,e.serializedCachedData=this.serializedCachedData,this._data&&this.serializedCachedData&&(e.data=Array.from(this._data)),e}_deserialize(e){super._deserialize(e),this._width=e.width,this._height=e.height,e.data?(this._data=new Float32Array(e.data),this.serializedCachedData=!0):this.serializedCachedData=!!e.serializedCachedData}}C([U("Serialize cached data",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],UC.prototype,"serializedCachedData",void 0);B("BABYLON.GeometryTextureBlock",UC);class GC extends be{constructor(e){super(e),this.clampCoordinates=!0,this.registerInput("texture",I.Texture),this.registerInput("coordinates",I.Vector2),this.registerOutput("rgba",I.Vector4),this.registerOutput("rgb",I.Vector3),this.registerOutput("r",I.Float),this.registerOutput("g",I.Float),this.registerOutput("b",I.Float),this.registerOutput("a",I.Float)}getClassName(){return"GeometryTextureFetchBlock"}get texture(){return this.inputs[0]}get coordinates(){return this.inputs[1]}get rgba(){return this._outputs[0]}get rgb(){return this._outputs[1]}get r(){return this._outputs[2]}get g(){return this._outputs[3]}get b(){return this._outputs[4]}get a(){return this._outputs[5]}_repeatClamp(e){return e>=0?e%1:1-Math.abs(e)%1}_buildBlock(){const e=t=>{const i=this.texture.getConnectedValue(t);if(!i||!i.data)return null;const r=this.coordinates.getConnectedValue(t);if(!r)return null;const s=this.clampCoordinates?Math.max(0,Math.min(r.x,1)):this._repeatClamp(r.x),n=this.clampCoordinates?Math.max(0,Math.min(r.y,1)):this._repeatClamp(r.y),o=Math.floor(s*(i.width-1)),l=Math.floor(n*(i.height-1)),u=o+i.width*l;return Ve.FromArray(i.data,u*4)};this.rgba._storedFunction=t=>e(t),this.rgb._storedFunction=t=>{const i=e(t);return i?i.toVector3():null},this.r._storedFunction=t=>{const i=e(t);return i?i.x:null},this.g._storedFunction=t=>{const i=e(t);return i?i.y:null},this.b._storedFunction=t=>{const i=e(t);return i?i.z:null},this.a._storedFunction=t=>{const i=e(t);return i?i.w:null}}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.clampCoordinates = ${this.clampCoordinates};
`}serialize(){const e=super.serialize();return e.clampCoordinates=this.clampCoordinates,e}_deserialize(e){super._deserialize(e),this.clampCoordinates=e.clampCoordinates}}C([U("Clamp Coordinates",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],GC.prototype,"clampCoordinates",void 0);B("BABYLON.GeometryTextureFetchBlock",GC);class jL extends be{constructor(e){super(e),this.registerInput("geometry",I.Geometry),this.registerOutput("min",I.Vector3),this.registerOutput("max",I.Vector3)}getClassName(){return"BoundingBlock"}get geometry(){return this._inputs[0]}get min(){return this._outputs[0]}get max(){return this._outputs[1]}_buildBlock(){this.min._storedFunction=e=>{const t=this.geometry.getConnectedValue(e);return t?zo(t.positions,0,t.positions.length/3).minimum:null},this.max._storedFunction=e=>{const t=this.geometry.getConnectedValue(e);return t?zo(t.positions,0,t.positions.length/3).maximum:null}}}B("BABYLON.BoundingBlock",jL);var or;(function(a){a[a.Intersect=0]="Intersect",a[a.Subtract=1]="Subtract",a[a.Union=2]="Union"})(or||(or={}));class sc extends be{get _isReadyState(){return mL()?null:(this._csg2LoadingPromise||(this._csg2LoadingPromise=_L()),this._csg2LoadingPromise)}constructor(e){super(e),this.evaluateContext=!1,this.operation=or.Intersect,this.useOldCSGEngine=!1,this.registerInput("geometry0",I.Geometry),this.registerInput("geometry1",I.Geometry),this.registerOutput("output",I.Geometry)}getClassName(){return"BooleanGeometryBlock"}get geometry0(){return this._inputs[0]}get geometry1(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){const t=i=>{const r=this.geometry0.getConnectedValue(i),s=this.geometry1.getConnectedValue(i);if(!r||!s)return null;const n=r.positions.length/3;!r.normals&&s.normals&&(r.normals=new Array(r.positions.length)),!s.normals&&r.normals&&(s.normals=new Array(s.positions.length)),!r.uvs&&s.uvs&&(r.uvs=new Array(n*2)),!s.uvs&&r.uvs&&(s.uvs=new Array(n*2)),!r.colors&&s.colors&&(r.colors=new Array(n*4)),!s.colors&&r.colors&&(s.colors=new Array(n*4));let o;if(this.useOldCSGEngine){const l=Xr.FromVertexData(r),u=Xr.FromVertexData(s);switch(this.operation){case or.Intersect:o=l.intersect(u);break;case or.Subtract:o=l.subtract(u);break;case or.Union:o=l.union(u);break}}else{const l=Ko.FromVertexData(r),u=Ko.FromVertexData(s);switch(this.operation){case or.Intersect:o=l.intersect(u);break;case or.Subtract:o=l.subtract(u);break;case or.Union:o=l.add(u);break}}return o.toVertexData()};this.evaluateContext?this.output._storedFunction=t:(this.output._storedFunction=null,this.output._storedValue=t(e))}_dumpPropertiesCode(){let e=super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`;return e+=`${this._codeVariableName}.operation = BABYLON.BooleanGeometryOperations.${or[this.operation]};
`,e+=`${this._codeVariableName}.useOldCSGEngine = ${this.useOldCSGEngine?"true":"false"};
`,e}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e.operation=this.operation,e.useOldCSGEngine=this.useOldCSGEngine,e}_deserialize(e){super._deserialize(e),this.evaluateContext=e.evaluateContext,e.operation&&(this.operation=e.operation),this.useOldCSGEngine=!!e.useOldCSGEngine}}C([U("Evaluate context",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],sc.prototype,"evaluateContext",void 0);C([U("Operation",4,"ADVANCED",{notifiers:{rebuild:!0},embedded:!0,options:[{label:"Intersect",value:or.Intersect},{label:"Subtract",value:or.Subtract},{label:"Union",value:or.Union}]})],sc.prototype,"operation",void 0);C([U("Use old CSG engine",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],sc.prototype,"useOldCSGEngine",void 0);B("BABYLON.BooleanGeometryBlock",sc);class YL extends be{constructor(e){super(e),this.registerInput("x",I.AutoDetect),this.registerInput("y",I.AutoDetect),this.registerOutput("output",I.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._linkConnectionTypes(0,1),this._inputs[0].excludedConnectionPointTypes.push(I.Matrix),this._inputs[0].excludedConnectionPointTypes.push(I.Geometry),this._inputs[0].excludedConnectionPointTypes.push(I.Texture)}getClassName(){return"GeometryArcTan2Block"}get x(){return this._inputs[0]}get y(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(){if(!this.x.isConnected||!this.y.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}const e=(t,i)=>Math.atan2(t,i);this.output._storedFunction=t=>{const i=this.x.getConnectedValue(t),r=this.y.getConnectedValue(t);switch(this.x.type){case I.Int:case I.Float:return e(i,r);case I.Vector2:return new Q(e(i.x,r.x),e(i.y,r.y));case I.Vector3:return new m(e(i.x,r.x),e(i.y,r.y),e(i.z,r.z));case I.Vector4:return new Ve(e(i.x,r.x),e(i.y,r.y),e(i.z,r.z),e(i.w,r.w))}return 0}}}B("BABYLON.GeometryArcTan2Block",YL);class XL extends be{constructor(e){super(e),this.registerInput("left",I.AutoDetect),this.registerInput("right",I.AutoDetect),this.registerInput("gradient",I.Float,!0,0,0,1),this.registerOutput("output",I.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._linkConnectionTypes(0,1),this._inputs[0].excludedConnectionPointTypes.push(I.Matrix),this._inputs[0].excludedConnectionPointTypes.push(I.Geometry),this._inputs[0].excludedConnectionPointTypes.push(I.Texture)}getClassName(){return"GeometryLerpBlock"}get left(){return this._inputs[0]}get right(){return this._inputs[1]}get gradient(){return this._inputs[2]}get output(){return this._outputs[0]}_buildBlock(){if(!this.left.isConnected||!this.right.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}const e=(t,i,r)=>(1-t)*i+t*r;return this.output._storedFunction=t=>{const i=this.left.getConnectedValue(t),r=this.right.getConnectedValue(t),s=this.gradient.getConnectedValue(t);switch(this.left.type){case I.Int:case I.Float:return e(s,i,r);case I.Vector2:return new Q(e(s,i.x,r.x),e(s,i.y,r.y));case I.Vector3:return new m(e(s,i.x,r.x),e(s,i.y,r.y),e(s,i.z,r.z));case I.Vector4:return new Ve(e(s,i.x,r.x),e(s,i.y,r.y),e(s,i.z,r.z),e(s,i.w,r.w))}return 0},this}}B("BABYLON.GeometryLerpBlock",XL);class ZL extends be{constructor(e){super(e),this.registerInput("left",I.AutoDetect),this.registerInput("right",I.AutoDetect),this.registerInput("gradient",I.Float,!0,0,0,1),this.registerOutput("output",I.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._linkConnectionTypes(0,1),this._inputs[0].excludedConnectionPointTypes.push(I.Matrix),this._inputs[0].excludedConnectionPointTypes.push(I.Geometry),this._inputs[0].excludedConnectionPointTypes.push(I.Texture)}getClassName(){return"GeometryNLerpBlock"}get left(){return this._inputs[0]}get right(){return this._inputs[1]}get gradient(){return this._inputs[2]}get output(){return this._outputs[0]}_buildBlock(){if(!this.left.isConnected||!this.right.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}const e=(t,i,r)=>(1-t)*i+t*r;return this.output._storedFunction=t=>{const i=this.left.getConnectedValue(t),r=this.right.getConnectedValue(t),s=this.gradient.getConnectedValue(t);switch(this.left.type){case I.Int:case I.Float:return e(s,i,r);case I.Vector2:{const n=new Q(e(s,i.x,r.x),e(s,i.y,r.y));return n.normalize(),n}case I.Vector3:{const n=new m(e(s,i.x,r.x),e(s,i.y,r.y),e(s,i.z,r.z));return n.normalize(),n}case I.Vector4:{const n=new Ve(e(s,i.x,r.x),e(s,i.y,r.y),e(s,i.z,r.z),e(s,i.w,r.w));return n.normalize(),n}}return 0},this}}B("BABYLON.GeometryNLerpBlock",ZL);class qL extends be{constructor(e){super(e),this.registerInput("value",I.AutoDetect),this.registerInput("edge",I.Float,!0,0),this.registerOutput("output",I.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._inputs[0].excludedConnectionPointTypes.push(I.Matrix),this._inputs[0].excludedConnectionPointTypes.push(I.Geometry),this._inputs[0].excludedConnectionPointTypes.push(I.Texture)}getClassName(){return"GeometryStepBlock"}get value(){return this._inputs[0]}get edge(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(){if(!this.value.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}const e=(t,i)=>t<i?0:1;return this.output._storedFunction=t=>{const i=this.value.getConnectedValue(t),r=this.edge.getConnectedValue(t);switch(this.value.type){case I.Int:case I.Float:return e(i,r);case I.Vector2:return new Q(e(i.x,r),e(i.y,r));case I.Vector3:return new m(e(i.x,r),e(i.y,r),e(i.z,r));case I.Vector4:return new Ve(e(i.x,r),e(i.y,r),e(i.z,r),e(i.w,r))}return 0},this}}B("BABYLON.GeometryStepBlock",qL);class QL extends be{constructor(e){super(e),this.registerInput("value",I.AutoDetect),this.registerInput("edge0",I.Float,!0,0),this.registerInput("edge1",I.Float,!0,1),this.registerOutput("output",I.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._inputs[0].excludedConnectionPointTypes.push(I.Matrix),this._inputs[0].excludedConnectionPointTypes.push(I.Geometry),this._inputs[0].excludedConnectionPointTypes.push(I.Texture)}getClassName(){return"GeometrySmoothStepBlock"}get value(){return this._inputs[0]}get edge0(){return this._inputs[1]}get edge1(){return this._inputs[2]}get output(){return this._outputs[0]}_buildBlock(){if(!this.value.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}const e=(t,i,r)=>{const s=Math.max(0,Math.min((t-i)/(r-i),1));return s*s*(3-2*s)};return this.output._storedFunction=t=>{const i=this.value.getConnectedValue(t),r=this.edge0.getConnectedValue(t),s=this.edge1.getConnectedValue(t);switch(this.value.type){case I.Int:case I.Float:return e(i,r,s);case I.Vector2:return new Q(e(i.x,r,s),e(i.y,r,s));case I.Vector3:return new m(e(i.x,r,s),e(i.y,r,s),e(i.z,r,s));case I.Vector4:return new Ve(e(i.x,r,s),e(i.y,r,s),e(i.z,r,s),e(i.w,r,s))}return 0},this}}B("BABYLON.GeometrySmoothStepBlock",QL);class KL extends be{constructor(e){super(e),this.registerInput("left",I.AutoDetect),this.registerInput("right",I.AutoDetect),this.registerOutput("output",I.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._linkConnectionTypes(0,1),this._inputs[0].excludedConnectionPointTypes.push(I.Matrix),this._inputs[0].excludedConnectionPointTypes.push(I.Geometry),this._inputs[0].excludedConnectionPointTypes.push(I.Texture)}getClassName(){return"GeometryModBlock"}get left(){return this._inputs[0]}get right(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(){if(!this.left.isConnected||!this.right.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}const e=(t,i)=>t-Math.floor(t/i)*i;return this.output._storedFunction=t=>{const i=this.left.getConnectedValue(t),r=this.right.getConnectedValue(t);switch(this.left.type){case I.Int:case I.Float:return e(i,r);case I.Vector2:return new Q(e(i.x,r.x),e(i.y,r.y));case I.Vector3:return new m(e(i.x,r.x),e(i.y,r.y),e(i.z,r.z));case I.Vector4:return new Ve(e(i.x,r.x),e(i.y,r.y),e(i.z,r.z),e(i.w,r.w))}return 0},this}}B("BABYLON.GeometryModBlock",KL);class JL extends be{constructor(e){super(e),this.registerInput("value",I.AutoDetect),this.registerInput("power",I.AutoDetect),this.registerOutput("output",I.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._linkConnectionTypes(0,1),this._inputs[0].excludedConnectionPointTypes.push(I.Matrix),this._inputs[0].excludedConnectionPointTypes.push(I.Geometry),this._inputs[0].excludedConnectionPointTypes.push(I.Texture)}getClassName(){return"GeometryPowBlock"}get value(){return this._inputs[0]}get power(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(){if(!this.value.isConnected||!this.power.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}const e=(t,i)=>Math.pow(t,i);return this.output._storedFunction=t=>{const i=this.value.getConnectedValue(t),r=this.power.getConnectedValue(t);switch(this.value.type){case I.Int:case I.Float:return e(i,r);case I.Vector2:return new Q(e(i.x,r),e(i.y,r));case I.Vector3:return new m(e(i.x,r),e(i.y,r),e(i.z,r));case I.Vector4:return new Ve(e(i.x,r),e(i.y,r),e(i.z,r),e(i.w,r))}return 0},this}}B("BABYLON.GeometryPowBlock",JL);class eB extends be{get minimum(){return this.min.value}set minimum(e){this.min.value=e}get maximum(){return this.max.value}set maximum(e){this.max.value=e}constructor(e){super(e),this.registerInput("value",I.AutoDetect),this.registerInput("min",I.Float,!0,0),this.registerInput("max",I.Float,!0,1),this.registerOutput("output",I.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._inputs[0].excludedConnectionPointTypes.push(I.Matrix),this._inputs[0].excludedConnectionPointTypes.push(I.Geometry),this._inputs[0].excludedConnectionPointTypes.push(I.Texture)}getClassName(){return"GeometryClampBlock"}get value(){return this._inputs[0]}get min(){return this._inputs[1]}get max(){return this._inputs[2]}get output(){return this._outputs[0]}_buildBlock(){if(!this.value.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}const e=(t,i,r)=>Math.max(i,Math.min(t,r));return this.output._storedFunction=t=>{const i=this.value.getConnectedValue(t),r=this.min.isConnected?this.min.getConnectedValue(t):this.minimum,s=this.max.isConnected?this.max.getConnectedValue(t):this.maximum;switch(this.value.type){case I.Int:case I.Float:return e(i,r,s);case I.Vector2:return new Q(e(i.x,r,s),e(i.y,r,s));case I.Vector3:return new m(e(i.x,r,s),e(i.y,r,s),e(i.z,r,s));case I.Vector4:return new Ve(e(i.x,r,s),e(i.y,r,s),e(i.z,r,s),e(i.w,r,s))}return 0},this}_deserialize(e){super._deserialize(e),this.minimum=e.minimum,this.maximum=e.maximum}}B("BABYLON.GeometryClampBlock",eB);class tB extends be{constructor(e){super(e),this.registerInput("left",I.AutoDetect),this.registerInput("right",I.AutoDetect),this.registerOutput("output",I.Vector3),this._linkConnectionTypes(0,1),this._inputs[0].excludedConnectionPointTypes.push(I.Int),this._inputs[0].excludedConnectionPointTypes.push(I.Float),this._inputs[0].excludedConnectionPointTypes.push(I.Matrix),this._inputs[0].excludedConnectionPointTypes.push(I.Vector2),this._inputs[1].excludedConnectionPointTypes.push(I.Int),this._inputs[1].excludedConnectionPointTypes.push(I.Float),this._inputs[1].excludedConnectionPointTypes.push(I.Matrix),this._inputs[1].excludedConnectionPointTypes.push(I.Vector2)}getClassName(){return"GeometryCrossBlock"}get left(){return this._inputs[0]}get right(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(){if(!this.left.isConnected||!this.right.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}return this.output._storedFunction=e=>{const t=this.left.getConnectedValue(e),i=this.right.getConnectedValue(e);switch(this.left.type){case I.Vector3:return m.Cross(t,i);case I.Vector4:return m.Cross(t.toVector3(),i.toVector3())}return 0},this}}B("BABYLON.GeometryCrossBlock",tB);var Oe;(function(a){a[a.EaseInSine=0]="EaseInSine",a[a.EaseOutSine=1]="EaseOutSine",a[a.EaseInOutSine=2]="EaseInOutSine",a[a.EaseInQuad=3]="EaseInQuad",a[a.EaseOutQuad=4]="EaseOutQuad",a[a.EaseInOutQuad=5]="EaseInOutQuad",a[a.EaseInCubic=6]="EaseInCubic",a[a.EaseOutCubic=7]="EaseOutCubic",a[a.EaseInOutCubic=8]="EaseInOutCubic",a[a.EaseInQuart=9]="EaseInQuart",a[a.EaseOutQuart=10]="EaseOutQuart",a[a.EaseInOutQuart=11]="EaseInOutQuart",a[a.EaseInQuint=12]="EaseInQuint",a[a.EaseOutQuint=13]="EaseOutQuint",a[a.EaseInOutQuint=14]="EaseInOutQuint",a[a.EaseInExpo=15]="EaseInExpo",a[a.EaseOutExpo=16]="EaseOutExpo",a[a.EaseInOutExpo=17]="EaseInOutExpo",a[a.EaseInCirc=18]="EaseInCirc",a[a.EaseOutCirc=19]="EaseOutCirc",a[a.EaseInOutCirc=20]="EaseInOutCirc",a[a.EaseInBack=21]="EaseInBack",a[a.EaseOutBack=22]="EaseOutBack",a[a.EaseInOutBack=23]="EaseInOutBack",a[a.EaseInElastic=24]="EaseInElastic",a[a.EaseOutElastic=25]="EaseOutElastic",a[a.EaseInOutElastic=26]="EaseInOutElastic"})(Oe||(Oe={}));class WC extends be{constructor(e){super(e),this.type=Oe.EaseInOutSine,this.registerInput("input",I.AutoDetect),this.registerOutput("output",I.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._inputs[0].excludedConnectionPointTypes.push(I.Matrix),this._inputs[0].excludedConnectionPointTypes.push(I.Int)}getClassName(){return"GeometryCurveBlock"}get input(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(){if(!this.input.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}let e;switch(this.type){case Oe.EaseInSine:e=t=>1-Math.cos(t*3.1415/2);break;case Oe.EaseOutSine:e=t=>Math.sin(t*3.1415/2);break;case Oe.EaseInOutSine:e=t=>-(Math.cos(t*3.1415)-1)/2;break;case Oe.EaseInQuad:e=t=>t*t;break;case Oe.EaseOutQuad:e=t=>(1-t)*(1-t);break;case Oe.EaseInOutQuad:{e=t=>t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2;break}case Oe.EaseInCubic:e=t=>t*t*t;break;case Oe.EaseOutCubic:{e=t=>1-Math.pow(1-t,3);break}case Oe.EaseInOutCubic:{e=t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2;break}case Oe.EaseInQuart:e=t=>t*t*t*t;break;case Oe.EaseOutQuart:{e=t=>1-Math.pow(1-t,4);break}case Oe.EaseInOutQuart:{e=t=>t<.5?8*t*t*t*t:1-Math.pow(-2*t+2,4)/2;break}case Oe.EaseInQuint:e=t=>t*t*t*t*t;break;case Oe.EaseOutQuint:{e=t=>1-Math.pow(1-t,5);break}case Oe.EaseInOutQuint:{e=t=>t<.5?16*t*t*t*t*t:1-Math.pow(-2*t+2,5)/2;break}case Oe.EaseInExpo:{e=t=>t===0?0:Math.pow(2,10*t-10);break}case Oe.EaseOutExpo:{e=t=>t===1?1:1-Math.pow(2,-10*t);break}case Oe.EaseInOutExpo:{e=t=>t===0?0:t===1?1:t<.5?Math.pow(2,20*t-10)/2:(2-Math.pow(2,-20*t+10))/2;break}case Oe.EaseInCirc:{e=t=>1-Math.sqrt(1-Math.pow(t,2));break}case Oe.EaseOutCirc:{e=t=>Math.sqrt(1-Math.pow(t-1,2));break}case Oe.EaseInOutCirc:{e=t=>t<.5?(1-Math.sqrt(1-Math.pow(2*t,2)))/2:(Math.sqrt(1-Math.pow(-2*t+2,2))+1)/2;break}case Oe.EaseInBack:{e=t=>2.70158*t*t*t-1.70158*t*t;break}case Oe.EaseOutBack:{e=t=>2.70158*Math.pow(t-1,3)+1.70158*Math.pow(t-1,2);break}case Oe.EaseInOutBack:{e=t=>t<.5?Math.pow(2*t,2)*(3.5949095*2*t-2.5949095)/2:(Math.pow(2*t-2,2)*(3.5949095*(t*2-2)+3.5949095)+2)/2;break}case Oe.EaseInElastic:{e=t=>t===0?0:t===1?1:-Math.pow(2,10*t-10)*Math.sin((t*10-10.75)*(2*3.1415/3));break}case Oe.EaseOutElastic:{e=t=>t===0?0:t===1?1:Math.pow(2,-10*t)*Math.sin((t*10-.75)*(2*3.1415/3))+1;break}case Oe.EaseInOutElastic:{e=t=>t===0?0:t==1?1:t<.5?-(Math.pow(2,20*t-10)*Math.sin((20*t-11.125)*(2*3.1415/4.5)))/2:Math.pow(2,-20*t+10)*Math.sin((20*t-11.125)*(2*3.1415/4.5))/2+1;break}}return this.output._storedFunction=t=>{const i=this.input.getConnectedValue(t);switch(this.input.type){case I.Float:return e(i);case I.Vector2:return new Q(e(i.x),e(i.y));case I.Vector3:return new m(e(i.x),e(i.y),e(i.z));case I.Vector4:return new Ve(e(i.x),e(i.y),e(i.z),e(i.w))}return 0},this}serialize(){const e=super.serialize();return e.curveType=this.type,e}_deserialize(e){super._deserialize(e),this.type=e.curveType}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.type = BABYLON.GeometryCurveBlockTypes.${Oe[this.type]};
`}}C([U("Type",4,"ADVANCED",{notifiers:{rebuild:!0},embedded:!0,options:[{label:"EaseInSine",value:Oe.EaseInSine},{label:"EaseOutSine",value:Oe.EaseOutSine},{label:"EaseInOutSine",value:Oe.EaseInOutSine},{label:"EaseInQuad",value:Oe.EaseInQuad},{label:"EaseOutQuad",value:Oe.EaseOutQuad},{label:"EaseInOutQuad",value:Oe.EaseInOutQuad},{label:"EaseInCubic",value:Oe.EaseInCubic},{label:"EaseOutCubic",value:Oe.EaseOutCubic},{label:"EaseInOutCubic",value:Oe.EaseInOutCubic},{label:"EaseInQuart",value:Oe.EaseInQuart},{label:"EaseOutQuart",value:Oe.EaseOutQuart},{label:"EaseInOutQuart",value:Oe.EaseInOutQuart},{label:"EaseInQuint",value:Oe.EaseInQuint},{label:"EaseOutQuint",value:Oe.EaseOutQuint},{label:"EaseInOutQuint",value:Oe.EaseInOutQuint},{label:"EaseInExpo",value:Oe.EaseInExpo},{label:"EaseOutExpo",value:Oe.EaseOutExpo},{label:"EaseInOutExpo",value:Oe.EaseInOutExpo},{label:"EaseInCirc",value:Oe.EaseInCirc},{label:"EaseOutCirc",value:Oe.EaseOutCirc},{label:"EaseInOutCirc",value:Oe.EaseInOutCirc},{label:"EaseInBack",value:Oe.EaseInBack},{label:"EaseOutBack",value:Oe.EaseOutBack},{label:"EaseInOutBack",value:Oe.EaseInOutBack},{label:"EaseInElastic",value:Oe.EaseInElastic},{label:"EaseOutElastic",value:Oe.EaseOutElastic},{label:"EaseInOutElastic",value:Oe.EaseInOutElastic}]})],WC.prototype,"type",void 0);B("BABYLON.GeometryCurveBlock",WC);class iB extends be{constructor(e){super(e),this.registerInput("color",I.Vector3),this.registerInput("level",I.Float,!0,0),this.registerOutput("output",I.Vector3)}getClassName(){return"GeometryDesaturateBlock"}get color(){return this._inputs[0]}get level(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(){if(!this.color.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}return this.output._storedFunction=e=>{const t=this.color.getConnectedValue(e),i=this.level.getConnectedValue(e),r=Math.min(t.x,t.y,t.z),s=Math.max(t.x,t.y,t.z),n=.5*(r+s);return new m(t.x*(1-i)+n*i,t.y*(1-i)+n*i,t.z*(1-i)+n*i)},this}}B("BABYLON.GeometryDesaturateBlock",iB);class rB extends be{constructor(e){super(e),this.registerInput("value",I.AutoDetect),this.registerInput("steps",I.AutoDetect),this.registerOutput("output",I.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._linkConnectionTypes(0,1),this._inputs[0].excludedConnectionPointTypes.push(I.Matrix),this._inputs[1].excludedConnectionPointTypes.push(I.Matrix),this._inputs[1].acceptedConnectionPointTypes.push(I.Float)}getClassName(){return"GeometryPosterizeBlock"}get value(){return this._inputs[0]}get steps(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(){if(!this.value.isConnected||!this.steps.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}return this.output._storedFunction=e=>{const t=this.value.getConnectedValue(e),i=this.steps.getConnectedValue(e);let r=i;if(this.steps.type===I.Float)switch(this.value.type){case I.Vector2:r=new Q(i,i);break;case I.Vector3:r=new m(i,i,i);break;case I.Vector4:r=new Ve(i,i,i,i);break}switch(this.value.type){case I.Vector2:return new Q(t.x/(1/r.x)*(1/r.x),t.y/(1/r.y)*(1/r.y));case I.Vector3:return new m(t.x/(1/r.x)*(1/r.x),t.y/(1/r.y)*(1/r.y),t.z/(1/r.z)*(1/r.z));case I.Vector4:return new Ve(t.x/(1/r.x)*(1/r.x),t.y/(1/r.y)*(1/r.y),t.z/(1/r.z)*(1/r.z),t.w/(1/r.w)*(1/r.w));default:return Math.floor(t/(1/i)*(1/i))}},this}}B("BABYLON.GeometryPosterizeBlock",rB);class sB extends be{constructor(e){super(e),this.registerInput("value",I.AutoDetect),this.registerInput("reference",I.AutoDetect),this.registerInput("distance",I.Float,!0,0),this.registerInput("replacement",I.AutoDetect),this.registerOutput("output",I.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._linkConnectionTypes(0,1),this._linkConnectionTypes(0,3),this._inputs[0].excludedConnectionPointTypes.push(I.Float),this._inputs[0].excludedConnectionPointTypes.push(I.Matrix),this._inputs[1].excludedConnectionPointTypes.push(I.Float),this._inputs[1].excludedConnectionPointTypes.push(I.Matrix),this._inputs[3].excludedConnectionPointTypes.push(I.Float),this._inputs[3].excludedConnectionPointTypes.push(I.Matrix)}getClassName(){return"GeometryReplaceColorBlock"}get value(){return this._inputs[0]}get reference(){return this._inputs[1]}get distance(){return this._inputs[2]}get replacement(){return this._inputs[3]}get output(){return this._outputs[0]}_buildBlock(){if(!this.value.isConnected||!this.reference.isConnected||!this.replacement.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}return this.output._storedFunction=e=>{const t=this.value.getConnectedValue(e),i=this.reference.getConnectedValue(e),r=this.distance.getConnectedValue(e),s=this.replacement.getConnectedValue(e);return t.subtract(i).length()<r?s:t},this}}B("BABYLON.GeometryReplaceColorBlock",sB);class nB extends be{constructor(e){super(e),this.registerInput("left",I.AutoDetect),this.registerInput("right",I.AutoDetect),this.registerOutput("output",I.Float),this._linkConnectionTypes(0,1),this._inputs[0].excludedConnectionPointTypes.push(I.Int),this._inputs[0].excludedConnectionPointTypes.push(I.Float),this._inputs[0].excludedConnectionPointTypes.push(I.Matrix),this._inputs[1].excludedConnectionPointTypes.push(I.Float),this._inputs[1].excludedConnectionPointTypes.push(I.Matrix)}getClassName(){return"GeometryDistanceBlock"}get left(){return this._inputs[0]}get right(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(){if(!this.left.isConnected||!this.right.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}return this.output._storedFunction=e=>{const t=this.left.getConnectedValue(e),i=this.right.getConnectedValue(e);return t.subtract(i).length()},this}}B("BABYLON.GeometryDistanceBlock",nB);class aB extends be{constructor(e){super(e),this.registerInput("left",I.AutoDetect),this.registerInput("right",I.AutoDetect),this.registerOutput("output",I.Float),this._linkConnectionTypes(0,1),this._inputs[0].excludedConnectionPointTypes.push(I.Int),this._inputs[0].excludedConnectionPointTypes.push(I.Float),this._inputs[0].excludedConnectionPointTypes.push(I.Matrix),this._inputs[1].excludedConnectionPointTypes.push(I.Float),this._inputs[1].excludedConnectionPointTypes.push(I.Matrix)}getClassName(){return"GeometryDotBlock"}get left(){return this._inputs[0]}get right(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(){if(!this.left.isConnected||!this.right.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}return this.output._storedFunction=e=>{const t=this.left.getConnectedValue(e),i=this.right.getConnectedValue(e);return t.dot(i)},this}}B("BABYLON.GeometryDotBlock",aB);class oB extends be{constructor(e){super(e),this.registerInput("value",I.AutoDetect),this.registerOutput("output",I.Float),this._inputs[0].excludedConnectionPointTypes.push(I.Int),this._inputs[0].excludedConnectionPointTypes.push(I.Float),this._inputs[0].excludedConnectionPointTypes.push(I.Matrix)}getClassName(){return"GeometryLengthBlock"}get value(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(){if(!this.value.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}return this.output._storedFunction=e=>this.value.getConnectedValue(e).length(),this}}B("BABYLON.GeometryLengthBlock",oB);class lB extends be{constructor(e){super(e),this.registerInput("input",I.Vector2),this.registerInput("angle",I.Float,!0,0),this.registerOutput("output",I.Vector2)}getClassName(){return"GeometryRotate2dBlock"}get input(){return this._inputs[0]}get angle(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(){if(!this.input.isConnected){this.output._storedFunction=null,this.output._storedValue=null;return}return this.output._storedFunction=e=>{const t=this.input.getConnectedValue(e),i=this.angle.getConnectedValue(e);return new Q(Math.cos(i)*t.x-Math.sin(i)*t.y,Math.sin(i)*t.x+Math.cos(i)*t.y)},this}}B("BABYLON.GeometryRotate2dBlock",lB);class uB extends be{constructor(e){super(e),this.onInterceptionObservable=new j(void 0,!0),this.registerInput("input",I.AutoDetect),this.registerOutput("output",I.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0]}get buildExecutionTime(){return-1}getClassName(){return"GeometryInterceptorBlock"}get input(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){super._buildBlock(e);const t=this._outputs[0],i=this._inputs[0];t._storedFunction=r=>{let s=i.getConnectedValue(r);return this.customFunction&&(s=this.customFunction(s,r)),this.onInterceptionObservable.notifyObservers(s),s}}}B("BABYLON.GeometryInterceptorBlock",uB);var we;(function(a){a[a.EaseInSine=0]="EaseInSine",a[a.EaseOutSine=1]="EaseOutSine",a[a.EaseInOutSine=2]="EaseInOutSine",a[a.EaseInQuad=3]="EaseInQuad",a[a.EaseOutQuad=4]="EaseOutQuad",a[a.EaseInOutQuad=5]="EaseInOutQuad",a[a.EaseInCubic=6]="EaseInCubic",a[a.EaseOutCubic=7]="EaseOutCubic",a[a.EaseInOutCubic=8]="EaseInOutCubic",a[a.EaseInQuart=9]="EaseInQuart",a[a.EaseOutQuart=10]="EaseOutQuart",a[a.EaseInOutQuart=11]="EaseInOutQuart",a[a.EaseInQuint=12]="EaseInQuint",a[a.EaseOutQuint=13]="EaseOutQuint",a[a.EaseInOutQuint=14]="EaseInOutQuint",a[a.EaseInExpo=15]="EaseInExpo",a[a.EaseOutExpo=16]="EaseOutExpo",a[a.EaseInOutExpo=17]="EaseInOutExpo",a[a.EaseInCirc=18]="EaseInCirc",a[a.EaseOutCirc=19]="EaseOutCirc",a[a.EaseInOutCirc=20]="EaseInOutCirc",a[a.EaseInBack=21]="EaseInBack",a[a.EaseOutBack=22]="EaseOutBack",a[a.EaseInOutBack=23]="EaseInOutBack",a[a.EaseInElastic=24]="EaseInElastic",a[a.EaseOutElastic=25]="EaseOutElastic",a[a.EaseInOutElastic=26]="EaseInOutElastic"})(we||(we={}));class $C extends be{get type(){return this._type}set type(e){if(this._type!==e)switch(this._type=e,this._type){case we.EaseInSine:this._easingFunction=new vs,this._easingFunction.setEasingMode(vs.EASINGMODE_EASEIN);break;case we.EaseOutSine:this._easingFunction=new vs,this._easingFunction.setEasingMode(vs.EASINGMODE_EASEOUT);break;case we.EaseInOutSine:this._easingFunction=new vs,this._easingFunction.setEasingMode(vs.EASINGMODE_EASEINOUT);break;case we.EaseInQuad:this._easingFunction=new Rn,this._easingFunction.setEasingMode(Rn.EASINGMODE_EASEIN);break;case we.EaseOutQuad:this._easingFunction=new Rn,this._easingFunction.setEasingMode(Rn.EASINGMODE_EASEOUT);break;case we.EaseInOutQuad:this._easingFunction=new Rn,this._easingFunction.setEasingMode(Rn.EASINGMODE_EASEINOUT);break;case we.EaseInCubic:this._easingFunction=new ca,this._easingFunction.setEasingMode(ca.EASINGMODE_EASEIN);break;case we.EaseOutCubic:this._easingFunction=new ca,this._easingFunction.setEasingMode(ca.EASINGMODE_EASEOUT);break;case we.EaseInOutCubic:this._easingFunction=new ca,this._easingFunction.setEasingMode(ca.EASINGMODE_EASEINOUT);break;case we.EaseInQuart:this._easingFunction=new ua,this._easingFunction.setEasingMode(ua.EASINGMODE_EASEIN);break;case we.EaseOutQuart:this._easingFunction=new ua,this._easingFunction.setEasingMode(ua.EASINGMODE_EASEOUT);break;case we.EaseInOutQuart:this._easingFunction=new ua,this._easingFunction.setEasingMode(ua.EASINGMODE_EASEINOUT);break;case we.EaseInQuint:this._easingFunction=new la,this._easingFunction.setEasingMode(la.EASINGMODE_EASEIN);break;case we.EaseOutQuint:this._easingFunction=new la,this._easingFunction.setEasingMode(la.EASINGMODE_EASEOUT);break;case we.EaseInOutQuint:this._easingFunction=new la,this._easingFunction.setEasingMode(la.EASINGMODE_EASEINOUT);break;case we.EaseInExpo:this._easingFunction=new En,this._easingFunction.setEasingMode(En.EASINGMODE_EASEIN);break;case we.EaseOutExpo:this._easingFunction=new En,this._easingFunction.setEasingMode(En.EASINGMODE_EASEOUT);break;case we.EaseInOutExpo:this._easingFunction=new En,this._easingFunction.setEasingMode(En.EASINGMODE_EASEINOUT);break;case we.EaseInCirc:this._easingFunction=new In,this._easingFunction.setEasingMode(In.EASINGMODE_EASEIN);break;case we.EaseOutCirc:this._easingFunction=new In,this._easingFunction.setEasingMode(In.EASINGMODE_EASEOUT);break;case we.EaseInOutCirc:this._easingFunction=new In,this._easingFunction.setEasingMode(In.EASINGMODE_EASEINOUT);break;case we.EaseInBack:this._easingFunction=new Pn,this._easingFunction.setEasingMode(Pn.EASINGMODE_EASEIN);break;case we.EaseOutBack:this._easingFunction=new Pn,this._easingFunction.setEasingMode(Pn.EASINGMODE_EASEOUT);break;case we.EaseInOutBack:this._easingFunction=new Pn,this._easingFunction.setEasingMode(Pn.EASINGMODE_EASEINOUT);break;case we.EaseInElastic:this._easingFunction=new oa,this._easingFunction.setEasingMode(oa.EASINGMODE_EASEIN);break;case we.EaseOutElastic:this._easingFunction=new oa,this._easingFunction.setEasingMode(oa.EASINGMODE_EASEOUT);break;case we.EaseInOutElastic:this._easingFunction=new oa,this._easingFunction.setEasingMode(oa.EASINGMODE_EASEINOUT);break}}constructor(e){super(e),this._easingFunction=new vs,this._type=we.EaseInOutSine,this.registerInput("input",I.AutoDetect),this.registerOutput("output",I.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[0],this._inputs[0].excludedConnectionPointTypes.push(I.Matrix),this._inputs[0].excludedConnectionPointTypes.push(I.Geometry),this._inputs[0].excludedConnectionPointTypes.push(I.Texture)}getClassName(){return"GeometryEaseBlock"}get input(){return this._inputs[0]}get output(){return this._outputs[0]}_buildBlock(e){if(super._buildBlock(e),!this._easingFunction){this.output._storedFunction=null,this.output._storedValue=null;return}switch(this.input.type){case I.Int:case I.Float:{this.output._storedFunction=t=>{const i=this.input.getConnectedValue(t);return this._easingFunction.ease(i)};break}case I.Vector2:{this.output._storedFunction=t=>{const i=this.input.getConnectedValue(t);return new Q(this._easingFunction.ease(i.x),this._easingFunction.ease(i.y))};break}case I.Vector3:{this.output._storedFunction=t=>{const i=this.input.getConnectedValue(t);return new m(this._easingFunction.ease(i.x),this._easingFunction.ease(i.y),this._easingFunction.ease(i.z))};break}case I.Vector4:{this.output._storedFunction=t=>{const i=this.input.getConnectedValue(t);return new Ve(this._easingFunction.ease(i.x),this._easingFunction.ease(i.y),this._easingFunction.ease(i.z),this._easingFunction.ease(i.w))};break}}return this}serialize(){const e=super.serialize();return e.type=this.type,e}_deserialize(e){super._deserialize(e),this.type=e.type}_dumpPropertiesCode(){return super._dumpPropertiesCode()+`${this._codeVariableName}.type = BABYLON.GeometryEaseBlockTypes.${we[this.type]};
`}}C([U("Type",4,"ADVANCED",{notifiers:{rebuild:!0},embedded:!0,options:[{label:"EaseInSine",value:we.EaseInSine},{label:"EaseOutSine",value:we.EaseOutSine},{label:"EaseInOutSine",value:we.EaseInOutSine},{label:"EaseInQuad",value:we.EaseInQuad},{label:"EaseOutQuad",value:we.EaseOutQuad},{label:"EaseInOutQuad",value:we.EaseInOutQuad},{label:"EaseInCubic",value:we.EaseInCubic},{label:"EaseOutCubic",value:we.EaseOutCubic},{label:"EaseInOutCubic",value:we.EaseInOutCubic},{label:"EaseInQuart",value:we.EaseInQuart},{label:"EaseOutQuart",value:we.EaseOutQuart},{label:"EaseInOutQuart",value:we.EaseInOutQuart},{label:"EaseInQuint",value:we.EaseInQuint},{label:"EaseOutQuint",value:we.EaseOutQuint},{label:"EaseInOutQuint",value:we.EaseInOutQuint},{label:"EaseInExpo",value:we.EaseInExpo},{label:"EaseOutExpo",value:we.EaseOutExpo},{label:"EaseInOutExpo",value:we.EaseInOutExpo},{label:"EaseInCirc",value:we.EaseInCirc},{label:"EaseOutCirc",value:we.EaseOutCirc},{label:"EaseInOutCirc",value:we.EaseInOutCirc},{label:"EaseInBack",value:we.EaseInBack},{label:"EaseOutBack",value:we.EaseOutBack},{label:"EaseInOutBack",value:we.EaseInOutBack},{label:"EaseInElastic",value:we.EaseInElastic},{label:"EaseOutElastic",value:we.EaseOutElastic},{label:"EaseInOutElastic",value:we.EaseInOutElastic}]})],$C.prototype,"type",null);B("BABYLON.GeometryEaseBlock",$C);var Jr;(function(a){a[a.Max=0]="Max",a[a.Min=1]="Min",a[a.Sum=2]="Sum"})(Jr||(Jr={}));class X_ extends be{constructor(e){super(e),this.aggregation=Jr.Sum,this.evaluateContext=!0,this.registerInput("geometry",I.Geometry),this.registerInput("source",I.AutoDetect),this.registerOutput("output",I.BasedOnInput),this._outputs[0]._typeConnectionSource=this._inputs[1]}getExecutionIndex(){return this._currentIndex}getExecutionLoopIndex(){return this._currentIndex}getExecutionFaceIndex(){return 0}getClassName(){return"AggregatorBlock"}get geometry(){return this._inputs[0]}get source(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(e){const t=i=>{if(i.pushExecutionContext(this),this._vertexData=this.geometry.getConnectedValue(i),i.pushGeometryContext(this._vertexData),!this._vertexData||!this._vertexData.positions||!this.source.isConnected){i.restoreGeometryContext(),i.restoreExecutionContext(),this.output._storedValue=null;return}const r=this._vertexData.positions.length/3,s=[];for(this._currentIndex=0;this._currentIndex<r;this._currentIndex++)s.push(this.source.getConnectedValue(i));let n=null;switch(this.aggregation){case Jr.Max:{n=(l,u)=>Math.max(l,u);break}case Jr.Min:{n=(l,u)=>Math.min(l,u);break}case Jr.Sum:{n=(l,u)=>l+u;break}}if(!n){i.restoreGeometryContext(),i.restoreExecutionContext(),this.output._storedFunction=null,this.output._storedValue=null;return}let o;switch(this.source.type){case I.Int:case I.Float:{o=s.reduce(n);break}case I.Vector2:{const l=s.map(c=>c.x).reduce(n),u=s.map(c=>c.y).reduce(n);o=new Q(l,u);break}case I.Vector3:{const l=s.map(h=>h.x).reduce(n),u=s.map(h=>h.y).reduce(n),c=s.map(h=>h.z).reduce(n);o=new m(l,u,c);break}case I.Vector4:{const l=s.map(d=>d.x).reduce(n),u=s.map(d=>d.y).reduce(n),c=s.map(d=>d.z).reduce(n),h=s.map(d=>d.w).reduce(n);o=new Ve(l,u,c,h);break}}return i.restoreGeometryContext(),i.restoreExecutionContext(),o};this.evaluateContext?this.output._storedFunction=t:(this.output._storedFunction=null,this.output._storedValue=t(e))}_dumpPropertiesCode(){let e=super._dumpPropertiesCode()+`${this._codeVariableName}.evaluateContext = ${this.evaluateContext?"true":"false"};
`;return e+=`${this._codeVariableName}.aggregation = BABYLON.Aggregations.${Jr[this.aggregation]};
`,e}serialize(){const e=super.serialize();return e.evaluateContext=this.evaluateContext,e.aggregation=this.aggregation,e}_deserialize(e){super._deserialize(e),e.evaluateContext!==void 0&&(this.evaluateContext=e.evaluateContext),e.aggregation!==void 0&&(this.aggregation=e.aggregation)}}C([U("Aggregation",4,"ADVANCED",{notifiers:{rebuild:!0},embedded:!0,options:[{label:"Max",value:Jr.Max},{label:"Min",value:Jr.Min},{label:"Sum",value:Jr.Sum}]})],X_.prototype,"aggregation",void 0);C([U("Evaluate context",0,"ADVANCED",{notifiers:{rebuild:!0}})],X_.prototype,"evaluateContext",void 0);B("BABYLON.AggregatorBlock",X_);class Z_ extends be{constructor(e){super(e),this.flatOnly=!1,this.loopWeight=1,this.registerInput("geometry",I.Geometry),this.registerInput("level",I.Int,!0,1,0,8),this.registerOutput("output",I.Geometry)}getClassName(){return"SubdivideBlock"}get geometry(){return this._inputs[0]}get level(){return this._inputs[1]}get output(){return this._outputs[0]}_buildBlock(){this.output._storedFunction=e=>{if(!this.geometry.isConnected)return null;const t=this.geometry.getConnectedValue(e);if(!t)return null;const i=this.level.getConnectedValue(e);return bL(t,i,{flatOnly:this.flatOnly,weight:this.loopWeight})}}_dumpPropertiesCode(){let e=super._dumpPropertiesCode()+`${this._codeVariableName}.flatOnly = ${this.flatOnly?"true":"false"};
`;return e+=`${this._codeVariableName}.loopWeight = ${this.loopWeight};
`,e}serialize(){const e=super.serialize();return e.flatOnly=this.flatOnly,e.loopWeight=this.loopWeight,e}_deserialize(e){super._deserialize(e),this.flatOnly=e.flatOnly,this.loopWeight=e.loopWeight}}C([U("Flat Only",0,"ADVANCED",{embedded:!0,notifiers:{rebuild:!0}})],Z_.prototype,"flatOnly",void 0);C([U("Loop weight",1,"ADVANCED",{embedded:!0,min:0,max:1,notifiers:{rebuild:!0}})],Z_.prototype,"loopWeight",void 0);B("BABYLON.SubdivideBlock",Z_);const md="colorPixelShader",HC=`#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
#define VERTEXCOLOR
varying vColor: vec4f;
#else
uniform color: vec4f;
#endif
#include<clipPlaneFragmentDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
fragmentOutputs.color=input.vColor;
#else
fragmentOutputs.color=uniforms.color;
#endif
#include<fogFragment>(color,fragmentOutputs.color)
#define CUSTOM_FRAGMENT_MAIN_END
}`;P.ShadersStoreWGSL[md]||(P.ShadersStoreWGSL[md]=HC);const cB={name:md,shader:HC},hB=Object.freeze(Object.defineProperty({__proto__:null,colorPixelShaderWGSL:cB},Symbol.toStringTag,{value:"Module"})),_d="colorVertexShader",jC=`attribute position: vec3f;
#ifdef VERTEXCOLOR
attribute color: vec4f;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#ifdef FOG
uniform view: mat4x4f;
#endif
#include<instancesDeclaration>
uniform viewProjection: mat4x4f;
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vColor: vec4f;
#endif
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
#ifdef VERTEXCOLOR
var colorUpdated: vec4f=vertexInputs.color;
#endif
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
var worldPos: vec4f=finalWorld* vec4f(input.position,1.0);vertexOutputs.position=uniforms.viewProjection*worldPos;
#include<clipPlaneVertex>
#include<fogVertex>
#include<vertexColorMixing>
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStoreWGSL[_d]||(P.ShadersStoreWGSL[_d]=jC);const dB={name:_d,shader:jC},fB=Object.freeze(Object.defineProperty({__proto__:null,colorVertexShaderWGSL:dB},Symbol.toStringTag,{value:"Module"})),gd="meshUVSpaceRendererVertexShader",YC=`precision highp float;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;uniform mat4 projMatrix;varying vec2 vDecalTC;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<instancesDeclaration>
void main(void) {vec3 positionUpdated=position;vec3 normalUpdated=normal;
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);mat3 normWorldSM=mat3(finalWorld);vec3 vNormalW;
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vNormalW=normalUpdated/vec3(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));vNormalW=normalize(normWorldSM*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normWorldSM=transposeMat3(inverseMat3(normWorldSM));
#endif
vNormalW=normalize(normWorldSM*normalUpdated);
#endif
vec3 normalView=normalize((projMatrix*vec4(vNormalW,0.0)).xyz);vec3 decalTC=(projMatrix*worldPos).xyz;vDecalTC=decalTC.xy;gl_Position=vec4(uv*2.0-1.0,normalView.z>0.0 ? 2. : decalTC.z,1.0);}`;P.ShadersStore[gd]||(P.ShadersStore[gd]=YC);const pB={name:gd,shader:YC},GW=Object.freeze(Object.defineProperty({__proto__:null,meshUVSpaceRendererVertexShader:pB},Symbol.toStringTag,{value:"Module"})),xd="meshUVSpaceRendererPixelShader",XC=`precision highp float;varying vec2 vDecalTC;uniform sampler2D textureSampler;void main(void) {if (vDecalTC.x<0. || vDecalTC.x>1. || vDecalTC.y<0. || vDecalTC.y>1.) {discard;}
gl_FragColor=texture2D(textureSampler,vDecalTC);}
`;P.ShadersStore[xd]||(P.ShadersStore[xd]=XC);const mB={name:xd,shader:XC},WW=Object.freeze(Object.defineProperty({__proto__:null,meshUVSpaceRendererPixelShader:mB},Symbol.toStringTag,{value:"Module"})),Sd="meshUVSpaceRendererMaskerVertexShader",ZC="attribute vec2 uv;varying vec2 vUV;void main(void) {gl_Position=vec4(vec2(uv.x,uv.y)*2.0-1.0,0.,1.0);vUV=uv;}";P.ShadersStore[Sd]||(P.ShadersStore[Sd]=ZC);const _B={name:Sd,shader:ZC},$W=Object.freeze(Object.defineProperty({__proto__:null,meshUVSpaceRendererMaskerVertexShader:_B},Symbol.toStringTag,{value:"Module"})),vd="meshUVSpaceRendererMaskerPixelShader",qC=`varying vec2 vUV;void main(void) {gl_FragColor=vec4(1.0,1.0,1.0,1.0);}
`;P.ShadersStore[vd]||(P.ShadersStore[vd]=qC);const gB={name:vd,shader:qC},HW=Object.freeze(Object.defineProperty({__proto__:null,meshUVSpaceRendererMaskerPixelShader:gB},Symbol.toStringTag,{value:"Module"})),bd="meshUVSpaceRendererFinaliserPixelShader",QC=`precision highp float;varying vec2 vUV;uniform sampler2D textureSampler;uniform sampler2D maskTextureSampler;uniform vec2 textureSize;void main() {vec4 mask=texture2D(maskTextureSampler,vUV).rgba;if (mask.r>0.5) {gl_FragColor=texture2D(textureSampler,vUV);} else {vec2 texelSize=4.0/textureSize;vec2 uv_p01=vUV+vec2(-1.0,0.0)*texelSize;vec2 uv_p21=vUV+vec2(1.0,0.0)*texelSize;vec2 uv_p10=vUV+vec2(0.0,-1.0)*texelSize;vec2 uv_p12=vUV+vec2(0.0,1.0)*texelSize;float mask_p01=texture2D(maskTextureSampler,uv_p01).r;float mask_p21=texture2D(maskTextureSampler,uv_p21).r;float mask_p10=texture2D(maskTextureSampler,uv_p10).r;float mask_p12=texture2D(maskTextureSampler,uv_p12).r;vec4 col=vec4(0.0,0.0,0.0,0.0);float total_weight=0.0;if (mask_p01>0.5) {col+=texture2D(textureSampler,uv_p01);total_weight+=1.0;}
if (mask_p21>0.5) {col+=texture2D(textureSampler,uv_p21);total_weight+=1.0;}
if (mask_p10>0.5) {col+=texture2D(textureSampler,uv_p10);total_weight+=1.0;}
if (mask_p12>0.5) {col+=texture2D(textureSampler,uv_p12);total_weight+=1.0;}
if (total_weight>0.0) {gl_FragColor=col/total_weight;} else {gl_FragColor=col;}}}
`;P.ShadersStore[bd]||(P.ShadersStore[bd]=QC);const xB={name:bd,shader:QC},jW=Object.freeze(Object.defineProperty({__proto__:null,meshUVSpaceRendererFinaliserPixelShader:xB},Symbol.toStringTag,{value:"Module"})),yd="meshUVSpaceRendererFinaliserVertexShader",KC=`precision highp float;attribute vec3 position;attribute vec2 uv;uniform mat4 worldViewProjection;varying vec2 vUV;void main() {gl_Position=worldViewProjection*vec4(position,1.0);vUV=uv;}
`;P.ShadersStore[yd]||(P.ShadersStore[yd]=KC);const SB={name:yd,shader:KC},YW=Object.freeze(Object.defineProperty({__proto__:null,meshUVSpaceRendererFinaliserVertexShader:SB},Symbol.toStringTag,{value:"Module"})),Td="meshUVSpaceRendererVertexShader",JC=`attribute position: vec3f;attribute normal: vec3f;attribute uv: vec2f;uniform projMatrix: mat4x4f;varying vDecalTC: vec2f;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<instancesDeclaration>
@vertex
fn main(input : VertexInputs)->FragmentInputs {var positionUpdated: vec3f=input.position;var normalUpdated: vec3f=input.normal;
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
var worldPos: vec4f=finalWorld* vec4f(positionUpdated,1.0);var normWorldSM: mat3x3f= mat3x3f(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz);var vNormalW: vec3f;
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vNormalW=normalUpdated/ vec3f(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));vNormalW=normalize(normWorldSM*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normWorldSM=transposeMat3(inverseMat3(normWorldSM));
#endif
vNormalW=normalize(normWorldSM*normalUpdated);
#endif
var normalView: vec3f=normalize((uniforms.projMatrix* vec4f(vNormalW,0.0)).xyz);var decalTC: vec3f=(uniforms.projMatrix*worldPos).xyz;vertexOutputs.vDecalTC=decalTC.xy;vertexOutputs.position=vec4f(input.uv*2.0-1.0,select(decalTC.z,2.,normalView.z>0.0),1.0);}`;P.ShadersStoreWGSL[Td]||(P.ShadersStoreWGSL[Td]=JC);const vB={name:Td,shader:JC},XW=Object.freeze(Object.defineProperty({__proto__:null,meshUVSpaceRendererVertexShaderWGSL:vB},Symbol.toStringTag,{value:"Module"})),Cd="meshUVSpaceRendererPixelShader",eP=`varying vDecalTC: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {if (input.vDecalTC.x<0. || input.vDecalTC.x>1. || input.vDecalTC.y<0. || input.vDecalTC.y>1.) {discard;}
fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,input.vDecalTC);}
`;P.ShadersStoreWGSL[Cd]||(P.ShadersStoreWGSL[Cd]=eP);const bB={name:Cd,shader:eP},ZW=Object.freeze(Object.defineProperty({__proto__:null,meshUVSpaceRendererPixelShaderWGSL:bB},Symbol.toStringTag,{value:"Module"})),Pd="meshUVSpaceRendererMaskerVertexShader",tP=`attribute uv: vec2f;varying vUV: vec2f;@vertex
fn main(input : VertexInputs)->FragmentInputs {vertexOutputs.position= vec4f( vec2f(input.uv.x,input.uv.y)*2.0-1.0,0.,1.0);vertexOutputs.vUV=input.uv;}`;P.ShadersStoreWGSL[Pd]||(P.ShadersStoreWGSL[Pd]=tP);const yB={name:Pd,shader:tP},qW=Object.freeze(Object.defineProperty({__proto__:null,meshUVSpaceRendererMaskerVertexShaderWGSL:yB},Symbol.toStringTag,{value:"Module"})),Ed="meshUVSpaceRendererMaskerPixelShader",iP=`varying vUV: vec2f;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color= vec4f(1.0,1.0,1.0,1.0);}
`;P.ShadersStoreWGSL[Ed]||(P.ShadersStoreWGSL[Ed]=iP);const TB={name:Ed,shader:iP},QW=Object.freeze(Object.defineProperty({__proto__:null,meshUVSpaceRendererMaskerPixelShaderWGSL:TB},Symbol.toStringTag,{value:"Module"})),Id="meshUVSpaceRendererFinaliserPixelShader",rP=`#define DISABLE_UNIFORMITY_ANALYSIS
varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var maskTextureSamplerSampler: sampler;var maskTextureSampler: texture_2d<f32>;uniform textureSize: vec2f;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var mask: vec4f=textureSample(maskTextureSampler,maskTextureSamplerSampler,input.vUV).rgba;if (mask.r>0.5) {fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,input.vUV);} else {var texelSize: vec2f=4.0/uniforms.textureSize;var uv_p01: vec2f=input.vUV+ vec2f(-1.0,0.0)*texelSize;var uv_p21: vec2f=input.vUV+ vec2f(1.0,0.0)*texelSize;var uv_p10: vec2f=input.vUV+ vec2f(0.0,-1.0)*texelSize;var uv_p12: vec2f=input.vUV+ vec2f(0.0,1.0)*texelSize;var mask_p01: f32=textureSample(maskTextureSampler,maskTextureSamplerSampler,uv_p01).r;var mask_p21: f32=textureSample(maskTextureSampler,maskTextureSamplerSampler,uv_p21).r;var mask_p10: f32=textureSample(maskTextureSampler,maskTextureSamplerSampler,uv_p10).r;var mask_p12: f32=textureSample(maskTextureSampler,maskTextureSamplerSampler,uv_p12).r;var col: vec4f= vec4f(0.0,0.0,0.0,0.0);var total_weight: f32=0.0;if (mask_p01>0.5) {col+=textureSample(textureSampler,textureSamplerSampler,uv_p01);total_weight+=1.0;}
if (mask_p21>0.5) {col+=textureSample(textureSampler,textureSamplerSampler,uv_p21);total_weight+=1.0;}
if (mask_p10>0.5) {col+=textureSample(textureSampler,textureSamplerSampler,uv_p10);total_weight+=1.0;}
if (mask_p12>0.5) {col+=textureSample(textureSampler,textureSamplerSampler,uv_p12);total_weight+=1.0;}
if (total_weight>0.0) {fragmentOutputs.color=col/total_weight;} else {fragmentOutputs.color=col;}}}
`;P.ShadersStoreWGSL[Id]||(P.ShadersStoreWGSL[Id]=rP);const CB={name:Id,shader:rP},KW=Object.freeze(Object.defineProperty({__proto__:null,meshUVSpaceRendererFinaliserPixelShaderWGSL:CB},Symbol.toStringTag,{value:"Module"})),Rd="meshUVSpaceRendererFinaliserVertexShader",sP=`attribute position: vec3f;attribute uv: vec2f;uniform worldViewProjection: mat4x4f;varying vUV: vec2f;@vertex
fn main(input : VertexInputs)->FragmentInputs {vertexOutputs.position=uniforms.worldViewProjection* vec4f(input.position,1.0);vertexOutputs.positionvUV=input.uv;}
`;P.ShadersStoreWGSL[Rd]||(P.ShadersStoreWGSL[Rd]=sP);const PB={name:Rd,shader:sP},JW=Object.freeze(Object.defineProperty({__proto__:null,meshUVSpaceRendererFinaliserVertexShaderWGSL:PB},Symbol.toStringTag,{value:"Module"}));var cv;(function(a){a[a.INIT=0]="INIT",a[a.RUNNING=1]="RUNNING",a[a.DONE=2]="DONE",a[a.ERROR=3]="ERROR"})(cv||(cv={}));class _s{constructor(e){this.name=e,this._isCompleted=!1,this._taskState=0}get isCompleted(){return this._isCompleted}get taskState(){return this._taskState}get errorObject(){return this._errorObject}_setErrorObject(e,t){this._errorObject||(this._errorObject={message:e,exception:t})}run(e,t,i){this._taskState=1,this.runTask(e,()=>{this._onDoneCallback(t,i)},(r,s)=>{this._onErrorCallback(i,r,s)})}runTask(e,t,i){throw new Error("runTask is not implemented")}reset(){this._taskState=0}_onErrorCallback(e,t,i){this._taskState=3,this._errorObject={message:t,exception:i},this.onError&&this.onError(this,t,i),e()}_onDoneCallback(e,t){try{this._taskState=2,this._isCompleted=!0,this.onSuccess&&this.onSuccess(this),e()}catch(i){this._onErrorCallback(t,"Task is done, error executing success callback(s)",i)}}}class EB{constructor(e,t,i){this.remainingCount=e,this.totalCount=t,this.task=i}}class IB extends _s{constructor(e,t,i,r,s){super(e),this.name=e,this.meshesNames=t,this.rootUrl=i,this.sceneFilename=r,this.extension=s}runTask(e,t,i){At.LoadAssetContainer(this.rootUrl,this.sceneFilename,e,r=>{this.loadedContainer=r,this.loadedMeshes=r.meshes,this.loadedTransformNodes=r.transformNodes,this.loadedParticleSystems=r.particleSystems,this.loadedSkeletons=r.skeletons,this.loadedAnimationGroups=r.animationGroups,t()},null,(r,s,n)=>{i(s,n)},this.extension)}}class RB extends _s{constructor(e,t,i,r,s){super(e),this.name=e,this.meshesNames=t,this.rootUrl=i,this.sceneFilename=r,this.extension=s}runTask(e,t,i){At.ImportMesh(this.meshesNames,this.rootUrl,this.sceneFilename,e,(r,s,n,o,l)=>{this.loadedMeshes=r,this.loadedTransformNodes=l,this.loadedParticleSystems=s,this.loadedSkeletons=n,this.loadedAnimationGroups=o,t()},null,(r,s,n)=>{i(s,n)},this.extension)}}class e$ extends _s{constructor(e,t,i,r,s){super(e),this.name=e,this.rootUrl=t,this.filename=i,this.targetConverter=r,this.extension=s}runTask(e,t,i){const r=e.animatables.length,s=e.animationGroups.length;this.loadedAnimatables=[],this.loadedAnimationGroups=[],At.ImportAnimations(this.rootUrl,this.filename,e,!1,3,this.targetConverter,()=>{this.loadedAnimatables=e.animatables.slice(r),this.loadedAnimationGroups=e.animationGroups.slice(s),t()},null,(n,o,l)=>{i(o,l)},this.extension)}}class MB extends _s{constructor(e,t){super(e),this.name=e,this.url=t}runTask(e,t,i){e._loadFile(this.url,r=>{this.text=r,t()},void 0,!1,!1,(r,s)=>{r&&i(r.status+" "+r.statusText,s)})}}class AB extends _s{constructor(e,t){super(e),this.name=e,this.url=t}runTask(e,t,i){e._loadFile(this.url,r=>{this.data=r,t()},void 0,!0,!0,(r,s)=>{r&&i(r.status+" "+r.statusText,s)})}}class DB extends _s{constructor(e,t){super(e),this.name=e,this.url=t}runTask(e,t,i){const r=new Image;ae.SetCorsBehavior(this.url,r),r.onload=()=>{this.image=r,t()},r.onerror=s=>{i("Error loading image",s)},r.src=this.url}}class OB extends _s{constructor(e,t,i,r=!0,s=Y.TRILINEAR_SAMPLINGMODE){super(e),this.name=e,this.url=t,this.noMipmap=i,this.invertY=r,this.samplingMode=s}runTask(e,t,i){const r=()=>{t()},s=(n,o)=>{i(n,o)};this.texture=new Y(this.url,e,this.noMipmap,this.invertY,this.samplingMode,r,s)}}class wB extends _s{constructor(e,t,i,r,s,n){super(e),this.name=e,this.url=t,this.extensions=i,this.noMipmap=r,this.files=s,this.prefiltered=n}runTask(e,t,i){const r=()=>{t()},s=(n,o)=>{i(n,o)};this.texture=new rn(this.url,e,this.extensions,this.noMipmap,this.files,r,s,void 0,this.prefiltered)}}class NB extends _s{constructor(e,t,i,r=!1,s=!0,n=!1,o=!1){super(e),this.name=e,this.url=t,this.size=i,this.noMipmap=r,this.generateHarmonics=s,this.gammaSpace=n,this.reserved=o}runTask(e,t,i){const r=()=>{t()},s=(n,o)=>{i(n,o)};this.texture=new an(this.url,e,this.size,this.noMipmap,this.generateHarmonics,this.gammaSpace,this.reserved,r,s)}}class FB extends _s{constructor(e,t,i,r=!1,s=!0){super(e),this.name=e,this.url=t,this.size=i,this.noMipmap=r,this.gammaSpace=s}runTask(e,t,i){const r=()=>{t()},s=(n,o)=>{i(n,o)};this.texture=new Yo(this.url,e,this.size,this.noMipmap,this.gammaSpace,r,s)}}class t${constructor(e){this._isLoading=!1,this._tasks=new Array,this._waitingTasksCount=0,this._totalTasksCount=0,this.onTaskSuccessObservable=new j,this.onTaskErrorObservable=new j,this.onTasksDoneObservable=new j,this.onProgressObservable=new j,this.useDefaultLoadingScreen=!0,this.autoHideLoadingUI=!0,this._scene=e||ze.LastCreatedScene}addContainerTask(e,t,i,r,s){const n=new IB(e,t,i,r,s);return this._tasks.push(n),n}addMeshTask(e,t,i,r,s){const n=new RB(e,t,i,r,s);return this._tasks.push(n),n}addTextFileTask(e,t){const i=new MB(e,t);return this._tasks.push(i),i}addBinaryFileTask(e,t){const i=new AB(e,t);return this._tasks.push(i),i}addImageTask(e,t){const i=new DB(e,t);return this._tasks.push(i),i}addTextureTask(e,t,i,r,s=Y.TRILINEAR_SAMPLINGMODE){const n=new OB(e,t,i,r,s);return this._tasks.push(n),n}addCubeTextureTask(e,t,i,r,s,n){const o=new wB(e,t,i,r,s,n);return this._tasks.push(o),o}addHDRCubeTextureTask(e,t,i,r=!1,s=!0,n=!1,o=!1){const l=new NB(e,t,i,r,s,n,o);return this._tasks.push(l),l}addEquiRectangularCubeTextureAssetTask(e,t,i,r=!1,s=!0){const n=new FB(e,t,i,r,s);return this._tasks.push(n),n}removeTask(e){const t=this._tasks.indexOf(e);t>-1&&this._tasks.splice(t,1)}_decreaseWaitingTasksCount(e){this._waitingTasksCount--;try{this.onProgress&&this.onProgress(this._waitingTasksCount,this._totalTasksCount,e),this.onProgressObservable.notifyObservers(new EB(this._waitingTasksCount,this._totalTasksCount,e))}catch(t){L.Error("Error running progress callbacks."),L.Log(t)}if(this._waitingTasksCount===0){try{const t=this._tasks.slice();this.onFinish&&this.onFinish(t);for(const i of t)if(i.taskState===2){const r=this._tasks.indexOf(i);r>-1&&this._tasks.splice(r,1)}this.onTasksDoneObservable.notifyObservers(this._tasks)}catch(t){L.Error("Error running tasks-done callbacks."),L.Log(t)}this._isLoading=!1,this.autoHideLoadingUI&&this._scene.getEngine().hideLoadingUI()}}_runTask(e){const t=()=>{try{this.onTaskSuccess&&this.onTaskSuccess(e),this.onTaskSuccessObservable.notifyObservers(e),this._decreaseWaitingTasksCount(e)}catch(r){i("Error executing task success callbacks",r)}},i=(r,s)=>{e._setErrorObject(r,s),this.onTaskError?this.onTaskError(e):e.onError||L.Error(this._formatTaskErrorMessage(e)),this.onTaskErrorObservable.notifyObservers(e),this._decreaseWaitingTasksCount(e)};e.run(this._scene,t,i)}_formatTaskErrorMessage(e){let t="Unable to complete task "+e.name;return e.errorObject.message&&(t+=`: ${e.errorObject.message}`),e.errorObject.exception&&(t+=`: ${e.errorObject.exception}`),t}reset(){return this._isLoading=!1,this._tasks=new Array,this}load(){if(this._isLoading)return this;if(this._isLoading=!0,this._waitingTasksCount=this._tasks.length,this._totalTasksCount=this._tasks.length,this._waitingTasksCount===0)return this._isLoading=!1,this.onFinish&&this.onFinish(this._tasks),this.onTasksDoneObservable.notifyObservers(this._tasks),this;this.useDefaultLoadingScreen&&this._scene.getEngine().displayLoadingUI();for(let e=0;e<this._tasks.length;e++){const t=this._tasks[e];t.taskState===0&&this._runTask(t)}return this}loadAsync(){return new Promise((e,t)=>{if(this._isLoading){e();return}this.onTasksDoneObservable.addOnce(i=>{i&&i.length?t(i):e()}),this.load()})}}class nP{dispose(){if(this._observers&&this._observables)for(let e=0;e<this._observers.length;e++)this._observables[e].remove(this._observers[e]);this._observers=null,this._observables=null}static Watch(e,t,i=-1,r=null){const s=new nP;s._observers=new Array,s._observables=e;for(const n of e){const o=n.add(t,i,!1,r);o&&s._observers.push(o)}return s}}j.prototype.notifyObserversWithPromise=async function(a,e=-1,t,i,r){let s=Promise.resolve(a);if(!this.observers.length)return s;const n=this._eventState;return n.mask=e,n.target=t,n.currentTarget=i,n.skipNextObservers=!1,n.userInfo=r,this.observers.forEach(o=>{n.skipNextObservers||o._willBeUnregistered||o.mask&e&&(o.scope?s=s.then(l=>(n.lastReturnValue=l,o.callback.apply(o.scope,[a,n]))):s=s.then(l=>(n.lastReturnValue=l,o.callback(a,n))),o.unregisterOnNextCall&&this._deferUnregister(o))}),await s,a};class Bs{getDescription(){return""}apply(e,t){return!0}constructor(e=0){this.priority=e}}class Uc extends Bs{getDescription(){return"Reducing render target texture size to "+this.maximumSize}constructor(e=0,t=1024,i=.5){super(e),this.priority=e,this.maximumSize=t,this.step=i}apply(e,t){let i=!0;for(let r=0;r<e.textures.length;r++){const s=e.textures[r];if(!s.canRescale||s.getContext)continue;const n=s.getSize();Math.max(n.width,n.height)>this.maximumSize&&(s.scale(this.step),i=!1)}return i}}class hv extends Bs{getDescription(){return"Setting hardware scaling level to "+this._currentScale}constructor(e=0,t=2,i=.25){super(e),this.priority=e,this.maximumScale=t,this.step=i,this._currentScale=-1,this._directionOffset=1}apply(e,t){return this._currentScale===-1&&(this._currentScale=e.getEngine().getHardwareScalingLevel(),this._currentScale>this.maximumScale&&(this._directionOffset=-1)),this._currentScale+=this._directionOffset*this.step,this._currentScale=Math.min(this.maximumScale,this._currentScale),e.getEngine().setHardwareScalingLevel(this._currentScale),this._directionOffset===1?this._currentScale>=this.maximumScale:this._currentScale<=this.maximumScale}}class Gc extends Bs{getDescription(){return"Turning shadows on/off"}apply(e,t){return e.shadowsEnabled=t.isInImprovementMode,!0}}class Wc extends Bs{getDescription(){return"Turning post-processes on/off"}apply(e,t){return e.postProcessesEnabled=t.isInImprovementMode,!0}}class $c extends Bs{getDescription(){return"Turning lens flares on/off"}apply(e,t){return e.lensFlaresEnabled=t.isInImprovementMode,!0}}class LB extends Bs{getDescription(){return this.onGetDescription?this.onGetDescription():"Running user defined callback"}apply(e,t){return this.onApply?this.onApply(e,t):!0}}class Hc extends Bs{getDescription(){return"Turning particles on/off"}apply(e,t){return e.particlesEnabled=t.isInImprovementMode,!0}}class dv extends Bs{getDescription(){return"Turning render targets off"}apply(e,t){return e.renderTargetsEnabled=t.isInImprovementMode,!0}}class on extends Bs{constructor(){super(...arguments),this._canBeMerged=e=>{if(!(e instanceof z))return!1;const t=e;return!(t.isDisposed()||!t.isVisible||!t.isEnabled()||t.instances.length>0||t.skeleton||t.hasLODLevels||t.getTotalVertices()===0)}}static get UpdateSelectionTree(){return on._UpdateSelectionTree}static set UpdateSelectionTree(e){on._UpdateSelectionTree=e}getDescription(){return"Merging similar meshes together"}apply(e,t,i){const r=e.meshes.slice(0);let s=r.length;for(let o=0;o<s;o++){const l=[],u=r[o];if(this._canBeMerged(u)){l.push(u);for(let c=o+1;c<s;c++){const h=r[c];this._canBeMerged(h)&&h.material===u.material&&h.checkCollisions===u.checkCollisions&&(l.push(h),s--,r.splice(c,1),c--)}l.length<2||z.MergeMeshes(l,void 0,!0)}}const n=e;return n.createOrUpdateSelectionOctree&&(i!=null?i&&n.createOrUpdateSelectionOctree():on.UpdateSelectionTree&&n.createOrUpdateSelectionOctree()),!0}}on._UpdateSelectionTree=!1;class Ia{constructor(e=60,t=2e3){this.targetFrameRate=e,this.trackerDuration=t,this.optimizations=[]}addOptimization(e){return this.optimizations.push(e),this}addCustomOptimization(e,t,i=0){const r=new LB(i);return r.onApply=e,r.onGetDescription=t,this.optimizations.push(r),this}static LowDegradationAllowed(e){const t=new Ia(e);let i=0;return t.addOptimization(new on(i)),t.addOptimization(new Gc(i)),t.addOptimization(new $c(i)),i++,t.addOptimization(new Wc(i)),t.addOptimization(new Hc(i)),i++,t.addOptimization(new Uc(i,1024)),t}static ModerateDegradationAllowed(e){const t=new Ia(e);let i=0;return t.addOptimization(new on(i)),t.addOptimization(new Gc(i)),t.addOptimization(new $c(i)),i++,t.addOptimization(new Wc(i)),t.addOptimization(new Hc(i)),i++,t.addOptimization(new Uc(i,512)),i++,t.addOptimization(new dv(i)),i++,t.addOptimization(new hv(i,2)),t}static HighDegradationAllowed(e){const t=new Ia(e);let i=0;return t.addOptimization(new on(i)),t.addOptimization(new Gc(i)),t.addOptimization(new $c(i)),i++,t.addOptimization(new Wc(i)),t.addOptimization(new Hc(i)),i++,t.addOptimization(new Uc(i,256)),i++,t.addOptimization(new dv(i)),i++,t.addOptimization(new hv(i,4)),t}}class aP{get isInImprovementMode(){return this._improvementMode}set isInImprovementMode(e){this._improvementMode=e}get currentPriorityLevel(){return this._currentPriorityLevel}get currentFrameRate(){return this._currentFrameRate}get targetFrameRate(){return this._targetFrameRate}set targetFrameRate(e){this._targetFrameRate=e}get trackerDuration(){return this._trackerDuration}set trackerDuration(e){this._trackerDuration=e}get optimizations(){return this._options.optimizations}constructor(e,t,i=!0,r=!1){if(this._isRunning=!1,this._currentPriorityLevel=0,this._targetFrameRate=60,this._trackerDuration=2e3,this._currentFrameRate=0,this._improvementMode=!1,this.onSuccessObservable=new j,this.onNewOptimizationAppliedObservable=new j,this.onFailureObservable=new j,t?this._options=t:this._options=new Ia,this._options.targetFrameRate&&(this._targetFrameRate=this._options.targetFrameRate),this._options.trackerDuration&&(this._trackerDuration=this._options.trackerDuration),i){let s=0;for(const n of this._options.optimizations)n.priority=s++}this._improvementMode=r,this._scene=e||ze.LastCreatedScene,this._sceneDisposeObserver=this._scene.onDisposeObservable.add(()=>{this._sceneDisposeObserver=null,this.dispose()})}stop(){this._isRunning=!1}reset(){this._currentPriorityLevel=0}start(){this._isRunning||(this._isRunning=!0,this._scene.executeWhenReady(()=>{setTimeout(()=>{this._checkCurrentState()},this._trackerDuration)}))}_checkCurrentState(){if(!this._isRunning)return;const e=this._scene,t=this._options;if(this._currentFrameRate=Math.round(e.getEngine().getFps()),this._improvementMode&&this._currentFrameRate<=this._targetFrameRate||!this._improvementMode&&this._currentFrameRate>=this._targetFrameRate){this._isRunning=!1,this.onSuccessObservable.notifyObservers(this);return}let i=!0,r=!0;for(let s=0;s<t.optimizations.length;s++){const n=t.optimizations[s];n.priority===this._currentPriorityLevel&&(r=!1,i=i&&n.apply(e,this),this.onNewOptimizationAppliedObservable.notifyObservers(n))}if(r){this._isRunning=!1,this.onFailureObservable.notifyObservers(this);return}i&&this._currentPriorityLevel++,e.executeWhenReady(()=>{setTimeout(()=>{this._checkCurrentState()},this._trackerDuration)})}dispose(){this.stop(),this.onSuccessObservable.clear(),this.onFailureObservable.clear(),this.onNewOptimizationAppliedObservable.clear(),this._sceneDisposeObserver&&this._scene.onDisposeObservable.remove(this._sceneDisposeObserver)}static OptimizeAsync(e,t,i,r){const s=new aP(e,t||Ia.ModerateDegradationAllowed(),!1);return i&&s.onSuccessObservable.add(()=>{i()}),r&&s.onFailureObservable.add(()=>{r()}),s.start(),s}}let Md=[];const q_=(a,e)=>{a.doNotSerialize||(e.vertexData.push(a.serializeVerticeData()),Md[a.id]=!0)},oP=(a,e)=>{const t={},i=a._geometry;return i&&(a.getScene().getGeometryById(i.id)||q_(i,e.geometries)),a.serialize&&a.serialize(t),t},BB=(a,e)=>{if(a._isMesh){const t=a;if(t.delayLoadState===1||t.delayLoadState===0){const i=s=>{e.materials=e.materials||[],t.material&&!e.materials.some(n=>n.id===t.material.id)&&e.materials.push(s.serialize())};if(t.material&&!t.material.doNotSerialize)if(t.material instanceof xu){if(e.multiMaterials=e.multiMaterials||[],!e.multiMaterials.some(s=>s.id===t.material.id)){e.multiMaterials.push(t.material.serialize());for(const s of t.material.subMaterials)s&&i(s)}}else i(t.material);else t.material||i(t.getScene().defaultMaterial);const r=t._geometry;r&&(e.geometries||(e.geometries={},e.geometries.boxes=[],e.geometries.spheres=[],e.geometries.cylinders=[],e.geometries.toruses=[],e.geometries.grounds=[],e.geometries.planes=[],e.geometries.torusKnots=[],e.geometries.vertexData=[]),q_(r,e.geometries)),t.skeleton&&!t.skeleton.doNotSerialize&&(e.skeletons=e.skeletons||[],e.skeletons.push(t.skeleton.serialize())),e.meshes=e.meshes||[],e.meshes.push(oP(t,e))}}else if(a.getClassName()==="TransformNode"){const t=a;e.transformNodes.push(t.serialize())}else if(a.getClassName().indexOf("Camera")!==-1){const t=a;e.cameras.push(t.serialize())}else if(a.getClassName().indexOf("Light")!==-1){const t=a;e.lights.push(t.serialize())}};class Sa{static ClearCache(){Md=[]}static Serialize(e){return Sa._Serialize(e)}static _Serialize(e,t=!0){const i={};if(t&&!e.getEngine()._features.supportSyncTextureRead&&Y.ForceSerializeBuffers&&L.Warn("The serialization object may not contain the proper base64 encoded texture data! You should use the SerializeAsync method instead."),Sa.ClearCache(),i.useDelayedTextureLoading=e.useDelayedTextureLoading,i.autoClear=e.autoClear,i.clearColor=e.clearColor.asArray(),i.ambientColor=e.ambientColor.asArray(),i.gravity=e.gravity.asArray(),i.collisionsEnabled=e.collisionsEnabled,i.useRightHandedSystem=e.useRightHandedSystem,e.fogMode!==void 0&&e.fogMode!==null&&(i.fogMode=e.fogMode),e.fogColor!==void 0&&e.fogColor!==null&&(i.fogColor=e.fogColor.asArray()),e.fogStart!==void 0&&e.fogStart!==null&&(i.fogStart=e.fogStart),e.fogEnd!==void 0&&e.fogEnd!==null&&(i.fogEnd=e.fogEnd),e.fogDensity!==void 0&&e.fogDensity!==null&&(i.fogDensity=e.fogDensity),e.isPhysicsEnabled&&e.isPhysicsEnabled()){const l=e.getPhysicsEngine();l&&(i.physicsEnabled=!0,i.physicsGravity=l.gravity.asArray(),i.physicsEngine=l.getPhysicsPluginName())}e.metadata&&(i.metadata=e.metadata),i.morphTargetManagers=[];for(const l of e.meshes){const u=l.morphTargetManager;u&&i.morphTargetManagers.push(u.serialize())}i.lights=[];let r,s;for(r=0;r<e.lights.length;r++)s=e.lights[r],s.doNotSerialize||i.lights.push(s.serialize());for(i.cameras=[],r=0;r<e.cameras.length;r++){const l=e.cameras[r];l.doNotSerialize||i.cameras.push(l.serialize())}if(e.activeCamera&&(i.activeCameraID=e.activeCamera.id),Me.AppendSerializedAnimations(e,i),e.animationGroups&&e.animationGroups.length>0){i.animationGroups=[];for(let l=0;l<e.animationGroups.length;l++){const u=e.animationGroups[l];i.animationGroups.push(u.serialize())}}if(e.reflectionProbes&&e.reflectionProbes.length>0)for(i.reflectionProbes=[],r=0;r<e.reflectionProbes.length;r++){const l=e.reflectionProbes[r];i.reflectionProbes.push(l.serialize())}i.materials=[],i.multiMaterials=[];let n;for(r=0;r<e.materials.length;r++)n=e.materials[r],n.doNotSerialize||i.materials.push(n.serialize());for(i.multiMaterials=[],r=0;r<e.multiMaterials.length;r++){const l=e.multiMaterials[r];i.multiMaterials.push(l.serialize())}for(e.environmentTexture&&(e.environmentTexture._files?i.environmentTexture=e.environmentTexture.serialize():(i.environmentTexture=e.environmentTexture.name,i.environmentTextureRotationY=e.environmentTexture.rotationY)),i.environmentIntensity=e.environmentIntensity,i.iblIntensity=e.iblIntensity,i.skeletons=[],r=0;r<e.skeletons.length;r++){const l=e.skeletons[r];l.doNotSerialize||i.skeletons.push(l.serialize())}for(i.transformNodes=[],r=0;r<e.transformNodes.length;r++)e.transformNodes[r].doNotSerialize||i.transformNodes.push(e.transformNodes[r].serialize());i.geometries={},i.geometries.boxes=[],i.geometries.spheres=[],i.geometries.cylinders=[],i.geometries.toruses=[],i.geometries.grounds=[],i.geometries.planes=[],i.geometries.torusKnots=[],i.geometries.vertexData=[],Md=[];const o=e.getGeometries();for(r=0;r<o.length;r++){const l=o[r];l.isReady()&&q_(l,i.geometries)}for(i.meshes=[],r=0;r<e.meshes.length;r++){const l=e.meshes[r];if(l instanceof z){const u=l;u.doNotSerialize||(u.delayLoadState===1||u.delayLoadState===0)&&i.meshes.push(oP(u,i))}}for(i.particleSystems=[],r=0;r<e.particleSystems.length;r++)i.particleSystems.push(e.particleSystems[r].serialize(!1));for(i.postProcesses=[],r=0;r<e.postProcesses.length;r++)i.postProcesses.push(e.postProcesses[r].serialize());e.actionManager&&(i.actions=e.actionManager.serialize("scene"));for(const l of e._serializableComponents)l.serialize(i);if(e.spriteManagers)for(i.spriteManagers=[],r=0;r<e.spriteManagers.length;r++)i.spriteManagers.push(e.spriteManagers[r].serialize(!0));return i}static SerializeAsync(e){const t=Sa._Serialize(e,!1),i=[];return this._CollectPromises(t,i),Promise.all(i).then(()=>t)}static _CollectPromises(e,t){if(Array.isArray(e))for(let i=0;i<e.length;++i){const r=e[i];r instanceof Promise?t.push(r.then(s=>e[i]=s)):(r instanceof Object||Array.isArray(r))&&this._CollectPromises(r,t)}else if(e instanceof Object){for(const i in e)if(Object.prototype.hasOwnProperty.call(e,i)){const r=e[i];r instanceof Promise?t.push(r.then(s=>e[i]=s)):(r instanceof Object||Array.isArray(r))&&this._CollectPromises(r,t)}}}static SerializeMesh(e,t=!1,i=!1){const r={};if(r.meshes=[],r.transformNodes=[],r.cameras=[],r.lights=[],Sa.ClearCache(),e=e instanceof Array?e:[e],t||i)for(let s=0;s<e.length;++s)i&&e[s].getDescendants().forEach(n=>{e.indexOf(n)<0&&!n.doNotSerialize&&e.push(n)}),t&&e[s].parent&&e.indexOf(e[s].parent)<0&&!e[s].parent.doNotSerialize&&e.push(e[s].parent);return e.forEach(s=>{BB(s,r)}),r}}class nu{static IsSupported(e,t){const i=t??e.getRenderingCanvas();return!!i&&typeof i.captureStream=="function"}get isRecording(){return!!this._canvas&&this._isRecording}constructor(e,t={}){if(!nu.IsSupported(e,t.canvas))throw"Your browser does not support recording so far.";const i=t.canvas??e.getRenderingCanvas();if(!i)throw"The babylon engine must have a canvas to be recorded";this._canvas=i,this._isRecording=!1,this._options={...nu._DefaultOptions,...t};const r=this._canvas.captureStream(this._options.fps);if(this._options.audioTracks)for(const s of this._options.audioTracks)r.addTrack(s);this._mediaRecorder=new MediaRecorder(r,{mimeType:this._options.mimeType}),this._mediaRecorder.ondataavailable=s=>this._handleDataAvailable(s),this._mediaRecorder.onerror=s=>this._handleError(s),this._mediaRecorder.onstop=()=>this._handleStop()}stopRecording(){!this._canvas||!this._mediaRecorder||this.isRecording&&(this._isRecording=!1,this._mediaRecorder.stop())}startRecording(e="babylonjs.webm",t=7){if(!this._canvas||!this._mediaRecorder)throw"Recorder has already been disposed";if(this.isRecording)throw"Recording already in progress";return t>0&&setTimeout(()=>{this.stopRecording()},t*1e3),this._fileName=e,this._recordedChunks=[],this._resolve=null,this._reject=null,this._isRecording=!0,this._mediaRecorder.start(this._options.recordChunckSize),new Promise((i,r)=>{this._resolve=i,this._reject=r})}dispose(){this._canvas=null,this._mediaRecorder=null,this._recordedChunks=[],this._fileName=null,this._resolve=null,this._reject=null}_handleDataAvailable(e){e.data.size>0&&this._recordedChunks.push(e.data)}_handleError(e){if(this.stopRecording(),this._reject)this._reject(e.error);else throw new e.error}_handleStop(){this.stopRecording();const e=new Blob(this._recordedChunks);this._resolve&&this._resolve(e),window.URL.createObjectURL(e),this._fileName&&ae.Download(e,this._fileName)}}nu._DefaultOptions={mimeType:"video/webm",fps:25,recordChunckSize:3e3};class lo extends Ce{getClassName(){return"FxaaPostProcess"}constructor(e,t,i=null,r,s,n,o=0){super(e,"fxaa",["texelSize"],null,t,i,r||Y.BILINEAR_SAMPLINGMODE,s,n,null,o,"fxaa",void 0,!0);const l=this._getDefines();this.updateEffect(l),this.onApplyObservable.add(u=>{const c=this.texelSize;u.setFloat2("texelSize",c.x,c.y)})}_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(Promise.all([k(()=>Promise.resolve().then(()=>pk),void 0),k(()=>Promise.resolve().then(()=>_k),void 0)]))):t.push(Promise.all([k(()=>Promise.resolve().then(()=>ck),void 0),k(()=>Promise.resolve().then(()=>dk),void 0)])),super._gatherImports(e,t)}_getDefines(){const e=this.getEngine();return e&&e.extractDriverInfo().toLowerCase().indexOf("mali")>-1?`#define MALI 1
`:null}static _Parse(e,t,i,r){return Me.Parse(()=>new lo(e.name,e.options,t,e.renderTargetSamplingMode,i.getEngine(),e.reusable),e,i,r)}}B("BABYLON.FxaaPostProcess",lo);let Ss=null;function nc(a,e,t,i,r="image/png",s=!1,n,o=!1){const{height:l,width:u}=cP(a,e,t);if(!(l&&u)){L.Error("Invalid 'size' parameter !");return}if(e.getScene().activeCamera!==e){ac(a,e,t,h=>{if(s){const d=new Blob([h]);ae.DownloadBlob(d),i&&i("")}else i&&i(h)},r,1,a.getCreationOptions().antialias,void 0,void 0,void 0,void 0,n);return}a.onEndFrameObservable.addOnce(()=>{Ss||(Ss=document.createElement("canvas")),Ss.width=u,Ss.height=l;const h=Ss.getContext("2d"),d=a.getRenderingCanvas();if(!h||!d){L.Error("Failed to create screenshot. Rendering context or rendering canvas is not available.");return}const f=d.width,p=d.height,g=Ss.width,_=Ss.height,S=g/f,b=_/p,y=o?Math.max(S,b):Math.min(S,b),T=f*y,v=p*y,E=(g-T)/2,R=(_-v)/2;h.drawImage(d,0,0,f,p,E,R,T,v),s?(ae.EncodeScreenshotCanvasData(Ss,void 0,r,void 0,n),i&&i("")):ae.EncodeScreenshotCanvasData(Ss,i,r,void 0,n)})}function lP(a,e,t,i="image/png",r,s=!1){return new Promise((n,o)=>{nc(a,e,t,l=>{typeof l<"u"?n(l):o(new Error("Data is undefined"))},i,void 0,r,s)})}function VB(a,e,t,i,r="image/png",s,n=!1){return new Promise(o=>{nc(a,e,{width:t,height:i},()=>{o()},r,!0,s,n)})}function ac(a,e,t,i,r="image/png",s=1,n=!1,o,l=!1,u=!1,c=!0,h,d,f){const{height:p,width:g,finalWidth:_,finalHeight:S}=cP(a,e,t),b={width:g,height:p};if(!(p&&g)){L.Error("Invalid 'size' parameter !");return}a.skipFrameRender=!0;const y=a.getRenderWidth,T=a.getRenderHeight;a.getRenderWidth=(M=!1)=>!M&&a._currentRenderTarget?a._currentRenderTarget.width:g,a.getRenderHeight=(M=!1)=>!M&&a._currentRenderTarget?a._currentRenderTarget.height:p,a.onResizeObservable.hasObservers()&&a.onResizeObservable.notifyObservers(a);const v=e.getScene(),E=new Kt("screenShot",b,v,!1,!1,0,!1,Y.BILINEAR_SAMPLINGMODE,void 0,u,void 0,void 0,void 0,s);E.renderList=v.meshes.slice(),E.samples=s,E.renderSprites=l,E.activeCamera=e,E.forceLayerMaskCheck=c,d==null||d(E);const R=f||NM,O=()=>{du(()=>E.isReadyForRendering()&&e.isReady(!0),()=>{a.onEndFrameObservable.addOnce(()=>{_===g&&S===p?E.readPixels(void 0,void 0,void 0,!1).then(ee=>{R(g,p,ee,i,r,o,!0,void 0,h),E.dispose()}):(a.isWebGPU?k(()=>import("./pass.fragment-B8b0gssu.js"),__vite__mapDeps([22,1,2,3,4,5])):k(()=>import("./pass.fragment-D7l-dmRx.js"),__vite__mapDeps([23,1,2,3,4,5]))).then(()=>FM("pass",E.getInternalTexture(),v,void 0,void 0,void 0,_,S).then(oe=>{a._readTexturePixels(oe,_,S,-1,0,null,!0,!1,0,0).then(_e=>{R(_,S,_e,i,r,o,!0,void 0,h),oe.dispose()})}))}),v.incrementRenderId(),v.resetCachedMaterial();const M=v.activeCamera,G=v.activeCameras,H=e.outputRenderTarget,q=v.spritesEnabled;v.activeCamera=e,v.activeCameras=null,e.outputRenderTarget=E,v.spritesEnabled=l;const X=v.meshes;v.meshes=E.renderList||v.meshes;try{v.render()}finally{v.activeCamera=M,v.activeCameras=G,e.outputRenderTarget=H,v.spritesEnabled=q,v.meshes=X,a.getRenderWidth=y,a.getRenderHeight=T,a.onResizeObservable.hasObservers()&&a.onResizeObservable.notifyObservers(a),e.getProjectionMatrix(!0),a.skipFrameRender=!1}},()=>{a.skipFrameRender=!1,a.getRenderWidth=y,a.getRenderHeight=T})},w=()=>{v.incrementRenderId(),v.resetCachedMaterial(),O()};if(n){const M=new lo("antialiasing",1,v.activeCamera);E.addPostProcess(M),M.onEffectCreatedObservable.addOnce(G=>{G.isReady()?w():G.onCompiled=()=>{w()}})}else w()}function uP(a,e,t,i="image/png",r=1,s=!1,n,o=!1,l=!1,u=!0,c,h,d){return new Promise((f,p)=>{ac(a,e,t,g=>{typeof g<"u"?f(g):p(new Error("Data is undefined"))},i,r,s,n,o,l,u,c,h,d)})}function cP(a,e,t){let i=0,r=0,s=0,n=0;if(typeof t=="object"){const o=t.precision?Math.abs(t.precision):1;t.width&&t.height?(i=t.height*o,r=t.width*o):t.width&&!t.height?(r=t.width*o,i=Math.round(r/a.getAspectRatio(e))):t.height&&!t.width?(i=t.height*o,r=Math.round(i*a.getAspectRatio(e))):(r=Math.round(a.getRenderWidth()*o),i=Math.round(r/a.getAspectRatio(e))),t.finalWidth&&t.finalHeight?(n=t.finalHeight,s=t.finalWidth):t.finalWidth&&!t.finalHeight?(s=t.finalWidth,n=Math.round(s/a.getAspectRatio(e))):t.finalHeight&&!t.finalWidth?(n=t.finalHeight,s=Math.round(n*a.getAspectRatio(e))):(s=r,n=i)}else isNaN(t)||(i=t,r=t,s=t,n=t);return r&&(r=Math.floor(r)),i&&(i=Math.floor(i)),s&&(s=Math.floor(s)),n&&(n=Math.floor(n)),{height:i|0,width:r|0,finalWidth:s|0,finalHeight:n|0}}const i$={CreateScreenshot:nc,CreateScreenshotAsync:lP,CreateScreenshotWithResizeAsync:VB,CreateScreenshotUsingRenderTarget:ac,CreateScreenshotUsingRenderTargetAsync:uP},kB=()=>{ae.CreateScreenshot=nc,ae.CreateScreenshotAsync=lP,ae.CreateScreenshotUsingRenderTarget=ac,ae.CreateScreenshotUsingRenderTargetAsync=uP};kB();var fv;(function(a){a[a.Checkbox=0]="Checkbox",a[a.Slider=1]="Slider",a[a.Vector3=2]="Vector3",a[a.Quaternion=3]="Quaternion",a[a.Color3=4]="Color3",a[a.String=5]="String",a[a.Button=6]="Button",a[a.Options=7]="Options",a[a.Tab=8]="Tab",a[a.FileButton=9]="FileButton",a[a.Vector2=10]="Vector2"})(fv||(fv={}));class hP{constructor(e,t,i){this.gradient=e,this.color1=t,this.color2=i}getColorToRef(e){if(!this.color2){e.copyFrom(this.color1);return}xe.LerpToRef(this.color1,this.color2,Math.random(),e)}}class zB{constructor(e,t){this.gradient=e,this.color=t}}class dP{constructor(e,t,i){this.gradient=e,this.factor1=t,this.factor2=i}getFactor(){return this.factor2===void 0||this.factor2===this.factor1?this.factor1:this.factor1+(this.factor2-this.factor1)*Math.random()}}class Wi{static GetCurrentGradient(e,t,i){if(t[0].gradient>e){i(t[0],t[0],1);return}for(let s=0;s<t.length-1;s++){const n=t[s],o=t[s+1];if(e>=n.gradient&&e<=o.gradient){const l=(e-n.gradient)/(o.gradient-n.gradient);i(n,o,l);return}}const r=t.length-1;i(t[r],t[r],1)}}class pv{static _GetStorage(){try{return localStorage.setItem("test",""),localStorage.removeItem("test"),localStorage}catch{const e={};return{getItem:t=>{const i=e[t];return i===void 0?null:i},setItem:(t,i)=>{e[t]=i}}}}static ReadString(e,t){const i=this._Storage.getItem(e);return i!==null?i:t}static WriteString(e,t){this._Storage.setItem(e,t)}static ReadBoolean(e,t){const i=this._Storage.getItem(e);return i!==null?i==="true":t}static WriteBoolean(e,t){this._Storage.setItem(e,t?"true":"false")}static ReadNumber(e,t){const i=this._Storage.getItem(e);return i!==null?parseFloat(i):t}static WriteNumber(e,t){this._Storage.setItem(e,t.toString())}}pv._Storage=pv._GetStorage();class Jo{constructor(e){this.particleSystem=e,this.position=m.Zero(),this.direction=m.Zero(),this.color=new xe(0,0,0,0),this.colorStep=new xe(0,0,0,0),this.lifeTime=1,this.age=0,this.size=0,this.scale=new Q(1,1),this.angle=0,this.angularSpeed=0,this.cellIndex=0,this._attachedSubEmitters=null,this._currentColor1=new xe(0,0,0,0),this._currentColor2=new xe(0,0,0,0),this._currentSize1=0,this._currentSize2=0,this._currentAngularSpeed1=0,this._currentAngularSpeed2=0,this._currentVelocity1=0,this._currentVelocity2=0,this._currentLimitVelocity1=0,this._currentLimitVelocity2=0,this._currentDrag1=0,this._currentDrag2=0,this.id=Jo._Count++,this.particleSystem.isAnimationSheetEnabled&&this._updateCellInfoFromSystem()}_updateCellInfoFromSystem(){this.cellIndex=this.particleSystem.startSpriteCellID}updateCellIndex(){let e=this.age,t=this.particleSystem.spriteCellChangeSpeed;this.particleSystem.spriteRandomStartCell&&(this._randomCellOffset===void 0&&(this._randomCellOffset=Math.random()*this.lifeTime),t===0?(t=1,e=this._randomCellOffset):e+=this._randomCellOffset);const i=this._initialEndSpriteCellID-this._initialStartSpriteCellID+1;let r;this._initialSpriteCellLoop?r=Si(e*t%this.lifeTime/this.lifeTime):r=Si(e*t/this.lifeTime),this.cellIndex=this._initialStartSpriteCellID+r*i|0}_inheritParticleInfoToSubEmitter(e){if(e.particleSystem.emitter.position){const t=e.particleSystem.emitter;if(t.position.copyFrom(this.position),e.inheritDirection){const i=V.Vector3[0];this.direction.normalizeToRef(i),t.setDirection(i,0,Math.PI/2)}}else e.particleSystem.emitter.copyFrom(this.position);this.direction.scaleToRef(e.inheritedVelocityAmount/2,V.Vector3[0]),e.particleSystem._inheritedVelocityOffset.copyFrom(V.Vector3[0])}_inheritParticleInfoToSubEmitters(){this._attachedSubEmitters&&this._attachedSubEmitters.length>0&&this._attachedSubEmitters.forEach(e=>{this._inheritParticleInfoToSubEmitter(e)})}_reset(){this.age=0,this.id=Jo._Count++,this._currentColorGradient=null,this._currentSizeGradient=null,this._currentAngularSpeedGradient=null,this._currentVelocityGradient=null,this._currentLimitVelocityGradient=null,this._currentDragGradient=null,this.cellIndex=this.particleSystem.startSpriteCellID,this._randomCellOffset=void 0}copyTo(e){e.position.copyFrom(this.position),this._initialDirection?e._initialDirection?e._initialDirection.copyFrom(this._initialDirection):e._initialDirection=this._initialDirection.clone():e._initialDirection=null,e.direction.copyFrom(this.direction),this._localPosition&&(e._localPosition?e._localPosition.copyFrom(this._localPosition):e._localPosition=this._localPosition.clone()),e.color.copyFrom(this.color),e.colorStep.copyFrom(this.colorStep),e.lifeTime=this.lifeTime,e.age=this.age,e._randomCellOffset=this._randomCellOffset,e.size=this.size,e.scale.copyFrom(this.scale),e.angle=this.angle,e.angularSpeed=this.angularSpeed,e.particleSystem=this.particleSystem,e.cellIndex=this.cellIndex,e.id=this.id,e._attachedSubEmitters=this._attachedSubEmitters,this._currentColorGradient&&(e._currentColorGradient=this._currentColorGradient,e._currentColor1.copyFrom(this._currentColor1),e._currentColor2.copyFrom(this._currentColor2)),this._currentSizeGradient&&(e._currentSizeGradient=this._currentSizeGradient,e._currentSize1=this._currentSize1,e._currentSize2=this._currentSize2),this._currentAngularSpeedGradient&&(e._currentAngularSpeedGradient=this._currentAngularSpeedGradient,e._currentAngularSpeed1=this._currentAngularSpeed1,e._currentAngularSpeed2=this._currentAngularSpeed2),this._currentVelocityGradient&&(e._currentVelocityGradient=this._currentVelocityGradient,e._currentVelocity1=this._currentVelocity1,e._currentVelocity2=this._currentVelocity2),this._currentLimitVelocityGradient&&(e._currentLimitVelocityGradient=this._currentLimitVelocityGradient,e._currentLimitVelocity1=this._currentLimitVelocity1,e._currentLimitVelocity2=this._currentLimitVelocity2),this._currentDragGradient&&(e._currentDragGradient=this._currentDragGradient,e._currentDrag1=this._currentDrag1,e._currentDrag2=this._currentDrag2),this.particleSystem.isAnimationSheetEnabled&&(e._initialStartSpriteCellID=this._initialStartSpriteCellID,e._initialEndSpriteCellID=this._initialEndSpriteCellID,e._initialSpriteCellLoop=this._initialSpriteCellLoop),this.particleSystem.useRampGradients&&(e.remapData&&this.remapData?e.remapData.copyFrom(this.remapData):e.remapData=new Ve(0,0,0,0)),this._randomNoiseCoordinates1&&(e._randomNoiseCoordinates1?(e._randomNoiseCoordinates1.copyFrom(this._randomNoiseCoordinates1),e._randomNoiseCoordinates2.copyFrom(this._randomNoiseCoordinates2)):(e._randomNoiseCoordinates1=this._randomNoiseCoordinates1.clone(),e._randomNoiseCoordinates2=this._randomNoiseCoordinates2.clone()))}}Jo._Count=0;class ln{constructor(){this.direction1=new m(0,1,0),this.direction2=new m(0,1,0),this.minEmitBox=new m(-.5,-.5,-.5),this.maxEmitBox=new m(.5,.5,.5)}startDirectionFunction(e,t,i,r){const s=Ne(this.direction1.x,this.direction2.x),n=Ne(this.direction1.y,this.direction2.y),o=Ne(this.direction1.z,this.direction2.z);if(r){t.x=s,t.y=n,t.z=o;return}m.TransformNormalFromFloatsToRef(s,n,o,e,t)}startPositionFunction(e,t,i,r){const s=Ne(this.minEmitBox.x,this.maxEmitBox.x),n=Ne(this.minEmitBox.y,this.maxEmitBox.y),o=Ne(this.minEmitBox.z,this.maxEmitBox.z);if(r){t.x=s,t.y=n,t.z=o;return}m.TransformCoordinatesFromFloatsToRef(s,n,o,e,t)}clone(){const e=new ln;return Ci.DeepCopy(this,e),e}applyToShader(e){e.setVector3("direction1",this.direction1),e.setVector3("direction2",this.direction2),e.setVector3("minEmitBox",this.minEmitBox),e.setVector3("maxEmitBox",this.maxEmitBox)}buildUniformLayout(e){e.addUniform("direction1",3),e.addUniform("direction2",3),e.addUniform("minEmitBox",3),e.addUniform("maxEmitBox",3)}getEffectDefines(){return"#define BOXEMITTER"}getClassName(){return"BoxParticleEmitter"}serialize(){const e={};return e.type=this.getClassName(),e.direction1=this.direction1.asArray(),e.direction2=this.direction2.asArray(),e.minEmitBox=this.minEmitBox.asArray(),e.maxEmitBox=this.maxEmitBox.asArray(),e}parse(e){m.FromArrayToRef(e.direction1,0,this.direction1),m.FromArrayToRef(e.direction2,0,this.direction2),m.FromArrayToRef(e.minEmitBox,0,this.minEmitBox),m.FromArrayToRef(e.maxEmitBox,0,this.maxEmitBox)}}class Ra extends kt{set onDispose(e){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(e)}get useRampGradients(){return this._useRampGradients}set useRampGradients(e){this._useRampGradients!==e&&(this._useRampGradients=e,this._resetEffect())}get particles(){return this._particles}get shaderLanguage(){return this._shaderLanguage}getActiveCount(){return this._particles.length}getClassName(){return"ParticleSystem"}isStopping(){return this._stopped&&this.isAlive()}getCustomEffect(e=0){var t;return((t=this._customWrappers[e])==null?void 0:t.effect)??this._customWrappers[0].effect}_getCustomDrawWrapper(e=0){return this._customWrappers[e]??this._customWrappers[0]}setCustomEffect(e,t=0){this._customWrappers[t]=new vi(this._engine),this._customWrappers[t].effect=e,this._customWrappers[t].drawContext&&(this._customWrappers[t].drawContext.useInstancing=this._useInstancing)}get onBeforeDrawParticlesObservable(){return this._onBeforeDrawParticlesObservable||(this._onBeforeDrawParticlesObservable=new j),this._onBeforeDrawParticlesObservable}get vertexShaderName(){return"particles"}get vertexBuffers(){return this._vertexBuffers}get indexBuffer(){return this._indexBuffer}constructor(e,t,i,r=null,s=!1,n=.01){super(e),this._emitterInverseWorldMatrix=$.Identity(),this._inheritedVelocityOffset=new m,this.onDisposeObservable=new j,this.onStoppedObservable=new j,this._particles=new Array,this._stockParticles=new Array,this._newPartsExcess=0,this._vertexBuffers={},this._scaledColorStep=new xe(0,0,0,0),this._colorDiff=new xe(0,0,0,0),this._scaledDirection=m.Zero(),this._scaledGravity=m.Zero(),this._currentRenderId=-1,this._useInstancing=!1,this._started=!1,this._stopped=!1,this._actualFrame=0,this._currentEmitRate1=0,this._currentEmitRate2=0,this._currentStartSize1=0,this._currentStartSize2=0,this.updateInAnimate=!0,this._rawTextureWidth=256,this._useRampGradients=!1,this.isLocal=!1,this.isGPU=!1,this._shaderLanguage=0,this._onBeforeDrawParticlesObservable=null,this._emitFromParticle=l=>{},this.recycleParticle=l=>{const u=this._particles.pop();u!==l&&u.copyTo(l),this._stockParticles.push(u)},this._createParticle=()=>{let l;return this._stockParticles.length!==0?(l=this._stockParticles.pop(),l._reset()):l=new Jo(this),this._prepareParticle(l),l},this._shadersLoaded=!1,this._capacity=t,this._epsilon=n,this._isAnimationSheetEnabled=s,!i||i.getClassName()==="Scene"?(this._scene=i||ze.LastCreatedScene,this._engine=this._scene.getEngine(),this.uniqueId=this._scene.getUniqueId(),this._scene.particleSystems.push(this)):(this._engine=i,this.defaultProjectionMatrix=$.PerspectiveFovLH(.8,1,.1,100,this._engine.isNDCHalfZRange)),this._engine.getCaps().vertexArrayObject&&(this._vertexArrayObject=null),this._initShaderSourceAsync(),this._attachImageProcessingConfiguration(null),this._customWrappers={0:new vi(this._engine)},this._customWrappers[0].effect=r,this._drawWrappers=[],this._useInstancing=this._engine.getCaps().instancedArrays,this._createIndexBuffer(),this._createVertexBuffers(),this.particleEmitterType=new ln;let o=null;this.updateFunction=l=>{var h;let u=null;this.noiseTexture&&(u=this.noiseTexture.getSize(),(h=this.noiseTexture.getContent())==null||h.then(d=>{o=d}));const c=l===this._particles;for(let d=0;d<l.length;d++){const f=l[d];let p=this._scaledUpdateSpeed;const g=f.age;if(f.age+=p,f.age>f.lifeTime){const b=f.age-g;p=(f.lifeTime-g)*p/b,f.age=f.lifeTime}const _=f.age/f.lifeTime;this._colorGradients&&this._colorGradients.length>0?Wi.GetCurrentGradient(_,this._colorGradients,(b,y,T)=>{b!==f._currentColorGradient&&(f._currentColor1.copyFrom(f._currentColor2),y.getColorToRef(f._currentColor2),f._currentColorGradient=b),xe.LerpToRef(f._currentColor1,f._currentColor2,T,f.color)}):(f.colorStep.scaleToRef(p,this._scaledColorStep),f.color.addInPlace(this._scaledColorStep),f.color.a<0&&(f.color.a=0)),this._angularSpeedGradients&&this._angularSpeedGradients.length>0&&Wi.GetCurrentGradient(_,this._angularSpeedGradients,(b,y,T)=>{b!==f._currentAngularSpeedGradient&&(f._currentAngularSpeed1=f._currentAngularSpeed2,f._currentAngularSpeed2=y.getFactor(),f._currentAngularSpeedGradient=b),f.angularSpeed=mi(f._currentAngularSpeed1,f._currentAngularSpeed2,T)}),f.angle+=f.angularSpeed*p;let S=p;if(this._velocityGradients&&this._velocityGradients.length>0&&Wi.GetCurrentGradient(_,this._velocityGradients,(b,y,T)=>{b!==f._currentVelocityGradient&&(f._currentVelocity1=f._currentVelocity2,f._currentVelocity2=y.getFactor(),f._currentVelocityGradient=b),S*=mi(f._currentVelocity1,f._currentVelocity2,T)}),f.direction.scaleToRef(S,this._scaledDirection),this._limitVelocityGradients&&this._limitVelocityGradients.length>0&&Wi.GetCurrentGradient(_,this._limitVelocityGradients,(b,y,T)=>{b!==f._currentLimitVelocityGradient&&(f._currentLimitVelocity1=f._currentLimitVelocity2,f._currentLimitVelocity2=y.getFactor(),f._currentLimitVelocityGradient=b);const v=mi(f._currentLimitVelocity1,f._currentLimitVelocity2,T);f.direction.length()>v&&f.direction.scaleInPlace(this.limitVelocityDamping)}),this._dragGradients&&this._dragGradients.length>0&&Wi.GetCurrentGradient(_,this._dragGradients,(b,y,T)=>{b!==f._currentDragGradient&&(f._currentDrag1=f._currentDrag2,f._currentDrag2=y.getFactor(),f._currentDragGradient=b);const v=mi(f._currentDrag1,f._currentDrag2,T);this._scaledDirection.scaleInPlace(1-v)}),this.isLocal&&f._localPosition?(f._localPosition.addInPlace(this._scaledDirection),m.TransformCoordinatesToRef(f._localPosition,this._emitterWorldMatrix,f.position)):f.position.addInPlace(this._scaledDirection),o&&u&&f._randomNoiseCoordinates1){const b=this._fetchR(f._randomNoiseCoordinates1.x,f._randomNoiseCoordinates1.y,u.width,u.height,o),y=this._fetchR(f._randomNoiseCoordinates1.z,f._randomNoiseCoordinates2.x,u.width,u.height,o),T=this._fetchR(f._randomNoiseCoordinates2.y,f._randomNoiseCoordinates2.z,u.width,u.height,o),v=V.Vector3[0],E=V.Vector3[1];v.copyFromFloats((2*b-1)*this.noiseStrength.x,(2*y-1)*this.noiseStrength.y,(2*T-1)*this.noiseStrength.z),v.scaleToRef(p,E),f.direction.addInPlace(E)}if(this.gravity.scaleToRef(p,this._scaledGravity),f.direction.addInPlace(this._scaledGravity),this._sizeGradients&&this._sizeGradients.length>0&&Wi.GetCurrentGradient(_,this._sizeGradients,(b,y,T)=>{b!==f._currentSizeGradient&&(f._currentSize1=f._currentSize2,f._currentSize2=y.getFactor(),f._currentSizeGradient=b),f.size=mi(f._currentSize1,f._currentSize2,T)}),this._useRampGradients&&(this._colorRemapGradients&&this._colorRemapGradients.length>0&&Wi.GetCurrentGradient(_,this._colorRemapGradients,(b,y,T)=>{const v=mi(b.factor1,y.factor1,T),E=mi(b.factor2,y.factor2,T);f.remapData.x=v,f.remapData.y=E-v}),this._alphaRemapGradients&&this._alphaRemapGradients.length>0&&Wi.GetCurrentGradient(_,this._alphaRemapGradients,(b,y,T)=>{const v=mi(b.factor1,y.factor1,T),E=mi(b.factor2,y.factor2,T);f.remapData.z=v,f.remapData.w=E-v})),this._isAnimationSheetEnabled&&f.updateCellIndex(),f._inheritParticleInfoToSubEmitters(),f.age>=f.lifeTime){this._emitFromParticle(f),f._attachedSubEmitters&&(f._attachedSubEmitters.forEach(b=>{b.particleSystem.disposeOnStop=!0,b.particleSystem.stop()}),f._attachedSubEmitters=null),this.recycleParticle(f),c&&d--;continue}}}}serialize(e){throw new Error("Method not implemented.")}clone(e,t,i=!1){throw new Error("Method not implemented.")}_addFactorGradient(e,t,i,r){const s=new dP(t,i,r);e.push(s),e.sort((n,o)=>n.gradient<o.gradient?-1:n.gradient>o.gradient?1:0)}_removeFactorGradient(e,t){if(!e)return;let i=0;for(const r of e){if(r.gradient===t){e.splice(i,1);break}i++}}addLifeTimeGradient(e,t,i){return this._lifeTimeGradients||(this._lifeTimeGradients=[]),this._addFactorGradient(this._lifeTimeGradients,e,t,i),this}removeLifeTimeGradient(e){return this._removeFactorGradient(this._lifeTimeGradients,e),this}addSizeGradient(e,t,i){return this._sizeGradients||(this._sizeGradients=[]),this._addFactorGradient(this._sizeGradients,e,t,i),this}removeSizeGradient(e){return this._removeFactorGradient(this._sizeGradients,e),this}addColorRemapGradient(e,t,i){return this._colorRemapGradients||(this._colorRemapGradients=[]),this._addFactorGradient(this._colorRemapGradients,e,t,i),this}removeColorRemapGradient(e){return this._removeFactorGradient(this._colorRemapGradients,e),this}addAlphaRemapGradient(e,t,i){return this._alphaRemapGradients||(this._alphaRemapGradients=[]),this._addFactorGradient(this._alphaRemapGradients,e,t,i),this}removeAlphaRemapGradient(e){return this._removeFactorGradient(this._alphaRemapGradients,e),this}addAngularSpeedGradient(e,t,i){return this._angularSpeedGradients||(this._angularSpeedGradients=[]),this._addFactorGradient(this._angularSpeedGradients,e,t,i),this}removeAngularSpeedGradient(e){return this._removeFactorGradient(this._angularSpeedGradients,e),this}addVelocityGradient(e,t,i){return this._velocityGradients||(this._velocityGradients=[]),this._addFactorGradient(this._velocityGradients,e,t,i),this}removeVelocityGradient(e){return this._removeFactorGradient(this._velocityGradients,e),this}addLimitVelocityGradient(e,t,i){return this._limitVelocityGradients||(this._limitVelocityGradients=[]),this._addFactorGradient(this._limitVelocityGradients,e,t,i),this}removeLimitVelocityGradient(e){return this._removeFactorGradient(this._limitVelocityGradients,e),this}addDragGradient(e,t,i){return this._dragGradients||(this._dragGradients=[]),this._addFactorGradient(this._dragGradients,e,t,i),this}removeDragGradient(e){return this._removeFactorGradient(this._dragGradients,e),this}addEmitRateGradient(e,t,i){return this._emitRateGradients||(this._emitRateGradients=[]),this._addFactorGradient(this._emitRateGradients,e,t,i),this}removeEmitRateGradient(e){return this._removeFactorGradient(this._emitRateGradients,e),this}addStartSizeGradient(e,t,i){return this._startSizeGradients||(this._startSizeGradients=[]),this._addFactorGradient(this._startSizeGradients,e,t,i),this}removeStartSizeGradient(e){return this._removeFactorGradient(this._startSizeGradients,e),this}_createRampGradientTexture(){if(!this._rampGradients||!this._rampGradients.length||this._rampGradientsTexture||!this._scene)return;const e=new Uint8Array(this._rawTextureWidth*4),t=_t.Color3[0];for(let i=0;i<this._rawTextureWidth;i++){const r=i/this._rawTextureWidth;Wi.GetCurrentGradient(r,this._rampGradients,(s,n,o)=>{ne.LerpToRef(s.color,n.color,o,t),e[i*4]=t.r*255,e[i*4+1]=t.g*255,e[i*4+2]=t.b*255,e[i*4+3]=255})}this._rampGradientsTexture=qt.CreateRGBATexture(e,this._rawTextureWidth,1,this._scene,!1,!1,1)}getRampGradients(){return this._rampGradients}forceRefreshGradients(){this._syncRampGradientTexture()}_syncRampGradientTexture(){this._rampGradients&&(this._rampGradients.sort((e,t)=>e.gradient<t.gradient?-1:e.gradient>t.gradient?1:0),this._rampGradientsTexture&&(this._rampGradientsTexture.dispose(),this._rampGradientsTexture=null),this._createRampGradientTexture())}addRampGradient(e,t){this._rampGradients||(this._rampGradients=[]);const i=new zB(e,t);return this._rampGradients.push(i),this._syncRampGradientTexture(),this}removeRampGradient(e){return this._removeGradientAndTexture(e,this._rampGradients,this._rampGradientsTexture),this._rampGradientsTexture=null,this._rampGradients&&this._rampGradients.length>0&&this._createRampGradientTexture(),this}addColorGradient(e,t,i){this._colorGradients||(this._colorGradients=[]);const r=new hP(e,t,i);return this._colorGradients.push(r),this._colorGradients.sort((s,n)=>s.gradient<n.gradient?-1:s.gradient>n.gradient?1:0),this}removeColorGradient(e){if(!this._colorGradients)return this;let t=0;for(const i of this._colorGradients){if(i.gradient===e){this._colorGradients.splice(t,1);break}t++}return this}resetDrawCache(){for(const e of this._drawWrappers)if(e)for(const t of e)t==null||t.dispose();this._drawWrappers=[]}_fetchR(e,t,i,r,s){e=Math.abs(e)*.5+.5,t=Math.abs(t)*.5+.5;const n=e*i%i|0,o=t*r%r|0,l=(n+o*i)*4;return s[l]/255}_reset(){this._resetEffect()}_resetEffect(){this._vertexBuffer&&(this._vertexBuffer.dispose(),this._vertexBuffer=null),this._spriteBuffer&&(this._spriteBuffer.dispose(),this._spriteBuffer=null),this._vertexArrayObject&&(this._engine.releaseVertexArrayObject(this._vertexArrayObject),this._vertexArrayObject=null),this._createVertexBuffers()}_createVertexBuffers(){this._vertexBufferSize=this._useInstancing?10:12,this._isAnimationSheetEnabled&&(this._vertexBufferSize+=1),(!this._isBillboardBased||this.billboardMode===8||this.billboardMode===9)&&(this._vertexBufferSize+=3),this._useRampGradients&&(this._vertexBufferSize+=4);const e=this._engine,t=this._vertexBufferSize*(this._useInstancing?1:4);this._vertexData=new Float32Array(this._capacity*t),this._vertexBuffer=new fi(e,this._vertexData,!0,t);let i=0;const r=this._vertexBuffer.createVertexBuffer(N.PositionKind,i,3,this._vertexBufferSize,this._useInstancing);this._vertexBuffers[N.PositionKind]=r,i+=3;const s=this._vertexBuffer.createVertexBuffer(N.ColorKind,i,4,this._vertexBufferSize,this._useInstancing);this._vertexBuffers[N.ColorKind]=s,i+=4;const n=this._vertexBuffer.createVertexBuffer("angle",i,1,this._vertexBufferSize,this._useInstancing);this._vertexBuffers.angle=n,i+=1;const o=this._vertexBuffer.createVertexBuffer("size",i,2,this._vertexBufferSize,this._useInstancing);if(this._vertexBuffers.size=o,i+=2,this._isAnimationSheetEnabled){const u=this._vertexBuffer.createVertexBuffer("cellIndex",i,1,this._vertexBufferSize,this._useInstancing);this._vertexBuffers.cellIndex=u,i+=1}if(!this._isBillboardBased||this.billboardMode===8||this.billboardMode===9){const u=this._vertexBuffer.createVertexBuffer("direction",i,3,this._vertexBufferSize,this._useInstancing);this._vertexBuffers.direction=u,i+=3}if(this._useRampGradients){const u=this._vertexBuffer.createVertexBuffer("remapData",i,4,this._vertexBufferSize,this._useInstancing);this._vertexBuffers.remapData=u,i+=4}let l;if(this._useInstancing){const u=new Float32Array([0,0,1,0,0,1,1,1]);this._spriteBuffer=new fi(e,u,!1,2),l=this._spriteBuffer.createVertexBuffer("offset",0,2)}else l=this._vertexBuffer.createVertexBuffer("offset",i,2,this._vertexBufferSize,this._useInstancing),i+=2;this._vertexBuffers.offset=l,this.resetDrawCache()}_createIndexBuffer(){if(this._useInstancing){this._linesIndexBufferUseInstancing=this._engine.createIndexBuffer(new Uint32Array([0,1,1,3,3,2,2,0,0,3]));return}const e=[],t=[];let i=0;for(let r=0;r<this._capacity;r++)e.push(i),e.push(i+1),e.push(i+2),e.push(i),e.push(i+2),e.push(i+3),t.push(i,i+1,i+1,i+2,i+2,i+3,i+3,i,i,i+3),i+=4;this._indexBuffer=this._engine.createIndexBuffer(e),this._linesIndexBuffer=this._engine.createIndexBuffer(t)}getCapacity(){return this._capacity}isAlive(){return this._alive}isStarted(){return this._started}_preStart(){}start(e=this.startDelay){var t;if(!this.targetStopDuration&&this._hasTargetStopDurationDependantGradient())throw"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set";if(e){setTimeout(()=>{this.start(0)},e);return}if(this._started=!0,this._stopped=!1,this._actualFrame=0,this._preStart(),this._emitRateGradients&&(this._emitRateGradients.length>0&&(this._currentEmitRateGradient=this._emitRateGradients[0],this._currentEmitRate1=this._currentEmitRateGradient.getFactor(),this._currentEmitRate2=this._currentEmitRate1),this._emitRateGradients.length>1&&(this._currentEmitRate2=this._emitRateGradients[1].getFactor())),this._startSizeGradients&&(this._startSizeGradients.length>0&&(this._currentStartSizeGradient=this._startSizeGradients[0],this._currentStartSize1=this._currentStartSizeGradient.getFactor(),this._currentStartSize2=this._currentStartSize1),this._startSizeGradients.length>1&&(this._currentStartSize2=this._startSizeGradients[1].getFactor())),this.preWarmCycles){((t=this.emitter)==null?void 0:t.getClassName().indexOf("Mesh"))!==-1&&this.emitter.computeWorldMatrix(!0);const i=this.noiseTexture;if(i&&i.onGeneratedObservable)i.onGeneratedObservable.addOnce(()=>{setTimeout(()=>{for(let r=0;r<this.preWarmCycles;r++)this.animate(!0),i.render()})});else for(let r=0;r<this.preWarmCycles;r++)this.animate(!0)}this.beginAnimationOnStart&&this.animations&&this.animations.length>0&&this._scene&&this._scene.beginAnimation(this,this.beginAnimationFrom,this.beginAnimationTo,this.beginAnimationLoop)}stop(e=!0){this._stopped||(this.onStoppedObservable.notifyObservers(this),this._stopped=!0,this._postStop(e))}_postStop(e){}reset(){this._stockParticles.length=0,this._particles.length=0}_appendParticleVertex(e,t,i,r){let s=e*this._vertexBufferSize;if(this._vertexData[s++]=t.position.x+this.worldOffset.x,this._vertexData[s++]=t.position.y+this.worldOffset.y,this._vertexData[s++]=t.position.z+this.worldOffset.z,this._vertexData[s++]=t.color.r,this._vertexData[s++]=t.color.g,this._vertexData[s++]=t.color.b,this._vertexData[s++]=t.color.a,this._vertexData[s++]=t.angle,this._vertexData[s++]=t.scale.x*t.size,this._vertexData[s++]=t.scale.y*t.size,this._isAnimationSheetEnabled&&(this._vertexData[s++]=t.cellIndex),this._isBillboardBased)(this.billboardMode===8||this.billboardMode===9)&&(this._vertexData[s++]=t.direction.x,this._vertexData[s++]=t.direction.y,this._vertexData[s++]=t.direction.z);else if(t._initialDirection){let n=t._initialDirection;this.isLocal&&(m.TransformNormalToRef(n,this._emitterWorldMatrix,V.Vector3[0]),n=V.Vector3[0]),n.x===0&&n.z===0&&(n.x=.001),this._vertexData[s++]=n.x,this._vertexData[s++]=n.y,this._vertexData[s++]=n.z}else{let n=t.direction;this.isLocal&&(m.TransformNormalToRef(n,this._emitterWorldMatrix,V.Vector3[0]),n=V.Vector3[0]),n.x===0&&n.z===0&&(n.x=.001),this._vertexData[s++]=n.x,this._vertexData[s++]=n.y,this._vertexData[s++]=n.z}this._useRampGradients&&t.remapData&&(this._vertexData[s++]=t.remapData.x,this._vertexData[s++]=t.remapData.y,this._vertexData[s++]=t.remapData.z,this._vertexData[s++]=t.remapData.w),this._useInstancing||(this._isAnimationSheetEnabled&&(i===0?i=this._epsilon:i===1&&(i=1-this._epsilon),r===0?r=this._epsilon:r===1&&(r=1-this._epsilon)),this._vertexData[s++]=i,this._vertexData[s++]=r)}_prepareParticle(e){}_update(e){if(this._alive=this._particles.length>0,this.emitter.position){const i=this.emitter;this._emitterWorldMatrix=i.getWorldMatrix()}else{const i=this.emitter;this._emitterWorldMatrix=$.Translation(i.x,i.y,i.z)}this._emitterWorldMatrix.invertToRef(this._emitterInverseWorldMatrix),this.updateFunction(this._particles);let t;for(let i=0;i<e&&this._particles.length!==this._capacity;i++){if(t=this._createParticle(),this._particles.push(t),this.targetStopDuration&&this._lifeTimeGradients&&this._lifeTimeGradients.length>0){const s=Si(this._actualFrame/this.targetStopDuration);Wi.GetCurrentGradient(s,this._lifeTimeGradients,(n,o)=>{const l=n,u=o,c=l.getFactor(),h=u.getFactor(),d=(s-l.gradient)/(u.gradient-l.gradient);t.lifeTime=mi(c,h,d)})}else t.lifeTime=Ne(this.minLifeTime,this.maxLifeTime);const r=Ne(this.minEmitPower,this.maxEmitPower);if(this.startPositionFunction?this.startPositionFunction(this._emitterWorldMatrix,t.position,t,this.isLocal):this.particleEmitterType.startPositionFunction(this._emitterWorldMatrix,t.position,t,this.isLocal),this.isLocal&&(t._localPosition?t._localPosition.copyFrom(t.position):t._localPosition=t.position.clone(),m.TransformCoordinatesToRef(t._localPosition,this._emitterWorldMatrix,t.position)),this.startDirectionFunction?this.startDirectionFunction(this._emitterWorldMatrix,t.direction,t,this.isLocal):this.particleEmitterType.startDirectionFunction(this._emitterWorldMatrix,t.direction,t,this.isLocal,this._emitterInverseWorldMatrix),r===0?t._initialDirection?t._initialDirection.copyFrom(t.direction):t._initialDirection=t.direction.clone():t._initialDirection=null,t.direction.scaleInPlace(r),!this._sizeGradients||this._sizeGradients.length===0?t.size=Ne(this.minSize,this.maxSize):(t._currentSizeGradient=this._sizeGradients[0],t._currentSize1=t._currentSizeGradient.getFactor(),t.size=t._currentSize1,this._sizeGradients.length>1?t._currentSize2=this._sizeGradients[1].getFactor():t._currentSize2=t._currentSize1),t.scale.copyFromFloats(Ne(this.minScaleX,this.maxScaleX),Ne(this.minScaleY,this.maxScaleY)),this._startSizeGradients&&this._startSizeGradients[0]&&this.targetStopDuration){const s=this._actualFrame/this.targetStopDuration;Wi.GetCurrentGradient(s,this._startSizeGradients,(n,o,l)=>{n!==this._currentStartSizeGradient&&(this._currentStartSize1=this._currentStartSize2,this._currentStartSize2=o.getFactor(),this._currentStartSizeGradient=n);const u=mi(this._currentStartSize1,this._currentStartSize2,l);t.scale.scaleInPlace(u)})}if(!this._angularSpeedGradients||this._angularSpeedGradients.length===0?t.angularSpeed=Ne(this.minAngularSpeed,this.maxAngularSpeed):(t._currentAngularSpeedGradient=this._angularSpeedGradients[0],t.angularSpeed=t._currentAngularSpeedGradient.getFactor(),t._currentAngularSpeed1=t.angularSpeed,this._angularSpeedGradients.length>1?t._currentAngularSpeed2=this._angularSpeedGradients[1].getFactor():t._currentAngularSpeed2=t._currentAngularSpeed1),t.angle=Ne(this.minInitialRotation,this.maxInitialRotation),this._velocityGradients&&this._velocityGradients.length>0&&(t._currentVelocityGradient=this._velocityGradients[0],t._currentVelocity1=t._currentVelocityGradient.getFactor(),this._velocityGradients.length>1?t._currentVelocity2=this._velocityGradients[1].getFactor():t._currentVelocity2=t._currentVelocity1),this._limitVelocityGradients&&this._limitVelocityGradients.length>0&&(t._currentLimitVelocityGradient=this._limitVelocityGradients[0],t._currentLimitVelocity1=t._currentLimitVelocityGradient.getFactor(),this._limitVelocityGradients.length>1?t._currentLimitVelocity2=this._limitVelocityGradients[1].getFactor():t._currentLimitVelocity2=t._currentLimitVelocity1),this._dragGradients&&this._dragGradients.length>0&&(t._currentDragGradient=this._dragGradients[0],t._currentDrag1=t._currentDragGradient.getFactor(),this._dragGradients.length>1?t._currentDrag2=this._dragGradients[1].getFactor():t._currentDrag2=t._currentDrag1),!this._colorGradients||this._colorGradients.length===0){const s=Ne(0,1);xe.LerpToRef(this.color1,this.color2,s,t.color),this.colorDead.subtractToRef(t.color,this._colorDiff),this._colorDiff.scaleToRef(1/t.lifeTime,t.colorStep)}else t._currentColorGradient=this._colorGradients[0],t._currentColorGradient.getColorToRef(t.color),t._currentColor1.copyFrom(t.color),this._colorGradients.length>1?this._colorGradients[1].getColorToRef(t._currentColor2):t._currentColor2.copyFrom(t.color);this._isAnimationSheetEnabled&&(t._initialStartSpriteCellID=this.startSpriteCellID,t._initialEndSpriteCellID=this.endSpriteCellID,t._initialSpriteCellLoop=this.spriteCellLoop),t.direction.addInPlace(this._inheritedVelocityOffset),this._useRampGradients&&(t.remapData=new Ve(0,1,0,1)),this.noiseTexture&&(t._randomNoiseCoordinates1?(t._randomNoiseCoordinates1.copyFromFloats(Math.random(),Math.random(),Math.random()),t._randomNoiseCoordinates2.copyFromFloats(Math.random(),Math.random(),Math.random())):(t._randomNoiseCoordinates1=new m(Math.random(),Math.random(),Math.random()),t._randomNoiseCoordinates2=new m(Math.random(),Math.random(),Math.random()))),t._inheritParticleInfoToSubEmitters()}}static _GetAttributeNamesOrOptions(e=!1,t=!1,i=!1){const r=[N.PositionKind,N.ColorKind,"angle","offset","size"];return e&&r.push("cellIndex"),t||r.push("direction"),i&&r.push("remapData"),r}static _GetEffectCreationOptions(e=!1,t=!1,i=!1){const r=["invView","view","projection","textureMask","translationPivot","eyePosition"];return _n(r),e&&r.push("particlesInfos"),t&&r.push("logarithmicDepthConstant"),i&&(r.push("vFogInfos"),r.push("vFogColor")),r}fillDefines(e,t,i=!0){if(this._scene&&(Zn(this,this._scene,e),this.applyFog&&this._scene.fogEnabled&&this._scene.fogMode!==0&&e.push("#define FOG")),this._isAnimationSheetEnabled&&e.push("#define ANIMATESHEET"),this.useLogarithmicDepth&&e.push("#define LOGARITHMICDEPTH"),t===kt.BLENDMODE_MULTIPLY&&e.push("#define BLENDMULTIPLYMODE"),this._useRampGradients&&e.push("#define RAMPGRADIENT"),this._isBillboardBased)switch(e.push("#define BILLBOARD"),this.billboardMode){case 2:e.push("#define BILLBOARDY");break;case 8:case 9:e.push("#define BILLBOARDSTRETCHED"),this.billboardMode===9&&e.push("#define BILLBOARDSTRETCHED_LOCAL");break;case 7:e.push("#define BILLBOARDMODE_ALL");break}i&&this._imageProcessingConfiguration&&(this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines),e.push(this._imageProcessingConfigurationDefines.toString()))}fillUniformsAttributesAndSamplerNames(e,t,i){t.push(...Ra._GetAttributeNamesOrOptions(this._isAnimationSheetEnabled,this._isBillboardBased&&this.billboardMode!==8&&this.billboardMode!==9,this._useRampGradients)),e.push(...Ra._GetEffectCreationOptions(this._isAnimationSheetEnabled,this.useLogarithmicDepth,this.applyFog)),i.push("diffuseSampler","rampSampler"),this._imageProcessingConfiguration&&(LM(e,this._imageProcessingConfigurationDefines),BM(i,this._imageProcessingConfigurationDefines))}_getWrapper(e){const t=this._getCustomDrawWrapper(e);if(t!=null&&t.effect)return t;const i=[];this.fillDefines(i,e);const r=this._engine._features.supportRenderPasses?this._engine.currentRenderPassId:0;let s=this._drawWrappers[r];s||(s=this._drawWrappers[r]=[]);let n=s[e];n||(n=new vi(this._engine),n.drawContext&&(n.drawContext.useInstancing=this._useInstancing),s[e]=n);const o=i.join(`
`);if(n.defines!==o){const l=[],u=[],c=[];this.fillUniformsAttributesAndSamplerNames(u,l,c),n.setEffect(this._engine.createEffect("particles",l,u,c,o,void 0,void 0,void 0,void 0,this._shaderLanguage),o)}return n}animate(e=!1){var i;if(!this._started)return;if(!e&&this._scene){if(!this.isReady()||this._currentRenderId===this._scene.getFrameId())return;this._currentRenderId=this._scene.getFrameId()}this._scaledUpdateSpeed=this.updateSpeed*(e?this.preWarmStepOffset:((i=this._scene)==null?void 0:i.getAnimationRatio())||1);let t;if(this.manualEmitCount>-1)t=this.manualEmitCount,this._newPartsExcess=0,this.manualEmitCount=0;else{let r=this.emitRate;if(this._emitRateGradients&&this._emitRateGradients.length>0&&this.targetStopDuration){const s=this._actualFrame/this.targetStopDuration;Wi.GetCurrentGradient(s,this._emitRateGradients,(n,o,l)=>{n!==this._currentEmitRateGradient&&(this._currentEmitRate1=this._currentEmitRate2,this._currentEmitRate2=o.getFactor(),this._currentEmitRateGradient=n),r=mi(this._currentEmitRate1,this._currentEmitRate2,l)})}t=r*this._scaledUpdateSpeed>>0,this._newPartsExcess+=r*this._scaledUpdateSpeed-t}if(this._newPartsExcess>1&&(t+=this._newPartsExcess>>0,this._newPartsExcess-=this._newPartsExcess>>0),this._alive=!1,this._stopped?t=0:(this._actualFrame+=this._scaledUpdateSpeed,this.targetStopDuration&&this._actualFrame>=this.targetStopDuration&&this.stop()),this._update(t),this._stopped&&(this._alive||(this._started=!1,this.onAnimationEnd&&this.onAnimationEnd(),this.disposeOnStop&&this._scene&&this._scene._toBeDisposed.push(this))),!e){let r=0;for(let s=0;s<this._particles.length;s++){const n=this._particles[s];this._appendParticleVertices(r,n),r+=this._useInstancing?1:4}this._vertexBuffer&&this._vertexBuffer.updateDirectly(this._vertexData,0,this._particles.length)}this.manualEmitCount===0&&this.disposeOnStop&&this.stop()}_appendParticleVertices(e,t){this._appendParticleVertex(e++,t,0,0),this._useInstancing||(this._appendParticleVertex(e++,t,1,0),this._appendParticleVertex(e++,t,1,1),this._appendParticleVertex(e++,t,0,1))}rebuild(){var e;this._engine.getCaps().vertexArrayObject&&(this._vertexArrayObject=null),this._createIndexBuffer(),(e=this._spriteBuffer)==null||e._rebuild(),this._createVertexBuffers(),this.resetDrawCache()}async _initShaderSourceAsync(){this._engine.isWebGPU&&!Ra.ForceGLSL?(this._shaderLanguage=1,await Promise.all([k(()=>Promise.resolve().then(()=>MP),void 0),k(()=>Promise.resolve().then(()=>cV),void 0)])):await Promise.all([k(()=>Promise.resolve().then(()=>EP),void 0),k(()=>Promise.resolve().then(()=>oV),void 0)]),this._shadersLoaded=!0}isReady(){if(!this._shadersLoaded||!this.emitter||this._imageProcessingConfiguration&&!this._imageProcessingConfiguration.isReady()||!this.particleTexture||!this.particleTexture.isReady())return!1;if(this.blendMode!==kt.BLENDMODE_MULTIPLYADD){if(!this._getWrapper(this.blendMode).effect.isReady())return!1}else if(!this._getWrapper(kt.BLENDMODE_MULTIPLY).effect.isReady()||!this._getWrapper(kt.BLENDMODE_ADD).effect.isReady())return!1;return!0}_render(e){var o,l,u,c,h,d;const t=this._getWrapper(e),i=t.effect,r=this._engine;r.enableEffect(t);const s=this.defaultViewMatrix??this._scene.getViewMatrix();if(i.setTexture("diffuseSampler",this.particleTexture),i.setMatrix("view",s),i.setMatrix("projection",this.defaultProjectionMatrix??this._scene.getProjectionMatrix()),this._isAnimationSheetEnabled&&this.particleTexture){const f=this.particleTexture.getBaseSize();i.setFloat3("particlesInfos",this.spriteCellWidth/f.width,this.spriteCellHeight/f.height,this.spriteCellWidth/f.width)}if(i.setVector2("translationPivot",this.translationPivot),i.setFloat4("textureMask",this.textureMask.r,this.textureMask.g,this.textureMask.b,this.textureMask.a),this._isBillboardBased&&this._scene){const f=this._scene.activeCamera;i.setVector3("eyePosition",f.globalPosition)}this._rampGradientsTexture&&((!this._rampGradients||!this._rampGradients.length)&&(this._rampGradientsTexture.dispose(),this._rampGradientsTexture=null),i.setTexture("rampSampler",this._rampGradientsTexture));const n=i.defines;switch(this._scene&&(Fs(i,this,this._scene),this.applyFog&&gu(this._scene,void 0,i)),n.indexOf("#define BILLBOARDMODE_ALL")>=0&&(s.invertToRef(V.Matrix[0]),i.setMatrix("invView",V.Matrix[0])),this._vertexArrayObject!==void 0?(o=this._scene)!=null&&o.forceWireframe?r.bindBuffers(this._vertexBuffers,this._linesIndexBufferUseInstancing,i):(this._vertexArrayObject||(this._vertexArrayObject=this._engine.recordVertexArrayObject(this._vertexBuffers,null,i)),this._engine.bindVertexArrayObject(this._vertexArrayObject,(l=this._scene)!=null&&l.forceWireframe?this._linesIndexBufferUseInstancing:this._indexBuffer)):this._indexBuffer?r.bindBuffers(this._vertexBuffers,(c=this._scene)!=null&&c.forceWireframe?this._linesIndexBuffer:this._indexBuffer,i):r.bindBuffers(this._vertexBuffers,(u=this._scene)!=null&&u.forceWireframe?this._linesIndexBufferUseInstancing:null,i),this.useLogarithmicDepth&&this._scene&&qa(n,i,this._scene),this._imageProcessingConfiguration&&!this._imageProcessingConfiguration.applyByPostProcess&&this._imageProcessingConfiguration.bind(i),e){case kt.BLENDMODE_ADD:r.setAlphaMode(1);break;case kt.BLENDMODE_ONEONE:r.setAlphaMode(6);break;case kt.BLENDMODE_STANDARD:r.setAlphaMode(2);break;case kt.BLENDMODE_MULTIPLY:r.setAlphaMode(4);break}return this._onBeforeDrawParticlesObservable&&this._onBeforeDrawParticlesObservable.notifyObservers(i),this._useInstancing?(h=this._scene)!=null&&h.forceWireframe?r.drawElementsType(6,0,10,this._particles.length):r.drawArraysType(7,0,4,this._particles.length):(d=this._scene)!=null&&d.forceWireframe?r.drawElementsType(1,0,this._particles.length*10):r.drawElementsType(0,0,this._particles.length*6),this._particles.length}render(){if(!this.isReady()||!this._particles.length)return 0;const e=this._engine;e.setState&&(e.setState(!1),this.forceDepthWrite&&e.setDepthWrite(!0));let t=0;return this.blendMode===kt.BLENDMODE_MULTIPLYADD?t=this._render(kt.BLENDMODE_MULTIPLY)+this._render(kt.BLENDMODE_ADD):t=this._render(this.blendMode),this._engine.unbindInstanceAttributes(),this._engine.setAlphaMode(0),t}_onDispose(e=!1,t=!1){}dispose(e=!0,t=!1,i=!1){if(this.resetDrawCache(),this._vertexBuffer&&(this._vertexBuffer.dispose(),this._vertexBuffer=null),this._spriteBuffer&&(this._spriteBuffer.dispose(),this._spriteBuffer=null),this._indexBuffer&&(this._engine._releaseBuffer(this._indexBuffer),this._indexBuffer=null),this._linesIndexBuffer&&(this._engine._releaseBuffer(this._linesIndexBuffer),this._linesIndexBuffer=null),this._linesIndexBufferUseInstancing&&(this._engine._releaseBuffer(this._linesIndexBufferUseInstancing),this._linesIndexBufferUseInstancing=null),this._vertexArrayObject&&(this._engine.releaseVertexArrayObject(this._vertexArrayObject),this._vertexArrayObject=null),e&&this.particleTexture&&(this.particleTexture.dispose(),this.particleTexture=null),e&&this.noiseTexture&&(this.noiseTexture.dispose(),this.noiseTexture=null),this._rampGradientsTexture&&(this._rampGradientsTexture.dispose(),this._rampGradientsTexture=null),this._onDispose(t,i),this._onBeforeDrawParticlesObservable&&this._onBeforeDrawParticlesObservable.clear(),this._scene){const r=this._scene.particleSystems.indexOf(this);r>-1&&this._scene.particleSystems.splice(r,1),this._scene._activeParticleSystems.dispose()}this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this.onStoppedObservable.clear(),this.reset()}}Ra.ForceGLSL=!1;var mv;(function(a){a[a.ATTACHED=0]="ATTACHED",a[a.END=1]="END"})(mv||(mv={}));class un{constructor(e){if(this.particleSystem=e,this.type=1,this.inheritDirection=!1,this.inheritedVelocityAmount=0,!e.emitter||!e.emitter.dispose){const t=oi("BABYLON.AbstractMesh");e.emitter=new t("SubemitterSystemEmitter",e.getScene()),e._disposeEmitterOnDispose=!0}}clone(){let e=this.particleSystem.emitter;if(!e)e=new m;else if(e instanceof m)e=e.clone();else if(e.getClassName().indexOf("Mesh")!==-1){const i=oi("BABYLON.Mesh");e=new i("",e.getScene()),e.isVisible=!1}const t=new un(this.particleSystem.clone(this.particleSystem.name,e));return t.particleSystem.name+="Clone",t.type=this.type,t.inheritDirection=this.inheritDirection,t.inheritedVelocityAmount=this.inheritedVelocityAmount,t.particleSystem._disposeEmitterOnDispose=!0,t.particleSystem.disposeOnStop=!0,t}serialize(e=!1){const t={};return t.type=this.type,t.inheritDirection=this.inheritDirection,t.inheritedVelocityAmount=this.inheritedVelocityAmount,t.particleSystem=this.particleSystem.serialize(e),t}static _ParseParticleSystem(e,t,i,r=!1){throw Cr("ParseParticle")}static Parse(e,t,i){const r=e.particleSystem,s=new un(un._ParseParticleSystem(r,t,i,!0));return s.type=e.type,s.inheritDirection=e.inheritDirection,s.inheritedVelocityAmount=e.inheritedVelocityAmount,s.particleSystem._isSubEmitter=!0,s}dispose(){this.particleSystem.dispose()}}class Q_{get mesh(){return this._mesh}set mesh(e){this._mesh!==e&&(this._mesh=e,e?(this._indices=e.getIndices(),this._positions=e.getVerticesData(N.PositionKind),this._normals=e.getVerticesData(N.NormalKind)):(this._indices=null,this._positions=null,this._normals=null))}constructor(e=null){this._indices=null,this._positions=null,this._normals=null,this._storedNormal=m.Zero(),this._mesh=null,this.direction1=new m(0,1,0),this.direction2=new m(0,1,0),this.useMeshNormalsForDirection=!0,this.mesh=e}startDirectionFunction(e,t,i,r){if(this.useMeshNormalsForDirection&&this._normals){m.TransformNormalToRef(this._storedNormal,e,t);return}const s=Ne(this.direction1.x,this.direction2.x),n=Ne(this.direction1.y,this.direction2.y),o=Ne(this.direction1.z,this.direction2.z);if(r){t.copyFromFloats(s,n,o);return}m.TransformNormalFromFloatsToRef(s,n,o,e,t)}startPositionFunction(e,t,i,r){if(!this._indices||!this._positions)return;const s=3*Math.random()*(this._indices.length/3)|0,n=Math.random(),o=Math.random()*(1-n),l=1-n-o,u=this._indices[s],c=this._indices[s+1],h=this._indices[s+2],d=V.Vector3[0],f=V.Vector3[1],p=V.Vector3[2],g=V.Vector3[3];m.FromArrayToRef(this._positions,u*3,d),m.FromArrayToRef(this._positions,c*3,f),m.FromArrayToRef(this._positions,h*3,p),g.x=n*d.x+o*f.x+l*p.x,g.y=n*d.y+o*f.y+l*p.y,g.z=n*d.z+o*f.z+l*p.z,r?t.copyFromFloats(g.x,g.y,g.z):m.TransformCoordinatesFromFloatsToRef(g.x,g.y,g.z,e,t),this.useMeshNormalsForDirection&&this._normals&&(m.FromArrayToRef(this._normals,u*3,d),m.FromArrayToRef(this._normals,c*3,f),m.FromArrayToRef(this._normals,h*3,p),this._storedNormal.x=n*d.x+o*f.x+l*p.x,this._storedNormal.y=n*d.y+o*f.y+l*p.y,this._storedNormal.z=n*d.z+o*f.z+l*p.z)}clone(){const e=new Q_(this.mesh);return Ci.DeepCopy(this,e),e}applyToShader(e){e.setVector3("direction1",this.direction1),e.setVector3("direction2",this.direction2)}buildUniformLayout(e){e.addUniform("direction1",3),e.addUniform("direction2",3)}getEffectDefines(){return""}getClassName(){return"MeshParticleEmitter"}serialize(){var t;const e={};return e.type=this.getClassName(),e.direction1=this.direction1.asArray(),e.direction2=this.direction2.asArray(),e.meshId=(t=this.mesh)==null?void 0:t.id,e.useMeshNormalsForDirection=this.useMeshNormalsForDirection,e}parse(e,t){m.FromArrayToRef(e.direction1,0,this.direction1),m.FromArrayToRef(e.direction2,0,this.direction2),e.meshId&&t&&(this.mesh=t.getLastMeshById(e.meshId)),this.useMeshNormalsForDirection=e.useMeshNormalsForDirection}}class cn{constructor(){this.particlePositionGenerator=()=>{},this.particleDestinationGenerator=()=>{}}startDirectionFunction(e,t,i,r){const s=V.Vector3[0];if(this.particleDestinationGenerator){this.particleDestinationGenerator(-1,i,s);const n=V.Vector3[1];s.subtractToRef(i.position,n),n.scaleToRef(1/i.lifeTime,s)}else s.set(0,0,0);if(r){t.copyFrom(s);return}m.TransformNormalToRef(s,e,t)}startPositionFunction(e,t,i,r){const s=V.Vector3[0];if(this.particlePositionGenerator?this.particlePositionGenerator(-1,i,s):s.set(0,0,0),r){t.copyFrom(s);return}m.TransformCoordinatesToRef(s,e,t)}clone(){const e=new cn;return Ci.DeepCopy(this,e),e}applyToShader(e){}buildUniformLayout(e){}getEffectDefines(){return"#define CUSTOMEMITTER"}getClassName(){return"CustomParticleEmitter"}serialize(){const e={};return e.type=this.getClassName(),e.particlePositionGenerator=this.particlePositionGenerator,e.particleDestinationGenerator=this.particleDestinationGenerator,e}parse(e){e.particlePositionGenerator&&(this.particlePositionGenerator=e.particlePositionGenerator),e.particleDestinationGenerator&&(this.particleDestinationGenerator=e.particleDestinationGenerator)}}class oc{constructor(){this.direction1=new m(0,1,0),this.direction2=new m(0,1,0)}startDirectionFunction(e,t,i,r){const s=Ne(this.direction1.x,this.direction2.x),n=Ne(this.direction1.y,this.direction2.y),o=Ne(this.direction1.z,this.direction2.z);if(r){t.copyFromFloats(s,n,o);return}m.TransformNormalFromFloatsToRef(s,n,o,e,t)}startPositionFunction(e,t,i,r){if(r){t.copyFromFloats(0,0,0);return}m.TransformCoordinatesFromFloatsToRef(0,0,0,e,t)}clone(){const e=new oc;return Ci.DeepCopy(this,e),e}applyToShader(e){e.setVector3("direction1",this.direction1),e.setVector3("direction2",this.direction2)}buildUniformLayout(e){e.addUniform("direction1",3),e.addUniform("direction2",3)}getEffectDefines(){return"#define POINTEMITTER"}getClassName(){return"PointParticleEmitter"}serialize(){const e={};return e.type=this.getClassName(),e.direction1=this.direction1.asArray(),e.direction2=this.direction2.asArray(),e}parse(e){m.FromArrayToRef(e.direction1,0,this.direction1),m.FromArrayToRef(e.direction2,0,this.direction2)}}class lc{constructor(e=1,t=1,i=0){this.radius=e,this.radiusRange=t,this.directionRandomizer=i}startDirectionFunction(e,t,i,r){const s=i.position.subtract(e.getTranslation()).normalize(),n=Ne(0,this.directionRandomizer),o=Ne(0,this.directionRandomizer),l=Ne(0,this.directionRandomizer);if(s.x+=n,s.y+=o,s.z+=l,s.normalize(),r){t.copyFrom(s);return}m.TransformNormalFromFloatsToRef(s.x,s.y,s.z,e,t)}startPositionFunction(e,t,i,r){const s=this.radius-Ne(0,this.radius*this.radiusRange),n=Ne(0,1),o=Ne(0,2*Math.PI),l=Math.acos(2*n-1),u=s*Math.cos(o)*Math.sin(l),c=s*Math.cos(l),h=s*Math.sin(o)*Math.sin(l);if(r){t.copyFromFloats(u,Math.abs(c),h);return}m.TransformCoordinatesFromFloatsToRef(u,Math.abs(c),h,e,t)}clone(){const e=new lc(this.radius,this.directionRandomizer);return Ci.DeepCopy(this,e),e}applyToShader(e){e.setFloat("radius",this.radius),e.setFloat("radiusRange",this.radiusRange),e.setFloat("directionRandomizer",this.directionRandomizer)}buildUniformLayout(e){e.addUniform("radius",1),e.addUniform("radiusRange",1),e.addUniform("directionRandomizer",1)}getEffectDefines(){return"#define HEMISPHERICEMITTER"}getClassName(){return"HemisphericParticleEmitter"}serialize(){const e={};return e.type=this.getClassName(),e.radius=this.radius,e.radiusRange=this.radiusRange,e.directionRandomizer=this.directionRandomizer,e}parse(e){this.radius=e.radius,this.radiusRange=e.radiusRange,this.directionRandomizer=e.directionRandomizer}}class pl{constructor(e=1,t=1,i=0){this.radius=e,this.radiusRange=t,this.directionRandomizer=i}startDirectionFunction(e,t,i,r){const s=i.position.subtract(e.getTranslation()).normalize(),n=Ne(0,this.directionRandomizer),o=Ne(0,this.directionRandomizer),l=Ne(0,this.directionRandomizer);if(s.x+=n,s.y+=o,s.z+=l,s.normalize(),r){t.copyFrom(s);return}m.TransformNormalFromFloatsToRef(s.x,s.y,s.z,e,t)}startPositionFunction(e,t,i,r){const s=this.radius-Ne(0,this.radius*this.radiusRange),n=Ne(0,1),o=Ne(0,2*Math.PI),l=Math.acos(2*n-1),u=s*Math.cos(o)*Math.sin(l),c=s*Math.cos(l),h=s*Math.sin(o)*Math.sin(l);if(r){t.copyFromFloats(u,c,h);return}m.TransformCoordinatesFromFloatsToRef(u,c,h,e,t)}clone(){const e=new pl(this.radius,this.directionRandomizer);return Ci.DeepCopy(this,e),e}applyToShader(e){e.setFloat("radius",this.radius),e.setFloat("radiusRange",this.radiusRange),e.setFloat("directionRandomizer",this.directionRandomizer)}buildUniformLayout(e){e.addUniform("radius",1),e.addUniform("radiusRange",1),e.addUniform("directionRandomizer",1)}getEffectDefines(){return"#define SPHEREEMITTER"}getClassName(){return"SphereParticleEmitter"}serialize(){const e={};return e.type=this.getClassName(),e.radius=this.radius,e.radiusRange=this.radiusRange,e.directionRandomizer=this.directionRandomizer,e}parse(e){this.radius=e.radius,this.radiusRange=e.radiusRange,this.directionRandomizer=e.directionRandomizer}}class uc extends pl{constructor(e=1,t=new m(0,1,0),i=new m(0,1,0)){super(e),this.direction1=t,this.direction2=i}startDirectionFunction(e,t){const i=Ne(this.direction1.x,this.direction2.x),r=Ne(this.direction1.y,this.direction2.y),s=Ne(this.direction1.z,this.direction2.z);m.TransformNormalFromFloatsToRef(i,r,s,e,t)}clone(){const e=new uc(this.radius,this.direction1,this.direction2);return Ci.DeepCopy(this,e),e}applyToShader(e){e.setFloat("radius",this.radius),e.setFloat("radiusRange",this.radiusRange),e.setVector3("direction1",this.direction1),e.setVector3("direction2",this.direction2)}buildUniformLayout(e){e.addUniform("radius",1),e.addUniform("radiusRange",1),e.addUniform("direction1",3),e.addUniform("direction2",3)}getEffectDefines(){return`#define SPHEREEMITTER
#define DIRECTEDSPHEREEMITTER`}getClassName(){return"SphereDirectedParticleEmitter"}serialize(){const e=super.serialize();return e.direction1=this.direction1.asArray(),e.direction2=this.direction2.asArray(),e}parse(e){super.parse(e),this.direction1.copyFrom(e.direction1),this.direction2.copyFrom(e.direction2)}}class ml{constructor(e=1,t=1,i=1,r=0){this.radius=e,this.height=t,this.radiusRange=i,this.directionRandomizer=r,this._tempVector=m.Zero()}startDirectionFunction(e,t,i,r,s){i.position.subtractToRef(e.getTranslation(),this._tempVector),this._tempVector.normalize(),m.TransformNormalToRef(this._tempVector,s,this._tempVector);const n=Ne(-this.directionRandomizer/2,this.directionRandomizer/2);let o=Math.atan2(this._tempVector.x,this._tempVector.z);if(o+=Ne(-Math.PI/2,Math.PI/2)*this.directionRandomizer,this._tempVector.y=n,this._tempVector.x=Math.sin(o),this._tempVector.z=Math.cos(o),this._tempVector.normalize(),r){t.copyFrom(this._tempVector);return}m.TransformNormalFromFloatsToRef(this._tempVector.x,this._tempVector.y,this._tempVector.z,e,t)}startPositionFunction(e,t,i,r){const s=Ne(-this.height/2,this.height/2),n=Ne(0,2*Math.PI),o=Ne((1-this.radiusRange)*(1-this.radiusRange),1),l=Math.sqrt(o)*this.radius,u=l*Math.cos(n),c=l*Math.sin(n);if(r){t.copyFromFloats(u,s,c);return}m.TransformCoordinatesFromFloatsToRef(u,s,c,e,t)}clone(){const e=new ml(this.radius,this.directionRandomizer);return Ci.DeepCopy(this,e),e}applyToShader(e){e.setFloat("radius",this.radius),e.setFloat("height",this.height),e.setFloat("radiusRange",this.radiusRange),e.setFloat("directionRandomizer",this.directionRandomizer)}buildUniformLayout(e){e.addUniform("radius",1),e.addUniform("height",1),e.addUniform("radiusRange",1),e.addUniform("directionRandomizer",1)}getEffectDefines(){return"#define CYLINDEREMITTER"}getClassName(){return"CylinderParticleEmitter"}serialize(){const e={};return e.type=this.getClassName(),e.radius=this.radius,e.height=this.height,e.radiusRange=this.radiusRange,e.directionRandomizer=this.directionRandomizer,e}parse(e){this.radius=e.radius,this.height=e.height,this.radiusRange=e.radiusRange,this.directionRandomizer=e.directionRandomizer}}class cc extends ml{constructor(e=1,t=1,i=1,r=new m(0,1,0),s=new m(0,1,0)){super(e,t,i),this.direction1=r,this.direction2=s}startDirectionFunction(e,t,i,r){const s=Ne(this.direction1.x,this.direction2.x),n=Ne(this.direction1.y,this.direction2.y),o=Ne(this.direction1.z,this.direction2.z);if(r){t.copyFromFloats(s,n,o);return}m.TransformNormalFromFloatsToRef(s,n,o,e,t)}clone(){const e=new cc(this.radius,this.height,this.radiusRange,this.direction1,this.direction2);return Ci.DeepCopy(this,e),e}applyToShader(e){e.setFloat("radius",this.radius),e.setFloat("height",this.height),e.setFloat("radiusRange",this.radiusRange),e.setVector3("direction1",this.direction1),e.setVector3("direction2",this.direction2)}buildUniformLayout(e){e.addUniform("radius",1),e.addUniform("height",1),e.addUniform("radiusRange",1),e.addUniform("direction1",3),e.addUniform("direction2",3)}getEffectDefines(){return`#define CYLINDEREMITTER
#define DIRECTEDCYLINDEREMITTER`}getClassName(){return"CylinderDirectedParticleEmitter"}serialize(){const e=super.serialize();return e.direction1=this.direction1.asArray(),e.direction2=this.direction2.asArray(),e}parse(e){super.parse(e),m.FromArrayToRef(e.direction1,0,this.direction1),m.FromArrayToRef(e.direction2,0,this.direction2)}}class _l{get radius(){return this._radius}set radius(e){this._radius=e,this._buildHeight()}get angle(){return this._angle}set angle(e){this._angle=e,this._buildHeight()}_buildHeight(){this._angle!==0?this._height=this._radius/Math.tan(this._angle/2):this._height=1}constructor(e=1,t=Math.PI,i=0){this.directionRandomizer=i,this.radiusRange=1,this.heightRange=1,this.emitFromSpawnPointOnly=!1,this.angle=t,this.radius=e}startDirectionFunction(e,t,i,r){r?V.Vector3[0].copyFrom(i._localPosition).normalize():i.position.subtractToRef(e.getTranslation(),V.Vector3[0]).normalize();const s=Ne(0,this.directionRandomizer),n=Ne(0,this.directionRandomizer),o=Ne(0,this.directionRandomizer);t.x=V.Vector3[0].x+s,t.y=V.Vector3[0].y+n,t.z=V.Vector3[0].z+o,t.normalize()}startPositionFunction(e,t,i,r){const s=Ne(0,Math.PI*2);let n;this.emitFromSpawnPointOnly?n=1e-4:(n=Ne(0,this.heightRange),n=1-n*n);let o=this._radius-Ne(0,this._radius*this.radiusRange);o=o*n;const l=o*Math.sin(s),u=o*Math.cos(s),c=n*this._height;if(r){t.x=l,t.y=c,t.z=u;return}m.TransformCoordinatesFromFloatsToRef(l,c,u,e,t)}clone(){const e=new _l(this._radius,this._angle,this.directionRandomizer);return Ci.DeepCopy(this,e),e}applyToShader(e){e.setFloat2("radius",this._radius,this.radiusRange),e.setFloat("coneAngle",this._angle),e.setFloat2("height",this._height,this.heightRange),e.setFloat("directionRandomizer",this.directionRandomizer)}buildUniformLayout(e){e.addUniform("radius",2),e.addUniform("coneAngle",1),e.addUniform("height",2),e.addUniform("directionRandomizer",1)}getEffectDefines(){let e="#define CONEEMITTER";return this.emitFromSpawnPointOnly&&(e+=`
#define CONEEMITTERSPAWNPOINT`),e}getClassName(){return"ConeParticleEmitter"}serialize(){const e={};return e.type=this.getClassName(),e.radius=this._radius,e.angle=this._angle,e.directionRandomizer=this.directionRandomizer,e.radiusRange=this.radiusRange,e.heightRange=this.heightRange,e.emitFromSpawnPointOnly=this.emitFromSpawnPointOnly,e}parse(e){this.radius=e.radius,this.angle=e.angle,this.directionRandomizer=e.directionRandomizer,this.radiusRange=e.radiusRange!==void 0?e.radiusRange:1,this.heightRange=e.radiusRange!==void 0?e.heightRange:1,this.emitFromSpawnPointOnly=e.emitFromSpawnPointOnly!==void 0?e.emitFromSpawnPointOnly:!1}}class hc extends _l{constructor(e=1,t=Math.PI,i=new m(0,1,0),r=new m(0,1,0)){super(e,t),this.direction1=i,this.direction2=r}startDirectionFunction(e,t){const i=Ne(this.direction1.x,this.direction2.x),r=Ne(this.direction1.y,this.direction2.y),s=Ne(this.direction1.z,this.direction2.z);m.TransformNormalFromFloatsToRef(i,r,s,e,t)}clone(){const e=new hc(this.radius,this.angle,this.direction1,this.direction2);return Ci.DeepCopy(this,e),e}applyToShader(e){e.setFloat("radius",this.radius),e.setFloat("radiusRange",this.radiusRange),e.setVector3("direction1",this.direction1),e.setVector3("direction2",this.direction2)}buildUniformLayout(e){e.addUniform("radius",1),e.addUniform("radiusRange",1),e.addUniform("direction1",3),e.addUniform("direction2",3)}getEffectDefines(){return`#define CONEEMITTER
#define DIRECTEDCONEEMITTER`}getClassName(){return"ConeDirectedParticleEmitter"}serialize(){const e=super.serialize();return e.direction1=this.direction1.asArray(),e.direction2=this.direction2.asArray(),e}parse(e){super.parse(e),this.direction1.copyFrom(e.direction1),this.direction2.copyFrom(e.direction2)}}function fP(a,e){const t=new oc;return t.direction1=a,t.direction2=e,t}function pP(a=1,e=1){return new lc(a,e)}function mP(a=1,e=1){return new pl(a,e)}function _P(a=1,e=new m(0,1,0),t=new m(0,1,0)){return new uc(a,e,t)}function gP(a=1,e=1,t=1,i=0){return new ml(a,e,t,i)}function xP(a=1,e=1,t=1,i=new m(0,1,0),r=new m(0,1,0)){return new cc(a,e,t,i,r)}function SP(a=1,e=Math.PI/4){return new _l(a,e)}function vP(a=1,e=Math.PI/4,t=new m(0,1,0),i=new m(0,1,0)){return new hc(a,e,t,i)}class ut extends Ra{constructor(){super(...arguments),this._disposeEmitterOnDispose=!1,this._emitFromParticle=e=>{if(!this._subEmitters||this._subEmitters.length===0)return;const t=Math.floor(Math.random()*this._subEmitters.length);this._subEmitters[t].forEach(i=>{if(i.type===1){const r=i.clone();e._inheritParticleInfoToSubEmitter(r),r.particleSystem._rootParticleSystem=this,this.activeSubSystems.push(r.particleSystem),r.particleSystem.start()}})}}createPointEmitter(e,t){const i=fP(e,t);return this.particleEmitterType=i,i}createHemisphericEmitter(e=1,t=1){const i=pP(e,t);return this.particleEmitterType=i,i}createSphereEmitter(e=1,t=1){const i=mP(e,t);return this.particleEmitterType=i,i}createDirectedSphereEmitter(e=1,t=new m(0,1,0),i=new m(0,1,0)){const r=_P(e,t,i);return this.particleEmitterType=r,r}createCylinderEmitter(e=1,t=1,i=1,r=0){const s=gP(e,t,i,r);return this.particleEmitterType=s,s}createDirectedCylinderEmitter(e=1,t=1,i=1,r=new m(0,1,0),s=new m(0,1,0)){const n=xP(e,t,i,r,s);return this.particleEmitterType=n,n}createConeEmitter(e=1,t=Math.PI/4){const i=SP(e,t);return this.particleEmitterType=i,i}createDirectedConeEmitter(e=1,t=Math.PI/4,i=new m(0,1,0),r=new m(0,1,0)){const s=vP(e,t,i,r);return this.particleEmitterType=s,s}createBoxEmitter(e,t,i,r){const s=new ln;return this.particleEmitterType=s,this.direction1=e,this.direction2=t,this.minEmitBox=i,this.maxEmitBox=r,s}_prepareSubEmitterInternalArray(){this._subEmitters=new Array,this.subEmitters&&this.subEmitters.forEach(e=>{e instanceof ut?this._subEmitters.push([new un(e)]):e instanceof un?this._subEmitters.push([e]):e instanceof Array&&this._subEmitters.push(e)})}_stopSubEmitters(){this.activeSubSystems&&(this.activeSubSystems.forEach(e=>{e.stop(!0)}),this.activeSubSystems=[])}_removeFromRoot(){if(!this._rootParticleSystem)return;const e=this._rootParticleSystem.activeSubSystems.indexOf(this);e!==-1&&this._rootParticleSystem.activeSubSystems.splice(e,1),this._rootParticleSystem=null}_preStart(){this._prepareSubEmitterInternalArray(),this._subEmitters&&this._subEmitters.length!=0&&(this.activeSubSystems=[])}_postStop(e){e&&this._stopSubEmitters()}_prepareParticle(e){if(this._subEmitters&&this._subEmitters.length>0){const t=this._subEmitters[Math.floor(Math.random()*this._subEmitters.length)];e._attachedSubEmitters=[],t.forEach(i=>{if(i.type===0){const r=i.clone();e._attachedSubEmitters.push(r),r.particleSystem.start()}})}}_onDispose(e=!1,t=!1){var i;if(this._removeFromRoot(),this.subEmitters&&!this._subEmitters&&this._prepareSubEmitterInternalArray(),e&&((i=this.particles)==null||i.forEach(r=>{if(r._attachedSubEmitters)for(let s=r._attachedSubEmitters.length-1;s>=0;s-=1)r._attachedSubEmitters[s].dispose()})),t&&this.activeSubSystems)for(let r=this.activeSubSystems.length-1;r>=0;r-=1)this.activeSubSystems[r].dispose();if(this._subEmitters&&this._subEmitters.length){for(let r=0;r<this._subEmitters.length;r++)for(const s of this._subEmitters[r])s.dispose();this._subEmitters=[],this.subEmitters=[]}this._disposeEmitterOnDispose&&this.emitter&&this.emitter.dispose&&this.emitter.dispose(!0)}static _Parse(e,t,i,r){let s;i instanceof st?s=null:s=i;const n=oi("BABYLON.Texture");if(n&&s&&(e.texture?t.particleTexture=n.Parse(e.texture,s,r):e.textureName&&(t.particleTexture=new n(r+e.textureName,s,!1,e.invertY!==void 0?e.invertY:!0),t.particleTexture.name=e.textureName)),!e.emitterId&&e.emitterId!==0&&e.emitter===void 0?t.emitter=m.Zero():e.emitterId&&s?t.emitter=s.getLastMeshById(e.emitterId):t.emitter=m.FromArray(e.emitter),t.isLocal=!!e.isLocal,e.renderingGroupId!==void 0&&(t.renderingGroupId=e.renderingGroupId),e.isBillboardBased!==void 0&&(t.isBillboardBased=e.isBillboardBased),e.billboardMode!==void 0&&(t.billboardMode=e.billboardMode),e.useLogarithmicDepth!==void 0&&(t.useLogarithmicDepth=e.useLogarithmicDepth),e.animations){for(let l=0;l<e.animations.length;l++){const u=e.animations[l],c=oi("BABYLON.Animation");c&&t.animations.push(c.Parse(u))}t.beginAnimationOnStart=e.beginAnimationOnStart,t.beginAnimationFrom=e.beginAnimationFrom,t.beginAnimationTo=e.beginAnimationTo,t.beginAnimationLoop=e.beginAnimationLoop}if(e.autoAnimate&&s&&s.beginAnimation(t,e.autoAnimateFrom,e.autoAnimateTo,e.autoAnimateLoop,e.autoAnimateSpeed||1),t.startDelay=e.startDelay|0,t.minAngularSpeed=e.minAngularSpeed,t.maxAngularSpeed=e.maxAngularSpeed,t.minSize=e.minSize,t.maxSize=e.maxSize,e.minScaleX&&(t.minScaleX=e.minScaleX,t.maxScaleX=e.maxScaleX,t.minScaleY=e.minScaleY,t.maxScaleY=e.maxScaleY),e.preWarmCycles!==void 0&&(t.preWarmCycles=e.preWarmCycles,t.preWarmStepOffset=e.preWarmStepOffset),e.minInitialRotation!==void 0&&(t.minInitialRotation=e.minInitialRotation,t.maxInitialRotation=e.maxInitialRotation),t.minLifeTime=e.minLifeTime,t.maxLifeTime=e.maxLifeTime,t.minEmitPower=e.minEmitPower,t.maxEmitPower=e.maxEmitPower,t.emitRate=e.emitRate,t.gravity=m.FromArray(e.gravity),e.noiseStrength&&(t.noiseStrength=m.FromArray(e.noiseStrength)),t.color1=xe.FromArray(e.color1),t.color2=xe.FromArray(e.color2),t.colorDead=xe.FromArray(e.colorDead),t.updateSpeed=e.updateSpeed,t.targetStopDuration=e.targetStopDuration,t.blendMode=e.blendMode,e.colorGradients)for(const l of e.colorGradients)t.addColorGradient(l.gradient,xe.FromArray(l.color1),l.color2?xe.FromArray(l.color2):void 0);if(e.rampGradients){for(const l of e.rampGradients)t.addRampGradient(l.gradient,ne.FromArray(l.color));t.useRampGradients=e.useRampGradients}if(e.colorRemapGradients)for(const l of e.colorRemapGradients)t.addColorRemapGradient(l.gradient,l.factor1!==void 0?l.factor1:l.factor,l.factor2);if(e.alphaRemapGradients)for(const l of e.alphaRemapGradients)t.addAlphaRemapGradient(l.gradient,l.factor1!==void 0?l.factor1:l.factor,l.factor2);if(e.sizeGradients)for(const l of e.sizeGradients)t.addSizeGradient(l.gradient,l.factor1!==void 0?l.factor1:l.factor,l.factor2);if(e.angularSpeedGradients)for(const l of e.angularSpeedGradients)t.addAngularSpeedGradient(l.gradient,l.factor1!==void 0?l.factor1:l.factor,l.factor2);if(e.velocityGradients)for(const l of e.velocityGradients)t.addVelocityGradient(l.gradient,l.factor1!==void 0?l.factor1:l.factor,l.factor2);if(e.dragGradients)for(const l of e.dragGradients)t.addDragGradient(l.gradient,l.factor1!==void 0?l.factor1:l.factor,l.factor2);if(e.emitRateGradients)for(const l of e.emitRateGradients)t.addEmitRateGradient(l.gradient,l.factor1!==void 0?l.factor1:l.factor,l.factor2);if(e.startSizeGradients)for(const l of e.startSizeGradients)t.addStartSizeGradient(l.gradient,l.factor1!==void 0?l.factor1:l.factor,l.factor2);if(e.lifeTimeGradients)for(const l of e.lifeTimeGradients)t.addLifeTimeGradient(l.gradient,l.factor1!==void 0?l.factor1:l.factor,l.factor2);if(e.limitVelocityGradients){for(const l of e.limitVelocityGradients)t.addLimitVelocityGradient(l.gradient,l.factor1!==void 0?l.factor1:l.factor,l.factor2);t.limitVelocityDamping=e.limitVelocityDamping}if(e.noiseTexture&&s){const l=oi("BABYLON.ProceduralTexture");t.noiseTexture=l.Parse(e.noiseTexture,s,r)}let o;if(e.particleEmitterType){switch(e.particleEmitterType.type){case"SphereParticleEmitter":o=new pl;break;case"SphereDirectedParticleEmitter":o=new uc;break;case"ConeEmitter":case"ConeParticleEmitter":o=new _l;break;case"ConeDirectedParticleEmitter":o=new hc;break;case"CylinderParticleEmitter":o=new ml;break;case"CylinderDirectedParticleEmitter":o=new cc;break;case"HemisphericParticleEmitter":o=new lc;break;case"PointParticleEmitter":o=new oc;break;case"MeshParticleEmitter":o=new Q_;break;case"CustomParticleEmitter":o=new cn;break;case"BoxEmitter":case"BoxParticleEmitter":default:o=new ln;break}o.parse(e.particleEmitterType,s)}else o=new ln,o.parse(e,s);t.particleEmitterType=o,t.startSpriteCellID=e.startSpriteCellID,t.endSpriteCellID=e.endSpriteCellID,t.spriteCellLoop=e.spriteCellLoop??!0,t.spriteCellWidth=e.spriteCellWidth,t.spriteCellHeight=e.spriteCellHeight,t.spriteCellChangeSpeed=e.spriteCellChangeSpeed,t.spriteRandomStartCell=e.spriteRandomStartCell,t.disposeOnStop=e.disposeOnStop??!1,t.manualEmitCount=e.manualEmitCount??-1}static Parse(e,t,i,r=!1,s){const n=e.name;let o=null,l=null,u,c;if(t instanceof st?u=t:(c=t,u=c.getEngine()),e.customShader&&u.createEffectForParticles){l=e.customShader;const d=l.shaderOptions.defines.length>0?l.shaderOptions.defines.join(`
`):"";o=u.createEffectForParticles(l.shaderPath.fragmentElement,l.shaderOptions.uniforms,l.shaderOptions.samplers,d)}const h=new ut(n,s||e.capacity,t,o,e.isAnimationSheetEnabled);if(h.customShader=l,h._rootUrl=i,e.id&&(h.id=e.id),e.subEmitters){h.subEmitters=[];for(const d of e.subEmitters){const f=[];for(const p of d)f.push(un.Parse(p,t,i));h.subEmitters.push(f)}}return ut._Parse(e,h,t,i),e.textureMask&&(h.textureMask=xe.FromArray(e.textureMask)),e.worldOffset&&(h.worldOffset=m.FromArray(e.worldOffset)),e.preventAutoStart&&(h.preventAutoStart=e.preventAutoStart),!r&&!h.preventAutoStart&&h.start(),h}serialize(e=!1){const t={};if(ut._Serialize(t,this,e),t.textureMask=this.textureMask.asArray(),t.customShader=this.customShader,t.preventAutoStart=this.preventAutoStart,t.worldOffset=this.worldOffset.asArray(),this.subEmitters){t.subEmitters=[],this._subEmitters||this._prepareSubEmitterInternalArray();for(const i of this._subEmitters){const r=[];for(const s of i)r.push(s.serialize(e));t.subEmitters.push(r)}}return t}static _Serialize(e,t,i){if(e.name=t.name,e.id=t.id,e.capacity=t.getCapacity(),e.disposeOnStop=t.disposeOnStop,e.manualEmitCount=t.manualEmitCount,t.emitter.position){const _=t.emitter;e.emitterId=_.id}else{const _=t.emitter;e.emitter=_.asArray()}t.particleEmitterType&&(e.particleEmitterType=t.particleEmitterType.serialize()),t.particleTexture&&(i?e.texture=t.particleTexture.serialize():(e.textureName=t.particleTexture.name,e.invertY=!!t.particleTexture._invertY)),e.isLocal=t.isLocal,Me.AppendSerializedAnimations(t,e),e.beginAnimationOnStart=t.beginAnimationOnStart,e.beginAnimationFrom=t.beginAnimationFrom,e.beginAnimationTo=t.beginAnimationTo,e.beginAnimationLoop=t.beginAnimationLoop,e.startDelay=t.startDelay,e.renderingGroupId=t.renderingGroupId,e.isBillboardBased=t.isBillboardBased,e.billboardMode=t.billboardMode,e.minAngularSpeed=t.minAngularSpeed,e.maxAngularSpeed=t.maxAngularSpeed,e.minSize=t.minSize,e.maxSize=t.maxSize,e.minScaleX=t.minScaleX,e.maxScaleX=t.maxScaleX,e.minScaleY=t.minScaleY,e.maxScaleY=t.maxScaleY,e.minEmitPower=t.minEmitPower,e.maxEmitPower=t.maxEmitPower,e.minLifeTime=t.minLifeTime,e.maxLifeTime=t.maxLifeTime,e.emitRate=t.emitRate,e.gravity=t.gravity.asArray(),e.noiseStrength=t.noiseStrength.asArray(),e.color1=t.color1.asArray(),e.color2=t.color2.asArray(),e.colorDead=t.colorDead.asArray(),e.updateSpeed=t.updateSpeed,e.targetStopDuration=t.targetStopDuration,e.blendMode=t.blendMode,e.preWarmCycles=t.preWarmCycles,e.preWarmStepOffset=t.preWarmStepOffset,e.minInitialRotation=t.minInitialRotation,e.maxInitialRotation=t.maxInitialRotation,e.startSpriteCellID=t.startSpriteCellID,e.spriteCellLoop=t.spriteCellLoop,e.endSpriteCellID=t.endSpriteCellID,e.spriteCellChangeSpeed=t.spriteCellChangeSpeed,e.spriteCellWidth=t.spriteCellWidth,e.spriteCellHeight=t.spriteCellHeight,e.spriteRandomStartCell=t.spriteRandomStartCell,e.isAnimationSheetEnabled=t.isAnimationSheetEnabled,e.useLogarithmicDepth=t.useLogarithmicDepth;const r=t.getColorGradients();if(r){e.colorGradients=[];for(const _ of r){const S={gradient:_.gradient,color1:_.color1.asArray()};_.color2?S.color2=_.color2.asArray():S.color2=_.color1.asArray(),e.colorGradients.push(S)}}const s=t.getRampGradients();if(s){e.rampGradients=[];for(const _ of s){const S={gradient:_.gradient,color:_.color.asArray()};e.rampGradients.push(S)}e.useRampGradients=t.useRampGradients}const n=t.getColorRemapGradients();if(n){e.colorRemapGradients=[];for(const _ of n){const S={gradient:_.gradient,factor1:_.factor1};_.factor2!==void 0?S.factor2=_.factor2:S.factor2=_.factor1,e.colorRemapGradients.push(S)}}const o=t.getAlphaRemapGradients();if(o){e.alphaRemapGradients=[];for(const _ of o){const S={gradient:_.gradient,factor1:_.factor1};_.factor2!==void 0?S.factor2=_.factor2:S.factor2=_.factor1,e.alphaRemapGradients.push(S)}}const l=t.getSizeGradients();if(l){e.sizeGradients=[];for(const _ of l){const S={gradient:_.gradient,factor1:_.factor1};_.factor2!==void 0?S.factor2=_.factor2:S.factor2=_.factor1,e.sizeGradients.push(S)}}const u=t.getAngularSpeedGradients();if(u){e.angularSpeedGradients=[];for(const _ of u){const S={gradient:_.gradient,factor1:_.factor1};_.factor2!==void 0?S.factor2=_.factor2:S.factor2=_.factor1,e.angularSpeedGradients.push(S)}}const c=t.getVelocityGradients();if(c){e.velocityGradients=[];for(const _ of c){const S={gradient:_.gradient,factor1:_.factor1};_.factor2!==void 0?S.factor2=_.factor2:S.factor2=_.factor1,e.velocityGradients.push(S)}}const h=t.getDragGradients();if(h){e.dragGradients=[];for(const _ of h){const S={gradient:_.gradient,factor1:_.factor1};_.factor2!==void 0?S.factor2=_.factor2:S.factor2=_.factor1,e.dragGradients.push(S)}}const d=t.getEmitRateGradients();if(d){e.emitRateGradients=[];for(const _ of d){const S={gradient:_.gradient,factor1:_.factor1};_.factor2!==void 0?S.factor2=_.factor2:S.factor2=_.factor1,e.emitRateGradients.push(S)}}const f=t.getStartSizeGradients();if(f){e.startSizeGradients=[];for(const _ of f){const S={gradient:_.gradient,factor1:_.factor1};_.factor2!==void 0?S.factor2=_.factor2:S.factor2=_.factor1,e.startSizeGradients.push(S)}}const p=t.getLifeTimeGradients();if(p){e.lifeTimeGradients=[];for(const _ of p){const S={gradient:_.gradient,factor1:_.factor1};_.factor2!==void 0?S.factor2=_.factor2:S.factor2=_.factor1,e.lifeTimeGradients.push(S)}}const g=t.getLimitVelocityGradients();if(g){e.limitVelocityGradients=[];for(const _ of g){const S={gradient:_.gradient,factor1:_.factor1};_.factor2!==void 0?S.factor2=_.factor2:S.factor2=_.factor1,e.limitVelocityGradients.push(S)}e.limitVelocityDamping=t.limitVelocityDamping}t.noiseTexture&&(e.noiseTexture=t.noiseTexture.serialize())}clone(e,t,i=!1){const r={...this._customWrappers};let s=null;const n=this._engine;if(n.createEffectForParticles&&this.customShader!=null){s=this.customShader;const u=s.shaderOptions.defines.length>0?s.shaderOptions.defines.join(`
`):"",c=n.createEffectForParticles(s.shaderPath.fragmentElement,s.shaderOptions.uniforms,s.shaderOptions.samplers,u);r[0]?r[0].effect=c:this.setCustomEffect(c,0)}const o=this.serialize(i),l=ut.Parse(o,this._scene||this._engine,this._rootUrl);return l.name=e,l.customShader=s,l._customWrappers=r,t===void 0&&(t=this.emitter),this.noiseTexture&&(l.noiseTexture=this.noiseTexture.clone()),l.emitter=t,this.preventAutoStart||l.start(),l}}ut.BILLBOARDMODE_Y=2;ut.BILLBOARDMODE_ALL=7;ut.BILLBOARDMODE_STRETCHED=8;ut.BILLBOARDMODE_STRETCHED_LOCAL=9;un._ParseParticleSystem=ut.Parse;var Ga;(function(a){class e{serialize(){const r={},s=new Array(this._characterToIdx.size);return this._characterToIdx.forEach((n,o)=>{s[n]=o}),r.characters=s,r.insertionCosts=this._insertionCosts,r.deletionCosts=this._deletionCosts,r.substitutionCosts=this._substitutionCosts,JSON.stringify(r)}static Deserialize(r){const s=JSON.parse(r),n=new e(s.characters);return n._insertionCosts=s.insertionCosts,n._deletionCosts=s.deletionCosts,n._substitutionCosts=s.substitutionCosts,n}constructor(r,s=null,n=null,o=null){s=s??(()=>1),n=n??(()=>1),o=o??((u,c)=>u===c?0:1),this._characterToIdx=new Map,this._insertionCosts=new Array(r.length),this._deletionCosts=new Array(r.length),this._substitutionCosts=new Array(r.length);let l;for(let u=0;u<r.length;++u){l=r[u],this._characterToIdx.set(l,u),this._insertionCosts[u]=s(l),this._deletionCosts[u]=n(l),this._substitutionCosts[u]=new Array(r.length);for(let c=u;c<r.length;++c)this._substitutionCosts[u][c]=o(l,r[c])}}getCharacterIdx(r){return this._characterToIdx.get(r)}getInsertionCost(r){return this._insertionCosts[r]}getDeletionCost(r){return this._deletionCosts[r]}getSubstitutionCost(r,s){const n=Math.min(r,s),o=Math.max(r,s);return this._substitutionCosts[n][o]}}a.Alphabet=e;class t{serialize(){return JSON.stringify(this._characters)}static Deserialize(r,s){const n=new t([],s);return n._characters=JSON.parse(r),n}constructor(r,s){if(r.length>t._MAX_SEQUENCE_LENGTH)throw new Error("Sequences longer than "+t._MAX_SEQUENCE_LENGTH+" not supported.");this._alphabet=s,this._characters=r.map(n=>this._alphabet.getCharacterIdx(n))}distance(r){return t._Distance(this,r)}static _Distance(r,s){const n=r._alphabet;if(n!==s._alphabet)throw new Error("Cannot Levenshtein compare Sequences built from different alphabets.");const o=r._characters,l=s._characters,u=o.length,c=l.length,h=t._CostMatrix;h[0][0]=0;for(let d=0;d<u;++d)h[d+1][0]=h[d][0]+n.getInsertionCost(o[d]);for(let d=0;d<c;++d)h[0][d+1]=h[0][d]+n.getInsertionCost(l[d]);for(let d=0;d<u;++d)for(let f=0;f<c;++f)t._InsertionCost=h[d+1][f]+n.getInsertionCost(l[f]),t._DeletionCost=h[d][f+1]+n.getDeletionCost(o[d]),t._SubstitutionCost=h[d][f]+n.getSubstitutionCost(o[d],l[f]),h[d+1][f+1]=Math.min(t._InsertionCost,t._DeletionCost,t._SubstitutionCost);return h[u][c]}}t._MAX_SEQUENCE_LENGTH=256,t._CostMatrix=[...Array(t._MAX_SEQUENCE_LENGTH+1)].map(()=>new Array(t._MAX_SEQUENCE_LENGTH+1)),a.Sequence=t})(Ga||(Ga={}));class nt{serialize(){return JSON.stringify(this)}static Deserialize(e){const t=JSON.parse(e),i=new nt(t._segmentLength);return i._points=t._points.map(r=>new m(r._x,r._y,r._z)),i}constructor(e=.01){this._points=[],this._segmentLength=e}getLength(){return this._points.length*this._segmentLength}add(e){let t=this._points.length;if(t===0)this._points.push(e.clone());else{const i=()=>this._segmentLength/m.Distance(this._points[t-1],e);for(let r=i();r<=1;r=i()){const s=this._points[t-1].scale(1-r);e.scaleAndAddToRef(r,s),this._points.push(s),++t}}}resampleAtTargetResolution(e){const t=new nt(this.getLength()/e);return this._points.forEach(i=>{t.add(i)}),t}tokenize(e){const t=[],i=new m;for(let r=2;r<this._points.length;++r)nt._TransformSegmentDirToRef(this._points[r-2],this._points[r-1],this._points[r],i)&&t.push(nt._TokenizeSegment(i,e));return t}static _TransformSegmentDirToRef(e,t,i,r){return t.subtractToRef(e,nt._ForwardDir),nt._ForwardDir.normalize(),t.scaleToRef(-1,nt._InverseFromVec),nt._InverseFromVec.normalize(),Math.abs(m.Dot(nt._ForwardDir,nt._InverseFromVec))>.98?!1:(m.CrossToRef(nt._ForwardDir,nt._InverseFromVec,nt._UpDir),nt._UpDir.normalize(),$.LookAtLHToRef(e,t,nt._UpDir,nt._LookMatrix),i.subtractToRef(t,nt._FromToVec),nt._FromToVec.normalize(),m.TransformNormalToRef(nt._FromToVec,nt._LookMatrix,r),!0)}static _TokenizeSegment(e,t){nt._BestMatch=0,nt._Score=m.Dot(e,t[0]),nt._BestScore=nt._Score;for(let i=1;i<t.length;++i)nt._Score=m.Dot(e,t[i]),nt._Score>nt._BestScore&&(nt._BestMatch=i,nt._BestScore=nt._Score);return nt._BestMatch}}nt._ForwardDir=new m;nt._InverseFromVec=new m;nt._UpDir=new m;nt._FromToVec=new m;nt._LookMatrix=new $;class el{static Generate(e=64,t=256,i=.1,r=.001,s=[]){const l=new el(e);for(let p=0;p<e;++p)l.chars[p]=new m(Math.random()-.5,Math.random()-.5,Math.random()-.5),l.chars[p].normalize();for(let p=0;p<s.length;++p)l.chars[p].copyFrom(s[p]);let u,c;const h=new m,d=new m,f=(p,g,_)=>(1-_)*p+_*g;for(let p=0;p<t;++p){u=f(i,r,p/(t-1));for(let g=s.length;g<l.chars.length;++g)h.copyFromFloats(0,0,0),l.chars.forEach(_=>{l.chars[g].subtractToRef(_,d),c=d.lengthSquared(),c>1e-6&&d.scaleAndAddToRef(1/(d.lengthSquared()*c),h)}),h.scaleInPlace(u),l.chars[g].addInPlace(h),l.chars[g].normalize()}return l}serialize(){return JSON.stringify(this.chars)}static Deserialize(e){const t=JSON.parse(e),i=new el(t.length);for(let r=0;r<t.length;++r)i.chars[r]=new m(t[r]._x,t[r]._y,t[r]._z);return i}constructor(e){this.chars=new Array(e)}}class es{serialize(){return JSON.stringify(this._sequences.map(e=>e.serialize()))}static Deserialize(e,t){const i=new es;return i._sequences=JSON.parse(e).map(r=>Ga.Sequence.Deserialize(r,t)),i}static CreateFromTrajectory(e,t,i){return es.CreateFromTokenizationPyramid(es._GetTokenizationPyramid(e,t),i)}static CreateFromTokenizationPyramid(e,t){const i=new es;return i._sequences=e.map(r=>new Ga.Sequence(r,t)),i}constructor(){this._sequences=[]}static _GetTokenizationPyramid(e,t,i=es._FINEST_DESCRIPTOR_RESOLUTION){const r=[];for(let s=i;s>4;s=Math.floor(s/2))r.push(e.resampleAtTargetResolution(s).tokenize(t.chars));return r}distance(e){let t=0,i;for(let r=0;r<this._sequences.length;++r)i=Math.pow(2,r),t+=i*this._sequences[r].distance(e._sequences[r]);return t}}es._FINEST_DESCRIPTOR_RESOLUTION=32;class Wa{serialize(){const e={};return e.descriptors=this._descriptors.map(t=>t.serialize()),e.centroidIdx=this._centroidIdx,e.averageDistance=this._averageDistance,JSON.stringify(e)}static Deserialize(e,t){const i=JSON.parse(e),r=new Wa;return r._descriptors=i.descriptors.map(s=>es.Deserialize(s,t)),r._centroidIdx=i.centroidIdx,r._averageDistance=i.averageDistance,r}constructor(e=[]){this._descriptors=e,this._centroidIdx=-1,this._averageDistance=0,this._refreshDescription()}add(e){this._descriptors.push(e),this._refreshDescription()}getMatchCost(e){return e.distance(this._descriptors[this._centroidIdx])/this._averageDistance}getMatchMinimumDistance(e){return Math.min(...this._descriptors.map(t=>t.distance(e)))}_refreshDescription(){this._centroidIdx=-1;let e;const t=this._descriptors.map(i=>(e=0,this._descriptors.forEach(r=>{e+=i.distance(r)}),e));for(let i=0;i<t.length;++i)(this._centroidIdx<0||t[i]<t[this._centroidIdx])&&(this._centroidIdx=i);this._averageDistance=0,this._descriptors.forEach(i=>{this._averageDistance+=i.distance(this._descriptors[this._centroidIdx])}),this._descriptors.length>0&&(this._averageDistance=Math.max(this._averageDistance/this._descriptors.length,Wa._MIN_AVERAGE_DISTANCE))}}Wa._MIN_AVERAGE_DISTANCE=1;class Ad{serialize(){const e={};return e.maximumAllowableMatchCost=this._maximumAllowableMatchCost,e.vector3Alphabet=this._vector3Alphabet.serialize(),e.levenshteinAlphabet=this._levenshteinAlphabet.serialize(),e.nameToDescribedTrajectory=[],this._nameToDescribedTrajectory.forEach((t,i)=>{e.nameToDescribedTrajectory.push(i),e.nameToDescribedTrajectory.push(t.serialize())}),JSON.stringify(e)}static Deserialize(e){const t=JSON.parse(e),i=new Ad;i._maximumAllowableMatchCost=t.maximumAllowableMatchCost,i._vector3Alphabet=el.Deserialize(t.vector3Alphabet),i._levenshteinAlphabet=Ga.Alphabet.Deserialize(t.levenshteinAlphabet);for(let r=0;r<t.nameToDescribedTrajectory.length;r+=2)i._nameToDescribedTrajectory.set(t.nameToDescribedTrajectory[r],Wa.Deserialize(t.nameToDescribedTrajectory[r+1],i._levenshteinAlphabet));return i}static Generate(){const e=el.Generate(64,256,.1,.001,[m.Forward()]),t=new Array(e.chars.length);for(let s=0;s<t.length;++s)t[s]=s;const i=new Ga.Alphabet(t,s=>s===0?0:1,s=>s===0?0:1,(s,n)=>Math.min(1-m.Dot(e.chars[s],e.chars[n]),1)),r=new Ad;return r._vector3Alphabet=e,r._levenshteinAlphabet=i,r}constructor(){this._maximumAllowableMatchCost=4,this._nameToDescribedTrajectory=new Map}addTrajectoryToClassification(e,t){this._nameToDescribedTrajectory.has(t)||this._nameToDescribedTrajectory.set(t,new Wa),this._nameToDescribedTrajectory.get(t).add(es.CreateFromTrajectory(e,this._vector3Alphabet,this._levenshteinAlphabet))}deleteClassification(e){return this._nameToDescribedTrajectory.delete(e)}classifyTrajectory(e){const t=es.CreateFromTrajectory(e,this._vector3Alphabet,this._levenshteinAlphabet),i=[];if(this._nameToDescribedTrajectory.forEach((o,l)=>{o.getMatchCost(t)<this._maximumAllowableMatchCost&&i.push(l)}),i.length===0)return null;let r=0,s=this._nameToDescribedTrajectory.get(i[r]).getMatchMinimumDistance(t),n;for(let o=0;o<i.length;++o)n=this._nameToDescribedTrajectory.get(i[o]).getMatchMinimumDistance(t),n<s&&(s=n,r=o);return i[r]}}class au{constructor(e,t,i){this._scene=e,L.Log(`[Reflector] Connecting to ws://${t}:${i}`),this._webSocket=new WebSocket(`ws://${t}:${i}`),this._webSocket.onmessage=r=>{const s=r.data;if(s.startsWith(au._SERVER_PREFIX)){const n=s.substring(au._SERVER_PREFIX.length);L.Log(`[Reflector] Received server message: ${n.substring(0,64)}`),this._handleServerMessage(n);return}else L.Log(`[Reflector] Received client message: ${s.substring(0,64)}`),this._handleClientMessage()},this._webSocket.onclose=r=>{L.Log(`[Reflector] Disconnected ${r.code} ${r.reason}`)}}close(){this._webSocket.close()}_handleServerMessage(e){switch(e){case"connected":{Sa.SerializeAsync(this._scene).then(t=>{this._webSocket.send(`load|${JSON.stringify(t)}`)});break}}}_handleClientMessage(){}}au._SERVER_PREFIX="$$";const UB=1.5;class Ws{constructor(e){this._view=new Float32Array(e),this._itemLength=0}get itemLength(){return this._itemLength}at(e){return e<0||e>=this._itemLength?NaN:this._view[e]}subarray(e,t){return e>=t||e<0?new Float32Array(0):(t>this._itemLength&&(t=this._itemLength),this._view.subarray(e,t))}push(e){this._view[this._itemLength]=e,this._itemLength++,this._itemLength>=this._view.length&&this._growArray()}_growArray(){const e=Math.floor(this._view.length*UB),t=new Float32Array(e);t.set(this._view),this._view=t}}const $s=1800,GB=24,WB="0",_v="timestamp",gv="numPoints",$B=/\r/g,jc="@";class Ar{static get SliceDataOffset(){return 2}static get NumberOfPointsOffset(){return 1}constructor(e,t){this._scene=e,this._collectDataAtFrame=()=>{const i=Li.Now-this._startingTimestamp,r=this.datasets.ids.length,s=this.datasets.startingIndices.itemLength;let n=0;if(s>0){const o=this.datasets.startingIndices.at(s-1);n=o+this.datasets.data.at(o+Ar.NumberOfPointsOffset)+Ar.SliceDataOffset}if(this.datasets.startingIndices.push(n),this.datasets.data.push(i),this.datasets.data.push(r),this.datasets.ids.forEach(o=>{const l=this._strategies.get(o);l&&this.datasets.data.push(l.getData())}),this.datasetObservable.hasObservers()){const o=[i,r];for(let l=0;l<r;l++)o.push(this.datasets.data.at(n+Ar.SliceDataOffset+l));this.datasetObservable.notifyObservers(o)}},this.datasets={ids:[],data:new Ws($s),startingIndices:new Ws($s)},this._strategies=new Map,this._datasetMeta=new Map,this._eventRestoreSet=new Set,this._customEventObservable=new j,this.datasetObservable=new j,this.metadataObservable=new j(i=>i.callback(this._datasetMeta,new VM(0))),t&&this.addCollectionStrategies(...t)}registerEvent(e,t,i){var n;if(this._strategies.has(e)&&!t)return;this._strategies.has(e)&&t&&((n=this._strategies.get(e))==null||n.dispose(),this._strategies.delete(e));const r=o=>{let l=0,u=0;const c=o.onAfterRenderObservable.add(()=>{u=l,l=0}),h=this._customEventObservable.add(d=>{e===d.name&&(d.value!==void 0?l=d.value:l++)});return{id:e,getData:()=>u,dispose:()=>{o.onAfterRenderObservable.remove(c),this._customEventObservable.remove(h)}}},s={name:e};return this._eventRestoreSet.add(e),this.addCollectionStrategies({strategyCallback:r,category:i}),s}sendEvent(e){this._customEventObservable.notifyObservers(e)}_restoreStringEvents(){this._eventRestoreSet.size!==this._customEventObservable.observers.length&&this._eventRestoreSet.forEach(e=>{this.registerEvent(e,!0)})}addCollectionStrategies(...e){for(let{strategyCallback:t,category:i,hidden:r}of e){const s=t(this._scene);if(this._strategies.has(s.id)){s.dispose();continue}this.datasets.ids.push(s.id),i&&(i=i.replace(new RegExp(jc,"g"),"")),this._datasetMeta.set(s.id,{color:this._getHexColorFromId(s.id),category:i,hidden:r}),this._strategies.set(s.id,s)}this.metadataObservable.notifyObservers(this._datasetMeta)}_getHexColorFromId(e){let t=0;for(let r=0;r<e.length;r++)t=e.charCodeAt(r)+((t<<5)-t);let i="#";for(let r=0;r<GB;r+=8){const s=t>>r&255,n=WB+s.toString(16);i+=n.substring(n.length-2)}return i}getCurrentSlice(){const e=Li.Now-this._startingTimestamp,t=this.datasets.ids.length,i=[e,t];this.datasets.ids.forEach(r=>{const s=this._strategies.get(r);s&&this.datasetObservable.hasObservers()&&i.push(s.getData())}),this.datasetObservable.hasObservers()&&this.datasetObservable.notifyObservers(i)}updateMetadata(e,t,i){const r=this._datasetMeta.get(e);r&&(r[t]=i,this.metadataObservable.notifyObservers(this._datasetMeta))}clear(e){this.datasets.data=new Ws($s),this.datasets.ids.length=0,this.datasets.startingIndices=new Ws($s),this._datasetMeta.clear(),this._strategies.forEach(t=>t.dispose()),this._strategies.clear(),e||this._eventRestoreSet.clear(),this._hasLoadedData=!1}get hasLoadedData(){return this._hasLoadedData}loadFromFileData(e,t){const i=e.replace($B,"").split(`
`).map(h=>h.split(",").filter(d=>d.length>0)).filter(h=>h.length>0),r=0,s=Ar.NumberOfPointsOffset;if(i.length<2)return!1;const n={ids:[],data:new Ws($s),startingIndices:new Ws($s)},[o,...l]=i;if(o.length<2||o[r]!==_v||o[s]!==gv)return!1;const u=new Map;for(let h=Ar.SliceDataOffset;h<o.length;h++){const[d,f]=o[h].split(jc);n.ids.push(d),u.set(d,f)}let c=0;for(const h of l){if(h.length<2)return!1;const d=parseFloat(h[r]),f=parseInt(h[s]);if(isNaN(f)||isNaN(d)||(n.data.push(d),n.data.push(f),f+Ar.SliceDataOffset!==h.length))return!1;for(let p=Ar.SliceDataOffset;p<h.length;p++){const g=parseFloat(h[p]);if(isNaN(g))return!1;n.data.push(g)}n.startingIndices.push(c),c+=h.length}if(this.datasets.ids=n.ids,this.datasets.data=n.data,this.datasets.startingIndices=n.startingIndices,t||this._datasetMeta.clear(),this._strategies.forEach(h=>h.dispose()),this._strategies.clear(),!t)for(const h of this.datasets.ids){const d=u.get(h);this._datasetMeta.set(h,{category:d,color:this._getHexColorFromId(h)})}return this.metadataObservable.notifyObservers(this._datasetMeta),this._hasLoadedData=!0,!0}exportDataToCsv(){let e="";e+=`${_v},${gv}`;for(let i=0;i<this.datasets.ids.length;i++)if(e+=`,${this.datasets.ids[i]}`,this._datasetMeta){const r=this._datasetMeta.get(this.datasets.ids[i]);r!=null&&r.category&&(e+=`${jc}${r.category}`)}e+=`
`;for(let i=0;i<this.datasets.startingIndices.itemLength;i++){const r=this.datasets.startingIndices.at(i),s=this.datasets.data.at(r),n=this.datasets.data.at(r+Ar.NumberOfPointsOffset);e+=`${s},${n}`;for(let o=0;o<n;o++)e+=`,${this.datasets.data.at(r+Ar.SliceDataOffset+o)}`;for(let o=0;o<this.datasets.ids.length-n;o++)e+=",";e+=`
`}const t=`${new Date().toISOString()}-perfdata.csv`;ae.Download(new Blob([e],{type:"text/csv"}),t)}start(e){e?this._startingTimestamp===void 0&&(this._startingTimestamp=Li.Now):(this.datasets.data=new Ws($s),this.datasets.startingIndices=new Ws($s),this._startingTimestamp=Li.Now),this._scene.onAfterRenderObservable.add(this._collectDataAtFrame),this._restoreStringEvents(),this._isStarted=!0}stop(){this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame),this._isStarted=!1}get isStarted(){return this._isStarted}dispose(){this._scene.onAfterRenderObservable.removeCallback(this._collectDataAtFrame),this._datasetMeta.clear(),this._strategies.forEach(e=>{e.dispose()}),this.datasetObservable.clear(),this.metadataObservable.clear(),this._isStarted=!1,this.datasets=null}}Te.prototype.getPerfCollector=function(){return this._perfCollector||(this._perfCollector=new Ar(this)),this._perfCollector};function HB(a){const e=new Array,t=new Array,i=new Array,r=a.add(()=>{const n=e.length;for(let o=0;o<n;o++)zM(e.shift(),t.shift(),i.shift())});return{scheduler:(n,o,l)=>{e.push(n),t.push(o),i.push(l)},dispose:()=>{a.remove(r)}}}j.prototype.runCoroutineAsync=function(a){if(!this._coroutineScheduler){const e=HB(this);this._coroutineScheduler=e.scheduler,this._coroutineSchedulerDispose=e.dispose}return kM(a,this._coroutineScheduler)};j.prototype.cancelAllCoroutines=function(){this._coroutineSchedulerDispose&&this._coroutineSchedulerDispose(),this._coroutineScheduler=void 0,this._coroutineSchedulerDispose=void 0};const xv="equirectangularPanoramaPixelShader",jB=`#ifdef GL_ES
precision highp float;
#endif
#define M_PI 3.1415926535897932384626433832795
varying vec2 vUV;uniform samplerCube cubeMap;void main(void) {vec2 uv=vUV;float longitude=uv.x*2.*M_PI-M_PI+M_PI/2.;float latitude=(1.-uv.y)*M_PI;vec3 dir=vec3(
- sin( longitude )*sin( latitude ),
cos( latitude ),
- cos( longitude )*sin( latitude )
);normalize( dir );gl_FragColor=textureCube( cubeMap,dir );}`;P.ShadersStore[xv]||(P.ShadersStore[xv]=jB);const Dd="copyTextureToTexturePixelShader",bP=`uniform float conversion;uniform sampler2D textureSampler;varying vec2 vUV;
#include<helperFunctions>
void main(void) 
{vec4 color=texture2D(textureSampler,vUV);
#ifdef DEPTH_TEXTURE
gl_FragDepth=color.r;
#else
if (conversion==1.) {color=toLinearSpace(color);} else if (conversion==2.) {color=toGammaSpace(color);}
gl_FragColor=color;
#endif
}
`;P.ShadersStore[Dd]||(P.ShadersStore[Dd]=bP);const YB={name:Dd,shader:bP},XB=Object.freeze(Object.defineProperty({__proto__:null,copyTextureToTexturePixelShader:YB},Symbol.toStringTag,{value:"Module"})),Od="copyTextureToTexturePixelShader",yP=`uniform conversion: f32;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;varying vUV: vec2f;
#include<helperFunctions>
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var color: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV);
#ifdef DEPTH_TEXTURE
fragmentOutputs.fragDepth=color.r;
#else
if (uniforms.conversion==1.) {color=toLinearSpaceVec4(color);} else if (uniforms.conversion==2.) {color=toGammaSpace(color);}
fragmentOutputs.color=color;
#endif
}
`;P.ShadersStoreWGSL[Od]||(P.ShadersStoreWGSL[Od]=yP);const ZB={name:Od,shader:yP},qB=Object.freeze(Object.defineProperty({__proto__:null,copyTextureToTexturePixelShaderWGSL:ZB},Symbol.toStringTag,{value:"Module"}));st.OfflineProviderFactory=(a,e,t=!1)=>new Pi(a,e,t);class Pi{get enableSceneOffline(){return this._enableSceneOffline}get enableTexturesOffline(){return this._enableTexturesOffline}constructor(e,t,i=!1){this._idbFactory=typeof indexedDB<"u"?indexedDB:void 0,this._currentSceneUrl=Pi._ReturnFullUrlLocation(e),this._db=null,this._enableSceneOffline=!1,this._enableTexturesOffline=!1,this._manifestVersionFound=0,this._mustUpdateRessources=!1,this._hasReachedQuota=!1,Pi.IDBStorageEnabled?i?(this._enableSceneOffline=!0,this._enableTexturesOffline=!0,this._manifestVersionFound=1,ae.SetImmediate(()=>{t(!0)})):this._checkManifestFile(t):t(!0)}_checkManifestFile(e){const t=()=>{this._enableSceneOffline=!1,this._enableTexturesOffline=!1,e(!1)},i=()=>{try{if(typeof URL=="function"&&this._currentSceneUrl.indexOf("http")===0){const o=new URL(this._currentSceneUrl);return o.pathname+=".manifest",o.toString()}}catch{}return`${this._currentSceneUrl}.manifest`};let r=!1,s=i();const n=new ss;navigator.onLine&&(r=!0,s=s+(s.match(/\?/)==null?"?":"&")+Date.now()),n.open("GET",s),n.addEventListener("load",()=>{if(n.status===200||Pi._ValidateXHRData(n,1))try{const o=JSON.parse(n.response);this._enableSceneOffline=o.enableSceneOffline,this._enableTexturesOffline=o.enableTexturesOffline&&Pi._IsUASupportingBlobStorage,o.version&&!isNaN(parseInt(o.version))&&(this._manifestVersionFound=o.version),e(!0)}catch{t()}else t()},!1),n.addEventListener("error",()=>{if(r){r=!1;const o=i();n.open("GET",o),n.send()}else t()},!1);try{n.send()}catch{L.Error("Error on XHR send request."),e(!1)}}open(e,t){const i=()=>{this._isSupported=!1,t&&t()};if(!this._idbFactory||!(this._enableSceneOffline||this._enableTexturesOffline))this._isSupported=!1,t&&t();else if(this._db)e&&e();else{this._hasReachedQuota=!1,this._isSupported=!0;const r=this._idbFactory.open("babylonjs",1);r.onerror=()=>{i()},r.onblocked=()=>{L.Error("IDB request blocked. Please reload the page."),i()},r.onsuccess=()=>{this._db=r.result,e()},r.onupgradeneeded=s=>{if(this._db=s.target.result,this._db)try{this._db.createObjectStore("scenes",{keyPath:"sceneUrl"}),this._db.createObjectStore("versions",{keyPath:"sceneUrl"}),this._db.createObjectStore("textures",{keyPath:"textureUrl"})}catch(n){L.Error("Error while creating object stores. Exception: "+n.message),i()}}}}loadImage(e,t){const i=Pi._ReturnFullUrlLocation(e),r=()=>{!this._hasReachedQuota&&this._db!==null?this._saveImageIntoDBAsync(i,t):t.src=e};this._mustUpdateRessources?r():this._loadImageFromDBAsync(i,t,r)}_loadImageFromDBAsync(e,t,i){if(this._isSupported&&this._db!==null){let r;const s=this._db.transaction(["textures"]);s.onabort=()=>{t.src=e},s.oncomplete=()=>{let o;r&&typeof URL=="function"?(o=URL.createObjectURL(r.data),t.onerror=()=>{L.Error("Error loading image from blob URL: "+o+" switching back to web url: "+e),t.src=e},t.src=o):i()};const n=s.objectStore("textures").get(e);n.onsuccess=o=>{r=o.target.result},n.onerror=()=>{L.Error("Error loading texture "+e+" from DB."),t.src=e}}else L.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."),t.src=e}_saveImageIntoDBAsync(e,t){let i;if(this._isSupported){const r=()=>{let s;if(i&&typeof URL=="function")try{s=URL.createObjectURL(i)}catch{s=URL.createObjectURL(i)}s&&(t.src=s)};if(Pi._IsUASupportingBlobStorage){const s=new ss;s.open("GET",e),s.responseType="blob",s.addEventListener("load",()=>{if(s.status===200&&this._db){i=s.response;const n=this._db.transaction(["textures"],"readwrite");n.onabort=l=>{try{const c=l.target.error;c&&c.name==="QuotaExceededError"&&(this._hasReachedQuota=!0)}catch{}r()},n.oncomplete=()=>{r()};const o={textureUrl:e,data:i};try{const l=n.objectStore("textures").put(o);l.onsuccess=()=>{},l.onerror=()=>{r()}}catch(l){l.code===25&&(Pi._IsUASupportingBlobStorage=!1,this._enableTexturesOffline=!1),t.src=e}}else t.src=e},!1),s.addEventListener("error",()=>{L.Error("Error in XHR request in BABYLON.Database."),t.src=e},!1),s.send()}else t.src=e}else L.Error("Error: IndexedDB not supported by your browser or Babylon.js database is not open."),t.src=e}_checkVersionFromDB(e,t){const i=()=>{this._saveVersionIntoDBAsync(e,t)};this._loadVersionFromDBAsync(e,t,i)}_loadVersionFromDBAsync(e,t,i){if(this._isSupported&&this._db){let r;try{const s=this._db.transaction(["versions"]);s.oncomplete=()=>{r?this._manifestVersionFound!==r.data?(this._mustUpdateRessources=!0,i()):t(r.data):(this._mustUpdateRessources=!0,i())},s.onabort=()=>{t(-1)};const n=s.objectStore("versions").get(e);n.onsuccess=o=>{r=o.target.result},n.onerror=()=>{L.Error("Error loading version for scene "+e+" from DB."),t(-1)}}catch(s){L.Error("Error while accessing 'versions' object store (READ OP). Exception: "+s.message),t(-1)}}else L.Error("Error: IndexedDB not supported by your browser or Babylon.js database is not open."),t(-1)}_saveVersionIntoDBAsync(e,t){if(this._isSupported&&!this._hasReachedQuota&&this._db)try{const i=this._db.transaction(["versions"],"readwrite");i.onabort=n=>{try{const o=n.target.error;o&&o.name==="QuotaExceededError"&&(this._hasReachedQuota=!0)}catch{}t(-1)},i.oncomplete=()=>{t(this._manifestVersionFound)};const r={sceneUrl:e,data:this._manifestVersionFound},s=i.objectStore("versions").put(r);s.onsuccess=()=>{},s.onerror=()=>{L.Error("Error in DB add version request in BABYLON.Database.")}}catch(i){L.Error("Error while accessing 'versions' object store (WRITE OP). Exception: "+i.message),t(-1)}else t(-1)}loadFile(e,t,i,r,s){const n=Pi._ReturnFullUrlLocation(e),o=()=>{this._saveFileAsync(n,t,i,s,r)};this._checkVersionFromDB(n,l=>{l!==-1?this._mustUpdateRessources?this._saveFileAsync(n,t,i,s,r):this._loadFileAsync(n,t,o,i):r&&r()})}_loadFileAsync(e,t,i,r){if(this._isSupported&&this._db){let s;e.indexOf(".babylon")!==-1?s="scenes":s="textures";let n;const o=this._db.transaction([s]);o.oncomplete=()=>{var u;if(n){if(r){const c=((u=n.data)==null?void 0:u.byteLength)||0;r({total:c,loaded:c,lengthComputable:!0})}t(n.data)}else i()},o.onabort=()=>{i()};const l=o.objectStore(s).get(e);l.onsuccess=u=>{n=u.target.result},l.onerror=()=>{L.Error("Error loading file "+e+" from DB."),i()}}else L.Error("Error: IndexedDB not supported by your browser or BabylonJS Database is not open."),t()}_saveFileAsync(e,t,i,r,s){if(this._isSupported){let n;e.indexOf(".babylon")!==-1?n="scenes":n="textures";const o=new ss;let l;o.open("GET",e+(e.match(/\?/)==null?"?":"&")+Date.now()),r&&(o.responseType="arraybuffer"),i&&(o.onprogress=i),o.addEventListener("load",()=>{if(o.status===200||o.status<400&&Pi._ValidateXHRData(o,r?6:1))if(l=r?o.response:o.responseText,!this._hasReachedQuota&&this._db){const u=this._db.transaction([n],"readwrite");u.onabort=h=>{try{const d=h.target.error;d&&d.name==="QuotaExceededError"&&(this._hasReachedQuota=!0)}catch{}t(l)},u.oncomplete=()=>{t(l)};let c;n==="scenes"?c={sceneUrl:e,data:l,version:this._manifestVersionFound}:c={textureUrl:e,data:l};try{const h=u.objectStore(n).put(c);h.onsuccess=()=>{},h.onerror=()=>{L.Error("Error in DB add file request in BABYLON.Database.")}}catch{t(l)}}else t(l);else o.status>=400&&s?s(o):t()},!1),o.addEventListener("error",()=>{L.Error("error on XHR request."),s&&s()},!1),o.send()}else L.Error("Error: IndexedDB not supported by your browser or Babylon.js database is not open."),s&&s()}static _ValidateXHRData(e,t=7){try{if(t&1){if(e.responseText&&e.responseText.length>0)return!0;if(t===1)return!1}if(t&2){const i=ZM(e.response);if(i.width&&i.height&&i.width>0&&i.height>0)return!0;if(t===2)return!1}if(t&4){const i=new Uint8Array(e.response,0,3);return i[0]===68&&i[1]===68&&i[2]===83}}catch{}return!1}}Pi._IsUASupportingBlobStorage=!0;Pi.IDBStorageEnabled=!1;Pi._ParseURL=a=>{const e=document.createElement("a");e.href=a;const t=a.substring(0,a.lastIndexOf("#")),i=a.substring(t.lastIndexOf("/")+1,a.length);return a.substring(0,a.indexOf(i,0))};Pi._ReturnFullUrlLocation=a=>a.indexOf("http:/")===-1&&a.indexOf("https:/")===-1&&typeof window<"u"?Pi._ParseURL(window.location.href)+a:a;class TP{_isUbo(e){return e.addUniform!==void 0}constructor(e){this._isUbo(e)?(this.setMatrix3x3=e.updateMatrix3x3.bind(e),this.setMatrix2x2=e.updateMatrix2x2.bind(e),this.setFloat=e.updateFloat.bind(e),this.setFloat2=e.updateFloat2.bind(e),this.setFloat3=e.updateFloat3.bind(e),this.setFloat4=e.updateFloat4.bind(e),this.setFloatArray=e.updateFloatArray.bind(e),this.setArray=e.updateArray.bind(e),this.setIntArray=e.updateIntArray.bind(e),this.setMatrix=e.updateMatrix.bind(e),this.setMatrices=e.updateMatrices.bind(e),this.setVector3=e.updateVector3.bind(e),this.setVector4=e.updateVector4.bind(e),this.setColor3=e.updateColor3.bind(e),this.setColor4=e.updateColor4.bind(e),this.setDirectColor4=e.updateDirectColor4.bind(e),this.setInt=e.updateInt.bind(e),this.setInt2=e.updateInt2.bind(e),this.setInt3=e.updateInt3.bind(e),this.setInt4=e.updateInt4.bind(e)):(this.setMatrix3x3=e.setMatrix3x3.bind(e),this.setMatrix2x2=e.setMatrix2x2.bind(e),this.setFloat=e.setFloat.bind(e),this.setFloat2=e.setFloat2.bind(e),this.setFloat3=e.setFloat3.bind(e),this.setFloat4=e.setFloat4.bind(e),this.setFloatArray=e.setFloatArray.bind(e),this.setArray=e.setArray.bind(e),this.setIntArray=e.setIntArray.bind(e),this.setMatrix=e.setMatrix.bind(e),this.setMatrices=e.setMatrices.bind(e),this.setVector3=e.setVector3.bind(e),this.setVector4=e.setVector4.bind(e),this.setColor3=e.setColor3.bind(e),this.setColor4=e.setColor4.bind(e),this.setDirectColor4=e.setDirectColor4.bind(e),this.setInt=e.setInt.bind(e),this.setInt2=e.setInt2.bind(e),this.setInt3=e.setInt3.bind(e),this.setInt4=e.setInt4.bind(e))}}const Sv="gpuUpdateParticlesPixelShader",QB=`#version 300 es
void main() {discard;}
`;P.ShadersStore[Sv]||(P.ShadersStore[Sv]=QB);const vv="gpuUpdateParticlesVertexShader",KB=`#version 300 es
#define PI 3.14159
uniform float currentCount;uniform float timeDelta;uniform float stopFactor;
#ifndef LOCAL
uniform mat4 emitterWM;
#endif
uniform vec2 lifeTime;uniform vec2 emitPower;uniform vec2 sizeRange;uniform vec4 scaleRange;
#ifndef COLORGRADIENTS
uniform vec4 color1;uniform vec4 color2;
#endif
uniform vec3 gravity;uniform sampler2D randomSampler;uniform sampler2D randomSampler2;uniform vec4 angleRange;
#ifdef BOXEMITTER
uniform vec3 direction1;uniform vec3 direction2;uniform vec3 minEmitBox;uniform vec3 maxEmitBox;
#endif
#ifdef POINTEMITTER
uniform vec3 direction1;uniform vec3 direction2;
#endif
#ifdef HEMISPHERICEMITTER
uniform float radius;uniform float radiusRange;uniform float directionRandomizer;
#endif
#ifdef SPHEREEMITTER
uniform float radius;uniform float radiusRange;
#ifdef DIRECTEDSPHEREEMITTER
uniform vec3 direction1;uniform vec3 direction2;
#else
uniform float directionRandomizer;
#endif
#endif
#ifdef CYLINDEREMITTER
uniform float radius;uniform float height;uniform float radiusRange;
#ifdef DIRECTEDCYLINDEREMITTER
uniform vec3 direction1;uniform vec3 direction2;
#else
uniform float directionRandomizer;
#endif
#endif
#ifdef CONEEMITTER
uniform vec2 radius;uniform float coneAngle;uniform vec2 height;
#ifdef DIRECTEDCONEEMITTER
uniform vec3 direction1;uniform vec3 direction2;
#else
uniform float directionRandomizer;
#endif
#endif
in vec3 position;
#ifdef CUSTOMEMITTER
in vec3 initialPosition;
#endif
in float age;in float life;in vec4 seed;in vec3 size;
#ifndef COLORGRADIENTS
in vec4 color;
#endif
in vec3 direction;
#ifndef BILLBOARD
in vec3 initialDirection;
#endif
#ifdef ANGULARSPEEDGRADIENTS
in float angle;
#else
in vec2 angle;
#endif
#ifdef ANIMATESHEET
in float cellIndex;
#ifdef ANIMATESHEETRANDOMSTART
in float cellStartOffset;
#endif
#endif
#ifdef NOISE
in vec3 noiseCoordinates1;in vec3 noiseCoordinates2;
#endif
out vec3 outPosition;
#ifdef CUSTOMEMITTER
out vec3 outInitialPosition;
#endif
out float outAge;out float outLife;out vec4 outSeed;out vec3 outSize;
#ifndef COLORGRADIENTS
out vec4 outColor;
#endif
out vec3 outDirection;
#ifndef BILLBOARD
out vec3 outInitialDirection;
#endif
#ifdef ANGULARSPEEDGRADIENTS
out float outAngle;
#else
out vec2 outAngle;
#endif
#ifdef ANIMATESHEET
out float outCellIndex;
#ifdef ANIMATESHEETRANDOMSTART
out float outCellStartOffset;
#endif
#endif
#ifdef NOISE
out vec3 outNoiseCoordinates1;out vec3 outNoiseCoordinates2;
#endif
#ifdef SIZEGRADIENTS
uniform sampler2D sizeGradientSampler;
#endif 
#ifdef ANGULARSPEEDGRADIENTS
uniform sampler2D angularSpeedGradientSampler;
#endif 
#ifdef VELOCITYGRADIENTS
uniform sampler2D velocityGradientSampler;
#endif
#ifdef LIMITVELOCITYGRADIENTS
uniform sampler2D limitVelocityGradientSampler;uniform float limitVelocityDamping;
#endif
#ifdef DRAGGRADIENTS
uniform sampler2D dragGradientSampler;
#endif
#ifdef NOISE
uniform vec3 noiseStrength;uniform sampler2D noiseSampler;
#endif
#ifdef ANIMATESHEET
uniform vec4 cellInfos;
#endif
vec3 getRandomVec3(float offset) {return texture(randomSampler2,vec2(float(gl_VertexID)*offset/currentCount,0)).rgb;}
vec4 getRandomVec4(float offset) {return texture(randomSampler,vec2(float(gl_VertexID)*offset/currentCount,0));}
void main() {float newAge=age+timeDelta; 
if (newAge>=life && stopFactor != 0.) {vec3 newPosition;vec3 newDirection;vec4 randoms=getRandomVec4(seed.x);outLife=lifeTime.x+(lifeTime.y-lifeTime.x)*randoms.r;outAge=newAge-life;outSeed=seed;
#ifdef SIZEGRADIENTS 
outSize.x=texture(sizeGradientSampler,vec2(0,0)).r;
#else
outSize.x=sizeRange.x+(sizeRange.y-sizeRange.x)*randoms.g;
#endif
outSize.y=scaleRange.x+(scaleRange.y-scaleRange.x)*randoms.b;outSize.z=scaleRange.z+(scaleRange.w-scaleRange.z)*randoms.a; 
#ifndef COLORGRADIENTS
outColor=color1+(color2-color1)*randoms.b;
#endif
#ifndef ANGULARSPEEDGRADIENTS 
outAngle.y=angleRange.x+(angleRange.y-angleRange.x)*randoms.a;outAngle.x=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;
#else
outAngle=angleRange.z+(angleRange.w-angleRange.z)*randoms.r;
#endif 
#ifdef POINTEMITTER
vec3 randoms2=getRandomVec3(seed.y);vec3 randoms3=getRandomVec3(seed.z);newPosition=vec3(0,0,0);newDirection=direction1+(direction2-direction1)*randoms3;
#elif defined(BOXEMITTER)
vec3 randoms2=getRandomVec3(seed.y);vec3 randoms3=getRandomVec3(seed.z);newPosition=minEmitBox+(maxEmitBox-minEmitBox)*randoms2;newDirection=direction1+(direction2-direction1)*randoms3; 
#elif defined(HEMISPHERICEMITTER)
vec3 randoms2=getRandomVec3(seed.y);vec3 randoms3=getRandomVec3(seed.z);float phi=2.0*PI*randoms2.x;float theta=acos(2.0*randoms2.y-1.0);float randX=cos(phi)*sin(theta);float randY=cos(theta);float randZ=sin(phi)*sin(theta);newPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,abs(randY),randZ);newDirection=newPosition+directionRandomizer*randoms3; 
#elif defined(SPHEREEMITTER)
vec3 randoms2=getRandomVec3(seed.y);vec3 randoms3=getRandomVec3(seed.z);float phi=2.0*PI*randoms2.x;float theta=acos(2.0*randoms2.y-1.0);float randX=cos(phi)*sin(theta);float randY=cos(theta);float randZ=sin(phi)*sin(theta);newPosition=(radius-(radius*radiusRange*randoms2.z))*vec3(randX,randY,randZ);
#ifdef DIRECTEDSPHEREEMITTER
newDirection=normalize(direction1+(direction2-direction1)*randoms3);
#else
newDirection=normalize(newPosition+directionRandomizer*randoms3);
#endif
#elif defined(CYLINDEREMITTER)
vec3 randoms2=getRandomVec3(seed.y);vec3 randoms3=getRandomVec3(seed.z);float yPos=(randoms2.x-0.5)*height;float angle=randoms2.y*PI*2.;float inverseRadiusRangeSquared=((1.-radiusRange)*(1.-radiusRange));float positionRadius=radius*sqrt(inverseRadiusRangeSquared+(randoms2.z*(1.-inverseRadiusRangeSquared)));float xPos=positionRadius*cos(angle);float zPos=positionRadius*sin(angle);newPosition=vec3(xPos,yPos,zPos);
#ifdef DIRECTEDCYLINDEREMITTER
newDirection=direction1+(direction2-direction1)*randoms3;
#else
angle=angle+((randoms3.x-0.5)*PI)*directionRandomizer;newDirection=vec3(cos(angle),(randoms3.y-0.5)*directionRandomizer,sin(angle));newDirection=normalize(newDirection);
#endif
#elif defined(CONEEMITTER)
vec3 randoms2=getRandomVec3(seed.y);float s=2.0*PI*randoms2.x;
#ifdef CONEEMITTERSPAWNPOINT
float h=0.0001;
#else
float h=randoms2.y*height.y;h=1.-h*h; 
#endif
float lRadius=radius.x-radius.x*randoms2.z*radius.y;lRadius=lRadius*h;float randX=lRadius*sin(s);float randZ=lRadius*cos(s);float randY=h *height.x;newPosition=vec3(randX,randY,randZ); 
vec3 randoms3=getRandomVec3(seed.z);
#ifdef DIRECTEDCONEEMITTER
newDirection=direction1+(direction2-direction1)*randoms3;
#else
if (abs(cos(coneAngle))==1.0) {newDirection=vec3(0.,1.0,0.);} else {newDirection=normalize(newPosition+directionRandomizer*randoms3); }
#endif
#elif defined(CUSTOMEMITTER)
newPosition=initialPosition;outInitialPosition=initialPosition;
#else 
newPosition=vec3(0.,0.,0.);newDirection=2.0*(getRandomVec3(seed.w)-vec3(0.5,0.5,0.5));
#endif
float power=emitPower.x+(emitPower.y-emitPower.x)*randoms.a;
#ifdef LOCAL
outPosition=newPosition;
#else
outPosition=(emitterWM*vec4(newPosition,1.)).xyz;
#endif
#ifdef CUSTOMEMITTER
outDirection=direction;
#ifndef BILLBOARD 
outInitialDirection=direction;
#endif
#else
#ifdef LOCAL
vec3 initial=newDirection;
#else 
vec3 initial=(emitterWM*vec4(newDirection,0.)).xyz;
#endif
outDirection=initial*power;
#ifndef BILLBOARD 
outInitialDirection=initial;
#endif
#endif
#ifdef ANIMATESHEET 
outCellIndex=cellInfos.x;
#ifdef ANIMATESHEETRANDOMSTART
outCellStartOffset=randoms.a*outLife;
#endif 
#endif
#ifdef NOISE
outNoiseCoordinates1=noiseCoordinates1;outNoiseCoordinates2=noiseCoordinates2;
#endif
} else {float directionScale=timeDelta;outAge=newAge;float ageGradient=newAge/life;
#ifdef VELOCITYGRADIENTS
directionScale*=texture(velocityGradientSampler,vec2(ageGradient,0)).r;
#endif
#ifdef DRAGGRADIENTS
directionScale*=1.0-texture(dragGradientSampler,vec2(ageGradient,0)).r;
#endif
#if defined(CUSTOMEMITTER)
outPosition=position+(direction-position)*ageGradient; 
outInitialPosition=initialPosition;
#else
outPosition=position+direction*directionScale;
#endif
outLife=life;outSeed=seed;
#ifndef COLORGRADIENTS 
outColor=color;
#endif
#ifdef SIZEGRADIENTS
outSize.x=texture(sizeGradientSampler,vec2(ageGradient,0)).r;outSize.yz=size.yz;
#else
outSize=size;
#endif 
#ifndef BILLBOARD 
outInitialDirection=initialDirection;
#endif
#ifdef CUSTOMEMITTER
outDirection=direction;
#else
vec3 updatedDirection=direction+gravity*timeDelta;
#ifdef LIMITVELOCITYGRADIENTS
float limitVelocity=texture(limitVelocityGradientSampler,vec2(ageGradient,0)).r;float currentVelocity=length(updatedDirection);if (currentVelocity>limitVelocity) {updatedDirection=updatedDirection*limitVelocityDamping;}
#endif
outDirection=updatedDirection;
#ifdef NOISE
float fetchedR=texture(noiseSampler,vec2(noiseCoordinates1.x,noiseCoordinates1.y)*vec2(0.5)+vec2(0.5)).r;float fetchedG=texture(noiseSampler,vec2(noiseCoordinates1.z,noiseCoordinates2.x)*vec2(0.5)+vec2(0.5)).r;float fetchedB=texture(noiseSampler,vec2(noiseCoordinates2.y,noiseCoordinates2.z)*vec2(0.5)+vec2(0.5)).r;vec3 force=vec3(2.*fetchedR-1.,2.*fetchedG-1.,2.*fetchedB-1.)*noiseStrength;outDirection=outDirection+force*timeDelta;outNoiseCoordinates1=noiseCoordinates1;outNoiseCoordinates2=noiseCoordinates2;
#endif 
#endif 
#ifdef ANGULARSPEEDGRADIENTS
float angularSpeed=texture(angularSpeedGradientSampler,vec2(ageGradient,0)).r;outAngle=angle+angularSpeed*timeDelta;
#else
outAngle=vec2(angle.x+angle.y*timeDelta,angle.y);
#endif
#ifdef ANIMATESHEET 
float offsetAge=outAge;float dist=cellInfos.y-cellInfos.x;
#ifdef ANIMATESHEETRANDOMSTART
outCellStartOffset=cellStartOffset;offsetAge+=cellStartOffset;
#else
float cellStartOffset=0.;
#endif 
float ratio=0.;if (cellInfos.w==1.0) {ratio=clamp(mod(cellStartOffset+cellInfos.z*offsetAge,life)/life,0.,1.0);}
else {ratio=clamp(cellStartOffset+cellInfos.z*offsetAge/life,0.,1.0);}
outCellIndex=float(int(cellInfos.x+ratio*dist));
#endif
}}`;P.ShadersStore[vv]||(P.ShadersStore[vv]=KB);class JB{constructor(e,t){this._renderVAO=[],this._updateVAO=[],this.alignDataInBuffer=!1,this._parent=e,this._engine=t,this._updateEffectOptions={attributes:["position","initialPosition","age","life","seed","size","color","direction","initialDirection","angle","cellIndex","cellStartOffset","noiseCoordinates1","noiseCoordinates2"],uniformsNames:["currentCount","timeDelta","emitterWM","lifeTime","color1","color2","sizeRange","scaleRange","gravity","emitPower","direction1","direction2","minEmitBox","maxEmitBox","radius","directionRandomizer","height","coneAngle","stopFactor","angleRange","radiusRange","cellInfos","noiseStrength","limitVelocityDamping"],uniformBuffersNames:[],samplers:["randomSampler","randomSampler2","sizeGradientSampler","angularSpeedGradientSampler","velocityGradientSampler","limitVelocityGradientSampler","noiseSampler","dragGradientSampler"],defines:"",fallbacks:null,onCompiled:null,onError:null,indexParameters:null,maxSimultaneousLights:0,transformFeedbackVaryings:[]}}contextLost(){this._updateEffect=void 0,this._renderVAO.length=0,this._updateVAO.length=0}isUpdateBufferCreated(){return!!this._updateEffect}isUpdateBufferReady(){var e;return((e=this._updateEffect)==null?void 0:e.isReady())??!1}createUpdateBuffer(e){return this._updateEffectOptions.transformFeedbackVaryings=["outPosition"],this._updateEffectOptions.transformFeedbackVaryings.push("outAge"),this._updateEffectOptions.transformFeedbackVaryings.push("outSize"),this._updateEffectOptions.transformFeedbackVaryings.push("outLife"),this._updateEffectOptions.transformFeedbackVaryings.push("outSeed"),this._updateEffectOptions.transformFeedbackVaryings.push("outDirection"),this._parent.particleEmitterType instanceof cn&&this._updateEffectOptions.transformFeedbackVaryings.push("outInitialPosition"),this._parent._colorGradientsTexture||this._updateEffectOptions.transformFeedbackVaryings.push("outColor"),this._parent._isBillboardBased||this._updateEffectOptions.transformFeedbackVaryings.push("outInitialDirection"),this._parent.noiseTexture&&(this._updateEffectOptions.transformFeedbackVaryings.push("outNoiseCoordinates1"),this._updateEffectOptions.transformFeedbackVaryings.push("outNoiseCoordinates2")),this._updateEffectOptions.transformFeedbackVaryings.push("outAngle"),this._parent.isAnimationSheetEnabled&&(this._updateEffectOptions.transformFeedbackVaryings.push("outCellIndex"),this._parent.spriteRandomStartCell&&this._updateEffectOptions.transformFeedbackVaryings.push("outCellStartOffset")),this._updateEffectOptions.defines=e,this._updateEffect=this._engine.createEffect("gpuUpdateParticles",this._updateEffectOptions,this._engine),new TP(this._updateEffect)}createVertexBuffers(e,t){this._updateVAO.push(this._createUpdateVAO(e)),this._renderVAO.push(this._engine.recordVertexArrayObject(t,null,this._parent._getWrapper(this._parent.blendMode).effect)),this._engine.bindArrayBuffer(null),this._renderVertexBuffers=t}createParticleBuffer(e){return e}bindDrawBuffers(e,t,i){i?this._engine.bindBuffers(this._renderVertexBuffers,i,t):this._engine.bindVertexArrayObject(this._renderVAO[e],null)}preUpdateParticleBuffer(){const e=this._engine;if(this._engine.enableEffect(this._updateEffect),!e.setState)throw new Error("GPU particles cannot work without a full Engine. ThinEngine is not supported")}updateParticleBuffer(e,t,i){this._updateEffect.setTexture("randomSampler",this._parent._randomTexture),this._updateEffect.setTexture("randomSampler2",this._parent._randomTexture2),this._parent._sizeGradientsTexture&&this._updateEffect.setTexture("sizeGradientSampler",this._parent._sizeGradientsTexture),this._parent._angularSpeedGradientsTexture&&this._updateEffect.setTexture("angularSpeedGradientSampler",this._parent._angularSpeedGradientsTexture),this._parent._velocityGradientsTexture&&this._updateEffect.setTexture("velocityGradientSampler",this._parent._velocityGradientsTexture),this._parent._limitVelocityGradientsTexture&&this._updateEffect.setTexture("limitVelocityGradientSampler",this._parent._limitVelocityGradientsTexture),this._parent._dragGradientsTexture&&this._updateEffect.setTexture("dragGradientSampler",this._parent._dragGradientsTexture),this._parent.noiseTexture&&this._updateEffect.setTexture("noiseSampler",this._parent.noiseTexture),this._engine.bindVertexArrayObject(this._updateVAO[e],null);const r=this._engine;r.bindTransformFeedbackBuffer(t.getBuffer()),r.setRasterizerState(!1),r.beginTransformFeedback(!0),r.drawArraysType(3,0,i),r.endTransformFeedback(),r.setRasterizerState(!0),r.bindTransformFeedbackBuffer(null)}releaseBuffers(){}releaseVertexBuffers(){for(let e=0;e<this._updateVAO.length;e++)this._engine.releaseVertexArrayObject(this._updateVAO[e]);this._updateVAO.length=0;for(let e=0;e<this._renderVAO.length;e++)this._engine.releaseVertexArrayObject(this._renderVAO[e]);this._renderVAO.length=0}_createUpdateVAO(e){const t={};t.position=e.createVertexBuffer("position",0,3);let i=3;t.age=e.createVertexBuffer("age",i,1),i+=1,t.size=e.createVertexBuffer("size",i,3),i+=3,t.life=e.createVertexBuffer("life",i,1),i+=1,t.seed=e.createVertexBuffer("seed",i,4),i+=4,t.direction=e.createVertexBuffer("direction",i,3),i+=3,this._parent.particleEmitterType instanceof cn&&(t.initialPosition=e.createVertexBuffer("initialPosition",i,3),i+=3),this._parent._colorGradientsTexture||(t.color=e.createVertexBuffer("color",i,4),i+=4),this._parent._isBillboardBased||(t.initialDirection=e.createVertexBuffer("initialDirection",i,3),i+=3),this._parent.noiseTexture&&(t.noiseCoordinates1=e.createVertexBuffer("noiseCoordinates1",i,3),i+=3,t.noiseCoordinates2=e.createVertexBuffer("noiseCoordinates2",i,3),i+=3),this._parent._angularSpeedGradientsTexture?(t.angle=e.createVertexBuffer("angle",i,1),i+=1):(t.angle=e.createVertexBuffer("angle",i,2),i+=2),this._parent._isAnimationSheetEnabled&&(t.cellIndex=e.createVertexBuffer("cellIndex",i,1),i+=1,this._parent.spriteRandomStartCell&&(t.cellStartOffset=e.createVertexBuffer("cellStartOffset",i,1),i+=1));const r=this._engine.recordVertexArrayObject(t,null,this._updateEffect);return this._engine.bindArrayBuffer(null),r}}B("BABYLON.WebGL2ParticleSystem",JB);const bv="gpuUpdateParticlesComputeShader",eV=`struct Particle {position : vec3<f32>,
age : f32,
size : vec3<f32>,
life : f32,
seed : vec4<f32>,
direction : vec3<f32>,
dummy0: f32,
#ifdef CUSTOMEMITTER
initialPosition : vec3<f32>,
dummy1: f32,
#endif
#ifndef COLORGRADIENTS
color : vec4<f32>,
#endif
#ifndef BILLBOARD
initialDirection : vec3<f32>,
dummy2: f32,
#endif
#ifdef NOISE
noiseCoordinates1 : vec3<f32>,
dummy3: f32,
noiseCoordinates2 : vec3<f32>,
dummy4: f32,
#endif
#ifdef ANGULARSPEEDGRADIENTS
angle : f32,
#else
angle : vec2<f32>,
#endif
#ifdef ANIMATESHEET
cellIndex : f32,
#ifdef ANIMATESHEETRANDOMSTART
cellStartOffset : f32,
#endif
#endif
};struct Particles {particles : array<Particle>,};struct SimParams {currentCount : f32,
timeDelta : f32,
stopFactor : f32,
randomTextureSize: i32,
lifeTime : vec2<f32>,
emitPower : vec2<f32>,
#ifndef COLORGRADIENTS
color1 : vec4<f32>,
color2 : vec4<f32>,
#endif
sizeRange : vec2<f32>,
scaleRange : vec4<f32>,
angleRange : vec4<f32>,
gravity : vec3<f32>,
#ifdef LIMITVELOCITYGRADIENTS
limitVelocityDamping : f32,
#endif
#ifdef ANIMATESHEET
cellInfos : vec4<f32>,
#endif
#ifdef NOISE
noiseStrength : vec3<f32>,
#endif
#ifndef LOCAL
emitterWM : mat4x4<f32>,
#endif
#ifdef BOXEMITTER
direction1 : vec3<f32>,
direction2 : vec3<f32>,
minEmitBox : vec3<f32>,
maxEmitBox : vec3<f32>,
#endif
#ifdef CONEEMITTER
radius : vec2<f32>,
coneAngle : f32,
height : vec2<f32>,
#ifdef DIRECTEDCONEEMITTER
direction1 : vec3<f32>,
direction2 : vec3<f32>,
#else
directionRandomizer : f32,
#endif
#endif
#ifdef CYLINDEREMITTER
radius : f32,
height : f32,
radiusRange : f32,
#ifdef DIRECTEDCYLINDEREMITTER
direction1 : vec3<f32>,
direction2 : vec3<f32>,
#else
directionRandomizer : f32,
#endif
#endif
#ifdef HEMISPHERICEMITTER
radius : f32,
radiusRange : f32,
directionRandomizer : f32,
#endif
#ifdef POINTEMITTER
direction1 : vec3<f32>,
direction2 : vec3<f32>,
#endif
#ifdef SPHEREEMITTER
radius : f32,
radiusRange : f32,
#ifdef DIRECTEDSPHEREEMITTER
direction1 : vec3<f32>,
direction2 : vec3<f32>,
#else
directionRandomizer : f32,
#endif
#endif
};@binding(0) @group(0) var<uniform> params : SimParams;@binding(1) @group(0) var<storage,read> particlesIn : Particles;@binding(2) @group(0) var<storage,read_write> particlesOut : Particles;@binding(3) @group(0) var randomTexture : texture_2d<f32>;@binding(4) @group(0) var randomTexture2 : texture_2d<f32>;
#ifdef SIZEGRADIENTS
@binding(0) @group(1) var sizeGradientSampler : sampler;@binding(1) @group(1) var sizeGradientTexture : texture_2d<f32>;
#endif 
#ifdef ANGULARSPEEDGRADIENTS
@binding(2) @group(1) var angularSpeedGradientSampler : sampler;@binding(3) @group(1) var angularSpeedGradientTexture : texture_2d<f32>;
#endif 
#ifdef VELOCITYGRADIENTS
@binding(4) @group(1) var velocityGradientSampler : sampler;@binding(5) @group(1) var velocityGradientTexture : texture_2d<f32>;
#endif
#ifdef LIMITVELOCITYGRADIENTS
@binding(6) @group(1) var limitVelocityGradientSampler : sampler;@binding(7) @group(1) var limitVelocityGradientTexture : texture_2d<f32>;
#endif
#ifdef DRAGGRADIENTS
@binding(8) @group(1) var dragGradientSampler : sampler;@binding(9) @group(1) var dragGradientTexture : texture_2d<f32>;
#endif
#ifdef NOISE
@binding(10) @group(1) var noiseSampler : sampler;@binding(11) @group(1) var noiseTexture : texture_2d<f32>;
#endif
fn getRandomVec3(offset : f32,vertexID : f32)->vec3<f32> {return textureLoad(randomTexture2,vec2<i32>(i32(vertexID*offset/params.currentCount*f32(params.randomTextureSize)) % params.randomTextureSize,0),0).rgb;}
fn getRandomVec4(offset : f32,vertexID : f32)->vec4<f32> {return textureLoad(randomTexture,vec2<i32>(i32(vertexID*offset/params.currentCount*f32(params.randomTextureSize)) % params.randomTextureSize,0),0);}
@compute @workgroup_size(64)
fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {let index : u32=GlobalInvocationID.x;let vertexID : f32=f32(index);if (index>=u32(params.currentCount)) {return;}
let PI : f32=3.14159;let timeDelta : f32=params.timeDelta;let newAge : f32=particlesIn.particles[index].age+timeDelta;let life : f32=particlesIn.particles[index].life;let seed : vec4<f32>=particlesIn.particles[index].seed;let direction : vec3<f32>=particlesIn.particles[index].direction;if (newAge>=life && params.stopFactor != 0.) {var newPosition : vec3<f32>;var newDirection : vec3<f32>;let randoms : vec4<f32>=getRandomVec4(seed.x,vertexID);let outLife : f32=params.lifeTime.x+(params.lifeTime.y-params.lifeTime.x)*randoms.r;particlesOut.particles[index].life=outLife;particlesOut.particles[index].age=newAge-life;particlesOut.particles[index].seed=seed;var sizex : f32;
#ifdef SIZEGRADIENTS 
sizex=textureSampleLevel(sizeGradientTexture,sizeGradientSampler,vec2<f32>(0.,0.),0.).r;
#else
sizex=params.sizeRange.x+(params.sizeRange.y-params.sizeRange.x)*randoms.g;
#endif
particlesOut.particles[index].size=vec3<f32>(
sizex,
params.scaleRange.x+(params.scaleRange.y-params.scaleRange.x)*randoms.b,
params.scaleRange.z+(params.scaleRange.w-params.scaleRange.z)*randoms.a);
#ifndef COLORGRADIENTS
particlesOut.particles[index].color=params.color1+(params.color2-params.color1)*randoms.b;
#endif
#ifndef ANGULARSPEEDGRADIENTS 
particlesOut.particles[index].angle=vec2<f32>(
params.angleRange.z+(params.angleRange.w-params.angleRange.z)*randoms.r,
params.angleRange.x+(params.angleRange.y-params.angleRange.x)*randoms.a);
#else
particlesOut.particles[index].angle=params.angleRange.z+(params.angleRange.w-params.angleRange.z)*randoms.r;
#endif 
#if defined(POINTEMITTER)
let randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);newPosition=vec3<f32>(0.,0.,0.);newDirection=params.direction1+(params.direction2-params.direction1)*randoms3;
#elif defined(BOXEMITTER)
let randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);newPosition=params.minEmitBox+(params.maxEmitBox-params.minEmitBox)*randoms2;newDirection=params.direction1+(params.direction2-params.direction1)*randoms3; 
#elif defined(HEMISPHERICEMITTER)
let randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);let phi : f32=2.0*PI*randoms2.x;let theta : f32=acos(-1.0+2.0*randoms2.y);let randX : f32=cos(phi)*sin(theta);let randY : f32=cos(theta);let randZ : f32=sin(phi)*sin(theta);newPosition=(params.radius-(params.radius*params.radiusRange*randoms2.z))*vec3<f32>(randX,abs(randY),randZ);newDirection=normalize(newPosition+params.directionRandomizer*randoms3);
#elif defined(SPHEREEMITTER)
let randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);let phi : f32=2.0*PI*randoms2.x;let theta : f32=acos(-1.0+2.0*randoms2.y);let randX : f32=cos(phi)*sin(theta);let randY : f32=cos(theta);let randZ : f32=sin(phi)*sin(theta);newPosition=(params.radius-(params.radius*params.radiusRange*randoms2.z))*vec3<f32>(randX,randY,randZ);
#ifdef DIRECTEDSPHEREEMITTER
newDirection=normalize(params.direction1+(params.direction2-params.direction1)*randoms3);
#else
newDirection=normalize(newPosition+params.directionRandomizer*randoms3);
#endif
#elif defined(CYLINDEREMITTER)
let randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);let yPos : f32=(-0.5+randoms2.x)*params.height;var angle : f32=randoms2.y*PI*2.;let inverseRadiusRangeSquared : f32=(1.-params.radiusRange)*(1.-params.radiusRange);let positionRadius : f32=params.radius*sqrt(inverseRadiusRangeSquared+randoms2.z*(1.-inverseRadiusRangeSquared));let xPos : f32=positionRadius*cos(angle);let zPos : f32=positionRadius*sin(angle);newPosition=vec3<f32>(xPos,yPos,zPos);
#ifdef DIRECTEDCYLINDEREMITTER
newDirection=params.direction1+(params.direction2-params.direction1)*randoms3;
#else
angle=angle+(-0.5+randoms3.x)*PI*params.directionRandomizer;newDirection=vec3<f32>(cos(angle),(-0.5+randoms3.y)*params.directionRandomizer,sin(angle));newDirection=normalize(newDirection);
#endif
#elif defined(CONEEMITTER)
let randoms2 : vec3<f32>=getRandomVec3(seed.y,vertexID);let s : f32=2.0*PI*randoms2.x;
#ifdef CONEEMITTERSPAWNPOINT
let h : f32=0.0001;
#else
var h : f32=randoms2.y*params.height.y;h=1.-h*h; 
#endif
var lRadius : f32=params.radius.x-params.radius.x*randoms2.z*params.radius.y;lRadius=lRadius*h;let randX : f32=lRadius*sin(s);let randZ : f32=lRadius*cos(s);let randY : f32=h *params.height.x;newPosition=vec3<f32>(randX,randY,randZ); 
let randoms3 : vec3<f32>=getRandomVec3(seed.z,vertexID);
#ifdef DIRECTEDCONEEMITTER
newDirection=params.direction1+(params.direction2-params.direction1)*randoms3;
#else
if (abs(cos(params.coneAngle))==1.0) {newDirection=vec3<f32>(0.,1.0,0.);} else {newDirection=normalize(newPosition+params.directionRandomizer*randoms3); }
#endif
#elif defined(CUSTOMEMITTER)
newPosition=particlesIn.particles[index].initialPosition;particlesOut.particles[index].initialPosition=newPosition;
#else 
newPosition=vec3<f32>(0.,0.,0.);newDirection=2.0*(getRandomVec3(seed.w,vertexID)-vec3<f32>(0.5,0.5,0.5));
#endif
let power : f32=params.emitPower.x+(params.emitPower.y-params.emitPower.x)*randoms.a;
#ifdef LOCAL
particlesOut.particles[index].position=newPosition;
#else
particlesOut.particles[index].position=(params.emitterWM*vec4<f32>(newPosition,1.)).xyz;
#endif
#ifdef CUSTOMEMITTER
particlesOut.particles[index].direction=direction;
#ifndef BILLBOARD 
particlesOut.particles[index].initialDirection=direction;
#endif
#else
#ifdef LOCAL
let initial : vec3<f32>=newDirection;
#else 
let initial : vec3<f32>=(params.emitterWM*vec4<f32>(newDirection,0.)).xyz;
#endif
particlesOut.particles[index].direction=initial*power;
#ifndef BILLBOARD 
particlesOut.particles[index].initialDirection=initial;
#endif
#endif
#ifdef ANIMATESHEET 
particlesOut.particles[index].cellIndex=params.cellInfos.x;
#ifdef ANIMATESHEETRANDOMSTART
particlesOut.particles[index].cellStartOffset=randoms.a*outLife;
#endif 
#endif
#ifdef NOISE
particlesOut.particles[index].noiseCoordinates1=particlesIn.particles[index].noiseCoordinates1;particlesOut.particles[index].noiseCoordinates2=particlesIn.particles[index].noiseCoordinates2;
#endif
} else {var directionScale : f32=timeDelta;particlesOut.particles[index].age=newAge;let ageGradient : f32=newAge/life;
#ifdef VELOCITYGRADIENTS
directionScale=directionScale*textureSampleLevel(velocityGradientTexture,velocityGradientSampler,vec2<f32>(ageGradient,0.),0.).r;
#endif
#ifdef DRAGGRADIENTS
directionScale=directionScale*(1.0-textureSampleLevel(dragGradientTexture,dragGradientSampler,vec2<f32>(ageGradient,0.),0.).r);
#endif
let position : vec3<f32>=particlesIn.particles[index].position;
#if defined(CUSTOMEMITTER)
particlesOut.particles[index].position=position+(direction-position)*ageGradient; 
particlesOut.particles[index].initialPosition=particlesIn.particles[index].initialPosition;
#else
particlesOut.particles[index].position=position+direction*directionScale;
#endif
particlesOut.particles[index].life=life;particlesOut.particles[index].seed=seed;
#ifndef COLORGRADIENTS 
particlesOut.particles[index].color=particlesIn.particles[index].color;
#endif
#ifdef SIZEGRADIENTS
particlesOut.particles[index].size=vec3<f32>(
textureSampleLevel(sizeGradientTexture,sizeGradientSampler,vec2<f32>(ageGradient,0.),0.).r,
particlesIn.particles[index].size.yz);
#else
particlesOut.particles[index].size=particlesIn.particles[index].size;
#endif 
#ifndef BILLBOARD 
particlesOut.particles[index].initialDirection=particlesIn.particles[index].initialDirection;
#endif
#ifdef CUSTOMEMITTER
particlesOut.particles[index].direction=direction;
#else
var updatedDirection : vec3<f32>=direction+params.gravity*timeDelta;
#ifdef LIMITVELOCITYGRADIENTS
let limitVelocity : f32=textureSampleLevel(limitVelocityGradientTexture,limitVelocityGradientSampler,vec2<f32>(ageGradient,0.),0.).r;let currentVelocity : f32=length(updatedDirection);if (currentVelocity>limitVelocity) {updatedDirection=updatedDirection*params.limitVelocityDamping;}
#endif
particlesOut.particles[index].direction=updatedDirection;
#ifdef NOISE
let noiseCoordinates1 : vec3<f32>=particlesIn.particles[index].noiseCoordinates1;let noiseCoordinates2 : vec3<f32>=particlesIn.particles[index].noiseCoordinates2;let fetchedR : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates1.x,noiseCoordinates1.y)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;let fetchedG : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates1.z,noiseCoordinates2.x)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;let fetchedB : f32=textureSampleLevel(noiseTexture,noiseSampler,vec2<f32>(noiseCoordinates2.y,noiseCoordinates2.z)*vec2<f32>(0.5,0.5)+vec2<f32>(0.5,0.5),0.).r;let force : vec3<f32>=vec3<f32>(-1.+2.*fetchedR,-1.+2.*fetchedG,-1.+2.*fetchedB)*params.noiseStrength;particlesOut.particles[index].direction=particlesOut.particles[index].direction+force*timeDelta;particlesOut.particles[index].noiseCoordinates1=noiseCoordinates1;particlesOut.particles[index].noiseCoordinates2=noiseCoordinates2;
#endif 
#endif 
#ifdef ANGULARSPEEDGRADIENTS
let angularSpeed : f32=textureSampleLevel(angularSpeedGradientTexture,angularSpeedGradientSampler,vec2<f32>(ageGradient,0.),0.).r;particlesOut.particles[index].angle=particlesIn.particles[index].angle+angularSpeed*timeDelta;
#else
let angle : vec2<f32>=particlesIn.particles[index].angle;particlesOut.particles[index].angle=vec2<f32>(angle.x+angle.y*timeDelta,angle.y);
#endif
#ifdef ANIMATESHEET 
var offsetAge : f32=particlesOut.particles[index].age;let dist : f32=params.cellInfos.y-params.cellInfos.x;
#ifdef ANIMATESHEETRANDOMSTART
let cellStartOffset : f32=particlesIn.particles[index].cellStartOffset;particlesOut.particles[index].cellStartOffset=cellStartOffset;offsetAge=offsetAge+cellStartOffset;
#else
let cellStartOffset : f32=0.;
#endif 
var ratio : f32;if (params.cellInfos.w==1.0) {ratio=clamp(((cellStartOffset+params.cellInfos.z*offsetAge) % life)/life,0.,1.0);}
else {ratio=clamp((cellStartOffset+params.cellInfos.z*offsetAge)/life,0.,1.0);}
particlesOut.particles[index].cellIndex=f32(i32(params.cellInfos.x+ratio*dist));
#endif
}}
`;P.ShadersStoreWGSL[bv]||(P.ShadersStoreWGSL[bv]=eV);class tV{constructor(e,t){this._bufferComputeShader=[],this._renderVertexBuffers=[],this.alignDataInBuffer=!0,this._parent=e,this._engine=t}contextLost(){this._updateComputeShader=void 0,this._bufferComputeShader.length=0,this._renderVertexBuffers.length=0}isUpdateBufferCreated(){return!!this._updateComputeShader}isUpdateBufferReady(){var e;return((e=this._updateComputeShader)==null?void 0:e.isReady())??!1}createUpdateBuffer(e){var i;const t={params:{group:0,binding:0},particlesIn:{group:0,binding:1},particlesOut:{group:0,binding:2},randomTexture:{group:0,binding:3},randomTexture2:{group:0,binding:4}};return this._parent._sizeGradientsTexture&&(t.sizeGradientTexture={group:1,binding:1}),this._parent._angularSpeedGradientsTexture&&(t.angularSpeedGradientTexture={group:1,binding:3}),this._parent._velocityGradientsTexture&&(t.velocityGradientTexture={group:1,binding:5}),this._parent._limitVelocityGradientsTexture&&(t.limitVelocityGradientTexture={group:1,binding:7}),this._parent._dragGradientsTexture&&(t.dragGradientTexture={group:1,binding:9}),this._parent.noiseTexture&&(t.noiseTexture={group:1,binding:11}),this._updateComputeShader=new Cs("updateParticles",this._engine,"gpuUpdateParticles",{bindingsMapping:t,defines:e.split(`
`)}),(i=this._simParamsComputeShader)==null||i.dispose(),this._simParamsComputeShader=new tn(this._engine,void 0,void 0,"ComputeShaderParticleSystemUBO"),this._simParamsComputeShader.addUniform("currentCount",1),this._simParamsComputeShader.addUniform("timeDelta",1),this._simParamsComputeShader.addUniform("stopFactor",1),this._simParamsComputeShader.addUniform("randomTextureSize",1),this._simParamsComputeShader.addUniform("lifeTime",2),this._simParamsComputeShader.addUniform("emitPower",2),this._parent._colorGradientsTexture||(this._simParamsComputeShader.addUniform("color1",4),this._simParamsComputeShader.addUniform("color2",4)),this._simParamsComputeShader.addUniform("sizeRange",2),this._simParamsComputeShader.addUniform("scaleRange",4),this._simParamsComputeShader.addUniform("angleRange",4),this._simParamsComputeShader.addUniform("gravity",3),this._parent._limitVelocityGradientsTexture&&this._simParamsComputeShader.addUniform("limitVelocityDamping",1),this._parent.isAnimationSheetEnabled&&this._simParamsComputeShader.addUniform("cellInfos",4),this._parent.noiseTexture&&this._simParamsComputeShader.addUniform("noiseStrength",3),this._parent.isLocal||this._simParamsComputeShader.addUniform("emitterWM",16),this._parent.particleEmitterType&&this._parent.particleEmitterType.buildUniformLayout(this._simParamsComputeShader),this._updateComputeShader.setUniformBuffer("params",this._simParamsComputeShader),new TP(this._simParamsComputeShader)}createVertexBuffers(e,t){this._renderVertexBuffers.push(t)}createParticleBuffer(e){const t=new HA(this._engine,e.length*4,11,"ComputeShaderParticleSystemBuffer");return t.update(e),this._bufferComputeShader.push(t),t.getBuffer()}bindDrawBuffers(e,t,i){this._engine.bindBuffers(this._renderVertexBuffers[e],i,t)}preUpdateParticleBuffer(){}updateParticleBuffer(e,t,i){this._simParamsComputeShader.update(),this._updateComputeShader.setTexture("randomTexture",this._parent._randomTexture,!1),this._updateComputeShader.setTexture("randomTexture2",this._parent._randomTexture2,!1),this._parent._sizeGradientsTexture&&this._updateComputeShader.setTexture("sizeGradientTexture",this._parent._sizeGradientsTexture),this._parent._angularSpeedGradientsTexture&&this._updateComputeShader.setTexture("angularSpeedGradientTexture",this._parent._angularSpeedGradientsTexture),this._parent._velocityGradientsTexture&&this._updateComputeShader.setTexture("velocityGradientTexture",this._parent._velocityGradientsTexture),this._parent._limitVelocityGradientsTexture&&this._updateComputeShader.setTexture("limitVelocityGradientTexture",this._parent._limitVelocityGradientsTexture),this._parent._dragGradientsTexture&&this._updateComputeShader.setTexture("dragGradientTexture",this._parent._dragGradientsTexture),this._parent.noiseTexture&&this._updateComputeShader.setTexture("noiseTexture",this._parent.noiseTexture),this._updateComputeShader.setStorageBuffer("particlesIn",this._bufferComputeShader[e]),this._updateComputeShader.setStorageBuffer("particlesOut",this._bufferComputeShader[e^1]),this._updateComputeShader.dispatch(Math.ceil(i/64))}releaseBuffers(){var e;for(let t=0;t<this._bufferComputeShader.length;++t)this._bufferComputeShader[t].dispose();this._bufferComputeShader.length=0,(e=this._simParamsComputeShader)==null||e.dispose(),this._simParamsComputeShader=null,this._updateComputeShader=null}releaseVertexBuffers(){this._renderVertexBuffers.length=0}}B("BABYLON.ComputeShaderParticleSystem",tV);const yv="clipPlaneFragmentDeclaration2",iV=`#ifdef CLIPPLANE
in float fClipDistance;
#endif
#ifdef CLIPPLANE2
in float fClipDistance2;
#endif
#ifdef CLIPPLANE3
in float fClipDistance3;
#endif
#ifdef CLIPPLANE4
in float fClipDistance4;
#endif
#ifdef CLIPPLANE5
in float fClipDistance5;
#endif
#ifdef CLIPPLANE6
in float fClipDistance6;
#endif
`;P.IncludesShadersStore[yv]||(P.IncludesShadersStore[yv]=iV);const Tv="gpuRenderParticlesPixelShader",rV=`precision highp float;
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
uniform sampler2D diffuseSampler;varying vec2 vUV;varying vec4 vColor;
#include<clipPlaneFragmentDeclaration2> 
#include<imageProcessingDeclaration>
#include<logDepthDeclaration>
#include<helperFunctions>
#include<imageProcessingFunctions>
#include<fogFragmentDeclaration>
void main() {
#include<clipPlaneFragment> 
vec4 textureColor=texture2D(diffuseSampler,vUV);gl_FragColor=textureColor*vColor;
#ifdef BLENDMULTIPLYMODE
float alpha=vColor.a*textureColor.a;gl_FragColor.rgb=gl_FragColor.rgb*alpha+vec3(1.0)*(1.0-alpha);
#endif 
#include<logDepthFragment>
#include<fogFragment>(color,gl_FragColor)
#ifdef IMAGEPROCESSINGPOSTPROCESS
gl_FragColor.rgb=toLinearSpace(gl_FragColor.rgb);
#else
#ifdef IMAGEPROCESSING
gl_FragColor.rgb=toLinearSpace(gl_FragColor.rgb);gl_FragColor=applyImageProcessing(gl_FragColor);
#endif
#endif
}
`;P.ShadersStore[Tv]||(P.ShadersStore[Tv]=rV);const Cv="clipPlaneVertexDeclaration2",sV=`#ifdef CLIPPLANE
uniform vec4 vClipPlane;out float fClipDistance;
#endif
#ifdef CLIPPLANE2
uniform vec4 vClipPlane2;out float fClipDistance2;
#endif
#ifdef CLIPPLANE3
uniform vec4 vClipPlane3;out float fClipDistance3;
#endif
#ifdef CLIPPLANE4
uniform vec4 vClipPlane4;out float fClipDistance4;
#endif
#ifdef CLIPPLANE5
uniform vec4 vClipPlane5;out float fClipDistance5;
#endif
#ifdef CLIPPLANE6
uniform vec4 vClipPlane6;out float fClipDistance6;
#endif
`;P.IncludesShadersStore[Cv]||(P.IncludesShadersStore[Cv]=sV);const Pv="gpuRenderParticlesVertexShader",nV=`precision highp float;uniform mat4 view;uniform mat4 projection;uniform vec2 translationPivot;uniform vec3 worldOffset;
#ifdef LOCAL
uniform mat4 emitterWM;
#endif
attribute vec3 position;attribute float age;attribute float life;attribute vec3 size;
#ifndef BILLBOARD
attribute vec3 initialDirection;
#endif
#ifdef BILLBOARDSTRETCHED
attribute vec3 direction;
#endif
attribute float angle;
#ifdef ANIMATESHEET
attribute float cellIndex;
#endif
attribute vec2 offset;attribute vec2 uv;varying vec2 vUV;varying vec4 vColor;varying vec3 vPositionW;
#if defined(BILLBOARD) && !defined(BILLBOARDY) && !defined(BILLBOARDSTRETCHED)
uniform mat4 invView;
#endif
#include<clipPlaneVertexDeclaration2>
#include<fogVertexDeclaration>
#include<logDepthDeclaration>
#ifdef COLORGRADIENTS
uniform sampler2D colorGradientSampler;
#else
uniform vec4 colorDead;attribute vec4 color;
#endif
#ifdef ANIMATESHEET
uniform vec3 sheetInfos;
#endif
#ifdef BILLBOARD
uniform vec3 eyePosition;
#endif
vec3 rotate(vec3 yaxis,vec3 rotatedCorner) {vec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));vec3 zaxis=normalize(cross(yaxis,xaxis));vec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);vec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);vec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);mat3 rotMatrix= mat3(row0,row1,row2);vec3 alignedCorner=rotMatrix*rotatedCorner;
#ifdef LOCAL
return ((emitterWM*vec4(position,1.0)).xyz+worldOffset)+alignedCorner;
#else
return (position+worldOffset)+alignedCorner;
#endif
}
#ifdef BILLBOARDSTRETCHED
vec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {vec3 normalizedToCamera=normalize(toCamera);vec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));vec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));vec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);vec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);vec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);mat3 rotMatrix= mat3(row0,row1,row2);vec3 alignedCorner=rotMatrix*rotatedCorner;
#ifdef LOCAL
return ((emitterWM*vec4(position,1.0)).xyz+worldOffset)+alignedCorner;
#else
return (position+worldOffset)+alignedCorner;
#endif
}
#endif
void main() {
#ifdef ANIMATESHEET
float rowOffset=floor(cellIndex/sheetInfos.z);float columnOffset=cellIndex-rowOffset*sheetInfos.z;vec2 uvScale=sheetInfos.xy;vec2 uvOffset=vec2(uv.x ,1.0-uv.y);vUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;
#else
vUV=uv;
#endif
float ratio=min(1.0,age/life);
#ifdef COLORGRADIENTS
vColor=texture2D(colorGradientSampler,vec2(ratio,0));
#else
vColor=color*vec4(1.0-ratio)+colorDead*vec4(ratio);
#endif
vec2 cornerPos=(offset-translationPivot)*size.yz*size.x;
#ifdef BILLBOARD
vec4 rotatedCorner;rotatedCorner.w=0.;
#ifdef BILLBOARDY
rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.y=0.;rotatedCorner.xz+=translationPivot;vec3 yaxis=(position+worldOffset)-eyePosition;yaxis.y=0.;vPositionW=rotate(normalize(yaxis),rotatedCorner.xyz);vec4 viewPosition=(view*vec4(vPositionW,1.0));
#elif defined(BILLBOARDSTRETCHED)
rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.z=0.;rotatedCorner.xy+=translationPivot;vec3 toCamera=(position+worldOffset)-eyePosition;vPositionW=rotateAlign(toCamera,rotatedCorner.xyz);vec4 viewPosition=(view*vec4(vPositionW,1.0));
#else
rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.z=0.;rotatedCorner.xy+=translationPivot;
#ifdef LOCAL
vec4 viewPosition=view*vec4(((emitterWM*vec4(position,1.0)).xyz+worldOffset),1.0)+rotatedCorner;
#else
vec4 viewPosition=view*vec4((position+worldOffset),1.0)+rotatedCorner;
#endif
vPositionW=(invView*viewPosition).xyz;
#endif
#else
vec3 rotatedCorner;rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=0.;rotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.xz+=translationPivot;vec3 yaxis=normalize(initialDirection);vPositionW=rotate(yaxis,rotatedCorner);vec4 viewPosition=view*vec4(vPositionW,1.0);
#endif
gl_Position=projection*viewPosition;
#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6) || defined(FOG)
vec4 worldPos=vec4(vPositionW,1.0);
#endif
#include<clipPlaneVertex>
#include<fogVertex>
#include<logDepthVertex>
}`;P.ShadersStore[Pv]||(P.ShadersStore[Pv]=nV);class Lr extends kt{static get IsSupported(){if(!ze.LastCreatedEngine)return!1;const e=ze.LastCreatedEngine.getCaps();return e.supportTransformFeedbacks||e.supportComputeShaders}_createIndexBuffer(){this._linesIndexBufferUseInstancing=this._engine.createIndexBuffer(new Uint32Array([0,1,1,3,3,2,2,0,0,3]),void 0,"GPUParticleSystemLinesIndexBuffer")}getCapacity(){return this._capacity}get maxActiveParticleCount(){return this._maxActiveParticleCount}set maxActiveParticleCount(e){this._maxActiveParticleCount=Math.min(e,this._capacity)}get activeParticleCount(){return this.maxActiveParticleCount}set activeParticleCount(e){this.maxActiveParticleCount=e}createPointEmitter(e,t){const i=fP(e,t);return this.particleEmitterType=i,i}createHemisphericEmitter(e=1,t=1){const i=pP(e,t);return this.particleEmitterType=i,i}createSphereEmitter(e=1,t=1){const i=mP(e,t);return this.particleEmitterType=i,i}createDirectedSphereEmitter(e=1,t=new m(0,1,0),i=new m(0,1,0)){const r=_P(e,t,i);return this.particleEmitterType=r,r}createCylinderEmitter(e=1,t=1,i=1,r=0){const s=gP(e,t,i,r);return this.particleEmitterType=s,s}createDirectedCylinderEmitter(e=1,t=1,i=1,r=new m(0,1,0),s=new m(0,1,0)){const n=xP(e,t,i,r,s);return this.particleEmitterType=n,n}createConeEmitter(e=1,t=Math.PI/4){const i=SP(e,t);return this.particleEmitterType=i,i}createDirectedConeEmitter(e=1,t=Math.PI/4,i=new m(0,1,0),r=new m(0,1,0)){const s=vP(e,t,i,r);return this.particleEmitterType=s,s}createBoxEmitter(e,t,i,r){const s=new ln;return this.particleEmitterType=s,this.direction1=e,this.direction2=t,this.minEmitBox=i,this.maxEmitBox=r,s}isReady(){if(!this.emitter||this._imageProcessingConfiguration&&!this._imageProcessingConfiguration.isReady()||!this.particleTexture||!this.particleTexture.isReady()||this._rebuildingAfterContextLost)return!1;if(this.blendMode!==ut.BLENDMODE_MULTIPLYADD){if(!this._getWrapper(this.blendMode).effect.isReady())return!1}else if(!this._getWrapper(ut.BLENDMODE_MULTIPLY).effect.isReady()||!this._getWrapper(ut.BLENDMODE_ADD).effect.isReady())return!1;return this._platform.isUpdateBufferCreated()?this._platform.isUpdateBufferReady():(this._recreateUpdateEffect(),!1)}isStarted(){return this._started}isStopped(){return this._stopped}isStopping(){return!1}getActiveCount(){return this._currentActiveCount}start(e=this.startDelay){if(!this.targetStopDuration&&this._hasTargetStopDurationDependantGradient())throw"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set";if(e){setTimeout(()=>{this.start(0)},e);return}this._started=!0,this._stopped=!1,this._preWarmDone=!1,this.beginAnimationOnStart&&this.animations&&this.animations.length>0&&this._scene&&this._scene.beginAnimation(this,this.beginAnimationFrom,this.beginAnimationTo,this.beginAnimationLoop)}stop(){this._stopped||(this.onStoppedObservable.notifyObservers(this),this._stopped=!0)}reset(){this._releaseBuffers(),this._platform.releaseVertexBuffers(),this._currentActiveCount=0,this._targetIndex=0}getClassName(){return"GPUParticleSystem"}getCustomEffect(e=0){var t;return((t=this._customWrappers[e])==null?void 0:t.effect)??this._customWrappers[0].effect}_getCustomDrawWrapper(e=0){return this._customWrappers[e]??this._customWrappers[0]}setCustomEffect(e,t=0){this._customWrappers[t]=new vi(this._engine),this._customWrappers[t].effect=e}get onBeforeDrawParticlesObservable(){return this._onBeforeDrawParticlesObservable||(this._onBeforeDrawParticlesObservable=new j),this._onBeforeDrawParticlesObservable}get vertexShaderName(){return"gpuRenderParticles"}get vertexBuffers(){return this._renderVertexBuffers[this._targetIndex^1]}get indexBuffer(){return null}_removeGradientAndTexture(e,t,i){return super._removeGradientAndTexture(e,t,i),this._releaseBuffers(),this}addColorGradient(e,t){this._colorGradients||(this._colorGradients=[]);const i=new hP(e,t);return this._colorGradients.push(i),this._refreshColorGradient(!0),this._releaseBuffers(),this}_refreshColorGradient(e=!1){this._colorGradients&&(e&&this._colorGradients.sort((t,i)=>t.gradient<i.gradient?-1:t.gradient>i.gradient?1:0),this._colorGradientsTexture&&(this._colorGradientsTexture.dispose(),this._colorGradientsTexture=null))}forceRefreshGradients(){this._refreshColorGradient(),this._refreshFactorGradient(this._sizeGradients,"_sizeGradientsTexture"),this._refreshFactorGradient(this._angularSpeedGradients,"_angularSpeedGradientsTexture"),this._refreshFactorGradient(this._velocityGradients,"_velocityGradientsTexture"),this._refreshFactorGradient(this._limitVelocityGradients,"_limitVelocityGradientsTexture"),this._refreshFactorGradient(this._dragGradients,"_dragGradientsTexture"),this.reset()}removeColorGradient(e){return this._removeGradientAndTexture(e,this._colorGradients,this._colorGradientsTexture),this._colorGradientsTexture=null,this}resetDrawCache(){var e;for(const t in this._drawWrappers)(e=this._drawWrappers[t].drawContext)==null||e.reset()}_addFactorGradient(e,t,i){const r=new dP(t,i);e.push(r),this._releaseBuffers()}addSizeGradient(e,t){return this._sizeGradients||(this._sizeGradients=[]),this._addFactorGradient(this._sizeGradients,e,t),this._refreshFactorGradient(this._sizeGradients,"_sizeGradientsTexture",!0),this._releaseBuffers(),this}removeSizeGradient(e){return this._removeGradientAndTexture(e,this._sizeGradients,this._sizeGradientsTexture),this._sizeGradientsTexture=null,this}_refreshFactorGradient(e,t,i=!1){if(!e)return;i&&e.sort((s,n)=>s.gradient<n.gradient?-1:s.gradient>n.gradient?1:0);const r=this;r[t]&&(r[t].dispose(),r[t]=null)}addAngularSpeedGradient(e,t){return this._angularSpeedGradients||(this._angularSpeedGradients=[]),this._addFactorGradient(this._angularSpeedGradients,e,t),this._refreshFactorGradient(this._angularSpeedGradients,"_angularSpeedGradientsTexture",!0),this._releaseBuffers(),this}removeAngularSpeedGradient(e){return this._removeGradientAndTexture(e,this._angularSpeedGradients,this._angularSpeedGradientsTexture),this._angularSpeedGradientsTexture=null,this}addVelocityGradient(e,t){return this._velocityGradients||(this._velocityGradients=[]),this._addFactorGradient(this._velocityGradients,e,t),this._refreshFactorGradient(this._velocityGradients,"_velocityGradientsTexture",!0),this._releaseBuffers(),this}removeVelocityGradient(e){return this._removeGradientAndTexture(e,this._velocityGradients,this._velocityGradientsTexture),this._velocityGradientsTexture=null,this}addLimitVelocityGradient(e,t){return this._limitVelocityGradients||(this._limitVelocityGradients=[]),this._addFactorGradient(this._limitVelocityGradients,e,t),this._refreshFactorGradient(this._limitVelocityGradients,"_limitVelocityGradientsTexture",!0),this._releaseBuffers(),this}removeLimitVelocityGradient(e){return this._removeGradientAndTexture(e,this._limitVelocityGradients,this._limitVelocityGradientsTexture),this._limitVelocityGradientsTexture=null,this}addDragGradient(e,t){return this._dragGradients||(this._dragGradients=[]),this._addFactorGradient(this._dragGradients,e,t),this._refreshFactorGradient(this._dragGradients,"_dragGradientsTexture",!0),this._releaseBuffers(),this}removeDragGradient(e){return this._removeGradientAndTexture(e,this._dragGradients,this._dragGradientsTexture),this._dragGradientsTexture=null,this}addEmitRateGradient(){return this}removeEmitRateGradient(){return this}addStartSizeGradient(){return this}removeStartSizeGradient(){return this}addColorRemapGradient(){return this}removeColorRemapGradient(){return this}addAlphaRemapGradient(){return this}removeAlphaRemapGradient(){return this}addRampGradient(){return this}removeRampGradient(){return this}getRampGradients(){return null}get useRampGradients(){return!1}set useRampGradients(e){}addLifeTimeGradient(){return this}removeLifeTimeGradient(){return this}constructor(e,t,i,r=null,s=!1){if(super(e),this.layerMask=268435455,this._accumulatedCount=0,this._renderVertexBuffers=[],this._targetIndex=0,this._currentRenderId=-1,this._currentRenderingCameraUniqueId=-1,this._started=!1,this._stopped=!1,this._timeDelta=0,this.updateInAnimate=!1,this._actualFrame=0,this._rawTextureWidth=256,this._rebuildingAfterContextLost=!1,this.onDisposeObservable=new j,this.onStoppedObservable=new j,this.forceDepthWrite=!1,this._preWarmDone=!1,this.isLocal=!1,this.isGPU=!0,this._onBeforeDrawParticlesObservable=null,!i||i.getClassName()==="Scene"?(this._scene=i||ze.LastCreatedScene,this._engine=this._scene.getEngine(),this.uniqueId=this._scene.getUniqueId(),this._scene.particleSystems.push(this)):(this._engine=i,this.defaultProjectionMatrix=$.PerspectiveFovLH(.8,1,.1,100,this._engine.isNDCHalfZRange)),this._engine.getCaps().supportComputeShaders){if(!oi("BABYLON.ComputeShaderParticleSystem"))throw new Error("The ComputeShaderParticleSystem class is not available! Make sure you have imported it.");this._platform=new(oi("BABYLON.ComputeShaderParticleSystem"))(this,this._engine)}else{if(!oi("BABYLON.WebGL2ParticleSystem"))throw new Error("The WebGL2ParticleSystem class is not available! Make sure you have imported it.");this._platform=new(oi("BABYLON.WebGL2ParticleSystem"))(this,this._engine)}this._customWrappers={0:new vi(this._engine)},this._customWrappers[0].effect=r,this._drawWrappers={0:new vi(this._engine)},this._drawWrappers[0].drawContext&&(this._drawWrappers[0].drawContext.useInstancing=!0),this._createIndexBuffer(),this._attachImageProcessingConfiguration(null),t=t??{},t.randomTextureSize||delete t.randomTextureSize;const n={capacity:5e4,randomTextureSize:this._engine.getCaps().maxTextureSize,...t},o=t;isFinite(o)&&(n.capacity=o),this._capacity=n.capacity,this._maxActiveParticleCount=n.capacity,this._currentActiveCount=0,this._isAnimationSheetEnabled=s,this.particleEmitterType=new ln;const l=Math.min(this._engine.getCaps().maxTextureSize,n.randomTextureSize);let u=[];for(let c=0;c<l;++c)u.push(Math.random()),u.push(Math.random()),u.push(Math.random()),u.push(Math.random());this._randomTexture=new qt(new Float32Array(u),l,1,5,i,!1,!1,1,1),this._randomTexture.name="GPUParticleSystem_random1",this._randomTexture.wrapU=1,this._randomTexture.wrapV=1,u=[];for(let c=0;c<l;++c)u.push(Math.random()),u.push(Math.random()),u.push(Math.random()),u.push(Math.random());this._randomTexture2=new qt(new Float32Array(u),l,1,5,i,!1,!1,1,1),this._randomTexture2.name="GPUParticleSystem_random2",this._randomTexture2.wrapU=1,this._randomTexture2.wrapV=1,this._randomTextureSize=l}_reset(){this._releaseBuffers()}_createVertexBuffers(e,t,i){const r={};r.position=t.createVertexBuffer("position",0,3,this._attributesStrideSize,!0);let s=3;r.age=t.createVertexBuffer("age",s,1,this._attributesStrideSize,!0),s+=1,r.size=t.createVertexBuffer("size",s,3,this._attributesStrideSize,!0),s+=3,r.life=t.createVertexBuffer("life",s,1,this._attributesStrideSize,!0),s+=1,s+=4,this.billboardMode===ut.BILLBOARDMODE_STRETCHED&&(r.direction=t.createVertexBuffer("direction",s,3,this._attributesStrideSize,!0)),s+=3,this._platform.alignDataInBuffer&&(s+=1),this.particleEmitterType instanceof cn&&(s+=3,this._platform.alignDataInBuffer&&(s+=1)),this._colorGradientsTexture||(r.color=t.createVertexBuffer("color",s,4,this._attributesStrideSize,!0),s+=4),this._isBillboardBased||(r.initialDirection=t.createVertexBuffer("initialDirection",s,3,this._attributesStrideSize,!0),s+=3,this._platform.alignDataInBuffer&&(s+=1)),this.noiseTexture&&(r.noiseCoordinates1=t.createVertexBuffer("noiseCoordinates1",s,3,this._attributesStrideSize,!0),s+=3,this._platform.alignDataInBuffer&&(s+=1),r.noiseCoordinates2=t.createVertexBuffer("noiseCoordinates2",s,3,this._attributesStrideSize,!0),s+=3,this._platform.alignDataInBuffer&&(s+=1)),r.angle=t.createVertexBuffer("angle",s,1,this._attributesStrideSize,!0),this._angularSpeedGradientsTexture?s++:s+=2,this._isAnimationSheetEnabled&&(r.cellIndex=t.createVertexBuffer("cellIndex",s,1,this._attributesStrideSize,!0),s+=1,this.spriteRandomStartCell&&(r.cellStartOffset=t.createVertexBuffer("cellStartOffset",s,1,this._attributesStrideSize,!0),s+=1)),r.offset=i.createVertexBuffer("offset",0,2),r.uv=i.createVertexBuffer("uv",2,2),this._renderVertexBuffers.push(r),this._platform.createVertexBuffers(e,r),this.resetDrawCache()}_initialize(e=!1){if(this._buffer0&&!e)return;const t=this._engine,i=[];this._attributesStrideSize=21,this._targetIndex=0,this._platform.alignDataInBuffer&&(this._attributesStrideSize+=1),this.particleEmitterType instanceof cn&&(this._attributesStrideSize+=3,this._platform.alignDataInBuffer&&(this._attributesStrideSize+=1)),this.isBillboardBased||(this._attributesStrideSize+=3,this._platform.alignDataInBuffer&&(this._attributesStrideSize+=1)),this._colorGradientsTexture&&(this._attributesStrideSize-=4),this._angularSpeedGradientsTexture&&(this._attributesStrideSize-=1),this._isAnimationSheetEnabled&&(this._attributesStrideSize+=1,this.spriteRandomStartCell&&(this._attributesStrideSize+=1)),this.noiseTexture&&(this._attributesStrideSize+=6,this._platform.alignDataInBuffer&&(this._attributesStrideSize+=2)),this._platform.alignDataInBuffer&&(this._attributesStrideSize+=3-(this._attributesStrideSize+3&3));const r=this.particleEmitterType instanceof cn,s=V.Vector3[0];let n=0;for(let c=0;c<this._capacity;c++)if(i.push(0),i.push(0),i.push(0),i.push(0),i.push(0),i.push(0),i.push(0),i.push(0),i.push(Math.random()),i.push(Math.random()),i.push(Math.random()),i.push(Math.random()),r?(this.particleEmitterType.particleDestinationGenerator(c,null,s),i.push(s.x),i.push(s.y),i.push(s.z)):(i.push(0),i.push(0),i.push(0)),this._platform.alignDataInBuffer&&i.push(0),n+=16,r&&(this.particleEmitterType.particlePositionGenerator(c,null,s),i.push(s.x),i.push(s.y),i.push(s.z),this._platform.alignDataInBuffer&&i.push(0),n+=4),this._colorGradientsTexture||(i.push(0),i.push(0),i.push(0),i.push(0),n+=4),this.isBillboardBased||(i.push(0),i.push(0),i.push(0),this._platform.alignDataInBuffer&&i.push(0),n+=4),this.noiseTexture&&(i.push(Math.random()),i.push(Math.random()),i.push(Math.random()),this._platform.alignDataInBuffer&&i.push(0),i.push(Math.random()),i.push(Math.random()),i.push(Math.random()),this._platform.alignDataInBuffer&&i.push(0),n+=8),i.push(0),n+=1,this._angularSpeedGradientsTexture||(i.push(0),n+=1),this._isAnimationSheetEnabled&&(i.push(0),n+=1,this.spriteRandomStartCell&&(i.push(0),n+=1)),this._platform.alignDataInBuffer){let h=3-(n+3&3);for(n+=h;h-- >0;)i.push(0)}const o=new Float32Array([.5,.5,1,1,-.5,.5,0,1,.5,-.5,1,0,-.5,-.5,0,0]),l=this._platform.createParticleBuffer(i),u=this._platform.createParticleBuffer(i);this._buffer0=new fi(t,l,!1,this._attributesStrideSize),this._buffer1=new fi(t,u,!1,this._attributesStrideSize),this._spriteBuffer=new fi(t,o,!1,4),this._renderVertexBuffers=[],this._createVertexBuffers(this._buffer0,this._buffer1,this._spriteBuffer),this._createVertexBuffers(this._buffer1,this._buffer0,this._spriteBuffer),this._sourceBuffer=this._buffer0,this._targetBuffer=this._buffer1}_recreateUpdateEffect(){this._createColorGradientTexture(),this._createSizeGradientTexture(),this._createAngularSpeedGradientTexture(),this._createVelocityGradientTexture(),this._createLimitVelocityGradientTexture(),this._createDragGradientTexture();let e=this.particleEmitterType?this.particleEmitterType.getEffectDefines():"";return this._isBillboardBased&&(e+=`
#define BILLBOARD`),this._colorGradientsTexture&&(e+=`
#define COLORGRADIENTS`),this._sizeGradientsTexture&&(e+=`
#define SIZEGRADIENTS`),this._angularSpeedGradientsTexture&&(e+=`
#define ANGULARSPEEDGRADIENTS`),this._velocityGradientsTexture&&(e+=`
#define VELOCITYGRADIENTS`),this._limitVelocityGradientsTexture&&(e+=`
#define LIMITVELOCITYGRADIENTS`),this._dragGradientsTexture&&(e+=`
#define DRAGGRADIENTS`),this.isAnimationSheetEnabled&&(e+=`
#define ANIMATESHEET`,this.spriteRandomStartCell&&(e+=`
#define ANIMATESHEETRANDOMSTART`)),this.noiseTexture&&(e+=`
#define NOISE`),this.isLocal&&(e+=`
#define LOCAL`),this._platform.isUpdateBufferCreated()&&this._cachedUpdateDefines===e?this._platform.isUpdateBufferReady():(this._cachedUpdateDefines=e,this._updateBuffer=this._platform.createUpdateBuffer(e),this._platform.isUpdateBufferReady())}_getWrapper(e){const t=this._getCustomDrawWrapper(e);if(t!=null&&t.effect)return t;const i=[];this.fillDefines(i,e);let r=this._drawWrappers[e];r||(r=new vi(this._engine),r.drawContext&&(r.drawContext.useInstancing=!0),this._drawWrappers[e]=r);const s=i.join(`
`);if(r.defines!==s){const n=[],o=[],l=[];this.fillUniformsAttributesAndSamplerNames(o,n,l),r.setEffect(this._engine.createEffect("gpuRenderParticles",n,o,l,s),s)}return r}static _GetAttributeNamesOrOptions(e=!1,t=!1,i=!1,r=!1){const s=[N.PositionKind,"age","life","size","angle"];return e||s.push(N.ColorKind),t&&s.push("cellIndex"),i||s.push("initialDirection"),r&&s.push("direction"),s.push("offset",N.UVKind),s}static _GetEffectCreationOptions(e=!1,t=!1,i=!1){const r=["emitterWM","worldOffset","view","projection","colorDead","invView","translationPivot","eyePosition"];return _n(r),e&&r.push("sheetInfos"),t&&r.push("logarithmicDepthConstant"),i&&(r.push("vFogInfos"),r.push("vFogColor")),r}fillDefines(e,t=0,i=!0){if(this._scene&&(Zn(this,this._scene,e),this.applyFog&&this._scene.fogEnabled&&this._scene.fogMode!==Te.FOGMODE_NONE&&e.push("#define FOG")),t===ut.BLENDMODE_MULTIPLY&&e.push("#define BLENDMULTIPLYMODE"),this.isLocal&&e.push("#define LOCAL"),this.useLogarithmicDepth&&e.push("#define LOGARITHMICDEPTH"),this._isBillboardBased)switch(e.push("#define BILLBOARD"),this.billboardMode){case ut.BILLBOARDMODE_Y:e.push("#define BILLBOARDY");break;case ut.BILLBOARDMODE_STRETCHED:e.push("#define BILLBOARDSTRETCHED");break;case ut.BILLBOARDMODE_ALL:e.push("#define BILLBOARDMODE_ALL");break}this._colorGradientsTexture&&e.push("#define COLORGRADIENTS"),this.isAnimationSheetEnabled&&e.push("#define ANIMATESHEET"),i&&this._imageProcessingConfiguration&&(this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines),e.push(""+this._imageProcessingConfigurationDefines.toString()))}fillUniformsAttributesAndSamplerNames(e,t,i){t.push(...Lr._GetAttributeNamesOrOptions(!!this._colorGradientsTexture,this._isAnimationSheetEnabled,this._isBillboardBased,this._isBillboardBased&&this.billboardMode===ut.BILLBOARDMODE_STRETCHED)),e.push(...Lr._GetEffectCreationOptions(this._isAnimationSheetEnabled,this.useLogarithmicDepth,this.applyFog)),i.push("diffuseSampler","colorGradientSampler"),this._imageProcessingConfiguration&&(ts.PrepareUniforms(e,this._imageProcessingConfigurationDefines),ts.PrepareSamplers(i,this._imageProcessingConfigurationDefines))}animate(e=!1){var t;this._timeDelta=this.updateSpeed*(e?this.preWarmStepOffset:((t=this._scene)==null?void 0:t.getAnimationRatio())||1),this._actualFrame+=this._timeDelta,this._stopped||this.targetStopDuration&&this._actualFrame>=this.targetStopDuration&&this.stop(),this.updateInAnimate&&this._update()}_createFactorGradientTexture(e,t){const i=this[t];if(!e||!e.length||i)return;const r=new Float32Array(this._rawTextureWidth);for(let s=0;s<this._rawTextureWidth;s++){const n=s/this._rawTextureWidth;Wi.GetCurrentGradient(n,e,(o,l,u)=>{r[s]=mi(o.factor1,l.factor1,u)})}this[t]=qt.CreateRTexture(r,this._rawTextureWidth,1,this._scene||this._engine,!1,!1,1),this[t].name=t.substring(1)}_createSizeGradientTexture(){this._createFactorGradientTexture(this._sizeGradients,"_sizeGradientsTexture")}_createAngularSpeedGradientTexture(){this._createFactorGradientTexture(this._angularSpeedGradients,"_angularSpeedGradientsTexture")}_createVelocityGradientTexture(){this._createFactorGradientTexture(this._velocityGradients,"_velocityGradientsTexture")}_createLimitVelocityGradientTexture(){this._createFactorGradientTexture(this._limitVelocityGradients,"_limitVelocityGradientsTexture")}_createDragGradientTexture(){this._createFactorGradientTexture(this._dragGradients,"_dragGradientsTexture")}_createColorGradientTexture(){if(!this._colorGradients||!this._colorGradients.length||this._colorGradientsTexture)return;const e=new Uint8Array(this._rawTextureWidth*4),t=_t.Color4[0];for(let i=0;i<this._rawTextureWidth;i++){const r=i/this._rawTextureWidth;Wi.GetCurrentGradient(r,this._colorGradients,(s,n,o)=>{xe.LerpToRef(s.color1,n.color1,o,t),e[i*4]=t.r*255,e[i*4+1]=t.g*255,e[i*4+2]=t.b*255,e[i*4+3]=t.a*255})}this._colorGradientsTexture=qt.CreateRGBATexture(e,this._rawTextureWidth,1,this._scene,!1,!1,1),this._colorGradientsTexture.name="colorGradients"}_render(e,t){var o,l,u,c;const i=this._getWrapper(e),r=i.effect;this._engine.enableEffect(i);const s=((o=this._scene)==null?void 0:o.getViewMatrix())||$.IdentityReadOnly;if(r.setMatrix("view",s),r.setMatrix("projection",this.defaultProjectionMatrix??this._scene.getProjectionMatrix()),r.setTexture("diffuseSampler",this.particleTexture),r.setVector2("translationPivot",this.translationPivot),r.setVector3("worldOffset",this.worldOffset),this.isLocal&&r.setMatrix("emitterWM",t),this._colorGradientsTexture?r.setTexture("colorGradientSampler",this._colorGradientsTexture):r.setDirectColor4("colorDead",this.colorDead),this._isAnimationSheetEnabled&&this.particleTexture){const h=this.particleTexture.getBaseSize();r.setFloat3("sheetInfos",this.spriteCellWidth/h.width,this.spriteCellHeight/h.height,h.width/this.spriteCellWidth)}if(this._isBillboardBased&&this._scene){const h=this._scene.activeCamera;r.setVector3("eyePosition",h.globalPosition)}const n=r.defines;if(this._scene&&(Fs(r,this,this._scene),this.applyFog&&gu(this._scene,void 0,r)),n.indexOf("#define BILLBOARDMODE_ALL")>=0){const h=s.clone();h.invert(),r.setMatrix("invView",h)}switch(this.useLogarithmicDepth&&this._scene&&qa(n,r,this._scene),this._imageProcessingConfiguration&&!this._imageProcessingConfiguration.applyByPostProcess&&this._imageProcessingConfiguration.bind(r),e){case ut.BLENDMODE_ADD:this._engine.setAlphaMode(1);break;case ut.BLENDMODE_ONEONE:this._engine.setAlphaMode(6);break;case ut.BLENDMODE_STANDARD:this._engine.setAlphaMode(2);break;case ut.BLENDMODE_MULTIPLY:this._engine.setAlphaMode(4);break}return this._platform.bindDrawBuffers(this._targetIndex,r,(l=this._scene)!=null&&l.forceWireframe?this._linesIndexBufferUseInstancing:null),this._onBeforeDrawParticlesObservable&&this._onBeforeDrawParticlesObservable.notifyObservers(r),(u=this._scene)!=null&&u.forceWireframe?this._engine.drawElementsType(6,0,10,this._currentActiveCount):this._engine.drawArraysType(7,0,4,this._currentActiveCount),this._engine.setAlphaMode(0),(c=this._scene)!=null&&c.forceWireframe&&this._engine.unbindInstanceAttributes(),this._currentActiveCount}_update(e){if(!this.emitter||!this._targetBuffer||!this._recreateUpdateEffect()||this._rebuildingAfterContextLost)return;if(!e)if(this.emitter.position)e=this.emitter.getWorldMatrix();else{const s=this.emitter;e=V.Matrix[0],$.TranslationToRef(s.x,s.y,s.z,e)}const t=this._engine,i=t.getDepthWrite();t.setDepthWrite(!1),this._platform.preUpdateParticleBuffer(),this._updateBuffer.setFloat("currentCount",this._currentActiveCount),this._updateBuffer.setFloat("timeDelta",this._timeDelta),this._updateBuffer.setFloat("stopFactor",this._stopped?0:1),this._updateBuffer.setInt("randomTextureSize",this._randomTextureSize),this._updateBuffer.setFloat2("lifeTime",this.minLifeTime,this.maxLifeTime),this._updateBuffer.setFloat2("emitPower",this.minEmitPower,this.maxEmitPower),this._colorGradientsTexture||(this._updateBuffer.setDirectColor4("color1",this.color1),this._updateBuffer.setDirectColor4("color2",this.color2)),this._updateBuffer.setFloat2("sizeRange",this.minSize,this.maxSize),this._updateBuffer.setFloat4("scaleRange",this.minScaleX,this.maxScaleX,this.minScaleY,this.maxScaleY),this._updateBuffer.setFloat4("angleRange",this.minAngularSpeed,this.maxAngularSpeed,this.minInitialRotation,this.maxInitialRotation),this._updateBuffer.setVector3("gravity",this.gravity),this._limitVelocityGradientsTexture&&this._updateBuffer.setFloat("limitVelocityDamping",this.limitVelocityDamping),this.particleEmitterType&&this.particleEmitterType.applyToShader(this._updateBuffer),this._isAnimationSheetEnabled&&this._updateBuffer.setFloat4("cellInfos",this.startSpriteCellID,this.endSpriteCellID,this.spriteCellChangeSpeed,this.spriteCellLoop?1:0),this.noiseTexture&&this._updateBuffer.setVector3("noiseStrength",this.noiseStrength),this.isLocal||this._updateBuffer.setMatrix("emitterWM",e),this._platform.updateParticleBuffer(this._targetIndex,this._targetBuffer,this._currentActiveCount),this._targetIndex++,this._targetIndex===2&&(this._targetIndex=0);const r=this._sourceBuffer;this._sourceBuffer=this._targetBuffer,this._targetBuffer=r,t.setDepthWrite(i)}render(e=!1,t=!1){if(!this._started||!this.isReady())return 0;if(!e&&this._scene){if(!this._preWarmDone&&this.preWarmCycles){for(let n=0;n<this.preWarmCycles;n++)this.animate(!0),this.render(!0,!0);this._preWarmDone=!0}if(this._currentRenderId===this._scene.getRenderId()&&(!this._scene.activeCamera||this._scene.activeCamera&&this._currentRenderingCameraUniqueId===this._scene.activeCamera.uniqueId))return 0;this._currentRenderId=this._scene.getRenderId(),this._scene.activeCamera&&(this._currentRenderingCameraUniqueId=this._scene.activeCamera.uniqueId)}if(this._initialize(),this.manualEmitCount>-1?(this._accumulatedCount+=this.manualEmitCount,this.manualEmitCount=0):this._accumulatedCount+=this.emitRate*this._timeDelta,this._accumulatedCount>=1){const n=this._accumulatedCount|0;this._accumulatedCount-=n,this._currentActiveCount+=n}if(this._currentActiveCount=Math.min(this._maxActiveParticleCount,this._currentActiveCount),!this._currentActiveCount)return 0;let i;if(this.emitter.position)i=this.emitter.getWorldMatrix();else{const n=this.emitter;i=V.Matrix[0],$.TranslationToRef(n.x,n.y,n.z,i)}const r=this._engine;this.updateInAnimate||this._update(i);let s=0;return!e&&!t&&(r.setState(!1),this.forceDepthWrite&&r.setDepthWrite(!0),this.blendMode===ut.BLENDMODE_MULTIPLYADD?s=this._render(ut.BLENDMODE_MULTIPLY,i)+this._render(ut.BLENDMODE_ADD,i):s=this._render(this.blendMode,i),this._engine.setAlphaMode(0)),s}rebuild(){const e=()=>{!this._recreateUpdateEffect()||!this._platform.isUpdateBufferReady()?setTimeout(e,10):(this._initialize(!0),this._rebuildingAfterContextLost=!1)};this._createIndexBuffer(),this._cachedUpdateDefines="",this._platform.contextLost(),this._rebuildingAfterContextLost=!0,e()}_releaseBuffers(){this._buffer0&&(this._buffer0.dispose(),this._buffer0=null),this._buffer1&&(this._buffer1.dispose(),this._buffer1=null),this._spriteBuffer&&(this._spriteBuffer.dispose(),this._spriteBuffer=null),this._platform.releaseBuffers()}dispose(e=!0){for(const t in this._drawWrappers)this._drawWrappers[t].dispose();if(this._drawWrappers={},this._scene){const t=this._scene.particleSystems.indexOf(this);t>-1&&this._scene.particleSystems.splice(t,1)}this._releaseBuffers(),this._platform.releaseVertexBuffers();for(let t=0;t<this._renderVertexBuffers.length;++t){const i=this._renderVertexBuffers[t];for(const r in i)i[r].dispose()}this._renderVertexBuffers=[],this._colorGradientsTexture&&(this._colorGradientsTexture.dispose(),this._colorGradientsTexture=null),this._sizeGradientsTexture&&(this._sizeGradientsTexture.dispose(),this._sizeGradientsTexture=null),this._angularSpeedGradientsTexture&&(this._angularSpeedGradientsTexture.dispose(),this._angularSpeedGradientsTexture=null),this._velocityGradientsTexture&&(this._velocityGradientsTexture.dispose(),this._velocityGradientsTexture=null),this._limitVelocityGradientsTexture&&(this._limitVelocityGradientsTexture.dispose(),this._limitVelocityGradientsTexture=null),this._dragGradientsTexture&&(this._dragGradientsTexture.dispose(),this._dragGradientsTexture=null),this._randomTexture&&(this._randomTexture.dispose(),this._randomTexture=null),this._randomTexture2&&(this._randomTexture2.dispose(),this._randomTexture2=null),e&&this.particleTexture&&(this.particleTexture.dispose(),this.particleTexture=null),e&&this.noiseTexture&&(this.noiseTexture.dispose(),this.noiseTexture=null),this.onStoppedObservable.clear(),this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear()}clone(e,t,i=!1){const r={...this._customWrappers};let s=null;const n=this._engine;if(n.createEffectForParticles&&this.customShader!=null){s=this.customShader;const u=s.shaderOptions.defines.length>0?s.shaderOptions.defines.join(`
`):"";r[0]=n.createEffectForParticles(s.shaderPath.fragmentElement,s.shaderOptions.uniforms,s.shaderOptions.samplers,u,void 0,void 0,void 0,this)}const o=this.serialize(i),l=Lr.Parse(o,this._scene||this._engine,this._rootUrl);return l.name=e,l.customShader=s,l._customWrappers=r,t===void 0&&(t=this.emitter),this.noiseTexture&&(l.noiseTexture=this.noiseTexture.clone()),l.emitter=t,l}serialize(e=!1){const t={};return ut._Serialize(t,this,e),t.activeParticleCount=this.activeParticleCount,t.randomTextureSize=this._randomTextureSize,t.customShader=this.customShader,t}static Parse(e,t,i,r=!1,s){const n=e.name;let o,l;t instanceof st?o=t:(l=t,o=l.getEngine());const u=new Lr(n,{capacity:s||e.capacity,randomTextureSize:e.randomTextureSize},t,null,e.isAnimationSheetEnabled);if(u._rootUrl=i,e.customShader&&o.createEffectForParticles){const c=e.customShader,h=c.shaderOptions.defines.length>0?c.shaderOptions.defines.join(`
`):"",d=o.createEffectForParticles(c.shaderPath.fragmentElement,c.shaderOptions.uniforms,c.shaderOptions.samplers,h,void 0,void 0,void 0,u);u.setCustomEffect(d,0),u.customShader=c}return e.id&&(u.id=e.id),e.activeParticleCount&&(u.activeParticleCount=e.activeParticleCount),ut._Parse(e,u,t,i),e.preventAutoStart&&(u.preventAutoStart=e.preventAutoStart),!r&&!u.preventAutoStart&&u.start(),u}}class $a{constructor(){this._emitterNodeIsOwned=!0,this.systems=[]}get emitterNode(){return this._emitterNode}set emitterNode(e){this._emitterNodeIsOwned&&this._emitterNode&&(this._emitterNode.dispose&&this._emitterNode.dispose(),this._emitterNodeIsOwned=!1);for(const t of this.systems)t.emitter=e;this._emitterNode=e}setEmitterAsSphere(e,t,i){this._emitterNodeIsOwned&&this._emitterNode&&this._emitterNode.dispose&&this._emitterNode.dispose(),this._emitterNodeIsOwned=!0,this._emitterCreationOptions={kind:"Sphere",options:e,renderingGroupId:t};const r=Ti("emitterSphere",{diameter:e.diameter,segments:e.segments},i);r.renderingGroupId=t;const s=new Ut("emitterSphereMaterial",i);s.emissiveColor=e.color,r.material=s;for(const n of this.systems)n.emitter=r;this._emitterNode=r}start(e){for(const t of this.systems)e&&(t.emitter=e),t.start()}dispose(){for(const e of this.systems)e.dispose();this.systems.length=0,this._emitterNode&&(this._emitterNode.dispose&&this._emitterNode.dispose(),this._emitterNode=null)}serialize(e=!1){const t={};t.systems=[];for(const i of this.systems)t.systems.push(i.serialize(e));return this._emitterNode&&(t.emitter=this._emitterCreationOptions),t}static Parse(e,t,i=!1,r){const s=new $a,n=this.BaseAssetsUrl+"/textures/";t=t||ze.LastCreatedScene;for(const o of e.systems)s.systems.push(i?Lr.Parse(o,t,n,!0,r):ut.Parse(o,t,n,!0,r));if(e.emitter){const o=e.emitter.options;switch(e.emitter.kind){case"Sphere":s.setEmitterAsSphere({diameter:o.diameter,segments:o.segments,color:ne.FromArray(o.color)},e.emitter.renderingGroupId,t);break}}return s}}$a.BaseAssetsUrl="https://assets.babylonjs.com/particles";class Ha{static CreateDefault(e,t=500,i,r=!1){let s;r?s=new Lr("default system",{capacity:t},i):s=new ut("default system",t,i),s.emitter=e;const n=ae.GetAssetUrl("https://assets.babylonjs.com/core/textures/flare.png");return s.particleTexture=new Y(n,s.getScene()),s.createConeEmitter(.1,Math.PI/4),s.color1=new xe(1,1,1,1),s.color2=new xe(1,1,1,1),s.colorDead=new xe(1,1,1,0),s.minSize=.1,s.maxSize=.1,s.minEmitPower=2,s.maxEmitPower=2,s.updateSpeed=1/60,s.emitRate=30,s}static CreateAsync(e,t,i=!1,r){t||(t=ze.LastCreatedScene);const s={};return t.addPendingData(s),new Promise((n,o)=>{if(i&&!Lr.IsSupported)return t.removePendingData(s),o("Particle system with GPU is not supported.");ae.LoadFile(`${Ha.BaseAssetsUrl}/systems/${e}.json`,l=>{t.removePendingData(s);const u=JSON.parse(l.toString());return n($a.Parse(u,t,i,r))},void 0,void 0,void 0,()=>(t.removePendingData(s),o(`An error occurred with the creation of your particle system. Check if your type '${e}' exists.`)))})}static ExportSet(e){const t=new $a;for(const i of e)t.systems.push(i);return t}static ParseFromFileAsync(e,t,i,r=!1,s="",n){return new Promise((o,l)=>{const u=new ss;u.addEventListener("readystatechange",()=>{if(u.readyState==4)if(u.status==200){const c=JSON.parse(u.responseText);let h;r?h=Lr.Parse(c,i,s,!1,n):h=ut.Parse(c,i,s,!1,n),e&&(h.name=e),o(h)}else l("Unable to load the particle system")}),u.open("GET",t),u.send()})}static ParseFromSnippetAsync(e,t,i=!1,r="",s){if(e==="_BLANK"){const n=this.CreateDefault(null);return n.start(),Promise.resolve(n)}return new Promise((n,o)=>{const l=new ss;l.addEventListener("readystatechange",()=>{if(l.readyState==4)if(l.status==200){const u=JSON.parse(JSON.parse(l.responseText).jsonPayload),c=JSON.parse(u.particleSystem);let h;i?h=Lr.Parse(c,t,r,!1,s):h=ut.Parse(c,t,r,!1,s),h.snippetId=e,n(h)}else o("Unable to load the snippet "+e)}),l.open("GET",this.SnippetUrl+"/"+e.replace(/#/g,"/")),l.send()})}}Ha.BaseAssetsUrl=$a.BaseAssetsUrl;Ha.SnippetUrl="https://snippet.babylonjs.com";Ha.CreateFromSnippetAsync=Ha.ParseFromSnippetAsync;rl(ge.NAME_PARTICLESYSTEM,(a,e,t,i)=>{const r=Ty(ge.NAME_PARTICLESYSTEM);if(r&&a.particleSystems!==void 0&&a.particleSystems!==null)for(let s=0,n=a.particleSystems.length;s<n;s++){const o=a.particleSystems[s];t.particleSystems.push(r(o,e,i))}});UM(ge.NAME_PARTICLESYSTEM,(a,e,t)=>a.activeParticleCount?Lr.Parse(a,e,t):ut.Parse(a,e,t));st.prototype.createEffectForParticles=function(a,e=[],t=[],i="",r,s,n,o,l=0,u){let c=[],h=[];const d=[];return o?o.fillUniformsAttributesAndSamplerNames(h,c,d):(c=ut._GetAttributeNamesOrOptions(),h=ut._GetEffectCreationOptions()),i.indexOf(" BILLBOARD")===-1&&(i+=`
#define BILLBOARD
`),o!=null&&o.isAnimationSheetEnabled&&i.indexOf(" ANIMATESHEET")===-1&&(i+=`
#define ANIMATESHEET
`),t.indexOf("diffuseSampler")===-1&&t.push("diffuseSampler"),this.createEffect({vertex:u??(o==null?void 0:o.vertexShaderName)??"particles",fragmentElement:a},c,h.concat(e),d.concat(t),i,r,s,n,void 0,l,async()=>{l===0?await k(()=>Promise.resolve().then(()=>EP),void 0):await k(()=>Promise.resolve().then(()=>MP),void 0)})};z.prototype.getEmittedParticleSystems=function(){const a=[];for(let e=0;e<this.getScene().particleSystems.length;e++){const t=this.getScene().particleSystems[e];t.emitter===this&&a.push(t)}return a};z.prototype.getHierarchyEmittedParticleSystems=function(){const a=[],e=this.getDescendants();e.push(this);for(let t=0;t<this.getScene().particleSystems.length;t++){const i=this.getScene().particleSystems[t],r=i.emitter;r.position&&e.indexOf(r)!==-1&&a.push(i)}return a};const wd="particlesPixelShader",CP=`#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
varying vec2 vUV;varying vec4 vColor;uniform vec4 textureMask;uniform sampler2D diffuseSampler;
#include<clipPlaneFragmentDeclaration>
#include<imageProcessingDeclaration>
#include<logDepthDeclaration>
#include<helperFunctions>
#include<imageProcessingFunctions>
#ifdef RAMPGRADIENT
varying vec4 remapRanges;uniform sampler2D rampSampler;
#endif
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec4 textureColor=texture2D(diffuseSampler,vUV);vec4 baseColor=(textureColor*textureMask+(vec4(1.,1.,1.,1.)-textureMask))*vColor;
#ifdef RAMPGRADIENT
float alpha=baseColor.a;float remappedColorIndex=clamp((alpha-remapRanges.x)/remapRanges.y,0.0,1.0);vec4 rampColor=texture2D(rampSampler,vec2(1.0-remappedColorIndex,0.));baseColor.rgb*=rampColor.rgb;float finalAlpha=baseColor.a;baseColor.a=clamp((alpha*rampColor.a-remapRanges.z)/remapRanges.w,0.0,1.0);
#endif
#ifdef BLENDMULTIPLYMODE
float sourceAlpha=vColor.a*textureColor.a;baseColor.rgb=baseColor.rgb*sourceAlpha+vec3(1.0)*(1.0-sourceAlpha);
#endif
#include<logDepthFragment>
#include<fogFragment>(color,baseColor)
#ifdef IMAGEPROCESSINGPOSTPROCESS
baseColor.rgb=toLinearSpace(baseColor.rgb);
#else
#ifdef IMAGEPROCESSING
baseColor.rgb=toLinearSpace(baseColor.rgb);baseColor=applyImageProcessing(baseColor);
#endif
#endif
gl_FragColor=baseColor;
#define CUSTOM_FRAGMENT_MAIN_END
}`;P.ShadersStore[wd]||(P.ShadersStore[wd]=CP);const aV={name:wd,shader:CP},oV=Object.freeze(Object.defineProperty({__proto__:null,particlesPixelShader:aV},Symbol.toStringTag,{value:"Module"})),Nd="particlesVertexShader",PP=`attribute vec3 position;attribute vec4 color;attribute float angle;attribute vec2 size;
#ifdef ANIMATESHEET
attribute float cellIndex;
#endif
#ifndef BILLBOARD
attribute vec3 direction;
#endif
#ifdef BILLBOARDSTRETCHED
attribute vec3 direction;
#endif
#ifdef RAMPGRADIENT
attribute vec4 remapData;
#endif
attribute vec2 offset;uniform mat4 view;uniform mat4 projection;uniform vec2 translationPivot;
#ifdef ANIMATESHEET
uniform vec3 particlesInfos; 
#endif
varying vec2 vUV;varying vec4 vColor;varying vec3 vPositionW;
#ifdef RAMPGRADIENT
varying vec4 remapRanges;
#endif
#if defined(BILLBOARD) && !defined(BILLBOARDY) && !defined(BILLBOARDSTRETCHED)
uniform mat4 invView;
#endif
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<logDepthDeclaration>
#ifdef BILLBOARD
uniform vec3 eyePosition;
#endif
vec3 rotate(vec3 yaxis,vec3 rotatedCorner) {vec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));vec3 zaxis=normalize(cross(yaxis,xaxis));vec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);vec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);vec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);mat3 rotMatrix= mat3(row0,row1,row2);vec3 alignedCorner=rotMatrix*rotatedCorner;return position+alignedCorner;}
#ifdef BILLBOARDSTRETCHED
vec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {vec3 normalizedToCamera=normalize(toCamera);vec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));vec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);vec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);
#ifdef BILLBOARDSTRETCHED_LOCAL
vec3 row1=direction;
#else
vec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));vec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);
#endif
mat3 rotMatrix= mat3(row0,row1,row2);vec3 alignedCorner=rotMatrix*rotatedCorner;return position+alignedCorner;}
#endif
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec2 cornerPos;cornerPos=(vec2(offset.x-0.5,offset.y -0.5)-translationPivot)*size;
#ifdef BILLBOARD
vec3 rotatedCorner;
#ifdef BILLBOARDY
rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.y=0.;rotatedCorner.xz+=translationPivot;vec3 yaxis=position-eyePosition;yaxis.y=0.;vPositionW=rotate(normalize(yaxis),rotatedCorner);vec3 viewPos=(view*vec4(vPositionW,1.0)).xyz;
#elif defined(BILLBOARDSTRETCHED)
rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.z=0.;rotatedCorner.xy+=translationPivot;vec3 toCamera=position-eyePosition;vPositionW=rotateAlign(toCamera,rotatedCorner);vec3 viewPos=(view*vec4(vPositionW,1.0)).xyz;
#else
rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.z=0.;rotatedCorner.xy+=translationPivot;vec3 viewPos=(view*vec4(position,1.0)).xyz+rotatedCorner;vPositionW=(invView*vec4(viewPos,1)).xyz;
#endif
#ifdef RAMPGRADIENT
remapRanges=remapData;
#endif
gl_Position=projection*vec4(viewPos,1.0);
#else
vec3 rotatedCorner;rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.y=0.;rotatedCorner.xz+=translationPivot;vec3 yaxis=normalize(direction);vPositionW=rotate(yaxis,rotatedCorner);gl_Position=projection*view*vec4(vPositionW,1.0);
#endif
vColor=color;
#ifdef ANIMATESHEET
float rowOffset=floor(cellIndex*particlesInfos.z);float columnOffset=cellIndex-rowOffset/particlesInfos.z;vec2 uvScale=particlesInfos.xy;vec2 uvOffset=vec2(offset.x ,1.0-offset.y);vUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;
#else
vUV=offset;
#endif
#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6) || defined(FOG)
vec4 worldPos=vec4(vPositionW,1.0);
#endif
#include<clipPlaneVertex>
#include<fogVertex>
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStore[Nd]||(P.ShadersStore[Nd]=PP);const lV={name:Nd,shader:PP},EP=Object.freeze(Object.defineProperty({__proto__:null,particlesVertexShader:lV},Symbol.toStringTag,{value:"Module"})),Fd="particlesPixelShader",IP=`varying vUV: vec2f;varying vColor: vec4f;uniform textureMask: vec4f;var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;
#include<clipPlaneFragmentDeclaration>
#include<imageProcessingDeclaration>
#include<logDepthDeclaration>
#include<helperFunctions>
#include<imageProcessingFunctions>
#ifdef RAMPGRADIENT
varying remapRanges: vec4f;var rampSamplerSampler: sampler;var rampSampler: texture_2d<f32>;
#endif
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
var textureColor: vec4f=textureSample(diffuseSampler,diffuseSamplerSampler,input.vUV);var baseColor: vec4f=(textureColor*uniforms.textureMask+( vec4f(1.,1.,1.,1.)-uniforms.textureMask))*input.vColor;
#ifdef RAMPGRADIENT
var alpha: f32=baseColor.a;var remappedColorIndex: f32=clamp((alpha-input.remapRanges.x)/input.remapRanges.y,0.0,1.0);var rampColor: vec4f=textureSample(rampSampler,rampSamplerSampler,vec2f(1.0-remappedColorIndex,0.));baseColor=vec4f(baseColor.rgb*rampColor.rgb,baseColor.a);var finalAlpha: f32=baseColor.a;baseColor.a=clamp((alpha*rampColor.a-input.remapRanges.z)/input.remapRanges.w,0.0,1.0);
#endif
#ifdef BLENDMULTIPLYMODE
var sourceAlpha: f32=input.vColor.a*textureColor.a;baseColor=vec4f(baseColor.rgb*sourceAlpha+ vec3f(1.0)*(1.0-sourceAlpha),baseColor.a);
#endif
#include<logDepthFragment>
#include<fogFragment>(color,baseColor)
#ifdef IMAGEPROCESSINGPOSTPROCESS
baseColor=vec4f(toLinearSpaceVec3(baseColor.rgb),baseColor.a);
#else
#ifdef IMAGEPROCESSING
baseColor=vec4f(toLinearSpaceVec3(baseColor.rgb),baseColor.a);baseColor=applyImageProcessing(baseColor);
#endif
#endif
fragmentOutputs.color=baseColor;
#define CUSTOM_FRAGMENT_MAIN_END
}`;P.ShadersStoreWGSL[Fd]||(P.ShadersStoreWGSL[Fd]=IP);const uV={name:Fd,shader:IP},cV=Object.freeze(Object.defineProperty({__proto__:null,particlesPixelShaderWGSL:uV},Symbol.toStringTag,{value:"Module"})),Ld="particlesVertexShader",RP=`attribute position: vec3f;attribute color: vec4f;attribute angle: f32;attribute size: vec2f;
#ifdef ANIMATESHEET
attribute cellIndex: f32;
#endif
#ifndef BILLBOARD
attribute direction: vec3f;
#endif
#ifdef BILLBOARDSTRETCHED
attribute direction: vec3f;
#endif
#ifdef RAMPGRADIENT
attribute remapData: vec4f;
#endif
attribute offset: vec2f;uniform view: mat4x4f;uniform projection: mat4x4f;uniform translationPivot: vec2f;
#ifdef ANIMATESHEET
uniform particlesInfos: vec3f; 
#endif
varying vUV: vec2f;varying vColor: vec4f;varying vPositionW: vec3f;
#ifdef RAMPGRADIENT
varying remapRanges: vec4f;
#endif
#if defined(BILLBOARD) && !defined(BILLBOARDY) && !defined(BILLBOARDSTRETCHED)
uniform invView: mat4x4f;
#endif
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<logDepthDeclaration>
#ifdef BILLBOARD
uniform eyePosition: vec3f;
#endif
fn rotate(yaxis: vec3f,rotatedCorner: vec3f)->vec3f {var xaxis: vec3f=normalize(cross( vec3f(0.,1.0,0.),yaxis));var zaxis: vec3f=normalize(cross(yaxis,xaxis));var row0: vec3f= vec3f(xaxis.x,xaxis.y,xaxis.z);var row1: vec3f= vec3f(yaxis.x,yaxis.y,yaxis.z);var row2: vec3f= vec3f(zaxis.x,zaxis.y,zaxis.z);var rotMatrix: mat3x3f= mat3x3f(row0,row1,row2);var alignedCorner: vec3f=rotMatrix*rotatedCorner;return vertexInputs.position+alignedCorner;}
#ifdef BILLBOARDSTRETCHED
fn rotateAlign(toCamera: vec3f,rotatedCorner: vec3f)->vec3f {var normalizedToCamera: vec3f=normalize(toCamera);var normalizedCrossDirToCamera: vec3f=normalize(cross(normalize(vertexInputs.direction),normalizedToCamera));var row0: vec3f= vec3f(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);var row2: vec3f= vec3f(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);
#ifdef BILLBOARDSTRETCHED_LOCAL
var row1: vec3f=vertexInputs.direction;
#else
var crossProduct: vec3f=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));var row1: vec3f= vec3f(crossProduct.x,crossProduct.y,crossProduct.z);
#endif
var rotMatrix: mat3x3f= mat3x3f(row0,row1,row2);var alignedCorner: vec3f=rotMatrix*rotatedCorner;return vertexInputs.position+alignedCorner;}
#endif
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
var cornerPos: vec2f;cornerPos=( vec2f(input.offset.x-0.5,input.offset.y -0.5)-uniforms.translationPivot)*input.size;
#ifdef BILLBOARD
var rotatedCorner: vec3f;
#ifdef BILLBOARDY
rotatedCorner.x=cornerPos.x*cos(input.angle)-cornerPos.y*sin(input.angle)+uniforms.translationPivot.x;rotatedCorner.z=cornerPos.x*sin(input.angle)+cornerPos.y*cos(input.angle)+uniforms.translationPivot.y;rotatedCorner.y=0.;var yaxis: vec3f=input.position-uniforms.eyePosition;yaxis.y=0.;vertexOutputs.vPositionW=rotate(normalize(yaxis),rotatedCorner);var viewPos: vec3f=(uniforms.view* vec4f(vertexOutputs.vPositionW,1.0)).xyz;
#elif defined(BILLBOARDSTRETCHED)
rotatedCorner.x=cornerPos.x*cos(input.angle)-cornerPos.y*sin(input.angle)+uniforms.translationPivot.x;rotatedCorner.y=cornerPos.x*sin(input.angle)+cornerPos.y*cos(input.angle)+uniforms.translationPivot.y;rotatedCorner.z=0.;var toCamera: vec3f=input.position-uniforms.eyePosition;vertexOutputs.vPositionW=rotateAlign(toCamera,rotatedCorner);var viewPos: vec3f=(uniforms.view* vec4f(vertexOutputs.vPositionW,1.0)).xyz;
#else
rotatedCorner.x=cornerPos.x*cos(input.angle)-cornerPos.y*sin(input.angle)+uniforms.translationPivot.x;rotatedCorner.y=cornerPos.x*sin(input.angle)+cornerPos.y*cos(input.angle)+uniforms.translationPivot.y;rotatedCorner.z=0.;var viewPos: vec3f=(uniforms.view* vec4f(input.position,1.0)).xyz+rotatedCorner;vertexOutputs.vPositionW=(uniforms.invView* vec4f(viewPos,1)).xyz;
#endif
#ifdef RAMPGRADIENT
vertexOutputs.remapRanges=input.remapData;
#endif
vertexOutputs.position=uniforms.projection* vec4f(viewPos,1.0);
#else
var rotatedCorner: vec3f;rotatedCorner.x=cornerPos.x*cos(input.angle)-cornerPos.y*sin(input.angle)+uniforms.translationPivot.x;rotatedCorner.z=cornerPos.x*sin(input.angle)+cornerPos.y*cos(input.angle)+uniforms.translationPivot.y;rotatedCorner.y=0.;var yaxis: vec3f=normalize(vertexInputs.direction);vertexOutputs.vPositionW=rotate(yaxis,rotatedCorner);vertexOutputs.position=uniforms.projection*uniforms.view* vec4f(vertexOutputs.vPositionW,1.0);
#endif
vertexOutputs.vColor=input.color;
#ifdef ANIMATESHEET
var rowOffset: f32=floor(input.cellIndex*uniforms.particlesInfos.z);var columnOffset: f32=input.cellIndex-rowOffset/uniforms.particlesInfos.z;var uvScale: vec2f=uniforms.particlesInfos.xy;var uvOffset: vec2f= vec2f(input.offset.x ,1.0-input.offset.y);vertexOutputs.vUV=(uvOffset+ vec2f(columnOffset,rowOffset))*uvScale;
#else
vertexOutputs.vUV=input.offset;
#endif
#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6) || defined(FOG)
var worldPos: vec4f= vec4f(vertexOutputs.vPositionW,1.0);
#endif
#include<clipPlaneVertex>
#include<fogVertex>
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStoreWGSL[Ld]||(P.ShadersStoreWGSL[Ld]=RP);const hV={name:Ld,shader:RP},MP=Object.freeze(Object.defineProperty({__proto__:null,particlesVertexShaderWGSL:hV},Symbol.toStringTag,{value:"Module"}));Object.defineProperty(Rt.prototype,"physicsImpostor",{get:function(){return this._physicsImpostor},set:function(a){this._physicsImpostor!==a&&(this._disposePhysicsObserver&&this.onDisposeObservable.remove(this._disposePhysicsObserver),this._physicsImpostor=a,a&&(this._disposePhysicsObserver=this.onDisposeObservable.add(()=>{this.physicsImpostor&&(this.physicsImpostor.dispose(),this.physicsImpostor=null)})))},enumerable:!0,configurable:!0});Rt.prototype.getPhysicsImpostor=function(){return this.physicsImpostor};Rt.prototype.applyImpulse=function(a,e){return this.physicsImpostor?(this.physicsImpostor.applyImpulse(a,e),this):this};Rt.prototype.setPhysicsLinkWith=function(a,e,t,i){return!this.physicsImpostor||!a.physicsImpostor?this:(this.physicsImpostor.createJoint(a.physicsImpostor,rt.HingeJoint,{mainPivot:e,connectedPivot:t,nativeParams:i}),this)};class K_{getPluginVersion(){return this._physicsPlugin.getPluginVersion()}static DefaultPluginFactory(){throw Cr("")}constructor(e,t=K_.DefaultPluginFactory()){this._physicsPlugin=t,this._physicsBodies=[],this._subTimeStep=0,e=e||new m(0,-9.807,0),this.setGravity(e),this.setTimeStep()}setGravity(e){this.gravity=e,this._physicsPlugin.setGravity(this.gravity)}setTimeStep(e=1/60){this._physicsPlugin.setTimeStep(e)}getTimeStep(){return this._physicsPlugin.getTimeStep()}setSubTimeStep(e=0){this._subTimeStep=e}getSubTimeStep(){return this._subTimeStep}dispose(){this._physicsPlugin.dispose()}getPhysicsPluginName(){return this._physicsPlugin.name}setVelocityLimits(e,t){this._physicsPlugin.setVelocityLimits(e,t)}getMaxLinearVelocity(){return this._physicsPlugin.getMaxLinearVelocity()}getMaxAngularVelocity(){return this._physicsPlugin.getMaxAngularVelocity()}_step(e){e>.1?e=.1:e<=0&&(e=1/60),this._physicsPlugin.executeStep(e,this._physicsBodies)}addBody(e){this._physicsBodies.push(e)}removeBody(e){const t=this._physicsBodies.indexOf(e);t>-1&&this._physicsBodies.splice(t,1)}getBodies(){return this._physicsBodies}getPhysicsPlugin(){return this._physicsPlugin}raycastToRef(e,t,i,r){this._physicsPlugin.raycast(e,t,i,r)}raycast(e,t,i){const r=new Qu;return this._physicsPlugin.raycast(e,t,r,i),r}}var Ev;(function(a){a[a.FREE=0]="FREE",a[a.LIMITED=1]="LIMITED",a[a.LOCKED=2]="LOCKED"})(Ev||(Ev={}));var Iv;(function(a){a[a.LINEAR_X=0]="LINEAR_X",a[a.LINEAR_Y=1]="LINEAR_Y",a[a.LINEAR_Z=2]="LINEAR_Z",a[a.ANGULAR_X=3]="ANGULAR_X",a[a.ANGULAR_Y=4]="ANGULAR_Y",a[a.ANGULAR_Z=5]="ANGULAR_Z",a[a.LINEAR_DISTANCE=6]="LINEAR_DISTANCE"})(Iv||(Iv={}));var Rv;(function(a){a[a.BALL_AND_SOCKET=1]="BALL_AND_SOCKET",a[a.DISTANCE=2]="DISTANCE",a[a.HINGE=3]="HINGE",a[a.SLIDER=4]="SLIDER",a[a.LOCK=5]="LOCK",a[a.PRISMATIC=6]="PRISMATIC",a[a.SIX_DOF=7]="SIX_DOF"})(Rv||(Rv={}));var Mv;(function(a){a[a.SPHERE=0]="SPHERE",a[a.CAPSULE=1]="CAPSULE",a[a.CYLINDER=2]="CYLINDER",a[a.BOX=3]="BOX",a[a.CONVEX_HULL=4]="CONVEX_HULL",a[a.CONTAINER=5]="CONTAINER",a[a.MESH=6]="MESH",a[a.HEIGHTFIELD=7]="HEIGHTFIELD"})(Mv||(Mv={}));var Av;(function(a){a[a.NONE=0]="NONE",a[a.VELOCITY=1]="VELOCITY",a[a.POSITION=2]="POSITION"})(Av||(Av={}));var Dv;(function(a){a.COLLISION_STARTED="COLLISION_STARTED",a.COLLISION_CONTINUED="COLLISION_CONTINUED",a.COLLISION_FINISHED="COLLISION_FINISHED",a.TRIGGER_ENTERED="TRIGGER_ENTERED",a.TRIGGER_EXITED="TRIGGER_EXITED"})(Dv||(Dv={}));var Ov;(function(a){a[a.STATIC=0]="STATIC",a[a.ANIMATED=1]="ANIMATED",a[a.DYNAMIC=2]="DYNAMIC"})(Ov||(Ov={}));var wv;(function(a){a[a.DISABLED=0]="DISABLED",a[a.TELEPORT=1]="TELEPORT",a[a.ACTION=2]="ACTION"})(wv||(wv={}));var Nv;(function(a){a[a.SIMULATION_CONTROLLED=0]="SIMULATION_CONTROLLED",a[a.ALWAYS_ACTIVE=1]="ALWAYS_ACTIVE",a[a.ALWAYS_INACTIVE=2]="ALWAYS_INACTIVE"})(Nv||(Nv={}));class Vs{constructor(e,t){if(this._pluginData=void 0,this._isTrigger=!1,this._isDisposed=!1,!t)return;const i=t.getPhysicsEngine();if(!i)throw new Error("No Physics Engine available.");if(i.getPluginVersion()!=2)throw new Error("Plugin version is incorrect. Expected version 2.");const r=i.getPhysicsPlugin();if(!r)throw new Error("No Physics Plugin available.");if(this._physicsPlugin=r,e.pluginData!==void 0&&e.pluginData!==null)this._pluginData=e.pluginData,this._type=this._physicsPlugin.getShapeType(this);else if(e.type!==void 0&&e.type!==null){this._type=e.type;const s=e.parameters??{};this._physicsPlugin.initShape(this,e.type,s)}}getClassName(){return"PhysicsShape"}get type(){return this._type}set filterMembershipMask(e){this._physicsPlugin.setShapeFilterMembershipMask(this,e)}get filterMembershipMask(){return this._physicsPlugin.getShapeFilterMembershipMask(this)}set filterCollideMask(e){this._physicsPlugin.setShapeFilterCollideMask(this,e)}get filterCollideMask(){return this._physicsPlugin.getShapeFilterCollideMask(this)}set material(e){this._physicsPlugin.setMaterial(this,e),this._material=e}get material(){return this._material||(this._material=this._physicsPlugin.getMaterial(this)),this._material}set density(e){this._physicsPlugin.setDensity(this,e)}get density(){return this._physicsPlugin.getDensity(this)}addChildFromParent(e,t,i){const r=i.computeWorldMatrix(!0),s=e.computeWorldMatrix(!0),n=V.Matrix[0];r.multiplyToRef($.Invert(s),n);const o=V.Vector3[0],l=V.Quaternion[0],u=V.Vector3[1];n.decompose(u,l,o),this._physicsPlugin.addChild(this,t,o,l,u)}addChild(e,t,i,r){this._physicsPlugin.addChild(this,e,t,i,r)}removeChild(e){this._physicsPlugin.removeChild(this,e)}getNumChildren(){return this._physicsPlugin.getNumChildren(this)}getBoundingBox(){return this._physicsPlugin.getBoundingBox(this)}set isTrigger(e){this._isTrigger!==e&&(this._isTrigger=e,this._physicsPlugin.setTrigger(this,e))}get isTrigger(){return this._isTrigger}dispose(){this._isDisposed||(this._physicsPlugin.disposeShape(this),this._isDisposed=!0)}}class AP extends Vs{constructor(e,t,i){super({type:0,parameters:{center:e,radius:t}},i)}static FromMesh(e){const t=e.getBoundingInfo(),i=t.boundingSphere.center,r=t.boundingBox.extendSize,s=Math.max(r.x,r.y,r.z);return new AP(i,s,e.getScene())}}class J_ extends Vs{constructor(e,t,i,r){super({type:1,parameters:{pointA:e,pointB:t,radius:i}},r)}static FromMesh(e){const t=e.getBoundingInfo(),i=t.boundingBox.extendSize.x,r=new m(0,t.boundingBox.extendSize.y-i,0),s=t.boundingBox.center.add(r),n=t.boundingBox.center.subtract(r);return new J_(s,n,i,e.getScene())}}class DP extends Vs{constructor(e,t,i,r){super({type:2,parameters:{pointA:e,pointB:t,radius:i}},r)}static FromMesh(e){const t=e.getBoundingInfo(),i=t.boundingBox.extendSize.x,r=new m(0,t.boundingBox.extendSize.y,0),s=t.boundingBox.center.add(r),n=t.boundingBox.center.subtract(r);return new DP(s,n,i,e.getScene())}}class OP extends Vs{constructor(e,t,i,r){super({type:3,parameters:{center:e,rotation:t,extents:i}},r)}static FromMesh(e){const t=e.getBoundingInfo(),i=t.boundingBox.center,r=t.boundingBox.extendSize.scale(2);return new OP(i,re.Identity(),r,e.getScene())}}class r$ extends Vs{constructor(e,t){super({type:4,parameters:{mesh:e}},t)}}class s$ extends Vs{constructor(e,t){super({type:6,parameters:{mesh:e}},t)}}class n$ extends Vs{constructor(e){super({type:5,parameters:{}},e)}}class a$ extends Vs{constructor(e,t,i,r,s,n){super({type:7,parameters:{heightFieldSizeX:e,heightFieldSizeZ:t,numHeightFieldSamplesX:i,numHeightFieldSamplesZ:r,heightFieldData:s}},n)}}class o$ extends Vs{constructor(e,t){super({type:7,parameters:{groundMesh:e}},t)}}var Fv;(function(a){a[a.GEOMETRIC_MEAN=0]="GEOMETRIC_MEAN",a[a.MINIMUM=1]="MINIMUM",a[a.MAXIMUM=2]="MAXIMUM",a[a.ARITHMETIC_MEAN=3]="ARITHMETIC_MEAN",a[a.MULTIPLY=4]="MULTIPLY"})(Fv||(Fv={}));var Lv;(function(a){a[a.UNSUPPORTED=0]="UNSUPPORTED",a[a.SLIDING=1]="SLIDING",a[a.SUPPORTED=2]="SUPPORTED"})(Lv||(Lv={}));var Bv;(function(a){a[a.OK=0]="OK",a[a.FAILURE_3D=1]="FAILURE_3D",a[a.FAILURE_2D=2]="FAILURE_2D"})(Bv||(Bv={}));class dV{}class Ll{copyFrom(e){this.index=e.index,this.constraint=e.constraint,this.interaction=e.interaction}}class fV{constructor(){this.supportPlanes=new Array(4),this.numSupportPlanes=0,this.currentTime=0}getOutput(e){return this.outputInteractions[this.inputConstraints.indexOf(e)]}}function Vv(a,e,t,i,r){const s=a._bodies,n=m.FromArray(e[4]),o=-i*t.dot(n);return{position:m.FromArray(e[3]),normal:n,distance:o,fraction:i,bodyB:s.get(e[0][0]),allowedPenetration:Math.min(Math.max(r-o,0),r)}}class l${constructor(e,t,i){this._orientation=re.Identity(),this._manifold=[],this._contactAngleSensitivity=10,this._tmpMatrix=new $,this._tmpVecs=uu(31,m.Zero),this.keepDistance=.05,this.keepContactTolerance=.1,this.maxCastIterations=10,this.penetrationRecoverySpeed=1,this.staticFriction=0,this.dynamicFriction=1,this.maxSlopeCosine=.5,this.maxCharacterSpeedForSolver=10,this.up=new m(0,1,0),this.characterStrength=1e38,this.acceleration=.05,this.maxAcceleration=50,this.characterMass=0,this._position=e.clone(),this._velocity=m.Zero(),this._lastVelocity=m.Zero();const r=t.capsuleRadius??.6,s=t.capsuleHeight??1.8;this._tmpVecs[0].set(0,s*.5-r,0),this._tmpVecs[1].set(0,-s*.5+r,0),this._shape=t.shape??new J_(this._tmpVecs[0],this._tmpVecs[1],r,i),this._lastInvDeltaTime=1/60,this._lastDisplacement=m.Zero(),this._scene=i;const o=this._scene.getPhysicsEngine().getPhysicsPlugin()._hknp;this._startCollector=o.HP_QueryCollector_Create(16)[1],this._castCollector=o.HP_QueryCollector_Create(16)[1]}getPosition(){return this._position}getVelocity(){return this._velocity}setVelocity(e){this._velocity.copyFrom(e)}_validateManifold(){const e=[];for(let t=0;t<this._manifold.length;t++)this._manifold[t].bodyB.body.isDisposed||e.push(this._manifold[t]);this._manifold=e}_getPointVelocityToRef(e,t,i){const r=this._tmpVecs[10];this._getComWorldToRef(e,r);const s=this._tmpVecs[11];t.subtractToRef(r,s);const n=this._tmpVecs[12];e.body.getAngularVelocityToRef(n,e.index);const o=this._tmpVecs[13];m.CrossToRef(n,s,o),o.addToRef(e.body.getLinearVelocity(e.index),i)}_compareContacts(e,t){const i=(1-e.normal.dot(t.normal))*this._contactAngleSensitivity*this._contactAngleSensitivity,r=(e.distance-t.distance)*(e.distance*t.distance),s=this._tmpVecs[7];this._getPointVelocityToRef(e.bodyB,e.position,s);const n=this._tmpVecs[8];this._getPointVelocityToRef(t.bodyB,t.position,n);const o=this._tmpVecs[9];s.subtractToRef(n,o);const l=o.lengthSquared();return i*10+l*.1+r}_findContact(e,t,i){let r=-1,s=i;for(let n=0;n<t.length;n++){const o=this._compareContacts(e,t[n]);o<s&&(s=o,r=n)}return r}_updateManifold(e,t,i){const r=this._scene.getPhysicsEngine().getPhysicsPlugin(),s=r._hknp,n=s.HP_QueryCollector_GetNumHits(e)[1];if(n>0){const u=[];let c=1e38;const h=r._bodies;for(let f=0;f<n;f++){const[p,,g]=s.HP_QueryCollector_GetShapeProximityResult(e,f)[1];c=Math.min(c,p),u.push({position:m.FromArray(g[3]),normal:m.FromArray(g[4]),distance:p,fraction:0,bodyB:h.get(g[0][0]),allowedPenetration:Math.min(Math.max(this.keepDistance-p,0),this.keepDistance)})}for(let f=this._manifold.length-1;f>=0;f--){const p=this._manifold[f],g=this._findContact(p,u,1.1);if(g>=0){const _=Math.min(Math.max(this.keepDistance-u[g].distance,0),p.allowedPenetration);this._manifold[f]=u[g],this._manifold[f].allowedPenetration=_,u.splice(g,1)}else this._manifold.splice(f,1)}const d=u.findIndex(f=>f.distance==c);if(d>=0){const f=this._findContact(u[d],this._manifold,.1);if(f>=0){const p=Math.min(Math.max(this.keepDistance-u[d].distance,0),this._manifold[f].allowedPenetration);this._manifold[f]=u[d],this._manifold[f].allowedPenetration=p}else this._manifold.push(u[d])}}else this._manifold.length=0;let o=0;const l=s.HP_QueryCollector_GetNumHits(t)[1];if(l>0){let u=null;for(let c=0;c<l;c++){const[h,,d]=s.HP_QueryCollector_GetShapeCastResult(t,c)[1];if(u==null){const f=Vv(r,d,i,h,this.keepDistance);if(u=d[0][0],this._findContact(f,this._manifold,.1)==-1&&this._manifold.push(f),f.bodyB.body.getMotionType(f.bodyB.index)==0)break}else if(u._pluginData&&d[0]!=u._pluginData.hpBodyId){o++;break}}}for(let u=this._manifold.length-1;u>=0;u--){let c=u-1;for(;c>=0&&!(this._compareContacts(this._manifold[u],this._manifold[c])<.1);c--);c>=0&&this._manifold.slice(u,1)}return o}_createSurfaceConstraint(e,t){const i={planeNormal:e.normal.clone(),planeDistance:e.distance,staticFriction:this.staticFriction,dynamicFriction:this.dynamicFriction,extraUpStaticFriction:0,extraDownStaticFriction:0,velocity:m.Zero(),angularVelocity:m.Zero(),priority:0},s=Math.max(this.maxSlopeCosine,.1),n=e.normal.dot(this.up),o=e.position.clone();if(n>s){const c=this.getPosition(),h=this._tmpVecs[20];e.position.subtractToRef(c,h);const d=e.normal.dot(h);o.x=c.x+this.up.x*d,o.y=c.y+this.up.y*d,o.z=c.z+this.up.z*d}const l=e.bodyB.body.getMotionType(e.bodyB.index),u=i.velocity.dot(i.planeNormal)*t;return i.planeDistance-=u,l==0?i.priority=2:l==1&&(i.priority=1),i}_addMaxSlopePlane(e,t,i,r,s){const n=r[i].planeNormal.dot(t);if(n>.01&&n<e){const o={planeNormal:r[i].planeNormal.clone(),planeDistance:r[i].planeDistance,velocity:r[i].velocity.clone(),angularVelocity:r[i].angularVelocity.clone(),priority:r[i].priority,dynamicFriction:r[i].dynamicFriction,staticFriction:r[i].staticFriction,extraDownStaticFriction:r[i].extraDownStaticFriction,extraUpStaticFriction:r[i].extraUpStaticFriction},l=o.planeDistance;if(o.planeNormal.subtractInPlace(t.scale(n)),o.planeNormal.normalize(),l>=0)o.planeDistance=l*o.planeNormal.dot(r[i].planeNormal);else{const u=Math.min(0,l+s);o.planeDistance=u/o.planeNormal.dot(r[i].planeNormal),r[i].planeDistance=0,this._resolveConstraintPenetration(o,this.penetrationRecoverySpeed)}return r.push(o),!0}return!1}_resolveConstraintPenetration(e,t){e.planeDistance<-1e-6&&(e.planeNormal.scaleToRef(e.planeDistance*t,this._tmpVecs[6]),e.velocity.subtractInPlace(this._tmpVecs[6]))}_createConstraintsFromManifold(e,t){const i=[];for(let r=0;r<this._manifold.length;r++){const s=this._createSurfaceConstraint(this._manifold[r],t);i.push(s),this._addMaxSlopePlane(this.maxSlopeCosine,this.up,r,i,this._manifold[r].allowedPenetration),this._resolveConstraintPenetration(s,this.penetrationRecoverySpeed)}return i}_simplexSolverSortInfo(e){for(let t=0;t<e.numSupportPlanes-1;t++)for(let i=t+1;i<e.numSupportPlanes;i++){const r=e.supportPlanes[t],s=e.supportPlanes[i];if(!(r.constraint.priority<s.constraint.priority)){if(r.constraint.priority==s.constraint.priority){const n=r.constraint.velocity.lengthSquared(),o=s.constraint.velocity.lengthSquared();if(n<o)continue}e.supportPlanes[t]=s,e.supportPlanes[i]=r}}}_simplexSolverSolve1d(e,t,i,r){const n=t.velocity,o=this._tmpVecs[22];i.subtractToRef(n,o);const l=o.dot(t.planeNormal),u=o.lengthSquared();o.subtractInPlace(t.planeNormal.scale(l));{const c=l*l,h=o.dot(this.up)>0?t.extraUpStaticFriction:t.extraDownStaticFriction;if(h>0){const d=this.up.cross(t.planeNormal),f=d.lengthSquared();let p=0;if(f>1e-5){d.scaleInPlace(1/Math.sqrt(f)),p=o.dot(d);{const g=p*p,_=t.staticFriction*t.staticFriction;c*_>=g&&(o.subtractInPlace(d.scale(p)),p=0)}}{const g=u-p*p-c,_=(t.staticFriction+h)*(t.staticFriction+h);if(c*_>=g&&p==0){r.copyFrom(n);return}}}else{const d=t.staticFriction*t.staticFriction;if(c*(1+d)>=u){r.copyFrom(n);return}}}if(t.dynamicFriction<1){const c=o.lengthSquared();if(c>=1e-5&&c>1e-4*u){let h=Math.sqrt(u/c);h=t.dynamicFriction+(1-t.dynamicFriction)*h,o.scaleInPlace(h);const d=t.planeNormal.dot(o);o.subtractInPlace(t.planeNormal.scale(d))}}r.copyFrom(o),r.addInPlace(n)}_simplexSolverSolveTest1d(e,t){const i=this._tmpVecs[23];return t.subtractToRef(e.velocity,i),i.dot(e.planeNormal)<-.001}_simplexSolverSolve2d(e,t,i,r,s,n){const l=i.planeNormal.cross(r.planeNormal),u=l.lengthSquared();let c=!1,h=null;for(;;){if(u<=1e-5||c){e.getOutput(i).status=2,e.getOutput(r).status=2,i.priority>r.priority?(this._simplexSolverSolve1d(e,r,s,n),this._simplexSolverSolve1d(e,i,s,n)):(this._simplexSolverSolve1d(e,i,s,n),this._simplexSolverSolve1d(e,r,s,n));return}const v=1/Math.sqrt(u);l.scaleInPlace(v);{const E=i.planeNormal.cross(r.planeNormal),R=r.planeNormal.cross(l),O=l.cross(i.planeNormal),w=i.velocity.add(r.velocity),M=this._tmpVecs[2];M.set(.5*l.dot(w),i.planeNormal.dot(i.velocity),r.planeNormal.dot(r.velocity));const G=$.FromValues(E.x,R.x,O.x,0,E.y,R.y,O.y,0,E.z,R.z,O.z,0,0,0,0,1);if(h=m.TransformNormal(M,G),h.scaleInPlace(v),Math.abs(h.x)>t.x||Math.abs(h.y)>t.y||Math.abs(h.z)>t.z)c=!0;else break}}const d=h,f=this._tmpVecs[24];s.subtractToRef(d,f);const p=f.lengthSquared(),g=this.up.dot(l);let _=f.dot(l),S=i.staticFriction+r.staticFriction;g*_>0?S+=(i.extraUpStaticFriction+r.extraUpStaticFriction)*g:S+=(i.extraDownStaticFriction+r.extraDownStaticFriction)*g,S*=.5;const b=(i.dynamicFriction+r.dynamicFriction)*.5,y=S*S,T=_*_;if((p-T)*y>=T){n.copyFrom(d);return}if(b<1&&_*_>1e-4*p){const v=1/_,E=Math.abs(v)*Math.sqrt(p)*(1-b)+b;_*=E}n.copyFrom(d),n.addInPlace(l.scale(_))}_simplexSolverSolve3d(e,t,i,r,s,n,o,l){let c=null;{const h=r.planeNormal.cross(s.planeNormal),d=s.planeNormal.cross(i.planeNormal),f=i.planeNormal.cross(r.planeNormal),p=h.dot(i.planeNormal);let g=!1;for(;;){if(Math.abs(p)<1e-5||g){n&&(this._simplexSolverSortInfo(e),i=e.supportPlanes[0].constraint,r=e.supportPlanes[1].constraint,s=e.supportPlanes[2].constraint),e.getOutput(i).status=1,e.getOutput(r).status=1,e.getOutput(s).status=1;const b=e.numSupportPlanes;this._simplexSolverSolve2d(e,t,i,r,o,l),b==e.numSupportPlanes&&this._simplexSolverSolve2d(e,t,i,s,o,l),b==e.numSupportPlanes&&this._simplexSolverSolve2d(e,t,r,s,o,l);return}const _=this._tmpVecs[2];_.set(i.planeNormal.dot(i.velocity),r.planeNormal.dot(r.velocity),s.planeNormal.dot(s.velocity));const S=$.FromValues(h.x,h.y,h.z,0,d.x,d.y,d.z,0,f.x,f.y,f.z,0,0,0,0,1);if(c=m.TransformNormal(_,S),c.scaleInPlace(1/p),Math.abs(c.x)>t.x||Math.abs(c.y)>t.y||Math.abs(c.z)>t.z)g=!0;else break}}l.copyFrom(c)}_simplexSolverExamineActivePlanes(e,t,i,r){for(;;)switch(e.numSupportPlanes){case 1:{const s=e.supportPlanes[0].constraint;this._simplexSolverSolve1d(e,s,i,r);return}case 2:{const s=m.Zero();this._simplexSolverSolve1d(e,e.supportPlanes[1].constraint,i,s),this._simplexSolverSolveTest1d(e.supportPlanes[0].constraint,s)?this._simplexSolverSolve2d(e,t,e.supportPlanes[0].constraint,e.supportPlanes[1].constraint,i,r):(e.supportPlanes[0].copyFrom(e.supportPlanes[1]),e.numSupportPlanes=1,r.copyFrom(s));return}case 3:{{const s=m.Zero();if(this._simplexSolverSolve1d(e,e.supportPlanes[2].constraint,i,r),!this._simplexSolverSolveTest1d(e.supportPlanes[0].constraint,s)&&!this._simplexSolverSolveTest1d(e.supportPlanes[1].constraint,s)){r.copyFrom(s),e.supportPlanes[0].copyFrom(e.supportPlanes[2]),e.numSupportPlanes=1;continue}}{let s=!1;for(let n=0;n<2;n++){const o=m.Zero();if(this._simplexSolverSolve2d(e,t,e.supportPlanes[n].constraint,e.supportPlanes[2].constraint,i,r),!this._simplexSolverSolveTest1d(e.supportPlanes[1-n].constraint,o)){e.supportPlanes[0].copyFrom(e.supportPlanes[n]),e.supportPlanes[1].copyFrom(e.supportPlanes[2]),e.numSupportPlanes--,s=!0;break}}if(s)continue}this._simplexSolverSolve3d(e,t,e.supportPlanes[0].constraint,e.supportPlanes[1].constraint,e.supportPlanes[2].constraint,!0,i,r);return}case 4:{this._simplexSolverSortInfo(e);let s=!1;for(let n=0;n<3;n++){const o=m.Zero();if(this._simplexSolverSolve3d(e,t,e.supportPlanes[(n+1)%3].constraint,e.supportPlanes[(n+2)%3].constraint,e.supportPlanes[3].constraint,!1,i,o),!this._simplexSolverSolveTest1d(e.supportPlanes[n].constraint,o)){e.supportPlanes[n].copyFrom(e.supportPlanes[2]),e.supportPlanes[2].copyFrom(e.supportPlanes[3]),e.numSupportPlanes=3,s=!0;break}}if(s)continue;{const n=i.clone(),o=e.supportPlanes[0].constraint,l=e.supportPlanes[1].constraint,u=e.supportPlanes[2].constraint,c=e.supportPlanes[3].constraint,h=e.numSupportPlanes;h==e.numSupportPlanes?this._simplexSolverSolve3d(e,t,o,l,u,!1,n,n):h==e.numSupportPlanes?this._simplexSolverSolve3d(e,t,o,l,c,!1,n,n):h==e.numSupportPlanes?this._simplexSolverSolve3d(e,t,o,u,c,!1,n,n):h==e.numSupportPlanes&&this._simplexSolverSolve3d(e,t,l,u,c,!1,n,n),r.copyFrom(n)}{let n=0;for(let l=0;l<4;l++)n=Math.max(n,e.supportPlanes[l].interaction.status);let o=0;for(;o<4;o++){if(n==e.supportPlanes[o].interaction.status){e.supportPlanes[o].copyFrom(e.supportPlanes[3]);break}e.numSupportPlanes--}}for(let n=0;n<3;n++)e.supportPlanes[n].interaction.status=0;continue}}}_simplexSolverSolve(e,t,i,r,s,n){const l=new dV;l.position=m.Zero(),l.velocity=t.clone(),l.planeInteractions=[];let u=i;for(let h=0;h<e.length;h++)l.planeInteractions.push({touched:!1,stopped:!1,surfaceTime:0,penaltyDistance:0,status:0});const c=new fV;for(c.inputConstraints=e,c.outputInteractions=l.planeInteractions,c.supportPlanes[0]=new Ll,c.supportPlanes[1]=new Ll,c.supportPlanes[2]=new Ll,c.supportPlanes[3]=new Ll;u>0;){let h=-1,d=u;for(let g=0;g<e.length;g++){if(c.numSupportPlanes>=1&&c.supportPlanes[0].index==g||c.numSupportPlanes>=2&&c.supportPlanes[1].index==g||c.numSupportPlanes>=3&&c.supportPlanes[2].index==g||l.planeInteractions[g].status!=0)continue;const _=e[g],S=this._tmpVecs[25];l.velocity.subtractToRef(_.velocity,S);const b=-S.dot(_.planeNormal);if(b<=0)continue;const y=this._tmpVecs[26];_.velocity.scaleToRef(c.currentTime,this._tmpVecs[27]),l.position.subtractToRef(this._tmpVecs[27],y);let T=_.planeNormal.dot(y);const v=l.planeInteractions[g].penaltyDistance;v<1e-6&&(T=0),T+=v,T<d*b&&(d=T/b,h=g)}if(d>1e-4){c.currentTime+=d,u-=d,l.position.addInPlace(l.velocity.scale(d));for(let g=0;g<c.numSupportPlanes;g++)c.supportPlanes[g].interaction.surfaceTime+=d,c.supportPlanes[g].interaction.touched=!0;if(l.deltaTime=c.currentTime,c.currentTime>r)return l}if(h<0){l.deltaTime=i;break}const p=c.supportPlanes[c.numSupportPlanes++];p.constraint=e[h],p.interaction=l.planeInteractions[h],p.interaction.penaltyDistance=(p.interaction.penaltyDistance+1e-6)*2,p.index=h,this._simplexSolverExamineActivePlanes(c,n,t,l.velocity)}return l}checkSupport(e,t){const i={isSurfaceDynamic:!1,supportedState:0,averageSurfaceNormal:m.Zero(),averageSurfaceVelocity:m.Zero(),averageAngularSurfaceVelocity:m.Zero()};return this.checkSupportToRef(e,t,i),i}checkSupportToRef(e,t,i){this._validateManifold();const s=this._createConstraintsFromManifold(e,0),n=[];for(let c=0;c<s.length;c++)n.push(s[c].velocity.clone()),s[c].velocity.setAll(0);const o=this._tmpVecs[3];o.set(this.maxCharacterSpeedForSolver,this.maxCharacterSpeedForSolver,this.maxCharacterSpeedForSolver);const l=this._simplexSolverSolve(s,t,e,e,this.up,o);if(i.averageSurfaceVelocity.setAll(0),i.averageAngularSurfaceVelocity.setAll(0),i.averageSurfaceNormal.setAll(0),i.isSurfaceDynamic=!1,l.velocity.equalsWithEpsilon(t,1e-4)){i.supportedState=0;return}if(l.velocity.lengthSquared()<1e-4)i.supportedState=2;else{l.velocity.normalize();const c=l.velocity.dot(t);1-c*c<this.maxSlopeCosine*this.maxSlopeCosine?i.supportedState=1:i.supportedState=2}let u=0;for(let c=-0;c<s.length;c++)l.planeInteractions[c].touched&&s[c].planeNormal.dot(t)<-.08&&(i.averageSurfaceNormal.addInPlace(s[c].planeNormal),i.averageSurfaceVelocity.addInPlace(n[c]),i.averageAngularSurfaceVelocity.addInPlace(s[c].angularVelocity),u++);if(u>0&&(i.averageSurfaceNormal.normalize(),i.averageSurfaceVelocity.scaleInPlace(1/u),i.averageAngularSurfaceVelocity.scaleInPlace(1/u)),i.supportedState==2)for(let c=0;c<this._manifold.length;c++){const d=this._manifold[c].bodyB;if(this._manifold[c].normal.dot(t)<-.08&&d.body.getMotionType(0)==2){i.isSurfaceDynamic=!0;break}}}_castWithCollectors(e,t,i,r){const s=this._scene.getPhysicsEngine().getPhysicsPlugin(),n=s._hknp,o=[e.x,e.y,e.z],l=[this._orientation.x,this._orientation.y,this._orientation.z,this._orientation.w];if(r!=null){const u=[this._shape._pluginData,o,l,this.keepDistance+this.keepContactTolerance,!1,[BigInt(0)]];n.HP_World_ShapeProximityWithCollector(s.world,r,u)}{const u=[this._shape._pluginData,l,o,[t.x,t.y,t.z],!1,[BigInt(0)]];n.HP_World_ShapeCastWithCollector(s.world,i,u)}}_resolveContacts(e,t){for(let i=0;i<this._manifold.length;i++){const r=this._manifold[i],s=this._manifold[i].bodyB;if(s.body.getMotionType(s.index)==2){let n=0,o=0,l=m.Zero();const u=r.position,c=this._tmpVecs[19];this._getPointVelocityToRef(s,r.position,c),c.subtractInPlace(this._velocity);const h=c.dot(r.normal);let f=-h*.9;if(r.distance<0&&(f+=r.distance*.4/e),f<0){const p=this._getInverseInertiaWorld(s),g=this._tmpVecs[15];this._getComWorldToRef(s,g);const _=this._tmpVecs[16];r.position.subtractToRef(g,_);const S=this._tmpVecs[17];m.CrossToRef(_,r.normal,S);const b=this._tmpVecs[18];m.TransformNormalToRef(S,p,b),n=b.dot(S)+this._getInvMass(s),o=f/n;const y=-this.characterStrength*e;o<y&&(o=y),l=r.normal.scale(o)}else o=0,n=this._getInvMass(s);{let p=r.normal.dot(t.scale(e));h<0&&(p-=h),p<-1e-12&&l.addInPlace(r.normal.scale(this.characterMass*p))}s.body.applyImpulse(l,u,s.index)}}}_getInverseInertiaWorld(e){const t=e.body.getMassProperties(e.index);if(!t.inertia||!t.inertiaOrientation)return $.IdentityReadOnly;const i=$.FromQuaternionToRef(t.inertiaOrientation,V.Matrix[0]).invert(),r=V.Matrix[1],s=i.getRowToRef(0,V.Vector4[0]);return r.setRowFromFloats(0,t.inertia.x*s.x,t.inertia.x*s.y,t.inertia.x*s.z,0),i.getRowToRef(1,s),r.setRowFromFloats(0,t.inertia.y*s.x,t.inertia.y*s.y,t.inertia.y*s.z,0),i.getRowToRef(2,s),r.setRowFromFloats(0,t.inertia.z*s.x,t.inertia.z*s.y,t.inertia.z*s.z,0),i.multiplyToRef(r,this._tmpMatrix),this._tmpMatrix}_getComWorldToRef(e,t){const i=e.body.getMassProperties(e.index);m.TransformCoordinatesToRef(i.centerOfMass,e.body.transformNode.getWorldMatrix(),t)}_getInvMass(e){return 1/e.body.getMassProperties(e.index).mass}integrate(e,t,i){const r=this._scene.getPhysicsEngine().getPhysicsPlugin(),s=1/e;let n=e,o=m.Zero();const l=1e-4,u=1e-8;{const c=l*s;if(this._velocity.equalsWithEpsilon(this._lastVelocity,c))this._lastDisplacement.scaleInPlace(n*this._lastInvDeltaTime);else{const h=this._velocity;if(t.supportedState==2){const d=this._tmpVecs[28];this._velocity.subtractToRef(t.averageSurfaceVelocity,d);const f=t.averageSurfaceNormal.dot(d);f<0&&(d.subtractInPlace(t.averageSurfaceNormal.scale(f)),h.copyFrom(d),h.addInPlace(t.averageSurfaceVelocity))}this._lastDisplacement.copyFrom(h),this._lastDisplacement.scaleInPlace(n)}this._lastVelocity.copyFrom(this._velocity),this._lastInvDeltaTime=s}this._validateManifold();for(let c=0;c<this.maxCastIterations&&n>1e-5;c++){this._castWithCollectors(this._position,this._position.add(this._lastDisplacement),this._castCollector,this._startCollector);const h=this._updateManifold(this._startCollector,this._castCollector,this._lastDisplacement),d=this._createConstraintsFromManifold(e,e-n),f=this._tmpVecs[3];f.set(this.maxCharacterSpeedForSolver,this.maxCharacterSpeedForSolver,this.maxCharacterSpeedForSolver);const p=this._velocity.lengthSquared()==0?0:.5*this.keepDistance/this._velocity.length(),g=this._simplexSolverSolve(d,this._velocity,n,p,this.up,f),_=g.position,S=g.deltaTime;o=g.velocity,this._resolveContacts(e,i);let b=-1;if(h!=0||_.lengthSquared()>u&&!this._lastDisplacement.equalsWithEpsilon(_,l)){this._castWithCollectors(this._position,this._position.add(_),this._castCollector,this._startCollector);const y=r._hknp,T=y.HP_QueryCollector_GetNumHits(this._castCollector)[1];if(T>0)for(let v=0;v<T;v++){const[E,R,O]=y.HP_QueryCollector_GetShapeCastResult(this._castCollector,v)[1],w=Vv(r,O,_,E,this.keepDistance);if(this._findContact(w,this._manifold,.1)==-1){b=this._manifold.length,this._manifold.push(w);break}}}if(b>=0){const y=this._manifold[b],T=1/_.length(),v=_.dot(y.normal)*T,E=this.keepDistance/-v;let O=y.fraction-E*T;O=Math.min(Math.max(O,0),1);const w=_.scale(O);this._position.addInPlace(w),n-=S*O}else this._position.addInPlace(_),n-=S;this._lastDisplacement.copyFrom(_)}this._velocity.copyFrom(o)}calculateMovementToRef(e,t,i,r,s,n,o,l){let c=t.cross(o);if(c.lengthSquared()<1e-5)return!1;c.normalize();const h=c.cross(i);h.normalize(),c=h.cross(i),c.normalize();const d=$.FromValues(h.x,h.y,h.z,0,c.x,c.y,c.z,0,i.x,i.y,i.z,0,0,0,0,1),f=d.clone().invert();r.subtractToRef(s,this._tmpVecs[29]);const p=this._tmpVecs[30];m.TransformNormalToRef(this._tmpVecs[29],f,p);const g=o.cross(t),_=n.dot(t),S=n.dot(g),b=n.length(),y=this._tmpVecs[4];y.set(-_,S,0),y.normalize(),y.scaleInPlace(b);const T=this._tmpVecs[5];y.subtractToRef(p,T);{const v=T.lengthSquared(),E=this.maxAcceleration*e;let R;v*this.acceleration*this.acceleration>E*E?R=E/Math.sqrt(v):R=this.acceleration,T.scaleInPlace(R)}return p.addInPlace(T),m.TransformNormalToRef(p,d,l),l.addInPlace(s),!0}calculateMovement(e,t,i,r,s,n,o){const l=new m(0,0,0);return this.calculateMovementToRef(e,t,i,r,s,n,o,l),l}}Te.prototype.getPhysicsEngine=function(){return this._physicsEngine};Te.prototype.enablePhysics=function(a=null,e){if(this._physicsEngine)return!0;let t=this._getComponent(ge.NAME_PHYSICSENGINE);t||(t=new pV(this),this._addComponent(t));try{if(!e||(e==null?void 0:e.getPluginVersion())===1)this._physicsEngine=new DT(a,e);else if((e==null?void 0:e.getPluginVersion())===2)this._physicsEngine=new K_(a,e);else throw new Error("Unsupported Physics plugin version.");return this._physicsTimeAccumulator=0,!0}catch(i){return L.Error(i.message),!1}};Te.prototype.disablePhysicsEngine=function(){this._physicsEngine&&(this._physicsEngine.dispose(),this._physicsEngine=null)};Te.prototype.isPhysicsEnabled=function(){return this._physicsEngine!==void 0};Te.prototype.deleteCompoundImpostor=function(a){const e=a.parts[0].mesh;e.physicsImpostor&&(e.physicsImpostor.dispose(),e.physicsImpostor=null)};Te.prototype._advancePhysicsEngineStep=function(a){if(this._physicsEngine){const e=this._physicsEngine.getSubTimeStep();if(e>0)for(this._physicsTimeAccumulator+=a;this._physicsTimeAccumulator>e;)this.onBeforePhysicsObservable.notifyObservers(this),this._physicsEngine._step(e/1e3),this.onAfterPhysicsObservable.notifyObservers(this),this._physicsTimeAccumulator-=e;else this.onBeforePhysicsObservable.notifyObservers(this),this._physicsEngine._step(a/1e3),this.onAfterPhysicsObservable.notifyObservers(this)}};class pV{constructor(e){this.name=ge.NAME_PHYSICSENGINE,this.scene=e,this.scene.onBeforePhysicsObservable=new j,this.scene.onAfterPhysicsObservable=new j,this.scene.getDeterministicFrameTime=()=>this.scene._physicsEngine?this.scene._physicsEngine.getTimeStep()*1e3:1e3/60}register(){}rebuild(){}dispose(){this.scene.onBeforePhysicsObservable.clear(),this.scene.onAfterPhysicsObservable.clear(),this.scene._physicsEngine&&this.scene.disablePhysicsEngine()}}Object.defineProperty(Bi.prototype,"physicsBody",{get:function(){return this._physicsBody},set:function(a){this._physicsBody!==a&&(this._disposePhysicsObserver&&this.onDisposeObservable.remove(this._disposePhysicsObserver),this._physicsBody=a,a&&(this._disposePhysicsObserver=this.onDisposeObservable.add(()=>{this.physicsBody&&(this.physicsBody.dispose(),this.physicsBody=null)})))},enumerable:!0,configurable:!0});Bi.prototype.getPhysicsBody=function(){return this.physicsBody};Bi.prototype.applyImpulse=function(a,e){if(!this.physicsBody)throw new Error("No Physics Body for TransformNode");return this.physicsBody.applyImpulse(a,e),this};Bi.prototype.applyAngularImpulse=function(a){if(!this.physicsBody)throw new Error("No Physics Body for TransformNode");return this.physicsBody.applyAngularImpulse(a),this};class kn{static GetContactPointToRef(e,t,i,r,s){const n=e.getScene().getPhysicsEngine(),o=n==null?void 0:n.getPluginVersion();if(o===1){const u=new Zt(t,i).intersectsMesh(e);if(u.hit&&u.pickedPoint)return r.copyFrom(u.pickedPoint),!0}else if(o===2)return e.physicsBody.getObjectCenterWorldToRef(r,s),!0;return!1}static HasAppliedForces(e,t){var i,r;return e.getMotionType(t)===0||(((i=e.getMassProperties(t))==null?void 0:i.mass)??0)===0||((r=e.transformNode)==null?void 0:r.getTotalVertices())===0}static IsInsideCylinder(e,t,i,r){const s=V.Vector3[0];return e.subtractToRef(t,s),Math.abs(s.x)<=i&&Math.abs(s.z)<=i&&s.y>=0&&s.y<=r}}class u${constructor(e){if(this._hitData={force:new m,contactPoint:new m,distanceFromOrigin:0},this._scene=e,this._physicsEngine=this._scene.getPhysicsEngine(),!this._physicsEngine){L.Warn("Physics engine not enabled. Please enable the physics before you can use the methods.");return}}applyRadialExplosionImpulse(e,t,i,r){if(!this._physicsEngine)return L.Warn("Physics engine not enabled. Please enable the physics before you call this method."),null;if(this._physicsEngine.getPluginVersion()===1&&this._physicsEngine.getImpostors().length===0||this._physicsEngine.getPluginVersion()===2&&this._physicsEngine.getBodies().length===0)return null;let s=!1;if(typeof t=="number"){const l=t;t=new bo,t.radius=l,t.strength=i??t.strength,t.falloff=r??t.falloff}else s=!!(t.affectedImpostorsCallback||t.affectedBodiesCallback);const n=new kv(this._scene,t),o=this._hitData;if(this._physicsEngine.getPluginVersion()===1){const l=Array();this._physicsEngine.getImpostors().forEach(c=>{n.getImpostorHitData(c,e,o)&&(c.applyImpulse(o.force,o.contactPoint),s&&l.push({impostor:c,hitData:this._copyPhysicsHitData(o)}))}),n.triggerAffectedImpostorsCallback(l)}else this._applicationForBodies(n,e,o,s,(l,u)=>{l.applyImpulse(u.force,u.contactPoint,u.instanceIndex)});return n.dispose(!1),n}applyRadialExplosionForce(e,t,i,r){if(!this._physicsEngine)return L.Warn("Physics engine not enabled. Please enable the physics before you call the PhysicsHelper."),null;if(this._physicsEngine.getPluginVersion()===1&&this._physicsEngine.getImpostors().length===0||this._physicsEngine.getPluginVersion()===2&&this._physicsEngine.getBodies().length===0)return null;let s=!1;if(typeof t=="number"){const l=t;t=new bo,t.radius=l,t.strength=i??t.strength,t.falloff=r??t.falloff}else s=!!(t.affectedImpostorsCallback||t.affectedBodiesCallback);const n=new kv(this._scene,t),o=this._hitData;if(this._physicsEngine.getPluginVersion()===1){const l=Array();this._physicsEngine.getImpostors().forEach(c=>{n.getImpostorHitData(c,e,o)&&(c.applyForce(o.force,o.contactPoint),s&&l.push({impostor:c,hitData:this._copyPhysicsHitData(o)}))}),n.triggerAffectedImpostorsCallback(l)}else this._applicationForBodies(n,e,o,s,(l,u)=>{l.applyForce(u.force,u.contactPoint,u.instanceIndex)});return n.dispose(!1),n}_applicationForBodies(e,t,i,r,s){const n=Array(),o=this._physicsEngine.getBodies();for(const l of o)l.iterateOverAllInstances((u,c)=>{e.getBodyHitData(u,t,i,c)&&(s(u,i),r&&n.push({body:u,hitData:this._copyPhysicsHitData(i)}))});e.triggerAffectedBodiesCallback(n)}gravitationalField(e,t,i,r){if(!this._physicsEngine)return L.Warn("Physics engine not enabled. Please enable the physics before you call the PhysicsHelper."),null;if(this._physicsEngine.getPluginVersion()===1&&this._physicsEngine.getImpostors().length===0||this._physicsEngine.getPluginVersion()===2&&this._physicsEngine.getBodies().length===0)return null;if(typeof t=="number"){const n=t;t=new bo,t.radius=n,t.strength=i??t.strength,t.falloff=r??t.falloff}const s=new mV(this,this._scene,e,t);return s.dispose(!1),s}updraft(e,t,i,r,s){if(!this._physicsEngine)return L.Warn("Physics engine not enabled. Please enable the physics before you call the PhysicsHelper."),null;if(this._physicsEngine.getPluginVersion()===1&&this._physicsEngine.getImpostors().length===0||this._physicsEngine.getPluginVersion()===2&&this._physicsEngine.getBodies().length===0)return null;if(typeof t=="number"){const o=t;t=new wP,t.radius=o,t.strength=i??t.strength,t.height=r??t.height,t.updraftMode=s??t.updraftMode}const n=new dc(this._scene,e,t);return n.dispose(!1),n}vortex(e,t,i,r){if(!this._physicsEngine)return L.Warn("Physics engine not enabled. Please enable the physics before you call the PhysicsHelper."),null;if(this._physicsEngine.getPluginVersion()===1&&this._physicsEngine.getImpostors().length===0||this._physicsEngine.getPluginVersion()===2&&this._physicsEngine.getBodies().length===0)return null;if(typeof t=="number"){const n=t;t=new NP,t.radius=n,t.strength=i??t.strength,t.height=r??t.height}const s=new ja(this._scene,e,t);return s.dispose(!1),s}_copyPhysicsHitData(e){return{force:e.force.clone(),contactPoint:e.contactPoint.clone(),distanceFromOrigin:e.distanceFromOrigin,instanceIndex:e.instanceIndex}}}class kv{constructor(e,t){this._scene=e,this._options=t,this._dataFetched=!1,this._options={...new bo,...this._options}}getData(){return this._dataFetched=!0,{sphere:this._sphere}}_getHitData(e,t,i,r){const s=V.Vector3[0];s.copyFrom(t).subtractInPlace(i);const n=V.Vector3[1];if(!kn.GetContactPointToRef(e,i,s,n,r.instanceIndex))return!1;const l=m.Distance(i,n);if(l>this._options.radius)return!1;const u=this._options.falloff===0?this._options.strength:this._options.strength*(1-l/this._options.radius);return s.scaleInPlace(u),r.force.copyFrom(s),r.contactPoint.copyFrom(n),r.distanceFromOrigin=l,!0}getBodyHitData(e,t,i,r){if(kn.HasAppliedForces(e,r))return!1;const s=e.transformNode,n=e.getObjectCenterWorld(r);return i.instanceIndex=r,this._getHitData(s,n,t,i)}getImpostorHitData(e,t,i){if(e.mass===0||e.object.getClassName()!=="Mesh"&&e.object.getClassName()!=="InstancedMesh")return!1;const r=e.object;if(!this._intersectsWithSphere(r,t,this._options.radius))return!1;const s=e.getObjectCenter();return this._getHitData(r,s,t,i),!0}triggerAffectedImpostorsCallback(e){this._options.affectedImpostorsCallback&&this._options.affectedImpostorsCallback(e)}triggerAffectedBodiesCallback(e){this._options.affectedBodiesCallback&&this._options.affectedBodiesCallback(e)}dispose(e=!0){this._sphere&&(e?this._sphere.dispose():setTimeout(()=>{this._dataFetched||this._sphere.dispose()},0))}_prepareSphere(){this._sphere||(this._sphere=Ti("radialExplosionEventSphere",this._options.sphere,this._scene),this._sphere.isVisible=!1)}_intersectsWithSphere(e,t,i){return this._prepareSphere(),this._sphere.position=t,this._sphere.scaling.setAll(i*2),this._sphere._updateBoundingInfo(),this._sphere.computeWorldMatrix(!0),this._sphere.intersectsMesh(e,!0)}}class mV{constructor(e,t,i,r){this._physicsHelper=e,this._scene=t,this._origin=i,this._options=r,this._dataFetched=!1,this._options={...new bo,...this._options},this._tickCallback=()=>this._tick(),this._options.strength=this._options.strength*-1}getData(){return this._dataFetched=!0,{sphere:this._sphere}}enable(){this._tickCallback.call(this),this._scene.registerBeforeRender(this._tickCallback)}disable(){this._scene.unregisterBeforeRender(this._tickCallback)}dispose(e=!0){this._sphere&&(e?this._sphere.dispose():setTimeout(()=>{this._dataFetched||this._sphere.dispose()},0))}_tick(){var e;if(this._sphere)this._physicsHelper.applyRadialExplosionForce(this._origin,this._options);else{const t=this._physicsHelper.applyRadialExplosionForce(this._origin,this._options);t&&(this._sphere=(e=t.getData().sphere)==null?void 0:e.clone("radialExplosionEventSphereClone"))}}}class dc{constructor(e,t,i){this._scene=e,this._origin=t,this._options=i,this._originTop=m.Zero(),this._originDirection=m.Zero(),this._cylinderPosition=m.Zero(),this._dataFetched=!1,this._physicsEngine=this._scene.getPhysicsEngine(),this._options={...new wP,...this._options},this._origin.addToRef(new m(0,this._options.height/2,0),this._cylinderPosition),this._origin.addToRef(new m(0,this._options.height,0),this._originTop),this._options.updraftMode===1&&(this._originDirection=this._origin.subtract(this._originTop).normalize()),this._tickCallback=()=>this._tick(),this._physicsEngine.getPluginVersion()===1&&this._prepareCylinder()}getData(){return this._dataFetched=!0,{cylinder:this._cylinder}}enable(){this._tickCallback.call(this),this._scene.registerBeforeRender(this._tickCallback)}disable(){this._scene.unregisterBeforeRender(this._tickCallback)}dispose(e=!0){this._cylinder&&(e?(this._cylinder.dispose(),this._cylinder=void 0):setTimeout(()=>{!this._dataFetched&&this._cylinder&&(this._cylinder.dispose(),this._cylinder=void 0)},0))}_getHitData(e,t){let i;this._options.updraftMode===1?i=this._originDirection:i=e.subtract(this._originTop);const r=m.Distance(this._origin,e),s=this._options.strength*-1,n=i.multiplyByFloats(s,s,s);t.force.copyFrom(n),t.contactPoint.copyFrom(e),t.distanceFromOrigin=r}_getBodyHitData(e,t,i){if(kn.HasAppliedForces(e))return!1;const r=e.getObjectCenterWorld(i);return kn.IsInsideCylinder(r,this._origin,this._options.radius,this._options.height)?(t.instanceIndex=i,this._getHitData(r,t),!0):!1}_getImpostorHitData(e,t){if(e.mass===0)return!1;const i=e.object;if(!this._intersectsWithCylinder(i))return!1;const r=e.getObjectCenter();return this._getHitData(r,t),!0}_tick(){const e=dc._HitData;this._physicsEngine.getPluginVersion()===1?this._physicsEngine.getImpostors().forEach(t=>{this._getImpostorHitData(t,e)&&t.applyForce(e.force,e.contactPoint)}):this._physicsEngine.getBodies().forEach(t=>{t.iterateOverAllInstances((i,r)=>{this._getBodyHitData(i,e,r)&&i.applyForce(e.force,e.contactPoint,e.instanceIndex)})})}_prepareCylinder(){this._cylinder||(this._cylinder=tr("updraftEventCylinder",{height:this._options.height,diameter:this._options.radius*2},this._scene),this._cylinder.isVisible=!1)}_intersectsWithCylinder(e){return this._cylinder?(this._cylinder.position=this._cylinderPosition,this._cylinder.intersectsMesh(e,!0)):!1}}dc._HitData={force:new m,contactPoint:new m,distanceFromOrigin:0};class ja{constructor(e,t,i){this._scene=e,this._origin=t,this._options=i,this._originTop=m.Zero(),this._cylinderPosition=m.Zero(),this._dataFetched=!1,this._physicsEngine=this._scene.getPhysicsEngine(),this._options={...new NP,...this._options},this._origin.addToRef(new m(0,this._options.height/2,0),this._cylinderPosition),this._origin.addToRef(new m(0,this._options.height,0),this._originTop),this._tickCallback=()=>this._tick(),this._physicsEngine.getPluginVersion()===1&&this._prepareCylinder()}getData(){return this._dataFetched=!0,{cylinder:this._cylinder}}enable(){this._tickCallback.call(this),this._scene.registerBeforeRender(this._tickCallback)}disable(){this._scene.unregisterBeforeRender(this._tickCallback)}dispose(e=!0){this._cylinder&&(e?this._cylinder.dispose():setTimeout(()=>{this._dataFetched||this._cylinder.dispose()},0))}_getHitData(e,t,i){const r=ja._OriginOnPlane;r.set(this._origin.x,t.y,this._origin.z);const s=V.Vector3[0];t.subtractToRef(r,s);const n=V.Vector3[1];if(!kn.GetContactPointToRef(e,r,s,n,i.instanceIndex))return!1;const u=m.Distance(n,r)/this._options.radius,c=V.Vector3[2];n.normalizeToRef(c),u>this._options.centripetalForceThreshold&&c.negateInPlace();let h,d,f;if(u>this._options.centripetalForceThreshold)h=c.x*this._options.centripetalForceMultiplier,d=c.y*this._options.updraftForceMultiplier,f=c.z*this._options.centripetalForceMultiplier;else{const g=m.Cross(r,t).normalize();h=(g.x+c.x)*this._options.centrifugalForceMultiplier,d=this._originTop.y*this._options.updraftForceMultiplier,f=(g.z+c.z)*this._options.centrifugalForceMultiplier}const p=V.Vector3[3];return p.set(h,d,f),p.scaleInPlace(this._options.strength),i.force.copyFrom(p),i.contactPoint.copyFrom(t),i.distanceFromOrigin=u,!0}_getBodyHitData(e,t,i){if(kn.HasAppliedForces(e,i))return!1;const r=e.transformNode,s=e.getObjectCenterWorld(i);return kn.IsInsideCylinder(s,this._origin,this._options.radius,this._options.height)?(t.instanceIndex=i,this._getHitData(r,s,t)):!1}_getImpostorHitData(e,t){if(e.mass===0||e.object.getClassName()!=="Mesh"&&e.object.getClassName()!=="InstancedMesh")return!1;const i=e.object;if(!this._intersectsWithCylinder(i))return!1;const r=e.getObjectCenter();return this._getHitData(i,r,t),!0}_tick(){const e=ja._HitData;this._physicsEngine.getPluginVersion()===1?this._physicsEngine.getImpostors().forEach(t=>{this._getImpostorHitData(t,e)&&t.applyForce(e.force,e.contactPoint)}):this._physicsEngine.getBodies().forEach(t=>{t.iterateOverAllInstances((i,r)=>{this._getBodyHitData(i,e,r)&&i.applyForce(e.force,e.contactPoint,e.instanceIndex)})})}_prepareCylinder(){this._cylinder||(this._cylinder=tr("vortexEventCylinder",{height:this._options.height,diameter:this._options.radius*2},this._scene),this._cylinder.isVisible=!1)}_intersectsWithCylinder(e){return this._cylinder.position=this._cylinderPosition,this._cylinder.intersectsMesh(e,!0)}}ja._OriginOnPlane=m.Zero();ja._HitData={force:new m,contactPoint:new m,distanceFromOrigin:0};class bo{constructor(){this.radius=5,this.strength=10,this.falloff=0,this.sphere={segments:32,diameter:1}}}class wP{constructor(){this.radius=5,this.strength=10,this.height=10,this.updraftMode=0}}class NP{constructor(){this.radius=5,this.strength=10,this.height=10,this.centripetalForceThreshold=.7,this.centripetalForceMultiplier=5,this.centrifugalForceMultiplier=.5,this.updraftForceMultiplier=.02}}var zv;(function(a){a[a.Constant=0]="Constant",a[a.Linear=1]="Linear"})(zv||(zv={}));var Uv;(function(a){a[a.Center=0]="Center",a[a.Perpendicular=1]="Perpendicular"})(Uv||(Uv={}));class fc extends Ce{get degree(){return this._effectWrapper.degree}set degree(e){this._effectWrapper.degree=e}getClassName(){return"BlackAndWhitePostProcess"}constructor(e,t,i=null,r,s,n){const o={uniforms:os.Uniforms,size:typeof t=="number"?t:void 0,camera:i,samplingMode:r,engine:s,reusable:n,...t};super(e,os.FragmentUrl,{effectWrapper:typeof t=="number"||!t.effectWrapper?new os(e,s,o):void 0,...o})}static _Parse(e,t,i,r){return Me.Parse(()=>new fc(e.name,e.options,t,e.renderTargetSamplingMode,i.getEngine(),e.reusable),e,i,r)}}C([F()],fc.prototype,"degree",null);B("BABYLON.BlackAndWhitePostProcess",fc);class Xe{constructor(e,t,i,r){this._name=t,this._singleInstance=r||!0,this._getPostProcesses=i,this._cameras={},this._indicesForCamera={},this._postProcesses={}}get isSupported(){for(const e in this._postProcesses)if(Object.prototype.hasOwnProperty.call(this._postProcesses,e)){const t=this._postProcesses[e];for(let i=0;i<t.length;i++)if(!t[i].isSupported)return!1}return!0}_update(){}_attachCameras(e){let t;const i=ae.MakeArray(e||this._cameras);if(i)for(let r=0;r<i.length;r++){const s=i[r];if(!s)continue;const n=s.name;if(this._singleInstance?t=0:t=n,!this._postProcesses[t]){const o=this._getPostProcesses();o&&(this._postProcesses[t]=Array.isArray(o)?o:[o])}this._indicesForCamera[n]||(this._indicesForCamera[n]=[]),this._postProcesses[t].forEach(o=>{const l=s.attachPostProcess(o);this._indicesForCamera[n].push(l)}),this._cameras[n]||(this._cameras[n]=s)}}_detachCameras(e){const t=ae.MakeArray(e||this._cameras);if(t)for(let i=0;i<t.length;i++){const r=t[i],s=r.name,n=this._postProcesses[this._singleInstance?0:s];n&&n.forEach(o=>{r.detachPostProcess(o)}),this._cameras[s]&&(this._cameras[s]=null),delete this._indicesForCamera[s]}}_enable(e){const t=ae.MakeArray(e||this._cameras);if(t)for(let i=0;i<t.length;i++){const r=t[i],s=r.name,n=this._singleInstance?0:s;for(let o=0;o<this._indicesForCamera[s].length;o++){const l=this._indicesForCamera[s][o],u=r._postProcesses[l];u==null&&t[i].attachPostProcess(this._postProcesses[n][o],l)}}}_disable(e){const t=ae.MakeArray(e||this._cameras);if(t)for(let i=0;i<t.length;i++){const r=t[i],s=r.name;this._postProcesses[this._singleInstance?0:s].forEach(n=>{r.detachPostProcess(n)})}}getPostProcesses(e){return this._singleInstance?this._postProcesses[0]:e?this._postProcesses[e.name]:null}}class eg extends Ce{get threshold(){return this._effectWrapper.threshold}set threshold(e){this._effectWrapper.threshold=e}get _exposure(){return this._effectWrapper._exposure}set _exposure(e){this._effectWrapper._exposure=e}getClassName(){return"ExtractHighlightsPostProcess"}constructor(e,t,i=null,r,s,n,o=0,l=!1){const u={uniforms:zr.Uniforms,size:typeof t=="number"?t:void 0,camera:i,samplingMode:r,engine:s,reusable:n,textureType:o,blockCompilation:l,...t};super(e,zr.FragmentUrl,{effectWrapper:typeof t=="number"||!t.effectWrapper?new zr(e,s,u):void 0,...u}),this._inputPostProcess=null,this.onApplyObservable.add(c=>{this.externalTextureSamplerBinding=!!this._inputPostProcess,this._inputPostProcess&&c.setTextureFromPostProcess("textureSampler",this._inputPostProcess)})}}C([F()],eg.prototype,"threshold",null);B("BABYLON.ExtractHighlightsPostProcess",eg);class tg extends Ce{get weight(){return this._effectWrapper.weight}set weight(e){this._effectWrapper.weight=e}getClassName(){return"BloomMergePostProcess"}constructor(e,t,i,r,s,n=null,o,l,u,c=0,h=!1){const d=typeof s=="number"?h:!!s.blockCompilation,f={uniforms:cr.Uniforms,samplers:cr.Samplers,size:typeof s=="number"?s:void 0,camera:n,samplingMode:o,engine:l,reusable:u,textureType:c,...s,blockCompilation:!0};super(e,cr.FragmentUrl,{effectWrapper:typeof s=="number"||!s.effectWrapper?new cr(e,l,f):void 0,...f}),this.weight=r,this.externalTextureSamplerBinding=!0,this.onApplyObservable.add(p=>{p.setTextureFromPostProcess("textureSampler",t),p.setTextureFromPostProcessOutput("bloomBlur",i)}),d||this.updateEffect()}}C([F()],tg.prototype,"weight",null);B("BABYLON.BloomMergePostProcess",tg);class Gv extends Xe{get threshold(){return this._thinBloomEffect.threshold}set threshold(e){this._thinBloomEffect.threshold=e}get weight(){return this._thinBloomEffect.weight}set weight(e){this._thinBloomEffect.weight=e}get kernel(){return this._thinBloomEffect.kernel}set kernel(e){this._thinBloomEffect.kernel=e}get bloomScale(){return this._thinBloomEffect.scale}constructor(e,t,i,r,s=0,n=!1){const o=e._renderForCamera?e.getEngine():e;super(o,"bloom",()=>this._effects,!0),this._effects=[],this._thinBloomEffect=new B0("bloom",o,t,n),this._downscale=new eg("highlights",{size:1,samplingMode:Y.BILINEAR_SAMPLINGMODE,engine:o,textureType:s,blockCompilation:n,effectWrapper:this._thinBloomEffect._downscale}),this._blurX=new zt("horizontal blur",this._thinBloomEffect._blurX.direction,this._thinBloomEffect._blurX.kernel,{size:t,samplingMode:Y.BILINEAR_SAMPLINGMODE,engine:o,textureType:s,blockCompilation:n,effectWrapper:this._thinBloomEffect._blurX}),this._blurX.alwaysForcePOT=!0,this._blurX.autoClear=!1,this._blurY=new zt("vertical blur",this._thinBloomEffect._blurY.direction,this._thinBloomEffect._blurY.kernel,{size:t,samplingMode:Y.BILINEAR_SAMPLINGMODE,engine:o,textureType:s,blockCompilation:n,effectWrapper:this._thinBloomEffect._blurY}),this._blurY.alwaysForcePOT=!0,this._blurY.autoClear=!1,this.kernel=r,this._effects=[this._downscale,this._blurX,this._blurY],this._merge=new tg("bloomMerge",this._downscale,this._blurY,i,{size:t,samplingMode:Y.BILINEAR_SAMPLINGMODE,engine:o,textureType:s,blockCompilation:n,effectWrapper:this._thinBloomEffect._merge}),this._merge.autoClear=!1,this._effects.push(this._merge)}disposeEffects(e){for(let t=0;t<this._effects.length;t++)this._effects[t].dispose(e)}_updateEffects(){for(let e=0;e<this._effects.length;e++)this._effects[e].updateEffect()}_isReady(){return this._thinBloomEffect.isReady()}}class gs extends Ce{get aberrationAmount(){return this._effectWrapper.aberrationAmount}set aberrationAmount(e){this._effectWrapper.aberrationAmount=e}get radialIntensity(){return this._effectWrapper.radialIntensity}set radialIntensity(e){this._effectWrapper.radialIntensity=e}get direction(){return this._effectWrapper.direction}set direction(e){this._effectWrapper.direction=e}get centerPosition(){return this._effectWrapper.centerPosition}set centerPosition(e){this._effectWrapper.centerPosition=e}get screenWidth(){return this._effectWrapper.screenWidth}set screenWidth(e){this._effectWrapper.screenWidth=e}get screenHeight(){return this._effectWrapper.screenHeight}set screenHeight(e){this._effectWrapper.screenHeight=e}getClassName(){return"ChromaticAberrationPostProcess"}constructor(e,t,i,r,s,n,o,l,u=0,c=!1){const h={uniforms:ls.Uniforms,size:typeof r=="number"?r:void 0,camera:s,samplingMode:n,engine:o,reusable:l,textureType:u,blockCompilation:c,...r};super(e,ls.FragmentUrl,{effectWrapper:typeof r=="number"||!r.effectWrapper?new ls(e,o,h):void 0,...h}),this.screenWidth=t,this.screenHeight=i}static _Parse(e,t,i,r){return Me.Parse(()=>new gs(e.name,e.screenWidth,e.screenHeight,e.options,t,e.renderTargetSamplingMode,i.getEngine(),e.reusable,e.textureType,!1),e,i,r)}}C([F()],gs.prototype,"aberrationAmount",null);C([F()],gs.prototype,"radialIntensity",null);C([F()],gs.prototype,"direction",null);C([F()],gs.prototype,"centerPosition",null);C([F()],gs.prototype,"screenWidth",null);C([F()],gs.prototype,"screenHeight",null);B("BABYLON.ChromaticAberrationPostProcess",gs);class uo extends Ce{get lensSize(){return this._effectWrapper.lensSize}set lensSize(e){this._effectWrapper.lensSize=e}get fStop(){return this._effectWrapper.fStop}set fStop(e){this._effectWrapper.fStop=e}get focusDistance(){return this._effectWrapper.focusDistance}set focusDistance(e){this._effectWrapper.focusDistance=e}get focalLength(){return this._effectWrapper.focalLength}set focalLength(e){this._effectWrapper.focalLength=e}getClassName(){return"CircleOfConfusionPostProcess"}constructor(e,t,i,r,s,n,o,l=0,u=!1){const c={uniforms:yi.Uniforms,samplers:yi.Samplers,defines:typeof i=="object"&&i.depthNotNormalized?yi.DefinesDepthNotNormalized:void 0,size:typeof i=="number"?i:void 0,camera:r,samplingMode:s,engine:n,reusable:o,textureType:l,blockCompilation:u,...i};super(e,yi.FragmentUrl,{effectWrapper:typeof i=="number"||!i.effectWrapper?new yi(e,n,c):void 0,...c}),this._depthTexture=null,this._depthTexture=t,this.onApplyObservable.add(h=>{if(!this._depthTexture){L.Warn("No depth texture set on CircleOfConfusionPostProcess");return}h.setTexture("depthSampler",this._depthTexture),this._effectWrapper.camera=this._depthTexture.activeCamera})}set depthTexture(e){this._depthTexture=e}}C([F()],uo.prototype,"lensSize",null);C([F()],uo.prototype,"fStop",null);C([F()],uo.prototype,"focusDistance",null);C([F()],uo.prototype,"focalLength",null);B("BABYLON.CircleOfConfusionPostProcess",uo);class pc extends Ce{getClassName(){return"ColorCorrectionPostProcess"}constructor(e,t,i,r,s,n,o){super(e,"colorCorrection",null,["colorTable"],i,r,s,n,o);const l=(r==null?void 0:r.getScene())||null;this._colorTableTexture=new Y(t,l,!0,!1,Y.TRILINEAR_SAMPLINGMODE),this._colorTableTexture.anisotropicFilteringLevel=1,this._colorTableTexture.wrapU=Y.CLAMP_ADDRESSMODE,this._colorTableTexture.wrapV=Y.CLAMP_ADDRESSMODE,this.colorTableUrl=t,this.onApply=u=>{u.setTexture("colorTable",this._colorTableTexture)}}_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(Promise.all([k(()=>Promise.resolve().then(()=>Ok),void 0)]))):t.push(Promise.all([k(()=>Promise.resolve().then(()=>Ak),void 0)])),super._gatherImports(e,t)}static _Parse(e,t,i,r){return Me.Parse(()=>new pc(e.name,e.colorTableUrl,e.options,t,e.renderTargetSamplingMode,i.getEngine(),e.reusable),e,i,r)}}C([F()],pc.prototype,"colorTableUrl",void 0);B("BABYLON.ColorCorrectionPostProcess",pc);class xs extends Ce{getClassName(){return"ConvolutionPostProcess"}constructor(e,t,i,r,s,n,o,l=0){super(e,"convolution",["kernel","screenSize"],null,i,r,s,n,o,null,l),this.kernel=t,this.onApply=u=>{u.setFloat2("screenSize",this.width,this.height),u.setArray("kernel",this.kernel)}}_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(Promise.all([k(()=>Promise.resolve().then(()=>Rk),void 0)]))):t.push(Promise.all([k(()=>Promise.resolve().then(()=>Ek),void 0)])),super._gatherImports(e,t)}static _Parse(e,t,i,r){return Me.Parse(()=>new xs(e.name,e.kernel,e.options,t,e.renderTargetSamplingMode,i.getEngine(),e.reusable,e.textureType),e,i,r)}}xs.EdgeDetect0Kernel=[1,0,-1,0,0,0,-1,0,1];xs.EdgeDetect1Kernel=[0,1,0,1,-4,1,0,1,0];xs.EdgeDetect2Kernel=[-1,-1,-1,-1,8,-1,-1,-1,-1];xs.SharpenKernel=[0,-1,0,-1,5,-1,0,-1,0];xs.EmbossKernel=[-2,-1,0,-1,1,1,0,1,2];xs.GaussianKernel=[0,1,0,1,1,1,0,1,0];C([F()],xs.prototype,"kernel",void 0);B("BABYLON.ConvolutionPostProcess",xs);class Bd extends zt{getClassName(){return"DepthOfFieldBlurPostProcess"}constructor(e,t,i,r,s,n,o,l=null,u=Y.BILINEAR_SAMPLINGMODE,c,h,d=0,f=!1,p=5){super(e,i,r,{camera:n,engine:c,reusable:h,textureType:d,defines:`#define DOF 1
`,blockCompilation:f,textureFormat:p,...s,samplingMode:u=2}),this.externalTextureSamplerBinding=!!l,this.onApplyObservable.add(g=>{l!=null&&g.setTextureFromPostProcess("textureSampler",l),g.setTextureFromPostProcessOutput("circleOfConfusionSampler",o)})}}B("BABYLON.DepthOfFieldBlurPostProcess",Bd);class _V extends Ce{getClassName(){return"DepthOfFieldMergePostProcess"}constructor(e,t,i,r,s,n,o,l,u,c=0,h=!1){const d=typeof s=="number"?h:!!s.blockCompilation,f={samplers:us.Samplers,size:typeof s=="number"?s:void 0,camera:n,samplingMode:o,engine:l,reusable:u,textureType:c,...s,blockCompilation:!0};super(e,us.FragmentUrl,{effectWrapper:typeof s=="number"||!s.effectWrapper?new us(e,l,f):void 0,...f}),this._blurSteps=r,this.externalTextureSamplerBinding=!0,this.onApplyObservable.add(p=>{p.setTextureFromPostProcess("textureSampler",t),p.setTextureFromPostProcessOutput("circleOfConfusionSampler",i),r.forEach((g,_)=>{p.setTextureFromPostProcessOutput("blurStep"+(r.length-_-1),g)})}),d||this.updateEffect()}updateEffect(e=null,t=null,i=null,r,s,n){e||(e="",e+="#define BLUR_LEVEL "+(this._blurSteps.length-1)+`
`),super.updateEffect(e,t,i,r,s,n)}}var Wv;(function(a){a[a.Low=0]="Low",a[a.Medium=1]="Medium",a[a.High=2]="High"})(Wv||(Wv={}));class $v extends Xe{set focalLength(e){this._thinDepthOfFieldEffect.focalLength=e}get focalLength(){return this._thinDepthOfFieldEffect.focalLength}set fStop(e){this._thinDepthOfFieldEffect.fStop=e}get fStop(){return this._thinDepthOfFieldEffect.fStop}set focusDistance(e){this._thinDepthOfFieldEffect.focusDistance=e}get focusDistance(){return this._thinDepthOfFieldEffect.focusDistance}set lensSize(e){this._thinDepthOfFieldEffect.lensSize=e}get lensSize(){return this._thinDepthOfFieldEffect.lensSize}constructor(e,t,i=0,r=0,s=!1,n=!1){const o=e._renderForCamera?e.getEngine():e;super(o,"depth of field",()=>this._effects,!0),this._effects=[],this._thinDepthOfFieldEffect=new z0("Depth of Field",o,i,!1,s);const l=o.isWebGPU||o.version>1?6:5;this._circleOfConfusion=new uo("circleOfConfusion",t,{size:1,samplingMode:Y.BILINEAR_SAMPLINGMODE,engine:o,textureType:r,blockCompilation:s,depthNotNormalized:n,effectWrapper:this._thinDepthOfFieldEffect._circleOfConfusion},null),this._depthOfFieldBlurY=[],this._depthOfFieldBlurX=[];const u=this._thinDepthOfFieldEffect._depthOfFieldBlurX.length;for(let c=0;c<u;c++){const[h,d]=this._thinDepthOfFieldEffect._depthOfFieldBlurY[c],f=new Bd("vertical blur",null,h.direction,h.kernel,{size:d,samplingMode:Y.BILINEAR_SAMPLINGMODE,engine:o,textureType:r,blockCompilation:s,textureFormat:c==0?l:5,effectWrapper:h},null,this._circleOfConfusion,c==0?this._circleOfConfusion:null);f.autoClear=!1;const[p,g]=this._thinDepthOfFieldEffect._depthOfFieldBlurX[c],_=new Bd("horizontal blur",null,p.direction,p.kernel,{size:g,samplingMode:Y.BILINEAR_SAMPLINGMODE,engine:o,textureType:r,blockCompilation:s,effectWrapper:p},null,this._circleOfConfusion,null);_.autoClear=!1,this._depthOfFieldBlurY.push(f),this._depthOfFieldBlurX.push(_)}this._effects=[this._circleOfConfusion];for(let c=0;c<this._depthOfFieldBlurX.length;c++)this._effects.push(this._depthOfFieldBlurY[c]),this._effects.push(this._depthOfFieldBlurX[c]);this._dofMerge=new _V("dofMerge",this._circleOfConfusion,this._circleOfConfusion,this._depthOfFieldBlurX,{size:this._thinDepthOfFieldEffect._depthOfFieldBlurX[u-1][1],samplingMode:Y.BILINEAR_SAMPLINGMODE,engine:o,textureType:r,blockCompilation:s,effectWrapper:this._thinDepthOfFieldEffect._dofMerge},null),this._dofMerge.autoClear=!1,this._effects.push(this._dofMerge)}getClassName(){return"DepthOfFieldEffect"}set depthTexture(e){this._circleOfConfusion.depthTexture=e}disposeEffects(e){for(let t=0;t<this._effects.length;t++)this._effects[t].dispose(e)}_updateEffects(){for(let e=0;e<this._effects.length;e++)this._effects[e].updateEffect()}_isReady(){return this._thinDepthOfFieldEffect.isReady()}}class ig extends Ce{getClassName(){return"DisplayPassPostProcess"}constructor(e,t,i,r,s,n){super(e,"displayPass",["passSampler"],["passSampler"],t,i,r,s,n)}_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(Promise.all([k(()=>Promise.resolve().then(()=>jk),void 0)]))):t.push(Promise.all([k(()=>Promise.resolve().then(()=>$k),void 0)])),super._gatherImports(e,t)}static _Parse(e,t,i,r){return Me.Parse(()=>new ig(e.name,e.options,t,e.renderTargetSamplingMode,i.getEngine(),e.reusable),e,i,r)}}B("BABYLON.DisplayPassPostProcess",ig);class mc extends Ce{getClassName(){return"FilterPostProcess"}constructor(e,t,i,r,s,n,o){super(e,"filter",["kernelMatrix"],null,i,r,s,n,o),this.kernelMatrix=t,this.onApply=l=>{l.setMatrix("kernelMatrix",this.kernelMatrix)}}_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(Promise.all([k(()=>Promise.resolve().then(()=>zk),void 0)]))):t.push(Promise.all([k(()=>Promise.resolve().then(()=>Vk),void 0)])),super._gatherImports(e,t)}static _Parse(e,t,i,r){return Me.Parse(()=>new mc(e.name,e.kernelMatrix,e.options,t,e.renderTargetSamplingMode,i.getEngine(),e.reusable),e,i,r)}}C([GM()],mc.prototype,"kernelMatrix",void 0);B("BABYLON.FilterPostProcess",mc);class co extends Ce{getClassName(){return"GrainPostProcess"}constructor(e,t,i,r,s,n,o=0,l=!1){super(e,"grain",["intensity","animatedSeed"],[],t,i,r,s,n,null,o,void 0,null,l),this.intensity=30,this.animated=!1,this.onApplyObservable.add(u=>{u.setFloat("intensity",this.intensity),u.setFloat("animatedSeed",this.animated?Math.random()+1:1)})}_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(Promise.all([k(()=>Promise.resolve().then(()=>$3),void 0)]))):t.push(Promise.all([k(()=>Promise.resolve().then(()=>G3),void 0)])),super._gatherImports(e,t)}static _Parse(e,t,i,r){return Me.Parse(()=>new co(e.name,e.options,t,e.renderTargetSamplingMode,i.getEngine(),e.reusable),e,i,r)}}C([F()],co.prototype,"intensity",void 0);C([F()],co.prototype,"animated",void 0);B("BABYLON.GrainPostProcess",co);class rg extends Ce{get imageProcessingConfiguration(){return this._imageProcessingConfiguration}set imageProcessingConfiguration(e){e.applyByPostProcess=!0,this._attachImageProcessingConfiguration(e)}_attachImageProcessingConfiguration(e,t=!1){if(e!==this._imageProcessingConfiguration){if(this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),e)this._imageProcessingConfiguration=e;else{let i=null;const r=this.getEngine(),s=this.getCamera();if(s)i=s.getScene();else if(r&&r.scenes){const n=r.scenes;i=n[n.length-1]}else i=ze.LastCreatedScene;i?this._imageProcessingConfiguration=i.imageProcessingConfiguration:this._imageProcessingConfiguration=new ts}this._imageProcessingConfiguration&&(this._imageProcessingObserver=this._imageProcessingConfiguration.onUpdateParameters.add(()=>{this._updateParameters()})),t||this._updateParameters()}}get isSupported(){const e=this.getEffect();return!e||e.isSupported}get colorCurves(){return this.imageProcessingConfiguration.colorCurves}set colorCurves(e){this.imageProcessingConfiguration.colorCurves=e}get colorCurvesEnabled(){return this.imageProcessingConfiguration.colorCurvesEnabled}set colorCurvesEnabled(e){this.imageProcessingConfiguration.colorCurvesEnabled=e}get colorGradingTexture(){return this.imageProcessingConfiguration.colorGradingTexture}set colorGradingTexture(e){this.imageProcessingConfiguration.colorGradingTexture=e}get colorGradingEnabled(){return this.imageProcessingConfiguration.colorGradingEnabled}set colorGradingEnabled(e){this.imageProcessingConfiguration.colorGradingEnabled=e}get exposure(){return this.imageProcessingConfiguration.exposure}set exposure(e){this.imageProcessingConfiguration.exposure=e}get toneMappingEnabled(){return this._imageProcessingConfiguration.toneMappingEnabled}set toneMappingEnabled(e){this._imageProcessingConfiguration.toneMappingEnabled=e}get toneMappingType(){return this._imageProcessingConfiguration.toneMappingType}set toneMappingType(e){this._imageProcessingConfiguration.toneMappingType=e}get contrast(){return this.imageProcessingConfiguration.contrast}set contrast(e){this.imageProcessingConfiguration.contrast=e}get vignetteStretch(){return this.imageProcessingConfiguration.vignetteStretch}set vignetteStretch(e){this.imageProcessingConfiguration.vignetteStretch=e}get vignetteCentreX(){return this.imageProcessingConfiguration.vignetteCenterX}set vignetteCentreX(e){this.imageProcessingConfiguration.vignetteCenterX=e}get vignetteCentreY(){return this.imageProcessingConfiguration.vignetteCenterY}set vignetteCentreY(e){this.imageProcessingConfiguration.vignetteCenterY=e}get vignetteCenterY(){return this.imageProcessingConfiguration.vignetteCenterY}set vignetteCenterY(e){this.imageProcessingConfiguration.vignetteCenterY=e}get vignetteCenterX(){return this.imageProcessingConfiguration.vignetteCenterX}set vignetteCenterX(e){this.imageProcessingConfiguration.vignetteCenterX=e}get vignetteWeight(){return this.imageProcessingConfiguration.vignetteWeight}set vignetteWeight(e){this.imageProcessingConfiguration.vignetteWeight=e}get vignetteColor(){return this.imageProcessingConfiguration.vignetteColor}set vignetteColor(e){this.imageProcessingConfiguration.vignetteColor=e}get vignetteCameraFov(){return this.imageProcessingConfiguration.vignetteCameraFov}set vignetteCameraFov(e){this.imageProcessingConfiguration.vignetteCameraFov=e}get vignetteBlendMode(){return this.imageProcessingConfiguration.vignetteBlendMode}set vignetteBlendMode(e){this.imageProcessingConfiguration.vignetteBlendMode=e}get vignetteEnabled(){return this.imageProcessingConfiguration.vignetteEnabled}set vignetteEnabled(e){this.imageProcessingConfiguration.vignetteEnabled=e}get ditheringIntensity(){return this.imageProcessingConfiguration.ditheringIntensity}set ditheringIntensity(e){this.imageProcessingConfiguration.ditheringIntensity=e}get ditheringEnabled(){return this.imageProcessingConfiguration.ditheringEnabled}set ditheringEnabled(e){this.imageProcessingConfiguration.ditheringEnabled=e}get fromLinearSpace(){return this._fromLinearSpace}set fromLinearSpace(e){this._fromLinearSpace!==e&&(this._fromLinearSpace=e,this._updateParameters())}constructor(e,t,i=null,r,s,n,o=0,l){super(e,"imageProcessing",[],[],t,i,r,s,n,null,o,"postprocess",null,!0),this._fromLinearSpace=!0,this._defines={IMAGEPROCESSING:!1,VIGNETTE:!1,VIGNETTEBLENDMODEMULTIPLY:!1,VIGNETTEBLENDMODEOPAQUE:!1,TONEMAPPING:0,CONTRAST:!1,COLORCURVES:!1,COLORGRADING:!1,COLORGRADING3D:!1,FROMLINEARSPACE:!1,SAMPLER3DGREENDEPTH:!1,SAMPLER3DBGRMAP:!1,DITHER:!1,IMAGEPROCESSINGPOSTPROCESS:!1,EXPOSURE:!1,SKIPFINALCOLORCLAMP:!1},l?(l.applyByPostProcess=!0,this._attachImageProcessingConfiguration(l,!0),this._updateParameters()):(this._attachImageProcessingConfiguration(null,!0),this.imageProcessingConfiguration.applyByPostProcess=!0),this.onApply=u=>{this.imageProcessingConfiguration.bind(u,this.aspectRatio)}}_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(k(()=>Promise.resolve().then(()=>L3),void 0))):t.push(k(()=>Promise.resolve().then(()=>V3),void 0)),super._gatherImports(e,t)}getClassName(){return"ImageProcessingPostProcess"}_updateParameters(){this._defines.FROMLINEARSPACE=this._fromLinearSpace,this.imageProcessingConfiguration.prepareDefines(this._defines,!0);let e="";for(const r in this._defines){const s=this._defines[r];switch(typeof s){case"number":case"string":e+=`#define ${r} ${s};
`;break;default:s&&(e+=`#define ${r};
`);break}}const t=["textureSampler"],i=["scale"];ts&&(ts.PrepareSamplers(t,this._defines),ts.PrepareUniforms(i,this._defines)),this.updateEffect(e,i,t)}dispose(e){super.dispose(e),this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),this._imageProcessingConfiguration&&(this.imageProcessingConfiguration.applyByPostProcess=!1)}}C([F()],rg.prototype,"_fromLinearSpace",void 0);const Hv="mrtFragmentDeclaration",gV=`#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
layout(location=0) out vec4 glFragData[{X}];
#endif
`;P.IncludesShadersStore[Hv]||(P.IncludesShadersStore[Hv]=gV);const Vd="geometryPixelShader",FP=`#extension GL_EXT_draw_buffers : require
#if defined(BUMP) || !defined(NORMAL)
#extension GL_OES_standard_derivatives : enable
#endif
precision highp float;
#ifdef BUMP
varying mat4 vWorldView;varying vec3 vNormalW;
#else
varying vec3 vNormalV;
#endif
varying vec4 vViewPos;
#if defined(POSITION) || defined(BUMP)
varying vec3 vPositionW;
#endif
#if defined(VELOCITY) || defined(VELOCITY_LINEAR)
varying vec4 vCurrentPosition;varying vec4 vPreviousPosition;
#endif
#ifdef NEED_UV
varying vec2 vUV;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;
#endif
#if defined(REFLECTIVITY)
#if defined(ORMTEXTURE) || defined(SPECULARGLOSSINESSTEXTURE) || defined(REFLECTIVITYTEXTURE)
uniform sampler2D reflectivitySampler;varying vec2 vReflectivityUV;
#endif
#ifdef ALBEDOTEXTURE
varying vec2 vAlbedoUV;uniform sampler2D albedoSampler;
#endif
#ifdef REFLECTIVITYCOLOR
uniform vec3 reflectivityColor;
#endif
#ifdef ALBEDOCOLOR
uniform vec3 albedoColor;
#endif
#ifdef METALLIC
uniform float metallic;
#endif
#if defined(ROUGHNESS) || defined(GLOSSINESS)
uniform float glossiness;
#endif
#endif
#if defined(ALPHATEST) && defined(NEED_UV)
uniform sampler2D diffuseSampler;
#endif
#include<clipPlaneFragmentDeclaration>
#include<mrtFragmentDeclaration>[SCENE_MRT_COUNT]
#include<bumpFragmentMainFunctions>
#include<bumpFragmentFunctions>
#include<helperFunctions>
void main() {
#include<clipPlaneFragment>
#ifdef ALPHATEST
if (texture2D(diffuseSampler,vUV).a<0.4)
discard;
#endif
vec3 normalOutput;
#ifdef BUMP
vec3 normalW=normalize(vNormalW);
#include<bumpFragment>
#ifdef NORMAL_WORLDSPACE
normalOutput=normalW;
#else
normalOutput=normalize(vec3(vWorldView*vec4(normalW,0.0)));
#endif
#else
normalOutput=normalize(vNormalV);
#endif
#ifdef ENCODE_NORMAL
normalOutput=normalOutput*0.5+0.5;
#endif
#ifdef DEPTH
gl_FragData[DEPTH_INDEX]=vec4(vViewPos.z/vViewPos.w,0.0,0.0,1.0);
#endif
#ifdef NORMAL
gl_FragData[NORMAL_INDEX]=vec4(normalOutput,1.0);
#endif
#ifdef SCREENSPACE_DEPTH
gl_FragData[SCREENSPACE_DEPTH_INDEX]=vec4(gl_FragCoord.z,0.0,0.0,1.0);
#endif
#ifdef POSITION
gl_FragData[POSITION_INDEX]=vec4(vPositionW,1.0);
#endif
#ifdef VELOCITY
vec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[VELOCITY_INDEX]=vec4(velocity,0.0,1.0);
#endif
#ifdef VELOCITY_LINEAR
vec2 velocity=vec2(0.5)*((vPreviousPosition.xy/vPreviousPosition.w) -
(vCurrentPosition.xy/vCurrentPosition.w));gl_FragData[VELOCITY_LINEAR_INDEX]=vec4(velocity,0.0,1.0);
#endif
#ifdef REFLECTIVITY
vec4 reflectivity=vec4(0.0,0.0,0.0,1.0);
#ifdef METALLICWORKFLOW
float metal=1.0;float roughness=1.0;
#ifdef ORMTEXTURE
metal*=texture2D(reflectivitySampler,vReflectivityUV).b;roughness*=texture2D(reflectivitySampler,vReflectivityUV).g;
#endif
#ifdef METALLIC
metal*=metallic;
#endif
#ifdef ROUGHNESS
roughness*=(1.0-glossiness); 
#endif
reflectivity.a-=roughness;vec3 color=vec3(1.0);
#ifdef ALBEDOTEXTURE
color=texture2D(albedoSampler,vAlbedoUV).rgb;
#ifdef GAMMAALBEDO
color=toLinearSpace(color);
#endif
#endif
#ifdef ALBEDOCOLOR
color*=albedoColor.xyz;
#endif
reflectivity.rgb=mix(vec3(0.04),color,metal);
#else
#if defined(SPECULARGLOSSINESSTEXTURE) || defined(REFLECTIVITYTEXTURE)
reflectivity=texture2D(reflectivitySampler,vReflectivityUV);
#ifdef GAMMAREFLECTIVITYTEXTURE
reflectivity.rgb=toLinearSpace(reflectivity.rgb);
#endif
#else 
#ifdef REFLECTIVITYCOLOR
reflectivity.rgb=toLinearSpace(reflectivityColor.xyz);reflectivity.a=1.0;
#endif
#endif
#ifdef GLOSSINESSS
reflectivity.a*=glossiness; 
#endif
#endif
gl_FragData[REFLECTIVITY_INDEX]=reflectivity;
#endif
}
`;P.ShadersStore[Vd]||(P.ShadersStore[Vd]=FP);const xV={name:Vd,shader:FP},SV=Object.freeze(Object.defineProperty({__proto__:null,geometryPixelShader:xV},Symbol.toStringTag,{value:"Module"})),jv="geometryVertexDeclaration",vV="uniform mat4 viewProjection;uniform mat4 view;";P.IncludesShadersStore[jv]||(P.IncludesShadersStore[jv]=vV);const Yv="geometryUboDeclaration",bV=`#include<sceneUboDeclaration>
`;P.IncludesShadersStore[Yv]||(P.IncludesShadersStore[Yv]=bV);const kd="geometryVertexShader",LP=`precision highp float;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<instancesDeclaration>
#include<__decl__geometryVertex>
#include<clipPlaneVertexDeclaration>
attribute vec3 position;attribute vec3 normal;
#ifdef NEED_UV
varying vec2 vUV;
#ifdef ALPHATEST
uniform mat4 diffuseMatrix;
#endif
#ifdef BUMP
uniform mat4 bumpMatrix;varying vec2 vBumpUV;
#endif
#ifdef REFLECTIVITY
uniform mat4 reflectivityMatrix;uniform mat4 albedoMatrix;varying vec2 vReflectivityUV;varying vec2 vAlbedoUV;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
#ifdef BUMP
varying mat4 vWorldView;
#endif
#ifdef BUMP
varying vec3 vNormalW;
#else
varying vec3 vNormalV;
#endif
varying vec4 vViewPos;
#if defined(POSITION) || defined(BUMP)
varying vec3 vPositionW;
#endif
#if defined(VELOCITY) || defined(VELOCITY_LINEAR)
uniform mat4 previousViewProjection;varying vec4 vCurrentPosition;varying vec4 vPreviousPosition;
#endif
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{vec3 positionUpdated=position;vec3 normalUpdated=normal;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#ifdef UV2
vec2 uv2Updated=uv2;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#if (defined(VELOCITY) || defined(VELOCITY_LINEAR)) && !defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=vec4(finalWorld*vec4(positionUpdated,1.0));
#ifdef BUMP
vWorldView=view*finalWorld;mat3 normalWorld=mat3(finalWorld);vNormalW=normalize(normalWorld*normalUpdated);
#else
#ifdef NORMAL_WORLDSPACE
vNormalV=normalize(vec3(finalWorld*vec4(normalUpdated,0.0)));
#else
vNormalV=normalize(vec3((view*finalWorld)*vec4(normalUpdated,0.0)));
#endif
#endif
vViewPos=view*worldPos;
#if (defined(VELOCITY) || defined(VELOCITY_LINEAR)) && defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);
#if NUM_BONE_INFLUENCERS>0
mat4 previousInfluence;previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
previousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
previousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
previousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
vPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);
#else
vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#endif
#if defined(POSITION) || defined(BUMP)
vPositionW=worldPos.xyz/worldPos.w;
#endif
gl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);
#include<clipPlaneVertex>
#ifdef NEED_UV
#ifdef UV1
#if defined(ALPHATEST) && defined(ALPHATEST_UV1)
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#else
vUV=uvUpdated;
#endif
#ifdef BUMP_UV1
vBumpUV=vec2(bumpMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef REFLECTIVITY_UV1
vReflectivityUV=vec2(reflectivityMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef ALBEDO_UV1
vAlbedoUV=vec2(albedoMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#endif
#ifdef UV2
#if defined(ALPHATEST) && defined(ALPHATEST_UV2)
vUV=vec2(diffuseMatrix*vec4(uv2Updated,1.0,0.0));
#else
vUV=uv2Updated;
#endif
#ifdef BUMP_UV2
vBumpUV=vec2(bumpMatrix*vec4(uv2Updated,1.0,0.0));
#endif
#ifdef REFLECTIVITY_UV2
vReflectivityUV=vec2(reflectivityMatrix*vec4(uv2Updated,1.0,0.0));
#endif
#ifdef ALBEDO_UV2
vAlbedoUV=vec2(albedoMatrix*vec4(uv2Updated,1.0,0.0));
#endif
#endif
#endif
#include<bumpVertex>
}
`;P.ShadersStore[kd]||(P.ShadersStore[kd]=LP);const yV={name:kd,shader:LP},TV=Object.freeze(Object.defineProperty({__proto__:null,geometryVertexShader:yV},Symbol.toStringTag,{value:"Module"})),BP=["world","mBones","viewProjection","diffuseMatrix","view","previousWorld","previousViewProjection","mPreviousBones","bumpMatrix","reflectivityMatrix","albedoMatrix","reflectivityColor","albedoColor","metallic","glossiness","vTangentSpaceParams","vBumpInfos","morphTargetInfluences","morphTargetCount","morphTargetTextureInfo","morphTargetTextureIndices","boneTextureWidth"];_n(BP);class Re{get normalsAreUnsigned(){return this._normalsAreUnsigned}_linkPrePassRenderer(e){this._linkedWithPrePass=!0,this._prePassRenderer=e,this._multiRenderTarget&&(this._multiRenderTarget.onClearObservable.clear(),this._multiRenderTarget.onClearObservable.add(()=>{}))}_unlinkPrePassRenderer(){this._linkedWithPrePass=!1,this._createRenderTargets()}_resetLayout(){this._enableDepth=!0,this._enableNormal=!0,this._enablePosition=!1,this._enableReflectivity=!1,this._enableVelocity=!1,this._enableVelocityLinear=!1,this._enableScreenspaceDepth=!1,this._attachmentsFromPrePass=[]}_forceTextureType(e,t){e===Re.POSITION_TEXTURE_TYPE?(this._positionIndex=t,this._enablePosition=!0):e===Re.VELOCITY_TEXTURE_TYPE?(this._velocityIndex=t,this._enableVelocity=!0):e===Re.VELOCITY_LINEAR_TEXTURE_TYPE?(this._velocityLinearIndex=t,this._enableVelocityLinear=!0):e===Re.REFLECTIVITY_TEXTURE_TYPE?(this._reflectivityIndex=t,this._enableReflectivity=!0):e===Re.DEPTH_TEXTURE_TYPE?(this._depthIndex=t,this._enableDepth=!0):e===Re.NORMAL_TEXTURE_TYPE?(this._normalIndex=t,this._enableNormal=!0):e===Re.SCREENSPACE_DEPTH_TEXTURE_TYPE&&(this._screenspaceDepthIndex=t,this._enableScreenspaceDepth=!0)}_setAttachments(e){this._attachmentsFromPrePass=e}_linkInternalTexture(e){this._multiRenderTarget.setInternalTexture(e,0,!1)}get renderList(){return this._multiRenderTarget.renderList}set renderList(e){this._multiRenderTarget.renderList=e}get isSupported(){return this._multiRenderTarget.isSupported}getTextureIndex(e){switch(e){case Re.POSITION_TEXTURE_TYPE:return this._positionIndex;case Re.VELOCITY_TEXTURE_TYPE:return this._velocityIndex;case Re.VELOCITY_LINEAR_TEXTURE_TYPE:return this._velocityLinearIndex;case Re.REFLECTIVITY_TEXTURE_TYPE:return this._reflectivityIndex;case Re.DEPTH_TEXTURE_TYPE:return this._depthIndex;case Re.NORMAL_TEXTURE_TYPE:return this._normalIndex;case Re.SCREENSPACE_DEPTH_TEXTURE_TYPE:return this._screenspaceDepthIndex;default:return-1}}get enableDepth(){return this._enableDepth}set enableDepth(e){this._enableDepth=e,this._linkedWithPrePass||(this.dispose(),this._createRenderTargets())}get enableNormal(){return this._enableNormal}set enableNormal(e){this._enableNormal=e,this._linkedWithPrePass||(this.dispose(),this._createRenderTargets())}get enablePosition(){return this._enablePosition}set enablePosition(e){this._enablePosition=e,this._linkedWithPrePass||(this.dispose(),this._createRenderTargets())}get enableVelocity(){return this._enableVelocity}set enableVelocity(e){this._enableVelocity=e,e||(this._previousTransformationMatrices={}),this._linkedWithPrePass||(this.dispose(),this._createRenderTargets()),this._scene.needsPreviousWorldMatrices=e}get enableVelocityLinear(){return this._enableVelocityLinear}set enableVelocityLinear(e){this._enableVelocityLinear=e,this._linkedWithPrePass||(this.dispose(),this._createRenderTargets())}get enableReflectivity(){return this._enableReflectivity}set enableReflectivity(e){this._enableReflectivity=e,this._linkedWithPrePass||(this.dispose(),this._createRenderTargets())}get enableScreenspaceDepth(){return this._enableScreenspaceDepth}set enableScreenspaceDepth(e){this._enableScreenspaceDepth=e,this._linkedWithPrePass||(this.dispose(),this._createRenderTargets())}get scene(){return this._scene}get ratio(){return typeof this._ratioOrDimensions=="object"?1:this._ratioOrDimensions}get shaderLanguage(){return this._shaderLanguage}constructor(e,t=1,i=15,r){this._previousTransformationMatrices={},this._previousBonesTransformationMatrices={},this.excludedSkinnedMeshesFromVelocity=[],this.renderTransparentMeshes=!0,this.generateNormalsInWorldSpace=!1,this._normalsAreUnsigned=!1,this._resizeObserver=null,this._enableDepth=!0,this._enableNormal=!0,this._enablePosition=!1,this._enableVelocity=!1,this._enableVelocityLinear=!1,this._enableReflectivity=!1,this._enableScreenspaceDepth=!1,this._clearColor=new xe(0,0,0,0),this._clearDepthColor=new xe(1e8,0,0,1),this._positionIndex=-1,this._velocityIndex=-1,this._velocityLinearIndex=-1,this._reflectivityIndex=-1,this._depthIndex=-1,this._normalIndex=-1,this._screenspaceDepthIndex=-1,this._linkedWithPrePass=!1,this.useSpecificClearForDepthTexture=!1,this._shaderLanguage=0,this._shadersLoaded=!1,this._scene=e,this._ratioOrDimensions=t,this._useUbo=e.getEngine().supportsUniformBuffers,this._depthFormat=i,this._textureTypesAndFormats=r||{},this._initShaderSourceAsync(),Re._SceneComponentInitialization(this._scene),this._createRenderTargets()}async _initShaderSourceAsync(){this._scene.getEngine().isWebGPU&&!Re.ForceGLSL?(this._shaderLanguage=1,await Promise.all([k(()=>Promise.resolve().then(()=>yU),void 0),k(()=>Promise.resolve().then(()=>vU),void 0)])):await Promise.all([k(()=>Promise.resolve().then(()=>TV),void 0),k(()=>Promise.resolve().then(()=>SV),void 0)]),this._shadersLoaded=!0}isReady(e,t){if(!this._shadersLoaded)return!1;const i=e.getMaterial();if(i&&i.disableDepthWrite)return!1;const r=[],s=[N.PositionKind,N.NormalKind],n=e.getMesh();let o=!1,l=!1;const u=!1;if(i){let g=!1;if(i.needAlphaTestingForMesh(n)&&i.getAlphaTestTexture()&&(r.push("#define ALPHATEST"),r.push(`#define ALPHATEST_UV${i.getAlphaTestTexture().coordinatesIndex+1}`),g=!0),(i.bumpTexture||i.normalTexture)&&vr.BumpTextureEnabled){const _=i.bumpTexture||i.normalTexture;r.push("#define BUMP"),r.push(`#define BUMP_UV${_.coordinatesIndex+1}`),g=!0}if(this._enableReflectivity){let _=!1;i.getClassName()==="PBRMetallicRoughnessMaterial"?(i.metallicRoughnessTexture&&(r.push("#define ORMTEXTURE"),r.push(`#define REFLECTIVITY_UV${i.metallicRoughnessTexture.coordinatesIndex+1}`),r.push("#define METALLICWORKFLOW"),g=!0,_=!0),i.metallic!=null&&(r.push("#define METALLIC"),r.push("#define METALLICWORKFLOW"),_=!0),i.roughness!=null&&(r.push("#define ROUGHNESS"),r.push("#define METALLICWORKFLOW"),_=!0),_&&(i.baseTexture&&(r.push("#define ALBEDOTEXTURE"),r.push(`#define ALBEDO_UV${i.baseTexture.coordinatesIndex+1}`),i.baseTexture.gammaSpace&&r.push("#define GAMMAALBEDO"),g=!0),i.baseColor&&r.push("#define ALBEDOCOLOR"))):i.getClassName()==="PBRSpecularGlossinessMaterial"?(i.specularGlossinessTexture?(r.push("#define SPECULARGLOSSINESSTEXTURE"),r.push(`#define REFLECTIVITY_UV${i.specularGlossinessTexture.coordinatesIndex+1}`),g=!0,i.specularGlossinessTexture.gammaSpace&&r.push("#define GAMMAREFLECTIVITYTEXTURE")):i.specularColor&&r.push("#define REFLECTIVITYCOLOR"),i.glossiness!=null&&r.push("#define GLOSSINESS")):i.getClassName()==="PBRMaterial"?(i.metallicTexture&&(r.push("#define ORMTEXTURE"),r.push(`#define REFLECTIVITY_UV${i.metallicTexture.coordinatesIndex+1}`),r.push("#define METALLICWORKFLOW"),g=!0,_=!0),i.metallic!=null&&(r.push("#define METALLIC"),r.push("#define METALLICWORKFLOW"),_=!0),i.roughness!=null&&(r.push("#define ROUGHNESS"),r.push("#define METALLICWORKFLOW"),_=!0),_?(i.albedoTexture&&(r.push("#define ALBEDOTEXTURE"),r.push(`#define ALBEDO_UV${i.albedoTexture.coordinatesIndex+1}`),i.albedoTexture.gammaSpace&&r.push("#define GAMMAALBEDO"),g=!0),i.albedoColor&&r.push("#define ALBEDOCOLOR")):(i.reflectivityTexture?(r.push("#define SPECULARGLOSSINESSTEXTURE"),r.push(`#define REFLECTIVITY_UV${i.reflectivityTexture.coordinatesIndex+1}`),i.reflectivityTexture.gammaSpace&&r.push("#define GAMMAREFLECTIVITYTEXTURE"),g=!0):i.reflectivityColor&&r.push("#define REFLECTIVITYCOLOR"),i.microSurface!=null&&r.push("#define GLOSSINESS"))):i.getClassName()==="StandardMaterial"&&(i.specularTexture&&(r.push("#define REFLECTIVITYTEXTURE"),r.push(`#define REFLECTIVITY_UV${i.specularTexture.coordinatesIndex+1}`),i.specularTexture.gammaSpace&&r.push("#define GAMMAREFLECTIVITYTEXTURE"),g=!0),i.specularColor&&r.push("#define REFLECTIVITYCOLOR"))}g&&(r.push("#define NEED_UV"),n.isVerticesDataPresent(N.UVKind)&&(s.push(N.UVKind),r.push("#define UV1"),o=!0),n.isVerticesDataPresent(N.UV2Kind)&&(s.push(N.UV2Kind),r.push("#define UV2"),l=!0))}this._enableDepth&&(r.push("#define DEPTH"),r.push("#define DEPTH_INDEX "+this._depthIndex)),this._enableNormal&&(r.push("#define NORMAL"),r.push("#define NORMAL_INDEX "+this._normalIndex)),this._enablePosition&&(r.push("#define POSITION"),r.push("#define POSITION_INDEX "+this._positionIndex)),this._enableVelocity&&(r.push("#define VELOCITY"),r.push("#define VELOCITY_INDEX "+this._velocityIndex),this.excludedSkinnedMeshesFromVelocity.indexOf(n)===-1&&r.push("#define BONES_VELOCITY_ENABLED")),this._enableVelocityLinear&&(r.push("#define VELOCITY_LINEAR"),r.push("#define VELOCITY_LINEAR_INDEX "+this._velocityLinearIndex),this.excludedSkinnedMeshesFromVelocity.indexOf(n)===-1&&r.push("#define BONES_VELOCITY_ENABLED")),this._enableReflectivity&&(r.push("#define REFLECTIVITY"),r.push("#define REFLECTIVITY_INDEX "+this._reflectivityIndex)),this._enableScreenspaceDepth&&this._screenspaceDepthIndex!==-1&&(r.push("#define SCREENSPACE_DEPTH_INDEX "+this._screenspaceDepthIndex),r.push("#define SCREENSPACE_DEPTH")),this.generateNormalsInWorldSpace&&r.push("#define NORMAL_WORLDSPACE"),this._normalsAreUnsigned&&r.push("#define ENCODE_NORMAL"),n.useBones&&n.computeBonesUsingShaders&&n.skeleton?(s.push(N.MatricesIndicesKind),s.push(N.MatricesWeightsKind),n.numBoneInfluencers>4&&(s.push(N.MatricesIndicesExtraKind),s.push(N.MatricesWeightsExtraKind)),r.push("#define NUM_BONE_INFLUENCERS "+n.numBoneInfluencers),r.push("#define BONETEXTURE "+n.skeleton.isUsingTextureForMatrices),r.push("#define BonesPerMesh "+(n.skeleton.bones.length+1))):(r.push("#define NUM_BONE_INFLUENCERS 0"),r.push("#define BONETEXTURE false"),r.push("#define BonesPerMesh 0"));const c=n.morphTargetManager?jn(n.morphTargetManager,r,s,n,!0,!0,!1,o,l,u):0;t&&(r.push("#define INSTANCES"),qn(s,this._enableVelocity||this._enableVelocityLinear),e.getRenderingMesh().hasThinInstances&&r.push("#define THIN_INSTANCES")),this._linkedWithPrePass?r.push("#define SCENE_MRT_COUNT "+this._attachmentsFromPrePass.length):r.push("#define SCENE_MRT_COUNT "+this._multiRenderTarget.textures.length),Zn(i,this._scene,r);const h=this._scene.getEngine(),d=e._getDrawWrapper(void 0,!0),f=d.defines,p=r.join(`
`);return f!==p&&d.setEffect(h.createEffect("geometry",{attributes:s,uniformsNames:BP,samplers:["diffuseSampler","bumpSampler","reflectivitySampler","albedoSampler","morphTargets","boneSampler"],defines:p,onCompiled:null,fallbacks:null,onError:null,uniformBuffersNames:["Scene"],indexParameters:{buffersCount:this._multiRenderTarget.textures.length-1,maxSimultaneousMorphTargets:c},shaderLanguage:this.shaderLanguage},h),p),d.effect.isReady()}getGBuffer(){return this._multiRenderTarget}get samples(){return this._multiRenderTarget.samples}set samples(e){this._multiRenderTarget.samples=e}dispose(){this._resizeObserver&&(this._scene.getEngine().onResizeObservable.remove(this._resizeObserver),this._resizeObserver=null),this.getGBuffer().dispose()}_assignRenderTargetIndices(){const e=[],t=[];let i=0;return this._enableDepth&&(this._depthIndex=i,i++,e.push("gBuffer_Depth"),t.push(this._textureTypesAndFormats[Re.DEPTH_TEXTURE_TYPE])),this._enableNormal&&(this._normalIndex=i,i++,e.push("gBuffer_Normal"),t.push(this._textureTypesAndFormats[Re.NORMAL_TEXTURE_TYPE])),this._enablePosition&&(this._positionIndex=i,i++,e.push("gBuffer_Position"),t.push(this._textureTypesAndFormats[Re.POSITION_TEXTURE_TYPE])),this._enableVelocity&&(this._velocityIndex=i,i++,e.push("gBuffer_Velocity"),t.push(this._textureTypesAndFormats[Re.VELOCITY_TEXTURE_TYPE])),this._enableVelocityLinear&&(this._velocityLinearIndex=i,i++,e.push("gBuffer_VelocityLinear"),t.push(this._textureTypesAndFormats[Re.VELOCITY_LINEAR_TEXTURE_TYPE])),this._enableReflectivity&&(this._reflectivityIndex=i,i++,e.push("gBuffer_Reflectivity"),t.push(this._textureTypesAndFormats[Re.REFLECTIVITY_TEXTURE_TYPE])),this._enableScreenspaceDepth&&(this._screenspaceDepthIndex=i,i++,e.push("gBuffer_ScreenspaceDepth"),t.push(this._textureTypesAndFormats[Re.SCREENSPACE_DEPTH_TEXTURE_TYPE])),[i,e,t]}_createRenderTargets(){const e=this._scene.getEngine(),[t,i,r]=this._assignRenderTargetIndices();let s=0;e._caps.textureFloat&&e._caps.textureFloatLinearFiltering?s=1:e._caps.textureHalfFloat&&e._caps.textureHalfFloatLinearFiltering&&(s=2);const n=this._ratioOrDimensions.width!==void 0?this._ratioOrDimensions:{width:e.getRenderWidth()*this._ratioOrDimensions,height:e.getRenderHeight()*this._ratioOrDimensions},o=[],l=[];for(const _ of r)_?(o.push(_.textureType),l.push(_.textureFormat)):(o.push(s),l.push(5));if(this._normalsAreUnsigned=o[Re.NORMAL_TEXTURE_TYPE]===11||o[Re.NORMAL_TEXTURE_TYPE]===13,this._multiRenderTarget=new Zs("gBuffer",n,t,this._scene,{generateMipMaps:!1,generateDepthTexture:!0,types:o,formats:l,depthTextureFormat:this._depthFormat},i.concat("gBuffer_DepthBuffer")),!this.isSupported)return;this._multiRenderTarget.wrapU=Y.CLAMP_ADDRESSMODE,this._multiRenderTarget.wrapV=Y.CLAMP_ADDRESSMODE,this._multiRenderTarget.refreshRate=1,this._multiRenderTarget.renderParticles=!1,this._multiRenderTarget.renderList=null;const u=[!0],c=[!1],h=[!0];for(let _=1;_<t;++_)u.push(!0),h.push(!1),c.push(!0);const d=e.buildTextureLayout(u),f=e.buildTextureLayout(c),p=e.buildTextureLayout(h);this._multiRenderTarget.onClearObservable.add(_=>{_.bindAttachments(this.useSpecificClearForDepthTexture?f:d),_.clear(this._clearColor,!0,!0,!0),this.useSpecificClearForDepthTexture&&(_.bindAttachments(p),_.clear(this._clearDepthColor,!0,!0,!0)),_.bindAttachments(d)}),this._resizeObserver=e.onResizeObservable.add(()=>{if(this._multiRenderTarget){const _=this._ratioOrDimensions.width!==void 0?this._ratioOrDimensions:{width:e.getRenderWidth()*this._ratioOrDimensions,height:e.getRenderHeight()*this._ratioOrDimensions};this._multiRenderTarget.resize(_)}});const g=_=>{const S=_.getRenderingMesh(),b=_.getEffectiveMesh(),y=this._scene,T=y.getEngine(),v=_.getMaterial();if(!v)return;if(b._internalAbstractMeshDataInfo._isActiveIntermediate=!1,(this._enableVelocity||this._enableVelocityLinear)&&!this._previousTransformationMatrices[b.uniqueId]&&(this._previousTransformationMatrices[b.uniqueId]={world:$.Identity(),viewProjection:y.getTransformMatrix()},S.skeleton)){const w=S.skeleton.getTransformMatrices(S);this._previousBonesTransformationMatrices[S.uniqueId]=this._copyBonesTransformationMatrices(w,new Float32Array(w.length))}const E=S._getInstancesRenderList(_._id,!!_.getReplacementMesh());if(E.mustReturn)return;const R=T.getCaps().instancedArrays&&(E.visibleInstances[_._id]!==null||S.hasThinInstances),O=b.getWorldMatrix();if(this.isReady(_,R)){const w=_._getDrawWrapper();if(!w)return;const M=w.effect;T.enableEffect(w),R||S._bind(_,M,v.fillMode),this._useUbo?(Lm(M,this._scene.getSceneUniformBuffer()),this._scene.finalizeSceneUbo()):(M.setMatrix("viewProjection",y.getTransformMatrix()),M.setMatrix("view",y.getViewMatrix()));let G;const H=S._instanceDataStorage;if(!H.isFrozen&&(v.backFaceCulling||v.sideOrientation!==null)){const q=b._getWorldMatrixDeterminant();G=v._getEffectiveOrientation(S),q<0&&(G=G===ft.ClockWiseSideOrientation?ft.CounterClockWiseSideOrientation:ft.ClockWiseSideOrientation)}else G=H.sideOrientation;if(v._preBind(w,G),v.needAlphaTestingForMesh(b)){const q=v.getAlphaTestTexture();q&&(M.setTexture("diffuseSampler",q),M.setMatrix("diffuseMatrix",q.getTextureMatrix()))}if((v.bumpTexture||v.normalTexture)&&y.getEngine().getCaps().standardDerivatives&&vr.BumpTextureEnabled){const q=v.bumpTexture||v.normalTexture;M.setFloat3("vBumpInfos",q.coordinatesIndex,1/q.level,v.parallaxScaleBias),M.setMatrix("bumpMatrix",q.getTextureMatrix()),M.setTexture("bumpSampler",q),M.setFloat2("vTangentSpaceParams",v.invertNormalMapX?-1:1,v.invertNormalMapY?-1:1)}if(this._enableReflectivity&&(v.getClassName()==="PBRMetallicRoughnessMaterial"?(v.metallicRoughnessTexture!==null&&(M.setTexture("reflectivitySampler",v.metallicRoughnessTexture),M.setMatrix("reflectivityMatrix",v.metallicRoughnessTexture.getTextureMatrix())),v.metallic!==null&&M.setFloat("metallic",v.metallic),v.roughness!==null&&M.setFloat("glossiness",1-v.roughness),v.baseTexture!==null&&(M.setTexture("albedoSampler",v.baseTexture),M.setMatrix("albedoMatrix",v.baseTexture.getTextureMatrix())),v.baseColor!==null&&M.setColor3("albedoColor",v.baseColor)):v.getClassName()==="PBRSpecularGlossinessMaterial"?(v.specularGlossinessTexture!==null?(M.setTexture("reflectivitySampler",v.specularGlossinessTexture),M.setMatrix("reflectivityMatrix",v.specularGlossinessTexture.getTextureMatrix())):v.specularColor!==null&&M.setColor3("reflectivityColor",v.specularColor),v.glossiness!==null&&M.setFloat("glossiness",v.glossiness)):v.getClassName()==="PBRMaterial"?(v.metallicTexture!==null&&(M.setTexture("reflectivitySampler",v.metallicTexture),M.setMatrix("reflectivityMatrix",v.metallicTexture.getTextureMatrix())),v.metallic!==null&&M.setFloat("metallic",v.metallic),v.roughness!==null&&M.setFloat("glossiness",1-v.roughness),v.roughness!==null||v.metallic!==null||v.metallicTexture!==null?(v.albedoTexture!==null&&(M.setTexture("albedoSampler",v.albedoTexture),M.setMatrix("albedoMatrix",v.albedoTexture.getTextureMatrix())),v.albedoColor!==null&&M.setColor3("albedoColor",v.albedoColor)):(v.reflectivityTexture!==null?(M.setTexture("reflectivitySampler",v.reflectivityTexture),M.setMatrix("reflectivityMatrix",v.reflectivityTexture.getTextureMatrix())):v.reflectivityColor!==null&&M.setColor3("reflectivityColor",v.reflectivityColor),v.microSurface!==null&&M.setFloat("glossiness",v.microSurface))):v.getClassName()==="StandardMaterial"&&(v.specularTexture!==null&&(M.setTexture("reflectivitySampler",v.specularTexture),M.setMatrix("reflectivityMatrix",v.specularTexture.getTextureMatrix())),v.specularColor!==null&&M.setColor3("reflectivityColor",v.specularColor))),Fs(M,v,this._scene),S.useBones&&S.computeBonesUsingShaders&&S.skeleton){const q=S.skeleton;if(q.isUsingTextureForMatrices&&M.getUniformIndex("boneTextureWidth")>-1){const X=q.getTransformMatrixTexture(S);M.setTexture("boneSampler",X),M.setFloat("boneTextureWidth",4*(q.bones.length+1))}else M.setMatrices("mBones",S.skeleton.getTransformMatrices(S));(this._enableVelocity||this._enableVelocityLinear)&&M.setMatrices("mPreviousBones",this._previousBonesTransformationMatrices[S.uniqueId])}Ns(S,M),S.morphTargetManager&&S.morphTargetManager.isUsingTextureForTargets&&S.morphTargetManager._bind(M),(this._enableVelocity||this._enableVelocityLinear)&&(M.setMatrix("previousWorld",this._previousTransformationMatrices[b.uniqueId].world),M.setMatrix("previousViewProjection",this._previousTransformationMatrices[b.uniqueId].viewProjection)),R&&S.hasThinInstances&&M.setMatrix("world",O),S._processRendering(b,_,M,v.fillMode,E,R,(q,X)=>{q||M.setMatrix("world",X)})}(this._enableVelocity||this._enableVelocityLinear)&&(this._previousTransformationMatrices[b.uniqueId].world=O.clone(),this._previousTransformationMatrices[b.uniqueId].viewProjection=this._scene.getTransformMatrix().clone(),S.skeleton&&this._copyBonesTransformationMatrices(S.skeleton.getTransformMatrices(S),this._previousBonesTransformationMatrices[b.uniqueId]))};this._multiRenderTarget.customIsReadyFunction=(_,S,b)=>{if((b||S===0)&&_.subMeshes)for(let y=0;y<_.subMeshes.length;++y){const T=_.subMeshes[y],v=T.getMaterial(),E=T.getRenderingMesh();if(!v)continue;const R=E._getInstancesRenderList(T._id,!!T.getReplacementMesh()),O=e.getCaps().instancedArrays&&(R.visibleInstances[T._id]!==null||E.hasThinInstances);if(!this.isReady(T,O))return!1}return!0},this._multiRenderTarget.customRenderFunction=(_,S,b,y)=>{let T;if(this._linkedWithPrePass){if(!this._prePassRenderer.enabled)return;this._scene.getEngine().bindAttachments(this._attachmentsFromPrePass)}if(y.length){for(e.setColorWrite(!1),T=0;T<y.length;T++)g(y.data[T]);e.setColorWrite(!0)}for(T=0;T<_.length;T++)g(_.data[T]);for(e.setDepthWrite(!1),T=0;T<S.length;T++)g(S.data[T]);if(this.renderTransparentMeshes)for(T=0;T<b.length;T++)g(b.data[T]);e.setDepthWrite(!0)}}_copyBonesTransformationMatrices(e,t){for(let i=0;i<e.length;i++)t[i]=e[i];return t}}Re.ForceGLSL=!1;Re.DEPTH_TEXTURE_TYPE=0;Re.NORMAL_TEXTURE_TYPE=1;Re.POSITION_TEXTURE_TYPE=2;Re.VELOCITY_TEXTURE_TYPE=3;Re.REFLECTIVITY_TEXTURE_TYPE=4;Re.SCREENSPACE_DEPTH_TEXTURE_TYPE=5;Re.VELOCITY_LINEAR_TEXTURE_TYPE=6;Re._SceneComponentInitialization=a=>{throw Cr("GeometryBufferRendererSceneComponent")};class CV{constructor(){this.enabled=!1,this.name="motionBlur",this.texturesRequired=[2]}}Object.defineProperty(Te.prototype,"geometryBufferRenderer",{get:function(){return this._geometryBufferRenderer},set:function(a){a&&a.isSupported&&(this._geometryBufferRenderer=a)},enumerable:!0,configurable:!0});Te.prototype.enableGeometryBufferRenderer=function(a=1,e=15,t){return this._geometryBufferRenderer?this._geometryBufferRenderer:(this._geometryBufferRenderer=new Re(this,a,e,t),this._geometryBufferRenderer.isSupported||(this._geometryBufferRenderer=null),this._geometryBufferRenderer)};Te.prototype.disableGeometryBufferRenderer=function(){this._geometryBufferRenderer&&(this._geometryBufferRenderer.dispose(),this._geometryBufferRenderer=null)};class PV{constructor(e){this.name=ge.NAME_GEOMETRYBUFFERRENDERER,this.scene=e}register(){this.scene._gatherRenderTargetsStage.registerStep(ge.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER,this,this._gatherRenderTargets)}rebuild(){}dispose(){}_gatherRenderTargets(e){this.scene._geometryBufferRenderer&&e.push(this.scene._geometryBufferRenderer.getGBuffer())}}Re._SceneComponentInitialization=a=>{let e=a._getComponent(ge.NAME_GEOMETRYBUFFERRENDERER);e||(e=new PV(a),a._addComponent(e))};class ia extends Ce{get motionBlurSamples(){return this._motionBlurSamples}set motionBlurSamples(e){this._motionBlurSamples=e,this._updateEffect()}get isObjectBased(){return this._isObjectBased}set isObjectBased(e){this._isObjectBased!==e&&(this._isObjectBased=e,this._applyMode())}get _geometryBufferRenderer(){return this._forceGeometryBuffer?this._scene.geometryBufferRenderer:null}get _prePassRenderer(){return this._forceGeometryBuffer?null:this._scene.prePassRenderer}getClassName(){return"MotionBlurPostProcess"}constructor(e,t,i,r,s,n,o,l=0,u=!1,c=!1){super(e,"motionBlur",["motionStrength","motionScale","screenSize","inverseViewProjection","prevViewProjection","projection"],["velocitySampler","depthSampler"],i,r,s,n,o,`#define GEOMETRY_SUPPORTED
#define SAMPLES 64.0
#define OBJECT_BASED`,l,void 0,null,u),this.motionStrength=1,this._motionBlurSamples=32,this._isObjectBased=!0,this._forceGeometryBuffer=!1,this._invViewProjection=null,this._previousViewProjection=null,this._forceGeometryBuffer=c,this._forceGeometryBuffer?(t.enableGeometryBufferRenderer(),this._geometryBufferRenderer&&(this._geometryBufferRenderer.enableVelocity=this._isObjectBased)):(t.enablePrePassRenderer(),this._prePassRenderer&&(this._prePassRenderer.markAsDirty(),this._prePassEffectConfiguration=new CV)),this._applyMode()}_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(Promise.all([k(()=>Promise.resolve().then(()=>Lk),void 0)]))):t.push(Promise.all([k(()=>Promise.resolve().then(()=>Nk),void 0)])),super._gatherImports(e,t)}excludeSkinnedMesh(e){if(e.skeleton){let t;if(this._geometryBufferRenderer)t=this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;else if(this._prePassRenderer)t=this._prePassRenderer.excludedSkinnedMesh;else return;t.push(e)}}removeExcludedSkinnedMesh(e){if(e.skeleton){let t;if(this._geometryBufferRenderer)t=this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;else if(this._prePassRenderer)t=this._prePassRenderer.excludedSkinnedMesh;else return;const i=t.indexOf(e);i!==-1&&t.splice(i,1)}}dispose(e){this._geometryBufferRenderer&&(this._geometryBufferRenderer._previousTransformationMatrices={},this._geometryBufferRenderer._previousBonesTransformationMatrices={},this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity=[]),super.dispose(e)}_applyMode(){if(!this._geometryBufferRenderer&&!this._prePassRenderer)return L.Warn("Multiple Render Target support needed to compute object based motion blur"),this.updateEffect();this._geometryBufferRenderer&&(this._geometryBufferRenderer.enableVelocity=this._isObjectBased),this._updateEffect(),this._invViewProjection=null,this._previousViewProjection=null,this.isObjectBased?(this._prePassRenderer&&this._prePassEffectConfiguration&&(this._prePassEffectConfiguration.texturesRequired[0]=2),this.onApply=e=>this._onApplyObjectBased(e)):(this._invViewProjection=$.Identity(),this._previousViewProjection=this._scene.getTransformMatrix().clone(),this._prePassRenderer&&this._prePassEffectConfiguration&&(this._prePassEffectConfiguration.texturesRequired[0]=5),this.onApply=e=>this._onApplyScreenBased(e))}_onApplyObjectBased(e){if(e.setVector2("screenSize",new Q(this.width,this.height)),e.setFloat("motionScale",this._scene.getAnimationRatio()),e.setFloat("motionStrength",this.motionStrength),this._geometryBufferRenderer){const t=this._geometryBufferRenderer.getTextureIndex(Re.VELOCITY_TEXTURE_TYPE);e.setTexture("velocitySampler",this._geometryBufferRenderer.getGBuffer().textures[t])}else if(this._prePassRenderer){const t=this._prePassRenderer.getIndex(2);e.setTexture("velocitySampler",this._prePassRenderer.getRenderTarget().textures[t])}}_onApplyScreenBased(e){const t=V.Matrix[0];if(t.copyFrom(this._scene.getTransformMatrix()),t.invertToRef(this._invViewProjection),e.setMatrix("inverseViewProjection",this._invViewProjection),e.setMatrix("prevViewProjection",this._previousViewProjection),this._previousViewProjection.copyFrom(t),e.setMatrix("projection",this._scene.getProjectionMatrix()),e.setVector2("screenSize",new Q(this.width,this.height)),e.setFloat("motionScale",this._scene.getAnimationRatio()),e.setFloat("motionStrength",this.motionStrength),this._geometryBufferRenderer){const i=this._geometryBufferRenderer.getTextureIndex(Re.DEPTH_TEXTURE_TYPE);e.setTexture("depthSampler",this._geometryBufferRenderer.getGBuffer().textures[i])}else if(this._prePassRenderer){const i=this._prePassRenderer.getIndex(5);e.setTexture("depthSampler",this._prePassRenderer.getRenderTarget().textures[i])}}_updateEffect(){if(this._geometryBufferRenderer||this._prePassRenderer){const e=["#define GEOMETRY_SUPPORTED","#define SAMPLES "+this._motionBlurSamples.toFixed(1),this._isObjectBased?"#define OBJECT_BASED":"#define SCREEN_BASED"];this.updateEffect(e.join(`
`))}}static _Parse(e,t,i,r){return Me.Parse(()=>new ia(e.name,i,e.options,t,e.renderTargetSamplingMode,i.getEngine(),e.reusable,e.textureType,!1),e,i,r)}}C([F()],ia.prototype,"motionStrength",void 0);C([F()],ia.prototype,"motionBlurSamples",null);C([F()],ia.prototype,"isObjectBased",null);B("BABYLON.MotionBlurPostProcess",ia);const Xv="refractionPixelShader",EV="varying vec2 vUV;uniform sampler2D textureSampler;uniform sampler2D refractionSampler;uniform vec3 baseColor;uniform float depth;uniform float colorLevel;void main() {float ref=1.0-texture2D(refractionSampler,vUV).r;vec2 uv=vUV-vec2(0.5);vec2 offset=uv*depth*ref;vec3 sourceColor=texture2D(textureSampler,vUV-offset).rgb;gl_FragColor=vec4(sourceColor+sourceColor*ref*colorLevel,1.0);}";P.ShadersStore[Xv]||(P.ShadersStore[Xv]=EV);class ra extends Ce{get refractionTexture(){return this._refTexture}set refractionTexture(e){this._refTexture&&this._ownRefractionTexture&&this._refTexture.dispose(),this._refTexture=e,this._ownRefractionTexture=!1}getClassName(){return"RefractionPostProcess"}constructor(e,t,i,r,s,n,o,l,u,c){super(e,"refraction",["baseColor","depth","colorLevel"],["refractionSampler"],n,o,l,u,c),this._ownRefractionTexture=!0,this.color=i,this.depth=r,this.colorLevel=s,this.refractionTextureUrl=t,this.onActivateObservable.add(h=>{this._refTexture=this._refTexture||new Y(t,h.getScene())}),this.onApplyObservable.add(h=>{h.setColor3("baseColor",this.color),h.setFloat("depth",this.depth),h.setFloat("colorLevel",this.colorLevel),h.setTexture("refractionSampler",this._refTexture)})}dispose(e){this._refTexture&&this._ownRefractionTexture&&(this._refTexture.dispose(),this._refTexture=null),super.dispose(e)}static _Parse(e,t,i,r){return Me.Parse(()=>new ra(e.name,e.refractionTextureUrl,e.color,e.depth,e.colorLevel,e.options,t,e.renderTargetSamplingMode,i.getEngine(),e.reusable),e,i,r)}}C([F()],ra.prototype,"color",void 0);C([F()],ra.prototype,"depth",void 0);C([F()],ra.prototype,"colorLevel",void 0);C([F()],ra.prototype,"refractionTextureUrl",void 0);B("BABYLON.RefractionPostProcess",ra);const zd="sharpenPixelShader",VP=`varying vec2 vUV;uniform sampler2D textureSampler;uniform vec2 screenSize;uniform vec2 sharpnessAmounts;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{vec2 onePixel=vec2(1.0,1.0)/screenSize;vec4 color=texture2D(textureSampler,vUV);vec4 edgeDetection=texture2D(textureSampler,vUV+onePixel*vec2(0,-1)) +
texture2D(textureSampler,vUV+onePixel*vec2(-1,0)) +
texture2D(textureSampler,vUV+onePixel*vec2(1,0)) +
texture2D(textureSampler,vUV+onePixel*vec2(0,1)) -
color*4.0;gl_FragColor=max(vec4(color.rgb*sharpnessAmounts.y,color.a)-(sharpnessAmounts.x*vec4(edgeDetection.rgb,0)),0.);}`;P.ShadersStore[zd]||(P.ShadersStore[zd]=VP);const IV={name:zd,shader:VP},RV=Object.freeze(Object.defineProperty({__proto__:null,sharpenPixelShader:IV},Symbol.toStringTag,{value:"Module"}));class ho extends Ce{getClassName(){return"SharpenPostProcess"}constructor(e,t,i,r,s,n,o=0,l=!1){super(e,"sharpen",["sharpnessAmounts","screenSize"],null,t,i,r,s,n,null,o,void 0,null,l),this.colorAmount=1,this.edgeAmount=.3,this.onApply=u=>{u.setFloat2("screenSize",this.width,this.height),u.setFloat2("sharpnessAmounts",this.edgeAmount,this.colorAmount)}}_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(Promise.all([k(()=>Promise.resolve().then(()=>z3),void 0)]))):t.push(Promise.all([k(()=>Promise.resolve().then(()=>RV),void 0)])),super._gatherImports(e,t)}static _Parse(e,t,i,r){return Me.Parse(()=>new ho(e.name,e.options,t,e.renderTargetSamplingMode,i.getEngine(),e.textureType,e.reusable),e,i,r)}}C([F()],ho.prototype,"colorAmount",void 0);C([F()],ho.prototype,"edgeAmount",void 0);B("BABYLON.SharpenPostProcess",ho);class sa{get name(){return this._name}get cameras(){return this._cameras}get engine(){return this._engine}constructor(e,t){this._engine=e,this._name=t,this._renderEffects={},this._renderEffectsForIsolatedPass=new Array,this._cameras=[]}getClassName(){return"PostProcessRenderPipeline"}get isSupported(){for(const e in this._renderEffects)if(Object.prototype.hasOwnProperty.call(this._renderEffects,e)&&!this._renderEffects[e].isSupported)return!1;return!0}addEffect(e){this._renderEffects[e._name]=e}_rebuild(){}_enableEffect(e,t){const i=this._renderEffects[e];i&&i._enable(ae.MakeArray(t||this._cameras))}_disableEffect(e,t){const i=this._renderEffects[e];i&&i._disable(ae.MakeArray(t||this._cameras))}_attachCameras(e,t){const i=ae.MakeArray(e||this._cameras);if(!i)return;const r=[];let s;for(s=0;s<i.length;s++){const n=i[s];n&&(this._cameras.indexOf(n)===-1?this._cameras.push(n):t&&r.push(s))}for(s=0;s<r.length;s++)i.splice(r[s],1);for(const n in this._renderEffects)Object.prototype.hasOwnProperty.call(this._renderEffects,n)&&this._renderEffects[n]._attachCameras(i)}_detachCameras(e){const t=ae.MakeArray(e||this._cameras);if(t){for(const i in this._renderEffects)Object.prototype.hasOwnProperty.call(this._renderEffects,i)&&this._renderEffects[i]._detachCameras(t);for(let i=0;i<t.length;i++)this._cameras.splice(this._cameras.indexOf(t[i]),1)}}_update(){for(const e in this._renderEffects)Object.prototype.hasOwnProperty.call(this._renderEffects,e)&&this._renderEffects[e]._update();for(let e=0;e<this._cameras.length;e++){if(!this._cameras[e])continue;const t=this._cameras[e].name;this._renderEffectsForIsolatedPass[t]&&this._renderEffectsForIsolatedPass[t]._update()}}_reset(){this._renderEffects={},this._renderEffectsForIsolatedPass=new Array}_enableMSAAOnFirstPostProcess(e){if(!this._engine._features.supportMSAA)return!1;const t=Object.keys(this._renderEffects);if(t.length>0){const i=this._renderEffects[t[0]].getPostProcesses();i&&(i[0].samples=e)}return!0}_adaptPostProcessesToViewPort(){const e=Object.keys(this._renderEffects);for(const t of e){const i=this._renderEffects[t].getPostProcesses();if(i)for(const r of i)r.adaptScaleToCurrentViewport=!0}}setPrePassRenderer(e){return!1}dispose(){}}C([F()],sa.prototype,"_name",void 0);class MV{constructor(){this._renderPipelines={}}get supportedPipelines(){const e=[];for(const t in this._renderPipelines)if(Object.prototype.hasOwnProperty.call(this._renderPipelines,t)){const i=this._renderPipelines[t];i.isSupported&&e.push(i)}return e}addPipeline(e){this._renderPipelines[e._name]=e}removePipeline(e){delete this._renderPipelines[e]}attachCamerasToRenderPipeline(e,t,i=!1){const r=this._renderPipelines[e];r&&r._attachCameras(t,i)}detachCamerasFromRenderPipeline(e,t){const i=this._renderPipelines[e];i&&i._detachCameras(t)}enableEffectInPipeline(e,t,i){const r=this._renderPipelines[e];r&&r._enableEffect(t,i)}disableEffectInPipeline(e,t,i){const r=this._renderPipelines[e];r&&r._disableEffect(t,i)}update(){for(const e in this._renderPipelines)if(Object.prototype.hasOwnProperty.call(this._renderPipelines,e)){const t=this._renderPipelines[e];t.isSupported?t._update():(t.dispose(),delete this._renderPipelines[e])}}_rebuild(){for(const e in this._renderPipelines)Object.prototype.hasOwnProperty.call(this._renderPipelines,e)&&this._renderPipelines[e]._rebuild()}dispose(){for(const e in this._renderPipelines)Object.prototype.hasOwnProperty.call(this._renderPipelines,e)&&this._renderPipelines[e].dispose()}}Object.defineProperty(Te.prototype,"postProcessRenderPipelineManager",{get:function(){if(!this._postProcessRenderPipelineManager){let a=this._getComponent(ge.NAME_POSTPROCESSRENDERPIPELINEMANAGER);a||(a=new AV(this),this._addComponent(a)),this._postProcessRenderPipelineManager=new MV}return this._postProcessRenderPipelineManager},enumerable:!0,configurable:!0});class AV{constructor(e){this.name=ge.NAME_POSTPROCESSRENDERPIPELINEMANAGER,this.scene=e}register(){this.scene._gatherRenderTargetsStage.registerStep(ge.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER,this,this._gatherRenderTargets)}rebuild(){this.scene._postProcessRenderPipelineManager&&this.scene._postProcessRenderPipelineManager._rebuild()}dispose(){this.scene._postProcessRenderPipelineManager&&this.scene._postProcessRenderPipelineManager.dispose()}_gatherRenderTargets(){this.scene._postProcessRenderPipelineManager&&this.scene._postProcessRenderPipelineManager.update()}}class ci extends sa{get automaticBuild(){return this._buildAllowed}set automaticBuild(e){this._buildAllowed=e}get scene(){return this._scene}set sharpenEnabled(e){this._sharpenEnabled!==e&&(this._sharpenEnabled=e,this._buildPipeline())}get sharpenEnabled(){return this._sharpenEnabled}get bloomKernel(){return this._bloomKernel}set bloomKernel(e){this._bloomKernel=e,this.bloom.kernel=e/this._hardwareScaleLevel}set bloomWeight(e){this._bloomWeight!==e&&(this.bloom.weight=e,this._bloomWeight=e)}get bloomWeight(){return this._bloomWeight}set bloomThreshold(e){this._bloomThreshold!==e&&(this.bloom.threshold=e,this._bloomThreshold=e)}get bloomThreshold(){return this._bloomThreshold}set bloomScale(e){this._bloomScale!==e&&(this._bloomScale=e,this._rebuildBloom(),this._buildPipeline())}get bloomScale(){return this._bloomScale}set bloomEnabled(e){this._bloomEnabled!==e&&(this._bloomEnabled=e,this._buildPipeline())}get bloomEnabled(){return this._bloomEnabled}_rebuildBloom(){const e=this.bloom;this.bloom=new Gv(this._scene,this.bloomScale,this._bloomWeight,this.bloomKernel/this._hardwareScaleLevel,this._defaultPipelineTextureType,!1),this.bloom.threshold=e.threshold;for(let t=0;t<this._cameras.length;t++)e.disposeEffects(this._cameras[t])}get depthOfFieldEnabled(){return this._depthOfFieldEnabled}set depthOfFieldEnabled(e){this._depthOfFieldEnabled!==e&&(this._depthOfFieldEnabled=e,this._buildPipeline())}get depthOfFieldBlurLevel(){return this._depthOfFieldBlurLevel}set depthOfFieldBlurLevel(e){if(this._depthOfFieldBlurLevel===e)return;this._depthOfFieldBlurLevel=e;const t=this.depthOfField;this.depthOfField=new $v(this._scene,null,this._depthOfFieldBlurLevel,this._defaultPipelineTextureType,!1),this.depthOfField.focalLength=t.focalLength,this.depthOfField.focusDistance=t.focusDistance,this.depthOfField.fStop=t.fStop,this.depthOfField.lensSize=t.lensSize;for(let i=0;i<this._cameras.length;i++)t.disposeEffects(this._cameras[i]);this._buildPipeline()}set fxaaEnabled(e){this._fxaaEnabled!==e&&(this._fxaaEnabled=e,this._buildPipeline())}get fxaaEnabled(){return this._fxaaEnabled}set samples(e){this._samples!==e&&(this._samples=e,this._buildPipeline())}get samples(){return this._samples}set imageProcessingEnabled(e){this._imageProcessingEnabled!==e&&(this._scene.imageProcessingConfiguration.isEnabled=e)}get imageProcessingEnabled(){return this._imageProcessingEnabled}set glowLayerEnabled(e){e&&!this._glowLayer?this._glowLayer=new Tr("",this._scene):!e&&this._glowLayer&&(this._glowLayer.dispose(),this._glowLayer=null)}get glowLayerEnabled(){return this._glowLayer!=null}get glowLayer(){return this._glowLayer}set chromaticAberrationEnabled(e){this._chromaticAberrationEnabled!==e&&(this._chromaticAberrationEnabled=e,this._buildPipeline())}get chromaticAberrationEnabled(){return this._chromaticAberrationEnabled}set grainEnabled(e){this._grainEnabled!==e&&(this._grainEnabled=e,this._buildPipeline())}get grainEnabled(){return this._grainEnabled}constructor(e="",t=!0,i=ze.LastCreatedScene,r,s=!0){super(i.getEngine(),e),this._camerasToBeAttached=[],this.SharpenPostProcessId="SharpenPostProcessEffect",this.ImageProcessingPostProcessId="ImageProcessingPostProcessEffect",this.FxaaPostProcessId="FxaaPostProcessEffect",this.ChromaticAberrationPostProcessId="ChromaticAberrationPostProcessEffect",this.GrainPostProcessId="GrainPostProcessEffect",this._glowLayer=null,this.animations=[],this._imageProcessingConfigurationObserver=null,this._sharpenEnabled=!1,this._bloomEnabled=!1,this._depthOfFieldEnabled=!1,this._depthOfFieldBlurLevel=0,this._fxaaEnabled=!1,this._imageProcessingEnabled=!0,this._bloomScale=.5,this._chromaticAberrationEnabled=!1,this._grainEnabled=!1,this._buildAllowed=!0,this.onBuildObservable=new j,this._resizeObserver=null,this._hardwareScaleLevel=1,this._bloomKernel=64,this._bloomWeight=.15,this._bloomThreshold=.9,this._samples=1,this._hasCleared=!1,this._prevPostProcess=null,this._prevPrevPostProcess=null,this._depthOfFieldSceneObserver=null,this._activeCameraChangedObserver=null,this._activeCamerasChangedObserver=null,this._cameras=r||i.cameras,this._cameras=this._cameras.slice(),this._camerasToBeAttached=this._cameras.slice(),this._buildAllowed=s,this._scene=i;const n=this._scene.getEngine().getCaps();this._hdr=t&&(n.textureHalfFloatRender||n.textureFloatRender),this._hdr?n.textureHalfFloatRender?this._defaultPipelineTextureType=2:n.textureFloatRender&&(this._defaultPipelineTextureType=1):this._defaultPipelineTextureType=0,i.postProcessRenderPipelineManager.addPipeline(this);const o=this._scene.getEngine();this.sharpen=new ho("sharpen",1,null,Y.BILINEAR_SAMPLINGMODE,o,!1,this._defaultPipelineTextureType,!0),this._sharpenEffect=new Xe(o,this.SharpenPostProcessId,()=>this.sharpen,!0),this.depthOfField=new $v(this._scene,null,this._depthOfFieldBlurLevel,this._defaultPipelineTextureType,!0),this._hardwareScaleLevel=o.getHardwareScalingLevel(),this._resizeObserver=o.onResizeObservable.add(()=>{this._hardwareScaleLevel=o.getHardwareScalingLevel(),this.bloomKernel=this._bloomKernel}),this.bloom=new Gv(this._scene,this._bloomScale,this._bloomWeight,this.bloomKernel/this._hardwareScaleLevel,this._defaultPipelineTextureType,!0),this.chromaticAberration=new gs("ChromaticAberration",o.getRenderWidth(),o.getRenderHeight(),1,null,Y.BILINEAR_SAMPLINGMODE,o,!1,this._defaultPipelineTextureType,!0),this._chromaticAberrationEffect=new Xe(o,this.ChromaticAberrationPostProcessId,()=>this.chromaticAberration,!0),this.grain=new co("Grain",1,null,Y.BILINEAR_SAMPLINGMODE,o,!1,this._defaultPipelineTextureType,!0),this._grainEffect=new Xe(o,this.GrainPostProcessId,()=>this.grain,!0);let l=!0;this._imageProcessingConfigurationObserver=this._scene.imageProcessingConfiguration.onUpdateParameters.add(()=>{this.bloom._downscale._exposure=this._scene.imageProcessingConfiguration.exposure,this.imageProcessingEnabled!==this._scene.imageProcessingConfiguration.isEnabled&&(this._imageProcessingEnabled=this._scene.imageProcessingConfiguration.isEnabled,l?ae.SetImmediate(()=>{this._buildPipeline()}):this._buildPipeline())}),this._buildPipeline(),l=!1}getClassName(){return"DefaultRenderingPipeline"}prepare(){const e=this._buildAllowed;this._buildAllowed=!0,this._buildPipeline(),this._buildAllowed=e}_setAutoClearAndTextureSharing(e,t=!1){this._hasCleared?e.autoClear=!1:(e.autoClear=!0,this._scene.autoClear=!1,this._hasCleared=!0),t||(this._prevPrevPostProcess?e.shareOutputWith(this._prevPrevPostProcess):e.useOwnOutput(),this._prevPostProcess&&(this._prevPrevPostProcess=this._prevPostProcess),this._prevPostProcess=e)}_buildPipeline(){if(!this._buildAllowed)return;this._scene.autoClear=!0;const e=this._scene.getEngine();if(this._disposePostProcesses(),this._cameras!==null&&(this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name,this._cameras),this._cameras=this._camerasToBeAttached.slice()),this._reset(),this._prevPostProcess=null,this._prevPrevPostProcess=null,this._hasCleared=!1,this.depthOfFieldEnabled){if(this._cameras.length>1){for(const t of this._cameras){const i=this._scene.enableDepthRenderer(t);i.useOnlyInActiveCamera=!0}this._depthOfFieldSceneObserver=this._scene.onAfterRenderTargetsRenderObservable.add(t=>{this._cameras.indexOf(t.activeCamera)>-1&&(this.depthOfField.depthTexture=t.enableDepthRenderer(t.activeCamera).getDepthMap())})}else{this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);const t=this._scene.enableDepthRenderer(this._cameras[0]);this.depthOfField.depthTexture=t.getDepthMap()}this.depthOfField._isReady()||this.depthOfField._updateEffects(),this.addEffect(this.depthOfField),this._setAutoClearAndTextureSharing(this.depthOfField._effects[0],!0)}else this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);this.bloomEnabled&&(this.bloom._isReady()||this.bloom._updateEffects(),this.addEffect(this.bloom),this._setAutoClearAndTextureSharing(this.bloom._effects[0],!0)),this._imageProcessingEnabled&&(this.imageProcessing=new rg("imageProcessing",1,null,Y.BILINEAR_SAMPLINGMODE,e,!1,this._defaultPipelineTextureType,this.scene.imageProcessingConfiguration),this._hdr?(this.addEffect(new Xe(e,this.ImageProcessingPostProcessId,()=>this.imageProcessing,!0)),this._setAutoClearAndTextureSharing(this.imageProcessing)):this._scene.imageProcessingConfiguration.applyByPostProcess=!1,(!this._cameras||this._cameras.length===0)&&(this._scene.imageProcessingConfiguration.applyByPostProcess=!1),this.imageProcessing.getEffect()||this.imageProcessing._updateParameters()),this.sharpenEnabled&&(this.sharpen.isReady()||this.sharpen.updateEffect(),this.addEffect(this._sharpenEffect),this._setAutoClearAndTextureSharing(this.sharpen)),this.grainEnabled&&(this.grain.isReady()||this.grain.updateEffect(),this.addEffect(this._grainEffect),this._setAutoClearAndTextureSharing(this.grain)),this.chromaticAberrationEnabled&&(this.chromaticAberration.isReady()||this.chromaticAberration.updateEffect(),this.addEffect(this._chromaticAberrationEffect),this._setAutoClearAndTextureSharing(this.chromaticAberration)),this.fxaaEnabled&&(this.fxaa=new lo("fxaa",1,null,Y.BILINEAR_SAMPLINGMODE,e,!1,this._defaultPipelineTextureType),this.addEffect(new Xe(e,this.FxaaPostProcessId,()=>this.fxaa,!0)),this._setAutoClearAndTextureSharing(this.fxaa,!0)),this._cameras!==null&&this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name,this._cameras),(this._scene.activeCameras&&this._scene.activeCameras.length>1||this._scene.activeCamera&&this._cameras.indexOf(this._scene.activeCamera)===-1)&&(this._scene.autoClear=!0),this._activeCameraChangedObserver||(this._activeCameraChangedObserver=this._scene.onActiveCameraChanged.add(()=>{this._scene.activeCamera&&this._cameras.indexOf(this._scene.activeCamera)===-1&&(this._scene.autoClear=!0)})),this._activeCamerasChangedObserver||(this._activeCamerasChangedObserver=this._scene.onActiveCamerasChanged.add(()=>{this._scene.activeCameras&&this._scene.activeCameras.length>1&&(this._scene.autoClear=!0)})),this._adaptPostProcessesToViewPort(),!this._enableMSAAOnFirstPostProcess(this.samples)&&this.samples>1&&L.Warn("MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0"),this.onBuildObservable.notifyObservers(this)}_disposePostProcesses(e=!1){for(let t=0;t<this._cameras.length;t++){const i=this._cameras[t];this.imageProcessing&&this.imageProcessing.dispose(i),this.fxaa&&this.fxaa.dispose(i),e&&(this.sharpen&&this.sharpen.dispose(i),this.depthOfField&&(this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver),this.depthOfField.disposeEffects(i)),this.bloom&&this.bloom.disposeEffects(i),this.chromaticAberration&&this.chromaticAberration.dispose(i),this.grain&&this.grain.dispose(i),this._glowLayer&&this._glowLayer.dispose())}this.imageProcessing=null,this.fxaa=null,e&&(this.sharpen=null,this._sharpenEffect=null,this.depthOfField=null,this.bloom=null,this.chromaticAberration=null,this._chromaticAberrationEffect=null,this.grain=null,this._grainEffect=null,this._glowLayer=null)}addCamera(e){this._camerasToBeAttached.push(e),this._buildPipeline()}removeCamera(e){const t=this._camerasToBeAttached.indexOf(e);this._camerasToBeAttached.splice(t,1),this._buildPipeline()}dispose(){this._buildAllowed=!1,this.onBuildObservable.clear(),this._disposePostProcesses(!0),this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name,this._cameras),this._scene._postProcessRenderPipelineManager.removePipeline(this.name),this._scene.autoClear=!0,this._resizeObserver&&(this._scene.getEngine().onResizeObservable.remove(this._resizeObserver),this._resizeObserver=null),this._scene.onActiveCameraChanged.remove(this._activeCameraChangedObserver),this._scene.onActiveCamerasChanged.remove(this._activeCamerasChangedObserver),this._scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigurationObserver),super.dispose()}serialize(){const e=Me.Serialize(this);return e.customType="DefaultRenderingPipeline",e}static Parse(e,t,i){return Me.Parse(()=>new ci(e._name,e._name._hdr,t),e,t,i)}}C([F()],ci.prototype,"sharpenEnabled",null);C([F()],ci.prototype,"bloomKernel",null);C([F()],ci.prototype,"_bloomWeight",void 0);C([F()],ci.prototype,"_bloomThreshold",void 0);C([F()],ci.prototype,"_hdr",void 0);C([F()],ci.prototype,"bloomWeight",null);C([F()],ci.prototype,"bloomThreshold",null);C([F()],ci.prototype,"bloomScale",null);C([F()],ci.prototype,"bloomEnabled",null);C([F()],ci.prototype,"depthOfFieldEnabled",null);C([F()],ci.prototype,"depthOfFieldBlurLevel",null);C([F()],ci.prototype,"fxaaEnabled",null);C([F()],ci.prototype,"samples",null);C([F()],ci.prototype,"imageProcessingEnabled",null);C([F()],ci.prototype,"glowLayerEnabled",null);C([F()],ci.prototype,"chromaticAberrationEnabled",null);C([F()],ci.prototype,"grainEnabled",null);B("BABYLON.DefaultRenderingPipeline",ci);const Ud="chromaticAberrationPixelShader",kP=`uniform sampler2D textureSampler; 
uniform float chromatic_aberration;uniform float radialIntensity;uniform vec2 direction;uniform vec2 centerPosition;uniform float screen_width;uniform float screen_height;varying vec2 vUV;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{vec2 centered_screen_pos=vec2(vUV.x-centerPosition.x,vUV.y-centerPosition.y);vec2 directionOfEffect=direction;if(directionOfEffect.x==0. && directionOfEffect.y==0.){directionOfEffect=normalize(centered_screen_pos);}
float radius2=centered_screen_pos.x*centered_screen_pos.x
+ centered_screen_pos.y*centered_screen_pos.y;float radius=sqrt(radius2);vec3 ref_indices=vec3(-0.3,0.0,0.3);float ref_shiftX=chromatic_aberration*pow(radius,radialIntensity)*directionOfEffect.x/screen_width;float ref_shiftY=chromatic_aberration*pow(radius,radialIntensity)*directionOfEffect.y/screen_height;vec2 ref_coords_r=vec2(vUV.x+ref_indices.r*ref_shiftX,vUV.y+ref_indices.r*ref_shiftY*0.5);vec2 ref_coords_g=vec2(vUV.x+ref_indices.g*ref_shiftX,vUV.y+ref_indices.g*ref_shiftY*0.5);vec2 ref_coords_b=vec2(vUV.x+ref_indices.b*ref_shiftX,vUV.y+ref_indices.b*ref_shiftY*0.5);vec4 r=texture2D(textureSampler,ref_coords_r);vec4 g=texture2D(textureSampler,ref_coords_g);vec4 b=texture2D(textureSampler,ref_coords_b);float a=clamp(r.a+g.a+b.a,0.,1.);gl_FragColor=vec4(r.r,g.g,b.b,a);}`;P.ShadersStore[Ud]||(P.ShadersStore[Ud]=kP);const DV={name:Ud,shader:kP},OV=Object.freeze(Object.defineProperty({__proto__:null,chromaticAberrationPixelShader:DV},Symbol.toStringTag,{value:"Module"})),Zv="lensHighlightsPixelShader",wV=`uniform sampler2D textureSampler; 
uniform float gain;uniform float threshold;uniform float screen_width;uniform float screen_height;varying vec2 vUV;vec4 highlightColor(vec4 color) {vec4 highlight=color;float luminance=dot(highlight.rgb,vec3(0.2125,0.7154,0.0721));float lum_threshold;if (threshold>1.0) { lum_threshold=0.94+0.01*threshold; }
else { lum_threshold=0.5+0.44*threshold; }
luminance=clamp((luminance-lum_threshold)*(1.0/(1.0-lum_threshold)),0.0,1.0);highlight*=luminance*gain;highlight.a=1.0;return highlight;}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{vec4 original=texture2D(textureSampler,vUV);if (gain==-1.0) {gl_FragColor=vec4(0.0,0.0,0.0,1.0);return;}
float w=2.0/screen_width;float h=2.0/screen_height;float weight=1.0;vec4 blurred=vec4(0.0,0.0,0.0,0.0);
#ifdef PENTAGON
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.84*w,0.43*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.48*w,-1.29*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.61*w,1.51*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.55*w,-0.74*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.71*w,-0.52*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.94*w,1.59*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.40*w,-1.87*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.62*w,1.16*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.09*w,0.25*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.46*w,-1.71*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.08*w,2.42*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.85*w,-1.89*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.89*w,0.16*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.29*w,1.88*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.40*w,-2.81*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.54*w,2.26*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.60*w,-0.61*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.31*w,-1.30*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.83*w,2.53*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.12*w,-2.48*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.60*w,1.11*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.99*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.50*w,-2.81*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.85*w,3.33*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.94*w,-1.92*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.27*w,-0.53*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.95*w,2.48*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.23*w,-3.04*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.17*w,2.05*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.97*w,-0.04*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.25*w,-2.00*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.31*w,3.08*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.94*w,-2.59*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.37*w,0.64*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.13*w,1.93*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.03*w,-3.65*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.60*w,3.17*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.14*w,-1.19*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.00*w,-1.19*h)));
#else
blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.85*w,0.36*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.52*w,-1.14*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.46*w,1.42*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.46*w,-0.83*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.79*w,-0.42*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.11*w,1.62*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.29*w,-2.07*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.69*w,1.39*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.28*w,0.12*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.65*w,-1.69*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.08*w,2.44*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.63*w,-1.90*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.55*w,0.31*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.13*w,1.52*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.56*w,-2.61*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.38*w,2.34*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.64*w,-0.81*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.53*w,-1.21*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.06*w,2.63*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.00*w,-2.69*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.59*w,1.32*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.78*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.57*w,-2.50*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.54*w,2.93*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.39*w,-1.81*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,-0.28*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.04*w,2.25*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.02*w,-3.05*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.09*w,2.25*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.07*w,-0.25*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.44*w,-1.90*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.52*w,3.05*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.68*w,-2.61*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,0.79*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.76*w,1.46*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.05*w,-2.94*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.21*w,2.88*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.84*w,-1.30*h)));blurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.98*w,-0.96*h)));
#endif
blurred/=39.0;gl_FragColor=blurred;}`;P.ShadersStore[Zv]||(P.ShadersStore[Zv]=wV);const qv="depthOfFieldPixelShader",NV=`uniform sampler2D textureSampler;uniform sampler2D highlightsSampler;uniform sampler2D depthSampler;uniform sampler2D grainSampler;uniform float grain_amount;uniform bool blur_noise;uniform float screen_width;uniform float screen_height;uniform float distortion;uniform bool dof_enabled;uniform float screen_distance; 
uniform float aperture;uniform float darken;uniform float edge_blur;uniform bool highlights;uniform float near;uniform float far;varying vec2 vUV;
#define PI 3.14159265
#define TWOPI 6.28318530
#define inverse_focal_length 0.1 
vec2 centered_screen_pos;vec2 distorted_coords;float radius2;float radius;vec2 rand(vec2 co)
{float noise1=(fract(sin(dot(co,vec2(12.9898,78.233)))*43758.5453));float noise2=(fract(sin(dot(co,vec2(12.9898,78.233)*2.0))*43758.5453));return clamp(vec2(noise1,noise2),0.0,1.0);}
vec2 getDistortedCoords(vec2 coords) {if (distortion==0.0) { return coords; }
vec2 direction=1.0*normalize(centered_screen_pos);vec2 dist_coords=vec2(0.5,0.5);dist_coords.x=0.5+direction.x*radius2*1.0;dist_coords.y=0.5+direction.y*radius2*1.0;float dist_amount=clamp(distortion*0.23,0.0,1.0);dist_coords=mix(coords,dist_coords,dist_amount);return dist_coords;}
float sampleScreen(inout vec4 color,in vec2 offset,in float weight) {vec2 coords=distorted_coords;float angle=rand(coords*100.0).x*TWOPI;coords+=vec2(offset.x*cos(angle)-offset.y*sin(angle),offset.x*sin(angle)+offset.y*cos(angle));color+=texture2D(textureSampler,coords)*weight;return weight;}
float getBlurLevel(float size) {return min(3.0,ceil(size/1.0));}
vec4 getBlurColor(float size) {vec4 col=texture2D(textureSampler,distorted_coords);float blur_level=getBlurLevel(size);float w=(size/screen_width);float h=(size/screen_height);float total_weight=1.0;vec2 sample_coords;total_weight+=sampleScreen(col,vec2(-0.50*w,0.24*h),0.93);total_weight+=sampleScreen(col,vec2(0.30*w,-0.75*h),0.90);total_weight+=sampleScreen(col,vec2(0.36*w,0.96*h),0.87);total_weight+=sampleScreen(col,vec2(-1.08*w,-0.55*h),0.85);total_weight+=sampleScreen(col,vec2(1.33*w,-0.37*h),0.83);total_weight+=sampleScreen(col,vec2(-0.82*w,1.31*h),0.80);total_weight+=sampleScreen(col,vec2(-0.31*w,-1.67*h),0.78);total_weight+=sampleScreen(col,vec2(1.47*w,1.11*h),0.76);total_weight+=sampleScreen(col,vec2(-1.97*w,0.19*h),0.74);total_weight+=sampleScreen(col,vec2(1.42*w,-1.57*h),0.72);if (blur_level>1.0) {total_weight+=sampleScreen(col,vec2(0.01*w,2.25*h),0.70);total_weight+=sampleScreen(col,vec2(-1.62*w,-1.74*h),0.67);total_weight+=sampleScreen(col,vec2(2.49*w,0.20*h),0.65);total_weight+=sampleScreen(col,vec2(-2.07*w,1.61*h),0.63);total_weight+=sampleScreen(col,vec2(0.46*w,-2.70*h),0.61);total_weight+=sampleScreen(col,vec2(1.55*w,2.40*h),0.59);total_weight+=sampleScreen(col,vec2(-2.88*w,-0.75*h),0.56);total_weight+=sampleScreen(col,vec2(2.73*w,-1.44*h),0.54);total_weight+=sampleScreen(col,vec2(-1.08*w,3.02*h),0.52);total_weight+=sampleScreen(col,vec2(-1.28*w,-3.05*h),0.49);}
if (blur_level>2.0) {total_weight+=sampleScreen(col,vec2(3.11*w,1.43*h),0.46);total_weight+=sampleScreen(col,vec2(-3.36*w,1.08*h),0.44);total_weight+=sampleScreen(col,vec2(1.80*w,-3.16*h),0.41);total_weight+=sampleScreen(col,vec2(0.83*w,3.65*h),0.38);total_weight+=sampleScreen(col,vec2(-3.16*w,-2.19*h),0.34);total_weight+=sampleScreen(col,vec2(3.92*w,-0.53*h),0.31);total_weight+=sampleScreen(col,vec2(-2.59*w,3.12*h),0.26);total_weight+=sampleScreen(col,vec2(-0.20*w,-4.15*h),0.22);total_weight+=sampleScreen(col,vec2(3.02*w,3.00*h),0.15);}
col/=total_weight; 
if (darken>0.0) {col.rgb*=clamp(0.3,1.0,1.05-size*0.5*darken);}
return col;}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{centered_screen_pos=vec2(vUV.x-0.5,vUV.y-0.5);radius2=centered_screen_pos.x*centered_screen_pos.x+centered_screen_pos.y*centered_screen_pos.y;radius=sqrt(radius2);distorted_coords=getDistortedCoords(vUV); 
vec2 texels_coords=vec2(vUV.x*screen_width,vUV.y*screen_height); 
float depth=texture2D(depthSampler,distorted_coords).r; 
float distance=near+(far-near)*depth; 
vec4 color=texture2D(textureSampler,vUV); 
float coc=abs(aperture*(screen_distance*(inverse_focal_length-1.0/distance)-1.0));if (dof_enabled==false || coc<0.07) { coc=0.0; }
float edge_blur_amount=0.0;if (edge_blur>0.0) {edge_blur_amount=clamp((radius*2.0-1.0+0.15*edge_blur)*1.5,0.0,1.0)*1.3;}
float blur_amount=max(edge_blur_amount,coc);if (blur_amount==0.0) {gl_FragColor=texture2D(textureSampler,distorted_coords);}
else {gl_FragColor=getBlurColor(blur_amount*1.7);if (highlights) {gl_FragColor.rgb+=clamp(coc,0.0,1.0)*texture2D(highlightsSampler,distorted_coords).rgb;}
if (blur_noise) {vec2 noise=rand(distorted_coords)*0.01*blur_amount;vec2 blurred_coord=vec2(distorted_coords.x+noise.x,distorted_coords.y+noise.y);gl_FragColor=0.04*texture2D(textureSampler,blurred_coord)+0.96*gl_FragColor;}}
if (grain_amount>0.0) {vec4 grain_color=texture2D(grainSampler,texels_coords*0.003);gl_FragColor.rgb+=(-0.5+grain_color.rgb)*0.30*grain_amount;}}
`;P.ShadersStore[qv]||(P.ShadersStore[qv]=NV);class FV{constructor(){this.enabled=!1,this.name="ssao2",this.texturesRequired=[6,5]}}class Gt extends sa{set epsilon(e){this._epsilon=e,this._ssaoPostProcess.updateEffect(this._getDefinesForSSAO())}get epsilon(){return this._epsilon}set samples(e){this._samples=e,this._ssaoPostProcess.updateEffect(this._getDefinesForSSAO()),this._sampleSphere=this._generateHemisphere()}get samples(){return this._samples}set textureSamples(e){this._textureSamples=e,this._prePassRenderer?this._prePassRenderer.samples=e:this._originalColorPostProcess.samples=e}get textureSamples(){return this._textureSamples}get _geometryBufferRenderer(){return this._forceGeometryBuffer?this._scene.geometryBufferRenderer:null}get _prePassRenderer(){return this._forceGeometryBuffer?null:this._scene.prePassRenderer}set bypassBlur(e){const t=this._getDefinesForBlur(this.expensiveBlur,e),i=this._getSamplersForBlur(e);this._blurHPostProcess.updateEffect(t.h,null,i),this._blurVPostProcess.updateEffect(t.v,null,i),this._bypassBlur=e}get bypassBlur(){return this._bypassBlur}set expensiveBlur(e){const t=this._getDefinesForBlur(e,this._bypassBlur);this._blurHPostProcess.updateEffect(t.h),this._blurVPostProcess.updateEffect(t.v),this._expensiveBlur=e}get expensiveBlur(){return this._expensiveBlur}static get IsSupported(){const e=ze.LastCreatedEngine;return e?e._features.supportSSAO2:!1}get scene(){return this._scene}constructor(e,t,i,r,s=!1,n=0){var u,c;if(super(t.getEngine(),e),this.SSAOOriginalSceneColorEffect="SSAOOriginalSceneColorEffect",this.SSAORenderEffect="SSAORenderEffect",this.SSAOBlurHRenderEffect="SSAOBlurHRenderEffect",this.SSAOBlurVRenderEffect="SSAOBlurVRenderEffect",this.SSAOCombineRenderEffect="SSAOCombineRenderEffect",this.totalStrength=1,this.maxZ=100,this.minZAspect=.2,this._epsilon=.02,this._samples=8,this._textureSamples=1,this._forceGeometryBuffer=!1,this.radius=2,this.base=0,this._bypassBlur=!1,this._expensiveBlur=!0,this.bilateralSamples=16,this.bilateralSoften=0,this.bilateralTolerance=0,this._bits=new Uint32Array(1),this._scene=t,this._ratio=i,this._textureType=n,this._forceGeometryBuffer=s,!this.isSupported){L.Error("The current engine does not support SSAO 2.");return}const o=this._ratio.ssaoRatio||i,l=this._ratio.blurRatio||i;this._forceGeometryBuffer?(t.enableGeometryBufferRenderer(),(u=t.geometryBufferRenderer)!=null&&u.generateNormalsInWorldSpace&&L.Error("SSAO2RenderingPipeline does not support generateNormalsInWorldSpace=true for the geometry buffer renderer!")):(t.enablePrePassRenderer(),(c=t.prePassRenderer)!=null&&c.generateNormalsInWorldSpace&&L.Error("SSAO2RenderingPipeline does not support generateNormalsInWorldSpace=true for the prepass renderer!")),this._createRandomTexture(),this._originalColorPostProcess=new Za("SSAOOriginalSceneColor",1,null,Y.BILINEAR_SAMPLINGMODE,t.getEngine(),void 0,this._textureType),this._originalColorPostProcess.samples=this.textureSamples,this._createSSAOPostProcess(1,n),this._createBlurPostProcess(o,l,this._textureType),this._createSSAOCombinePostProcess(l,this._textureType),this.addEffect(new Xe(t.getEngine(),this.SSAOOriginalSceneColorEffect,()=>this._originalColorPostProcess,!0)),this.addEffect(new Xe(t.getEngine(),this.SSAORenderEffect,()=>this._ssaoPostProcess,!0)),this.addEffect(new Xe(t.getEngine(),this.SSAOBlurHRenderEffect,()=>this._blurHPostProcess,!0)),this.addEffect(new Xe(t.getEngine(),this.SSAOBlurVRenderEffect,()=>this._blurVPostProcess,!0)),this.addEffect(new Xe(t.getEngine(),this.SSAOCombineRenderEffect,()=>this._ssaoCombinePostProcess,!0)),t.postProcessRenderPipelineManager.addPipeline(this),r&&t.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(e,r)}getClassName(){return"SSAO2RenderingPipeline"}dispose(e=!1){for(let t=0;t<this._scene.cameras.length;t++){const i=this._scene.cameras[t];this._originalColorPostProcess.dispose(i),this._ssaoPostProcess.dispose(i),this._blurHPostProcess.dispose(i),this._blurVPostProcess.dispose(i),this._ssaoCombinePostProcess.dispose(i)}this._randomTexture.dispose(),e&&this._scene.disableGeometryBufferRenderer(),this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name,this._scene.cameras),super.dispose()}_rebuild(){super._rebuild()}_getSamplersForBlur(e){return e?["textureSampler"]:["textureSampler","depthSampler"]}_getDefinesForBlur(e,t){let i=`#define BLUR
`;return t&&(i+=`#define BLUR_BYPASS
`),e||(i+=`#define BLUR_LEGACY
`),{h:i+`#define BLUR_H
`,v:i}}_createBlurPostProcess(e,t,i){const r=this._getDefinesForBlur(this.expensiveBlur,this.bypassBlur),s=this._getSamplersForBlur(this.bypassBlur);this._blurHPostProcess=this._createBlurFilter("BlurH",s,e,r.h,i,!0),this._blurVPostProcess=this._createBlurFilter("BlurV",s,t,r.v,i,!1)}_createBlurFilter(e,t,i,r,s,n){const o=new Ce(e,"ssao2",["outSize","samples","soften","tolerance"],t,i,null,Y.BILINEAR_SAMPLINGMODE,this._scene.getEngine(),!1,r,s,void 0,void 0,void 0,void 0,this._scene.getEngine().isWebGPU?1:0,(l,u)=>{l?u.push(k(()=>Promise.resolve().then(()=>tb),void 0)):u.push(k(()=>Promise.resolve().then(()=>eb),void 0))});return o.onApply=l=>{if(!this._scene.activeCamera)return;const u=this._ratio.blurRatio||this._ratio,c=n?this._originalColorPostProcess.width*u:this._originalColorPostProcess.height*u,h=n?this._originalColorPostProcess.width:this._originalColorPostProcess.height;l.setFloat("outSize",c>0?c:h),l.setInt("samples",this.bilateralSamples),l.setFloat("soften",this.bilateralSoften),l.setFloat("tolerance",this.bilateralTolerance),this._geometryBufferRenderer?l.setTexture("depthSampler",this._geometryBufferRenderer.getGBuffer().textures[0]):this._prePassRenderer&&l.setTexture("depthSampler",this._prePassRenderer.getRenderTarget().textures[this._prePassRenderer.getIndex(5)])},o.samples=this.textureSamples,o.autoClear=!1,o}_radicalInverse_VdC(e){return this._bits[0]=e,this._bits[0]=(this._bits[0]<<16|this._bits[0]>>16)>>>0,this._bits[0]=(this._bits[0]&1431655765)<<1|(this._bits[0]&2863311530)>>>1>>>0,this._bits[0]=(this._bits[0]&858993459)<<2|(this._bits[0]&3435973836)>>>2>>>0,this._bits[0]=(this._bits[0]&252645135)<<4|(this._bits[0]&4042322160)>>>4>>>0,this._bits[0]=(this._bits[0]&16711935)<<8|(this._bits[0]&4278255360)>>>8>>>0,this._bits[0]*23283064365386963e-26}_hammersley(e,t){return[e/t,this._radicalInverse_VdC(e)]}_hemisphereSample_uniform(e,t){const i=t*2*Math.PI,r=1-e*.85,s=Math.sqrt(1-r*r);return new m(Math.cos(i)*s,Math.sin(i)*s,r)}_generateHemisphere(){const e=this.samples,t=[];let i,r=0;for(;r<e;){if(e<16)i=this._hemisphereSample_uniform(Math.random(),Math.random());else{const s=this._hammersley(r,e);i=this._hemisphereSample_uniform(s[0],s[1])}t.push(i.x,i.y,i.z),r++}return t}_getDefinesForSSAO(){return`#define SSAO
#define SAMPLES ${this.samples}
#define EPSILON ${this.epsilon.toFixed(4)}`}_createSSAOPostProcess(e,t){this._sampleSphere=this._generateHemisphere();const i=this._getDefinesForSSAO(),r=["randomSampler","depthSampler","normalSampler"];this._ssaoPostProcess=new Ce("ssao2","ssao2",["sampleSphere","samplesFactor","randTextureTiles","totalStrength","radius","base","range","projection","near","texelSize","xViewport","yViewport","maxZ","minZAspect","depthProjection"],r,e,null,Y.BILINEAR_SAMPLINGMODE,this._scene.getEngine(),!1,i,t,void 0,void 0,void 0,void 0,this._scene.getEngine().isWebGPU?1:0,(s,n)=>{s?n.push(k(()=>Promise.resolve().then(()=>tb),void 0)):n.push(k(()=>Promise.resolve().then(()=>eb),void 0))}),this._ssaoPostProcess.autoClear=!1,this._ssaoPostProcess.onApply=s=>{if(this._scene.activeCamera){if(s.setArray3("sampleSphere",this._sampleSphere),s.setFloat("randTextureTiles",32),s.setFloat("samplesFactor",1/this.samples),s.setFloat("totalStrength",this.totalStrength),s.setFloat2("texelSize",1/this._ssaoPostProcess.width,1/this._ssaoPostProcess.height),s.setFloat("radius",this.radius),s.setFloat("maxZ",this.maxZ),s.setFloat("minZAspect",this.minZAspect),s.setFloat("base",this.base),s.setFloat("near",this._scene.activeCamera.minZ),this._scene.activeCamera.mode===Ze.PERSPECTIVE_CAMERA)s.setMatrix3x3("depthProjection",Gt.PERSPECTIVE_DEPTH_PROJECTION),s.setFloat("xViewport",Math.tan(this._scene.activeCamera.fov/2)*this._scene.getEngine().getAspectRatio(this._scene.activeCamera,!0)),s.setFloat("yViewport",Math.tan(this._scene.activeCamera.fov/2));else{const n=this._scene.getEngine().getRenderWidth()/2,o=this._scene.getEngine().getRenderHeight()/2,l=this._scene.activeCamera.orthoLeft??-n,u=this._scene.activeCamera.orthoRight??n,c=this._scene.activeCamera.orthoBottom??-o,h=this._scene.activeCamera.orthoTop??o;s.setMatrix3x3("depthProjection",Gt.ORTHO_DEPTH_PROJECTION),s.setFloat("xViewport",(u-l)*.5),s.setFloat("yViewport",(h-c)*.5)}s.setMatrix("projection",this._scene.getProjectionMatrix()),this._geometryBufferRenderer?(s.setTexture("depthSampler",this._geometryBufferRenderer.getGBuffer().textures[0]),s.setTexture("normalSampler",this._geometryBufferRenderer.getGBuffer().textures[1])):this._prePassRenderer&&(s.setTexture("depthSampler",this._prePassRenderer.getRenderTarget().textures[this._prePassRenderer.getIndex(5)]),s.setTexture("normalSampler",this._prePassRenderer.getRenderTarget().textures[this._prePassRenderer.getIndex(6)])),s.setTexture("randomSampler",this._randomTexture)}},this._ssaoPostProcess.samples=this.textureSamples,this._forceGeometryBuffer||(this._ssaoPostProcess._prePassEffectConfiguration=new FV)}_createSSAOCombinePostProcess(e,t){this._ssaoCombinePostProcess=new Ce("ssaoCombine","ssaoCombine",[],["originalColor","viewport"],e,null,Y.BILINEAR_SAMPLINGMODE,this._scene.getEngine(),!1,void 0,t,void 0,void 0,void 0,void 0,this._scene.getEngine().isWebGPU?1:0,(i,r)=>{i?r.push(k(()=>Promise.resolve().then(()=>jV),void 0)):r.push(k(()=>Promise.resolve().then(()=>VV),void 0))}),this._ssaoCombinePostProcess.onApply=i=>{const r=this._scene.activeCamera.viewport;i.setVector4("viewport",V.Vector4[0].copyFromFloats(r.x,r.y,r.width,r.height)),i.setTextureFromPostProcessOutput("originalColor",this._originalColorPostProcess)},this._ssaoCombinePostProcess.autoClear=!1,this._ssaoCombinePostProcess.samples=this.textureSamples}_createRandomTexture(){const t=new Uint8Array(65536),i=Q.Zero();for(let s=0;s<t.length;)i.set(Ne(0,1),Ne(0,1)).normalize().scaleInPlace(255),t[s++]=Math.floor(i.x),t[s++]=Math.floor(i.y),t[s++]=0,t[s++]=255;const r=qt.CreateRGBATexture(t,128,128,this._scene,!1,!1,2);r.name="SSAORandomTexture",r.wrapU=Y.WRAP_ADDRESSMODE,r.wrapV=Y.WRAP_ADDRESSMODE,this._randomTexture=r}serialize(){const e=Me.Serialize(this);return e.customType="SSAO2RenderingPipeline",e}static Parse(e,t,i){return Me.Parse(()=>new Gt(e._name,t,e._ratio,void 0,e._forceGeometryBuffer,e._textureType),e,t,i)}}Gt.ORTHO_DEPTH_PROJECTION=[1,0,0,0,1,0,0,0,1];Gt.PERSPECTIVE_DEPTH_PROJECTION=[0,0,0,0,0,0,1,1,1];C([F()],Gt.prototype,"totalStrength",void 0);C([F()],Gt.prototype,"maxZ",void 0);C([F()],Gt.prototype,"minZAspect",void 0);C([F("epsilon")],Gt.prototype,"_epsilon",void 0);C([F("samples")],Gt.prototype,"_samples",void 0);C([F("textureSamples")],Gt.prototype,"_textureSamples",void 0);C([F()],Gt.prototype,"_forceGeometryBuffer",void 0);C([F()],Gt.prototype,"_ratio",void 0);C([F()],Gt.prototype,"_textureType",void 0);C([F()],Gt.prototype,"radius",void 0);C([F()],Gt.prototype,"base",void 0);C([F("bypassBlur")],Gt.prototype,"_bypassBlur",void 0);C([F("expensiveBlur")],Gt.prototype,"_expensiveBlur",void 0);C([F()],Gt.prototype,"bilateralSamples",void 0);C([F()],Gt.prototype,"bilateralSoften",void 0);C([F()],Gt.prototype,"bilateralTolerance",void 0);B("BABYLON.SSAO2RenderingPipeline",Gt);const Qv="ssaoPixelShader",LV=`uniform sampler2D textureSampler;varying vec2 vUV;
#ifdef SSAO
uniform sampler2D randomSampler;uniform float randTextureTiles;uniform float samplesFactor;uniform vec3 sampleSphere[SAMPLES];uniform float totalStrength;uniform float radius;uniform float area;uniform float fallOff;uniform float base;vec3 normalFromDepth(float depth,vec2 coords)
{vec2 offset1=vec2(0.0,radius);vec2 offset2=vec2(radius,0.0);float depth1=texture2D(textureSampler,coords+offset1).r;float depth2=texture2D(textureSampler,coords+offset2).r;vec3 p1=vec3(offset1,depth1-depth);vec3 p2=vec3(offset2,depth2-depth);vec3 normal=cross(p1,p2);normal.z=-normal.z;return normalize(normal);}
void main()
{vec3 random=normalize(texture2D(randomSampler,vUV*randTextureTiles).rgb);float depth=texture2D(textureSampler,vUV).r;vec3 position=vec3(vUV,depth);vec3 normal=normalFromDepth(depth,vUV);float radiusDepth=radius/depth;float occlusion=0.0;vec3 ray;vec3 hemiRay;float occlusionDepth;float difference;for (int i=0; i<SAMPLES; i++)
{ray=radiusDepth*reflect(sampleSphere[i],random);hemiRay=position+sign(dot(ray,normal))*ray;occlusionDepth=texture2D(textureSampler,clamp(hemiRay.xy,vec2(0.001,0.001),vec2(0.999,0.999))).r;difference=depth-occlusionDepth;occlusion+=step(fallOff,difference)*(1.0-smoothstep(fallOff,area,difference));}
float ao=1.0-totalStrength*occlusion*samplesFactor;float result=clamp(ao+base,0.0,1.0);gl_FragColor.r=result;gl_FragColor.g=result;gl_FragColor.b=result;gl_FragColor.a=1.0;}
#endif
`;P.ShadersStore[Qv]||(P.ShadersStore[Qv]=LV);const Gd="ssaoCombinePixelShader",zP=`uniform sampler2D textureSampler;uniform sampler2D originalColor;uniform vec4 viewport;varying vec2 vUV;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
vec2 uv=viewport.xy+vUV*viewport.zw;vec4 ssaoColor=texture2D(textureSampler,uv);vec4 sceneColor=texture2D(originalColor,uv);gl_FragColor=sceneColor*ssaoColor;
#define CUSTOM_FRAGMENT_MAIN_END
}
`;P.ShadersStore[Gd]||(P.ShadersStore[Gd]=zP);const BV={name:Gd,shader:zP},VV=Object.freeze(Object.defineProperty({__proto__:null,ssaoCombinePixelShader:BV},Symbol.toStringTag,{value:"Module"}));class gl extends sa{get scene(){return this._scene}constructor(e,t,i,r){super(t.getEngine(),e),this.SSAOOriginalSceneColorEffect="SSAOOriginalSceneColorEffect",this.SSAORenderEffect="SSAORenderEffect",this.SSAOBlurHRenderEffect="SSAOBlurHRenderEffect",this.SSAOBlurVRenderEffect="SSAOBlurVRenderEffect",this.SSAOCombineRenderEffect="SSAOCombineRenderEffect",this.totalStrength=1,this.radius=1e-4,this.area=.0075,this.fallOff=1e-6,this.base=.5,this._firstUpdate=!0,this._scene=t,this._createRandomTexture();const s=i.ssaoRatio||i,n=i.combineRatio||i;this._originalColorPostProcess=new Za("SSAOOriginalSceneColor",n,null,Y.BILINEAR_SAMPLINGMODE,t.getEngine(),!1),this._createSSAOPostProcess(s),this._createBlurPostProcess(s),this._createSSAOCombinePostProcess(n),this.addEffect(new Xe(t.getEngine(),this.SSAOOriginalSceneColorEffect,()=>this._originalColorPostProcess,!0)),this.addEffect(new Xe(t.getEngine(),this.SSAORenderEffect,()=>this._ssaoPostProcess,!0)),this.addEffect(new Xe(t.getEngine(),this.SSAOBlurHRenderEffect,()=>this._blurHPostProcess,!0)),this.addEffect(new Xe(t.getEngine(),this.SSAOBlurVRenderEffect,()=>this._blurVPostProcess,!0)),this.addEffect(new Xe(t.getEngine(),this.SSAOCombineRenderEffect,()=>this._ssaoCombinePostProcess,!0)),t.postProcessRenderPipelineManager.addPipeline(this),r&&t.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(e,r)}_attachCameras(e,t){super._attachCameras(e,t);for(const i of this._cameras)this._scene.enableDepthRenderer(i).getDepthMap()}getClassName(){return"SSAORenderingPipeline"}dispose(e=!1){for(let t=0;t<this._scene.cameras.length;t++){const i=this._scene.cameras[t];this._originalColorPostProcess.dispose(i),this._ssaoPostProcess.dispose(i),this._blurHPostProcess.dispose(i),this._blurVPostProcess.dispose(i),this._ssaoCombinePostProcess.dispose(i)}this._randomTexture.dispose(),e&&this._scene.disableDepthRenderer(),this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name,this._scene.cameras),super.dispose()}_createBlurPostProcess(e){this._blurHPostProcess=new zt("BlurH",new Q(1,0),16,e,null,Y.BILINEAR_SAMPLINGMODE,this._scene.getEngine(),!1,0),this._blurVPostProcess=new zt("BlurV",new Q(0,1),16,e,null,Y.BILINEAR_SAMPLINGMODE,this._scene.getEngine(),!1,0),this._blurHPostProcess.onActivateObservable.add(()=>{const i=this._blurHPostProcess.width/this._scene.getEngine().getRenderWidth();this._blurHPostProcess.kernel=16*i}),this._blurVPostProcess.onActivateObservable.add(()=>{const i=this._blurVPostProcess.height/this._scene.getEngine().getRenderHeight();this._blurVPostProcess.kernel=16*i})}_rebuild(){this._firstUpdate=!0,super._rebuild()}_createSSAOPostProcess(e){const i=[.5381,.1856,-.4319,.1379,.2486,.443,.3371,.5679,-.0057,-.6999,-.0451,-.0019,.0689,-.1598,-.8547,.056,.0069,-.1843,-.0146,.1402,.0762,.01,-.1924,-.0344,-.3577,-.5301,-.4358,-.3169,.1063,.0158,.0103,-.5869,.0046,-.0897,-.494,.3287,.7119,-.0154,-.0918,-.0533,.0596,-.5411,.0352,-.0631,.546,-.4776,.2847,-.0271],r=1/16;this._ssaoPostProcess=new Ce("ssao","ssao",["sampleSphere","samplesFactor","randTextureTiles","totalStrength","radius","area","fallOff","base","range","viewport"],["randomSampler"],e,null,Y.BILINEAR_SAMPLINGMODE,this._scene.getEngine(),!1,`#define SAMPLES 16
#define SSAO`),this._ssaoPostProcess.externalTextureSamplerBinding=!0,this._ssaoPostProcess.onApply=s=>{this._firstUpdate&&(s.setArray3("sampleSphere",i),s.setFloat("samplesFactor",r),s.setFloat("randTextureTiles",4)),s.setFloat("totalStrength",this.totalStrength),s.setFloat("radius",this.radius),s.setFloat("area",this.area),s.setFloat("fallOff",this.fallOff),s.setFloat("base",this.base),s.setTexture("textureSampler",this._scene.enableDepthRenderer(this._scene.activeCamera).getDepthMap()),s.setTexture("randomSampler",this._randomTexture)}}_createSSAOCombinePostProcess(e){this._ssaoCombinePostProcess=new Ce("ssaoCombine","ssaoCombine",[],["originalColor","viewport"],e,null,Y.BILINEAR_SAMPLINGMODE,this._scene.getEngine(),!1),this._ssaoCombinePostProcess.onApply=t=>{t.setVector4("viewport",V.Vector4[0].copyFromFloats(0,0,1,1)),t.setTextureFromPostProcess("originalColor",this._originalColorPostProcess)}}_createRandomTexture(){const t=new Uint8Array(1048576);for(let r=0;r<t.length;)t[r++]=Math.floor(Math.max(0,Ne(-1,1))*255),t[r++]=Math.floor(Math.max(0,Ne(-1,1))*255),t[r++]=Math.floor(Math.max(0,Ne(-1,1))*255),t[r++]=255;const i=qt.CreateRGBATexture(t,512,512,this._scene,!1,!1,2);i.name="SSAORandomTexture",i.wrapU=Y.WRAP_ADDRESSMODE,i.wrapV=Y.WRAP_ADDRESSMODE,this._randomTexture=i}}C([F()],gl.prototype,"totalStrength",void 0);C([F()],gl.prototype,"radius",void 0);C([F()],gl.prototype,"area",void 0);C([F()],gl.prototype,"fallOff",void 0);C([F()],gl.prototype,"base",void 0);class kV{constructor(){this.enabled=!1,this.name="screenSpaceReflections",this.texturesRequired=[6,3,1]}}const Kv="screenSpaceReflectionPixelShader",zV=`uniform sampler2D textureSampler;
#ifdef SSR_SUPPORTED
uniform sampler2D reflectivitySampler;uniform sampler2D normalSampler;uniform sampler2D positionSampler;
#endif
uniform mat4 view;uniform mat4 projection;uniform float stepSize;uniform float strength;uniform float threshold;uniform float roughnessFactor;uniform float reflectionSpecularFalloffExponent;varying vec2 vUV;
#ifdef SSR_SUPPORTED
struct ReflectionInfo {vec3 color;vec4 coords;};/**
* According to specular,see https:
*/
vec3 fresnelSchlick(float cosTheta,vec3 F0)
{return F0+(1.0-F0)*pow(1.0-cosTheta,5.0);}
/**
* Once the pixel's coordinates has been found,let's adjust (smooth) a little bit
* by sampling multiple reflection pixels.
*/
ReflectionInfo smoothReflectionInfo(vec3 dir,vec3 hitCoord)
{ReflectionInfo info;info.color=vec3(0.0);vec4 projectedCoord;float sampledDepth;for(int i=0; i<SMOOTH_STEPS; i++)
{projectedCoord=projection*vec4(hitCoord,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);sampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;float depth=sampledDepth-hitCoord.z;dir*=0.5;if(depth>0.0)
hitCoord-=dir;else
hitCoord+=dir;info.color+=texture2D(textureSampler,projectedCoord.xy).rgb;}
projectedCoord=projection*vec4(hitCoord,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);info.coords=vec4(projectedCoord.xy,sampledDepth,1.0);info.color+=texture2D(textureSampler,projectedCoord.xy).rgb;info.color/=float(SMOOTH_STEPS+1);return info;}
/**
* Tests the given world position (hitCoord) according to the given reflection vector (dir)
* until it finds a collision (means that depth is enough close to say "it's the pixel to sample!").
*/
ReflectionInfo getReflectionInfo(vec3 dir,vec3 hitCoord)
{ReflectionInfo info;vec4 projectedCoord;float sampledDepth;dir*=stepSize;for(int i=0; i<REFLECTION_SAMPLES; i++)
{hitCoord+=dir;projectedCoord=projection*vec4(hitCoord,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);sampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;float depth=sampledDepth-hitCoord.z;
#ifdef RIGHT_HANDED_SCENE
depth*=-1.0;
#endif
if(((depth-dir.z)<threshold) && depth<=0.0)
{
#ifdef ENABLE_SMOOTH_REFLECTIONS
return smoothReflectionInfo(dir,hitCoord);
#else
info.color=texture2D(textureSampler,projectedCoord.xy).rgb;info.coords=vec4(projectedCoord.xy,sampledDepth,0.0);return info;
#endif
}}
info.color=texture2D(textureSampler,projectedCoord.xy).rgb;info.coords=vec4(projectedCoord.xy,sampledDepth,0.0);return info;}
vec3 hash(vec3 a)
{a=fract(a*0.8);a+=dot(a,a.yxz+19.19);return fract((a.xxy+a.yxx)*a.zyx);}
#endif
void main()
{
#ifdef SSR_SUPPORTED
vec4 albedoFull=texture2D(textureSampler,vUV);vec3 albedo=albedoFull.rgb;float spec=texture2D(reflectivitySampler,vUV).r;if (spec==0.0) {gl_FragColor=albedoFull;return;}
vec3 normal=(texture2D(normalSampler,vUV)).xyz;vec3 position=(view*texture2D(positionSampler,vUV)).xyz;vec3 reflected=normalize(reflect(normalize(position),normalize(normal)));float roughness=1.0-texture2D(reflectivitySampler,vUV).a;vec3 jitt=mix(vec3(0.0),hash(position),roughness)*roughnessFactor;ReflectionInfo info=getReflectionInfo(jitt+reflected,position);vec2 dCoords=smoothstep(0.2,0.6,abs(vec2(0.5,0.5)-info.coords.xy));float screenEdgefactor=clamp(1.0-(dCoords.x+dCoords.y),0.0,1.0);vec3 F0=vec3(0.04);F0 =mix(F0,albedo,spec);vec3 fresnel=fresnelSchlick(max(dot(normalize(normal),normalize(position)),0.0),F0);
#ifdef RIGHT_HANDED_SCENE
reflected.z*=-1.0;
#endif
float reflectionMultiplier=clamp(pow(spec*strength,reflectionSpecularFalloffExponent)*screenEdgefactor*reflected.z,0.0,0.9);float albedoMultiplier=1.0-reflectionMultiplier;vec3 SSR=info.color*fresnel;gl_FragColor=vec4((albedo*albedoMultiplier)+(SSR*reflectionMultiplier),albedoFull.a);
#else
gl_FragColor=texture2D(textureSampler,vUV);
#endif
}
`;P.ShadersStore[Kv]||(P.ShadersStore[Kv]=zV);class Er extends Ce{get _geometryBufferRenderer(){return this._forceGeometryBuffer?this._scene.geometryBufferRenderer:null}get _prePassRenderer(){return this._forceGeometryBuffer?null:this._scene.prePassRenderer}getClassName(){return"ScreenSpaceReflectionPostProcess"}constructor(e,t,i,r,s,n,o,l=0,u=!1,c=!1){if(super(e,"screenSpaceReflection",["projection","view","threshold","reflectionSpecularFalloffExponent","strength","stepSize","roughnessFactor"],["textureSampler","normalSampler","positionSampler","reflectivitySampler"],i,r,s,n,o,`#define SSR_SUPPORTED
#define REFLECTION_SAMPLES 64
#define SMOOTH_STEPS 5
`,l,void 0,null,u),this.threshold=1.2,this.strength=1,this.reflectionSpecularFalloffExponent=3,this.step=1,this.roughnessFactor=.2,this._forceGeometryBuffer=!1,this._enableSmoothReflections=!1,this._reflectionSamples=64,this._smoothSteps=5,this._forceGeometryBuffer=c,this._forceGeometryBuffer){const h=t.enableGeometryBufferRenderer();h&&h.isSupported&&(h.enablePosition=!0,h.enableReflectivity=!0,h.generateNormalsInWorldSpace&&L.Error("ScreenSpaceReflectionPostProcess does not support generateNormalsInWorldSpace=true for the geometry buffer renderer!"))}else{const h=t.enablePrePassRenderer();h==null||h.markAsDirty(),h!=null&&h.generateNormalsInWorldSpace&&L.Error("ScreenSpaceReflectionPostProcess does not support generateNormalsInWorldSpace=true for the prepass renderer!"),this._prePassEffectConfiguration=new kV}this._updateEffectDefines(),this.onApply=h=>{const d=this._geometryBufferRenderer,f=this._prePassRenderer;if(!f&&!d)return;if(d){const S=d.getTextureIndex(Re.POSITION_TEXTURE_TYPE),b=d.getTextureIndex(Re.REFLECTIVITY_TEXTURE_TYPE);h.setTexture("normalSampler",d.getGBuffer().textures[1]),h.setTexture("positionSampler",d.getGBuffer().textures[S]),h.setTexture("reflectivitySampler",d.getGBuffer().textures[b])}else if(f){const S=f.getIndex(1),b=f.getIndex(3),y=f.getIndex(6);h.setTexture("normalSampler",f.getRenderTarget().textures[y]),h.setTexture("positionSampler",f.getRenderTarget().textures[S]),h.setTexture("reflectivitySampler",f.getRenderTarget().textures[b])}const p=t.activeCamera;if(!p)return;const g=p.getViewMatrix(!0),_=p.getProjectionMatrix(!0);h.setMatrix("projection",_),h.setMatrix("view",g),h.setFloat("threshold",this.threshold),h.setFloat("reflectionSpecularFalloffExponent",this.reflectionSpecularFalloffExponent),h.setFloat("strength",this.strength),h.setFloat("stepSize",this.step),h.setFloat("roughnessFactor",this.roughnessFactor)},this._isSceneRightHanded=t.useRightHandedSystem}get enableSmoothReflections(){return this._enableSmoothReflections}set enableSmoothReflections(e){e!==this._enableSmoothReflections&&(this._enableSmoothReflections=e,this._updateEffectDefines())}get reflectionSamples(){return this._reflectionSamples}set reflectionSamples(e){e!==this._reflectionSamples&&(this._reflectionSamples=e,this._updateEffectDefines())}get smoothSteps(){return this._smoothSteps}set smoothSteps(e){e!==this._smoothSteps&&(this._smoothSteps=e,this._updateEffectDefines())}_updateEffectDefines(){const e=[];(this._geometryBufferRenderer||this._prePassRenderer)&&e.push("#define SSR_SUPPORTED"),this._enableSmoothReflections&&e.push("#define ENABLE_SMOOTH_REFLECTIONS"),this._isSceneRightHanded&&e.push("#define RIGHT_HANDED_SCENE"),e.push("#define REFLECTION_SAMPLES "+(this._reflectionSamples>>0)),e.push("#define SMOOTH_STEPS "+(this._smoothSteps>>0)),this.updateEffect(e.join(`
`))}static _Parse(e,t,i,r){return Me.Parse(()=>new Er(e.name,i,e.options,t,e.renderTargetSamplingMode,i.getEngine(),e.textureType,e.reusable),e,i,r)}}C([F()],Er.prototype,"threshold",void 0);C([F()],Er.prototype,"strength",void 0);C([F()],Er.prototype,"reflectionSpecularFalloffExponent",void 0);C([F()],Er.prototype,"step",void 0);C([F()],Er.prototype,"roughnessFactor",void 0);C([F()],Er.prototype,"enableSmoothReflections",null);C([F()],Er.prototype,"reflectionSamples",null);C([F()],Er.prototype,"smoothSteps",null);B("BABYLON.ScreenSpaceReflectionPostProcess",Er);const Jv="standardPixelShader",UV=`uniform sampler2D textureSampler;varying vec2 vUV;
#define CUSTOM_FRAGMENT_DEFINITIONS
#if defined(PASS_POST_PROCESS)
void main(void)
{vec4 color=texture2D(textureSampler,vUV);gl_FragColor=color;}
#endif
#if defined(DOWN_SAMPLE_X4)
uniform vec2 dsOffsets[16];void main(void)
{vec4 average=vec4(0.0,0.0,0.0,0.0);average=texture2D(textureSampler,vUV+dsOffsets[0]);average+=texture2D(textureSampler,vUV+dsOffsets[1]);average+=texture2D(textureSampler,vUV+dsOffsets[2]);average+=texture2D(textureSampler,vUV+dsOffsets[3]);average+=texture2D(textureSampler,vUV+dsOffsets[4]);average+=texture2D(textureSampler,vUV+dsOffsets[5]);average+=texture2D(textureSampler,vUV+dsOffsets[6]);average+=texture2D(textureSampler,vUV+dsOffsets[7]);average+=texture2D(textureSampler,vUV+dsOffsets[8]);average+=texture2D(textureSampler,vUV+dsOffsets[9]);average+=texture2D(textureSampler,vUV+dsOffsets[10]);average+=texture2D(textureSampler,vUV+dsOffsets[11]);average+=texture2D(textureSampler,vUV+dsOffsets[12]);average+=texture2D(textureSampler,vUV+dsOffsets[13]);average+=texture2D(textureSampler,vUV+dsOffsets[14]);average+=texture2D(textureSampler,vUV+dsOffsets[15]);average/=16.0;gl_FragColor=average;}
#endif
#if defined(BRIGHT_PASS)
uniform vec2 dsOffsets[4];uniform float brightThreshold;void main(void)
{vec4 average=vec4(0.0,0.0,0.0,0.0);average=texture2D(textureSampler,vUV+vec2(dsOffsets[0].x,dsOffsets[0].y));average+=texture2D(textureSampler,vUV+vec2(dsOffsets[1].x,dsOffsets[1].y));average+=texture2D(textureSampler,vUV+vec2(dsOffsets[2].x,dsOffsets[2].y));average+=texture2D(textureSampler,vUV+vec2(dsOffsets[3].x,dsOffsets[3].y));average*=0.25;float luminance=length(average.rgb);if (luminance<brightThreshold) {average=vec4(0.0,0.0,0.0,1.0);}
gl_FragColor=average;}
#endif
#if defined(TEXTURE_ADDER)
uniform sampler2D otherSampler;uniform sampler2D lensSampler;uniform float exposure;void main(void)
{vec3 colour=texture2D(textureSampler,vUV).rgb;colour*=exposure;vec3 X=max(vec3(0.0,0.0,0.0),colour-0.004);vec3 retColor=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);colour=retColor*retColor;colour+=colour*texture2D(lensSampler,vUV).rgb;vec4 finalColor=vec4(colour.rgb,1.0)+texture2D(otherSampler,vUV);gl_FragColor=finalColor;}
#endif
#if defined(VLS)
#define PI 3.1415926535897932384626433832795
uniform mat4 shadowViewProjection;uniform mat4 lightWorld;uniform vec3 cameraPosition;uniform vec3 sunDirection;uniform vec3 sunColor;uniform vec2 depthValues;uniform float scatteringCoefficient;uniform float scatteringPower;uniform sampler2D shadowMapSampler;uniform sampler2D positionSampler;float computeScattering(float lightDotView)
{float result=1.0-scatteringCoefficient*scatteringCoefficient;result/=(4.0*PI*pow(1.0+scatteringCoefficient*scatteringCoefficient-(2.0*scatteringCoefficient)*lightDotView,1.5));return result;}
void main(void)
{vec3 worldPos=texture2D(positionSampler,vUV).rgb;vec3 startPosition=cameraPosition;vec3 rayVector=worldPos-startPosition;float rayLength=length(rayVector);vec3 rayDirection=rayVector/rayLength;float stepLength=rayLength/NB_STEPS;vec3 stepL=rayDirection*stepLength;vec3 currentPosition=startPosition;vec3 accumFog=vec3(0.0);for (int i=0; i<int(NB_STEPS); i++)
{vec4 worldInShadowCameraSpace=shadowViewProjection*vec4(currentPosition,1.0);float depthMetric= (worldInShadowCameraSpace.z+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depthMetric,0.0,1.0);worldInShadowCameraSpace.xyz/=worldInShadowCameraSpace.w;worldInShadowCameraSpace.xyz=0.5*worldInShadowCameraSpace.xyz+vec3(0.5);float shadowMapValue=texture2D(shadowMapSampler,worldInShadowCameraSpace.xy).r;if (shadowMapValue>shadowPixelDepth)
accumFog+=sunColor*computeScattering(dot(rayDirection,sunDirection));currentPosition+=stepL;}
accumFog/=NB_STEPS;vec3 color=accumFog*scatteringPower;gl_FragColor=vec4(color*exp(color) ,1.0);}
#endif
#if defined(VLSMERGE)
uniform sampler2D originalSampler;void main(void)
{gl_FragColor=texture2D(originalSampler,vUV)+texture2D(textureSampler,vUV);}
#endif
#if defined(LUMINANCE)
uniform vec2 lumOffsets[4];void main()
{float average=0.0;vec4 color=vec4(0.0);float maximum=-1e20;vec3 weight=vec3(0.299,0.587,0.114);for (int i=0; i<4; i++)
{color=texture2D(textureSampler,vUV+ lumOffsets[i]);float GreyValue=dot(color.rgb,vec3(0.33,0.33,0.33));
#ifdef WEIGHTED_AVERAGE
float GreyValue=dot(color.rgb,weight);
#endif
#ifdef BRIGHTNESS
float GreyValue=max(color.r,max(color.g,color.b));
#endif
#ifdef HSL_COMPONENT
float GreyValue=0.5*(max(color.r,max(color.g,color.b))+min(color.r,min(color.g,color.b)));
#endif
#ifdef MAGNITUDE
float GreyValue=length(color.rgb);
#endif
maximum=max(maximum,GreyValue);average+=(0.25*log(1e-5+GreyValue));}
average=exp(average);gl_FragColor=vec4(average,maximum,0.0,1.0);}
#endif
#if defined(LUMINANCE_DOWN_SAMPLE)
uniform vec2 dsOffsets[9];uniform float halfDestPixelSize;
#ifdef FINAL_DOWN_SAMPLER
#include<packingFunctions>
#endif
void main()
{vec4 color=vec4(0.0);float average=0.0;for (int i=0; i<9; i++)
{color=texture2D(textureSampler,vUV+vec2(halfDestPixelSize,halfDestPixelSize)+dsOffsets[i]);average+=color.r;}
average/=9.0;
#ifdef FINAL_DOWN_SAMPLER
gl_FragColor=pack(average);
#else
gl_FragColor=vec4(average,average,0.0,1.0);
#endif
}
#endif
#if defined(HDR)
uniform sampler2D textureAdderSampler;uniform float averageLuminance;void main()
{vec4 color=texture2D(textureAdderSampler,vUV);
#ifndef AUTO_EXPOSURE
vec4 adjustedColor=color/averageLuminance;color=adjustedColor;color.a=1.0;
#endif
gl_FragColor=color;}
#endif
#if defined(LENS_FLARE)
#define GHOSTS 3
uniform sampler2D lensColorSampler;uniform float strength;uniform float ghostDispersal;uniform float haloWidth;uniform vec2 resolution;uniform float distortionStrength;float hash(vec2 p)
{float h=dot(p,vec2(127.1,311.7));return -1.0+2.0*fract(sin(h)*43758.5453123);}
float noise(in vec2 p)
{vec2 i=floor(p);vec2 f=fract(p);vec2 u=f*f*(3.0-2.0*f);return mix(mix(hash(i+vec2(0.0,0.0)),
hash(i+vec2(1.0,0.0)),u.x),
mix(hash(i+vec2(0.0,1.0)),
hash(i+vec2(1.0,1.0)),u.x),u.y);}
float fbm(vec2 p)
{float f=0.0;f+=0.5000*noise(p); p*=2.02;f+=0.2500*noise(p); p*=2.03;f+=0.1250*noise(p); p*=2.01;f+=0.0625*noise(p); p*=2.04;f/=0.9375;return f;}
vec3 pattern(vec2 uv)
{vec2 p=-1.0+2.0*uv;float p2=dot(p,p);float f=fbm(vec2(15.0*p2))/2.0;float r=0.2+0.6*sin(12.5*length(uv-vec2(0.5)));float g=0.2+0.6*sin(20.5*length(uv-vec2(0.5)));float b=0.2+0.6*sin(17.2*length(uv-vec2(0.5)));return (1.0-f)*vec3(r,g,b);}
float luminance(vec3 color)
{return dot(color.rgb,vec3(0.2126,0.7152,0.0722));}
vec4 textureDistorted(sampler2D tex,vec2 texcoord,vec2 direction,vec3 distortion)
{return vec4(
texture2D(tex,texcoord+direction*distortion.r).r,
texture2D(tex,texcoord+direction*distortion.g).g,
texture2D(tex,texcoord+direction*distortion.b).b,
1.0
);}
void main(void)
{vec2 uv=-vUV+vec2(1.0);vec2 ghostDir=(vec2(0.5)-uv)*ghostDispersal;vec2 texelSize=1.0/resolution;vec3 distortion=vec3(-texelSize.x*distortionStrength,0.0,texelSize.x*distortionStrength);vec4 result=vec4(0.0);float ghostIndice=1.0;for (int i=0; i<GHOSTS; ++i)
{vec2 offset=fract(uv+ghostDir*ghostIndice);float weight=length(vec2(0.5)-offset)/length(vec2(0.5));weight=pow(1.0-weight,10.0);result+=textureDistorted(textureSampler,offset,normalize(ghostDir),distortion)*weight*strength;ghostIndice+=1.0;}
vec2 haloVec=normalize(ghostDir)*haloWidth;float weight=length(vec2(0.5)-fract(uv+haloVec))/length(vec2(0.5));weight=pow(1.0-weight,10.0);result+=textureDistorted(textureSampler,fract(uv+haloVec),normalize(ghostDir),distortion)*weight*strength;result*=texture2D(lensColorSampler,vec2(length(vec2(0.5)-uv)/length(vec2(0.5))));gl_FragColor=result;}
#endif
#if defined(LENS_FLARE_COMPOSE)
uniform sampler2D otherSampler;uniform sampler2D lensDirtSampler;uniform sampler2D lensStarSampler;uniform mat4 lensStarMatrix;void main(void)
{vec2 lensFlareCoords=(lensStarMatrix*vec4(vUV,1.0,1.0)).xy;vec4 lensMod=texture2D(lensDirtSampler,vUV);lensMod+=texture2D(lensStarSampler,vUV/*lensFlareCoords*/);vec4 result=texture2D(textureSampler,vUV)*lensMod;gl_FragColor=texture2D(otherSampler,vUV)+result;}
#endif
#if defined(DEPTH_OF_FIELD)
uniform sampler2D otherSampler;uniform sampler2D depthSampler;uniform float distance;void main(void)
{vec4 sharp=texture2D(otherSampler,vUV);vec4 blur=texture2D(textureSampler,vUV);float dist=clamp(texture2D(depthSampler,vUV).r*distance,0.0,1.0);float factor=0.0;if (dist<0.05)
factor=1.0;else if (dist<0.1)
factor=20.0*(0.1-dist);else if (dist<0.5)
factor=0.0;else
factor=2.0*(dist-0.5);factor=clamp(factor,0.0,0.90);gl_FragColor=mix(sharp,blur,factor);}
#endif
#if defined(MOTION_BLUR)
uniform mat4 inverseViewProjection;uniform mat4 prevViewProjection;uniform vec2 screenSize;uniform float motionScale;uniform float motionStrength;uniform sampler2D depthSampler;void main(void)
{vec2 texelSize=1.0/screenSize;float depth=texture2D(depthSampler,vUV).r;vec4 cpos=vec4(vUV*2.0-1.0,depth,1.0);cpos=cpos*inverseViewProjection;vec4 ppos=cpos*prevViewProjection;ppos.xyz/=ppos.w;ppos.xy=ppos.xy*0.5+0.5;vec2 velocity=(ppos.xy-vUV)*motionScale*motionStrength;float speed=length(velocity/texelSize);int nSamples=int(clamp(speed,1.0,MAX_MOTION_SAMPLES));vec4 result=texture2D(textureSampler,vUV);for (int i=1; i<int(MAX_MOTION_SAMPLES); ++i) {if (i>=nSamples)
break;vec2 offset1=vUV+velocity*(float(i)/float(nSamples-1)-0.5);result+=texture2D(textureSampler,offset1);}
gl_FragColor=result/float(nSamples);}
#endif
`;P.ShadersStore[Jv]||(P.ShadersStore[Jv]=UV);class qe extends sa{get exposure(){return this._fixedExposure}set exposure(e){this._fixedExposure=e,this._currentExposure=e}get hdrAutoExposure(){return this._hdrAutoExposure}set hdrAutoExposure(e){if(this._hdrAutoExposure=e,this.hdrPostProcess){const t=["#define HDR"];e&&t.push("#define AUTO_EXPOSURE"),this.hdrPostProcess.updateEffect(t.join(`
`))}}get motionStrength(){return this._motionStrength}set motionStrength(e){this._motionStrength=e,this._isObjectBasedMotionBlur&&this.motionBlurPostProcess&&(this.motionBlurPostProcess.motionStrength=e)}get objectBasedMotionBlur(){return this._isObjectBasedMotionBlur}set objectBasedMotionBlur(e){const t=this._isObjectBasedMotionBlur!==e;this._isObjectBasedMotionBlur=e,t&&this._buildPipeline()}get BloomEnabled(){return this._bloomEnabled}set BloomEnabled(e){this._bloomEnabled!==e&&(this._bloomEnabled=e,this._buildPipeline())}get DepthOfFieldEnabled(){return this._depthOfFieldEnabled}set DepthOfFieldEnabled(e){this._depthOfFieldEnabled!==e&&(this._depthOfFieldEnabled=e,this._buildPipeline())}get LensFlareEnabled(){return this._lensFlareEnabled}set LensFlareEnabled(e){this._lensFlareEnabled!==e&&(this._lensFlareEnabled=e,this._buildPipeline())}get HDREnabled(){return this._hdrEnabled}set HDREnabled(e){this._hdrEnabled!==e&&(this._hdrEnabled=e,this._buildPipeline())}get VLSEnabled(){return this._vlsEnabled}set VLSEnabled(e){if(this._vlsEnabled!==e){if(e&&!this._scene.enableGeometryBufferRenderer()){L.Warn("Geometry renderer is not supported, cannot create volumetric lights in Standard Rendering Pipeline");return}this._vlsEnabled=e,this._buildPipeline()}}get MotionBlurEnabled(){return this._motionBlurEnabled}set MotionBlurEnabled(e){this._motionBlurEnabled!==e&&(this._motionBlurEnabled=e,this._buildPipeline())}get fxaaEnabled(){return this._fxaaEnabled}set fxaaEnabled(e){this._fxaaEnabled!==e&&(this._fxaaEnabled=e,this._buildPipeline())}get screenSpaceReflectionsEnabled(){return this._screenSpaceReflectionsEnabled}set screenSpaceReflectionsEnabled(e){this._screenSpaceReflectionsEnabled!==e&&(this._screenSpaceReflectionsEnabled=e,this._buildPipeline())}get volumetricLightStepsCount(){return this._volumetricLightStepsCount}set volumetricLightStepsCount(e){this.volumetricLightPostProcess&&this.volumetricLightPostProcess.updateEffect(`#define VLS
#define NB_STEPS `+e.toFixed(1)),this._volumetricLightStepsCount=e}get motionBlurSamples(){return this._motionBlurSamples}set motionBlurSamples(e){this.motionBlurPostProcess&&(this._isObjectBasedMotionBlur?this.motionBlurPostProcess.motionBlurSamples=e:this.motionBlurPostProcess.updateEffect(`#define MOTION_BLUR
#define MAX_MOTION_SAMPLES `+e.toFixed(1))),this._motionBlurSamples=e}get samples(){return this._samples}set samples(e){this._samples!==e&&(this._samples=e,this._buildPipeline())}constructor(e,t,i,r=null,s){super(t.getEngine(),e),this.downSampleX4PostProcess=null,this.brightPassPostProcess=null,this.blurHPostProcesses=[],this.blurVPostProcesses=[],this.textureAdderPostProcess=null,this.volumetricLightPostProcess=null,this.volumetricLightSmoothXPostProcess=null,this.volumetricLightSmoothYPostProcess=null,this.volumetricLightMergePostProces=null,this.volumetricLightFinalPostProcess=null,this.luminancePostProcess=null,this.luminanceDownSamplePostProcesses=[],this.hdrPostProcess=null,this.textureAdderFinalPostProcess=null,this.lensFlareFinalPostProcess=null,this.hdrFinalPostProcess=null,this.lensFlarePostProcess=null,this.lensFlareComposePostProcess=null,this.motionBlurPostProcess=null,this.depthOfFieldPostProcess=null,this.fxaaPostProcess=null,this.screenSpaceReflectionPostProcess=null,this.brightThreshold=1,this.blurWidth=512,this.horizontalBlur=!1,this.lensTexture=null,this.volumetricLightCoefficient=.2,this.volumetricLightPower=4,this.volumetricLightBlurScale=64,this.sourceLight=null,this.hdrMinimumLuminance=1,this.hdrDecreaseRate=.5,this.hdrIncreaseRate=.5,this.lensColorTexture=null,this.lensFlareStrength=20,this.lensFlareGhostDispersal=1.4,this.lensFlareHaloWidth=.7,this.lensFlareDistortionStrength=16,this.lensFlareBlurWidth=512,this.lensStarTexture=null,this.lensFlareDirtTexture=null,this.depthOfFieldDistance=10,this.depthOfFieldBlurWidth=64,this.animations=[],this._currentDepthOfFieldSource=null,this._fixedExposure=1,this._currentExposure=1,this._hdrAutoExposure=!1,this._hdrCurrentLuminance=1,this._motionStrength=1,this._isObjectBasedMotionBlur=!1,this._camerasToBeAttached=[],this._bloomEnabled=!1,this._depthOfFieldEnabled=!1,this._vlsEnabled=!1,this._lensFlareEnabled=!1,this._hdrEnabled=!1,this._motionBlurEnabled=!1,this._fxaaEnabled=!1,this._screenSpaceReflectionsEnabled=!1,this._motionBlurSamples=64,this._volumetricLightStepsCount=50,this._samples=1,this._cameras=s||t.cameras,this._cameras=this._cameras.slice(),this._camerasToBeAttached=this._cameras.slice(),this._scene=t,this._basePostProcess=r,this._ratio=i,this._floatTextureType=t.getEngine().getCaps().textureFloatRender?1:2,t.postProcessRenderPipelineManager.addPipeline(this),this._buildPipeline()}_buildPipeline(){const e=this._ratio,t=this._scene;this._disposePostProcesses(),this._cameras!==null&&(this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name,this._cameras),this._cameras=this._camerasToBeAttached.slice()),this._reset(),this._screenSpaceReflectionsEnabled&&(this.screenSpaceReflectionPostProcess=new Er("HDRPass",t,e,null,Y.BILINEAR_SAMPLINGMODE,t.getEngine(),!1,this._floatTextureType),this.screenSpaceReflectionPostProcess.onApplyObservable.add(()=>{this._currentDepthOfFieldSource=this.screenSpaceReflectionPostProcess}),this.addEffect(new Xe(t.getEngine(),"HDRScreenSpaceReflections",()=>this.screenSpaceReflectionPostProcess,!0))),this._basePostProcess?this.originalPostProcess=this._basePostProcess:this.originalPostProcess=new Ce("HDRPass","standard",[],[],e,null,Y.BILINEAR_SAMPLINGMODE,t.getEngine(),!1,"#define PASS_POST_PROCESS",this._floatTextureType),this.originalPostProcess.autoClear=!this.screenSpaceReflectionPostProcess,this.originalPostProcess.onApplyObservable.add(()=>{this._currentDepthOfFieldSource=this.originalPostProcess}),this.addEffect(new Xe(t.getEngine(),"HDRPassPostProcess",()=>this.originalPostProcess,!0)),this._bloomEnabled&&(this._createDownSampleX4PostProcess(t,e/4),this._createBrightPassPostProcess(t,e/4),this._createBlurPostProcesses(t,e/4,1),this._createTextureAdderPostProcess(t,e),this.textureAdderFinalPostProcess=new Ce("HDRDepthOfFieldSource","standard",[],[],e,null,Y.BILINEAR_SAMPLINGMODE,t.getEngine(),!1,"#define PASS_POST_PROCESS",0),this.addEffect(new Xe(t.getEngine(),"HDRBaseDepthOfFieldSource",()=>this.textureAdderFinalPostProcess,!0))),this._vlsEnabled&&(this._createVolumetricLightPostProcess(t,e),this.volumetricLightFinalPostProcess=new Ce("HDRVLSFinal","standard",[],[],e,null,Y.BILINEAR_SAMPLINGMODE,t.getEngine(),!1,"#define PASS_POST_PROCESS",0),this.addEffect(new Xe(t.getEngine(),"HDRVLSFinal",()=>this.volumetricLightFinalPostProcess,!0))),this._lensFlareEnabled&&(this._createLensFlarePostProcess(t,e),this.lensFlareFinalPostProcess=new Ce("HDRPostLensFlareDepthOfFieldSource","standard",[],[],e,null,Y.BILINEAR_SAMPLINGMODE,t.getEngine(),!1,"#define PASS_POST_PROCESS",0),this.addEffect(new Xe(t.getEngine(),"HDRPostLensFlareDepthOfFieldSource",()=>this.lensFlareFinalPostProcess,!0))),this._hdrEnabled&&(this._createLuminancePostProcesses(t,this._floatTextureType),this._createHdrPostProcess(t,e),this.hdrFinalPostProcess=new Ce("HDRPostHDReDepthOfFieldSource","standard",[],[],e,null,Y.BILINEAR_SAMPLINGMODE,t.getEngine(),!1,"#define PASS_POST_PROCESS",0),this.addEffect(new Xe(t.getEngine(),"HDRPostHDReDepthOfFieldSource",()=>this.hdrFinalPostProcess,!0))),this._depthOfFieldEnabled&&(this._createBlurPostProcesses(t,e/2,3,"depthOfFieldBlurWidth"),this._createDepthOfFieldPostProcess(t,e)),this._motionBlurEnabled&&this._createMotionBlurPostProcess(t,e),this._fxaaEnabled&&(this.fxaaPostProcess=new lo("fxaa",1,null,Y.BILINEAR_SAMPLINGMODE,t.getEngine(),!1,0),this.addEffect(new Xe(t.getEngine(),"HDRFxaa",()=>this.fxaaPostProcess,!0))),this._cameras!==null&&this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name,this._cameras),!this._enableMSAAOnFirstPostProcess(this._samples)&&this._samples>1&&L.Warn("MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0")}_createDownSampleX4PostProcess(e,t){const i=new Array(32);this.downSampleX4PostProcess=new Ce("HDRDownSampleX4","standard",["dsOffsets"],[],t,null,Y.BILINEAR_SAMPLINGMODE,e.getEngine(),!1,"#define DOWN_SAMPLE_X4",this._floatTextureType),this.downSampleX4PostProcess.onApply=r=>{let s=0;const n=this.downSampleX4PostProcess.width,o=this.downSampleX4PostProcess.height;for(let l=-2;l<2;l++)for(let u=-2;u<2;u++)i[s]=(l+.5)*(1/n),i[s+1]=(u+.5)*(1/o),s+=2;r.setArray2("dsOffsets",i)},this.addEffect(new Xe(e.getEngine(),"HDRDownSampleX4",()=>this.downSampleX4PostProcess,!0))}_createBrightPassPostProcess(e,t){const i=new Array(8);this.brightPassPostProcess=new Ce("HDRBrightPass","standard",["dsOffsets","brightThreshold"],[],t,null,Y.BILINEAR_SAMPLINGMODE,e.getEngine(),!1,"#define BRIGHT_PASS",this._floatTextureType),this.brightPassPostProcess.onApply=r=>{const s=1/this.brightPassPostProcess.width,n=1/this.brightPassPostProcess.height;i[0]=-.5*s,i[1]=.5*n,i[2]=.5*s,i[3]=.5*n,i[4]=-.5*s,i[5]=-.5*n,i[6]=.5*s,i[7]=-.5*n,r.setArray2("dsOffsets",i),r.setFloat("brightThreshold",this.brightThreshold)},this.addEffect(new Xe(e.getEngine(),"HDRBrightPass",()=>this.brightPassPostProcess,!0))}_createBlurPostProcesses(e,t,i,r="blurWidth"){const s=e.getEngine(),n=new zt("HDRBlurH_"+i,new Q(1,0),this[r],t,null,Y.BILINEAR_SAMPLINGMODE,e.getEngine(),!1,this._floatTextureType),o=new zt("HDRBlurV_"+i,new Q(0,1),this[r],t,null,Y.BILINEAR_SAMPLINGMODE,e.getEngine(),!1,this._floatTextureType);n.onActivateObservable.add(()=>{const l=n.width/s.getRenderWidth();n.kernel=this[r]*l}),o.onActivateObservable.add(()=>{const l=o.height/s.getRenderHeight();o.kernel=this.horizontalBlur?64*l:this[r]*l}),this.addEffect(new Xe(e.getEngine(),"HDRBlurH"+i,()=>n,!0)),this.addEffect(new Xe(e.getEngine(),"HDRBlurV"+i,()=>o,!0)),this.blurHPostProcesses.push(n),this.blurVPostProcesses.push(o)}_createTextureAdderPostProcess(e,t){this.textureAdderPostProcess=new Ce("HDRTextureAdder","standard",["exposure"],["otherSampler","lensSampler"],t,null,Y.BILINEAR_SAMPLINGMODE,e.getEngine(),!1,"#define TEXTURE_ADDER",this._floatTextureType),this.textureAdderPostProcess.onApply=i=>{i.setTextureFromPostProcess("otherSampler",this._vlsEnabled?this._currentDepthOfFieldSource:this.originalPostProcess),i.setTexture("lensSampler",this.lensTexture),i.setFloat("exposure",this._currentExposure),this._currentDepthOfFieldSource=this.textureAdderFinalPostProcess},this.addEffect(new Xe(e.getEngine(),"HDRTextureAdder",()=>this.textureAdderPostProcess,!0))}_createVolumetricLightPostProcess(e,t){const i=e.enableGeometryBufferRenderer();i.enablePosition=!0;const r=i.getGBuffer();this.volumetricLightPostProcess=new Ce("HDRVLS","standard",["shadowViewProjection","cameraPosition","sunDirection","sunColor","scatteringCoefficient","scatteringPower","depthValues"],["shadowMapSampler","positionSampler"],t/8,null,Y.BILINEAR_SAMPLINGMODE,e.getEngine(),!1,`#define VLS
#define NB_STEPS `+this._volumetricLightStepsCount.toFixed(1));const s=Q.Zero();this.volumetricLightPostProcess.onApply=n=>{if(this.sourceLight&&this.sourceLight.getShadowGenerator()&&this._scene.activeCamera){const o=this.sourceLight.getShadowGenerator();n.setTexture("shadowMapSampler",o.getShadowMap()),n.setTexture("positionSampler",r.textures[2]),n.setColor3("sunColor",this.sourceLight.diffuse),n.setVector3("sunDirection",this.sourceLight.getShadowDirection()),n.setVector3("cameraPosition",this._scene.activeCamera.globalPosition),n.setMatrix("shadowViewProjection",o.getTransformMatrix()),n.setFloat("scatteringCoefficient",this.volumetricLightCoefficient),n.setFloat("scatteringPower",this.volumetricLightPower),s.x=this.sourceLight.getDepthMinZ(this._scene.activeCamera),s.y=this.sourceLight.getDepthMaxZ(this._scene.activeCamera),n.setVector2("depthValues",s)}},this.addEffect(new Xe(e.getEngine(),"HDRVLS",()=>this.volumetricLightPostProcess,!0)),this._createBlurPostProcesses(e,t/4,0,"volumetricLightBlurScale"),this.volumetricLightMergePostProces=new Ce("HDRVLSMerge","standard",[],["originalSampler"],t,null,Y.BILINEAR_SAMPLINGMODE,e.getEngine(),!1,"#define VLSMERGE"),this.volumetricLightMergePostProces.onApply=n=>{n.setTextureFromPostProcess("originalSampler",this._bloomEnabled?this.textureAdderFinalPostProcess:this.originalPostProcess),this._currentDepthOfFieldSource=this.volumetricLightFinalPostProcess},this.addEffect(new Xe(e.getEngine(),"HDRVLSMerge",()=>this.volumetricLightMergePostProces,!0))}_createLuminancePostProcesses(e,t){let i=Math.pow(3,qe.LuminanceSteps);this.luminancePostProcess=new Ce("HDRLuminance","standard",["lumOffsets"],[],{width:i,height:i},null,Y.BILINEAR_SAMPLINGMODE,e.getEngine(),!1,"#define LUMINANCE",t);const r=[];this.luminancePostProcess.onApply=n=>{const o=1/this.luminancePostProcess.width,l=1/this.luminancePostProcess.height;r[0]=-.5*o,r[1]=.5*l,r[2]=.5*o,r[3]=.5*l,r[4]=-.5*o,r[5]=-.5*l,r[6]=.5*o,r[7]=-.5*l,n.setArray2("lumOffsets",r)},this.addEffect(new Xe(e.getEngine(),"HDRLuminance",()=>this.luminancePostProcess,!0));for(let n=qe.LuminanceSteps-1;n>=0;n--){i=Math.pow(3,n);let o=`#define LUMINANCE_DOWN_SAMPLE
`;n===0&&(o+="#define FINAL_DOWN_SAMPLER");const l=new Ce("HDRLuminanceDownSample"+n,"standard",["dsOffsets","halfDestPixelSize"],[],{width:i,height:i},null,Y.BILINEAR_SAMPLINGMODE,e.getEngine(),!1,o,t);this.luminanceDownSamplePostProcesses.push(l)}let s=this.luminancePostProcess;this.luminanceDownSamplePostProcesses.forEach((n,o)=>{const l=new Array(18);n.onApply=u=>{if(!s)return;let c=0;for(let h=-1;h<2;h++)for(let d=-1;d<2;d++)l[c]=h/s.width,l[c+1]=d/s.height,c+=2;u.setArray2("dsOffsets",l),u.setFloat("halfDestPixelSize",.5/s.width),o===this.luminanceDownSamplePostProcesses.length-1?s=this.luminancePostProcess:s=n},o===this.luminanceDownSamplePostProcesses.length-1&&(n.onAfterRender=()=>{const u=e.getEngine().readPixels(0,0,1,1),c=new Ve(1/(255*255*255),1/(255*255),1/255,1);u.then(h=>{const d=new Uint8Array(h.buffer);this._hdrCurrentLuminance=(d[0]*c.x+d[1]*c.y+d[2]*c.z+d[3]*c.w)/100})}),this.addEffect(new Xe(e.getEngine(),"HDRLuminanceDownSample"+o,()=>n,!0))})}_createHdrPostProcess(e,t){const i=["#define HDR"];this._hdrAutoExposure&&i.push("#define AUTO_EXPOSURE"),this.hdrPostProcess=new Ce("HDR","standard",["averageLuminance"],["textureAdderSampler"],t,null,Y.BILINEAR_SAMPLINGMODE,e.getEngine(),!1,i.join(`
`),0);let r=1,s=0,n=0;this.hdrPostProcess.onApply=o=>{if(o.setTextureFromPostProcess("textureAdderSampler",this._currentDepthOfFieldSource),s+=e.getEngine().getDeltaTime(),r<0)r=this._hdrCurrentLuminance;else{const l=(n-s)/1e3;this._hdrCurrentLuminance<r+this.hdrDecreaseRate*l?r+=this.hdrDecreaseRate*l:this._hdrCurrentLuminance>r-this.hdrIncreaseRate*l?r-=this.hdrIncreaseRate*l:r=this._hdrCurrentLuminance}this.hdrAutoExposure?this._currentExposure=this._fixedExposure/r:(r=Si(r,this.hdrMinimumLuminance,1e20),o.setFloat("averageLuminance",r)),n=s,this._currentDepthOfFieldSource=this.hdrFinalPostProcess},this.addEffect(new Xe(e.getEngine(),"HDR",()=>this.hdrPostProcess,!0))}_createLensFlarePostProcess(e,t){this.lensFlarePostProcess=new Ce("HDRLensFlare","standard",["strength","ghostDispersal","haloWidth","resolution","distortionStrength"],["lensColorSampler"],t/2,null,Y.BILINEAR_SAMPLINGMODE,e.getEngine(),!1,"#define LENS_FLARE",0),this.addEffect(new Xe(e.getEngine(),"HDRLensFlare",()=>this.lensFlarePostProcess,!0)),this._createBlurPostProcesses(e,t/4,2,"lensFlareBlurWidth"),this.lensFlareComposePostProcess=new Ce("HDRLensFlareCompose","standard",["lensStarMatrix"],["otherSampler","lensDirtSampler","lensStarSampler"],t,null,Y.BILINEAR_SAMPLINGMODE,e.getEngine(),!1,"#define LENS_FLARE_COMPOSE",0),this.addEffect(new Xe(e.getEngine(),"HDRLensFlareCompose",()=>this.lensFlareComposePostProcess,!0));const i=new Q(0,0);this.lensFlarePostProcess.externalTextureSamplerBinding=!0,this.lensFlarePostProcess.onApply=n=>{n.setTextureFromPostProcess("textureSampler",this._bloomEnabled?this.blurHPostProcesses[0]:this.originalPostProcess),n.setTexture("lensColorSampler",this.lensColorTexture),n.setFloat("strength",this.lensFlareStrength),n.setFloat("ghostDispersal",this.lensFlareGhostDispersal),n.setFloat("haloWidth",this.lensFlareHaloWidth),i.x=this.lensFlarePostProcess.width,i.y=this.lensFlarePostProcess.height,n.setVector2("resolution",i),n.setFloat("distortionStrength",this.lensFlareDistortionStrength)};const r=$.FromValues(2,0,-1,0,0,2,-1,0,0,0,1,0,0,0,0,1),s=$.FromValues(.5,0,.5,0,0,.5,.5,0,0,0,1,0,0,0,0,1);this.lensFlareComposePostProcess.onApply=n=>{if(!this._scene.activeCamera)return;n.setTextureFromPostProcess("otherSampler",this.lensFlarePostProcess),n.setTexture("lensDirtSampler",this.lensFlareDirtTexture),n.setTexture("lensStarSampler",this.lensStarTexture);const o=this._scene.activeCamera.getViewMatrix().getRow(0),l=this._scene.activeCamera.getViewMatrix().getRow(2);let u=m.Dot(o.toVector3(),new m(1,0,0))+m.Dot(l.toVector3(),new m(0,0,1));u*=4;const c=$.FromValues(Math.cos(u)*.5,-Math.sin(u),0,0,Math.sin(u),Math.cos(u)*.5,0,0,0,0,1,0,0,0,0,1),h=s.multiply(c).multiply(r);n.setMatrix("lensStarMatrix",h),this._currentDepthOfFieldSource=this.lensFlareFinalPostProcess}}_createDepthOfFieldPostProcess(e,t){this.depthOfFieldPostProcess=new Ce("HDRDepthOfField","standard",["distance"],["otherSampler","depthSampler"],t,null,Y.BILINEAR_SAMPLINGMODE,e.getEngine(),!1,"#define DEPTH_OF_FIELD",0),this.depthOfFieldPostProcess.onApply=i=>{i.setTextureFromPostProcess("otherSampler",this._currentDepthOfFieldSource),i.setTexture("depthSampler",this._getDepthTexture()),i.setFloat("distance",this.depthOfFieldDistance)},this.addEffect(new Xe(e.getEngine(),"HDRDepthOfField",()=>this.depthOfFieldPostProcess,!0))}_createMotionBlurPostProcess(e,t){if(this._isObjectBasedMotionBlur){const i=new ia("HDRMotionBlur",e,t,null,Y.BILINEAR_SAMPLINGMODE,e.getEngine(),!1,0);i.motionStrength=this.motionStrength,i.motionBlurSamples=this.motionBlurSamples,this.motionBlurPostProcess=i}else{this.motionBlurPostProcess=new Ce("HDRMotionBlur","standard",["inverseViewProjection","prevViewProjection","screenSize","motionScale","motionStrength"],["depthSampler"],t,null,Y.BILINEAR_SAMPLINGMODE,e.getEngine(),!1,`#define MOTION_BLUR
#define MAX_MOTION_SAMPLES `+this.motionBlurSamples.toFixed(1),0);let i=0,r=$.Identity();const s=$.Identity();let n=$.Identity();const o=Q.Zero();this.motionBlurPostProcess.onApply=l=>{n=e.getProjectionMatrix().multiply(e.getViewMatrix()),n.invertToRef(s),l.setMatrix("inverseViewProjection",s),l.setMatrix("prevViewProjection",r),r=n,o.x=this.motionBlurPostProcess.width,o.y=this.motionBlurPostProcess.height,l.setVector2("screenSize",o),i=e.getEngine().getFps()/60,l.setFloat("motionScale",i),l.setFloat("motionStrength",this.motionStrength),l.setTexture("depthSampler",this._getDepthTexture())}}this.addEffect(new Xe(e.getEngine(),"HDRMotionBlur",()=>this.motionBlurPostProcess,!0))}_getDepthTexture(){return this._scene.getEngine().getCaps().drawBuffersExtension?this._scene.enableGeometryBufferRenderer().getGBuffer().textures[0]:this._scene.enableDepthRenderer().getDepthMap()}_disposePostProcesses(){for(let e=0;e<this._cameras.length;e++){const t=this._cameras[e];this.originalPostProcess&&this.originalPostProcess.dispose(t),this.screenSpaceReflectionPostProcess&&this.screenSpaceReflectionPostProcess.dispose(t),this.downSampleX4PostProcess&&this.downSampleX4PostProcess.dispose(t),this.brightPassPostProcess&&this.brightPassPostProcess.dispose(t),this.textureAdderPostProcess&&this.textureAdderPostProcess.dispose(t),this.volumetricLightPostProcess&&this.volumetricLightPostProcess.dispose(t),this.volumetricLightSmoothXPostProcess&&this.volumetricLightSmoothXPostProcess.dispose(t),this.volumetricLightSmoothYPostProcess&&this.volumetricLightSmoothYPostProcess.dispose(t),this.volumetricLightMergePostProces&&this.volumetricLightMergePostProces.dispose(t),this.volumetricLightFinalPostProcess&&this.volumetricLightFinalPostProcess.dispose(t),this.lensFlarePostProcess&&this.lensFlarePostProcess.dispose(t),this.lensFlareComposePostProcess&&this.lensFlareComposePostProcess.dispose(t);for(let i=0;i<this.luminanceDownSamplePostProcesses.length;i++)this.luminanceDownSamplePostProcesses[i].dispose(t);this.luminancePostProcess&&this.luminancePostProcess.dispose(t),this.hdrPostProcess&&this.hdrPostProcess.dispose(t),this.hdrFinalPostProcess&&this.hdrFinalPostProcess.dispose(t),this.depthOfFieldPostProcess&&this.depthOfFieldPostProcess.dispose(t),this.motionBlurPostProcess&&this.motionBlurPostProcess.dispose(t),this.fxaaPostProcess&&this.fxaaPostProcess.dispose(t);for(let i=0;i<this.blurHPostProcesses.length;i++)this.blurHPostProcesses[i].dispose(t);for(let i=0;i<this.blurVPostProcesses.length;i++)this.blurVPostProcesses[i].dispose(t)}this.originalPostProcess=null,this.downSampleX4PostProcess=null,this.brightPassPostProcess=null,this.textureAdderPostProcess=null,this.textureAdderFinalPostProcess=null,this.volumetricLightPostProcess=null,this.volumetricLightSmoothXPostProcess=null,this.volumetricLightSmoothYPostProcess=null,this.volumetricLightMergePostProces=null,this.volumetricLightFinalPostProcess=null,this.lensFlarePostProcess=null,this.lensFlareComposePostProcess=null,this.luminancePostProcess=null,this.hdrPostProcess=null,this.hdrFinalPostProcess=null,this.depthOfFieldPostProcess=null,this.motionBlurPostProcess=null,this.fxaaPostProcess=null,this.screenSpaceReflectionPostProcess=null,this.luminanceDownSamplePostProcesses.length=0,this.blurHPostProcesses.length=0,this.blurVPostProcesses.length=0}dispose(){this._disposePostProcesses(),this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name,this._cameras),super.dispose()}serialize(){const e=Me.Serialize(this);return this.sourceLight&&(e.sourceLightId=this.sourceLight.id),this.screenSpaceReflectionPostProcess&&(e.screenSpaceReflectionPostProcess=Me.Serialize(this.screenSpaceReflectionPostProcess)),e.customType="StandardRenderingPipeline",e}static Parse(e,t,i){const r=Me.Parse(()=>new qe(e._name,t,e._ratio),e,t,i);return e.sourceLightId&&(r.sourceLight=t.getLightById(e.sourceLightId)),e.screenSpaceReflectionPostProcess&&Me.Parse(()=>r.screenSpaceReflectionPostProcess,e.screenSpaceReflectionPostProcess,t,i),r}}qe.LuminanceSteps=6;C([F()],qe.prototype,"brightThreshold",void 0);C([F()],qe.prototype,"blurWidth",void 0);C([F()],qe.prototype,"horizontalBlur",void 0);C([F()],qe.prototype,"exposure",null);C([Mi("lensTexture")],qe.prototype,"lensTexture",void 0);C([F()],qe.prototype,"volumetricLightCoefficient",void 0);C([F()],qe.prototype,"volumetricLightPower",void 0);C([F()],qe.prototype,"volumetricLightBlurScale",void 0);C([F()],qe.prototype,"hdrMinimumLuminance",void 0);C([F()],qe.prototype,"hdrDecreaseRate",void 0);C([F()],qe.prototype,"hdrIncreaseRate",void 0);C([F()],qe.prototype,"hdrAutoExposure",null);C([Mi("lensColorTexture")],qe.prototype,"lensColorTexture",void 0);C([F()],qe.prototype,"lensFlareStrength",void 0);C([F()],qe.prototype,"lensFlareGhostDispersal",void 0);C([F()],qe.prototype,"lensFlareHaloWidth",void 0);C([F()],qe.prototype,"lensFlareDistortionStrength",void 0);C([F()],qe.prototype,"lensFlareBlurWidth",void 0);C([Mi("lensStarTexture")],qe.prototype,"lensStarTexture",void 0);C([Mi("lensFlareDirtTexture")],qe.prototype,"lensFlareDirtTexture",void 0);C([F()],qe.prototype,"depthOfFieldDistance",void 0);C([F()],qe.prototype,"depthOfFieldBlurWidth",void 0);C([F()],qe.prototype,"motionStrength",null);C([F()],qe.prototype,"objectBasedMotionBlur",null);C([F()],qe.prototype,"_ratio",void 0);C([F()],qe.prototype,"BloomEnabled",null);C([F()],qe.prototype,"DepthOfFieldEnabled",null);C([F()],qe.prototype,"LensFlareEnabled",null);C([F()],qe.prototype,"HDREnabled",null);C([F()],qe.prototype,"VLSEnabled",null);C([F()],qe.prototype,"MotionBlurEnabled",null);C([F()],qe.prototype,"fxaaEnabled",null);C([F()],qe.prototype,"screenSpaceReflectionsEnabled",null);C([F()],qe.prototype,"volumetricLightStepsCount",null);C([F()],qe.prototype,"motionBlurSamples",null);C([F()],qe.prototype,"samples",null);B("BABYLON.StandardRenderingPipeline",qe);class GV{constructor(e=!1){this.enabled=!1,this.name="screenSpaceReflections2",this.texturesRequired=[6,3],this.texturesRequired.push(e?10:5)}}class St extends sa{set samples(e){this._samples!==e&&(this._samples=e,this._ssrPostProcess&&(this._ssrPostProcess.samples=this.samples))}get samples(){return this._samples}get maxDistance(){return this._thinSSRRenderingPipeline.maxDistance}set maxDistance(e){this._thinSSRRenderingPipeline.maxDistance=e}get step(){return this._thinSSRRenderingPipeline.step}set step(e){this._thinSSRRenderingPipeline.step=e}get thickness(){return this._thinSSRRenderingPipeline.thickness}set thickness(e){this._thinSSRRenderingPipeline.thickness=e}get strength(){return this._thinSSRRenderingPipeline.strength}set strength(e){this._thinSSRRenderingPipeline.strength=e}get reflectionSpecularFalloffExponent(){return this._thinSSRRenderingPipeline.reflectionSpecularFalloffExponent}set reflectionSpecularFalloffExponent(e){this._thinSSRRenderingPipeline.reflectionSpecularFalloffExponent=e}get maxSteps(){return this._thinSSRRenderingPipeline.maxSteps}set maxSteps(e){this._thinSSRRenderingPipeline.maxSteps=e}get roughnessFactor(){return this._thinSSRRenderingPipeline.roughnessFactor}set roughnessFactor(e){this._thinSSRRenderingPipeline.roughnessFactor=e}get selfCollisionNumSkip(){return this._thinSSRRenderingPipeline.selfCollisionNumSkip}set selfCollisionNumSkip(e){this._thinSSRRenderingPipeline.selfCollisionNumSkip=e}get reflectivityThreshold(){return this._thinSSRRenderingPipeline.reflectivityThreshold}set reflectivityThreshold(e){const t=this.reflectivityThreshold;e!==t&&(this._thinSSRRenderingPipeline.reflectivityThreshold=e,(e===0&&t!==0||e!==0&&t===0)&&this._buildPipeline())}get ssrDownsample(){return this._thinSSRRenderingPipeline.ssrDownsample}set ssrDownsample(e){this._thinSSRRenderingPipeline.ssrDownsample=e,this._buildPipeline()}get blurDispersionStrength(){return this._thinSSRRenderingPipeline.blurDispersionStrength}set blurDispersionStrength(e){const t=this.blurDispersionStrength;e!==t&&(this._thinSSRRenderingPipeline.blurDispersionStrength=e,(e===0&&t!==0||e!==0&&t===0)&&this._buildPipeline())}_useBlur(){return this.blurDispersionStrength>0}get blurDownsample(){return this._thinSSRRenderingPipeline.blurDownsample}set blurDownsample(e){this._thinSSRRenderingPipeline.blurDownsample=e,this._buildPipeline()}get enableSmoothReflections(){return this._thinSSRRenderingPipeline.enableSmoothReflections}set enableSmoothReflections(e){this._thinSSRRenderingPipeline.enableSmoothReflections=e}get _useScreenspaceDepth(){return this._thinSSRRenderingPipeline.useScreenspaceDepth}get environmentTexture(){return this._thinSSRRenderingPipeline.environmentTexture}set environmentTexture(e){this._thinSSRRenderingPipeline.environmentTexture=e}get environmentTextureIsProbe(){return this._thinSSRRenderingPipeline.environmentTextureIsProbe}set environmentTextureIsProbe(e){this._thinSSRRenderingPipeline.environmentTextureIsProbe=e}get attenuateScreenBorders(){return this._thinSSRRenderingPipeline.attenuateScreenBorders}set attenuateScreenBorders(e){this._thinSSRRenderingPipeline.attenuateScreenBorders=e}get attenuateIntersectionDistance(){return this._thinSSRRenderingPipeline.attenuateIntersectionDistance}set attenuateIntersectionDistance(e){this._thinSSRRenderingPipeline.attenuateIntersectionDistance=e}get attenuateIntersectionIterations(){return this._thinSSRRenderingPipeline.attenuateIntersectionIterations}set attenuateIntersectionIterations(e){this._thinSSRRenderingPipeline.attenuateIntersectionIterations=e}get attenuateFacingCamera(){return this._thinSSRRenderingPipeline.attenuateFacingCamera}set attenuateFacingCamera(e){this._thinSSRRenderingPipeline.attenuateFacingCamera=e}get attenuateBackfaceReflection(){return this._thinSSRRenderingPipeline.attenuateBackfaceReflection}set attenuateBackfaceReflection(e){this._thinSSRRenderingPipeline.attenuateBackfaceReflection=e}get clipToFrustum(){return this._thinSSRRenderingPipeline.clipToFrustum}set clipToFrustum(e){this._thinSSRRenderingPipeline.clipToFrustum=e}get useFresnel(){return this._thinSSRRenderingPipeline.useFresnel}set useFresnel(e){this._thinSSRRenderingPipeline.useFresnel=e,this._buildPipeline()}get enableAutomaticThicknessComputation(){return this._thinSSRRenderingPipeline.enableAutomaticThicknessComputation}set enableAutomaticThicknessComputation(e){this._thinSSRRenderingPipeline.enableAutomaticThicknessComputation=e,this._buildPipeline()}get backfaceDepthRenderer(){return this._depthRenderer}get backfaceDepthTextureDownsample(){return this._backfaceDepthTextureDownsample}set backfaceDepthTextureDownsample(e){this._backfaceDepthTextureDownsample!==e&&(this._backfaceDepthTextureDownsample=e,this._resizeDepthRenderer())}get backfaceForceDepthWriteTransparentMeshes(){return this._backfaceForceDepthWriteTransparentMeshes}set backfaceForceDepthWriteTransparentMeshes(e){this._backfaceForceDepthWriteTransparentMeshes!==e&&(this._backfaceForceDepthWriteTransparentMeshes=e,this._depthRenderer&&(this._depthRenderer.forceDepthWriteTransparentMeshes=e))}get isEnabled(){return this._isEnabled}set isEnabled(e){this._isEnabled!==e&&(this._isEnabled=e,e?e&&(this._isDirty?this._buildPipeline():this._cameras!==null&&this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name,this._cameras)):this._cameras!==null&&(this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name,this._cameras),this._cameras=this._camerasToBeAttached.slice()))}get inputTextureColorIsInGammaSpace(){return this._thinSSRRenderingPipeline.inputTextureColorIsInGammaSpace}set inputTextureColorIsInGammaSpace(e){this._thinSSRRenderingPipeline.inputTextureColorIsInGammaSpace=e,this._buildPipeline()}get generateOutputInGammaSpace(){return this._thinSSRRenderingPipeline.generateOutputInGammaSpace}set generateOutputInGammaSpace(e){this._thinSSRRenderingPipeline.generateOutputInGammaSpace=e,this._buildPipeline()}get debug(){return this._thinSSRRenderingPipeline.debug}set debug(e){this._thinSSRRenderingPipeline.debug=e,this._buildPipeline()}getScene(){return this._scene}get _geometryBufferRenderer(){return this._forceGeometryBuffer?this._scene.geometryBufferRenderer:null}get _prePassRenderer(){return this._forceGeometryBuffer?null:this._scene.prePassRenderer}get scene(){return this._scene}get isSupported(){const e=this._scene.getEngine().getCaps();return e.drawBuffersExtension&&e.texelFetch}constructor(e,t,i,r=!1,s=0,n=!1){if(super(t.getEngine(),e),this.SSRRenderEffect="SSRRenderEffect",this.SSRBlurRenderEffect="SSRBlurRenderEffect",this.SSRCombineRenderEffect="SSRCombineRenderEffect",this._samples=1,this._backfaceDepthTextureDownsample=0,this._backfaceForceDepthWriteTransparentMeshes=!0,this._isEnabled=!0,this._forceGeometryBuffer=!1,this._isDirty=!1,this._camerasToBeAttached=[],this._thinSSRRenderingPipeline=new G0(e,t),this._thinSSRRenderingPipeline.isSSRSupported=!1,this._thinSSRRenderingPipeline.useScreenspaceDepth=n,this._cameras=i||t.cameras,this._cameras=this._cameras.slice(),this._camerasToBeAttached=this._cameras.slice(),this._scene=t,this._textureType=s,this._forceGeometryBuffer=r,this.isSupported){if(this._createSSRPostProcess(),t.postProcessRenderPipelineManager.addPipeline(this),this._forceGeometryBuffer){const o=t.enableGeometryBufferRenderer();o&&(o.enableReflectivity=!0,o.useSpecificClearForDepthTexture=!0,o.enableScreenspaceDepth=this._useScreenspaceDepth,o.enableDepth=!this._useScreenspaceDepth)}else{const o=t.enablePrePassRenderer();o&&(o.useSpecificClearForDepthTexture=!0,o.markAsDirty())}this._thinSSRRenderingPipeline.isSSRSupported=!!this._geometryBufferRenderer||!!this._prePassRenderer,this._buildPipeline()}}getClassName(){return"SSRRenderingPipeline"}addCamera(e){this._camerasToBeAttached.push(e),this._buildPipeline()}removeCamera(e){const t=this._camerasToBeAttached.indexOf(e);this._camerasToBeAttached.splice(t,1),this._buildPipeline()}dispose(e=!1){this._disposeDepthRenderer(),this._disposeSSRPostProcess(),this._disposeBlurPostProcesses(),e&&this._scene.disableGeometryBufferRenderer(),this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name,this._cameras),this._thinSSRRenderingPipeline.dispose(),super.dispose()}_getTextureSize(){var r,s;const e=this._scene.getEngine(),t=this._prePassRenderer;let i={width:e.getRenderWidth(),height:e.getRenderHeight()};if(t&&((r=this._scene.activeCamera)==null?void 0:r._getFirstPostProcess())===this._ssrPostProcess){const n=t.getRenderTarget();n&&n.textures&&(i=n.textures[t.getIndex(4)].getSize())}else(s=this._ssrPostProcess)!=null&&s.inputTexture&&(i.width=this._ssrPostProcess.inputTexture.width,i.height=this._ssrPostProcess.inputTexture.height);return i}_buildPipeline(){var t,i,r;if(!this.isSupported)return;if(!this._isEnabled){this._isDirty=!0;return}this._isDirty=!1;const e=this._scene.getEngine();if(this._disposeDepthRenderer(),this._cameras!==null&&(this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name,this._cameras),this._cameras=this._camerasToBeAttached.slice(),this._cameras.length>0&&(this._thinSSRRenderingPipeline.camera=this._cameras[0])),this._reset(),this._thinSSRRenderingPipeline.normalsAreInWorldSpace=!!(((t=this._geometryBufferRenderer)==null?void 0:t.generateNormalsInWorldSpace)??((i=this._prePassRenderer)==null?void 0:i.generateNormalsInWorldSpace)),this.enableAutomaticThicknessComputation){const s=(r=this._cameras)==null?void 0:r[0];s&&(this._depthRendererCamera=s,this._depthRenderer=new As(this._scene,void 0,void 0,this._useScreenspaceDepth,1,!this._useScreenspaceDepth,"SSRBackDepth"),this._useScreenspaceDepth||(this._depthRenderer.clearColor.r=1e8),this._depthRenderer.reverseCulling=!0,this._depthRenderer.forceDepthWriteTransparentMeshes=this.backfaceForceDepthWriteTransparentMeshes,this._resizeDepthRenderer(),s.customRenderTargets.push(this._depthRenderer.getDepthMap()))}this.addEffect(new Xe(e,this.SSRRenderEffect,()=>this._ssrPostProcess,!0)),this._disposeBlurPostProcesses(),this._useBlur()&&(this._createBlurAndCombinerPostProcesses(),this.addEffect(new Xe(e,this.SSRBlurRenderEffect,()=>[this._blurPostProcessX,this._blurPostProcessY],!0)),this.addEffect(new Xe(e,this.SSRCombineRenderEffect,()=>this._blurCombinerPostProcess,!0))),this._cameras!==null&&this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name,this._cameras)}_resizeDepthRenderer(){if(!this._depthRenderer)return;const e=this._getTextureSize(),t=this._depthRenderer.getDepthMap().getSize(),i=Math.floor(e.width/(this.backfaceDepthTextureDownsample+1)),r=Math.floor(e.height/(this.backfaceDepthTextureDownsample+1));(t.width!==i||t.height!==r)&&this._depthRenderer.getDepthMap().resize({width:i,height:r})}_disposeDepthRenderer(){if(this._depthRenderer){if(this._depthRendererCamera){const e=this._depthRendererCamera.customRenderTargets.indexOf(this._depthRenderer.getDepthMap())??-1;e!==-1&&this._depthRendererCamera.customRenderTargets.splice(e,1)}this._depthRendererCamera=null,this._depthRenderer.getDepthMap().dispose()}this._depthRenderer=null}_disposeBlurPostProcesses(){var e,t,i;for(let r=0;r<this._cameras.length;r++){const s=this._cameras[r];(e=this._blurPostProcessX)==null||e.dispose(s),(t=this._blurPostProcessY)==null||t.dispose(s),(i=this._blurCombinerPostProcess)==null||i.dispose(s)}this._blurPostProcessX=null,this._blurPostProcessY=null,this._blurCombinerPostProcess=null}_disposeSSRPostProcess(){var e;for(let t=0;t<this._cameras.length;t++){const i=this._cameras[t];(e=this._ssrPostProcess)==null||e.dispose(i)}this._ssrPostProcess=null}_createSSRPostProcess(){this._ssrPostProcess=new Ce("ssr",yr.FragmentUrl,{uniformNames:yr.Uniforms,samplerNames:yr.Samplers,size:1,samplingMode:2,engine:this._scene.getEngine(),textureType:this._textureType,effectWrapper:this._thinSSRRenderingPipeline._ssrPostProcess}),this._ssrPostProcess.onApply=e=>{this._resizeDepthRenderer();const t=this._geometryBufferRenderer,i=this._prePassRenderer;if(!i&&!t)return;if(t){const s=t.getTextureIndex(Re.REFLECTIVITY_TEXTURE_TYPE),n=t.getTextureIndex(Re.NORMAL_TEXTURE_TYPE);if(e.setTexture("normalSampler",t.getGBuffer().textures[n]),e.setTexture("reflectivitySampler",t.getGBuffer().textures[s]),this._useScreenspaceDepth){const o=t.getTextureIndex(Re.SCREENSPACE_DEPTH_TEXTURE_TYPE);e.setTexture("depthSampler",t.getGBuffer().textures[o])}else{const o=t.getTextureIndex(Re.DEPTH_TEXTURE_TYPE);e.setTexture("depthSampler",t.getGBuffer().textures[o])}}else if(i){const s=i.getIndex(this._useScreenspaceDepth?10:5),n=i.getIndex(3),o=i.getIndex(6);e.setTexture("normalSampler",i.getRenderTarget().textures[o]),e.setTexture("depthSampler",i.getRenderTarget().textures[s]),e.setTexture("reflectivitySampler",i.getRenderTarget().textures[n])}this.enableAutomaticThicknessComputation&&this._depthRenderer&&(e.setTexture("backDepthSampler",this._depthRenderer.getDepthMap()),e.setFloat("backSizeFactor",this.backfaceDepthTextureDownsample+1));const r=this._getTextureSize();this._thinSSRRenderingPipeline._ssrPostProcess.textureWidth=r.width,this._thinSSRRenderingPipeline._ssrPostProcess.textureHeight=r.height},this._ssrPostProcess.samples=this.samples,this._forceGeometryBuffer||(this._ssrPostProcess._prePassEffectConfiguration=new GV(this._useScreenspaceDepth))}_createBlurAndCombinerPostProcesses(){const e=this._scene.getEngine();this._blurPostProcessX=new Ce("SSRblurX",Ii.FragmentUrl,{uniformNames:Ii.Uniforms,samplerNames:Ii.Samplers,size:1/(this.ssrDownsample+1),samplingMode:2,engine:e,textureType:this._textureType,effectWrapper:this._thinSSRRenderingPipeline._ssrBlurXPostProcess}),this._blurPostProcessX.autoClear=!1,this._blurPostProcessX.onApplyObservable.add(()=>{var t;this._thinSSRRenderingPipeline._ssrBlurXPostProcess.textureWidth=((t=this._blurPostProcessX)==null?void 0:t.inputTexture.width)??this._scene.getEngine().getRenderWidth(),this._thinSSRRenderingPipeline._ssrBlurXPostProcess.textureHeight=1}),this._blurPostProcessY=new Ce("SSRblurY",Ii.FragmentUrl,{uniformNames:Ii.Uniforms,samplerNames:Ii.Samplers,size:1/(this.blurDownsample+1),samplingMode:2,engine:e,textureType:this._textureType,effectWrapper:this._thinSSRRenderingPipeline._ssrBlurYPostProcess}),this._blurPostProcessY.autoClear=!1,this._blurPostProcessY.onApplyObservable.add(()=>{var t;this._thinSSRRenderingPipeline._ssrBlurYPostProcess.textureWidth=1,this._thinSSRRenderingPipeline._ssrBlurYPostProcess.textureHeight=((t=this._blurPostProcessY)==null?void 0:t.inputTexture.height)??this._scene.getEngine().getRenderHeight()}),this._blurCombinerPostProcess=new Ce("SSRblurCombiner",Ur.FragmentUrl,{uniformNames:Ur.Uniforms,samplerNames:Ur.Samplers,size:1/(this.blurDownsample+1),samplingMode:1,engine:e,textureType:this._textureType,effectWrapper:this._thinSSRRenderingPipeline._ssrBlurCombinerPostProcess}),this._blurCombinerPostProcess.autoClear=!1,this._blurCombinerPostProcess.onApplyObservable.add(t=>{var s;const i=this._geometryBufferRenderer,r=this._prePassRenderer;if(!(!r&&!i)){if(r&&((s=this._scene.activeCamera)==null?void 0:s._getFirstPostProcess())===this._ssrPostProcess){const n=r.getRenderTarget();n&&n.textures&&t.setTexture("mainSampler",n.textures[r.getIndex(4)])}else t.setTextureFromPostProcess("mainSampler",this._ssrPostProcess);if(i){const n=i.getTextureIndex(Re.REFLECTIVITY_TEXTURE_TYPE);if(t.setTexture("reflectivitySampler",i.getGBuffer().textures[n]),this.useFresnel)if(t.setTexture("normalSampler",i.getGBuffer().textures[1]),this._useScreenspaceDepth){const o=i.getTextureIndex(Re.SCREENSPACE_DEPTH_TEXTURE_TYPE);t.setTexture("depthSampler",i.getGBuffer().textures[o])}else t.setTexture("depthSampler",i.getGBuffer().textures[0])}else if(r){const n=r.getIndex(3);if(t.setTexture("reflectivitySampler",r.getRenderTarget().textures[n]),this.useFresnel){const o=r.getIndex(this._useScreenspaceDepth?10:5),l=r.getIndex(6);t.setTexture("normalSampler",r.getRenderTarget().textures[l]),t.setTexture("depthSampler",r.getRenderTarget().textures[o])}}}})}serialize(){const e=Me.Serialize(this);return e.customType="SSRRenderingPipeline",e}static Parse(e,t,i){return Me.Parse(()=>new St(e._name,t,e._ratio),e,t,i)}}C([F()],St.prototype,"samples",null);C([F()],St.prototype,"maxDistance",null);C([F()],St.prototype,"step",null);C([F()],St.prototype,"thickness",null);C([F()],St.prototype,"strength",null);C([F()],St.prototype,"reflectionSpecularFalloffExponent",null);C([F()],St.prototype,"maxSteps",null);C([F()],St.prototype,"roughnessFactor",null);C([F()],St.prototype,"selfCollisionNumSkip",null);C([F()],St.prototype,"reflectivityThreshold",null);C([F()],St.prototype,"ssrDownsample",null);C([F("blurDispersionStrength")],St.prototype,"blurDispersionStrength",null);C([F("blurDownsample")],St.prototype,"blurDownsample",null);C([F("enableSmoothReflections")],St.prototype,"enableSmoothReflections",null);C([F("environmentTexture")],St.prototype,"environmentTexture",null);C([F("environmentTextureIsProbe")],St.prototype,"environmentTextureIsProbe",null);C([F("attenuateScreenBorders")],St.prototype,"attenuateScreenBorders",null);C([F("attenuateIntersectionDistance")],St.prototype,"attenuateIntersectionDistance",null);C([F("attenuateIntersectionIterations")],St.prototype,"attenuateIntersectionIterations",null);C([F("attenuateFacingCamera")],St.prototype,"attenuateFacingCamera",null);C([F("attenuateBackfaceReflection")],St.prototype,"attenuateBackfaceReflection",null);C([F("clipToFrustum")],St.prototype,"clipToFrustum",null);C([F("useFresnel")],St.prototype,"useFresnel",null);C([F("enableAutomaticThicknessComputation")],St.prototype,"enableAutomaticThicknessComputation",null);C([F("backfaceDepthTextureDownsample")],St.prototype,"_backfaceDepthTextureDownsample",void 0);C([F("backfaceForceDepthWriteTransparentMeshes")],St.prototype,"_backfaceForceDepthWriteTransparentMeshes",void 0);C([F("isEnabled")],St.prototype,"_isEnabled",void 0);C([F("inputTextureColorIsInGammaSpace")],St.prototype,"inputTextureColorIsInGammaSpace",null);C([F("generateOutputInGammaSpace")],St.prototype,"generateOutputInGammaSpace",null);C([F("debug")],St.prototype,"debug",null);B("BABYLON.SSRRenderingPipeline",St);class bn extends sa{set samples(e){this._taaThinPostProcess.samples=e}get samples(){return this._taaThinPostProcess.samples}set msaaSamples(e){this._msaaSamples!==e&&(this._msaaSamples=e,this._taaPostProcess&&(this._taaPostProcess.samples=e))}get msaaSamples(){return this._msaaSamples}get factor(){return this._taaThinPostProcess.factor}set factor(e){this._taaThinPostProcess.factor=e}get disableOnCameraMove(){return this._taaThinPostProcess.disableOnCameraMove}set disableOnCameraMove(e){this._taaThinPostProcess.disableOnCameraMove=e}get isEnabled(){return this._isEnabled}set isEnabled(e){this._isEnabled!==e&&(this._isEnabled=e,e?e&&(this._isDirty?this._buildPipeline():this._cameras!==null&&(this._taaThinPostProcess._reset(),this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name,this._cameras))):this._cameras!==null&&(this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name,this._cameras),this._cameras=this._camerasToBeAttached.slice()))}get scene(){return this._scene}get isSupported(){return this._scene.getEngine().getCaps().texelFetch}constructor(e,t,i,r=0){const s=t.getEngine();super(s,e),this.TAARenderEffect="TAARenderEffect",this.TAAPassEffect="TAAPassEffect",this._msaaSamples=1,this._isEnabled=!0,this._isDirty=!1,this._camerasToBeAttached=[],this._pingpong=0,this._cameras=i||t.cameras,this._cameras=this._cameras.slice(),this._camerasToBeAttached=this._cameras.slice(),this._scene=t,this._textureType=r,this._taaThinPostProcess=new Rs("TAA",this._scene.getEngine()),this.isSupported&&(this._createPingPongTextures(s.getRenderWidth(),s.getRenderHeight()),t.postProcessRenderPipelineManager.addPipeline(this),this._buildPipeline())}getClassName(){return"TAARenderingPipeline"}addCamera(e){this._camerasToBeAttached.push(e),this._buildPipeline()}removeCamera(e){const t=this._camerasToBeAttached.indexOf(e);this._camerasToBeAttached.splice(t,1),this._buildPipeline()}dispose(){this._disposePostProcesses(),this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name,this._cameras),this._ping.dispose(),this._pong.dispose(),super.dispose()}_createPingPongTextures(e,t){var r,s;const i=this._scene.getEngine();(r=this._ping)==null||r.dispose(),(s=this._pong)==null||s.dispose(),this._ping=i.createRenderTargetTexture({width:e,height:t},{generateMipMaps:!1,generateDepthBuffer:!1,type:2,samplingMode:1}),this._pong=i.createRenderTargetTexture({width:e,height:t},{generateMipMaps:!1,generateDepthBuffer:!1,type:2,samplingMode:1}),this._taaThinPostProcess.textureWidth=e,this._taaThinPostProcess.textureHeight=t}_buildPipeline(){if(!this.isSupported)return;if(!this._isEnabled){this._isDirty=!0;return}this._isDirty=!1;const e=this._scene.getEngine();this._disposePostProcesses(),this._cameras!==null&&(this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name,this._cameras),this._cameras=this._camerasToBeAttached.slice()),this._reset(),this._createTAAPostProcess(),this.addEffect(new Xe(e,this.TAARenderEffect,()=>this._taaPostProcess,!0)),this._createPassPostProcess(),this.addEffect(new Xe(e,this.TAAPassEffect,()=>this._passPostProcess,!0)),this._cameras!==null&&this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name,this._cameras)}_disposePostProcesses(){var e,t;for(let i=0;i<this._cameras.length;i++){const r=this._cameras[i];(e=this._taaPostProcess)==null||e.dispose(r),(t=this._passPostProcess)==null||t.dispose(r),r.getProjectionMatrix(!0)}this._taaPostProcess=null,this._passPostProcess=null}_createTAAPostProcess(){this._taaPostProcess=new Ce("TAA","taa",{uniforms:["factor"],samplers:["historySampler"],size:1,engine:this._scene.getEngine(),textureType:this._textureType,effectWrapper:this._taaThinPostProcess}),this._taaPostProcess.samples=this._msaaSamples,this._taaPostProcess.onActivateObservable.add(()=>{var e,t;if(this._taaThinPostProcess.camera=this._scene.activeCamera,((e=this._taaPostProcess)==null?void 0:e.width)!==this._ping.width||((t=this._taaPostProcess)==null?void 0:t.height)!==this._ping.height){const i=this._scene.getEngine();this._createPingPongTextures(i.getRenderWidth(),i.getRenderHeight())}this._taaThinPostProcess.updateProjectionMatrix(),this._passPostProcess&&(this._passPostProcess.inputTexture=this._pingpong?this._ping:this._pong),this._pingpong=this._pingpong^1}),this._taaPostProcess.onApplyObservable.add(e=>{e._bindTexture("historySampler",this._pingpong?this._ping.texture:this._pong.texture)})}_createPassPostProcess(){const e=this._scene.getEngine();this._passPostProcess=new Za("TAAPass",1,null,1,e),this._passPostProcess.inputTexture=this._ping,this._passPostProcess.autoClear=!1}serialize(){const e=Me.Serialize(this);return e.customType="TAARenderingPipeline",e}static Parse(e,t,i){return Me.Parse(()=>new bn(e._name,t,e._ratio),e,t,i)}}C([F("samples")],bn.prototype,"samples",null);C([F("msaaSamples")],bn.prototype,"_msaaSamples",void 0);C([F()],bn.prototype,"factor",null);C([F()],bn.prototype,"disableOnCameraMove",null);C([F("isEnabled")],bn.prototype,"_isEnabled",void 0);B("BABYLON.TAARenderingPipeline",bn);const Wd="ssao2PixelShader",UP=`precision highp float;uniform sampler2D textureSampler;varying vec2 vUV;
#ifdef SSAO
float scales[16]=float[16](
0.1,
0.11406250000000001,
0.131640625,
0.15625,
0.187890625,
0.2265625,
0.272265625,
0.325,
0.384765625,
0.4515625,
0.525390625,
0.60625,
0.694140625,
0.7890625,
0.891015625,
1.0
);uniform float near;uniform float radius;uniform sampler2D depthSampler;uniform sampler2D randomSampler;uniform sampler2D normalSampler;uniform float randTextureTiles;uniform float samplesFactor;uniform vec3 sampleSphere[SAMPLES];uniform float totalStrength;uniform float base;uniform float xViewport;uniform float yViewport;uniform mat3 depthProjection;uniform float maxZ;uniform float minZAspect;uniform vec2 texelSize;uniform mat4 projection;void main()
{vec3 random=textureLod(randomSampler,vUV*randTextureTiles,0.0).rgb;float depth=textureLod(depthSampler,vUV,0.0).r;float depthSign=sign(depth);depth=depth*depthSign;vec3 normal=textureLod(normalSampler,vUV,0.0).rgb;float occlusion=0.0;float correctedRadius=min(radius,minZAspect*depth/near);vec3 vViewRay=vec3((vUV.x*2.0-1.0)*xViewport,(vUV.y*2.0-1.0)*yViewport,depthSign);vec3 vDepthFactor=depthProjection*vec3(1.0,1.0,depth);vec3 origin=vViewRay*vDepthFactor;vec3 rvec=random*2.0-1.0;rvec.z=0.0;float dotProduct=dot(rvec,normal);rvec=1.0-abs(dotProduct)>1e-2 ? rvec : vec3(-rvec.y,0.0,rvec.x);vec3 tangent=normalize(rvec-normal*dot(rvec,normal));vec3 bitangent=cross(normal,tangent);mat3 tbn=mat3(tangent,bitangent,normal);float difference;for (int i=0; i<SAMPLES; ++i) {vec3 samplePosition=scales[(i+int(random.x*16.0)) % 16]*tbn*sampleSphere[(i+int(random.y*16.0)) % 16];samplePosition=samplePosition*correctedRadius+origin;vec4 offset=vec4(samplePosition,1.0);offset=projection*offset;offset.xyz/=offset.w;offset.xy=offset.xy*0.5+0.5;if (offset.x<0.0 || offset.y<0.0 || offset.x>1.0 || offset.y>1.0) {continue;}
float sampleDepth=abs(textureLod(depthSampler,offset.xy,0.0).r);difference=depthSign*samplePosition.z-sampleDepth;float rangeCheck=1.0-smoothstep(correctedRadius*0.5,correctedRadius,difference);occlusion+=step(EPSILON,difference)*rangeCheck;}
occlusion=occlusion*(1.0-smoothstep(maxZ*0.75,maxZ,depth));float ao=1.0-totalStrength*occlusion*samplesFactor;float result=clamp(ao+base,0.0,1.0);gl_FragColor=vec4(vec3(result),1.0);}
#endif
#ifdef BLUR
uniform float outSize;uniform float soften;uniform float tolerance;uniform int samples;
#ifndef BLUR_BYPASS
uniform sampler2D depthSampler;
#ifdef BLUR_LEGACY
#define inline
float blur13Bilateral(sampler2D image,vec2 uv,vec2 step) {float result=0.0;vec2 off1=vec2(1.411764705882353)*step;vec2 off2=vec2(3.2941176470588234)*step;vec2 off3=vec2(5.176470588235294)*step;float compareDepth=abs(textureLod(depthSampler,uv,0.0).r);float sampleDepth;float weight;float weightSum=30.0;result+=textureLod(image,uv,0.0).r*30.0;sampleDepth=abs(textureLod(depthSampler,uv+off1,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+= weight;result+=textureLod(image,uv+off1,0.0).r*weight;sampleDepth=abs(textureLod(depthSampler,uv-off1,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+= weight;result+=textureLod(image,uv-off1,0.0).r*weight;sampleDepth=abs(textureLod(depthSampler,uv+off2,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+=weight;result+=textureLod(image,uv+off2,0.0).r*weight;sampleDepth=abs(textureLod(depthSampler,uv-off2,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+=weight;result+=textureLod(image,uv-off2,0.0).r*weight;sampleDepth=abs(textureLod(depthSampler,uv+off3,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+=weight;result+=textureLod(image,uv+off3,0.0).r*weight;sampleDepth=abs(textureLod(depthSampler,uv-off3,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+=weight;result+=textureLod(image,uv-off3,0.0).r*weight;return result/weightSum;}
#endif
#endif
void main()
{float result=0.0;
#ifdef BLUR_BYPASS
result=textureLod(textureSampler,vUV,0.0).r;
#else
#ifdef BLUR_H
vec2 step=vec2(1.0/outSize,0.0);
#else
vec2 step=vec2(0.0,1.0/outSize);
#endif
#ifdef BLUR_LEGACY
result=blur13Bilateral(textureSampler,vUV,step);
#else
float compareDepth=abs(textureLod(depthSampler,vUV,0.0).r);float weightSum=0.0;for (int i=-samples; i<samples; i+=2)
{vec2 samplePos=vUV+step*(float(i)+0.5);float sampleDepth=abs(textureLod(depthSampler,samplePos,0.0).r);float falloff=smoothstep(0.0,
float(samples),
float(samples)-abs(float(i))*soften);float minDivider=tolerance*0.5+0.003;float weight=falloff/( minDivider+abs(compareDepth-sampleDepth));result+=textureLod(textureSampler,samplePos,0.0).r*weight;weightSum+=weight;}
result/=weightSum;
#endif
#endif
gl_FragColor.rgb=vec3(result);gl_FragColor.a=1.0;}
#endif
`;P.ShadersStore[Wd]||(P.ShadersStore[Wd]=UP);const WV={name:Wd,shader:UP},eb=Object.freeze(Object.defineProperty({__proto__:null,ssao2PixelShader:WV},Symbol.toStringTag,{value:"Module"})),$d="ssao2PixelShader",GP=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;
#ifdef SSAO
const scales: array<f32,16>=array<f32,16>(
0.1,
0.11406250000000001,
0.131640625,
0.15625,
0.187890625,
0.2265625,
0.272265625,
0.325,
0.384765625,
0.4515625,
0.525390625,
0.60625,
0.694140625,
0.7890625,
0.891015625,
1.0
);uniform near: f32;uniform radius: f32;var depthSamplerSampler: sampler;var depthSampler: texture_2d<f32>;var randomSamplerSampler: sampler;var randomSampler: texture_2d<f32>;var normalSamplerSampler: sampler;var normalSampler: texture_2d<f32>;uniform randTextureTiles: f32;uniform samplesFactor: f32;uniform sampleSphere: array<vec3f,SAMPLES>;uniform totalStrength: f32;uniform base: f32;uniform xViewport: f32;uniform yViewport: f32;uniform depthProjection: mat3x3f;uniform maxZ: f32;uniform minZAspect: f32;uniform texelSize: vec2f;uniform projection: mat4x4f;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var random: vec3f=textureSampleLevel(randomSampler,randomSamplerSampler,input.vUV*uniforms.randTextureTiles,0.0).rgb;var depth: f32=textureSampleLevel(depthSampler,depthSamplerSampler,input.vUV,0.0).r;var depthSign: f32=sign(depth);depth=depth*depthSign;var normal: vec3f=textureSampleLevel(normalSampler,normalSamplerSampler,input.vUV,0.0).rgb;var occlusion: f32=0.0;var correctedRadius: f32=min(uniforms.radius,uniforms.minZAspect*depth/uniforms.near);var vViewRay: vec3f= vec3f((input.vUV.x*2.0-1.0)*uniforms.xViewport,(input.vUV.y*2.0-1.0)*uniforms.yViewport,depthSign);var vDepthFactor: vec3f=uniforms.depthProjection* vec3f(1.0,1.0,depth);var origin: vec3f=vViewRay*vDepthFactor;var rvec: vec3f=random*2.0-1.0;rvec.z=0.0;var dotProduct: f32=dot(rvec,normal);rvec=select( vec3f(-rvec.y,0.0,rvec.x),rvec,1.0-abs(dotProduct)>1e-2);var tangent: vec3f=normalize(rvec-normal*dot(rvec,normal));var bitangent: vec3f=cross(normal,tangent);var tbn: mat3x3f= mat3x3f(tangent,bitangent,normal);var difference: f32;for (var i: i32=0; i<SAMPLES; i++) {var samplePosition: vec3f=scales[(i+ i32(random.x*16.0)) % 16]*tbn*uniforms.sampleSphere[(i+ i32(random.y*16.0)) % 16];samplePosition=samplePosition*correctedRadius+origin;var offset: vec4f= vec4f(samplePosition,1.0);offset=uniforms.projection*offset;offset=vec4f(offset.xyz/offset.w,offset.w);offset=vec4f(offset.xy*0.5+0.5,offset.z,offset.w);if (offset.x<0.0 || offset.y<0.0 || offset.x>1.0 || offset.y>1.0) {continue;}
var sampleDepth: f32=abs(textureSampleLevel(depthSampler,depthSamplerSampler,offset.xy,0.0).r);difference=depthSign*samplePosition.z-sampleDepth;var rangeCheck: f32=1.0-smoothstep(correctedRadius*0.5,correctedRadius,difference);occlusion+=step(EPSILON,difference)*rangeCheck;}
occlusion=occlusion*(1.0-smoothstep(uniforms.maxZ*0.75,uniforms.maxZ,depth));var ao: f32=1.0-uniforms.totalStrength*occlusion*uniforms.samplesFactor;var result: f32=clamp(ao+uniforms.base,0.0,1.0);fragmentOutputs.color= vec4f( vec3f(result),1.0);}
#else
#ifdef BLUR
uniform outSize: f32;uniform soften: f32;uniform tolerance: f32;uniform samples: i32;
#ifndef BLUR_BYPASS
var depthSamplerSampler: sampler;var depthSampler: texture_2d<f32>;
#ifdef BLUR_LEGACY
fn blur13Bilateral(image: texture_2d<f32>,imageSampler: sampler,uv: vec2f,step: vec2f)->f32 {var result: f32=0.0;var off1: vec2f= vec2f(1.411764705882353)*step;var off2: vec2f= vec2f(3.2941176470588234)*step;var off3: vec2f= vec2f(5.176470588235294)*step;var compareDepth: f32=abs(textureSampleLevel(depthSampler,depthSamplerSampler,uv,0.0).r);var sampleDepth: f32;var weight: f32;var weightSum: f32=30.0;result+=textureSampleLevel(image,imageSampler,uv,0.0).r*30.0;sampleDepth=abs(textureSampleLevel(depthSampler,depthSamplerSampler,uv+off1,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+= weight;result+=textureSampleLevel(image,imageSampler,uv+off1,0.0).r*weight;sampleDepth=abs(textureSampleLevel(depthSampler,depthSamplerSampler,uv-off1,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+= weight;result+=textureSampleLevel(image,imageSampler,uv-off1,0.0).r*weight;sampleDepth=abs(textureSampleLevel(depthSampler,depthSamplerSampler,uv+off2,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+=weight;result+=textureSampleLevel(image,imageSampler,uv+off2,0.0).r*weight;sampleDepth=abs(textureSampleLevel(depthSampler,depthSamplerSampler,uv-off2,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+=weight;result+=textureSampleLevel(image,imageSampler,uv-off2,0.0).r*weight;sampleDepth=abs(textureSampleLevel(depthSampler,depthSamplerSampler,uv+off3,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+=weight;result+=textureSampleLevel(image,imageSampler,uv+off3,0.0).r*weight;sampleDepth=abs(textureSampleLevel(depthSampler,depthSamplerSampler,uv-off3,0.0).r);weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);weightSum+=weight;result+=textureSampleLevel(image,imageSampler,uv-off3,0.0).r*weight;return result/weightSum;}
#endif
#endif
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var result: f32=0.0;
#ifdef BLUR_BYPASS
result=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.0).r;
#else
#ifdef BLUR_H
var step: vec2f= vec2f(1.0/uniforms.outSize,0.0);
#else
var step: vec2f= vec2f(0.0,1.0/uniforms.outSize);
#endif
#ifdef BLUR_LEGACY
result=blur13Bilateral(textureSampler,textureSamplerSampler,input.vUV,step);
#else
var compareDepth: f32=abs(textureSampleLevel(depthSampler,depthSamplerSampler,input.vUV,0.0).r);var weightSum: f32=0.0;for (var i: i32=-uniforms.samples; i<uniforms.samples; i+=2)
{var samplePos: vec2f=input.vUV+step*( f32(i)+0.5);var sampleDepth: f32=abs(textureSampleLevel(depthSampler,depthSamplerSampler,samplePos,0.0).r);var falloff: f32=smoothstep(0.0,
f32(uniforms.samples),
f32(uniforms.samples)-abs( f32(i))*uniforms.soften);var minDivider: f32=uniforms.tolerance*0.5+0.003;var weight: f32=falloff/( minDivider+abs(compareDepth-sampleDepth));result+=textureSampleLevel(textureSampler,textureSamplerSampler,samplePos,0.0).r*weight;weightSum+=weight;}
result/=weightSum;
#endif
#endif
fragmentOutputs.color=vec4f(result,result,result,1.0);}
#endif
#endif
`;P.ShadersStoreWGSL[$d]||(P.ShadersStoreWGSL[$d]=GP);const $V={name:$d,shader:GP},tb=Object.freeze(Object.defineProperty({__proto__:null,ssao2PixelShaderWGSL:$V},Symbol.toStringTag,{value:"Module"})),Hd="ssaoCombinePixelShader",WP=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var originalColorSampler: sampler;var originalColor: texture_2d<f32>;uniform viewport: vec4f;
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
var uv: vec2f=uniforms.viewport.xy+input.vUV*uniforms.viewport.zw;var ssaoColor: vec4f=textureSample(textureSampler,textureSamplerSampler,uv);var sceneColor: vec4f=textureSample(originalColor,originalColorSampler,uv);fragmentOutputs.color=sceneColor*ssaoColor;
#define CUSTOM_FRAGMENT_MAIN_END
}
`;P.ShadersStoreWGSL[Hd]||(P.ShadersStoreWGSL[Hd]=WP);const HV={name:Hd,shader:WP},jV=Object.freeze(Object.defineProperty({__proto__:null,ssaoCombinePixelShaderWGSL:HV},Symbol.toStringTag,{value:"Module"})),ib="screenSpaceRayTrace",YV=`float distanceSquared(vec2 a,vec2 b) { a-=b; return dot(a,a); }
#ifdef SSRAYTRACE_SCREENSPACE_DEPTH
float linearizeDepth(float depth,float near,float far) {
#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE
return -(near*far)/(far-depth*(far-near));
#else
return (near*far)/(far-depth*(far-near));
#endif
}
#endif
/**
param csOrigin Camera-space ray origin,which must be 
within the view volume and must have z>0.01 and project within the valid screen rectangle
param csDirection Unit length camera-space ray direction
param projectToPixelMatrix A projection matrix that maps to **pixel** coordinates 
(**not** [-1,+1] normalized device coordinates).
param csZBuffer The camera-space Z buffer
param csZBufferSize Dimensions of csZBuffer
param csZThickness Camera space csZThickness to ascribe to each pixel in the depth buffer
param nearPlaneZ Positive number. Doesn't have to be THE actual near plane,just a reasonable value
for clipping rays headed towards the camera
param stride Step in horizontal or vertical pixels between samples. This is a float
because integer math is slow on GPUs,but should be set to an integer>=1
param jitterFraction Number between 0 and 1 for how far to bump the ray in stride units
to conceal banding artifacts,plus the stride ray offset.
param maxSteps Maximum number of iterations. Higher gives better images but may be slow
param maxRayTraceDistance Maximum camera-space distance to trace before returning a miss
param selfCollisionNumSkip Number of steps to skip at start when raytracing to avoid self collisions.
1 is a reasonable value,depending on the scene you may need to set this value to 2
param hitPixel Pixel coordinates of the first intersection with the scene
param numIterations number of iterations performed
param csHitPoint Camera space location of the ray hit
*/
#define inline
bool traceScreenSpaceRay1(
vec3 csOrigin,
vec3 csDirection,
mat4 projectToPixelMatrix,
sampler2D csZBuffer,
vec2 csZBufferSize,
#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER
sampler2D csZBackBuffer,
float csZBackSizeFactor,
#endif
float csZThickness,
float nearPlaneZ,
float farPlaneZ,
float stride,
float jitterFraction,
float maxSteps,
float maxRayTraceDistance,
float selfCollisionNumSkip,
out vec2 startPixel,
out vec2 hitPixel,
out vec3 csHitPoint,
out float numIterations
#ifdef SSRAYTRACE_DEBUG
,out vec3 debugColor
#endif
)
{
#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE
float rayLength=(csOrigin.z+csDirection.z*maxRayTraceDistance)>-nearPlaneZ ? (-nearPlaneZ-csOrigin.z)/csDirection.z : maxRayTraceDistance;
#else
float rayLength=(csOrigin.z+csDirection.z*maxRayTraceDistance)<nearPlaneZ ? (nearPlaneZ-csOrigin.z)/csDirection.z : maxRayTraceDistance;
#endif
vec3 csEndPoint=csOrigin+csDirection*rayLength;hitPixel=vec2(-1.0,-1.0);vec4 H0=projectToPixelMatrix*vec4(csOrigin,1.0);vec4 H1=projectToPixelMatrix*vec4(csEndPoint,1.0);float k0=1.0/H0.w;float k1=1.0/H1.w;vec3 Q0=csOrigin*k0;vec3 Q1=csEndPoint*k1;vec2 P0=H0.xy*k0;vec2 P1=H1.xy*k1;
#ifdef SSRAYTRACE_CLIP_TO_FRUSTUM
float xMax=csZBufferSize.x-0.5,xMin=0.5,yMax=csZBufferSize.y-0.5,yMin=0.5;float alpha=0.0;if ((P1.y>yMax) || (P1.y<yMin)) {alpha=(P1.y-((P1.y>yMax) ? yMax : yMin))/(P1.y-P0.y);}
if ((P1.x>xMax) || (P1.x<xMin)) {alpha=max(alpha,(P1.x-((P1.x>xMax) ? xMax : xMin))/(P1.x-P0.x));}
P1=mix(P1,P0,alpha); k1=mix(k1,k0,alpha); Q1=mix(Q1,Q0,alpha);
#endif
P1+=vec2((distanceSquared(P0,P1)<0.0001) ? 0.01 : 0.0);vec2 delta=P1-P0;bool permute=false;if (abs(delta.x)<abs(delta.y)) { 
permute=true;delta=delta.yx;P0=P0.yx;P1=P1.yx; }
float stepDirection=sign(delta.x);float invdx=stepDirection/delta.x;vec2 dP=vec2(stepDirection,delta.y*invdx);vec3 dQ=(Q1-Q0)*invdx;float dk=(k1-k0)*invdx;float zMin=min(csEndPoint.z,csOrigin.z);float zMax=max(csEndPoint.z,csOrigin.z);dP*=stride; dQ*=stride; dk*=stride;P0+=dP*jitterFraction; Q0+=dQ*jitterFraction; k0+=dk*jitterFraction;vec4 pqk=vec4(P0,Q0.z,k0);vec4 dPQK=vec4(dP,dQ.z,dk);startPixel=permute ? P0.yx : P0.xy;float prevZMaxEstimate=csOrigin.z;float rayZMin=prevZMaxEstimate,rayZMax=prevZMaxEstimate;float sceneZMax=rayZMax+1e4;float end=P1.x*stepDirection;bool hit=false;float stepCount;for (stepCount=0.0;stepCount<=selfCollisionNumSkip ||
(pqk.x*stepDirection)<=end &&
stepCount<maxSteps &&
!hit &&
sceneZMax != 0.0; 
pqk+=dPQK,++stepCount)
{hitPixel=permute ? pqk.yx : pqk.xy;rayZMin=prevZMaxEstimate;rayZMax=(dPQK.z*0.5+pqk.z)/(dPQK.w*0.5+pqk.w);rayZMax=clamp(rayZMax,zMin,zMax);prevZMaxEstimate=rayZMax;if (rayZMin>rayZMax) { 
float t=rayZMin; rayZMin=rayZMax; rayZMax=t;}
sceneZMax=texelFetch(csZBuffer,ivec2(hitPixel),0).r;
#ifdef SSRAYTRACE_SCREENSPACE_DEPTH
sceneZMax=linearizeDepth(sceneZMax,nearPlaneZ,farPlaneZ);
#endif
#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE
#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER
float sceneBackZ=texelFetch(csZBackBuffer,ivec2(hitPixel/csZBackSizeFactor),0).r;
#ifdef SSRAYTRACE_SCREENSPACE_DEPTH
sceneBackZ=linearizeDepth(sceneBackZ,nearPlaneZ,farPlaneZ);
#endif
hit=(rayZMax>=sceneBackZ-csZThickness) && (rayZMin<=sceneZMax);
#else
hit=(rayZMax>=sceneZMax-csZThickness) && (rayZMin<=sceneZMax);
#endif
#else
#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER
float sceneBackZ=texelFetch(csZBackBuffer,ivec2(hitPixel/csZBackSizeFactor),0).r;
#ifdef SSRAYTRACE_SCREENSPACE_DEPTH
sceneBackZ=linearizeDepth(sceneBackZ,nearPlaneZ,farPlaneZ);
#endif
hit=(rayZMin<=sceneBackZ+csZThickness) && (rayZMax>=sceneZMax) && (sceneZMax != 0.0);
#else
hit=(rayZMin<=sceneZMax+csZThickness) && (rayZMax>=sceneZMax);
#endif
#endif
}
pqk-=dPQK;stepCount-=1.0;if (((pqk.x+dPQK.x)*stepDirection)>end || (stepCount+1.0)>=maxSteps || sceneZMax==0.0) {hit=false;}
#ifdef SSRAYTRACE_ENABLE_REFINEMENT
if (stride>1.0 && hit) {pqk-=dPQK;stepCount-=1.0;float invStride=1.0/stride;dPQK*=invStride;float refinementStepCount=0.0;prevZMaxEstimate=pqk.z/pqk.w;rayZMax=prevZMaxEstimate;sceneZMax=rayZMax+1e7;for (;refinementStepCount<=1.0 ||
(refinementStepCount<=stride*1.4) &&
(rayZMax<sceneZMax) && (sceneZMax != 0.0);pqk+=dPQK,refinementStepCount+=1.0)
{rayZMin=prevZMaxEstimate;rayZMax=(dPQK.z*0.5+pqk.z)/(dPQK.w*0.5+pqk.w);rayZMax=clamp(rayZMax,zMin,zMax);prevZMaxEstimate=rayZMax;rayZMax=max(rayZMax,rayZMin);hitPixel=permute ? pqk.yx : pqk.xy;sceneZMax=texelFetch(csZBuffer,ivec2(hitPixel),0).r;
#ifdef SSRAYTRACE_SCREENSPACE_DEPTH
sceneZMax=linearizeDepth(sceneZMax,nearPlaneZ,farPlaneZ);
#endif
}
pqk-=dPQK;refinementStepCount-=1.0;stepCount+=refinementStepCount/stride;}
#endif
Q0.xy+=dQ.xy*stepCount;Q0.z=pqk.z;csHitPoint=Q0/pqk.w;numIterations=stepCount+1.0;
#ifdef SSRAYTRACE_DEBUG
if (((pqk.x+dPQK.x)*stepDirection)>end) {debugColor=vec3(0,0,1);} else if ((stepCount+1.0)>=maxSteps) {debugColor=vec3(1,0,0);} else if (sceneZMax==0.0) {debugColor=vec3(1,1,0);} else {debugColor=vec3(0,stepCount/maxSteps,0);}
#endif
return hit;}
/**
texCoord: in the [0,1] range
depth: depth in view space (range [znear,zfar]])
*/
vec3 computeViewPosFromUVDepth(vec2 texCoord,float depth,mat4 projection,mat4 invProjectionMatrix) {vec4 ndc;ndc.xy=texCoord*2.0-1.0;
#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE
#ifdef ORTHOGRAPHIC_CAMERA
ndc.z=-projection[2].z*depth+projection[3].z;
#else
ndc.z=-projection[2].z-projection[3].z/depth;
#endif
#else
#ifdef ORTHOGRAPHIC_CAMERA
ndc.z=projection[2].z*depth+projection[3].z;
#else
ndc.z=projection[2].z+projection[3].z/depth;
#endif
#endif
ndc.w=1.0;vec4 eyePos=invProjectionMatrix*ndc;eyePos.xyz/=eyePos.w;return eyePos.xyz;}
`;P.IncludesShadersStore[ib]||(P.IncludesShadersStore[ib]=YV);const jd="screenSpaceReflection2PixelShader",$P=`#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define TEXTUREFUNC(s,c,lod) texture2DLodEXT(s,c,lod)
#define TEXTURECUBEFUNC(s,c,lod) textureLod(s,c,lod)
#else
#define TEXTUREFUNC(s,c,bias) texture2D(s,c,bias)
#define TEXTURECUBEFUNC(s,c,bias) textureCube(s,c,bias)
#endif
uniform sampler2D textureSampler;varying vec2 vUV;
#ifdef SSR_SUPPORTED
uniform sampler2D reflectivitySampler;uniform sampler2D normalSampler;uniform sampler2D depthSampler;
#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER
uniform sampler2D backDepthSampler;uniform float backSizeFactor;
#endif
#ifdef SSR_USE_ENVIRONMENT_CUBE
uniform samplerCube envCubeSampler;
#ifdef SSR_USE_LOCAL_REFLECTIONMAP_CUBIC
uniform vec3 vReflectionPosition;uniform vec3 vReflectionSize;
#endif
#endif
uniform mat4 view;uniform mat4 invView;uniform mat4 projection;uniform mat4 invProjectionMatrix;uniform mat4 projectionPixel;uniform float nearPlaneZ;uniform float farPlaneZ;uniform float stepSize;uniform float maxSteps;uniform float strength;uniform float thickness;uniform float roughnessFactor;uniform float reflectionSpecularFalloffExponent;uniform float maxDistance;uniform float selfCollisionNumSkip;uniform float reflectivityThreshold;
#include<helperFunctions>
#include<pbrBRDFFunctions>
#include<screenSpaceRayTrace>
vec3 hash(vec3 a)
{a=fract(a*0.8);a+=dot(a,a.yxz+19.19);return fract((a.xxy+a.yxx)*a.zyx);}
float computeAttenuationForIntersection(ivec2 hitPixel,vec2 hitUV,vec3 vsRayOrigin,vec3 vsHitPoint,vec3 reflectionVector,float maxRayDistance,float numIterations) {float attenuation=1.0;
#ifdef SSR_ATTENUATE_SCREEN_BORDERS
vec2 dCoords=smoothstep(0.2,0.6,abs(vec2(0.5,0.5)-hitUV.xy));attenuation*=clamp(1.0-(dCoords.x+dCoords.y),0.0,1.0);
#endif
#ifdef SSR_ATTENUATE_INTERSECTION_DISTANCE
attenuation*=1.0-clamp(distance(vsRayOrigin,vsHitPoint)/maxRayDistance,0.0,1.0);
#endif
#ifdef SSR_ATTENUATE_INTERSECTION_NUMITERATIONS
attenuation*=1.0-(numIterations/maxSteps);
#endif
#ifdef SSR_ATTENUATE_BACKFACE_REFLECTION
vec3 reflectionNormal=texelFetch(normalSampler,hitPixel,0).xyz;float directionBasedAttenuation=smoothstep(-0.17,0.0,dot(reflectionNormal,-reflectionVector));attenuation*=directionBasedAttenuation;
#endif
return attenuation;}
#endif
void main()
{
#ifdef SSR_SUPPORTED
vec4 colorFull=TEXTUREFUNC(textureSampler,vUV,0.0);vec3 color=colorFull.rgb;vec4 reflectivity=max(TEXTUREFUNC(reflectivitySampler,vUV,0.0),vec4(0.));
#ifndef SSR_DISABLE_REFLECTIVITY_TEST
if (max(reflectivity.r,max(reflectivity.g,reflectivity.b))<=reflectivityThreshold) {
#ifdef SSR_USE_BLUR
gl_FragColor=vec4(0.);
#else
gl_FragColor=colorFull;
#endif
return;}
#endif
#ifdef SSR_INPUT_IS_GAMMA_SPACE
color=toLinearSpace(color);
#endif
vec2 texSize=vec2(textureSize(depthSampler,0));vec3 csNormal=texelFetch(normalSampler,ivec2(vUV*texSize),0).xyz; 
#ifdef SSR_DECODE_NORMAL
csNormal=csNormal*2.0-1.0;
#endif
#ifdef SSR_NORMAL_IS_IN_WORLDSPACE
csNormal=(view*vec4(csNormal,0.0)).xyz;
#endif
float depth=texelFetch(depthSampler,ivec2(vUV*texSize),0).r;
#ifdef SSRAYTRACE_SCREENSPACE_DEPTH
depth=linearizeDepth(depth,nearPlaneZ,farPlaneZ);
#endif
vec3 csPosition=computeViewPosFromUVDepth(vUV,depth,projection,invProjectionMatrix);
#ifdef ORTHOGRAPHIC_CAMERA
vec3 csViewDirection=vec3(0.,0.,1.);
#else
vec3 csViewDirection=normalize(csPosition);
#endif
vec3 csReflectedVector=reflect(csViewDirection,csNormal);
#ifdef SSR_USE_ENVIRONMENT_CUBE
vec3 wReflectedVector=vec3(invView*vec4(csReflectedVector,0.0));
#ifdef SSR_USE_LOCAL_REFLECTIONMAP_CUBIC
vec4 worldPos=invView*vec4(csPosition,1.0);wReflectedVector=parallaxCorrectNormal(worldPos.xyz,normalize(wReflectedVector),vReflectionSize,vReflectionPosition);
#endif
#ifdef SSR_INVERTCUBICMAP
wReflectedVector.y*=-1.0;
#endif
#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE
wReflectedVector.z*=-1.0;
#endif
vec3 envColor=TEXTURECUBEFUNC(envCubeSampler,wReflectedVector,0.0).xyz;
#ifdef SSR_ENVIRONMENT_CUBE_IS_GAMMASPACE
envColor=toLinearSpace(envColor);
#endif
#else
vec3 envColor=color;
#endif
float reflectionAttenuation=1.0;bool rayHasHit=false;vec2 startPixel;vec2 hitPixel;vec3 hitPoint;float numIterations;
#ifdef SSRAYTRACE_DEBUG
vec3 debugColor;
#endif
#ifdef SSR_ATTENUATE_FACING_CAMERA
reflectionAttenuation*=1.0-smoothstep(0.25,0.5,dot(-csViewDirection,csReflectedVector));
#endif
if (reflectionAttenuation>0.0) {
#ifdef SSR_USE_BLUR
vec3 jitt=vec3(0.);
#else
float roughness=1.0-reflectivity.a;vec3 jitt=mix(vec3(0.0),hash(csPosition)-vec3(0.5),roughness)*roughnessFactor; 
#endif
vec2 uv2=vUV*texSize;float c=(uv2.x+uv2.y)*0.25;float jitter=mod(c,1.0); 
rayHasHit=traceScreenSpaceRay1(
csPosition,
normalize(csReflectedVector+jitt),
projectionPixel,
depthSampler,
texSize,
#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER
backDepthSampler,
backSizeFactor,
#endif
thickness,
nearPlaneZ,
farPlaneZ,
stepSize,
jitter,
maxSteps,
maxDistance,
selfCollisionNumSkip,
startPixel,
hitPixel,
hitPoint,
numIterations
#ifdef SSRAYTRACE_DEBUG
,debugColor
#endif
);}
#ifdef SSRAYTRACE_DEBUG
gl_FragColor=vec4(debugColor,1.);return;
#endif
vec3 F0=reflectivity.rgb;vec3 fresnel=fresnelSchlickGGX(max(dot(csNormal,-csViewDirection),0.0),F0,vec3(1.));vec3 SSR=envColor;if (rayHasHit) {vec3 reflectedColor=texelFetch(textureSampler,ivec2(hitPixel),0).rgb;
#ifdef SSR_INPUT_IS_GAMMA_SPACE
reflectedColor=toLinearSpace(reflectedColor);
#endif
reflectionAttenuation*=computeAttenuationForIntersection(ivec2(hitPixel),hitPixel/texSize,csPosition,hitPoint,csReflectedVector,maxDistance,numIterations);SSR=reflectedColor*reflectionAttenuation+(1.0-reflectionAttenuation)*envColor;}
#ifndef SSR_BLEND_WITH_FRESNEL
SSR*=fresnel;
#endif
#ifdef SSR_USE_BLUR
float blur_radius=0.0;float roughness=1.0-reflectivity.a*(1.0-roughnessFactor);if (roughness>0.001) {float cone_angle=min(roughness,0.999)*3.14159265*0.5;float cone_len=distance(startPixel,hitPixel);float op_len=2.0*tan(cone_angle)*cone_len; 
float a=op_len;float h=cone_len;float a2=a*a;float fh2=4.0f*h*h;blur_radius=(a*(sqrt(a2+fh2)-a))/(4.0f*h);}
gl_FragColor=vec4(SSR,blur_radius/255.0); 
#else
#ifdef SSR_BLEND_WITH_FRESNEL
vec3 reflectionMultiplier=clamp(pow(fresnel*strength,vec3(reflectionSpecularFalloffExponent)),0.0,1.0);
#else
vec3 reflectionMultiplier=clamp(pow(reflectivity.rgb*strength,vec3(reflectionSpecularFalloffExponent)),0.0,1.0);
#endif
vec3 colorMultiplier=1.0-reflectionMultiplier;vec3 finalColor=(color*colorMultiplier)+(SSR*reflectionMultiplier);
#ifdef SSR_OUTPUT_IS_GAMMA_SPACE
finalColor=toGammaSpace(finalColor);
#endif
gl_FragColor=vec4(finalColor,colorFull.a);
#endif
#else
gl_FragColor=TEXTUREFUNC(textureSampler,vUV,0.0);
#endif
}
`;P.ShadersStore[jd]||(P.ShadersStore[jd]=$P);const XV={name:jd,shader:$P},ZV=Object.freeze(Object.defineProperty({__proto__:null,screenSpaceReflection2PixelShader:XV},Symbol.toStringTag,{value:"Module"})),Yd="screenSpaceReflection2BlurPixelShader",HP=`#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define TEXTUREFUNC(s,c,lod) texture2DLodEXT(s,c,lod)
#else
#define TEXTUREFUNC(s,c,bias) texture2D(s,c,bias)
#endif
uniform sampler2D textureSampler;varying vec2 vUV;uniform vec2 texelOffsetScale;const float weights[8]=float[8] (0.071303,0.131514,0.189879,0.321392,0.452906, 0.584419,0.715932,0.847445);void processSample(vec2 uv,float i,vec2 stepSize,inout vec4 accumulator,inout float denominator)
{vec2 offsetUV=stepSize*i+uv;float coefficient=weights[int(2.0-abs(i))];accumulator+=TEXTUREFUNC(textureSampler,offsetUV,0.0)*coefficient;denominator+=coefficient;}
void main()
{vec4 colorFull=TEXTUREFUNC(textureSampler,vUV,0.0);if (dot(colorFull,vec4(1.0))==0.0) {gl_FragColor=colorFull;return;}
float blurRadius=colorFull.a*255.0; 
vec2 stepSize=texelOffsetScale.xy*blurRadius;vec4 accumulator=TEXTUREFUNC(textureSampler,vUV,0.0)*0.214607;float denominator=0.214607;processSample(vUV,1.0,stepSize,accumulator,denominator);processSample(vUV,1.0*0.2,stepSize,accumulator,denominator);processSample(vUV,1.0*0.4,stepSize,accumulator,denominator);processSample(vUV,1.0*0.6,stepSize,accumulator,denominator);processSample(vUV,1.0*0.8,stepSize,accumulator,denominator);processSample(vUV,1.0*1.2,stepSize,accumulator,denominator);processSample(vUV,1.0*1.4,stepSize,accumulator,denominator);processSample(vUV,1.0*1.6,stepSize,accumulator,denominator);processSample(vUV,1.0*1.8,stepSize,accumulator,denominator);processSample(vUV,1.0*2.0,stepSize,accumulator,denominator);processSample(vUV,-1.0,stepSize,accumulator,denominator);processSample(vUV,-1.0*0.2,stepSize,accumulator,denominator);processSample(vUV,-1.0*0.4,stepSize,accumulator,denominator);processSample(vUV,-1.0*0.6,stepSize,accumulator,denominator);processSample(vUV,-1.0*0.8,stepSize,accumulator,denominator);processSample(vUV,-1.0*1.2,stepSize,accumulator,denominator);processSample(vUV,-1.0*1.4,stepSize,accumulator,denominator);processSample(vUV,-1.0*1.6,stepSize,accumulator,denominator);processSample(vUV,-1.0*1.8,stepSize,accumulator,denominator);processSample(vUV,-1.0*2.0,stepSize,accumulator,denominator);gl_FragColor=vec4(accumulator.rgb/denominator,colorFull.a);}
`;P.ShadersStore[Yd]||(P.ShadersStore[Yd]=HP);const qV={name:Yd,shader:HP},QV=Object.freeze(Object.defineProperty({__proto__:null,screenSpaceReflection2BlurPixelShader:qV},Symbol.toStringTag,{value:"Module"})),Xd="screenSpaceReflection2BlurCombinerPixelShader",jP=`uniform sampler2D textureSampler; 
uniform sampler2D mainSampler;uniform sampler2D reflectivitySampler;uniform float strength;uniform float reflectionSpecularFalloffExponent;uniform float reflectivityThreshold;varying vec2 vUV;
#include<helperFunctions>
#ifdef SSR_BLEND_WITH_FRESNEL
#include<pbrBRDFFunctions>
#include<screenSpaceRayTrace>
uniform mat4 projection;uniform mat4 invProjectionMatrix;
#ifdef SSR_NORMAL_IS_IN_WORLDSPACE
uniform mat4 view;
#endif
uniform sampler2D normalSampler;uniform sampler2D depthSampler;
#ifdef SSRAYTRACE_SCREENSPACE_DEPTH
uniform float nearPlaneZ;uniform float farPlaneZ;
#endif
#endif
void main()
{
#ifdef SSRAYTRACE_DEBUG
gl_FragColor=texture2D(textureSampler,vUV);
#else
vec3 SSR=texture2D(textureSampler,vUV).rgb;vec4 color=texture2D(mainSampler,vUV);vec4 reflectivity=texture2D(reflectivitySampler,vUV);
#ifndef SSR_DISABLE_REFLECTIVITY_TEST
if (max(reflectivity.r,max(reflectivity.g,reflectivity.b))<=reflectivityThreshold) {gl_FragColor=color;return;}
#endif
#ifdef SSR_INPUT_IS_GAMMA_SPACE
color=toLinearSpace(color);
#endif
#ifdef SSR_BLEND_WITH_FRESNEL
vec2 texSize=vec2(textureSize(depthSampler,0));vec3 csNormal=texelFetch(normalSampler,ivec2(vUV*texSize),0).xyz;
#ifdef SSR_DECODE_NORMAL
csNormal=csNormal*2.0-1.0;
#endif
#ifdef SSR_NORMAL_IS_IN_WORLDSPACE
csNormal=(view*vec4(csNormal,0.0)).xyz;
#endif
float depth=texelFetch(depthSampler,ivec2(vUV*texSize),0).r;
#ifdef SSRAYTRACE_SCREENSPACE_DEPTH
depth=linearizeDepth(depth,nearPlaneZ,farPlaneZ);
#endif
vec3 csPosition=computeViewPosFromUVDepth(vUV,depth,projection,invProjectionMatrix);vec3 csViewDirection=normalize(csPosition);vec3 F0=reflectivity.rgb;vec3 fresnel=fresnelSchlickGGX(max(dot(csNormal,-csViewDirection),0.0),F0,vec3(1.));vec3 reflectionMultiplier=clamp(pow(fresnel*strength,vec3(reflectionSpecularFalloffExponent)),0.0,1.0);
#else
vec3 reflectionMultiplier=clamp(pow(reflectivity.rgb*strength,vec3(reflectionSpecularFalloffExponent)),0.0,1.0);
#endif
vec3 colorMultiplier=1.0-reflectionMultiplier;vec3 finalColor=(color.rgb*colorMultiplier)+(SSR*reflectionMultiplier);
#ifdef SSR_OUTPUT_IS_GAMMA_SPACE
finalColor=toGammaSpace(finalColor);
#endif
gl_FragColor=vec4(finalColor,color.a);
#endif
}
`;P.ShadersStore[Xd]||(P.ShadersStore[Xd]=jP);const KV={name:Xd,shader:jP},JV=Object.freeze(Object.defineProperty({__proto__:null,screenSpaceReflection2BlurCombinerPixelShader:KV},Symbol.toStringTag,{value:"Module"})),rb="screenSpaceRayTrace",e3=`fn distanceSquared(a: vec2f,b: vec2f)->f32 { 
var temp=a-b; 
return dot(temp,temp); }
#ifdef SSRAYTRACE_SCREENSPACE_DEPTH
fn linearizeDepth(depth: f32,near: f32,far: f32)->f32 {
#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE
return -(near*far)/(far-depth*(far-near));
#else
return (near*far)/(far-depth*(far-near));
#endif
}
#endif
/**
param csOrigin Camera-space ray origin,which must be 
within the view volume and must have z>0.01 and project within the valid screen rectangle
param csDirection Unit length camera-space ray direction
param projectToPixelMatrix A projection matrix that maps to **pixel** coordinates 
(**not** [-1,+1] normalized device coordinates).
param csZBuffer The camera-space Z buffer
param csZBufferSize Dimensions of csZBuffer
param csZThickness Camera space csZThickness to ascribe to each pixel in the depth buffer
param nearPlaneZ Positive number. Doesn't have to be THE actual near plane,just a reasonable value
for clipping rays headed towards the camera. Should be the actual near plane if screen-space depth is enabled.
param farPlaneZ The far plane for the camera. Used when screen-space depth is enabled.
param stride Step in horizontal or vertical pixels between samples. This is a var because: f32 integer math is slow on GPUs,but should be set to an integer>=1
param jitterFraction Number between 0 and 1 for how far to bump the ray in stride units
to conceal banding artifacts,plus the stride ray offset.
param maxSteps Maximum number of iterations. Higher gives better images but may be slow
param maxRayTraceDistance Maximum camera-space distance to trace before returning a miss
param selfCollisionNumSkip Number of steps to skip at start when raytracing to avar self: voidnull collisions.
1 is a reasonable value,depending on the scene you may need to set this value to 2
param hitPixel Pixel coordinates of the first intersection with the scene
param numIterations number of iterations performed
param csHitPovar Camera: i32 space location of the ray hit
*/
fn traceScreenSpaceRay1(
csOrigin: vec3f,
csDirection: vec3f,
projectToPixelMatrix: mat4x4f,
csZBuffer: texture_2d<f32>,
csZBufferSize: vec2f,
#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER
csZBackBuffer: texture_2d<f32>,
csZBackSizeFactor: f32,
#endif
csZThickness: f32,
nearPlaneZ: f32,
farPlaneZ: f32,
stride: f32,
jitterFraction: f32,
maxSteps: f32,
maxRayTraceDistance: f32,
selfCollisionNumSkip: f32,
startPixel: ptr<function,vec2f>,
hitPixel: ptr<function,vec2f>,
csHitPoint: ptr<function,vec3f>,
numIterations: ptr<function,f32>
#ifdef SSRAYTRACE_DEBUG
,debugColor: ptr<function,vec3f>
#endif
)->bool
{
#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE
var rayLength: f32=select(maxRayTraceDistance,(-nearPlaneZ-csOrigin.z)/csDirection.z,(csOrigin.z+csDirection.z*maxRayTraceDistance)>-nearPlaneZ);
#else
var rayLength: f32=select(maxRayTraceDistance,(nearPlaneZ-csOrigin.z)/csDirection.z,(csOrigin.z+csDirection.z*maxRayTraceDistance)<nearPlaneZ);
#endif
var csEndPoint: vec3f=csOrigin+csDirection*rayLength;*hitPixel= vec2f(-1.0,-1.0);var H0: vec4f=projectToPixelMatrix* vec4f(csOrigin,1.0);var H1: vec4f=projectToPixelMatrix* vec4f(csEndPoint,1.0);var k0: f32=1.0/H0.w;var k1: f32=1.0/H1.w;var Q0: vec3f=csOrigin*k0;var Q1: vec3f=csEndPoint*k1;var P0: vec2f=H0.xy*k0;var P1: vec2f=H1.xy*k1;
#ifdef SSRAYTRACE_CLIP_TO_FRUSTUM
var xMax: f32=csZBufferSize.x-0.5;var xMin=0.5;var yMax=csZBufferSize.y-0.5;var yMin=0.5;var alpha: f32=0.0;if ((P1.y>yMax) || (P1.y<yMin)) {alpha=(P1.y-select(yMin,yMax,(P1.y>yMax)))/(P1.y-P0.y);}
if ((P1.x>xMax) || (P1.x<xMin)) {alpha=max(alpha,(P1.x-select(xMin,xMax,(P1.x>xMax)))/(P1.x-P0.x));}
P1=mix(P1,P0,alpha); k1=mix(k1,k0,alpha); Q1=mix(Q1,Q0,alpha);
#endif
P1+= vec2f(select(0.0,0.01,distanceSquared(P0,P1)<0.0001));var delta: vec2f=P1-P0;var permute: bool=false;if (abs(delta.x)<abs(delta.y)) { 
permute=true;delta=delta.yx;P0=P0.yx;P1=P1.yx; }
var stepDirection: f32=sign(delta.x);var invdx: f32=stepDirection/delta.x;var dP: vec2f= vec2f(stepDirection,delta.y*invdx);var dQ: vec3f=(Q1-Q0)*invdx;var dk: f32=(k1-k0)*invdx;var zMin: f32=min(csEndPoint.z,csOrigin.z);var zMax: f32=max(csEndPoint.z,csOrigin.z);dP*=stride; dQ*=stride; dk*=stride;P0+=dP*jitterFraction; Q0+=dQ*jitterFraction; k0+=dk*jitterFraction;var pqk: vec4f= vec4f(P0,Q0.z,k0);var dPQK: vec4f= vec4f(dP,dQ.z,dk);*startPixel=select(P0.xy,P0.yx,permute);var prevZMaxEstimate: f32=csOrigin.z;var rayZMin: f32=prevZMaxEstimate;var rayZMax=prevZMaxEstimate;var sceneZMax: f32=rayZMax+1e4;var end: f32=P1.x*stepDirection;var hit: bool=false;var stepCount: f32;for (stepCount=0.0;(stepCount<=selfCollisionNumSkip) ||
((pqk.x*stepDirection)<=end &&
stepCount<maxSteps &&
!hit &&
sceneZMax != 0.0);pqk+=dPQK 
)
{*hitPixel=select(pqk.xy,pqk.yx,permute);rayZMin=prevZMaxEstimate;rayZMax=(dPQK.z*0.5+pqk.z)/(dPQK.w*0.5+pqk.w);rayZMax=clamp(rayZMax,zMin,zMax);prevZMaxEstimate=rayZMax;if (rayZMin>rayZMax) { 
var t: f32=rayZMin; rayZMin=rayZMax; rayZMax=t;}
sceneZMax=textureLoad(csZBuffer,vec2<i32>(*hitPixel),0).r;
#ifdef SSRAYTRACE_SCREENSPACE_DEPTH
sceneZMax=linearizeDepth(sceneZMax,nearPlaneZ,farPlaneZ);
#endif
#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE
#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER
var sceneBackZ: f32=textureLoad(csZBackBuffer,vec2<i32>(*hitPixel/csZBackSizeFactor),0).r;
#ifdef SSRAYTRACE_SCREENSPACE_DEPTH
sceneBackZ=linearizeDepth(sceneBackZ,nearPlaneZ,farPlaneZ);
#endif
hit=(rayZMax>=sceneBackZ-csZThickness) && (rayZMin<=sceneZMax);
#else
hit=(rayZMax>=sceneZMax-csZThickness) && (rayZMin<=sceneZMax);
#endif
#else
#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER
var sceneBackZ: f32=textureLoad(csZBackBuffer,vec2<i32>(*hitPixel/csZBackSizeFactor),0).r;
#ifdef SSRAYTRACE_SCREENSPACE_DEPTH
sceneBackZ=linearizeDepth(sceneBackZ,nearPlaneZ,farPlaneZ);
#endif
hit=(rayZMin<=sceneBackZ+csZThickness) && (rayZMax>=sceneZMax) && (sceneZMax != 0.0);
#else
hit=(rayZMin<=sceneZMax+csZThickness) && (rayZMax>=sceneZMax);
#endif
#endif
stepCount+=1.0;}
pqk-=dPQK;stepCount-=1.0;if (((pqk.x+dPQK.x)*stepDirection)>end || (stepCount+1.0)>=maxSteps || sceneZMax==0.0) {hit=false;}
#ifdef SSRAYTRACE_ENABLE_REFINEMENT
if (stride>1.0 && hit) {pqk-=dPQK;stepCount-=1.0;var invStride: f32=1.0/stride;dPQK*=invStride;var refinementStepCount: f32=0.0;prevZMaxEstimate=pqk.z/pqk.w;rayZMax=prevZMaxEstimate;sceneZMax=rayZMax+1e7;for (;refinementStepCount<=1.0 ||
((refinementStepCount<=stride*1.4) &&
(rayZMax<sceneZMax) && (sceneZMax != 0.0));pqk+=dPQK)
{rayZMin=prevZMaxEstimate;rayZMax=(dPQK.z*0.5+pqk.z)/(dPQK.w*0.5+pqk.w);rayZMax=clamp(rayZMax,zMin,zMax);prevZMaxEstimate=rayZMax;rayZMax=max(rayZMax,rayZMin);*hitPixel=select(pqk.xy,pqk.yx,permute);sceneZMax=textureLoad(csZBuffer,vec2<i32>(*hitPixel),0).r;
#ifdef SSRAYTRACE_SCREENSPACE_DEPTH
sceneZMax=linearizeDepth(sceneZMax,nearPlaneZ,farPlaneZ);
#endif
refinementStepCount+=1.0;}
pqk-=dPQK;refinementStepCount-=1.0;stepCount+=refinementStepCount/stride;}
#endif
Q0=vec3f(Q0.xy+dQ.xy*stepCount,pqk.z);*csHitPoint=Q0/pqk.w;*numIterations=stepCount+1.0;
#ifdef SSRAYTRACE_DEBUG
if (((pqk.x+dPQK.x)*stepDirection)>end) {*debugColor= vec3f(0,0,1);} else if ((stepCount+1.0)>=maxSteps) {*debugColor= vec3f(1,0,0);} else if (sceneZMax==0.0) {*debugColor= vec3f(1,1,0);} else {*debugColor= vec3f(0,stepCount/maxSteps,0);}
#endif
return hit;}
/**
texCoord: in the [0,1] range
depth: depth in view space (range [znear,zfar]])
*/
fn computeViewPosFromUVDepth(texCoord: vec2f,depth: f32,projection: mat4x4f,invProjectionMatrix: mat4x4f)->vec3f {var xy=texCoord*2.0-1.0;var z: f32;
#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE
#ifdef ORTHOGRAPHIC_CAMERA
z=-projection[2].z*depth+projection[3].z;
#else
z=-projection[2].z-projection[3].z/depth;
#endif
#else
#ifdef ORTHOGRAPHIC_CAMERA
z=projection[2].z*depth+projection[3].z;
#else
z=projection[2].z+projection[3].z/depth;
#endif
#endif
var w=1.0;var ndc=vec4f(xy,z,w);var eyePos: vec4f=invProjectionMatrix*ndc;var result=eyePos.xyz/eyePos.w;return result;}
`;P.IncludesShadersStoreWGSL[rb]||(P.IncludesShadersStoreWGSL[rb]=e3);const Zd="screenSpaceReflection2PixelShader",YP=`var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;varying vUV: vec2f;
#ifdef SSR_SUPPORTED
var reflectivitySamplerSampler: sampler;var reflectivitySampler: texture_2d<f32>;var normalSampler: texture_2d<f32>;var depthSampler: texture_2d<f32>;
#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER
var backDepthSampler: texture_2d<f32>;uniform backSizeFactor: f32;
#endif
#ifdef SSR_USE_ENVIRONMENT_CUBE
var envCubeSamplerSampler: sampler;var envCubeSampler: texture_cube<f32>;
#ifdef SSR_USE_LOCAL_REFLECTIONMAP_CUBIC
uniform vReflectionPosition: vec3f;uniform vReflectionSize: vec3f;
#endif
#endif
uniform view: mat4x4f;uniform invView: mat4x4f;uniform projection: mat4x4f;uniform invProjectionMatrix: mat4x4f;uniform projectionPixel: mat4x4f;uniform nearPlaneZ: f32;uniform farPlaneZ: f32;uniform stepSize: f32;uniform maxSteps: f32;uniform strength: f32;uniform thickness: f32;uniform roughnessFactor: f32;uniform reflectionSpecularFalloffExponent: f32;uniform maxDistance: f32;uniform selfCollisionNumSkip: f32;uniform reflectivityThreshold: f32;
#include<helperFunctions>
#include<pbrBRDFFunctions>
#include<screenSpaceRayTrace>
fn hash(a: vec3f)->vec3f
{var result=fract(a*0.8);result+=dot(result,result.yxz+19.19);return fract((result.xxy+result.yxx)*result.zyx);}
fn computeAttenuationForIntersection(ihitPixel: vec2f,hitUV: vec2f,vsRayOrigin: vec3f,vsHitPoint: vec3f,reflectionVector: vec3f,maxRayDistance: f32,numIterations: f32)->f32 {var attenuation: f32=1.0;
#ifdef SSR_ATTENUATE_SCREEN_BORDERS
var dCoords: vec2f=smoothstep(vec2f(0.2),vec2f(0.6),abs( vec2f(0.5,0.5)-hitUV.xy));attenuation*=clamp(1.0-(dCoords.x+dCoords.y),0.0,1.0);
#endif
#ifdef SSR_ATTENUATE_INTERSECTION_DISTANCE
attenuation*=1.0-clamp(distance(vsRayOrigin,vsHitPoint)/maxRayDistance,0.0,1.0);
#endif
#ifdef SSR_ATTENUATE_INTERSECTION_NUMITERATIONS
attenuation*=1.0-(numIterations/uniforms.maxSteps);
#endif
#ifdef SSR_ATTENUATE_BACKFACE_REFLECTION
var reflectionNormal: vec3f=texelFetch(normalSampler,hitPixel,0).xyz;var directionBasedAttenuation: f32=smoothstep(-0.17,0.0,dot(reflectionNormal,-reflectionVector));attenuation*=directionBasedAttenuation;
#endif
return attenuation;}
#endif
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#ifdef SSR_SUPPORTED
var colorFull: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.0);var color: vec3f=colorFull.rgb;var reflectivity: vec4f=max(textureSampleLevel(reflectivitySampler,reflectivitySamplerSampler,input.vUV,0.0),vec4f(0.0));
#ifndef SSR_DISABLE_REFLECTIVITY_TEST
if (max(reflectivity.r,max(reflectivity.g,reflectivity.b))<=uniforms.reflectivityThreshold) {
#ifdef SSR_USE_BLUR
fragmentOutputs.color= vec4f(0.);
#else
fragmentOutputs.color=colorFull;
#endif
return fragmentOutputs;}
#endif
#ifdef SSR_INPUT_IS_GAMMA_SPACE
color=toLinearSpaceVec3(color);
#endif
var texSize: vec2f= vec2f(textureDimensions(depthSampler,0));var csNormal: vec3f=textureLoad(normalSampler,vec2<i32>(input.vUV*texSize),0).xyz; 
#ifdef SSR_DECODE_NORMAL
csNormal=csNormal*2.0-1.0;
#endif
#ifdef SSR_NORMAL_IS_IN_WORLDSPACE
csNormal=(uniforms.view* vec4f(csNormal,0.0)).xyz;
#endif
var depth: f32=textureLoad(depthSampler,vec2<i32>(input.vUV*texSize),0).r;
#ifdef SSRAYTRACE_SCREENSPACE_DEPTH
depth=linearizeDepth(depth,uniforms.nearPlaneZ,uniforms.farPlaneZ);
#endif
var csPosition: vec3f=computeViewPosFromUVDepth(input.vUV,depth,uniforms.projection,uniforms.invProjectionMatrix);
#ifdef ORTHOGRAPHIC_CAMERA
var csViewDirection: vec3f= vec3f(0.,0.,1.);
#else
var csViewDirection: vec3f=normalize(csPosition);
#endif
var csReflectedVector: vec3f=reflect(csViewDirection,csNormal);
#ifdef SSR_USE_ENVIRONMENT_CUBE
var wReflectedVector: vec3f=(uniforms.invView* vec4f(csReflectedVector,0.0)).xyz;
#ifdef SSR_USE_LOCAL_REFLECTIONMAP_CUBIC
var worldPos: vec4f=uniforms.invView* vec4f(csPosition,1.0);wReflectedVector=parallaxCorrectNormal(worldPos.xyz,normalize(wReflectedVector),uniforms.vReflectionSize,uniforms.vReflectionPosition);
#endif
#ifdef SSR_INVERTCUBICMAP
wReflectedVector.y*=-1.0;
#endif
#ifdef SSRAYTRACE_RIGHT_HANDED_SCENE
wReflectedVector.z*=-1.0;
#endif
var envColor: vec3f=textureSampleLevel(envCubeSampler,envCubeSamplerSampler,wReflectedVector,0.0).xyz;
#ifdef SSR_ENVIRONMENT_CUBE_IS_GAMMASPACE
envColor=toLinearSpaceVec3(envColor);
#endif
#else
var envColor: vec3f=color;
#endif
var reflectionAttenuation: f32=1.0;var rayHasHit: bool=false;var startPixel: vec2f;var hitPixel: vec2f;var hitPoint: vec3f;var numIterations: f32;
#ifdef SSRAYTRACE_DEBUG
var debugColor: vec3f;
#endif
#ifdef SSR_ATTENUATE_FACING_CAMERA
reflectionAttenuation*=1.0-smoothstep(0.25,0.5,dot(-csViewDirection,csReflectedVector));
#endif
if (reflectionAttenuation>0.0) {
#ifdef SSR_USE_BLUR
var jitt: vec3f= vec3f(0.);
#else
var roughness: f32=1.0-reflectivity.a;var jitt: vec3f=mix( vec3f(0.0),hash(csPosition)- vec3f(0.5),roughness)*uniforms.roughnessFactor; 
#endif
var uv2: vec2f=input.vUV*texSize;var c: f32=(uv2.x+uv2.y)*0.25;var jitter: f32=((c)%(1.0)); 
rayHasHit=traceScreenSpaceRay1(
csPosition,
normalize(csReflectedVector+jitt),
uniforms.projectionPixel,
depthSampler,
texSize,
#ifdef SSRAYTRACE_USE_BACK_DEPTHBUFFER
backDepthSampler,
uniforms.backSizeFactor,
#endif
uniforms.thickness,
uniforms.nearPlaneZ,
uniforms.farPlaneZ,
uniforms.stepSize,
jitter,
uniforms.maxSteps,
uniforms.maxDistance,
uniforms.selfCollisionNumSkip,
&startPixel,
&hitPixel,
&hitPoint,
&numIterations
#ifdef SSRAYTRACE_DEBUG
,&debugColor
#endif
);}
#ifdef SSRAYTRACE_DEBUG
fragmentOutputs.color= vec4f(debugColor,1.);return fragmentOutputs;
#endif
var F0: vec3f=reflectivity.rgb;var fresnel: vec3f=fresnelSchlickGGXVec3(max(dot(csNormal,-csViewDirection),0.0),F0, vec3f(1.));var SSR: vec3f=envColor;if (rayHasHit) {var reflectedColor: vec3f=textureLoad(textureSampler,vec2<i32>(hitPixel),0).rgb;
#ifdef SSR_INPUT_IS_GAMMA_SPACE
reflectedColor=toLinearSpaceVec3(reflectedColor);
#endif
reflectionAttenuation*=computeAttenuationForIntersection(hitPixel,hitPixel/texSize,csPosition,hitPoint,csReflectedVector,uniforms.maxDistance,numIterations);SSR=reflectedColor*reflectionAttenuation+(1.0-reflectionAttenuation)*envColor;}
#ifndef SSR_BLEND_WITH_FRESNEL
SSR*=fresnel;
#endif
#ifdef SSR_USE_BLUR
var blur_radius: f32=0.0;var roughness: f32=1.0-reflectivity.a*(1.0-uniforms.roughnessFactor);if (roughness>0.001) {var cone_angle: f32=min(roughness,0.999)*3.14159265*0.5;var cone_len: f32=distance(startPixel,hitPixel);var op_len: f32=2.0*tan(cone_angle)*cone_len; 
var a: f32=op_len;var h: f32=cone_len;var a2: f32=a*a;var fh2: f32=4.0f*h*h;blur_radius=(a*(sqrt(a2+fh2)-a))/(4.0f*h);}
fragmentOutputs.color= vec4f(SSR,blur_radius/255.0); 
#else
#ifdef SSR_BLEND_WITH_FRESNEL
var reflectionMultiplier: vec3f=clamp(pow(fresnel*uniforms.strength, vec3f(uniforms.reflectionSpecularFalloffExponent)),vec3f(0.0),vec3f(1.0));
#else
var reflectionMultiplier: vec3f=clamp(pow(reflectivity.rgb*uniforms.strength, vec3f(uniforms.reflectionSpecularFalloffExponent)),vec3f(0.0),vec3f(1.0));
#endif
var colorMultiplier: vec3f=1.0-reflectionMultiplier;var finalColor: vec3f=(color*colorMultiplier)+(SSR*reflectionMultiplier);
#ifdef SSR_OUTPUT_IS_GAMMA_SPACE
finalColor=toGammaSpaceVec3(finalColor);
#endif
fragmentOutputs.color= vec4f(finalColor,colorFull.a);
#endif
#else
fragmentOutputs.color=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.0);
#endif
}
`;P.ShadersStoreWGSL[Zd]||(P.ShadersStoreWGSL[Zd]=YP);const t3={name:Zd,shader:YP},i3=Object.freeze(Object.defineProperty({__proto__:null,screenSpaceReflection2PixelShaderWGSL:t3},Symbol.toStringTag,{value:"Module"})),qd="screenSpaceReflection2BlurPixelShader",XP=`var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;varying vUV: vec2f;uniform texelOffsetScale: vec2f;const weights: array<f32,8>=array<f32,8>(0.071303,0.131514,0.189879,0.321392,0.452906, 0.584419,0.715932,0.847445);fn processSample(uv: vec2f,i: f32,stepSize: vec2f,accumulator: ptr<function,vec4f>,denominator: ptr<function,f32>)
{var offsetUV: vec2f=stepSize*i+uv;var coefficient: f32=weights[ i32(2.0-abs(i))];*accumulator+=textureSampleLevel(textureSampler,textureSamplerSampler,offsetUV,0.0)*coefficient;*denominator+=coefficient;}
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var colorFull: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.0);if (dot(colorFull, vec4f(1.0))==0.0) {fragmentOutputs.color=colorFull;return fragmentOutputs;}
var blurRadius: f32=colorFull.a*255.0; 
var stepSize: vec2f=uniforms.texelOffsetScale.xy*blurRadius;var accumulator: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.0)*0.214607;var denominator: f32=0.214607;processSample(input.vUV,1.0,stepSize,&accumulator,&denominator);processSample(input.vUV,1.0*0.2,stepSize,&accumulator,&denominator);processSample(input.vUV,1.0*0.4,stepSize,&accumulator,&denominator);processSample(input.vUV,1.0*0.6,stepSize,&accumulator,&denominator);processSample(input.vUV,1.0*0.8,stepSize,&accumulator,&denominator);processSample(input.vUV,1.0*1.2,stepSize,&accumulator,&denominator);processSample(input.vUV,1.0*1.4,stepSize,&accumulator,&denominator);processSample(input.vUV,1.0*1.6,stepSize,&accumulator,&denominator);processSample(input.vUV,1.0*1.8,stepSize,&accumulator,&denominator);processSample(input.vUV,1.0*2.0,stepSize,&accumulator,&denominator);processSample(input.vUV,-1.0,stepSize,&accumulator,&denominator);processSample(input.vUV,-1.0*0.2,stepSize,&accumulator,&denominator);processSample(input.vUV,-1.0*0.4,stepSize,&accumulator,&denominator);processSample(input.vUV,-1.0*0.6,stepSize,&accumulator,&denominator);processSample(input.vUV,-1.0*0.8,stepSize,&accumulator,&denominator);processSample(input.vUV,-1.0*1.2,stepSize,&accumulator,&denominator);processSample(input.vUV,-1.0*1.4,stepSize,&accumulator,&denominator);processSample(input.vUV,-1.0*1.6,stepSize,&accumulator,&denominator);processSample(input.vUV,-1.0*1.8,stepSize,&accumulator,&denominator);processSample(input.vUV,-1.0*2.0,stepSize,&accumulator,&denominator);fragmentOutputs.color= vec4f(accumulator.rgb/denominator,colorFull.a);}
`;P.ShadersStoreWGSL[qd]||(P.ShadersStoreWGSL[qd]=XP);const r3={name:qd,shader:XP},s3=Object.freeze(Object.defineProperty({__proto__:null,screenSpaceReflection2BlurPixelShaderWGSL:r3},Symbol.toStringTag,{value:"Module"})),Qd="screenSpaceReflection2BlurCombinerPixelShader",ZP=`var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>; 
var mainSamplerSampler: sampler;var mainSampler: texture_2d<f32>;var reflectivitySamplerSampler: sampler;var reflectivitySampler: texture_2d<f32>;uniform strength: f32;uniform reflectionSpecularFalloffExponent: f32;uniform reflectivityThreshold: f32;varying vUV: vec2f;
#include<helperFunctions>
#ifdef SSR_BLEND_WITH_FRESNEL
#include<pbrBRDFFunctions>
#include<screenSpaceRayTrace>
uniform projection: mat4x4f;uniform invProjectionMatrix: mat4x4f;
#ifdef SSR_NORMAL_IS_IN_WORLDSPACE
uniform view: mat4x4f;
#endif
var normalSampler: texture_2d<f32>;var depthSampler: texture_2d<f32>;
#ifdef SSRAYTRACE_SCREENSPACE_DEPTH
uniform nearPlaneZ: f32;uniform farPlaneZ: f32;
#endif
#endif
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#ifdef SSRAYTRACE_DEBUG
fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,input.vUV);
#else
var SSR: vec3f=textureSample(textureSampler,textureSamplerSampler,input.vUV).rgb;var color: vec4f=textureSample(mainSampler,textureSamplerSampler,input.vUV);var reflectivity: vec4f=textureSample(reflectivitySampler,reflectivitySamplerSampler,input.vUV);
#ifndef SSR_DISABLE_REFLECTIVITY_TEST
if (max(reflectivity.r,max(reflectivity.g,reflectivity.b))<=uniforms.reflectivityThreshold) {fragmentOutputs.color=color;return fragmentOutputs;}
#endif
#ifdef SSR_INPUT_IS_GAMMA_SPACE
color=toLinearSpaceVec4(color);
#endif
#ifdef SSR_BLEND_WITH_FRESNEL
var texSize: vec2f= vec2f(textureDimensions(depthSampler,0));var csNormal: vec3f=textureLoad(normalSampler,vec2<i32>(input.vUV*texSize),0).xyz;
#ifdef SSR_DECODE_NORMAL
csNormal=csNormal*2.0-1.0;
#endif
#ifdef SSR_NORMAL_IS_IN_WORLDSPACE
csNormal=(uniforms.view*vec4f(csNormal,0.0)).xyz;
#endif
var depth: f32=textureLoad(depthSampler,vec2<i32>(input.vUV*texSize),0).r;
#ifdef SSRAYTRACE_SCREENSPACE_DEPTH
depth=linearizeDepth(depth,uniforms.nearPlaneZ,uniforms.farPlaneZ);
#endif
var csPosition: vec3f=computeViewPosFromUVDepth(input.vUV,depth,uniforms.projection,uniforms.invProjectionMatrix);var csViewDirection: vec3f=normalize(csPosition);var F0: vec3f=reflectivity.rgb;var fresnel: vec3f=fresnelSchlickGGXVec3(max(dot(csNormal,-csViewDirection),0.0),F0, vec3f(1.));var reflectionMultiplier: vec3f=clamp(pow(fresnel*uniforms.strength, vec3f(uniforms.reflectionSpecularFalloffExponent)),vec3f(0.0),vec3f(1.0));
#else
var reflectionMultiplier: vec3f=clamp(pow(reflectivity.rgb*uniforms.strength, vec3f(uniforms.reflectionSpecularFalloffExponent)),vec3f(0.0),vec3f(1.0));
#endif
var colorMultiplier: vec3f=1.0-reflectionMultiplier;var finalColor: vec3f=(color.rgb*colorMultiplier)+(SSR*reflectionMultiplier);
#ifdef SSR_OUTPUT_IS_GAMMA_SPACE
finalColor=toGammaSpaceVec3(finalColor);
#endif
fragmentOutputs.color= vec4f(finalColor,color.a);
#endif
}
`;P.ShadersStoreWGSL[Qd]||(P.ShadersStoreWGSL[Qd]=ZP);const n3={name:Qd,shader:ZP},a3=Object.freeze(Object.defineProperty({__proto__:null,screenSpaceReflection2BlurCombinerPixelShaderWGSL:n3},Symbol.toStringTag,{value:"Module"})),Kd="taaPixelShader",qP=`varying vec2 vUV;uniform sampler2D textureSampler;uniform sampler2D historySampler;uniform float factor;void main() {vec4 c=texelFetch(textureSampler,ivec2(gl_FragCoord.xy),0);vec4 h=texelFetch(historySampler,ivec2(gl_FragCoord.xy),0);gl_FragColor=mix(h,c,factor);}
`;P.ShadersStore[Kd]||(P.ShadersStore[Kd]=qP);const o3={name:Kd,shader:qP},l3=Object.freeze(Object.defineProperty({__proto__:null,taaPixelShader:o3},Symbol.toStringTag,{value:"Module"})),Jd="taaPixelShader",QP=`var textureSampler: texture_2d<f32>;var historySampler: texture_2d<f32>;uniform factor: f32;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {let c=textureLoad(textureSampler,vec2<i32>(fragmentInputs.position.xy),0);let h=textureLoad(historySampler,vec2<i32>(fragmentInputs.position.xy),0);fragmentOutputs.color= mix(h,c,uniforms.factor);}
`;P.ShadersStoreWGSL[Jd]||(P.ShadersStoreWGSL[Jd]=QP);const u3={name:Jd,shader:QP},c3=Object.freeze(Object.defineProperty({__proto__:null,taaPixelShaderWGSL:u3},Symbol.toStringTag,{value:"Module"}));var sb;(function(a){a[a.Hable=0]="Hable",a[a.Reinhard=1]="Reinhard",a[a.HejiDawson=2]="HejiDawson",a[a.Photographic=3]="Photographic"})(sb||(sb={}));class c$ extends Ce{getClassName(){return"TonemapPostProcess"}constructor(e,t,i,r,s=2,n,o=0,l){super(e,"tonemap",["_ExposureAdjustment"],null,1,r,s,n,l,null,o),this._operator=t,this.exposureAdjustment=i;let u="#define ";this._operator===0?u+="HABLE_TONEMAPPING":this._operator===1?u+="REINHARD_TONEMAPPING":this._operator===2?u+="OPTIMIZED_HEJIDAWSON_TONEMAPPING":this._operator===3&&(u+="PHOTOGRAPHIC_TONEMAPPING"),this.updateEffect(u),this.onApply=c=>{c.setFloat("_ExposureAdjustment",this.exposureAdjustment)}}_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(Promise.all([k(()=>Promise.resolve().then(()=>qk),void 0)]))):t.push(Promise.all([k(()=>Promise.resolve().then(()=>Xk),void 0)])),super._gatherImports(e,t)}}const nb="volumetricLightScatteringPixelShader",h3=`uniform sampler2D textureSampler;uniform sampler2D lightScatteringSampler;uniform float decay;uniform float exposure;uniform float weight;uniform float density;uniform vec2 meshPositionOnScreen;varying vec2 vUV;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
vec2 tc=vUV;vec2 deltaTexCoord=(tc-meshPositionOnScreen.xy);deltaTexCoord*=1.0/float(NUM_SAMPLES)*density;float illuminationDecay=1.0;vec4 color=texture2D(lightScatteringSampler,tc)*0.4;for(int i=0; i<NUM_SAMPLES; i++) {tc-=deltaTexCoord;vec4 dataSample=texture2D(lightScatteringSampler,tc)*0.4;dataSample*=illuminationDecay*weight;color+=dataSample;illuminationDecay*=decay;}
vec4 realColor=texture2D(textureSampler,vUV);gl_FragColor=((vec4((vec3(color.r,color.g,color.b)*exposure),realColor.a))+(realColor*(1.5-0.4)));
#define CUSTOM_FRAGMENT_MAIN_END
}
`;P.ShadersStore[nb]||(P.ShadersStore[nb]=h3);const ab="volumetricLightScatteringPassVertexShader",d3=`attribute vec3 position;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<instancesDeclaration>
uniform mat4 viewProjection;uniform vec2 depthValues;
#if defined(ALPHATEST) || defined(NEED_UV)
varying vec2 vUV;uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{vec3 positionUpdated=position;
#if (defined(ALPHATEST) || defined(NEED_UV)) && defined(UV1)
vec2 uvUpdated=uv;
#endif
#if (defined(ALPHATEST) || defined(NEED_UV)) && defined(UV2)
vec2 uv2Updated=uv2;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
gl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);
#if defined(ALPHATEST) || defined(BASIC_RENDER)
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2Updated,1.0,0.0));
#endif
#endif
}
`;P.ShadersStore[ab]||(P.ShadersStore[ab]=d3);const ob="volumetricLightScatteringPassPixelShader",f3=`#if defined(ALPHATEST) || defined(NEED_UV)
varying vec2 vUV;
#endif
#if defined(ALPHATEST)
uniform sampler2D diffuseSampler;
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#if defined(ALPHATEST)
vec4 diffuseColor=texture2D(diffuseSampler,vUV);if (diffuseColor.a<0.4)
discard;
#endif
gl_FragColor=vec4(0.0,0.0,0.0,1.0);}
`;P.ShadersStore[ob]||(P.ShadersStore[ob]=f3);class mr extends Ce{get useDiffuseColor(){return L.Warn("VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead"),!1}set useDiffuseColor(e){L.Warn("VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead")}constructor(e,t,i,r,s=100,n=Y.BILINEAR_SAMPLINGMODE,o,l,u){super(e,"volumetricLightScattering",["decay","exposure","weight","meshPositionOnScreen","density"],["lightScatteringSampler"],t.postProcessRatio||t,i,n,o,l,"#define NUM_SAMPLES "+s),this._screenCoordinates=Q.Zero(),this.customMeshPosition=m.Zero(),this.useCustomMeshPosition=!1,this.invert=!0,this.excludedMeshes=[],this.includedMeshes=[],this.exposure=.3,this.decay=.96815,this.weight=.58767,this.density=.926,u=(i==null?void 0:i.getScene())??u??this._scene,o=u.getEngine(),this._viewPort=new pn(0,0,1,1).toGlobal(o.getRenderWidth(),o.getRenderHeight()),this.mesh=r??mr.CreateDefaultMesh("VolumetricLightScatteringMesh",u),this._createPass(u,t.passRatio||t),this.onActivate=c=>{this.isSupported||this.dispose(c),this.onActivate=null},this.onApplyObservable.add(c=>{this._updateMeshScreenCoordinates(u),c.setTexture("lightScatteringSampler",this._volumetricLightScatteringRTT),c.setFloat("exposure",this.exposure),c.setFloat("decay",this.decay),c.setFloat("weight",this.weight),c.setFloat("density",this.density),c.setVector2("meshPositionOnScreen",this._screenCoordinates)})}getClassName(){return"VolumetricLightScatteringPostProcess"}_isReady(e,t){var S;const i=e.getMesh();if(i===this.mesh&&i.material)return i.material.isReady(i);const r=(S=i._internalAbstractMeshDataInfo._materialForRenderPass)==null?void 0:S[this._scene.getEngine().currentRenderPassId];if(r)return r.isReadyForSubMesh(i,e,t);const s=[],n=[N.PositionKind],o=e.getMaterial();let l=!1,u=!1;const c=!1;if(o){const b=o.needAlphaTestingForMesh(i);b&&s.push("#define ALPHATEST"),i.isVerticesDataPresent(N.UVKind)&&(n.push(N.UVKind),s.push("#define UV1"),l=b),i.isVerticesDataPresent(N.UV2Kind)&&(n.push(N.UV2Kind),s.push("#define UV2"),u=b)}const h=new Xn;if(i.useBones&&i.computeBonesUsingShaders&&i.skeleton){n.push(N.MatricesIndicesKind),n.push(N.MatricesWeightsKind),i.numBoneInfluencers>4&&(n.push(N.MatricesIndicesExtraKind),n.push(N.MatricesWeightsExtraKind)),s.push("#define NUM_BONE_INFLUENCERS "+i.numBoneInfluencers),i.numBoneInfluencers>0&&h.addCPUSkinningFallback(0,i);const b=i.skeleton;b.isUsingTextureForMatrices?s.push("#define BONETEXTURE"):s.push("#define BonesPerMesh "+(b.bones.length+1))}else s.push("#define NUM_BONE_INFLUENCERS 0");const d=i.morphTargetManager?jn(i.morphTargetManager,s,n,i,!0,!1,!1,l,u,c):0;t&&(s.push("#define INSTANCES"),qn(n),e.getRenderingMesh().hasThinInstances&&s.push("#define THIN_INSTANCES"));const f=i.bakedVertexAnimationManager;f&&f.isEnabled&&(s.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),t&&n.push("bakedVertexAnimationSettingsInstanced"));const p=e._getDrawWrapper(void 0,!0),g=p.defines,_=s.join(`
`);if(g!==_){const b=["world","mBones","boneTextureWidth","viewProjection","diffuseMatrix","morphTargetInfluences","morphTargetCount","morphTargetTextureInfo","morphTargetTextureIndices","bakedVertexAnimationSettings","bakedVertexAnimationTextureSizeInverted","bakedVertexAnimationTime","bakedVertexAnimationTexture"],y=["diffuseSampler","morphTargets","boneSampler","bakedVertexAnimationTexture"];p.setEffect(i.getScene().getEngine().createEffect("volumetricLightScatteringPass",{attributes:n,uniformsNames:b,uniformBuffersNames:[],samplers:y,defines:_,fallbacks:h,onCompiled:null,onError:null,indexParameters:{maxSimultaneousMorphTargets:d}},i.getScene().getEngine()),_)}return p.effect.isReady()}setCustomMeshPosition(e){this.customMeshPosition=e}getCustomMeshPosition(){return this.customMeshPosition}dispose(e){const t=e.getScene().customRenderTargets.indexOf(this._volumetricLightScatteringRTT);t!==-1&&e.getScene().customRenderTargets.splice(t,1),this._volumetricLightScatteringRTT.dispose(),super.dispose(e)}getPass(){return this._volumetricLightScatteringRTT}_meshExcluded(e){return this.includedMeshes.length>0&&this.includedMeshes.indexOf(e)===-1||this.excludedMeshes.length>0&&this.excludedMeshes.indexOf(e)!==-1}_createPass(e,t){const i=e.getEngine();this._volumetricLightScatteringRTT=new Kt("volumetricLightScatteringMap",{width:i.getRenderWidth()*t,height:i.getRenderHeight()*t},e,!1,!0,0),this._volumetricLightScatteringRTT.wrapU=Y.CLAMP_ADDRESSMODE,this._volumetricLightScatteringRTT.wrapV=Y.CLAMP_ADDRESSMODE,this._volumetricLightScatteringRTT.renderList=null,this._volumetricLightScatteringRTT.renderParticles=!1,this._volumetricLightScatteringRTT.ignoreCameraViewport=!0;const r=this.getCamera();r?r.customRenderTargets.push(this._volumetricLightScatteringRTT):e.customRenderTargets.push(this._volumetricLightScatteringRTT);const s=l=>{var _;const u=l.getRenderingMesh(),c=l.getEffectiveMesh();if(this._meshExcluded(u))return;c._internalAbstractMeshDataInfo._isActiveIntermediate=!1;const h=l.getMaterial();if(!h)return;const d=u.getScene(),f=d.getEngine();f.setState(h.backFaceCulling,void 0,void 0,void 0,h.cullBackFaces);const p=u._getInstancesRenderList(l._id,!!l.getReplacementMesh());if(p.mustReturn)return;const g=f.getCaps().instancedArrays&&(p.visibleInstances[l._id]!==null||u.hasThinInstances);if(this._isReady(l,g)){const S=(_=c._internalAbstractMeshDataInfo._materialForRenderPass)==null?void 0:_[f.currentRenderPassId];let b=l._getDrawWrapper();if(u===this.mesh&&!b&&(b=h._getDrawWrapper()),!b)return;const y=b.effect;if(f.enableEffect(b),g||u._bind(l,y,h.fillMode),u===this.mesh)h.bind(c.getWorldMatrix(),u);else if(S)S.bindForSubMesh(c.getWorldMatrix(),c,l);else{if(y.setMatrix("viewProjection",d.getTransformMatrix()),h.needAlphaTestingForMesh(c)){const v=h.getAlphaTestTexture();v&&(y.setTexture("diffuseSampler",v),y.setMatrix("diffuseMatrix",v.getTextureMatrix()))}Yn(u,y),Ns(u,y),u.morphTargetManager&&u.morphTargetManager.isUsingTextureForTargets&&u.morphTargetManager._bind(y);const T=l.getMesh().bakedVertexAnimationManager;T&&T.isEnabled&&T.bind(y,g)}g&&u.hasThinInstances&&y.setMatrix("world",c.getWorldMatrix()),u._processRendering(c,l,y,ft.TriangleFillMode,p,g,(T,v)=>{T||y.setMatrix("world",v)})}};let n;const o=new xe(0,0,0,1);this._volumetricLightScatteringRTT.onBeforeRenderObservable.add(()=>{n=e.clearColor,e.clearColor=o}),this._volumetricLightScatteringRTT.onAfterRenderObservable.add(()=>{e.clearColor=n}),this._volumetricLightScatteringRTT.customIsReadyFunction=(l,u,c)=>{if((c||u===0)&&l.subMeshes)for(let h=0;h<l.subMeshes.length;++h){const d=l.subMeshes[h],f=d.getMaterial(),p=d.getRenderingMesh();if(!f)continue;const g=p._getInstancesRenderList(d._id,!!d.getReplacementMesh()),_=i.getCaps().instancedArrays&&(g.visibleInstances[d._id]!==null||p.hasThinInstances);if(!this._isReady(d,_))return!1}return!0},this._volumetricLightScatteringRTT.customRenderFunction=(l,u,c,h)=>{const d=e.getEngine();let f;if(h.length){for(d.setColorWrite(!1),f=0;f<h.length;f++)s(h.data[f]);d.setColorWrite(!0)}for(f=0;f<l.length;f++)s(l.data[f]);for(f=0;f<u.length;f++)s(u.data[f]);if(c.length){for(f=0;f<c.length;f++){const g=c.data[f],_=g.getBoundingInfo();_&&e.activeCamera&&(g._alphaIndex=g.getMesh().alphaIndex,g._distanceToCamera=_.boundingSphere.centerWorld.subtract(e.activeCamera.position).length())}const p=c.data.slice(0,c.length);for(p.sort((g,_)=>g._alphaIndex>_._alphaIndex?1:g._alphaIndex<_._alphaIndex?-1:g._distanceToCamera<_._distanceToCamera?1:g._distanceToCamera>_._distanceToCamera?-1:0),d.setAlphaMode(2),f=0;f<p.length;f++)s(p[f]);d.setAlphaMode(0)}}}_updateMeshScreenCoordinates(e){const t=e.getTransformMatrix();let i;this.useCustomMeshPosition?i=this.customMeshPosition:this.attachedNode?i=this.attachedNode.position:i=this.mesh.parent?this.mesh.getAbsolutePosition():this.mesh.position;const r=m.Project(i,$.Identity(),t,this._viewPort);this._screenCoordinates.x=r.x/this._viewPort.width,this._screenCoordinates.y=r.y/this._viewPort.height,this.invert&&(this._screenCoordinates.y=1-this._screenCoordinates.y)}static CreateDefaultMesh(e,t){const i=gn(e,{size:1},t);i.billboardMode=Rt.BILLBOARDMODE_ALL;const r=new Ut(e+"Material",t);return r.emissiveColor=new ne(1,1,1),i.material=r,i}}C([Hn()],mr.prototype,"customMeshPosition",void 0);C([F()],mr.prototype,"useCustomMeshPosition",void 0);C([F()],mr.prototype,"invert",void 0);C([cu()],mr.prototype,"mesh",void 0);C([F()],mr.prototype,"excludedMeshes",void 0);C([F()],mr.prototype,"includedMeshes",void 0);C([F()],mr.prototype,"exposure",void 0);C([F()],mr.prototype,"decay",void 0);C([F()],mr.prototype,"weight",void 0);C([F()],mr.prototype,"density",void 0);B("BABYLON.VolumetricLightScatteringPostProcess",mr);const lb="screenSpaceCurvaturePixelShader",p3=`precision highp float;varying vec2 vUV;uniform sampler2D textureSampler;uniform sampler2D normalSampler;uniform float curvature_ridge;uniform float curvature_valley;
#ifndef CURVATURE_OFFSET
#define CURVATURE_OFFSET 1
#endif
float curvature_soft_clamp(float curvature,float control)
{if (curvature<0.5/control)
return curvature*(1.0-curvature*control);return 0.25/control;}
float calculate_curvature(ivec2 texel,float ridge,float valley)
{vec2 normal_up =texelFetch(normalSampler,texel+ivec2(0, CURVATURE_OFFSET),0).rb;vec2 normal_down =texelFetch(normalSampler,texel+ivec2(0,-CURVATURE_OFFSET),0).rb;vec2 normal_left =texelFetch(normalSampler,texel+ivec2(-CURVATURE_OFFSET,0),0).rb;vec2 normal_right=texelFetch(normalSampler,texel+ivec2( CURVATURE_OFFSET,0),0).rb;float normal_diff=((normal_up.g-normal_down.g)+(normal_right.r-normal_left.r));if (normal_diff<0.0)
return -2.0*curvature_soft_clamp(-normal_diff,valley);return 2.0*curvature_soft_clamp(normal_diff,ridge);}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{ivec2 texel=ivec2(gl_FragCoord.xy);vec4 baseColor=texture2D(textureSampler,vUV);float curvature=calculate_curvature(texel,curvature_ridge,curvature_valley);baseColor.rgb*=curvature+1.0;gl_FragColor=baseColor;}`;P.ShadersStore[lb]||(P.ShadersStore[lb]=p3);class xl extends Ce{getClassName(){return"ScreenSpaceCurvaturePostProcess"}constructor(e,t,i,r,s,n,o,l=0,u=!1){super(e,"screenSpaceCurvature",["curvature_ridge","curvature_valley"],["textureSampler","normalSampler"],i,r,s,n,o,void 0,l,void 0,null,u),this.ridge=1,this.valley=1,this._geometryBufferRenderer=t.enableGeometryBufferRenderer(),this._geometryBufferRenderer?(this._geometryBufferRenderer.generateNormalsInWorldSpace&&L.Error("ScreenSpaceCurvaturePostProcess does not support generateNormalsInWorldSpace=true for the geometry buffer renderer!"),this.onApply=c=>{c.setFloat("curvature_ridge",.5/Math.max(this.ridge*this.ridge,1e-4)),c.setFloat("curvature_valley",.7/Math.max(this.valley*this.valley,1e-4));const h=this._geometryBufferRenderer.getGBuffer().textures[1];c.setTexture("normalSampler",h)}):L.Error("Multiple Render Target support needed for screen space curvature post process. Please use IsSupported test first.")}static get IsSupported(){const e=ze.LastCreatedEngine;return e?e.getCaps().drawBuffersExtension:!1}static _Parse(e,t,i,r){return Me.Parse(()=>new xl(e.name,i,e.options,t,e.renderTargetSamplingMode,i.getEngine(),e.textureType,e.reusable),e,i,r)}}C([F()],xl.prototype,"ridge",void 0);C([F()],xl.prototype,"valley",void 0);B("BABYLON.ScreenSpaceCurvaturePostProcess",xl);const ub="kernelBlurVaryingDeclaration",m3="varying vec2 sampleCoord{X};";P.IncludesShadersStore[ub]||(P.IncludesShadersStore[ub]=m3);const cb="kernelBlurFragment",_3=`#ifdef DOF
factor=sampleCoC(sampleCoord{X}); 
computedWeight=KERNEL_WEIGHT{X}*factor;sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCoord{X}))*computedWeight;
#else
blend+=texture2D(textureSampler,sampleCoord{X})*computedWeight;
#endif
`;P.IncludesShadersStore[cb]||(P.IncludesShadersStore[cb]=_3);const hb="kernelBlurFragment2",g3=`#ifdef DOF
factor=sampleCoC(sampleCenter+delta*KERNEL_DEP_OFFSET{X});computedWeight=KERNEL_DEP_WEIGHT{X}*factor;sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_DEP_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X}))*computedWeight;
#else
blend+=texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X})*computedWeight;
#endif
`;P.IncludesShadersStore[hb]||(P.IncludesShadersStore[hb]=g3);const ef="kernelBlurPixelShader",KP=`uniform sampler2D textureSampler;uniform vec2 delta;varying vec2 sampleCenter;
#ifdef DOF
uniform sampler2D circleOfConfusionSampler;float sampleCoC(in vec2 offset) {float coc=texture2D(circleOfConfusionSampler,offset).r;return coc; }
#endif
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
#ifdef PACKEDFLOAT
#include<packingFunctions>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{float computedWeight=0.0;
#ifdef PACKEDFLOAT
float blend=0.;
#else
vec4 blend=vec4(0.);
#endif
#ifdef DOF
float sumOfWeights=CENTER_WEIGHT; 
float factor=0.0;
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCenter))*CENTER_WEIGHT;
#else
blend+=texture2D(textureSampler,sampleCenter)*CENTER_WEIGHT;
#endif
#endif
#include<kernelBlurFragment>[0..varyingCount]
#include<kernelBlurFragment2>[0..depCount]
#ifdef PACKEDFLOAT
gl_FragColor=pack(blend);
#else
gl_FragColor=blend;
#endif
#ifdef DOF
gl_FragColor/=sumOfWeights;
#endif
}`;P.ShadersStore[ef]||(P.ShadersStore[ef]=KP);const x3={name:ef,shader:KP},S3=Object.freeze(Object.defineProperty({__proto__:null,kernelBlurPixelShader:x3},Symbol.toStringTag,{value:"Module"})),db="kernelBlurVertex",v3="sampleCoord{X}=sampleCenter+delta*KERNEL_OFFSET{X};";P.IncludesShadersStore[db]||(P.IncludesShadersStore[db]=v3);const tf="kernelBlurVertexShader",JP=`attribute vec2 position;uniform vec2 delta;varying vec2 sampleCenter;
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
sampleCenter=(position*madd+madd);
#include<kernelBlurVertex>[0..varyingCount]
gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStore[tf]||(P.ShadersStore[tf]=JP);const b3={name:tf,shader:JP},y3=Object.freeze(Object.defineProperty({__proto__:null,kernelBlurVertexShader:b3},Symbol.toStringTag,{value:"Module"})),fb="kernelBlurVaryingDeclaration",T3="varying sampleCoord{X}: vec2f;";P.IncludesShadersStoreWGSL[fb]||(P.IncludesShadersStoreWGSL[fb]=T3);const pb="kernelBlurFragment",C3=`#ifdef DOF
factor=sampleCoC(fragmentInputs.sampleCoord{X}); 
computedWeight=KERNEL_WEIGHT{X}*factor;sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(textureSample(textureSampler,textureSamplerSampler,fragmentInputs.sampleCoord{X}))*computedWeight;
#else
blend+=textureSample(textureSampler,textureSamplerSampler,fragmentInputs.sampleCoord{X})*computedWeight;
#endif
`;P.IncludesShadersStoreWGSL[pb]||(P.IncludesShadersStoreWGSL[pb]=C3);const mb="kernelBlurFragment2",P3=`#ifdef DOF
factor=sampleCoC(fragmentInputs.sampleCenter+uniforms.delta*KERNEL_DEP_OFFSET{X});computedWeight=KERNEL_DEP_WEIGHT{X}*factor;sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_DEP_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(textureSample(textureSampler,textureSamplerSampler,fragmentInputs.sampleCenter+uniforms.delta*KERNEL_DEP_OFFSET{X}))*computedWeight;
#else
blend+=textureSample(textureSampler,textureSamplerSampler,fragmentInputs.sampleCenter+uniforms.delta*KERNEL_DEP_OFFSET{X})*computedWeight;
#endif
`;P.IncludesShadersStoreWGSL[mb]||(P.IncludesShadersStoreWGSL[mb]=P3);const rf="kernelBlurPixelShader",eE=`var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform delta: vec2f;varying sampleCenter: vec2f;
#ifdef DOF
var circleOfConfusionSamplerSampler: sampler;var circleOfConfusionSampler: texture_2d<f32>;fn sampleCoC(offset: vec2f)->f32 {var coc: f32=textureSample(circleOfConfusionSampler,circleOfConfusionSamplerSampler,offset).r;return coc; }
#endif
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
#ifdef PACKEDFLOAT
#include<packingFunctions>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var computedWeight: f32=0.0;
#ifdef PACKEDFLOAT
var blend: f32=0.;
#else
var blend: vec4f= vec4f(0.);
#endif
#ifdef DOF
var sumOfWeights: f32=CENTER_WEIGHT; 
var factor: f32=0.0;
#ifdef PACKEDFLOAT
blend+=unpack(textureSample(textureSampler,textureSamplerSampler,input.sampleCenter))*CENTER_WEIGHT;
#else
blend+=textureSample(textureSampler,textureSamplerSampler,input.sampleCenter)*CENTER_WEIGHT;
#endif
#endif
#include<kernelBlurFragment>[0..varyingCount]
#include<kernelBlurFragment2>[0..depCount]
#ifdef PACKEDFLOAT
fragmentOutputs.color=pack(blend);
#else
fragmentOutputs.color=blend;
#endif
#ifdef DOF
fragmentOutputs.color/=sumOfWeights;
#endif
}`;P.ShadersStoreWGSL[rf]||(P.ShadersStoreWGSL[rf]=eE);const E3={name:rf,shader:eE},I3=Object.freeze(Object.defineProperty({__proto__:null,kernelBlurPixelShaderWGSL:E3},Symbol.toStringTag,{value:"Module"})),_b="kernelBlurVertex",R3="vertexOutputs.sampleCoord{X}=vertexOutputs.sampleCenter+uniforms.delta*KERNEL_OFFSET{X};";P.IncludesShadersStoreWGSL[_b]||(P.IncludesShadersStoreWGSL[_b]=R3);const sf="kernelBlurVertexShader",tE=`attribute position: vec2f;uniform delta: vec2f;varying sampleCenter: vec2f;
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {const madd: vec2f= vec2f(0.5,0.5);
#define CUSTOM_VERTEX_MAIN_BEGIN
vertexOutputs.sampleCenter=(input.position*madd+madd);
#include<kernelBlurVertex>[0..varyingCount]
vertexOutputs.position= vec4f(input.position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStoreWGSL[sf]||(P.ShadersStoreWGSL[sf]=tE);const M3={name:sf,shader:tE},A3=Object.freeze(Object.defineProperty({__proto__:null,kernelBlurVertexShaderWGSL:M3},Symbol.toStringTag,{value:"Module"})),nf="vrDistortionCorrectionPixelShader",iE=`varying vec2 vUV;uniform sampler2D textureSampler;uniform vec2 LensCenter;uniform vec2 Scale;uniform vec2 ScaleIn;uniform vec4 HmdWarpParam;vec2 HmdWarp(vec2 in01) {vec2 theta=(in01-LensCenter)*ScaleIn; 
float rSq=theta.x*theta.x+theta.y*theta.y;vec2 rvector=theta*(HmdWarpParam.x+HmdWarpParam.y*rSq+HmdWarpParam.z*rSq*rSq+HmdWarpParam.w*rSq*rSq*rSq);return LensCenter+Scale*rvector;}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{vec2 tc=HmdWarp(vUV);if (tc.x <0.0 || tc.x>1.0 || tc.y<0.0 || tc.y>1.0)
gl_FragColor=vec4(0.0,0.0,0.0,0.0);else{gl_FragColor=texture2D(textureSampler,tc);}}`;P.ShadersStore[nf]||(P.ShadersStore[nf]=iE);const D3={name:nf,shader:iE},O3=Object.freeze(Object.defineProperty({__proto__:null,vrDistortionCorrectionPixelShader:D3},Symbol.toStringTag,{value:"Module"})),af="vrDistortionCorrectionPixelShader",rE=`#define DISABLE_UNIFORMITY_ANALYSIS
varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform LensCenter: vec2f;uniform Scale: vec2f;uniform ScaleIn: vec2f;uniform HmdWarpParam: vec4f;fn HmdWarp(in01: vec2f)->vec2f {var theta: vec2f=(in01-uniforms.LensCenter)*uniforms.ScaleIn; 
var rSq: f32=theta.x*theta.x+theta.y*theta.y;var rvector: vec2f=theta*(uniforms.HmdWarpParam.x+uniforms.HmdWarpParam.y*rSq+uniforms.HmdWarpParam.z*rSq*rSq+uniforms.HmdWarpParam.w*rSq*rSq*rSq);return uniforms.LensCenter+uniforms.Scale*rvector;}
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var tc: vec2f=HmdWarp(input.vUV);if (tc.x <0.0 || tc.x>1.0 || tc.y<0.0 || tc.y>1.0) {fragmentOutputs.color=vec4f(0.0,0.0,0.0,0.0);}
else{fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,tc);}}`;P.ShadersStoreWGSL[af]||(P.ShadersStoreWGSL[af]=rE);const w3={name:af,shader:rE},N3=Object.freeze(Object.defineProperty({__proto__:null,vrDistortionCorrectionPixelShaderWGSL:w3},Symbol.toStringTag,{value:"Module"})),of="imageProcessingPixelShader",sE=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;
#include<imageProcessingDeclaration>
#include<helperFunctions>
#include<imageProcessingFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var result: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV);result=vec4f(max(result.rgb,vec3f(0.)),result.a);
#ifdef IMAGEPROCESSING
#ifndef FROMLINEARSPACE
result=vec4f(toLinearSpaceVec3(result.rgb),result.a);
#endif
result=applyImageProcessing(result);
#else
#ifdef FROMLINEARSPACE
result=applyImageProcessing(result);
#endif
#endif
fragmentOutputs.color=result;}`;P.ShadersStoreWGSL[of]||(P.ShadersStoreWGSL[of]=sE);const F3={name:of,shader:sE},L3=Object.freeze(Object.defineProperty({__proto__:null,imageProcessingPixelShaderWGSL:F3},Symbol.toStringTag,{value:"Module"})),lf="imageProcessingPixelShader",nE=`varying vec2 vUV;uniform sampler2D textureSampler;
#include<imageProcessingDeclaration>
#include<helperFunctions>
#include<imageProcessingFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{vec4 result=texture2D(textureSampler,vUV);result.rgb=max(result.rgb,vec3(0.));
#ifdef IMAGEPROCESSING
#ifndef FROMLINEARSPACE
result.rgb=toLinearSpace(result.rgb);
#endif
result=applyImageProcessing(result);
#else
#ifdef FROMLINEARSPACE
result=applyImageProcessing(result);
#endif
#endif
gl_FragColor=result;}`;P.ShadersStore[lf]||(P.ShadersStore[lf]=nE);const B3={name:lf,shader:nE},V3=Object.freeze(Object.defineProperty({__proto__:null,imageProcessingPixelShader:B3},Symbol.toStringTag,{value:"Module"})),uf="sharpenPixelShader",aE=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform screenSize: vec2f;uniform sharpnessAmounts: vec2f;
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var onePixel: vec2f= vec2f(1.0,1.0)/uniforms.screenSize;var color: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV);var edgeDetection: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel*vec2f(0,-1)) +
textureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel*vec2f(-1,0)) +
textureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel*vec2f(1,0)) +
textureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel*vec2f(0,1)) -
color*4.0;fragmentOutputs.color=max(vec4f(color.rgb*uniforms.sharpnessAmounts.y,color.a)-(uniforms.sharpnessAmounts.x* vec4f(edgeDetection.rgb,0)),vec4f(0.));}`;P.ShadersStoreWGSL[uf]||(P.ShadersStoreWGSL[uf]=aE);const k3={name:uf,shader:aE},z3=Object.freeze(Object.defineProperty({__proto__:null,sharpenPixelShaderWGSL:k3},Symbol.toStringTag,{value:"Module"})),cf="grainPixelShader",oE=`#include<helperFunctions>
uniform sampler2D textureSampler; 
uniform float intensity;uniform float animatedSeed;varying vec2 vUV;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{gl_FragColor=texture2D(textureSampler,vUV);vec2 seed=vUV*(animatedSeed);float grain=dither(seed,intensity);float lum=getLuminance(gl_FragColor.rgb);float grainAmount=(cos(-PI+(lum*PI*2.))+1.)/2.;gl_FragColor.rgb+=grain*grainAmount;gl_FragColor.rgb=max(gl_FragColor.rgb,0.0);}`;P.ShadersStore[cf]||(P.ShadersStore[cf]=oE);const U3={name:cf,shader:oE},G3=Object.freeze(Object.defineProperty({__proto__:null,grainPixelShader:U3},Symbol.toStringTag,{value:"Module"})),hf="grainPixelShader",lE=`#include<helperFunctions>
varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform intensity: f32;uniform animatedSeed: f32;
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,input.vUV);var seed: vec2f=input.vUV*uniforms.animatedSeed;var grain: f32=dither(seed,uniforms.intensity);var lum: f32=getLuminance(fragmentOutputs.color.rgb);var grainAmount: f32=(cos(-PI+(lum*PI*2.))+1.)/2.;fragmentOutputs.color=vec4f(fragmentOutputs.color.rgb+grain*grainAmount,fragmentOutputs.color.a);fragmentOutputs.color=vec4f(max(fragmentOutputs.color.rgb,vec3f(0.0)),fragmentOutputs.color.a);}`;P.ShadersStoreWGSL[hf]||(P.ShadersStoreWGSL[hf]=lE);const W3={name:hf,shader:lE},$3=Object.freeze(Object.defineProperty({__proto__:null,grainPixelShaderWGSL:W3},Symbol.toStringTag,{value:"Module"})),df="chromaticAberrationPixelShader",uE=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform chromatic_aberration: f32;uniform radialIntensity: f32;uniform direction: vec2f;uniform centerPosition: vec2f;uniform screen_width: f32;uniform screen_height: f32;
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var centered_screen_pos: vec2f= vec2f(input.vUV.x-uniforms.centerPosition.x,input.vUV.y-uniforms.centerPosition.y);var directionOfEffect: vec2f=uniforms.direction;if(directionOfEffect.x==0. && directionOfEffect.y==0.){directionOfEffect=normalize(centered_screen_pos);}
var radius2: f32=centered_screen_pos.x*centered_screen_pos.x
+ centered_screen_pos.y*centered_screen_pos.y;var radius: f32=sqrt(radius2);var ref_indices: vec3f= vec3f(-0.3,0.0,0.3);var ref_shiftX: f32=uniforms.chromatic_aberration*pow(radius,uniforms.radialIntensity)*directionOfEffect.x/uniforms.screen_width;var ref_shiftY: f32=uniforms.chromatic_aberration*pow(radius,uniforms.radialIntensity)*directionOfEffect.y/uniforms.screen_height;var ref_coords_r: vec2f=vec2f(input.vUV.x+ref_indices.r*ref_shiftX,input.vUV.y+ref_indices.r*ref_shiftY*0.5);var ref_coords_g: vec2f=vec2f(input.vUV.x+ref_indices.g*ref_shiftX,input.vUV.y+ref_indices.g*ref_shiftY*0.5);var ref_coords_b: vec2f=vec2f(input.vUV.x+ref_indices.b*ref_shiftX,input.vUV.y+ref_indices.b*ref_shiftY*0.5);var r=textureSample(textureSampler,textureSamplerSampler,ref_coords_r);var g=textureSample(textureSampler,textureSamplerSampler,ref_coords_g);var b=textureSample(textureSampler,textureSamplerSampler,ref_coords_b);var a=clamp(r.a+g.a+b.a,0.,1.);fragmentOutputs.color=vec4f(r.r,g.g,b.b,a);}`;P.ShadersStoreWGSL[df]||(P.ShadersStoreWGSL[df]=uE);const H3={name:df,shader:uE},j3=Object.freeze(Object.defineProperty({__proto__:null,chromaticAberrationPixelShaderWGSL:H3},Symbol.toStringTag,{value:"Module"})),ff="depthOfFieldMergePixelShader",cE=`#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define TEXTUREFUNC(s,c,lod) texture2DLodEXT(s,c,lod)
#else
#define TEXTUREFUNC(s,c,bias) texture2D(s,c,bias)
#endif
uniform sampler2D textureSampler;varying vec2 vUV;uniform sampler2D circleOfConfusionSampler;uniform sampler2D blurStep0;
#if BLUR_LEVEL>0
uniform sampler2D blurStep1;
#endif
#if BLUR_LEVEL>1
uniform sampler2D blurStep2;
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{float coc=TEXTUREFUNC(circleOfConfusionSampler,vUV,0.0).r;
#if BLUR_LEVEL==0
vec4 original=TEXTUREFUNC(textureSampler,vUV,0.0);vec4 blurred0=TEXTUREFUNC(blurStep0,vUV,0.0);gl_FragColor=mix(original,blurred0,coc);
#endif
#if BLUR_LEVEL==1
if(coc<0.5){vec4 original=TEXTUREFUNC(textureSampler,vUV,0.0);vec4 blurred1=TEXTUREFUNC(blurStep1,vUV,0.0);gl_FragColor=mix(original,blurred1,coc/0.5);}else{vec4 blurred0=TEXTUREFUNC(blurStep0,vUV,0.0);vec4 blurred1=TEXTUREFUNC(blurStep1,vUV,0.0);gl_FragColor=mix(blurred1,blurred0,(coc-0.5)/0.5);}
#endif
#if BLUR_LEVEL==2
if(coc<0.33){vec4 original=TEXTUREFUNC(textureSampler,vUV,0.0);vec4 blurred2=TEXTUREFUNC(blurStep2,vUV,0.0);gl_FragColor=mix(original,blurred2,coc/0.33);}else if(coc<0.66){vec4 blurred1=TEXTUREFUNC(blurStep1,vUV,0.0);vec4 blurred2=TEXTUREFUNC(blurStep2,vUV,0.0);gl_FragColor=mix(blurred2,blurred1,(coc-0.33)/0.33);}else{vec4 blurred0=TEXTUREFUNC(blurStep0,vUV,0.0);vec4 blurred1=TEXTUREFUNC(blurStep1,vUV,0.0);gl_FragColor=mix(blurred1,blurred0,(coc-0.66)/0.34);}
#endif
}
`;P.ShadersStore[ff]||(P.ShadersStore[ff]=cE);const Y3={name:ff,shader:cE},X3=Object.freeze(Object.defineProperty({__proto__:null,depthOfFieldMergePixelShader:Y3},Symbol.toStringTag,{value:"Module"})),pf="depthOfFieldMergePixelShader",hE=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var circleOfConfusionSamplerSampler: sampler;var circleOfConfusionSampler: texture_2d<f32>;var blurStep0Sampler: sampler;var blurStep0: texture_2d<f32>;
#if BLUR_LEVEL>0
var blurStep1Sampler: sampler;var blurStep1: texture_2d<f32>;
#endif
#if BLUR_LEVEL>1
var blurStep2Sampler: sampler;var blurStep2: texture_2d<f32>;
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var coc: f32=textureSampleLevel(circleOfConfusionSampler,circleOfConfusionSamplerSampler,input.vUV,0.0).r;
#if BLUR_LEVEL==0
var original: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.0);var blurred0: vec4f=textureSampleLevel(blurStep0,blurStep0Sampler,input.vUV,0.0);fragmentOutputs.color=mix(original,blurred0,coc);
#endif
#if BLUR_LEVEL==1
if(coc<0.5){var original: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.0);var blurred1: vec4f=textureSampleLevel(blurStep1,blurStep1Sampler,input.vUV,0.0);fragmentOutputs.color=mix(original,blurred1,coc/0.5);}else{var blurred0: vec4f=textureSampleLevel(blurStep0,blurStep0Sampler,input.vUV,0.0);var blurred1: vec4f=textureSampleLevel(blurStep1,blurStep1Sampler,input.vUV,0.0);fragmentOutputs.color=mix(blurred1,blurred0,(coc-0.5)/0.5);}
#endif
#if BLUR_LEVEL==2
if(coc<0.33){var original: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.0);var blurred2: vec4f=textureSampleLevel(blurStep2,blurStep2Sampler,input.vUV,0.0);fragmentOutputs.color=mix(original,blurred2,coc/0.33);}else if(coc<0.66){var blurred1: vec4f=textureSampleLevel(blurStep1,blurStep1Sampler,input.vUV,0.0);var blurred2: vec4f=textureSampleLevel(blurStep2,blurStep2Sampler,input.vUV,0.0);fragmentOutputs.color=mix(blurred2,blurred1,(coc-0.33)/0.33);}else{var blurred0: vec4f=textureSampleLevel(blurStep0,blurStep0Sampler,input.vUV,0.0);var blurred1: vec4f=textureSampleLevel(blurStep1,blurStep1Sampler,input.vUV,0.0);fragmentOutputs.color=mix(blurred1,blurred0,(coc-0.66)/0.34);}
#endif
}
`;P.ShadersStoreWGSL[pf]||(P.ShadersStoreWGSL[pf]=hE);const Z3={name:pf,shader:hE},q3=Object.freeze(Object.defineProperty({__proto__:null,depthOfFieldMergePixelShaderWGSL:Z3},Symbol.toStringTag,{value:"Module"})),mf="circleOfConfusionPixelShader",dE=`uniform sampler2D depthSampler;varying vec2 vUV;
#ifndef COC_DEPTH_NOT_NORMALIZED
uniform vec2 cameraMinMaxZ;
#endif
uniform float focusDistance;uniform float cocPrecalculation;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{float depth=texture2D(depthSampler,vUV).r;
#define CUSTOM_COC_DEPTH
#ifdef COC_DEPTH_NOT_NORMALIZED
float pixelDistance=depth*1000.0;
#else
float pixelDistance=(cameraMinMaxZ.x+cameraMinMaxZ.y*depth)*1000.0; 
#endif
#define CUSTOM_COC_PIXELDISTANCE
float coc=abs(cocPrecalculation*((focusDistance-pixelDistance)/pixelDistance));coc=clamp(coc,0.0,1.0);gl_FragColor=vec4(coc,coc,coc,1.0);}
`;P.ShadersStore[mf]||(P.ShadersStore[mf]=dE);const Q3={name:mf,shader:dE},K3=Object.freeze(Object.defineProperty({__proto__:null,circleOfConfusionPixelShader:Q3},Symbol.toStringTag,{value:"Module"})),_f="circleOfConfusionPixelShader",fE=`varying vUV: vec2f;var depthSamplerSampler: sampler;var depthSampler: texture_2d<f32>;
#ifndef COC_DEPTH_NOT_NORMALIZED
uniform cameraMinMaxZ: vec2f;
#endif
uniform focusDistance: f32;uniform cocPrecalculation: f32;
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var depth: f32=textureSample(depthSampler,depthSamplerSampler,input.vUV).r;
#define CUSTOM_COC_DEPTH
#ifdef COC_DEPTH_NOT_NORMALIZED
let pixelDistance=depth*1000.0;
#else
let pixelDistance: f32=(uniforms.cameraMinMaxZ.x+uniforms.cameraMinMaxZ.y*depth)*1000.0; 
#endif
#define CUSTOM_COC_PIXELDISTANCE
var coc: f32=abs(uniforms.cocPrecalculation*((uniforms.focusDistance-pixelDistance)/pixelDistance));coc=clamp(coc,0.0,1.0);fragmentOutputs.color= vec4f(coc,coc,coc,1.0);}
`;P.ShadersStoreWGSL[_f]||(P.ShadersStoreWGSL[_f]=fE);const J3={name:_f,shader:fE},ek=Object.freeze(Object.defineProperty({__proto__:null,circleOfConfusionPixelShaderWGSL:J3},Symbol.toStringTag,{value:"Module"})),gf="bloomMergePixelShader",pE=`uniform sampler2D textureSampler;uniform sampler2D bloomBlur;varying vec2 vUV;uniform float bloomWeight;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{gl_FragColor=texture2D(textureSampler,vUV);vec3 blurred=texture2D(bloomBlur,vUV).rgb;gl_FragColor.rgb=gl_FragColor.rgb+(blurred.rgb*bloomWeight); }
`;P.ShadersStore[gf]||(P.ShadersStore[gf]=pE);const tk={name:gf,shader:pE},ik=Object.freeze(Object.defineProperty({__proto__:null,bloomMergePixelShader:tk},Symbol.toStringTag,{value:"Module"})),xf="bloomMergePixelShader",mE=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var bloomBlurSampler: sampler;var bloomBlur: texture_2d<f32>;uniform bloomWeight: f32;
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,input.vUV);var blurred: vec3f=textureSample(bloomBlur,bloomBlurSampler,input.vUV).rgb;fragmentOutputs.color=vec4f(fragmentOutputs.color.rgb+(blurred.rgb*uniforms.bloomWeight),fragmentOutputs.color.a);}
`;P.ShadersStoreWGSL[xf]||(P.ShadersStoreWGSL[xf]=mE);const rk={name:xf,shader:mE},sk=Object.freeze(Object.defineProperty({__proto__:null,bloomMergePixelShaderWGSL:rk},Symbol.toStringTag,{value:"Module"})),Sf="extractHighlightsPixelShader",_E=`#include<helperFunctions>
varying vec2 vUV;uniform sampler2D textureSampler;uniform float threshold;uniform float exposure;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{gl_FragColor=texture2D(textureSampler,vUV);float luma=dot(LuminanceEncodeApprox,gl_FragColor.rgb*exposure);gl_FragColor.rgb=step(threshold,luma)*gl_FragColor.rgb;}`;P.ShadersStore[Sf]||(P.ShadersStore[Sf]=_E);const nk={name:Sf,shader:_E},ak=Object.freeze(Object.defineProperty({__proto__:null,extractHighlightsPixelShader:nk},Symbol.toStringTag,{value:"Module"})),vf="extractHighlightsPixelShader",gE=`#include<helperFunctions>
varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform threshold: f32;uniform exposure: f32;
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,input.vUV);var luma: f32=dot(LuminanceEncodeApprox,fragmentOutputs.color.rgb*uniforms.exposure);fragmentOutputs.color=vec4f(step(uniforms.threshold,luma)*fragmentOutputs.color.rgb,fragmentOutputs.color.a);}`;P.ShadersStoreWGSL[vf]||(P.ShadersStoreWGSL[vf]=gE);const ok={name:vf,shader:gE},lk=Object.freeze(Object.defineProperty({__proto__:null,extractHighlightsPixelShaderWGSL:ok},Symbol.toStringTag,{value:"Module"})),bf="fxaaPixelShader",xE=`#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)
#else
#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)
#endif
uniform sampler2D textureSampler;uniform vec2 texelSize;varying vec2 vUV;varying vec2 sampleCoordS;varying vec2 sampleCoordE;varying vec2 sampleCoordN;varying vec2 sampleCoordW;varying vec2 sampleCoordNW;varying vec2 sampleCoordSE;varying vec2 sampleCoordNE;varying vec2 sampleCoordSW;const float fxaaQualitySubpix=1.0;const float fxaaQualityEdgeThreshold=0.166;const float fxaaQualityEdgeThresholdMin=0.0833;const vec3 kLumaCoefficients=vec3(0.2126,0.7152,0.0722);
#define FxaaLuma(rgba) dot(rgba.rgb,kLumaCoefficients)
void main(){vec2 posM;posM.x=vUV.x;posM.y=vUV.y;vec4 rgbyM=TEXTUREFUNC(textureSampler,vUV,0.0);float lumaM=FxaaLuma(rgbyM);float lumaS=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordS,0.0));float lumaE=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordE,0.0));float lumaN=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordN,0.0));float lumaW=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordW,0.0));float maxSM=max(lumaS,lumaM);float minSM=min(lumaS,lumaM);float maxESM=max(lumaE,maxSM);float minESM=min(lumaE,minSM);float maxWN=max(lumaN,lumaW);float minWN=min(lumaN,lumaW);float rangeMax=max(maxWN,maxESM);float rangeMin=min(minWN,minESM);float rangeMaxScaled=rangeMax*fxaaQualityEdgeThreshold;float range=rangeMax-rangeMin;float rangeMaxClamped=max(fxaaQualityEdgeThresholdMin,rangeMaxScaled);
#ifndef MALI
if(range<rangeMaxClamped) 
{gl_FragColor=rgbyM;return;}
#endif
float lumaNW=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordNW,0.0));float lumaSE=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordSE,0.0));float lumaNE=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordNE,0.0));float lumaSW=FxaaLuma(TEXTUREFUNC(textureSampler,sampleCoordSW,0.0));float lumaNS=lumaN+lumaS;float lumaWE=lumaW+lumaE;float subpixRcpRange=1.0/range;float subpixNSWE=lumaNS+lumaWE;float edgeHorz1=(-2.0*lumaM)+lumaNS;float edgeVert1=(-2.0*lumaM)+lumaWE;float lumaNESE=lumaNE+lumaSE;float lumaNWNE=lumaNW+lumaNE;float edgeHorz2=(-2.0*lumaE)+lumaNESE;float edgeVert2=(-2.0*lumaN)+lumaNWNE;float lumaNWSW=lumaNW+lumaSW;float lumaSWSE=lumaSW+lumaSE;float edgeHorz4=(abs(edgeHorz1)*2.0)+abs(edgeHorz2);float edgeVert4=(abs(edgeVert1)*2.0)+abs(edgeVert2);float edgeHorz3=(-2.0*lumaW)+lumaNWSW;float edgeVert3=(-2.0*lumaS)+lumaSWSE;float edgeHorz=abs(edgeHorz3)+edgeHorz4;float edgeVert=abs(edgeVert3)+edgeVert4;float subpixNWSWNESE=lumaNWSW+lumaNESE;float lengthSign=texelSize.x;bool horzSpan=edgeHorz>=edgeVert;float subpixA=subpixNSWE*2.0+subpixNWSWNESE;if (!horzSpan)
{lumaN=lumaW;}
if (!horzSpan) 
{lumaS=lumaE;}
if (horzSpan) 
{lengthSign=texelSize.y;}
float subpixB=(subpixA*(1.0/12.0))-lumaM;float gradientN=lumaN-lumaM;float gradientS=lumaS-lumaM;float lumaNN=lumaN+lumaM;float lumaSS=lumaS+lumaM;bool pairN=abs(gradientN)>=abs(gradientS);float gradient=max(abs(gradientN),abs(gradientS));if (pairN)
{lengthSign=-lengthSign;}
float subpixC=clamp(abs(subpixB)*subpixRcpRange,0.0,1.0);vec2 posB;posB.x=posM.x;posB.y=posM.y;vec2 offNP;offNP.x=(!horzSpan) ? 0.0 : texelSize.x;offNP.y=(horzSpan) ? 0.0 : texelSize.y;if (!horzSpan) 
{posB.x+=lengthSign*0.5;}
if (horzSpan)
{posB.y+=lengthSign*0.5;}
vec2 posN;posN.x=posB.x-offNP.x*1.5;posN.y=posB.y-offNP.y*1.5;vec2 posP;posP.x=posB.x+offNP.x*1.5;posP.y=posB.y+offNP.y*1.5;float subpixD=((-2.0)*subpixC)+3.0;float lumaEndN=FxaaLuma(TEXTUREFUNC(textureSampler,posN,0.0));float subpixE=subpixC*subpixC;float lumaEndP=FxaaLuma(TEXTUREFUNC(textureSampler,posP,0.0));if (!pairN) 
{lumaNN=lumaSS;}
float gradientScaled=gradient*1.0/4.0;float lumaMM=lumaM-lumaNN*0.5;float subpixF=subpixD*subpixE;bool lumaMLTZero=lumaMM<0.0;lumaEndN-=lumaNN*0.5;lumaEndP-=lumaNN*0.5;bool doneN=abs(lumaEndN)>=gradientScaled;bool doneP=abs(lumaEndP)>=gradientScaled;if (!doneN) 
{posN.x-=offNP.x*3.0;}
if (!doneN) 
{posN.y-=offNP.y*3.0;}
bool doneNP=(!doneN) || (!doneP);if (!doneP) 
{posP.x+=offNP.x*3.0;}
if (!doneP)
{posP.y+=offNP.y*3.0;}
if (doneNP)
{if (!doneN) lumaEndN=FxaaLuma(TEXTUREFUNC(textureSampler,posN.xy,0.0));if (!doneP) lumaEndP=FxaaLuma(TEXTUREFUNC(textureSampler,posP.xy,0.0));if (!doneN) lumaEndN=lumaEndN-lumaNN*0.5;if (!doneP) lumaEndP=lumaEndP-lumaNN*0.5;doneN=abs(lumaEndN)>=gradientScaled;doneP=abs(lumaEndP)>=gradientScaled;if (!doneN) posN.x-=offNP.x*12.0;if (!doneN) posN.y-=offNP.y*12.0;doneNP=(!doneN) || (!doneP);if (!doneP) posP.x+=offNP.x*12.0;if (!doneP) posP.y+=offNP.y*12.0;}
float dstN=posM.x-posN.x;float dstP=posP.x-posM.x;if (!horzSpan)
{dstN=posM.y-posN.y;}
if (!horzSpan) 
{dstP=posP.y-posM.y;}
bool goodSpanN=(lumaEndN<0.0) != lumaMLTZero;float spanLength=(dstP+dstN);bool goodSpanP=(lumaEndP<0.0) != lumaMLTZero;float spanLengthRcp=1.0/spanLength;bool directionN=dstN<dstP;float dst=min(dstN,dstP);bool goodSpan=directionN ? goodSpanN : goodSpanP;float subpixG=subpixF*subpixF;float pixelOffset=(dst*(-spanLengthRcp))+0.5;float subpixH=subpixG*fxaaQualitySubpix;float pixelOffsetGood=goodSpan ? pixelOffset : 0.0;float pixelOffsetSubpix=max(pixelOffsetGood,subpixH);if (!horzSpan)
{posM.x+=pixelOffsetSubpix*lengthSign;}
if (horzSpan)
{posM.y+=pixelOffsetSubpix*lengthSign;}
#ifdef MALI
if(range<rangeMaxClamped) 
{gl_FragColor=rgbyM;}
else
{gl_FragColor=TEXTUREFUNC(textureSampler,posM,0.0);}
#else
gl_FragColor=TEXTUREFUNC(textureSampler,posM,0.0);
#endif
}`;P.ShadersStore[bf]||(P.ShadersStore[bf]=xE);const uk={name:bf,shader:xE},ck=Object.freeze(Object.defineProperty({__proto__:null,fxaaPixelShader:uk},Symbol.toStringTag,{value:"Module"})),yf="fxaaVertexShader",SE=`attribute vec2 position;uniform vec2 texelSize;varying vec2 vUV;varying vec2 sampleCoordS;varying vec2 sampleCoordE;varying vec2 sampleCoordN;varying vec2 sampleCoordW;varying vec2 sampleCoordNW;varying vec2 sampleCoordSE;varying vec2 sampleCoordNE;varying vec2 sampleCoordSW;const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vUV=(position*madd+madd);sampleCoordS=vUV+vec2( 0.0,1.0)*texelSize;sampleCoordE=vUV+vec2( 1.0,0.0)*texelSize;sampleCoordN=vUV+vec2( 0.0,-1.0)*texelSize;sampleCoordW=vUV+vec2(-1.0,0.0)*texelSize;sampleCoordNW=vUV+vec2(-1.0,-1.0)*texelSize;sampleCoordSE=vUV+vec2( 1.0,1.0)*texelSize;sampleCoordNE=vUV+vec2( 1.0,-1.0)*texelSize;sampleCoordSW=vUV+vec2(-1.0,1.0)*texelSize;gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStore[yf]||(P.ShadersStore[yf]=SE);const hk={name:yf,shader:SE},dk=Object.freeze(Object.defineProperty({__proto__:null,fxaaVertexShader:hk},Symbol.toStringTag,{value:"Module"})),Tf="fxaaPixelShader",vE=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform texelSize: vec2f;varying sampleCoordS: vec2f;varying sampleCoordE: vec2f;varying sampleCoordN: vec2f;varying sampleCoordW: vec2f;varying sampleCoordNW: vec2f;varying sampleCoordSE: vec2f;varying sampleCoordNE: vec2f;varying sampleCoordSW: vec2f;const fxaaQualitySubpix: f32=1.0;const fxaaQualityEdgeThreshold: f32=0.166;const fxaaQualityEdgeThresholdMin: f32=0.0833;const kLumaCoefficients: vec3f= vec3f(0.2126,0.7152,0.0722);fn FxaaLuma(rgba: vec4f)->f32 {return dot(rgba.rgb,kLumaCoefficients);} 
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var posM: vec2f;posM.x=input.vUV.x;posM.y=input.vUV.y;var rgbyM: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.0);var lumaM: f32=FxaaLuma(rgbyM);var lumaS: f32=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,input.sampleCoordS,0.0));var lumaE: f32=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,input.sampleCoordE,0.0));var lumaN: f32=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,input.sampleCoordN,0.0));var lumaW: f32=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,input.sampleCoordW,0.0));var maxSM: f32=max(lumaS,lumaM);var minSM: f32=min(lumaS,lumaM);var maxESM: f32=max(lumaE,maxSM);var minESM: f32=min(lumaE,minSM);var maxWN: f32=max(lumaN,lumaW);var minWN: f32=min(lumaN,lumaW);var rangeMax: f32=max(maxWN,maxESM);var rangeMin: f32=min(minWN,minESM);var rangeMaxScaled: f32=rangeMax*fxaaQualityEdgeThreshold;var range: f32=rangeMax-rangeMin;var rangeMaxClamped: f32=max(fxaaQualityEdgeThresholdMin,rangeMaxScaled);
#ifndef MALI
if(range<rangeMaxClamped) 
{fragmentOutputs.color=rgbyM;return fragmentOutputs;}
#endif
var lumaNW: f32=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,input.sampleCoordNW,0.0));var lumaSE: f32=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,input.sampleCoordSE,0.0));var lumaNE: f32=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,input.sampleCoordNE,0.0));var lumaSW: f32=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,input.sampleCoordSW,0.0));var lumaNS: f32=lumaN+lumaS;var lumaWE: f32=lumaW+lumaE;var subpixRcpRange: f32=1.0/range;var subpixNSWE: f32=lumaNS+lumaWE;var edgeHorz1: f32=(-2.0*lumaM)+lumaNS;var edgeVert1: f32=(-2.0*lumaM)+lumaWE;var lumaNESE: f32=lumaNE+lumaSE;var lumaNWNE: f32=lumaNW+lumaNE;var edgeHorz2: f32=(-2.0*lumaE)+lumaNESE;var edgeVert2: f32=(-2.0*lumaN)+lumaNWNE;var lumaNWSW: f32=lumaNW+lumaSW;var lumaSWSE: f32=lumaSW+lumaSE;var edgeHorz4: f32=(abs(edgeHorz1)*2.0)+abs(edgeHorz2);var edgeVert4: f32=(abs(edgeVert1)*2.0)+abs(edgeVert2);var edgeHorz3: f32=(-2.0*lumaW)+lumaNWSW;var edgeVert3: f32=(-2.0*lumaS)+lumaSWSE;var edgeHorz: f32=abs(edgeHorz3)+edgeHorz4;var edgeVert: f32=abs(edgeVert3)+edgeVert4;var subpixNWSWNESE: f32=lumaNWSW+lumaNESE;var lengthSign: f32=uniforms.texelSize.x;var horzSpan: bool=edgeHorz>=edgeVert;var subpixA: f32=subpixNSWE*2.0+subpixNWSWNESE;if (!horzSpan)
{lumaN=lumaW;}
if (!horzSpan) 
{lumaS=lumaE;}
if (horzSpan) 
{lengthSign=uniforms.texelSize.y;}
var subpixB: f32=(subpixA*(1.0/12.0))-lumaM;var gradientN: f32=lumaN-lumaM;var gradientS: f32=lumaS-lumaM;var lumaNN: f32=lumaN+lumaM;var lumaSS: f32=lumaS+lumaM;var pairN: bool=abs(gradientN)>=abs(gradientS);var gradient: f32=max(abs(gradientN),abs(gradientS));if (pairN)
{lengthSign=-lengthSign;}
var subpixC: f32=clamp(abs(subpixB)*subpixRcpRange,0.0,1.0);var posB: vec2f;posB.x=posM.x;posB.y=posM.y;var offNP: vec2f;offNP.x=select(uniforms.texelSize.x,0.0,(!horzSpan));offNP.y=select(uniforms.texelSize.y,0.0,(horzSpan));if (!horzSpan) 
{posB.x+=lengthSign*0.5;}
if (horzSpan)
{posB.y+=lengthSign*0.5;}
var posN: vec2f;posN.x=posB.x-offNP.x*1.5;posN.y=posB.y-offNP.y*1.5;var posP: vec2f;posP.x=posB.x+offNP.x*1.5;posP.y=posB.y+offNP.y*1.5;var subpixD: f32=((-2.0)*subpixC)+3.0;var lumaEndN: f32=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,posN,0.0));var subpixE: f32=subpixC*subpixC;var lumaEndP: f32=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,posP,0.0));if (!pairN) 
{lumaNN=lumaSS;}
var gradientScaled: f32=gradient*1.0/4.0;var lumaMM: f32=lumaM-lumaNN*0.5;var subpixF: f32=subpixD*subpixE;var lumaMLTZero: bool=lumaMM<0.0;lumaEndN-=lumaNN*0.5;lumaEndP-=lumaNN*0.5;var doneN: bool=abs(lumaEndN)>=gradientScaled;var doneP: bool=abs(lumaEndP)>=gradientScaled;if (!doneN) 
{posN.x-=offNP.x*3.0;}
if (!doneN) 
{posN.y-=offNP.y*3.0;}
var doneNP: bool=(!doneN) || (!doneP);if (!doneP) 
{posP.x+=offNP.x*3.0;}
if (!doneP)
{posP.y+=offNP.y*3.0;}
if (doneNP)
{if (!doneN) {lumaEndN=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,posN.xy,0.0));}
if (!doneP) {lumaEndP=FxaaLuma(textureSampleLevel(textureSampler,textureSamplerSampler,posP.xy,0.0));}
if (!doneN) {lumaEndN=lumaEndN-lumaNN*0.5;}
if (!doneP) {lumaEndP=lumaEndP-lumaNN*0.5;}
doneN=abs(lumaEndN)>=gradientScaled;doneP=abs(lumaEndP)>=gradientScaled;if (!doneN) {posN.x-=offNP.x*12.0;}
if (!doneN) {posN.y-=offNP.y*12.0;}
doneNP=(!doneN) || (!doneP);if (!doneP) {posP.x+=offNP.x*12.0;}
if (!doneP) {posP.y+=offNP.y*12.0;}}
var dstN: f32=posM.x-posN.x;var dstP: f32=posP.x-posM.x;if (!horzSpan)
{dstN=posM.y-posN.y;}
if (!horzSpan) 
{dstP=posP.y-posM.y;}
var goodSpanN: bool=(lumaEndN<0.0) != lumaMLTZero;var spanLength: f32=(dstP+dstN);var goodSpanP: bool=(lumaEndP<0.0) != lumaMLTZero;var spanLengthRcp: f32=1.0/spanLength;var directionN: bool=dstN<dstP;var dst: f32=min(dstN,dstP);var goodSpan: bool=select(goodSpanP,goodSpanN,directionN);var subpixG: f32=subpixF*subpixF;var pixelOffset: f32=(dst*(-spanLengthRcp))+0.5;var subpixH: f32=subpixG*fxaaQualitySubpix;var pixelOffsetGood: f32=select(0.0,pixelOffset,goodSpan);var pixelOffsetSubpix: f32=max(pixelOffsetGood,subpixH);if (!horzSpan)
{posM.x+=pixelOffsetSubpix*lengthSign;}
if (horzSpan)
{posM.y+=pixelOffsetSubpix*lengthSign;}
#ifdef MALI
if(range<rangeMaxClamped) 
{fragmentOutputs.color=rgbyM;}
else
{fragmentOutputs.color=textureSampleLevel(textureSampler,textureSamplerSampler,posM,0.0);}
#else
fragmentOutputs.color=textureSampleLevel(textureSampler,textureSamplerSampler,posM,0.0);
#endif
}`;P.ShadersStoreWGSL[Tf]||(P.ShadersStoreWGSL[Tf]=vE);const fk={name:Tf,shader:vE},pk=Object.freeze(Object.defineProperty({__proto__:null,fxaaPixelShaderWGSL:fk},Symbol.toStringTag,{value:"Module"})),Cf="fxaaVertexShader",bE=`attribute position: vec2f;uniform texelSize: vec2f;varying vUV: vec2f;varying sampleCoordS: vec2f;varying sampleCoordE: vec2f;varying sampleCoordN: vec2f;varying sampleCoordW: vec2f;varying sampleCoordNW: vec2f;varying sampleCoordSE: vec2f;varying sampleCoordNE: vec2f;varying sampleCoordSW: vec2f;const madd: vec2f= vec2f(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
vertexOutputs.vUV=(input.position*madd+madd);vertexOutputs.sampleCoordS=vertexOutputs.vUV+ vec2f( 0.0,1.0)*uniforms.texelSize;vertexOutputs.sampleCoordE=vertexOutputs.vUV+ vec2f( 1.0,0.0)*uniforms.texelSize;vertexOutputs.sampleCoordN=vertexOutputs.vUV+ vec2f( 0.0,-1.0)*uniforms.texelSize;vertexOutputs.sampleCoordW=vertexOutputs.vUV+ vec2f(-1.0,0.0)*uniforms.texelSize;vertexOutputs.sampleCoordNW=vertexOutputs.vUV+ vec2f(-1.0,-1.0)*uniforms.texelSize;vertexOutputs.sampleCoordSE=vertexOutputs.vUV+ vec2f( 1.0,1.0)*uniforms.texelSize;vertexOutputs.sampleCoordNE=vertexOutputs.vUV+ vec2f( 1.0,-1.0)*uniforms.texelSize;vertexOutputs.sampleCoordSW=vertexOutputs.vUV+ vec2f(-1.0,1.0)*uniforms.texelSize;vertexOutputs.position=vec4f(input.position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStoreWGSL[Cf]||(P.ShadersStoreWGSL[Cf]=bE);const mk={name:Cf,shader:bE},_k=Object.freeze(Object.defineProperty({__proto__:null,fxaaVertexShaderWGSL:mk},Symbol.toStringTag,{value:"Module"})),Pf="blackAndWhitePixelShader",yE=`varying vec2 vUV;uniform sampler2D textureSampler;uniform float degree;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{vec3 color=texture2D(textureSampler,vUV).rgb;float luminance=dot(color,vec3(0.3,0.59,0.11)); 
vec3 blackAndWhite=vec3(luminance,luminance,luminance);gl_FragColor=vec4(color-((color-blackAndWhite)*degree),1.0);}`;P.ShadersStore[Pf]||(P.ShadersStore[Pf]=yE);const gk={name:Pf,shader:yE},xk=Object.freeze(Object.defineProperty({__proto__:null,blackAndWhitePixelShader:gk},Symbol.toStringTag,{value:"Module"})),Ef="blackAndWhitePixelShader",TE=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform degree: f32;
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var color: vec3f=textureSample(textureSampler,textureSamplerSampler,input.vUV).rgb;var luminance: f32=dot(color, vec3f(0.3,0.59,0.11)); 
var blackAndWhite: vec3f= vec3f(luminance,luminance,luminance);fragmentOutputs.color= vec4f(color-((color-blackAndWhite)*uniforms.degree),1.0);}`;P.ShadersStoreWGSL[Ef]||(P.ShadersStoreWGSL[Ef]=TE);const Sk={name:Ef,shader:TE},vk=Object.freeze(Object.defineProperty({__proto__:null,blackAndWhitePixelShaderWGSL:Sk},Symbol.toStringTag,{value:"Module"})),If="anaglyphPixelShader",CE=`varying vec2 vUV;uniform sampler2D textureSampler;uniform sampler2D leftSampler;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{vec4 leftFrag=texture2D(leftSampler,vUV);leftFrag=vec4(1.0,leftFrag.g,leftFrag.b,1.0);vec4 rightFrag=texture2D(textureSampler,vUV);rightFrag=vec4(rightFrag.r,1.0,1.0,1.0);gl_FragColor=vec4(rightFrag.rgb*leftFrag.rgb,1.0);}`;P.ShadersStore[If]||(P.ShadersStore[If]=CE);const bk={name:If,shader:CE},yk=Object.freeze(Object.defineProperty({__proto__:null,anaglyphPixelShader:bk},Symbol.toStringTag,{value:"Module"})),Rf="anaglyphPixelShader",PE=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var leftSamplerSampler: sampler;var leftSampler: texture_2d<f32>;
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var leftFrag: vec4f=textureSample(leftSampler,leftSamplerSampler,input.vUV);leftFrag= vec4f(1.0,leftFrag.g,leftFrag.b,1.0);var rightFrag: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV);rightFrag= vec4f(rightFrag.r,1.0,1.0,1.0);fragmentOutputs.color= vec4f(rightFrag.rgb*leftFrag.rgb,1.0);}`;P.ShadersStoreWGSL[Rf]||(P.ShadersStoreWGSL[Rf]=PE);const Tk={name:Rf,shader:PE},Ck=Object.freeze(Object.defineProperty({__proto__:null,anaglyphPixelShaderWGSL:Tk},Symbol.toStringTag,{value:"Module"})),Mf="convolutionPixelShader",EE=`varying vec2 vUV;uniform sampler2D textureSampler;uniform vec2 screenSize;uniform float kernel[9];
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{vec2 onePixel=vec2(1.0,1.0)/screenSize;vec4 colorSum =
texture2D(textureSampler,vUV+onePixel*vec2(-1,-1))*kernel[0] +
texture2D(textureSampler,vUV+onePixel*vec2(0,-1))*kernel[1] +
texture2D(textureSampler,vUV+onePixel*vec2(1,-1))*kernel[2] +
texture2D(textureSampler,vUV+onePixel*vec2(-1,0))*kernel[3] +
texture2D(textureSampler,vUV+onePixel*vec2(0,0))*kernel[4] +
texture2D(textureSampler,vUV+onePixel*vec2(1,0))*kernel[5] +
texture2D(textureSampler,vUV+onePixel*vec2(-1,1))*kernel[6] +
texture2D(textureSampler,vUV+onePixel*vec2(0,1))*kernel[7] +
texture2D(textureSampler,vUV+onePixel*vec2(1,1))*kernel[8];float kernelWeight =
kernel[0] +
kernel[1] +
kernel[2] +
kernel[3] +
kernel[4] +
kernel[5] +
kernel[6] +
kernel[7] +
kernel[8];if (kernelWeight<=0.0) {kernelWeight=1.0;}
gl_FragColor=vec4((colorSum/kernelWeight).rgb,1);}`;P.ShadersStore[Mf]||(P.ShadersStore[Mf]=EE);const Pk={name:Mf,shader:EE},Ek=Object.freeze(Object.defineProperty({__proto__:null,convolutionPixelShader:Pk},Symbol.toStringTag,{value:"Module"})),Af="convolutionPixelShader",IE=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform screenSize: vec2f;uniform kernel: array<f32,9>;
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var onePixel: vec2f= vec2f(1.0,1.0)/uniforms.screenSize;var colorSum: vec4f =
textureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel* vec2f(-1,-1))*uniforms.kernel[0] +
textureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel* vec2f(0,-1))*uniforms.kernel[1] +
textureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel* vec2f(1,-1))*uniforms.kernel[2] +
textureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel* vec2f(-1,0))*uniforms.kernel[3] +
textureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel* vec2f(0,0))*uniforms.kernel[4] +
textureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel* vec2f(1,0))*uniforms.kernel[5] +
textureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel* vec2f(-1,1))*uniforms.kernel[6] +
textureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel* vec2f(0,1))*uniforms.kernel[7] +
textureSample(textureSampler,textureSamplerSampler,input.vUV+onePixel* vec2f(1,1))*uniforms.kernel[8];var kernelWeight: f32 =
uniforms.kernel[0] +
uniforms.kernel[1] +
uniforms.kernel[2] +
uniforms.kernel[3] +
uniforms.kernel[4] +
uniforms.kernel[5] +
uniforms.kernel[6] +
uniforms.kernel[7] +
uniforms.kernel[8];if (kernelWeight<=0.0) {kernelWeight=1.0;}
fragmentOutputs.color= vec4f((colorSum/kernelWeight).rgb,1);}`;P.ShadersStoreWGSL[Af]||(P.ShadersStoreWGSL[Af]=IE);const Ik={name:Af,shader:IE},Rk=Object.freeze(Object.defineProperty({__proto__:null,convolutionPixelShaderWGSL:Ik},Symbol.toStringTag,{value:"Module"})),Df="colorCorrectionPixelShader",RE=`uniform sampler2D textureSampler; 
uniform sampler2D colorTable; 
varying vec2 vUV;const float SLICE_COUNT=16.0; 
#define inline
vec4 sampleAs3DTexture(sampler2D textureSampler,vec3 uv,float width) {float sliceSize=1.0/width; 
float slicePixelSize=sliceSize/width; 
float sliceInnerSize=slicePixelSize*(width-1.0); 
float zSlice0=min(floor(uv.z*width),width-1.0);float zSlice1=min(zSlice0+1.0,width-1.0);float xOffset=slicePixelSize*0.5+uv.x*sliceInnerSize;float s0=xOffset+(zSlice0*sliceSize);float s1=xOffset+(zSlice1*sliceSize);vec4 slice0Color=texture2D(textureSampler,vec2(s0,uv.y));vec4 slice1Color=texture2D(textureSampler,vec2(s1,uv.y));float zOffset=mod(uv.z*width,1.0);vec4 result=mix(slice0Color,slice1Color,zOffset);return result;}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{vec4 screen_color=texture2D(textureSampler,vUV);gl_FragColor=sampleAs3DTexture(colorTable,screen_color.rgb,SLICE_COUNT);}`;P.ShadersStore[Df]||(P.ShadersStore[Df]=RE);const Mk={name:Df,shader:RE},Ak=Object.freeze(Object.defineProperty({__proto__:null,colorCorrectionPixelShader:Mk},Symbol.toStringTag,{value:"Module"})),Of="colorCorrectionPixelShader",ME=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;varying vUV: vec2f;var colorTableSampler: sampler;var colorTable: texture_2d<f32>;const SLICE_COUNT: f32=16.0; 
fn sampleAs3DTexture(uv: vec3f,width: f32)->vec4f {var sliceSize: f32=1.0/width; 
var slicePixelSize: f32=sliceSize/width; 
var sliceInnerSize: f32=slicePixelSize*(width-1.0); 
var zSlice0: f32=min(floor(uv.z*width),width-1.0);var zSlice1: f32=min(zSlice0+1.0,width-1.0);var xOffset: f32=slicePixelSize*0.5+uv.x*sliceInnerSize;var s0: f32=xOffset+(zSlice0*sliceSize);var s1: f32=xOffset+(zSlice1*sliceSize);var slice0Color: vec4f=textureSample(colorTable,colorTableSampler,vec2f(s0,uv.y));var slice1Color: vec4f=textureSample(colorTable,colorTableSampler,vec2f(s1,uv.y));var zOffset: f32=((uv.z*width)%(1.0));return mix(slice0Color,slice1Color,zOffset);}
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var screen_color: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV);fragmentOutputs.color=sampleAs3DTexture(screen_color.rgb,SLICE_COUNT);}`;P.ShadersStoreWGSL[Of]||(P.ShadersStoreWGSL[Of]=ME);const Dk={name:Of,shader:ME},Ok=Object.freeze(Object.defineProperty({__proto__:null,colorCorrectionPixelShaderWGSL:Dk},Symbol.toStringTag,{value:"Module"})),wf="motionBlurPixelShader",AE=`varying vec2 vUV;uniform sampler2D textureSampler;uniform float motionStrength;uniform float motionScale;uniform vec2 screenSize;
#ifdef OBJECT_BASED
uniform sampler2D velocitySampler;
#else
uniform sampler2D depthSampler;uniform mat4 inverseViewProjection;uniform mat4 prevViewProjection;uniform mat4 projection;
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#ifdef GEOMETRY_SUPPORTED
#ifdef OBJECT_BASED
vec2 texelSize=1.0/screenSize;vec4 velocityColor=texture2D(velocitySampler,vUV);velocityColor.rg=velocityColor.rg*2.0-vec2(1.0);vec2 signs=sign(velocityColor.rg);vec2 velocity=pow(abs(velocityColor.rg),vec2(3.0))*signs*velocityColor.a;velocity*=motionScale*motionStrength;float speed=length(velocity/texelSize);int samplesCount=int(clamp(speed,1.0,SAMPLES));velocity=normalize(velocity)*texelSize;float hlim=float(-samplesCount)*0.5+0.5;vec4 result=texture2D(textureSampler,vUV);for (int i=1; i<int(SAMPLES); ++i)
{if (i>=samplesCount)
break;vec2 offset=vUV+velocity*(hlim+float(i));
#if defined(WEBGPU)
result+=texture2DLodEXT(textureSampler,offset,0.0);
#else
result+=texture2D(textureSampler,offset);
#endif
}
gl_FragColor=result/float(samplesCount);gl_FragColor.a=1.0;
#else
vec2 texelSize=1.0/screenSize;float depth=texture2D(depthSampler,vUV).r;depth=projection[2].z+projection[3].z/depth; 
vec4 cpos=vec4(vUV*2.0-1.0,depth,1.0);cpos=inverseViewProjection*cpos;cpos/=cpos.w;vec4 ppos=prevViewProjection*cpos;ppos/=ppos.w;ppos.xy=ppos.xy*0.5+0.5;vec2 velocity=(ppos.xy-vUV)*motionScale*motionStrength;float speed=length(velocity/texelSize);int nSamples=int(clamp(speed,1.0,SAMPLES));vec4 result=texture2D(textureSampler,vUV);for (int i=1; i<int(SAMPLES); ++i) {if (i>=nSamples)
break;vec2 offset1=vUV+velocity*(float(i)/float(nSamples-1)-0.5);
#if defined(WEBGPU)
result+=texture2DLodEXT(textureSampler,offset1,0.0);
#else
result+=texture2D(textureSampler,offset1);
#endif
}
gl_FragColor=result/float(nSamples);
#endif
#else
gl_FragColor=texture2D(textureSampler,vUV);
#endif
}
`;P.ShadersStore[wf]||(P.ShadersStore[wf]=AE);const wk={name:wf,shader:AE},Nk=Object.freeze(Object.defineProperty({__proto__:null,motionBlurPixelShader:wk},Symbol.toStringTag,{value:"Module"})),Nf="motionBlurPixelShader",DE=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform motionStrength: f32;uniform motionScale: f32;uniform screenSize: vec2f;
#ifdef OBJECT_BASED
var velocitySamplerSampler: sampler;var velocitySampler: texture_2d<f32>;
#else
var depthSamplerSampler: sampler;var depthSampler: texture_2d<f32>;uniform inverseViewProjection: mat4x4f;uniform prevViewProjection: mat4x4f;uniform projection: mat4x4f;
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#ifdef GEOMETRY_SUPPORTED
#ifdef OBJECT_BASED
var texelSize: vec2f=1.0/uniforms.screenSize;var velocityColor: vec4f=textureSample(velocitySampler,velocitySamplerSampler,input.vUV);velocityColor=vec4f(velocityColor.rg*2.0- vec2f(1.0),velocityColor.b,velocityColor.a);let signs=sign(velocityColor.rg);var velocity=pow(abs(velocityColor.rg),vec2f(3.0))*signs*velocityColor.a;velocity*=uniforms.motionScale*uniforms.motionStrength;var speed: f32=length(velocity/texelSize);var samplesCount: i32= i32(clamp(speed,1.0,SAMPLES));velocity=normalize(velocity)*texelSize;var hlim: f32= f32(-samplesCount)*0.5+0.5;var result: vec4f=textureSample(textureSampler,textureSamplerSampler, input.vUV);for (var i: i32=1; i< i32(SAMPLES); i++)
{if (i>=samplesCount) {break;}
var offset: vec2f=input.vUV+velocity*(hlim+ f32(i));
#if defined(WEBGPU)
result+=textureSampleLevel(textureSampler,textureSamplerSampler, offset,0.0);
#else
result+=textureSample(textureSampler,textureSamplerSampler, offset);
#endif
}
fragmentOutputs.color=vec4f(result.rgb/ f32(samplesCount),1.0);
#else
var texelSize: vec2f=1.0/uniforms.screenSize;var depth: f32=textureSample(depthSampler,depthSamplerSampler,input.vUV).r;depth=uniforms.projection[2].z+uniforms.projection[3].z/depth; 
var cpos: vec4f= vec4f(input.vUV*2.0-1.0,depth,1.0);cpos=uniforms.inverseViewProjection*cpos;cpos/=cpos.w;var ppos: vec4f=uniforms.prevViewProjection*cpos;ppos/=ppos.w;ppos.xy=ppos.xy*0.5+0.5;var velocity: vec2f=(ppos.xy-input.vUV)*uniforms.motionScale*uniforms.motionStrength;var speed: f32=length(velocity/texelSize);var nSamples: i32= i32(clamp(speed,1.0,SAMPLES));var result: vec4f=textureSample(textureSampler,textureSamplerSampler, input.vUV);for (var i: i32=1; i< i32(SAMPLES); i++) {if (i>=nSamples) {break;}
var offset1: vec2f=input.vUV+velocity*( f32(i)/ f32(nSamples-1)-0.5);
#if defined(WEBGPU)
result+=textureSampleLevel(textureSampler,textureSamplerSampler, offset1,0.0);
#else
result+=textureSample(textureSampler,textureSamplerSampler, offset1);
#endif
}
fragmentOutputs.color=result/ f32(nSamples);
#endif
#else
fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler, input.vUV);
#endif
}
`;P.ShadersStoreWGSL[Nf]||(P.ShadersStoreWGSL[Nf]=DE);const Fk={name:Nf,shader:DE},Lk=Object.freeze(Object.defineProperty({__proto__:null,motionBlurPixelShaderWGSL:Fk},Symbol.toStringTag,{value:"Module"})),Ff="filterPixelShader",OE=`varying vec2 vUV;uniform sampler2D textureSampler;uniform mat4 kernelMatrix;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{vec3 baseColor=texture2D(textureSampler,vUV).rgb;vec3 updatedColor=(kernelMatrix*vec4(baseColor,1.0)).rgb;gl_FragColor=vec4(updatedColor,1.0);}`;P.ShadersStore[Ff]||(P.ShadersStore[Ff]=OE);const Bk={name:Ff,shader:OE},Vk=Object.freeze(Object.defineProperty({__proto__:null,filterPixelShader:Bk},Symbol.toStringTag,{value:"Module"})),Lf="filterPixelShader",wE=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform kernelMatrix: mat4x4f;
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var baseColor: vec3f=textureSample(textureSampler,textureSamplerSampler,input.vUV).rgb;var updatedColor: vec3f=(uniforms.kernelMatrix* vec4f(baseColor,1.0)).rgb;fragmentOutputs.color= vec4f(updatedColor,1.0);}`;P.ShadersStoreWGSL[Lf]||(P.ShadersStoreWGSL[Lf]=wE);const kk={name:Lf,shader:wE},zk=Object.freeze(Object.defineProperty({__proto__:null,filterPixelShaderWGSL:kk},Symbol.toStringTag,{value:"Module"})),Bf="highlightsPixelShader",NE=`varying vec2 vUV;uniform sampler2D textureSampler;const vec3 RGBLuminanceCoefficients=vec3(0.2126,0.7152,0.0722);
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{vec4 tex=texture2D(textureSampler,vUV);vec3 c=tex.rgb;float luma=dot(c.rgb,RGBLuminanceCoefficients);gl_FragColor=vec4(pow(c,vec3(25.0-luma*15.0)),tex.a); }`;P.ShadersStore[Bf]||(P.ShadersStore[Bf]=NE);const Uk={name:Bf,shader:NE},h$=Object.freeze(Object.defineProperty({__proto__:null,highlightsPixelShader:Uk},Symbol.toStringTag,{value:"Module"})),Vf="highlightsPixelShader",FE=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;const RGBLuminanceCoefficients: vec3f= vec3f(0.2126,0.7152,0.0722);
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var tex: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV);var c: vec3f=tex.rgb;var luma: f32=dot(c.rgb,RGBLuminanceCoefficients);fragmentOutputs.color= vec4f(pow(c, vec3f(25.0-luma*15.0)),tex.a); }`;P.ShadersStoreWGSL[Vf]||(P.ShadersStoreWGSL[Vf]=FE);const Gk={name:Vf,shader:FE},d$=Object.freeze(Object.defineProperty({__proto__:null,highlightsPixelShaderWGSL:Gk},Symbol.toStringTag,{value:"Module"})),kf="displayPassPixelShader",LE=`varying vec2 vUV;uniform sampler2D textureSampler;uniform sampler2D passSampler;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{gl_FragColor=texture2D(passSampler,vUV);}`;P.ShadersStore[kf]||(P.ShadersStore[kf]=LE);const Wk={name:kf,shader:LE},$k=Object.freeze(Object.defineProperty({__proto__:null,displayPassPixelShader:Wk},Symbol.toStringTag,{value:"Module"})),zf="displayPassPixelShader",BE=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var passSamplerSampler: sampler;var passSampler: texture_2d<f32>;
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=textureSample(passSampler,passSamplerSampler,input.vUV);}`;P.ShadersStoreWGSL[zf]||(P.ShadersStoreWGSL[zf]=BE);const Hk={name:zf,shader:BE},jk=Object.freeze(Object.defineProperty({__proto__:null,displayPassPixelShaderWGSL:Hk},Symbol.toStringTag,{value:"Module"})),Uf="tonemapPixelShader",VE=`varying vec2 vUV;uniform sampler2D textureSampler;uniform float _ExposureAdjustment;
#if defined(HABLE_TONEMAPPING)
const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;const float W=11.2;
#endif
float Luminance(vec3 c)
{return dot(c,vec3(0.22,0.707,0.071));}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{vec3 colour=texture2D(textureSampler,vUV).rgb;
#if defined(REINHARD_TONEMAPPING)
float lum=Luminance(colour.rgb); 
float lumTm=lum*_ExposureAdjustment;float scale=lumTm/(1.0+lumTm); 
colour*=scale/lum;
#elif defined(HABLE_TONEMAPPING)
colour*=_ExposureAdjustment;const float ExposureBias=2.0;vec3 x=ExposureBias*colour;vec3 curr=((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;x=vec3(W,W,W);vec3 whiteScale=1.0/(((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F);colour=curr*whiteScale;
#elif defined(OPTIMIZED_HEJIDAWSON_TONEMAPPING)
colour*=_ExposureAdjustment;vec3 X=max(vec3(0.0,0.0,0.0),colour-0.004);vec3 retColor=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);colour=retColor*retColor;
#elif defined(PHOTOGRAPHIC_TONEMAPPING)
colour= vec3(1.0,1.0,1.0)-exp2(-_ExposureAdjustment*colour);
#endif
gl_FragColor=vec4(colour.rgb,1.0);}`;P.ShadersStore[Uf]||(P.ShadersStore[Uf]=VE);const Yk={name:Uf,shader:VE},Xk=Object.freeze(Object.defineProperty({__proto__:null,tonemapPixelShader:Yk},Symbol.toStringTag,{value:"Module"})),Gf="tonemapPixelShader",kE=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform _ExposureAdjustment: f32;
#if defined(HABLE_TONEMAPPING)
const A: f32=0.15;const B: f32=0.50;const C: f32=0.10;const D: f32=0.20;const E: f32=0.02;const F: f32=0.30;const W: f32=11.2;
#endif
fn Luminance(c: vec3f)->f32
{return dot(c, vec3f(0.22,0.707,0.071));}
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var colour: vec3f=textureSample(textureSampler,textureSamplerSampler,input.vUV).rgb;
#if defined(REINHARD_TONEMAPPING)
var lum: f32=Luminance(colour.rgb); 
var lumTm: f32=lum*uniforms._ExposureAdjustment;var scale: f32=lumTm/(1.0+lumTm); 
colour*=scale/lum;
#elif defined(HABLE_TONEMAPPING)
colour*=uniforms._ExposureAdjustment;const ExposureBias: f32=2.0;var x: vec3f=ExposureBias*colour;var curr: vec3f=((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;x= vec3f(W,W,W);var whiteScale: vec3f=1.0/(((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F);colour=curr*whiteScale;
#elif defined(OPTIMIZED_HEJIDAWSON_TONEMAPPING)
colour*=uniforms._ExposureAdjustment;var X: vec3f=max( vec3f(0.0,0.0,0.0),colour-0.004);var retColor: vec3f=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);colour=retColor*retColor;
#elif defined(PHOTOGRAPHIC_TONEMAPPING)
colour= vec3f(1.0,1.0,1.0)-exp2(-uniforms._ExposureAdjustment*colour);
#endif
fragmentOutputs.color= vec4f(colour.rgb,1.0);}`;P.ShadersStoreWGSL[Gf]||(P.ShadersStoreWGSL[Gf]=kE);const Zk={name:Gf,shader:kE},qk=Object.freeze(Object.defineProperty({__proto__:null,tonemapPixelShaderWGSL:Zk},Symbol.toStringTag,{value:"Module"}));Object.defineProperty(Te.prototype,"forceShowBoundingBoxes",{get:function(){return this._forceShowBoundingBoxes||!1},set:function(a){this._forceShowBoundingBoxes=a,a&&this.getBoundingBoxRenderer()},enumerable:!0,configurable:!0});Te.prototype.getBoundingBoxRenderer=function(){return this._boundingBoxRenderer||(this._boundingBoxRenderer=new Jk(this)),this._boundingBoxRenderer};Object.defineProperty(Rt.prototype,"showBoundingBox",{get:function(){return this._showBoundingBox||!1},set:function(a){this._showBoundingBox=a,a&&this.getScene().getBoundingBoxRenderer()},enumerable:!0,configurable:!0});const zE=$.Identity(),ou=new m,Qk=new m,Kk=zE.asArray(),gb=new Zc(ou,ou);class Jk{get shaderLanguage(){return this._shaderLanguage}constructor(e){this.name=ge.NAME_BOUNDINGBOXRENDERER,this.frontColor=new ne(1,1,1),this.backColor=new ne(.1,.1,.1),this.showBackLines=!0,this.onBeforeBoxRenderingObservable=new j,this.onAfterBoxRenderingObservable=new j,this.onResourcesReadyObservable=new j,this.enabled=!0,this._shaderLanguage=0,this.renderList=new Go(32),this._vertexBuffers={},this._fillIndexBuffer=null,this._fillIndexData=null,this._matrixBuffer=null,this._matrices=null,this._useInstances=!1,this._drawWrapperFront=null,this._drawWrapperBack=null,this.scene=e,this.scene.getEngine().isWebGPU&&(this._shaderLanguage=1),e._addComponent(this),this._uniformBufferFront=new tn(this.scene.getEngine(),void 0,void 0,"BoundingBoxRendererFront",!0),this._buildUniformLayout(this._uniformBufferFront),this._uniformBufferBack=new tn(this.scene.getEngine(),void 0,void 0,"BoundingBoxRendererBack",!0),this._buildUniformLayout(this._uniformBufferBack)}_buildUniformLayout(e){e.addUniform("color",4),e.addUniform("world",16),e.addUniform("viewProjection",16),e.addUniform("viewProjectionR",16),e.create()}register(){this.scene._beforeEvaluateActiveMeshStage.registerStep(ge.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER,this,this.reset),this.scene._preActiveMeshStage.registerStep(ge.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER,this,this._preActiveMesh),this.scene._evaluateSubMeshStage.registerStep(ge.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER,this,this._evaluateSubMesh),this.scene._afterRenderingGroupDrawStage.registerStep(ge.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER,this,this.render)}_evaluateSubMesh(e,t){if(e.showSubMeshesBoundingBox){const i=t.getBoundingInfo();i!=null&&(i.boundingBox._tag=e.renderingGroupId,this.renderList.push(i.boundingBox))}}_preActiveMesh(e){if(e.showBoundingBox||this.scene.forceShowBoundingBoxes){const t=e.getBoundingInfo();t.boundingBox._tag=e.renderingGroupId,this.renderList.push(t.boundingBox)}}_prepareResources(){if(this._colorShader)return;this._colorShader=new Wr("colorShader",this.scene,"boundingBoxRenderer",{attributes:[N.PositionKind,"world0","world1","world2","world3"],uniforms:["world","viewProjection","viewProjectionR","color"],uniformBuffers:["BoundingBoxRenderer"],shaderLanguage:this._shaderLanguage,extraInitializationsAsync:async()=>{this._shaderLanguage===1?await Promise.all([k(()=>Promise.resolve().then(()=>Lb),void 0),k(()=>Promise.resolve().then(()=>Fb),void 0)]):await Promise.all([k(()=>Promise.resolve().then(()=>Nb),void 0),k(()=>Promise.resolve().then(()=>Ob),void 0)])}},!1),this._colorShader.setDefine("INSTANCES",this._useInstances),this._colorShader.doNotSerialize=!0,this._colorShader.reservedDataStore={hidden:!0},this._colorShaderForOcclusionQuery=new Wr("colorShaderOccQuery",this.scene,"boundingBoxRenderer",{attributes:[N.PositionKind],uniforms:["world","viewProjection","viewProjectionR","color"],uniformBuffers:["BoundingBoxRenderer"],shaderLanguage:this._shaderLanguage,extraInitializationsAsync:async()=>{this._shaderLanguage===1?await Promise.all([k(()=>Promise.resolve().then(()=>Lb),void 0),k(()=>Promise.resolve().then(()=>Fb),void 0)]):await Promise.all([k(()=>Promise.resolve().then(()=>Nb),void 0),k(()=>Promise.resolve().then(()=>Ob),void 0)])}},!0),this._colorShaderForOcclusionQuery.doNotSerialize=!0,this._colorShaderForOcclusionQuery.reservedDataStore={hidden:!0};const e=this.scene.getEngine(),t=c_({size:1});this._vertexBuffers[N.PositionKind]=new N(e,t.positions,N.PositionKind,!1),this._createIndexBuffer(),this._fillIndexData=t.indices,this.onResourcesReadyObservable.notifyObservers(this)}_createIndexBuffer(){const e=this.scene.getEngine();this._indexBuffer=e.createIndexBuffer([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,7,1,6,2,5,3,4])}rebuild(){const e=this._vertexBuffers[N.PositionKind];e&&e._rebuild(),this._createIndexBuffer(),this._matrixBuffer&&this._matrixBuffer._rebuild()}reset(){this.renderList.reset()}render(e){if(this.renderList.length===0||!this.enabled)return;if(this._useInstances){this._renderInstanced(e);return}if(this._prepareResources(),!this._colorShader.isReady())return;const t=this.scene.getEngine();t.setDepthWrite(!1);const i=this.scene.getTransformMatrix();for(let r=0;r<this.renderList.length;r++){const s=this.renderList.data[r];if(s._tag!==e)continue;this._createWrappersForBoundingBox(s),this.onBeforeBoxRenderingObservable.notifyObservers(s);const n=s.minimum,l=s.maximum.subtract(n),u=n.add(l.scale(.5)),c=$.Scaling(l.x,l.y,l.z).multiply($.Translation(u.x,u.y,u.z)).multiply(s.getWorldMatrix()),h=t.useReverseDepthBuffer;if(this.showBackLines){const f=s._drawWrapperBack??this._colorShader._getDrawWrapper();this._colorShader._preBind(f),t.bindBuffers(this._vertexBuffers,this._indexBuffer,this._colorShader.getEffect()),h?t.setDepthFunctionToLessOrEqual():t.setDepthFunctionToGreaterOrEqual(),this._uniformBufferBack.bindToEffect(f.effect,"BoundingBoxRenderer"),this._uniformBufferBack.updateColor4("color",this.backColor,1),this._uniformBufferBack.updateMatrix("world",c),this._uniformBufferBack.updateMatrix("viewProjection",i),this._uniformBufferBack.update(),t.drawElementsType(ft.LineListDrawMode,0,24)}const d=s._drawWrapperFront??this._colorShader._getDrawWrapper();this._colorShader._preBind(d),t.bindBuffers(this._vertexBuffers,this._indexBuffer,this._colorShader.getEffect()),h?t.setDepthFunctionToGreater():t.setDepthFunctionToLess(),this._uniformBufferFront.bindToEffect(d.effect,"BoundingBoxRenderer"),this._uniformBufferFront.updateColor4("color",this.frontColor,1),this._uniformBufferFront.updateMatrix("world",c),this._uniformBufferFront.updateMatrix("viewProjection",i),this._uniformBufferFront.update(),t.drawElementsType(ft.LineListDrawMode,0,24),this.onAfterBoxRenderingObservable.notifyObservers(s)}this._colorShader.unbind(),t.setDepthFunctionToLessOrEqual(),t.setDepthWrite(!0)}_createWrappersForBoundingBox(e){if(!e._drawWrapperFront){const t=this.scene.getEngine();e._drawWrapperFront=new vi(t),e._drawWrapperBack=new vi(t),e._drawWrapperFront.setEffect(this._colorShader.getEffect()),e._drawWrapperBack.setEffect(this._colorShader.getEffect())}}renderOcclusionBoundingBox(e){const t=this.scene.getEngine();this._renderPassIdForOcclusionQuery===void 0&&(this._renderPassIdForOcclusionQuery=t.createRenderPassId("Render pass for occlusion query"));const i=t.currentRenderPassId;t.currentRenderPassId=this._renderPassIdForOcclusionQuery,this._prepareResources();const r=e.subMeshes[0];if(!this._colorShaderForOcclusionQuery.isReady(e,void 0,r)||!e.hasBoundingInfo){t.currentRenderPassId=i;return}this._fillIndexBuffer||(this._fillIndexBuffer=t.createIndexBuffer(this._fillIndexData));const s=t.useReverseDepthBuffer;t.setDepthWrite(!1),t.setColorWrite(!1);const n=e.getBoundingInfo().boundingBox,o=n.minimum,u=n.maximum.subtract(o),c=o.add(u.scale(.5)),h=$.Scaling(u.x,u.y,u.z).multiply($.Translation(c.x,c.y,c.z)).multiply(n.getWorldMatrix()),d=r._drawWrapper;this._colorShaderForOcclusionQuery._preBind(d),t.bindBuffers(this._vertexBuffers,this._fillIndexBuffer,d.effect),s?t.setDepthFunctionToGreater():t.setDepthFunctionToLess(),this.scene.resetCachedMaterial(),this._uniformBufferFront.bindToEffect(d.effect,"BoundingBoxRenderer"),this._uniformBufferFront.updateMatrix("world",h),this._uniformBufferFront.updateMatrix("viewProjection",this.scene.getTransformMatrix()),this._uniformBufferFront.update(),t.drawElementsType(ft.TriangleFillMode,0,36),this._colorShaderForOcclusionQuery.unbind(),t.setDepthFunctionToLessOrEqual(),t.setDepthWrite(!0),t.setColorWrite(!0),t.currentRenderPassId=i}set useInstances(e){this._useInstances=e,this._colorShader&&this._colorShader.setDefine("INSTANCES",e),e||this._cleanupInstances()}get useInstances(){return this._useInstances}_renderInstanced(e){if(this.renderList.length===0||!this.enabled||(this._prepareResources(),!this._colorShader.isReady()))return;const t=this._colorShader;let i=this._matrices;const r=this.renderList.length*16;(!i||i.length<r||i.length>r*2)&&(i=new Float32Array(r),this._matrices=i),this.onBeforeBoxRenderingObservable.notifyObservers(gb);let s=0;for(let p=0;p<this.renderList.length;p++){const g=this.renderList.data[p];if(g._tag!==e)continue;const _=g.minimum,b=g.maximum.subtractToRef(_,Qk),y=_.addToRef(b.scaleToRef(.5,ou),ou),T=Kk;T[0]=b._x,T[3]=y._x,T[5]=b._y,T[7]=y._y,T[10]=b._z,T[11]=y._z,zE.multiplyToArray(g.getWorldMatrix(),i,s*16),s++}const n=this.scene.getEngine(),o=n.getDepthFunction()??515,l=n.getDepthWrite();n.setDepthWrite(!1);const u=this._matrixBuffer;u!=null&&u.isUpdatable()&&u.getData()===i?u.update(i):this._createInstanceBuffer(i),this._createWrappersForBoundingBox(this);const c=n.useReverseDepthBuffer,h=this.scene.getTransformMatrix();if(this.showBackLines){const p=this._drawWrapperBack??t._getDrawWrapper();t._preBind(p),n.bindBuffers(this._vertexBuffers,this._indexBuffer,t.getEffect()),c?n.setDepthFunctionToLessOrEqual():n.setDepthFunctionToGreaterOrEqual();const g=this._uniformBufferBack;g.bindToEffect(p.effect,"BoundingBoxRenderer"),g.updateColor4("color",this.backColor,1),g.updateMatrix("viewProjection",h),g.update(),n.drawElementsType(ft.LineListDrawMode,0,24,s)}const d=t._getDrawWrapper();t._preBind(d),n.bindBuffers(this._vertexBuffers,this._indexBuffer,t.getEffect()),c?n.setDepthFunctionToGreater():n.setDepthFunctionToLess();const f=this._uniformBufferFront;f.bindToEffect(d.effect,"BoundingBoxRenderer"),f.updateColor4("color",this.frontColor,1),f.updateMatrix("viewProjection",h),f.update(),n.drawElementsType(ft.LineListDrawMode,0,24,s),this.onAfterBoxRenderingObservable.notifyObservers(gb),t.unbind(),n.setDepthFunction(o),n.setDepthWrite(l)}_createInstanceBuffer(e){const t=this._vertexBuffers;this._cleanupInstanceBuffer();const i=new fi(this.scene.getEngine(),e,!0,16,!1,!0);t.world0=i.createVertexBuffer("world0",0,4),t.world1=i.createVertexBuffer("world1",4,4),t.world2=i.createVertexBuffer("world2",8,4),t.world3=i.createVertexBuffer("world3",12,4),this._matrixBuffer=i}_cleanupInstanceBuffer(){const e=this._vertexBuffers;e.world0&&(e.world0.dispose(),delete e.world0),e.world1&&(e.world1.dispose(),delete e.world1),e.world2&&(e.world2.dispose(),delete e.world2),e.world3&&(e.world3.dispose(),delete e.world3),this._matrices=null,this._matrixBuffer&&(this._matrixBuffer.dispose(),this._matrixBuffer=null)}_cleanupInstances(){this._cleanupInstanceBuffer(),this._drawWrapperFront&&(this._drawWrapperFront.dispose(),this._drawWrapperFront=null),this._drawWrapperBack&&(this._drawWrapperBack.dispose(),this._drawWrapperBack=null)}dispose(){if(this._renderPassIdForOcclusionQuery!==void 0&&(this.scene.getEngine().releaseRenderPassId(this._renderPassIdForOcclusionQuery),this._renderPassIdForOcclusionQuery=void 0),!this._colorShader)return;this.onBeforeBoxRenderingObservable.clear(),this.onAfterBoxRenderingObservable.clear(),this.onResourcesReadyObservable.clear(),this.renderList.dispose(),this._colorShader.dispose(),this._colorShaderForOcclusionQuery.dispose(),this._uniformBufferFront.dispose(),this._uniformBufferBack.dispose();const e=this._vertexBuffers[N.PositionKind];e&&(e.dispose(),this._vertexBuffers[N.PositionKind]=null),this.scene.getEngine()._releaseBuffer(this._indexBuffer),this._fillIndexBuffer&&(this.scene.getEngine()._releaseBuffer(this._fillIndexBuffer),this._fillIndexBuffer=null),this._cleanupInstances()}}Te.prototype.enableDepthRenderer=function(a,e=!1,t=!1,i=3,r=!1){if(a=a||this.activeCamera,!a)throw"No camera available to enable depth renderer";if(this._depthRenderer||(this._depthRenderer={}),!this._depthRenderer[a.id]){const s=!!this.getEngine().getCaps().textureFloatRender;let n=0;this.getEngine().getCaps().textureHalfFloatRender&&(!t||!s)?n=2:s?n=1:n=0,this._depthRenderer[a.id]=new As(this,n,a,e,i,r)}return this._depthRenderer[a.id]};Te.prototype.disableDepthRenderer=function(a){a=a||this.activeCamera,!(!a||!this._depthRenderer||!this._depthRenderer[a.id])&&this._depthRenderer[a.id].dispose()};class ez{constructor(e){this.name=ge.NAME_DEPTHRENDERER,this.scene=e}register(){this.scene._gatherRenderTargetsStage.registerStep(ge.STEP_GATHERRENDERTARGETS_DEPTHRENDERER,this,this._gatherRenderTargets),this.scene._gatherActiveCameraRenderTargetsStage.registerStep(ge.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER,this,this._gatherActiveCameraRenderTargets)}rebuild(){}dispose(){for(const e in this.scene._depthRenderer)this.scene._depthRenderer[e].dispose()}_gatherRenderTargets(e){if(this.scene._depthRenderer)for(const t in this.scene._depthRenderer){const i=this.scene._depthRenderer[t];i.enabled&&!i.useOnlyInActiveCamera&&e.push(i.getDepthMap())}}_gatherActiveCameraRenderTargets(e){if(this.scene._depthRenderer)for(const t in this.scene._depthRenderer){const i=this.scene._depthRenderer[t];i.enabled&&i.useOnlyInActiveCamera&&this.scene.activeCamera.id===t&&e.push(i.getDepthMap())}}}As._SceneComponentInitialization=a=>{let e=a._getComponent(ge.NAME_DEPTHRENDERER);e||(e=new ez(a),a._addComponent(e))};class tz{constructor(){this.enabled=!0,this.name="depthPeeling",this.texturesRequired=[4]}}class Es{get passCount(){return this._passCount}set passCount(e){this._passCount!==e&&(this._passCount=e,this._createRenderPassIds())}get useRenderPasses(){return this._useRenderPasses}set useRenderPasses(e){this._useRenderPasses!==e&&(this._useRenderPasses=e,this._createRenderPassIds())}addExcludedMesh(e){this._excludedMeshes.indexOf(e.uniqueId)===-1&&this._excludedMeshes.push(e.uniqueId)}removeExcludedMesh(e){const t=this._excludedMeshes.indexOf(e.uniqueId);t!==-1&&this._excludedMeshes.splice(t,1)}get shaderLanguage(){return this._shaderLanguage}constructor(e,t=5){if(this._thinTextures=[],this._currentPingPongState=0,this._layoutCacheFormat=[[!0],[!0,!0],[!0,!0,!0]],this._layoutCache=[],this._candidateSubMeshes=new Go(10),this._excludedSubMeshes=new Go(10),this._excludedMeshes=[],this._colorCache=[new xe(Es._DEPTH_CLEAR_VALUE,Es._DEPTH_CLEAR_VALUE,0,0),new xe(-Es._MIN_DEPTH,Es._MAX_DEPTH,0,0),new xe(0,0,0,0)],this._shaderLanguage=0,this._scene=e,this._engine=e.getEngine(),this._passCount=t,!e.enablePrePassRenderer()){L.Warn("Depth peeling for order independant transparency could not enable PrePass, aborting.");return}for(let i=0;i<this._layoutCacheFormat.length;++i)this._layoutCache[i]=this._engine.buildTextureLayout(this._layoutCacheFormat[i]);this._renderPassIds=[],this.useRenderPasses=!1,this._engine.isWebGPU&&(this._shaderLanguage=1),this._prePassEffectConfiguration=new tz,this._createTextures(),this._createEffects()}_createRenderPassIds(){if(this._releaseRenderPassIds(),this._useRenderPasses)for(let e=0;e<this._passCount+1;++e)this._renderPassIds[e]||(this._renderPassIds[e]=this._engine.createRenderPassId(`DepthPeelingRenderer - pass #${e}`))}_releaseRenderPassIds(){for(let e=0;e<this._renderPassIds.length;++e)this._engine.releaseRenderPassId(this._renderPassIds[e]);this._renderPassIds=[]}_createTextures(){const e={width:this._engine.getRenderWidth(),height:this._engine.getRenderHeight()};this._depthMrts=[new Zs("depthPeelingDepth0MRT",e,3,this._scene,void 0,["depthPeelingDepth0MRT_depth","depthPeelingDepth0MRT_frontColor","depthPeelingDepth0MRT_backColor"]),new Zs("depthPeelingDepth1MRT",e,3,this._scene,void 0,["depthPeelingDepth1MRT_depth","depthPeelingDepth1MRT_frontColor","depthPeelingDepth1MRT_backColor"])],this._colorMrts=[new Zs("depthPeelingColor0MRT",e,2,this._scene,{generateDepthBuffer:!1},["depthPeelingColor0MRT_frontColor","depthPeelingColor0MRT_backColor"]),new Zs("depthPeelingColor1MRT",e,2,this._scene,{generateDepthBuffer:!1},["depthPeelingColor1MRT_frontColor","depthPeelingColor1MRT_backColor"])],this._blendBackMrt=new Zs("depthPeelingBackMRT",e,1,this._scene,{generateDepthBuffer:!1},["depthPeelingBackMRT_blendBack"]),this._outputRT=new Kt("depthPeelingOutputRTT",e,this._scene,!1);const t=[{format:7,samplingMode:1,type:this._engine.getCaps().textureFloatLinearFiltering?1:2,label:"DepthPeelingRenderer-DepthTexture"},{format:5,samplingMode:1,type:2,label:"DepthPeelingRenderer-ColorTexture"}];for(let i=0;i<2;i++){const r=this._engine._createInternalTexture(e,t[0],!1),s=this._engine._createInternalTexture(e,t[1],!1),n=this._engine._createInternalTexture(e,t[1],!1);this._depthMrts[i].setInternalTexture(r,0),this._depthMrts[i].setInternalTexture(s,1),this._depthMrts[i].setInternalTexture(n,2),this._colorMrts[i].setInternalTexture(s,0),this._colorMrts[i].setInternalTexture(n,1),this._thinTextures.push(new Tl(r),new Tl(s),new Tl(n))}}_disposeTextures(){for(let e=0;e<this._thinTextures.length;e++)e!==6&&this._thinTextures[e].dispose();for(let e=0;e<2;e++)this._depthMrts[e].dispose(!0),this._colorMrts[e].dispose(!0),this._blendBackMrt.dispose(!0);this._outputRT.dispose(),this._thinTextures=[],this._colorMrts=[],this._depthMrts=[]}_updateTextures(){return(this._depthMrts[0].getSize().width!==this._engine.getRenderWidth()||this._depthMrts[0].getSize().height!==this._engine.getRenderHeight())&&(this._disposeTextures(),this._createTextures()),this._updateTextureReferences()}_updateTextureReferences(){var r;const e=this._scene.prePassRenderer;if(!e)return!1;const t=e.getIndex(4),i=(r=e.defaultRT.textures)!=null&&r.length?e.defaultRT.textures[t].getInternalTexture():null;return i?(this._blendBackTexture!==i&&(this._blendBackTexture=i,this._blendBackMrt.setInternalTexture(this._blendBackTexture,0),this._thinTextures[6]&&this._thinTextures[6].dispose(),this._thinTextures[6]=new Tl(this._blendBackTexture),e.defaultRT.renderTarget.shareDepth(this._depthMrts[0].renderTarget)),!0):!1}_createEffects(){this._blendBackEffectWrapper=new Qt({fragmentShader:"oitBackBlend",useShaderStore:!0,engine:this._engine,samplerNames:["uBackColor"],uniformNames:[],shaderLanguage:this._shaderLanguage,extraInitializationsAsync:async()=>{this._shaderLanguage===1?await k(()=>Promise.resolve().then(()=>zb),void 0):await k(()=>Promise.resolve().then(()=>kb),void 0)}}),this._blendBackEffectWrapperPingPong=new Qt({fragmentShader:"oitBackBlend",useShaderStore:!0,engine:this._engine,samplerNames:["uBackColor"],uniformNames:[],shaderLanguage:this._shaderLanguage,extraInitializationsAsync:async()=>{this._shaderLanguage===1?await k(()=>Promise.resolve().then(()=>zb),void 0):await k(()=>Promise.resolve().then(()=>kb),void 0)}}),this._finalEffectWrapper=new Qt({fragmentShader:"oitFinal",useShaderStore:!0,engine:this._engine,samplerNames:["uFrontColor","uBackColor"],uniformNames:[],shaderLanguage:this._shaderLanguage,extraInitializationsAsync:async()=>{this._shaderLanguage===1?await k(()=>Promise.resolve().then(()=>YG),void 0):await k(()=>Promise.resolve().then(()=>$G),void 0)}}),this._effectRenderer=new il(this._engine)}setPrePassRenderer(e){e.addEffectConfiguration(this._prePassEffectConfiguration)}bind(e){e.setTexture("oitDepthSampler",this._thinTextures[this._currentPingPongState*3]),e.setTexture("oitFrontColorSampler",this._thinTextures[this._currentPingPongState*3+1])}_renderSubMeshes(e){let t;this._useRenderPasses&&(t={});for(let i=0;i<e.length;i++){const r=e.data[i].getMaterial();let s=!0,n=!1;const o=e.data[i];let l,u=!1;if(this._useRenderPasses&&(l=o._getDrawWrapper(),u=!l),r&&(s=r.allowShaderHotSwapping,n=r.backFaceCulling,r.allowShaderHotSwapping=!1,r.backFaceCulling=!1),o.render(!1),u&&(l=o._getDrawWrapper(),l.materialContext)){let c=t[l.materialContext.uniqueId];c||(c=t[l.materialContext.uniqueId]=this._engine.createMaterialContext()),o._getDrawWrapper().materialContext=c}r&&(r.allowShaderHotSwapping=s,r.backFaceCulling=n)}}_finalCompose(e){var i;((i=this._scene.prePassRenderer)==null?void 0:i.setCustomOutput(this._outputRT))?this._engine.bindFramebuffer(this._outputRT.renderTarget):this._engine.restoreDefaultFramebuffer(),this._engine.setAlphaMode(0),this._engine.applyStates(),this._engine.enableEffect(this._finalEffectWrapper.drawWrapper),this._finalEffectWrapper.effect.setTexture("uFrontColor",this._thinTextures[e*3+1]),this._finalEffectWrapper.effect.setTexture("uBackColor",this._thinTextures[6]),this._effectRenderer.render(this._finalEffectWrapper)}isReady(){return this._blendBackEffectWrapper.effect.isReady()&&this._blendBackEffectWrapperPingPong.effect.isReady()&&this._finalEffectWrapper.effect.isReady()&&this._updateTextures()}render(e){if(this._candidateSubMeshes.length=0,this._excludedSubMeshes.length=0,!this.isReady())return this._excludedSubMeshes;this._scene.activeCamera&&this._engine.setViewport(this._scene.activeCamera.viewport);for(let s=0;s<e.length;s++){const n=e.data[s],o=n.getMaterial(),l=o&&n.getRenderingMesh()._getRenderingFillMode(o.fillMode);o&&(l===ft.TriangleFanDrawMode||l===ft.TriangleFillMode||l===ft.TriangleStripDrawMode)&&this._excludedMeshes.indexOf(n.getMesh().uniqueId)===-1?this._candidateSubMeshes.push(n):this._excludedSubMeshes.push(n)}if(!this._candidateSubMeshes.length)return this._engine.bindFramebuffer(this._colorMrts[1].renderTarget),this._engine.bindAttachments(this._layoutCache[1]),this._engine.clear(this._colorCache[2],!0,!1,!1),this._engine.unBindFramebuffer(this._colorMrts[1].renderTarget),this._finalCompose(1),this._excludedSubMeshes;const t=this._engine.currentRenderPassId;this._scene.prePassRenderer._enabled=!1,this._useRenderPasses&&(this._engine.currentRenderPassId=this._renderPassIds[0]),this._engine.bindFramebuffer(this._depthMrts[0].renderTarget),this._engine.bindAttachments(this._layoutCache[0]),this._engine.clear(this._colorCache[0],!0,!1,!1),this._engine.unBindFramebuffer(this._depthMrts[0].renderTarget),this._engine.bindFramebuffer(this._depthMrts[1].renderTarget),this._engine.bindAttachments(this._layoutCache[0]),this._engine.clear(this._colorCache[1],!0,!1,!1),this._engine.unBindFramebuffer(this._depthMrts[1].renderTarget),this._engine.bindFramebuffer(this._colorMrts[0].renderTarget),this._engine.bindAttachments(this._layoutCache[1]),this._engine.clear(this._colorCache[2],!0,!1,!1),this._engine.unBindFramebuffer(this._colorMrts[0].renderTarget),this._engine.bindFramebuffer(this._colorMrts[1].renderTarget),this._engine.bindAttachments(this._layoutCache[1]),this._engine.clear(this._colorCache[2],!0,!1,!1),this._engine.unBindFramebuffer(this._colorMrts[1].renderTarget),this._engine.bindFramebuffer(this._depthMrts[0].renderTarget),this._engine.bindAttachments(this._layoutCache[0]),this._engine.setAlphaMode(11),this._engine.setAlphaEquation(3),this._engine.depthCullingState.depthMask=!1,this._engine.depthCullingState.depthTest=!0,this._engine.applyStates(),this._currentPingPongState=1,this._renderSubMeshes(this._candidateSubMeshes),this._engine.unBindFramebuffer(this._depthMrts[0].renderTarget),this._scene.resetCachedMaterial();let i=0,r=0;for(let s=0;s<this._passCount;s++){i=s%2,r=1-i,this._currentPingPongState=i,this._useRenderPasses&&(this._engine.currentRenderPassId=this._renderPassIds[s+1]),this._scene.activeCamera&&this._engine.setViewport(this._scene.activeCamera.viewport),this._engine.bindFramebuffer(this._depthMrts[r].renderTarget),this._engine.bindAttachments(this._layoutCache[0]),this._engine.clear(this._colorCache[0],!0,!1,!1),this._engine.unBindFramebuffer(this._depthMrts[r].renderTarget),this._engine.bindFramebuffer(this._colorMrts[r].renderTarget),this._engine.bindAttachments(this._layoutCache[1]),this._engine.clear(this._colorCache[2],!0,!1,!1),this._engine.unBindFramebuffer(this._colorMrts[r].renderTarget),this._engine.bindFramebuffer(this._depthMrts[r].renderTarget),this._engine.bindAttachments(this._layoutCache[2]),this._engine.setAlphaMode(11),this._engine.setAlphaEquation(3),this._engine.depthCullingState.depthTest=!1,this._engine.applyStates(),this._renderSubMeshes(this._candidateSubMeshes),this._engine.unBindFramebuffer(this._depthMrts[r].renderTarget),this._scene.resetCachedMaterial(),this._engine.bindFramebuffer(this._blendBackMrt.renderTarget),this._engine.bindAttachments(this._layoutCache[0]),this._engine.setAlphaEquation(0),this._engine.setAlphaMode(17),this._engine.applyStates();const n=r===0||!this._useRenderPasses?this._blendBackEffectWrapper:this._blendBackEffectWrapperPingPong;this._engine.enableEffect(n.drawWrapper),n.effect.setTexture("uBackColor",this._thinTextures[r*3+2]),this._effectRenderer.render(n),this._engine.unBindFramebuffer(this._blendBackMrt.renderTarget)}return this._engine.currentRenderPassId=t,this._finalCompose(r),this._scene.prePassRenderer._enabled=!0,this._engine.depthCullingState.depthMask=!0,this._engine.depthCullingState.depthTest=!0,this._excludedSubMeshes}dispose(){this._disposeTextures(),this._blendBackEffectWrapper.dispose(),this._finalEffectWrapper.dispose(),this._effectRenderer.dispose(),this._releaseRenderPassIds()}}Es._DEPTH_CLEAR_VALUE=-99999;Es._MIN_DEPTH=0;Es._MAX_DEPTH=1;Object.defineProperty(Te.prototype,"depthPeelingRenderer",{get:function(){if(!this._depthPeelingRenderer){let a=this._getComponent(ge.NAME_DEPTHPEELINGRENDERER);a||(a=new iz(this),this._addComponent(a))}return this._depthPeelingRenderer},set:function(a){this._depthPeelingRenderer=a},enumerable:!0,configurable:!0});Object.defineProperty(Te.prototype,"useOrderIndependentTransparency",{get:function(){return this._useOrderIndependentTransparency},set:function(a){var e;this._useOrderIndependentTransparency!==a&&(this._useOrderIndependentTransparency=a,this.markAllMaterialsAsDirty(127),(e=this.prePassRenderer)==null||e.markAsDirty())},enumerable:!0,configurable:!0});class iz{constructor(e){this.name=ge.NAME_DEPTHPEELINGRENDERER,this.scene=e,e.depthPeelingRenderer=new Es(e)}register(){}rebuild(){}dispose(){var e;(e=this.scene.depthPeelingRenderer)==null||e.dispose(),this.scene.depthPeelingRenderer=null}}Rt.prototype.disableEdgesRendering=function(){return this._edgesRenderer&&(this._edgesRenderer.dispose(),this._edgesRenderer=null),this};Rt.prototype.enableEdgesRendering=function(a=.95,e=!1,t){return this.disableEdgesRendering(),this._edgesRenderer=new _c(this,a,e,!0,t),this};Object.defineProperty(Rt.prototype,"edgesRenderer",{get:function(){return this._edgesRenderer},enumerable:!0,configurable:!0});as.prototype.enableEdgesRendering=function(a=.95,e=!1){return this.disableEdgesRendering(),this._edgesRenderer=new sz(this,a,e),this};c0.prototype.enableEdgesRendering=function(a=.95,e=!1){return as.prototype.enableEdgesRendering.apply(this,arguments),this};class rz{constructor(){this.edges=[],this.edgesConnectedCount=0}}class _c{get linesPositions(){return this._linesPositions}get linesNormals(){return this._linesNormals}get linesIndices(){return this._linesIndices}get lineShader(){return this._lineShader}set lineShader(e){this._lineShader=e}static _GetShader(e,t){if(!e._edgeRenderLineShader){const i=new Wr("lineShader",e,"line",{attributes:["position","normal"],uniforms:["world","viewProjection","color","width","aspectRatio"],uniformBuffers:["Scene","Mesh"],shaderLanguage:t,extraInitializationsAsync:async()=>{t===1?await Promise.all([k(()=>Promise.resolve().then(()=>kU),void 0),k(()=>Promise.resolve().then(()=>BU),void 0)]):await Promise.all([k(()=>Promise.resolve().then(()=>FU),void 0),k(()=>Promise.resolve().then(()=>DU),void 0)])}},!1);i.disableDepthWrite=!0,i.backFaceCulling=!1,i.checkReadyOnEveryCall=e.getEngine().isWebGPU,e._edgeRenderLineShader=i,e.onDisposeObservable.add(()=>{e._edgeRenderLineShader.dispose(),e._edgeRenderLineShader=null})}return e._edgeRenderLineShader}get shaderLanguage(){return this._shaderLanguage}constructor(e,t=.95,i=!1,r=!0,s){this.edgesWidthScalerForOrthographic=1e3,this.edgesWidthScalerForPerspective=50,this._linesPositions=new Array,this._linesNormals=new Array,this._linesIndices=new Array,this._buffers={},this._buffersForInstances={},this._checkVerticesInsteadOfIndices=!1,this.isEnabled=!0,this.customInstances=new Go(32),this._shaderLanguage=0,this._source=e,this._checkVerticesInsteadOfIndices=i,this._options=s??null,this._epsilon=t;const n=this._source.getScene().getEngine();n.isWebGPU&&(this._drawWrapper=new vi(n),this._shaderLanguage=1),this._prepareRessources(),r&&((s==null?void 0:s.useAlternateEdgeFinder)??!0?this._generateEdgesLinesAlternate():this._generateEdgesLines()),this._meshRebuildObserver=this._source.onRebuildObservable.add(()=>{this._rebuild()}),this._meshDisposeObserver=this._source.onDisposeObservable.add(()=>{this.dispose()})}_prepareRessources(){this._lineShader||(this._lineShader=_c._GetShader(this._source.getScene(),this._shaderLanguage))}_rebuild(){let e=this._buffers[N.PositionKind];e&&e._rebuild(),e=this._buffers[N.NormalKind],e&&e._rebuild();const i=this._source.getScene().getEngine();this._ib=i.createIndexBuffer(this._linesIndices)}dispose(){var t;this._source.onRebuildObservable.remove(this._meshRebuildObserver),this._source.onDisposeObservable.remove(this._meshDisposeObserver);let e=this._buffers[N.PositionKind];e&&(e.dispose(),this._buffers[N.PositionKind]=null),e=this._buffers[N.NormalKind],e&&(e.dispose(),this._buffers[N.NormalKind]=null),this._ib&&this._source.getScene().getEngine()._releaseBuffer(this._ib),(t=this._drawWrapper)==null||t.dispose()}_processEdgeForAdjacencies(e,t,i,r,s){return e===i&&t===r||e===r&&t===i?0:e===r&&t===s||e===s&&t===r?1:e===s&&t===i||e===i&&t===s?2:-1}_processEdgeForAdjacenciesWithVertices(e,t,i,r,s){return e.equalsWithEpsilon(i,1e-10)&&t.equalsWithEpsilon(r,1e-10)||e.equalsWithEpsilon(r,1e-10)&&t.equalsWithEpsilon(i,1e-10)?0:e.equalsWithEpsilon(r,1e-10)&&t.equalsWithEpsilon(s,1e-10)||e.equalsWithEpsilon(s,1e-10)&&t.equalsWithEpsilon(r,1e-10)?1:e.equalsWithEpsilon(s,1e-10)&&t.equalsWithEpsilon(i,1e-10)||e.equalsWithEpsilon(i,1e-10)&&t.equalsWithEpsilon(s,1e-10)?2:-1}_checkEdge(e,t,i,r,s){let n;t===void 0?n=!0:n=m.Dot(i[e],i[t])<this._epsilon,n&&this.createLine(r,s,this._linesPositions.length/3)}createLine(e,t,i){this._linesPositions.push(e.x,e.y,e.z,e.x,e.y,e.z,t.x,t.y,t.z,t.x,t.y,t.z),this._linesNormals.push(t.x,t.y,t.z,-1,t.x,t.y,t.z,1,e.x,e.y,e.z,-1,e.x,e.y,e.z,1),this._linesIndices.push(i,i+1,i+2,i,i+2,i+3)}_tessellateTriangle(e,t,i,r){const s=(O,w,M)=>{M>=0&&w.push(M);for(let G=0;G<O.length;++G)w.push(O[G][0])};let n=0;e[1].length>=e[0].length&&e[1].length>=e[2].length?n=1:e[2].length>=e[0].length&&e[2].length>=e[1].length&&(n=2);for(let O=0;O<3;++O)O===n?e[O].sort((w,M)=>w[1]<M[1]?-1:w[1]>M[1]?1:0):e[O].sort((w,M)=>w[1]>M[1]?-1:w[1]<M[1]?1:0);const o=[],l=[];s(e[n],o,-1);const u=o.length;for(let O=n+2;O>=n+1;--O)s(e[O%3],l,O!==n+2?r[i[t+(O+1)%3]]:-1);const c=l.length,h=0,d=0;i.push(r[i[t+n]],o[0],l[0]),i.push(r[i[t+(n+1)%3]],l[c-1],o[u-1]);const f=u<=c,p=f?u:c,g=f?c:u,_=f?u-1:c-1,S=f?0:1;let b=u+c-2,y=f?h:d,T=f?d:h;const v=f?o:l,E=f?l:o;let R=0;for(;b-- >0;){S?i.push(v[y],E[T]):i.push(E[T],v[y]),R+=p;let O;R>=g&&y<_?(O=v[++y],R-=g):O=E[++T],i.push(O)}i[t+0]=i[i.length-3],i[t+1]=i[i.length-2],i[t+2]=i[i.length-1],i.length=i.length-3}_generateEdgesLinesAlternate(){var u,c,h,d,f,p;const e=this._source.getVerticesData(N.PositionKind);let t=this._source.getIndices();if(!t||!e)return;Array.isArray(t)||(t=Array.from(t));const i=((u=this._options)==null?void 0:u.useFastVertexMerger)??!0,r=i?Math.round(-Math.log(((c=this._options)==null?void 0:c.epsilonVertexMerge)??1e-6)/Math.log(10)):((h=this._options)==null?void 0:h.epsilonVertexMerge)??1e-6,s=[],n=[];if(i){const g={};for(let _=0;_<e.length;_+=3){const S=e[_+0],b=e[_+1],y=e[_+2],T=S.toFixed(r)+"|"+b.toFixed(r)+"|"+y.toFixed(r);if(g[T]!==void 0)s.push(g[T]);else{const v=_/3;g[T]=v,s.push(v),n.push(v)}}}else for(let g=0;g<e.length;g+=3){const _=e[g+0],S=e[g+1],b=e[g+2];let y=!1;for(let T=0;T<g&&!y;T+=3){const v=e[T+0],E=e[T+1],R=e[T+2];if(Math.abs(_-v)<r&&Math.abs(S-E)<r&&Math.abs(b-R)<r){s.push(T/3),y=!0;break}}y||(s.push(g/3),n.push(g/3))}if((d=this._options)!=null&&d.applyTessellation){const g=((f=this._options)==null?void 0:f.epsilonVertexAligned)??1e-6,_=[];for(let S=0;S<t.length;S+=3){let b;for(let y=0;y<3;++y){const T=s[t[S+y]],v=s[t[S+(y+1)%3]],E=s[t[S+(y+2)%3]];if(T===v)continue;const R=e[T*3+0],O=e[T*3+1],w=e[T*3+2],M=e[v*3+0],G=e[v*3+1],H=e[v*3+2],q=Math.sqrt((M-R)*(M-R)+(G-O)*(G-O)+(H-w)*(H-w));for(let X=0;X<n.length-1;X++){const ee=n[X];if(ee===T||ee===v||ee===E)continue;const oe=e[ee*3+0],_e=e[ee*3+1],te=e[ee*3+2],ie=Math.sqrt((oe-R)*(oe-R)+(_e-O)*(_e-O)+(te-w)*(te-w)),Z=Math.sqrt((oe-M)*(oe-M)+(_e-G)*(_e-G)+(te-H)*(te-H));Math.abs(ie+Z-q)<g&&(b||(b={index:S,edgesPoints:[[],[],[]]},_.push(b)),b.edgesPoints[y].push([ee,ie]))}}}for(let S=0;S<_.length;++S){const b=_[S];this._tessellateTriangle(b.edgesPoints,b.index,t,s)}_.length=0}const o={};for(let g=0;g<t.length;g+=3){let _;for(let S=0;S<3;++S){let b=s[t[g+S]],y=s[t[g+(S+1)%3]];const T=s[t[g+(S+2)%3]];if(b===y||(b===T||y===T)&&((p=this._options)!=null&&p.removeDegeneratedTriangles))continue;if(V.Vector3[0].copyFromFloats(e[b*3+0],e[b*3+1],e[b*3+2]),V.Vector3[1].copyFromFloats(e[y*3+0],e[y*3+1],e[y*3+2]),V.Vector3[2].copyFromFloats(e[T*3+0],e[T*3+1],e[T*3+2]),_||(V.Vector3[1].subtractToRef(V.Vector3[0],V.Vector3[3]),V.Vector3[2].subtractToRef(V.Vector3[1],V.Vector3[4]),_=m.Cross(V.Vector3[3],V.Vector3[4]),_.normalize()),b>y){const R=b;b=y,y=R}const v=b+"_"+y,E=o[v];E?E.done||(m.Dot(_,E.normal)<this._epsilon&&this.createLine(V.Vector3[0],V.Vector3[1],this._linesPositions.length/3),E.done=!0):o[v]={normal:_,done:!1,index:g,i:S}}}for(const g in o){const _=o[g];if(!_.done){const S=s[t[_.index+_.i]],b=s[t[_.index+(_.i+1)%3]];V.Vector3[0].copyFromFloats(e[S*3+0],e[S*3+1],e[S*3+2]),V.Vector3[1].copyFromFloats(e[b*3+0],e[b*3+1],e[b*3+2]),this.createLine(V.Vector3[0],V.Vector3[1],this._linesPositions.length/3)}}const l=this._source.getScene().getEngine();this._buffers[N.PositionKind]=new N(l,this._linesPositions,N.PositionKind,!1),this._buffers[N.NormalKind]=new N(l,this._linesNormals,N.NormalKind,!1,!1,4),this._buffersForInstances[N.PositionKind]=this._buffers[N.PositionKind],this._buffersForInstances[N.NormalKind]=this._buffers[N.NormalKind],this._ib=l.createIndexBuffer(this._linesIndices),this._indicesCount=this._linesIndices.length}_generateEdgesLines(){const e=this._source.getVerticesData(N.PositionKind),t=this._source.getIndices();if(!t||!e)return;const i=[],r=[];let s,n;for(s=0;s<t.length;s+=3){n=new rz;const l=t[s],u=t[s+1],c=t[s+2];n.p0=new m(e[l*3],e[l*3+1],e[l*3+2]),n.p1=new m(e[u*3],e[u*3+1],e[u*3+2]),n.p2=new m(e[c*3],e[c*3+1],e[c*3+2]);const h=m.Cross(n.p1.subtract(n.p0),n.p2.subtract(n.p1));h.normalize(),r.push(h),i.push(n)}for(s=0;s<i.length;s++){n=i[s];for(let l=s+1;l<i.length;l++){const u=i[l];if(n.edgesConnectedCount===3)break;if(u.edgesConnectedCount===3)continue;const c=t[l*3],h=t[l*3+1],d=t[l*3+2];for(let f=0;f<3;f++){let p=0;if(n.edges[f]===void 0){switch(f){case 0:this._checkVerticesInsteadOfIndices?p=this._processEdgeForAdjacenciesWithVertices(n.p0,n.p1,u.p0,u.p1,u.p2):p=this._processEdgeForAdjacencies(t[s*3],t[s*3+1],c,h,d);break;case 1:this._checkVerticesInsteadOfIndices?p=this._processEdgeForAdjacenciesWithVertices(n.p1,n.p2,u.p0,u.p1,u.p2):p=this._processEdgeForAdjacencies(t[s*3+1],t[s*3+2],c,h,d);break;case 2:this._checkVerticesInsteadOfIndices?p=this._processEdgeForAdjacenciesWithVertices(n.p2,n.p0,u.p0,u.p1,u.p2):p=this._processEdgeForAdjacencies(t[s*3+2],t[s*3],c,h,d);break}if(p!==-1&&(n.edges[f]=l,u.edges[p]=s,n.edgesConnectedCount++,u.edgesConnectedCount++,n.edgesConnectedCount===3))break}}}}for(s=0;s<i.length;s++){const l=i[s];this._checkEdge(s,l.edges[0],r,l.p0,l.p1),this._checkEdge(s,l.edges[1],r,l.p1,l.p2),this._checkEdge(s,l.edges[2],r,l.p2,l.p0)}const o=this._source.getScene().getEngine();this._buffers[N.PositionKind]=new N(o,this._linesPositions,N.PositionKind,!1),this._buffers[N.NormalKind]=new N(o,this._linesNormals,N.NormalKind,!1,!1,4),this._buffersForInstances[N.PositionKind]=this._buffers[N.PositionKind],this._buffersForInstances[N.NormalKind]=this._buffers[N.NormalKind],this._ib=o.createIndexBuffer(this._linesIndices),this._indicesCount=this._linesIndices.length}isReady(){return this._lineShader.isReady(this._source,this._source.hasInstances&&this.customInstances.length>0||this._source.hasThinInstances)}render(){const e=this._source.getScene(),t=this._lineShader._getDrawWrapper();if(this._drawWrapper&&this._lineShader._setDrawWrapper(this._drawWrapper),!this.isReady()||!e.activeCamera){this._lineShader._setDrawWrapper(t);return}const i=this._source.hasInstances&&this.customInstances.length>0,r=i||this._source.hasThinInstances;let s=0;if(r)if(this._buffersForInstances.world0=this._source.getVertexBuffer("world0"),this._buffersForInstances.world1=this._source.getVertexBuffer("world1"),this._buffersForInstances.world2=this._source.getVertexBuffer("world2"),this._buffersForInstances.world3=this._source.getVertexBuffer("world3"),i){const o=this._source._instanceDataStorage;if(s=this.customInstances.length,!o.instancesData){this._source.getScene()._activeMeshesFrozen||this.customInstances.reset();return}if(!o.isFrozen){let l=0;for(let u=0;u<s;++u)this.customInstances.data[u].copyToArray(o.instancesData,l),l+=16;o.instancesBuffer.updateDirectly(o.instancesData,0,s)}}else s=this._source.thinInstanceCount;const n=e.getEngine();this._lineShader._preBind(),this._source.edgesColor.a!==1?n.setAlphaMode(2):n.setAlphaMode(0),n.bindBuffers(r?this._buffersForInstances:this._buffers,this._ib,this._lineShader.getEffect()),e.resetCachedMaterial(),this._lineShader.setColor4("color",this._source.edgesColor),e.activeCamera.mode===Ze.ORTHOGRAPHIC_CAMERA?this._lineShader.setFloat("width",this._source.edgesWidth/this.edgesWidthScalerForOrthographic):this._lineShader.setFloat("width",this._source.edgesWidth/this.edgesWidthScalerForPerspective),this._lineShader.setFloat("aspectRatio",n.getAspectRatio(e.activeCamera)),this._lineShader.bind(this._source.getWorldMatrix(),this._source),n.drawElementsType(ft.TriangleFillMode,0,this._indicesCount,s),this._lineShader.unbind(),r&&n.unbindInstanceAttributes(),this._source.getScene()._activeMeshesFrozen||this.customInstances.reset(),this._lineShader._setDrawWrapper(t)}}class sz extends _c{constructor(e,t=.95,i=!1){super(e,t,i,!1),this._generateEdgesLines()}_generateEdgesLines(){const e=this._source.getVerticesData(N.PositionKind),t=this._source.getIndices();if(!t||!e)return;const i=V.Vector3[0],r=V.Vector3[1],s=t.length-1;for(let o=0,l=0;o<s;o+=2,l+=4)m.FromArrayToRef(e,3*t[o],i),m.FromArrayToRef(e,3*t[o+1],r),this.createLine(i,r,l);const n=this._source.getScene().getEngine();this._buffers[N.PositionKind]=new N(n,this._linesPositions,N.PositionKind,!1),this._buffers[N.NormalKind]=new N(n,this._linesNormals,N.NormalKind,!1,!1,4),this._ib=n.createIndexBuffer(this._linesIndices),this._indicesCount=this._linesIndices.length}}Object.defineProperty(Te.prototype,"iblCdfGenerator",{get:function(){return this._iblCdfGenerator},set:function(a){a&&(this._iblCdfGenerator=a)},enumerable:!0,configurable:!0});Te.prototype.enableIblCdfGenerator=function(){return this._iblCdfGenerator?this._iblCdfGenerator:(this._iblCdfGenerator=new $n(this),this.environmentTexture&&(this._iblCdfGenerator.iblSource=this.environmentTexture),this._iblCdfGenerator)};Te.prototype.disableIblCdfGenerator=function(){this._iblCdfGenerator&&(this._iblCdfGenerator.dispose(),this._iblCdfGenerator=null)};class nz{constructor(e){this.name=ge.NAME_IBLCDFGENERATOR,this._newIblObserver=null,this.scene=e}register(){this._updateIblSource(),this._newIblObserver=this.scene.onEnvironmentTextureChangedObservable.add(this._updateIblSource.bind(this))}rebuild(){}dispose(){this.scene.onEnvironmentTextureChangedObservable.remove(this._newIblObserver)}_updateIblSource(){this.scene.iblCdfGenerator&&this.scene.environmentTexture&&(this.scene.iblCdfGenerator.iblSource=this.scene.environmentTexture)}}$n._SceneComponentInitialization=a=>{let e=a._getComponent(ge.NAME_IBLCDFGENERATOR);e||(e=new nz(a),a._addComponent(e))};class az extends ps{constructor(){super(...arguments),this.RENDER_WITH_IBL_SHADOWS=!1,this.COLORED_IBL_SHADOWS=!1}}class na extends Qn{get isColored(){return this._isColored}set isColored(e){this._isColored!==e&&(this._isColored=e,this._markAllSubMeshesAsTexturesDirty())}_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}isCompatible(){return!0}constructor(e){super(e,na.Name,310,new az),this.shadowOpacity=1,this._isEnabled=!1,this._isColored=!1,this.isEnabled=!1,this._internalMarkAllSubMeshesAsTexturesDirty=e._dirtyCallbacks[1]}prepareDefines(e){e.RENDER_WITH_IBL_SHADOWS=this._isEnabled,e.COLORED_IBL_SHADOWS=this.isColored}getClassName(){return"IBLShadowsPluginMaterial"}getUniforms(){return{ubo:[{name:"renderTargetSize",size:2,type:"vec2"},{name:"shadowOpacity",size:1,type:"float"}],fragment:`#ifdef RENDER_WITH_IBL_SHADOWS
                    uniform vec2 renderTargetSize;
                    uniform float shadowOpacity;
                #endif`}}getSamplers(e){e.push("iblShadowsTexture")}bindForSubMesh(e){this._isEnabled&&(e.bindTexture("iblShadowsTexture",this.iblShadowsTexture),e.updateFloat2("renderTargetSize",this._material.getScene().getEngine().getRenderWidth(),this._material.getScene().getEngine().getRenderHeight()),e.updateFloat("shadowOpacity",this.shadowOpacity))}getCustomCode(e,t){let i;return t===1?(i={CUSTOM_FRAGMENT_DEFINITIONS:`
                #ifdef RENDER_WITH_IBL_SHADOWS
                    var iblShadowsTextureSampler: sampler;
                    var iblShadowsTexture: texture_2d<f32>;

                    #ifdef COLORED_IBL_SHADOWS
                        fn computeIndirectShadow() -> vec3f {
                            var uv = fragmentInputs.position.xy / uniforms.renderTargetSize;
                            var shadowValue: vec3f = textureSample(iblShadowsTexture, iblShadowsTextureSampler, uv).rgb;
                            return mix(shadowValue, vec3f(1.0), 1.0 - uniforms.shadowOpacity);
                        }
                    #else
                        fn computeIndirectShadow() -> vec2f {
                            var uv = fragmentInputs.position.xy / uniforms.renderTargetSize;
                            var shadowValue: vec2f = textureSample(iblShadowsTexture, iblShadowsTextureSampler, uv).rg;
                            return mix(shadowValue, vec2f(1.0), 1.0 - uniforms.shadowOpacity);
                        }
                    #endif
                #endif
            `},this._material instanceof hr?i.CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION=`
                #ifdef RENDER_WITH_IBL_SHADOWS
                    #ifndef UNLIT
                        #ifdef REFLECTION
                            #ifdef COLORED_IBL_SHADOWS
                                var shadowValue: vec3f = computeIndirectShadow();
                                finalIrradiance *= shadowValue;
                                finalRadianceScaled *= mix(vec3f(1.0), shadowValue, roughness);
                            #else
                                var shadowValue: vec2f = computeIndirectShadow();
                                finalIrradiance *= vec3f(shadowValue.x);
                                finalRadianceScaled *= vec3f(mix(pow(shadowValue.y, 4.0), shadowValue.x, roughness));
                            #endif
                        #endif
                    #else
                        finalDiffuse *= computeIndirectShadow().x;
                    #endif
                #endif
            `:i.CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR=`
                #ifdef RENDER_WITH_IBL_SHADOWS
                    #ifdef COLORED_IBL_SHADOWS
                        var shadowValue: vec3f = computeIndirectShadow();
                        color *= toGammaSpace(vec4f(shadowValue, 1.0f));
                    #else
                        var shadowValue: vec2f = computeIndirectShadow();
                        color *= toGammaSpace(vec4f(shadowValue.x, shadowValue.x, shadowValue.x, 1.0f));
                    #endif
                #endif
            `):(i={CUSTOM_FRAGMENT_DEFINITIONS:`
                #ifdef RENDER_WITH_IBL_SHADOWS
                    uniform sampler2D iblShadowsTexture;
                #ifdef COLORED_IBL_SHADOWS
                    vec3 computeIndirectShadow() {
                        vec2 uv = gl_FragCoord.xy / renderTargetSize;
                        vec3 shadowValue = texture2D(iblShadowsTexture, uv).rgb;
                        return mix(shadowValue.rgb, vec3(1.0), 1.0 - shadowOpacity);
                    }
                #else
                    vec2 computeIndirectShadow() {
                        vec2 uv = gl_FragCoord.xy / renderTargetSize;
                        vec2 shadowValue = texture2D(iblShadowsTexture, uv).rg;
                        return mix(shadowValue.rg, vec2(1.0), 1.0 - shadowOpacity);
                    }
                #endif
                #endif
            `},this._material instanceof hr?i.CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION=`
                #ifdef RENDER_WITH_IBL_SHADOWS
                    #ifndef UNLIT
                        #ifdef REFLECTION
                            #ifdef COLORED_IBL_SHADOWS
                                vec3 shadowValue = computeIndirectShadow();
                                finalIrradiance.rgb *= shadowValue.rgb;
                                finalRadianceScaled *= mix(vec3(1.0), shadowValue.rgb, roughness);
                            #else
                                vec2 shadowValue = computeIndirectShadow();
                                finalIrradiance *= shadowValue.x;
                                finalRadianceScaled *= mix(pow(shadowValue.y, 4.0), shadowValue.x, roughness);
                            #endif
                        #endif
                    #else
                        finalDiffuse *= computeIndirectShadow().x;
                    #endif
                #endif
            `:i.CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR=`
                #ifdef RENDER_WITH_IBL_SHADOWS
                    #ifdef COLORED_IBL_SHADOWS
                        vec3 shadowValue = computeIndirectShadow();
                        color.rgb *= toGammaSpace(shadowValue.rgb);
                    #else
                        vec2 shadowValue = computeIndirectShadow();
                        color.rgb *= toGammaSpace(shadowValue.x);
                    #endif
                #endif
            `),e==="vertex"?null:i}}na.Name="IBLShadowsPluginMaterial";C([F()],na.prototype,"iblShadowsTexture",void 0);C([F()],na.prototype,"shadowOpacity",void 0);C([F(),Ue("_markAllSubMeshesAsTexturesDirty")],na.prototype,"isEnabled",void 0);B("BABYLON.IBLShadowsPluginMaterial",na);class oz extends Zs{constructor(e,t,i,r,s,n){super(e,i,r,s,n),this._beforeCompositionPostProcesses=[],this._internalTextureDirty=!1,this.enabled=!1,this.renderTargetTexture=null,this.renderTargetTexture=t}_createCompositionEffect(){this.imageProcessingPostProcess=new rg("prePassComposition",1,null,void 0,this._engine),this.imageProcessingPostProcess._updateParameters()}_checkSize(){const e=this._engine.getRenderWidth(!0),t=this._engine.getRenderHeight(!0),i=this.getRenderWidth(),r=this.getRenderHeight();(i!==e||r!==t)&&(this.resize({width:e,height:t}),this._internalTextureDirty=!0)}updateCount(e,t,i){super.updateCount(e,t,i),this._internalTextureDirty=!0}_resetPostProcessChain(){this._beforeCompositionPostProcesses.length=0}dispose(){const e=this._scene;if(super.dispose(),e&&e.prePassRenderer){const t=e.prePassRenderer.renderTargets.indexOf(this);t!==-1&&e.prePassRenderer.renderTargets.splice(t,1)}this.imageProcessingPostProcess&&this.imageProcessingPostProcess.dispose(),this.renderTargetTexture&&(this.renderTargetTexture._prePassRenderTarget=null),this._outputPostProcess&&(this._outputPostProcess.autoClear=!0,this._outputPostProcess.restoreDefaultInputTexture())}}class di{get generateNormalsInWorldSpace(){return this._generateNormalsInWorldSpace}set generateNormalsInWorldSpace(e){this._generateNormalsInWorldSpace!==e&&(this._generateNormalsInWorldSpace=e,this._markAllMaterialsAsPrePassDirty())}getIndex(e){return this._textureIndices[e]}get samples(){return this.defaultRT.samples}set samples(e){this.defaultRT.samples=e}get useSpecificClearForDepthTexture(){return this._useSpecificClearForDepthTexture}set useSpecificClearForDepthTexture(e){this._useSpecificClearForDepthTexture!==e&&(this._useSpecificClearForDepthTexture=e,this._isDirty=!0)}getRenderTarget(){return this._currentTarget}_setRenderTarget(e){var t;e?this._currentTarget=e:(this._currentTarget=this.defaultRT,this._engine.currentRenderPassId=((t=this._scene.activeCamera)==null?void 0:t.renderPassId)??this._currentTarget.renderPassId)}get currentRTisSceneRT(){return this._currentTarget===this.defaultRT}_refreshGeometryBufferRendererLink(){if(this.doNotUseGeometryRendererFallback)this._geometryBuffer&&this._geometryBuffer._unlinkPrePassRenderer(),this._geometryBuffer=null,this._scene.disableGeometryBufferRenderer();else{if(this._geometryBuffer=this._scene.enableGeometryBufferRenderer(),!this._geometryBuffer){this.doNotUseGeometryRendererFallback=!0;return}this._geometryBuffer._linkPrePassRenderer(this)}}get enabled(){return this._enabled}constructor(e){this.excludedSkinnedMesh=[],this.excludedMaterials=[],this.mrtCount=0,this._mrtTypes=[],this._mrtFormats=[],this._mrtLayout=[],this._mrtNames=[],this._textureIndices=[],this._generateNormalsInWorldSpace=!1,this._useSpecificClearForDepthTexture=!1,this._isDirty=!0,this._effectConfigurations=[],this.doNotUseGeometryRendererFallback=!0,this.renderTargets=[],this._clearColor=new xe(0,0,0,0),this._clearDepthColor=new xe(1e8,0,0,1),this._enabled=!1,this._needsCompositionForThisPass=!1,this.disableGammaTransform=!1,this._scene=e,this._engine=e.getEngine();let t=0;this._engine._caps.textureFloat&&this._engine._caps.textureFloatLinearFiltering?t=1:this._engine._caps.textureHalfFloat&&this._engine._caps.textureHalfFloatLinearFiltering&&(t=2);for(let i=0;i<di.TextureFormats.length;++i){const r=di.TextureFormats[i].format;di.TextureFormats[i].type===1&&(di.TextureFormats[i].type=t,t===1&&(r===6||r===7||r===5)&&!this._engine._caps.supportFloatTexturesResolve&&(di.TextureFormats[i].type=2))}di._SceneComponentInitialization(this._scene),this.defaultRT=this._createRenderTarget("sceneprePassRT",null),this._currentTarget=this.defaultRT}_createRenderTarget(e,t){const i=new oz(e,t,{width:this._engine.getRenderWidth(),height:this._engine.getRenderHeight()},0,this._scene,{generateMipMaps:!1,generateStencilBuffer:this._engine.isStencilEnable,defaultType:0,types:[],drawOnlyOnFirstAttachmentByDefault:!0});return this.renderTargets.push(i),this._enabled&&this._update(),i}get isSupported(){return this._scene.getEngine().getCaps().drawBuffersExtension}bindAttachmentsForEffect(e,t){const i=t.getMaterial(),r=i&&i.isPrePassCapable,s=i&&this.excludedMaterials.indexOf(i)!==-1;this.enabled&&this._currentTarget.enabled&&(e._multiTarget&&r&&!s?this._engine.bindAttachments(this._multiRenderAttachments):(this._engine._currentRenderTarget?this._engine.bindAttachments(this._defaultAttachments):this._engine.restoreSingleAttachment(),this._geometryBuffer&&this.currentRTisSceneRT&&!s&&this._geometryBuffer.renderList.push(t.getRenderingMesh())))}_reinitializeAttachments(){const e=[],t=[!1],i=[!1],r=[!0];for(let s=0;s<this.mrtCount;s++)e.push(!0),s>0&&(this._useSpecificClearForDepthTexture&&this._mrtLayout[s]===5?(t.push(!1),i.push(!0)):(t.push(!0),i.push(!1)),r.push(!1));this._multiRenderAttachments=this._engine.buildTextureLayout(e),this._clearAttachments=this._engine.buildTextureLayout(t),this._clearDepthAttachments=this._engine.buildTextureLayout(i),this._defaultAttachments=this._engine.buildTextureLayout(r)}_resetLayout(){for(let e=0;e<di.TextureFormats.length;e++)this._textureIndices[di.TextureFormats[e].purpose]=-1;this._textureIndices[4]=0,this._mrtLayout=[4],this._mrtTypes=[di.TextureFormats[4].type],this._mrtFormats=[di.TextureFormats[4].format],this._mrtNames=[di.TextureFormats[4].name],this.mrtCount=1}_updateGeometryBufferLayout(){if(this._refreshGeometryBufferRendererLink(),this._geometryBuffer){this._geometryBuffer._resetLayout();const e=[];for(let i=0;i<this._mrtLayout.length;i++)e.push(!1);this._geometryBuffer._linkInternalTexture(this.defaultRT.getInternalTexture());const t=[{prePassConstant:5,geometryBufferConstant:Re.DEPTH_TEXTURE_TYPE},{prePassConstant:6,geometryBufferConstant:Re.NORMAL_TEXTURE_TYPE},{prePassConstant:1,geometryBufferConstant:Re.POSITION_TEXTURE_TYPE},{prePassConstant:3,geometryBufferConstant:Re.REFLECTIVITY_TEXTURE_TYPE},{prePassConstant:2,geometryBufferConstant:Re.VELOCITY_TEXTURE_TYPE}];for(let i=0;i<t.length;i++){const r=this._mrtLayout.indexOf(t[i].prePassConstant);r!==-1&&(this._geometryBuffer._forceTextureType(t[i].geometryBufferConstant,r),e[r]=!0)}this._geometryBuffer._setAttachments(this._engine.buildTextureLayout(e))}}restoreAttachments(){this.enabled&&this._currentTarget.enabled&&this._defaultAttachments&&(this._engine._currentRenderTarget?this._engine.bindAttachments(this._defaultAttachments):this._engine.restoreSingleAttachment())}_beforeDraw(e,t,i){this._isDirty&&this._update(),!(!this._enabled||!this._currentTarget.enabled)&&(this._geometryBuffer&&(this._geometryBuffer.renderList=[]),this._setupOutputForThisPass(this._currentTarget,e))}_prepareFrame(e,t,i){e.renderTargetTexture?e.renderTargetTexture._prepareFrame(this._scene,t,i,e.renderTargetTexture.useCameraPostProcesses):this._postProcessesSourceForThisPass.length?this._scene.postProcessManager._prepareFrame():this._engine.restoreDefaultFramebuffer()}setCustomOutput(e){const t=this._postProcessesSourceForThisPass[0];return t?(t.inputTexture=e.renderTarget,!0):!1}_renderPostProcesses(e,t){var n;const i=this._postProcessesSourceForThisPass[0],r=i?i.inputTexture:e.renderTargetTexture?e.renderTargetTexture.renderTarget:null;let s=this._currentTarget._beforeCompositionPostProcesses;this._needsCompositionForThisPass&&(s=s.concat([this._currentTarget.imageProcessingPostProcess])),s.length&&(this._scene.postProcessManager._prepareFrame((n=this._currentTarget.renderTarget)==null?void 0:n.texture,s),this._scene.postProcessManager.directRender(s,r,!1,t))}_afterDraw(e,t){this._enabled&&this._currentTarget.enabled&&(this._prepareFrame(this._currentTarget,e,t),this._renderPostProcesses(this._currentTarget,e))}_clear(){this._isDirty&&this._update(),this._enabled&&this._currentTarget.enabled&&(this._bindFrameBuffer(),this._engine.bindAttachments(this._clearAttachments),this._engine.clear(this._clearColor,!0,!1,!1),this._useSpecificClearForDepthTexture&&(this._engine.bindAttachments(this._clearDepthAttachments),this._engine.clear(this._clearDepthColor,!0,!1,!1)),this._engine.bindAttachments(this._defaultAttachments))}_bindFrameBuffer(){if(this._enabled&&this._currentTarget.enabled){this._currentTarget._checkSize();const e=this._currentTarget.renderTarget;e&&this._engine.bindFramebuffer(e)}}_setEnabled(e){this._enabled=e}_setRenderTargetEnabled(e,t){e.enabled=t,t||this._unlinkInternalTexture(e)}addEffectConfiguration(e){for(let t=0;t<this._effectConfigurations.length;t++)if(this._effectConfigurations[t].name===e.name)return this._effectConfigurations[t];return this._effectConfigurations.push(e),e}getEffectConfiguration(e){for(let t=0;t<this._effectConfigurations.length;t++)if(this._effectConfigurations[t].name===e)return this._effectConfigurations[t];return null}_enable(){const e=this.mrtCount;for(let t=0;t<this._effectConfigurations.length;t++)this._effectConfigurations[t].enabled&&this._enableTextures(this._effectConfigurations[t].texturesRequired);for(let t=0;t<this.renderTargets.length;t++){(this.mrtCount!==e||this.renderTargets[t].count!==this.mrtCount)&&this.renderTargets[t].updateCount(this.mrtCount,{types:this._mrtTypes,formats:this._mrtFormats},this._mrtNames.concat("prePass_DepthBuffer")),this.renderTargets[t]._resetPostProcessChain();for(let i=0;i<this._effectConfigurations.length;i++)this._effectConfigurations[i].enabled&&(!this._effectConfigurations[i].postProcess&&this._effectConfigurations[i].createPostProcess&&this._effectConfigurations[i].createPostProcess(),this._effectConfigurations[i].postProcess&&this.renderTargets[t]._beforeCompositionPostProcesses.push(this._effectConfigurations[i].postProcess))}this._reinitializeAttachments(),this._setEnabled(!0),this._updateGeometryBufferLayout()}_disable(){this._setEnabled(!1);for(let e=0;e<this.renderTargets.length;e++)this._setRenderTargetEnabled(this.renderTargets[e],!1);this._resetLayout();for(let e=0;e<this._effectConfigurations.length;e++)this._effectConfigurations[e].enabled=!1}_getPostProcessesSource(e,t){if(t)return t._postProcesses;if(e.renderTargetTexture)if(e.renderTargetTexture.useCameraPostProcesses){const i=e.renderTargetTexture.activeCamera?e.renderTargetTexture.activeCamera:this._scene.activeCamera;return i?i._postProcesses:[]}else return e.renderTargetTexture.postProcesses?e.renderTargetTexture.postProcesses:[];else return this._scene.activeCamera?this._scene.activeCamera._postProcesses:[]}_setupOutputForThisPass(e,t){const i=t&&this._scene.activeCameras&&!!this._scene.activeCameras.length&&this._scene.activeCameras.indexOf(t)!==0;this._postProcessesSourceForThisPass=this._getPostProcessesSource(e,t),this._postProcessesSourceForThisPass=this._postProcessesSourceForThisPass.filter(l=>l!=null),this._scene.autoClear=!0;const r=this._hasImageProcessing(this._postProcessesSourceForThisPass);this._needsCompositionForThisPass=!r&&!this.disableGammaTransform&&this._needsImageProcessing()&&!i;const s=this._getFirstPostProcess(this._postProcessesSourceForThisPass),n=e._beforeCompositionPostProcesses&&e._beforeCompositionPostProcesses[0];let o=null;this._scene.imageProcessingConfiguration.applyByPostProcess=this._needsCompositionForThisPass||r,this._needsCompositionForThisPass&&!e.imageProcessingPostProcess&&e._createCompositionEffect(),n?o=n:this._needsCompositionForThisPass?o=e.imageProcessingPostProcess:s&&(o=s),this._bindFrameBuffer(),this._linkInternalTexture(e,o)}_linkInternalTexture(e,t){t&&(t.autoClear=!1,t.inputTexture=e.renderTarget),e._outputPostProcess!==t&&(e._outputPostProcess&&this._unlinkInternalTexture(e),e._outputPostProcess=t),e._internalTextureDirty&&(this._updateGeometryBufferLayout(),e._internalTextureDirty=!1)}_unlinkInternalTexture(e){e._outputPostProcess&&(e._outputPostProcess.autoClear=!0,e._outputPostProcess.restoreDefaultInputTexture(),e._outputPostProcess=null)}_needsImageProcessing(){for(let e=0;e<this._effectConfigurations.length;e++)if(this._effectConfigurations[e].enabled&&this._effectConfigurations[e].needsImageProcessing)return!0;return!1}_hasImageProcessing(e){var i;let t=!1;if(e){for(let r=0;r<e.length;r++)if(((i=e[r])==null?void 0:i.getClassName())==="ImageProcessingPostProcess"){t=!0;break}}return t}_getFirstPostProcess(e){for(let t=0;t<e.length;t++)if(e[t]!==null)return e[t];return null}markAsDirty(){this._isDirty=!0}_enableTextures(e){this._scene.needsPreviousWorldMatrices=!1;for(let t=0;t<e.length;t++){const i=e[t];this._textureIndices[i]===-1&&(this._textureIndices[i]=this._mrtLayout.length,this._mrtLayout.push(i),this._mrtTypes.push(di.TextureFormats[i].type),this._mrtFormats.push(di.TextureFormats[i].format),this._mrtNames.push(di.TextureFormats[i].name),this.mrtCount++),(i===2||i===11)&&(this._scene.needsPreviousWorldMatrices=!0)}}update(){this._isDirty&&this._update()}_update(){this._disable();let e=!1;this._scene.imageProcessingConfiguration.applyByPostProcess=!1,this._scene._depthPeelingRenderer&&this._scene.useOrderIndependentTransparency&&(this._scene._depthPeelingRenderer.setPrePassRenderer(this),e=!0);for(let i=0;i<this._scene.materials.length;i++)this._scene.materials[i].setPrePassRenderer(this)&&(e=!0);e&&this._setRenderTargetEnabled(this.defaultRT,!0);let t;for(let i=0;i<this.renderTargets.length;i++){if(this.renderTargets[i].renderTargetTexture)t=this._getPostProcessesSource(this.renderTargets[i]);else{const r=this._scene.activeCamera;if(!r)continue;t=r._postProcesses}if(t&&(t=t.filter(r=>r!=null),t)){for(let r=0;r<t.length;r++)t[r].setPrePassRenderer(this)&&(this._setRenderTargetEnabled(this.renderTargets[i],!0),e=!0);this._hasImageProcessing(t)&&(this._scene.imageProcessingConfiguration.applyByPostProcess=!0)}}this._markAllMaterialsAsPrePassDirty(),this._isDirty=!1,e&&this._enable()}_markAllMaterialsAsPrePassDirty(){const e=this._scene.materials;for(let t=0;t<e.length;t++)e[t].markAsDirty(ft.PrePassDirtyFlag)}dispose(){for(let e=this.renderTargets.length-1;e>=0;e--)this.renderTargets[e].dispose();for(let e=0;e<this._effectConfigurations.length;e++)this._effectConfigurations[e].dispose&&this._effectConfigurations[e].dispose()}}di._SceneComponentInitialization=a=>{throw Cr("PrePassRendererSceneComponent")};di.TextureFormats=[{purpose:0,type:2,format:5,name:"prePass_Irradiance"},{purpose:1,type:2,format:5,name:"prePass_Position"},{purpose:2,type:0,format:5,name:"prePass_Velocity"},{purpose:3,type:0,format:5,name:"prePass_Reflectivity"},{purpose:4,type:2,format:5,name:"prePass_Color"},{purpose:5,type:1,format:6,name:"prePass_Depth"},{purpose:6,type:2,format:5,name:"prePass_Normal"},{purpose:7,type:0,format:5,name:"prePass_Albedo"},{purpose:8,type:0,format:5,name:"prePass_WorldNormal"},{purpose:9,type:2,format:5,name:"prePass_LocalPosition"},{purpose:10,type:1,format:6,name:"prePass_ScreenDepth"},{purpose:11,type:2,format:5,name:"prePass_VelocityLinear"}];Object.defineProperty(Te.prototype,"prePassRenderer",{get:function(){return this._prePassRenderer},set:function(a){a&&a.isSupported&&(this._prePassRenderer=a)},enumerable:!0,configurable:!0});Te.prototype.enablePrePassRenderer=function(){return this._prePassRenderer?this._prePassRenderer:(this._prePassRenderer=new di(this),this._prePassRenderer.isSupported||(this._prePassRenderer=null,L.Error(`PrePassRenderer needs WebGL 2 support.
Maybe you tried to use the following features that need the PrePassRenderer :
 + Subsurface Scattering`)),this._prePassRenderer)};Te.prototype.disablePrePassRenderer=function(){this._prePassRenderer&&(this._prePassRenderer.dispose(),this._prePassRenderer=null)};class lz{constructor(e){this.name=ge.NAME_PREPASSRENDERER,this.scene=e}register(){this.scene._beforeCameraDrawStage.registerStep(ge.STEP_BEFORECAMERADRAW_PREPASS,this,this._beforeCameraDraw),this.scene._afterCameraDrawStage.registerStep(ge.STEP_AFTERCAMERADRAW_PREPASS,this,this._afterCameraDraw),this.scene._beforeRenderTargetDrawStage.registerStep(ge.STEP_BEFORERENDERTARGETDRAW_PREPASS,this,this._beforeRenderTargetDraw),this.scene._afterRenderTargetDrawStage.registerStep(ge.STEP_AFTERCAMERADRAW_PREPASS,this,this._afterRenderTargetDraw),this.scene._beforeClearStage.registerStep(ge.STEP_BEFORECLEAR_PREPASS,this,this._beforeClearStage),this.scene._beforeRenderTargetClearStage.registerStep(ge.STEP_BEFORERENDERTARGETCLEAR_PREPASS,this,this._beforeRenderTargetClearStage),this.scene._beforeRenderingMeshStage.registerStep(ge.STEP_BEFORERENDERINGMESH_PREPASS,this,this._beforeRenderingMeshStage),this.scene._afterRenderingMeshStage.registerStep(ge.STEP_AFTERRENDERINGMESH_PREPASS,this,this._afterRenderingMeshStage)}_beforeRenderTargetDraw(e,t,i){this.scene.prePassRenderer&&!e.noPrePassRenderer&&(this.scene.prePassRenderer._setRenderTarget(e._prePassRenderTarget),this.scene.prePassRenderer._beforeDraw(void 0,t,i))}_afterRenderTargetDraw(e,t,i){this.scene.prePassRenderer&&!e.noPrePassRenderer&&this.scene.prePassRenderer._afterDraw(t,i)}_beforeRenderTargetClearStage(e){this.scene.prePassRenderer&&!e.noPrePassRenderer&&(e._prePassRenderTarget||(e._prePassRenderTarget=this.scene.prePassRenderer._createRenderTarget(e.name+"_prePassRTT",e)),this.scene.prePassRenderer._setRenderTarget(e._prePassRenderTarget),this.scene.prePassRenderer._clear())}_beforeCameraDraw(e){this.scene.prePassRenderer&&(this.scene.prePassRenderer._setRenderTarget(null),this.scene.prePassRenderer._beforeDraw(e))}_afterCameraDraw(){this.scene.prePassRenderer&&this.scene.prePassRenderer._afterDraw()}_beforeClearStage(){this.scene.prePassRenderer&&(this.scene.prePassRenderer._setRenderTarget(null),this.scene.prePassRenderer._clear())}_beforeRenderingMeshStage(e,t,i,r){if(!r)return;const s=e.getScene();s.prePassRenderer&&s.prePassRenderer.bindAttachmentsForEffect(r,t)}_afterRenderingMeshStage(e){const t=e.getScene();t.prePassRenderer&&t.prePassRenderer.restoreAttachments()}rebuild(){}dispose(){this.scene.disablePrePassRenderer()}}di._SceneComponentInitialization=a=>{let e=a._getComponent(ge.NAME_PREPASSRENDERER);e||(e=new lz(a),a._addComponent(e))};const xb="fibonacci",uz=`#define rcp(x) 1./x
#define GOLDEN_RATIO 1.618033988749895
vec2 Golden2dSeq(int i,float n)
{return vec2(float(i)/n+(0.5/n),fract(float(i)*rcp(GOLDEN_RATIO)));}
vec2 SampleDiskGolden(int i,int sampleCount)
{vec2 f=Golden2dSeq(i,float(sampleCount));return vec2(sqrt(f.x),TWO_PI*f.y);}`;P.IncludesShadersStore[xb]||(P.IncludesShadersStore[xb]=uz);const Sb="diffusionProfile",cz="uniform vec3 diffusionS[5];uniform float diffusionD[5];uniform float filterRadii[5];";P.IncludesShadersStore[Sb]||(P.IncludesShadersStore[Sb]=cz);const vb="subSurfaceScatteringPixelShader",hz=`#include<helperFunctions>
#include<fibonacci>
#include<subSurfaceScatteringFunctions>
#include<diffusionProfile>
varying vec2 vUV;uniform vec2 texelSize;uniform sampler2D textureSampler;uniform sampler2D irradianceSampler;uniform sampler2D depthSampler;uniform sampler2D albedoSampler;uniform vec2 viewportSize;uniform float metersPerUnit;const float LOG2_E=1.4426950408889634;const float SSS_PIXELS_PER_SAMPLE=4.;const int _SssSampleBudget=40;
#define rcp(x) 1./x
#define Sq(x) x*x
#define SSS_BILATERAL_FILTER true
vec3 EvalBurleyDiffusionProfile(float r,vec3 S)
{vec3 exp_13=exp2(((LOG2_E*(-1.0/3.0))*r)*S); 
vec3 expSum=exp_13*(1.+exp_13*exp_13); 
return (S*rcp((8.*PI)))*expSum; }
vec2 SampleBurleyDiffusionProfile(float u,float rcpS)
{u=1.-u; 
float g=1.+(4.*u)*(2.*u+sqrt(1.+(4.*u)*u));float n=exp2(log2(g)*(-1.0/3.0)); 
float p=(g*n)*n; 
float c=1.+p+n; 
float d=(3./LOG2_E*2.)+(3./LOG2_E)*log2(u); 
float x=(3./LOG2_E)*log2(c)-d; 
float rcpExp=((c*c)*c)*rcp(((4.*u)*((c*c)+(4.*u)*(4.*u))));float r=x*rcpS;float rcpPdf=(8.*PI*rcpS)*rcpExp; 
return vec2(r,rcpPdf);}
vec3 ComputeBilateralWeight(float xy2,float z,float mmPerUnit,vec3 S,float rcpPdf)
{
#ifndef SSS_BILATERAL_FILTER
z=0.;
#endif
float r=sqrt(xy2+(z*mmPerUnit)*(z*mmPerUnit));float area=rcpPdf;
#if SSS_CLAMP_ARTIFACT
return clamp(EvalBurleyDiffusionProfile(r,S)*area,0.0,1.0);
#else
return EvalBurleyDiffusionProfile(r,S)*area;
#endif
}
void EvaluateSample(int i,int n,vec3 S,float d,vec3 centerPosVS,float mmPerUnit,float pixelsPerMm,
float phase,inout vec3 totalIrradiance,inout vec3 totalWeight)
{float scale =rcp(float(n));float offset=rcp(float(n))*0.5;float sinPhase,cosPhase;sinPhase=sin(phase);cosPhase=cos(phase);vec2 bdp=SampleBurleyDiffusionProfile(float(i)*scale+offset,d);float r=bdp.x;float rcpPdf=bdp.y;float phi=SampleDiskGolden(i,n).y;float sinPhi,cosPhi;sinPhi=sin(phi);cosPhi=cos(phi);float sinPsi=cosPhase*sinPhi+sinPhase*cosPhi; 
float cosPsi=cosPhase*cosPhi-sinPhase*sinPhi; 
vec2 vec=r*vec2(cosPsi,sinPsi);vec2 position; 
float xy2;position=vUV+round((pixelsPerMm*r)*vec2(cosPsi,sinPsi))*texelSize;xy2 =r*r;vec4 textureSample=texture2D(irradianceSampler,position);float viewZ=texture2D(depthSampler,position).r;vec3 irradiance =textureSample.rgb;if (testLightingForSSS(textureSample.a))
{float relZ=viewZ-centerPosVS.z;vec3 weight=ComputeBilateralWeight(xy2,relZ,mmPerUnit,S,rcpPdf);totalIrradiance+=weight*irradiance;totalWeight +=weight;}
else
{}}
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{vec4 irradianceAndDiffusionProfile =texture2D(irradianceSampler,vUV);vec3 centerIrradiance=irradianceAndDiffusionProfile.rgb;int diffusionProfileIndex=int(round(irradianceAndDiffusionProfile.a*255.));float centerDepth =0.;vec4 inputColor=texture2D(textureSampler,vUV);bool passedStencilTest=testLightingForSSS(irradianceAndDiffusionProfile.a);if (passedStencilTest)
{centerDepth=texture2D(depthSampler,vUV).r;}
if (!passedStencilTest) { 
gl_FragColor=inputColor;return;}
float distScale =1.;vec3 S =diffusionS[diffusionProfileIndex];float d =diffusionD[diffusionProfileIndex];float filterRadius=filterRadii[diffusionProfileIndex];vec2 centerPosNDC=vUV;vec2 cornerPosNDC=vUV+0.5*texelSize;vec3 centerPosVS =vec3(centerPosNDC*viewportSize,1.0)*centerDepth; 
vec3 cornerPosVS =vec3(cornerPosNDC*viewportSize,1.0)*centerDepth; 
float mmPerUnit =1000.*(metersPerUnit*rcp(distScale));float unitsPerMm=rcp(mmPerUnit);float unitsPerPixel=2.*abs(cornerPosVS.x-centerPosVS.x);float pixelsPerMm =rcp(unitsPerPixel)*unitsPerMm;float filterArea =PI*Sq(filterRadius*pixelsPerMm);int sampleCount =int(filterArea*rcp(SSS_PIXELS_PER_SAMPLE));int sampleBudget=_SssSampleBudget;int texturingMode=0;vec3 albedo =texture2D(albedoSampler,vUV).rgb;if (distScale==0. || sampleCount<1)
{
#ifdef DEBUG_SSS_SAMPLES
vec3 green=vec3(0.,1.,0.);gl_FragColor=vec4(green,1.0);return;
#endif
gl_FragColor=vec4(inputColor.rgb+albedo*centerIrradiance,1.0);return;}
#ifdef DEBUG_SSS_SAMPLES
vec3 red =vec3(1.,0.,0.);vec3 blue=vec3(0.,0.,1.);gl_FragColor=vec4(mix(blue,red,clamp(float(sampleCount)/float(sampleBudget),0.0,1.0)),1.0);return;
#endif
float phase=0.;int n=min(sampleCount,sampleBudget);vec3 centerWeight =vec3(0.); 
vec3 totalIrradiance=vec3(0.);vec3 totalWeight =vec3(0.);for (int i=0; i<n; i++)
{EvaluateSample(i,n,S,d,centerPosVS,mmPerUnit,pixelsPerMm,
phase,totalIrradiance,totalWeight);}
totalWeight=max(totalWeight,HALF_MIN);gl_FragColor=vec4(inputColor.rgb+albedo*max(totalIrradiance/totalWeight,vec3(0.0)),1.);}`;P.ShadersStore[vb]||(P.ShadersStore[vb]=hz);const bb="fibonacci",dz=`fn rcp(x: f32)->f32
{return 1./x;}
const GOLDEN_RATIO=1.618033988749895;fn Golden2dSeq(i: u32,n: f32)->vec2f
{return vec2f(f32(i)/n+(0.5/n),fract(f32(i)*rcp(GOLDEN_RATIO)));}
fn SampleDiskGolden(i: u32,sampleCount: u32)->vec2f
{let f=Golden2dSeq(i,f32(sampleCount));return vec2f(sqrt(f.x),TWO_PI*f.y);}
`;P.IncludesShadersStoreWGSL[bb]||(P.IncludesShadersStoreWGSL[bb]=dz);const yb="diffusionProfile",fz=`uniform diffusionS: array<vec3f,5>;uniform diffusionD: array<f32,5>;uniform filterRadii: array<f32,5>;
`;P.IncludesShadersStoreWGSL[yb]||(P.IncludesShadersStoreWGSL[yb]=fz);const Tb="subSurfaceScatteringPixelShader",pz=`#include<helperFunctions>
#include<fibonacci>
#include<subSurfaceScatteringFunctions>
#include<diffusionProfile>
varying vUV: vec2f;uniform texelSize: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var irradianceSamplerSampler: sampler;var irradianceSampler: texture_2d<f32>;var depthSamplerSampler: sampler;var depthSampler: texture_2d<f32>;var albedoSamplerSampler: sampler;var albedoSampler: texture_2d<f32>;uniform viewportSize: vec2f;uniform metersPerUnit: f32;const LOG2_E=1.4426950408889634;const SSS_PIXELS_PER_SAMPLE=4.;const _SssSampleBudget=40u;
#define SSS_BILATERAL_FILTER true
fn EvalBurleyDiffusionProfile(r: f32,S: vec3f)->vec3f
{let exp_13=exp2(((LOG2_E*(-1.0/3.0))*r)*S); 
let expSum=exp_13*(1.+exp_13*exp_13); 
return (S*rcp(8.*PI))*expSum; }
fn SampleBurleyDiffusionProfile(u_: f32,rcpS: f32)->vec2f
{let u=1.-u_; 
let g=1.+(4.*u)*(2.*u+sqrt(1.+(4.*u)*u));let n=exp2(log2(g)*(-1.0/3.0)); 
let p=(g*n)*n; 
let c=1.+p+n; 
let d=(3./LOG2_E*2.)+(3./LOG2_E)*log2(u); 
let x=(3./LOG2_E)*log2(c)-d; 
let rcpExp=((c*c)*c)*rcp((4.*u)*((c*c)+(4.*u)*(4.*u)));let r=x*rcpS;let rcpPdf=(8.*PI*rcpS)*rcpExp; 
return vec2f(r,rcpPdf);}
fn ComputeBilateralWeight(xy2: f32,z_: f32,mmPerUnit: f32,S: vec3f,rcpPdf: f32)->vec3f
{
#ifndef SSS_BILATERAL_FILTER
let z=0.;
#else
let z=z_;
#endif
let r=sqrt(xy2+(z*mmPerUnit)*(z*mmPerUnit));let area=rcpPdf;
#ifdef SSS_CLAMP_ARTIFACT
return clamp(EvalBurleyDiffusionProfile(r,S)*area,vec3f(0.0),vec3f(1.0));
#else
return EvalBurleyDiffusionProfile(r,S)*area;
#endif
}
fn EvaluateSample(i: u32,n: u32,S: vec3f,d: f32,centerPosVS: vec3f,mmPerUnit: f32,pixelsPerMm: f32,
phase: f32,totalIrradiance: ptr<function,vec3f>,totalWeight: ptr<function,vec3f>)
{let scale =rcp(f32(n));let offset=rcp(f32(n))*0.5;let sinPhase=sin(phase);let cosPhase=cos(phase);let bdp=SampleBurleyDiffusionProfile(f32(i)*scale+offset,d);let r=bdp.x;let rcpPdf=bdp.y;let phi=SampleDiskGolden(i,n).y;let sinPhi=sin(phi);let cosPhi=cos(phi);let sinPsi=cosPhase*sinPhi+sinPhase*cosPhi; 
let cosPsi=cosPhase*cosPhi-sinPhase*sinPhi; 
let vec=r*vec2f(cosPsi,sinPsi);let position=fragmentInputs.vUV+round((pixelsPerMm*r)*vec2(cosPsi,sinPsi))*uniforms.texelSize;let xy2 =r*r;let textureRead=textureSampleLevel(irradianceSampler,irradianceSamplerSampler,position,0.);let viewZ=textureSampleLevel(depthSampler,depthSamplerSampler,position,0.).r;let irradiance =textureRead.rgb;if (testLightingForSSS(textureRead.a))
{let relZ=viewZ-centerPosVS.z;let weight=ComputeBilateralWeight(xy2,relZ,mmPerUnit,S,rcpPdf);*totalIrradiance+=weight*irradiance;*totalWeight +=weight;}
else
{}}
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {let irradianceAndDiffusionProfile =textureSampleLevel(irradianceSampler,irradianceSamplerSampler,fragmentInputs.vUV,0.);let centerIrradiance=irradianceAndDiffusionProfile.rgb;let diffusionProfileIndex=u32(round(irradianceAndDiffusionProfile.a*255.));var centerDepth =0.;let inputColor=textureSampleLevel(textureSampler,textureSamplerSampler,fragmentInputs.vUV,0.);let passedStencilTest=testLightingForSSS(irradianceAndDiffusionProfile.a);if (passedStencilTest)
{centerDepth=textureSampleLevel(depthSampler,depthSamplerSampler,fragmentInputs.vUV,0.).r;}
if (!passedStencilTest) { 
fragmentOutputs.color=inputColor;return fragmentOutputs;}
let distScale =1.;let S =uniforms.diffusionS[diffusionProfileIndex];let d =uniforms.diffusionD[diffusionProfileIndex];let filterRadius=uniforms.filterRadii[diffusionProfileIndex];let centerPosNDC=fragmentInputs.vUV;let cornerPosNDC=fragmentInputs.vUV+0.5*uniforms.texelSize;let centerPosVS =vec3f(centerPosNDC*uniforms.viewportSize,1.0)*centerDepth; 
let cornerPosVS =vec3f(cornerPosNDC*uniforms.viewportSize,1.0)*centerDepth; 
let mmPerUnit =1000.*(uniforms.metersPerUnit*rcp(distScale));let unitsPerMm=rcp(mmPerUnit);let unitsPerPixel=2.*abs(cornerPosVS.x-centerPosVS.x);let pixelsPerMm =rcp(unitsPerPixel)*unitsPerMm;let filterArea =PI*square(filterRadius*pixelsPerMm);let sampleCount =u32(filterArea*rcp(SSS_PIXELS_PER_SAMPLE));let sampleBudget=_SssSampleBudget;let albedo =textureSampleLevel(albedoSampler,albedoSamplerSampler,fragmentInputs.vUV,0.).rgb;if (distScale==0. || sampleCount<1)
{
#ifdef DEBUG_SSS_SAMPLES
let green=vec3f(0.,1.,0.);fragmentOutputs.color=vec4f(green,1.0);return fragmentOutputs;
#endif
fragmentOutputs.color=vec4f(inputColor.rgb+albedo*centerIrradiance,1.0);return fragmentOutputs;}
#ifdef DEBUG_SSS_SAMPLES
let red =vec3f(1.,0.,0.);let blue=vec3f(0.,0.,1.);fragmentOutputs.color=vec4f(mix(blue,red,clamp(f32(sampleCount)/f32(sampleBudget),0.0,1.0)),1.0);return fragmentOutputs;
#endif
let phase=0.;let n=min(sampleCount,sampleBudget);var totalIrradiance=vec3f(0.);var totalWeight =vec3f(0.);for (var i=0u; i<n; i++)
{EvaluateSample(i,n,S,d,centerPosVS,mmPerUnit,pixelsPerMm,
phase,&totalIrradiance,&totalWeight);}
totalWeight=max(totalWeight,vec3f(HALF_MIN));fragmentOutputs.color=vec4f(inputColor.rgb+albedo*max(totalIrradiance/totalWeight,vec3f(0.0)),1.);}
`;P.ShadersStoreWGSL[Tb]||(P.ShadersStoreWGSL[Tb]=pz);class mz extends Ce{getClassName(){return"SubSurfaceScatteringPostProcess"}constructor(e,t,i,r=null,s,n,o,l=0){const u={uniforms:["texelSize","viewportSize","metersPerUnit"],samplers:["diffusionS","diffusionD","filterRadii","irradianceSampler","depthSampler","albedoSampler"],size:typeof i=="number"?i:void 0,camera:r,samplingMode:s,engine:n,reusable:o,textureType:l,...i,blockCompilation:!0};super(e,"subSurfaceScattering",{...u,samplingMode:s||Y.BILINEAR_SAMPLINGMODE}),this._scene=t,this.updateEffect(),this.onApplyObservable.add(c=>{if(!t.prePassRenderer||!t.subSurfaceConfiguration){L.Error("PrePass and subsurface configuration needs to be enabled for subsurface scattering.");return}const h=this.texelSize;c.setFloat("metersPerUnit",t.subSurfaceConfiguration.metersPerUnit),c.setFloat2("texelSize",h.x,h.y),c.setTexture("irradianceSampler",t.prePassRenderer.getRenderTarget().textures[t.prePassRenderer.getIndex(0)]),c.setTexture("depthSampler",t.prePassRenderer.getRenderTarget().textures[t.prePassRenderer.getIndex(5)]),c.setTexture("albedoSampler",t.prePassRenderer.getRenderTarget().textures[t.prePassRenderer.getIndex(7)]),c.setFloat2("viewportSize",Math.tan(t.activeCamera.fov/2)*t.getEngine().getAspectRatio(t.activeCamera,!0),Math.tan(t.activeCamera.fov/2)),c.setArray3("diffusionS",t.subSurfaceConfiguration.ssDiffusionS),c.setArray("diffusionD",t.subSurfaceConfiguration.ssDiffusionD),c.setArray("filterRadii",t.subSurfaceConfiguration.ssFilterRadii)})}}class Sl{get ssDiffusionS(){return this._ssDiffusionS}get ssDiffusionD(){return this._ssDiffusionD}get ssFilterRadii(){return this._ssFilterRadii}constructor(e){this._ssDiffusionS=[],this._ssFilterRadii=[],this._ssDiffusionD=[],this.enabled=!1,this.needsImageProcessing=!0,this.name=ge.NAME_SUBSURFACE,this.ssDiffusionProfileColors=[],this.metersPerUnit=1,this.texturesRequired=[5,7,4,0],this.addDiffusionProfile(new ne(1,1,1)),this._scene=e,Sl._SceneComponentInitialization(this._scene)}addDiffusionProfile(e){if(this.ssDiffusionD.length>=5)return L.Error("You already reached the maximum number of diffusion profiles."),0;for(let t=0;t<this._ssDiffusionS.length/3;t++)if(this._ssDiffusionS[t*3]===e.r&&this._ssDiffusionS[t*3+1]===e.g&&this._ssDiffusionS[t*3+2]===e.b)return t;return this._ssDiffusionS.push(e.r,e.b,e.g),this._ssDiffusionD.push(Math.max(Math.max(e.r,e.b),e.g)),this._ssFilterRadii.push(this.getDiffusionProfileParameters(e)),this.ssDiffusionProfileColors.push(e),this._ssDiffusionD.length-1}createPostProcess(){return this.postProcess=new mz("subSurfaceScattering",this._scene,{size:1,engine:this._scene.getEngine(),shaderLanguage:this._scene.getEngine().isWebGPU?1:0}),this.postProcess.autoClear=!1,this.postProcess}clearAllDiffusionProfiles(){this._ssDiffusionD=[],this._ssDiffusionS=[],this._ssFilterRadii=[],this.ssDiffusionProfileColors=[]}dispose(){this.clearAllDiffusionProfiles(),this.postProcess&&this.postProcess.dispose()}getDiffusionProfileParameters(e){const i=Math.max(e.r,e.g,e.b);return this._sampleBurleyDiffusionProfile(.997,i)}_sampleBurleyDiffusionProfile(e,t){e=1-e;const i=1+4*e*(2*e+Math.sqrt(1+4*e*e)),r=Math.pow(i,-1/3),n=1+i*r*r+r;return 3*Math.log(n/(4*e))*t}}Sl._SceneComponentInitialization=a=>{throw Cr("SubSurfaceSceneComponent")};rl(ge.NAME_SUBSURFACE,(a,e)=>{if(a.ssDiffusionProfileColors!==void 0&&a.ssDiffusionProfileColors!==null&&(e.enableSubSurfaceForPrePass(),e.subSurfaceConfiguration))for(let t=0,i=a.ssDiffusionProfileColors.length;t<i;t++){const r=a.ssDiffusionProfileColors[t];e.subSurfaceConfiguration.addDiffusionProfile(new ne(r.r,r.g,r.b))}});Object.defineProperty(Te.prototype,"subSurfaceConfiguration",{get:function(){return this._subSurfaceConfiguration},set:function(a){a&&this.enablePrePassRenderer()&&(this._subSurfaceConfiguration=a)},enumerable:!0,configurable:!0});Te.prototype.enableSubSurfaceForPrePass=function(){if(this._subSurfaceConfiguration)return this._subSurfaceConfiguration;const a=this.enablePrePassRenderer();return a?(this._subSurfaceConfiguration=new Sl(this),a.addEffectConfiguration(this._subSurfaceConfiguration),this._subSurfaceConfiguration):null};Te.prototype.disableSubSurfaceForPrePass=function(){this._subSurfaceConfiguration&&(this._subSurfaceConfiguration.dispose(),this._subSurfaceConfiguration=null)};class _z{constructor(e){this.name=ge.NAME_PREPASSRENDERER,this.scene=e}register(){}serialize(e){if(!this.scene.subSurfaceConfiguration)return;const t=this.scene.subSurfaceConfiguration.ssDiffusionProfileColors;e.ssDiffusionProfileColors=[];for(let i=0;i<t.length;i++)e.ssDiffusionProfileColors.push({r:t[i].r,g:t[i].g,b:t[i].b})}addFromContainer(){}removeFromContainer(){this.scene.prePassRenderer&&this.scene.subSurfaceConfiguration&&this.scene.subSurfaceConfiguration.clearAllDiffusionProfiles()}rebuild(){}dispose(){}}Sl._SceneComponentInitialization=a=>{let e=a._getComponent(ge.NAME_SUBSURFACE);e||(e=new _z(a),a._addComponent(e))};Te.prototype.getOutlineRenderer=function(){return this._outlineRenderer||(this._outlineRenderer=new tl(this)),this._outlineRenderer};Object.defineProperty(z.prototype,"renderOutline",{get:function(){return this._renderOutline},set:function(a){a&&this.getScene().getOutlineRenderer(),this._renderOutline=a},enumerable:!0,configurable:!0});Object.defineProperty(z.prototype,"renderOverlay",{get:function(){return this._renderOverlay},set:function(a){a&&this.getScene().getOutlineRenderer(),this._renderOverlay=a},enumerable:!0,configurable:!0});class tl{get shaderLanguage(){return this._shaderLanguage}constructor(e){this.name=ge.NAME_OUTLINERENDERER,this.zOffset=1,this.zOffsetUnits=4,this._shaderLanguage=0,this.scene=e,this._engine=e.getEngine(),this.scene._addComponent(this),this._passIdForDrawWrapper=[];for(let i=0;i<4;++i)this._passIdForDrawWrapper[i]=this._engine.createRenderPassId(`Outline Renderer (${i})`);this._engine.isWebGPU&&(this._shaderLanguage=1)}register(){this.scene._beforeRenderingMeshStage.registerStep(ge.STEP_BEFORERENDERINGMESH_OUTLINE,this,this._beforeRenderingMesh),this.scene._afterRenderingMeshStage.registerStep(ge.STEP_AFTERRENDERINGMESH_OUTLINE,this,this._afterRenderingMesh)}rebuild(){}dispose(){for(let e=0;e<this._passIdForDrawWrapper.length;++e)this._engine.releaseRenderPassId(this._passIdForDrawWrapper[e])}render(e,t,i=!1,r){r=r??this._passIdForDrawWrapper[0];const s=this.scene,n=s.getEngine(),o=n.getCaps().instancedArrays&&(t.visibleInstances[e._id]!==null&&t.visibleInstances[e._id]!==void 0||e.getRenderingMesh().hasThinInstances);if(!this.isReady(e,o,r))return;const l=e.getMesh(),u=l._internalAbstractMeshDataInfo._actAsRegularMesh?l:null,c=e.getRenderingMesh(),h=u||c,d=e.getMaterial();if(!d||!s.activeCamera)return;const f=e._getDrawWrapper(r),p=vi.GetEffect(f);n.enableEffect(f),d.useLogarithmicDepth&&p.setFloat("logarithmicDepthConstant",2/(Math.log(s.activeCamera.maxZ+1)/Math.LN2)),p.setFloat("offset",i?0:c.outlineWidth),p.setColor4("color",i?c.overlayColor:c.outlineColor,i?c.overlayAlpha:d.alpha),p.setMatrix("viewProjection",s.getTransformMatrix()),p.setMatrix("world",h.getWorldMatrix()),Yn(c,p),Ns(c,p),c.morphTargetManager&&c.morphTargetManager.isUsingTextureForTargets&&c.morphTargetManager._bind(p),o||c._bind(e,p,d.fillMode);const g=e.getMesh().bakedVertexAnimationManager;if(g&&g.isEnabled&&g.bind(p,o),d&&d.needAlphaTestingForMesh(h)){const _=d.getAlphaTestTexture();_&&(p.setTexture("diffuseSampler",_),p.setMatrix("diffuseMatrix",_.getTextureMatrix()))}Fs(p,d,s),n.setZOffset(-this.zOffset),n.setZOffsetUnits(-this.zOffsetUnits),c._processRendering(h,e,p,d.fillMode,t,o,(_,S)=>{p.setMatrix("world",S)}),n.setZOffset(0),n.setZOffsetUnits(0)}isReady(e,t,i){i=i??this._passIdForDrawWrapper[0];const r=[],s=[N.PositionKind,N.NormalKind],n=e.getMesh(),o=e.getMaterial();if(!o)return!1;const l=n.getScene();let u=!1,c=!1;const h=!1;o.needAlphaTestingForMesh(n)&&(r.push("#define ALPHATEST"),n.isVerticesDataPresent(N.UVKind)&&(s.push(N.UVKind),r.push("#define UV1"),u=!0),n.isVerticesDataPresent(N.UV2Kind)&&(s.push(N.UV2Kind),r.push("#define UV2"),c=!0)),o.useLogarithmicDepth&&r.push("#define LOGARITHMICDEPTH"),Zn(o,l,r);const d=new Xn;if(n.useBones&&n.computeBonesUsingShaders&&n.skeleton){s.push(N.MatricesIndicesKind),s.push(N.MatricesWeightsKind),n.numBoneInfluencers>4&&(s.push(N.MatricesIndicesExtraKind),s.push(N.MatricesWeightsExtraKind));const b=n.skeleton;r.push("#define NUM_BONE_INFLUENCERS "+n.numBoneInfluencers),n.numBoneInfluencers>0&&d.addCPUSkinningFallback(0,n),b.isUsingTextureForMatrices?r.push("#define BONETEXTURE"):r.push("#define BonesPerMesh "+(b.bones.length+1))}else r.push("#define NUM_BONE_INFLUENCERS 0");const f=n.morphTargetManager?jn(n.morphTargetManager,r,s,n,!0,!0,!1,u,c,h):0;t&&(r.push("#define INSTANCES"),qn(s),e.getRenderingMesh().hasThinInstances&&r.push("#define THIN_INSTANCES"));const p=n.bakedVertexAnimationManager;p&&p.isEnabled&&(r.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),t&&s.push("bakedVertexAnimationSettingsInstanced"));const g=e._getDrawWrapper(i,!0),_=g.defines,S=r.join(`
`);if(_!==S){const b=["world","mBones","viewProjection","diffuseMatrix","offset","color","logarithmicDepthConstant","morphTargetInfluences","boneTextureWidth","morphTargetCount","morphTargetTextureInfo","morphTargetTextureIndices","bakedVertexAnimationSettings","bakedVertexAnimationTextureSizeInverted","bakedVertexAnimationTime","bakedVertexAnimationTexture"],y=["diffuseSampler","boneSampler","morphTargets","bakedVertexAnimationTexture"];_n(b),g.setEffect(this.scene.getEngine().createEffect("outline",{attributes:s,uniformsNames:b,uniformBuffersNames:[],samplers:y,defines:S,fallbacks:d,onCompiled:null,onError:null,indexParameters:{maxSimultaneousMorphTargets:f},shaderLanguage:this._shaderLanguage,extraInitializationsAsync:async()=>{this._shaderLanguage===1?await Promise.all([k(()=>Promise.resolve().then(()=>HU),void 0),k(()=>Promise.resolve().then(()=>YU),void 0)]):await Promise.all([k(()=>Promise.resolve().then(()=>UU),void 0),k(()=>Promise.resolve().then(()=>WU),void 0)])}},this.scene.getEngine()),S)}return g.effect.isReady()}_beforeRenderingMesh(e,t,i){if(this._savedDepthWrite=this._engine.getDepthWrite(),e.renderOutline){const r=t.getMaterial();r&&r.needAlphaBlendingForMesh(e)&&(this._engine.cacheStencilState(),this._engine.setDepthWrite(!1),this._engine.setColorWrite(!1),this._engine.setStencilBuffer(!0),this._engine.setStencilOperationPass(7681),this._engine.setStencilFunction(519),this._engine.setStencilMask(tl._StencilReference),this._engine.setStencilFunctionReference(tl._StencilReference),this._engine.stencilStateComposer.useStencilGlobalOnly=!0,this.render(t,i,!0,this._passIdForDrawWrapper[1]),this._engine.setColorWrite(!0),this._engine.setStencilFunction(517)),this._engine.setDepthWrite(!1),this.render(t,i,!1,this._passIdForDrawWrapper[0]),this._engine.setDepthWrite(this._savedDepthWrite),r&&r.needAlphaBlendingForMesh(e)&&(this._engine.stencilStateComposer.useStencilGlobalOnly=!1,this._engine.restoreStencilState())}}_afterRenderingMesh(e,t,i){if(e.renderOverlay){const r=this._engine.getAlphaMode(),s=this._engine.alphaState.alphaBlend;this._engine.setAlphaMode(2),this.render(t,i,!0,this._passIdForDrawWrapper[3]),this._engine.setAlphaMode(r),this._engine.setDepthWrite(this._savedDepthWrite),this._engine.alphaState.alphaBlend=s}e.renderOutline&&this._savedDepthWrite&&(this._engine.setDepthWrite(!0),this._engine.setColorWrite(!1),this.render(t,i,!1,this._passIdForDrawWrapper[2]),this._engine.setColorWrite(!0))}}tl._StencilReference=4;class UE{get particleSize(){return this._particleSize}set particleSize(e){e!==this._particleSize&&(this._particleSize=e,this.onParticleSizeChanged.notifyObservers(this))}get useInstancing(){return!this.indexBuffer}get useVelocity(){return this._useVelocity}set useVelocity(e){this._useVelocity===e||!this._hasVelocity()||(this._useVelocity=e,this._effectsAreDirty=!0)}_hasVelocity(){var e;return!!((e=this.vertexBuffers)!=null&&e.velocity)}get indexBuffer(){return null}getClassName(){return"FluidRenderingObject"}get shaderLanguage(){return this._shaderLanguage}constructor(e,t){this.priority=0,this._particleSize=.1,this.onParticleSizeChanged=new j,this.particleThicknessAlpha=.05,this._useVelocity=!1,this._shaderLanguage=0,this._scene=e,this._engine=e.getEngine(),this._effectsAreDirty=!0,this._depthEffectWrapper=null,this._thicknessEffectWrapper=null,this._shaderLanguage=t??(this._engine.isWebGPU?1:0)}_createEffects(){const e=["view","projection","particleRadius","size"],t=["position","offset"],i=[];this._effectsAreDirty=!1,this.useVelocity&&(t.push("velocity"),i.push("#define FLUIDRENDERING_VELOCITY")),this._scene.useRightHandedSystem&&i.push("#define FLUIDRENDERING_RHS"),this._depthEffectWrapper=new Qt({engine:this._engine,useShaderStore:!0,vertexShader:"fluidRenderingParticleDepth",fragmentShader:"fluidRenderingParticleDepth",attributeNames:t,uniformNames:e,samplerNames:[],defines:i,shaderLanguage:this._shaderLanguage,extraInitializationsAsync:async()=>{this._shaderLanguage===1?await Promise.all([k(()=>Promise.resolve().then(()=>Vz),void 0),k(()=>Promise.resolve().then(()=>zz),void 0)]):await Promise.all([k(()=>Promise.resolve().then(()=>Cz),void 0),k(()=>Promise.resolve().then(()=>Ez),void 0)])}}),e.push("particleAlpha"),this._thicknessEffectWrapper=new Qt({engine:this._engine,useShaderStore:!0,vertexShader:"fluidRenderingParticleThickness",fragmentShader:"fluidRenderingParticleThickness",attributeNames:["position","offset"],uniformNames:e,samplerNames:[],shaderLanguage:this._shaderLanguage,extraInitializationsAsync:async()=>{this._shaderLanguage===1?await Promise.all([k(()=>Promise.resolve().then(()=>Gz),void 0),k(()=>Promise.resolve().then(()=>$z),void 0)]):await Promise.all([k(()=>Promise.resolve().then(()=>Rz),void 0),k(()=>Promise.resolve().then(()=>Az),void 0)])}})}isReady(){if(this._effectsAreDirty&&this._createEffects(),!this._depthEffectWrapper||!this._thicknessEffectWrapper)return!1;const e=this._depthEffectWrapper.drawWrapper.effect,t=this._thicknessEffectWrapper.drawWrapper.effect;return e.isReady()&&t.isReady()}renderDepthTexture(){const e=this.numParticles;if(!this._depthEffectWrapper||e===0)return;const t=this._depthEffectWrapper.drawWrapper,i=t.effect;this._engine.enableEffect(t),this._engine.bindBuffers(this.vertexBuffers,this.indexBuffer,i),i.setMatrix("view",this._scene.getViewMatrix()),i.setMatrix("projection",this._scene.getProjectionMatrix()),i.setFloat2("size",this._particleSize,this._particleSize),i.setFloat("particleRadius",this._particleSize/2),this.useInstancing?this._engine.drawArraysType(7,0,4,e):this._engine.drawElementsType(0,0,e)}renderThicknessTexture(){const e=this.numParticles;if(!this._thicknessEffectWrapper||e===0)return;const t=this._thicknessEffectWrapper.drawWrapper,i=t.effect;this._engine.setAlphaMode(6),this._engine.setDepthWrite(!1),this._engine.enableEffect(t),this._engine.bindBuffers(this.vertexBuffers,this.indexBuffer,i),i.setMatrix("view",this._scene.getViewMatrix()),i.setMatrix("projection",this._scene.getProjectionMatrix()),i.setFloat("particleAlpha",this.particleThicknessAlpha),i.setFloat2("size",this._particleSize,this._particleSize),this.useInstancing?this._engine.drawArraysType(7,0,4,e):this._engine.drawElementsType(0,0,e),this._engine.setDepthWrite(!0),this._engine.setAlphaMode(0)}renderDiffuseTexture(){}dispose(){var e,t;(e=this._depthEffectWrapper)==null||e.dispose(!1),(t=this._thicknessEffectWrapper)==null||t.dispose(!1),this.onParticleSizeChanged.clear()}}class gz extends UE{get particleSystem(){return this._particleSystem}getClassName(){return"FluidRenderingObjectParticleSystem"}get useTrueRenderingForDiffuseTexture(){return this._useTrueRenderingForDiffuseTexture}set useTrueRenderingForDiffuseTexture(e){this._useTrueRenderingForDiffuseTexture!==e&&(this._useTrueRenderingForDiffuseTexture=e,e?(this._particleSystem.blendMode=this._blendMode,this._particleSystem.onBeforeDrawParticlesObservable.remove(this._onBeforeDrawParticleObserver),this._onBeforeDrawParticleObserver=null):(this._particleSystem.blendMode=-1,this._onBeforeDrawParticleObserver=this._particleSystem.onBeforeDrawParticlesObservable.add(()=>{this._engine.setAlphaMode(2)})))}get vertexBuffers(){return this._particleSystem.vertexBuffers}get indexBuffer(){return this._particleSystem.indexBuffer}constructor(e,t,i){super(e,i),this._useTrueRenderingForDiffuseTexture=!0,this._particleSystem=t,this._originalRender=t.render.bind(t),this._blendMode=t.blendMode,this._onBeforeDrawParticleObserver=null,this._updateInAnimate=this._particleSystem.updateInAnimate,this._particleSystem.updateInAnimate=!0,this._particleSystem.render=()=>0,this.particleSize=(t.minSize+t.maxSize)/2,this.useTrueRenderingForDiffuseTexture=!1}isReady(){return super.isReady()&&this._particleSystem.isReady()}get numParticles(){return this._particleSystem.getActiveCount()}renderDiffuseTexture(){this._originalRender()}dispose(){super.dispose(),this._particleSystem.onBeforeDrawParticlesObservable.remove(this._onBeforeDrawParticleObserver),this._onBeforeDrawParticleObserver=null,this._particleSystem.render=this._originalRender,this._particleSystem.blendMode=this._blendMode,this._particleSystem.updateInAnimate=this._updateInAnimate}}class Yc{get blurNumIterations(){return this._blurNumIterations}set blurNumIterations(e){if(this._blurNumIterations!==e&&(this._blurNumIterations=e,this._blurPostProcesses!==null)){const t=this._blurPostProcesses[0],i=this._blurPostProcesses[1];this._blurPostProcesses=[];for(let r=0;r<this._blurNumIterations*2;++r)this._blurPostProcesses[r]=r&1?i:t}}get renderTarget(){return this._rt}get renderTargetBlur(){return this._rtBlur}get texture(){return this._texture}get textureBlur(){return this._textureBlurred}get shaderLanguage(){return this._shaderLanguage}constructor(e,t,i,r,s,n,o=1,l=6,u=1,c=6,h=!1,d=null,f=!0,p=1,g){this.enableBlur=!0,this.blurSizeDivisor=1,this.blurFilterSize=7,this._blurNumIterations=3,this.blurMaxFilterSize=100,this.blurDepthScale=10,this.particleSize=.02,this.onDisposeObservable=new j,this._shaderLanguage=0,this._name=e,this._scene=t,this._camera=d,this._engine=t.getEngine(),this._width=i,this._height=r,this._blurTextureSizeX=s,this._blurTextureSizeY=n,this._textureType=o,this._textureFormat=l,this._blurTextureType=u,this._blurTextureFormat=c,this._useStandardBlur=h,this._generateDepthBuffer=f,this._samples=p,this._postProcessRunningIndex=0,this.enableBlur=s!==0&&n!==0,this._rt=null,this._texture=null,this._rtBlur=null,this._textureBlurred=null,this._blurPostProcesses=null,this._shaderLanguage=g??(this._engine.isWebGPU?1:0)}initialize(){if(this.dispose(),this._createRenderTarget(),this.enableBlur&&this._texture){const[e,t,i]=this._createBlurPostProcesses(this._texture,this._blurTextureType,this._blurTextureFormat,this.blurSizeDivisor,this._name,this._useStandardBlur);this._rtBlur=e,this._textureBlurred=t,this._blurPostProcesses=i}}applyBlurPostProcesses(){this.enableBlur&&this._blurPostProcesses&&(this._postProcessRunningIndex=0,this._scene.postProcessManager.directRender(this._blurPostProcesses,this._rtBlur,!0),this._engine.unBindFramebuffer(this._rtBlur))}_createRenderTarget(){this._rt=this._engine.createRenderTargetTexture({width:this._width,height:this._height},{generateMipMaps:!1,type:this._textureType,format:this._textureFormat,samplingMode:1,generateDepthBuffer:this._generateDepthBuffer,generateStencilBuffer:!1,samples:this._samples,label:`FluidRenderingRTT-${this._name}`});const e=this._rt.texture;e.incrementReferences(),this._texture=new Y(null,this._scene),this._texture.name="rtt"+this._name,this._texture._texture=e,this._texture.wrapU=Y.CLAMP_ADDRESSMODE,this._texture.wrapV=Y.CLAMP_ADDRESSMODE,this._texture.anisotropicFilteringLevel=1}_createBlurPostProcesses(e,t,i,r,s,n=!1){const o=this._scene.getEngine(),l=new Q(Math.floor(this._blurTextureSizeX/r),Math.floor(this._blurTextureSizeY/r)),u=t===1&&o.getCaps().textureFloatLinearFiltering||t===2&&o.getCaps().textureHalfFloatLinearFiltering,c=this._engine.createRenderTargetTexture({width:l.x,height:l.y},{generateMipMaps:!1,type:t,format:i,samplingMode:u?2:1,generateDepthBuffer:!1,generateStencilBuffer:!1,samples:this._samples,label:`FluidRenderingRTTBlur-${s}`}),h=c.texture;h.incrementReferences();const d=new Y(null,this._scene);if(d.name="rttBlurred"+s,d._texture=h,d.wrapU=Y.CLAMP_ADDRESSMODE,d.wrapV=Y.CLAMP_ADDRESSMODE,d.anisotropicFilteringLevel=1,n){const f=new Ce("BilateralBlurX","fluidRenderingStandardBlur",["filterSize","blurDir"],null,1,null,1,o,!0,null,t,void 0,void 0,void 0,i,this._shaderLanguage,async()=>{this.shaderLanguage===1?await k(()=>Promise.resolve().then(()=>Mb),void 0):await k(()=>Promise.resolve().then(()=>Ib),void 0)});f.samples=this._samples,f.externalTextureSamplerBinding=!0,f.onApplyObservable.add(_=>{this._postProcessRunningIndex===0?_.setTexture("textureSampler",e):_._bindTexture("textureSampler",f.inputTexture.texture),_.setInt("filterSize",this.blurFilterSize),_.setFloat2("blurDir",1/this._blurTextureSizeX,0),this._postProcessRunningIndex++}),f.onSizeChangedObservable.add(()=>{f._textures.forEach(_=>{_.texture.wrapU=Y.CLAMP_ADDRESSMODE,_.texture.wrapV=Y.CLAMP_ADDRESSMODE})}),this._fixReusablePostProcess(f);const p=new Ce("BilateralBlurY","fluidRenderingStandardBlur",["filterSize","blurDir"],null,1,null,1,o,!0,null,t,void 0,void 0,void 0,i,this._shaderLanguage,async()=>{this.shaderLanguage===1?await k(()=>Promise.resolve().then(()=>Mb),void 0):await k(()=>Promise.resolve().then(()=>Ib),void 0)});p.samples=this._samples,p.onApplyObservable.add(_=>{_.setInt("filterSize",this.blurFilterSize),_.setFloat2("blurDir",0,1/this._blurTextureSizeY),this._postProcessRunningIndex++}),p.onSizeChangedObservable.add(()=>{p._textures.forEach(_=>{_.texture.wrapU=Y.CLAMP_ADDRESSMODE,_.texture.wrapV=Y.CLAMP_ADDRESSMODE})}),this._fixReusablePostProcess(p),f.autoClear=!1,p.autoClear=!1;const g=[];for(let _=0;_<this._blurNumIterations*2;++_)g[_]=_&1?p:f;return[c,d,g]}else{const f=["maxFilterSize","blurDir","projectedParticleConstant","depthThreshold"],p=new Ce("BilateralBlurX","fluidRenderingBilateralBlur",f,null,1,null,1,o,!0,null,t,void 0,void 0,void 0,i,this._shaderLanguage,async()=>{this.shaderLanguage===1?await k(()=>Promise.resolve().then(()=>Rb),void 0):await k(()=>Promise.resolve().then(()=>Eb),void 0)});p.samples=this._samples,p.externalTextureSamplerBinding=!0,p.onApplyObservable.add(S=>{this._postProcessRunningIndex===0?S.setTexture("textureSampler",e):S._bindTexture("textureSampler",p.inputTexture.texture),S.setInt("maxFilterSize",this.blurMaxFilterSize),S.setFloat2("blurDir",1/this._blurTextureSizeX,0),S.setFloat("projectedParticleConstant",this._getProjectedParticleConstant()),S.setFloat("depthThreshold",this._getDepthThreshold()),this._postProcessRunningIndex++}),p.onSizeChangedObservable.add(()=>{p._textures.forEach(S=>{S.texture.wrapU=Y.CLAMP_ADDRESSMODE,S.texture.wrapV=Y.CLAMP_ADDRESSMODE})}),this._fixReusablePostProcess(p);const g=new Ce("BilateralBlurY","fluidRenderingBilateralBlur",f,null,1,null,1,o,!0,null,t,void 0,void 0,void 0,i,this._shaderLanguage,async()=>{this.shaderLanguage===1?await k(()=>Promise.resolve().then(()=>Rb),void 0):await k(()=>Promise.resolve().then(()=>Eb),void 0)});g.samples=this._samples,g.onApplyObservable.add(S=>{S.setInt("maxFilterSize",this.blurMaxFilterSize),S.setFloat2("blurDir",0,1/this._blurTextureSizeY),S.setFloat("projectedParticleConstant",this._getProjectedParticleConstant()),S.setFloat("depthThreshold",this._getDepthThreshold()),this._postProcessRunningIndex++}),g.onSizeChangedObservable.add(()=>{g._textures.forEach(S=>{S.texture.wrapU=Y.CLAMP_ADDRESSMODE,S.texture.wrapV=Y.CLAMP_ADDRESSMODE})}),this._fixReusablePostProcess(g),p.autoClear=!1,g.autoClear=!1;const _=[];for(let S=0;S<this._blurNumIterations*2;++S)_[S]=S&1?g:p;return[c,d,_]}}_fixReusablePostProcess(e){e.isReusable()&&(e.onActivateObservable.add(()=>{e._currentRenderTextureInd=(e._currentRenderTextureInd+1)%2}),e.onApplyObservable.add(()=>{e._currentRenderTextureInd=(e._currentRenderTextureInd+1)%2}))}_getProjectedParticleConstant(){var e;return this.blurFilterSize*this.particleSize*.05*(this._height/2)/Math.tan((((e=this._camera)==null?void 0:e.fov)??45*Math.PI/180)/2)}_getDepthThreshold(){return this.particleSize/2*this.blurDepthScale}dispose(){var e,t,i,r;this.onDisposeObservable.hasObservers()&&this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),(e=this._rt)==null||e.dispose(),this._rt=null,(t=this._texture)==null||t.dispose(),this._texture=null,(i=this._rtBlur)==null||i.dispose(),this._rtBlur=null,(r=this._textureBlurred)==null||r.dispose(),this._textureBlurred=null,this._blurPostProcesses&&(this._blurPostProcesses[0].dispose(),this._blurPostProcesses[1].dispose()),this._blurPostProcesses=null}}var Cb;(function(a){a[a.DepthTexture=0]="DepthTexture",a[a.DepthBlurredTexture=1]="DepthBlurredTexture",a[a.ThicknessTexture=2]="ThicknessTexture",a[a.ThicknessBlurredTexture=3]="ThicknessBlurredTexture",a[a.DiffuseTexture=4]="DiffuseTexture",a[a.Normals=5]="Normals",a[a.DiffuseRendering=6]="DiffuseRendering"})(Cb||(Cb={}));class Pb{get needInitialization(){return this._needInitialization}get generateDiffuseTexture(){return this._generateDiffuseTexture}set generateDiffuseTexture(e){this._generateDiffuseTexture!==e&&(this._generateDiffuseTexture=e,this._needInitialization=!0)}get debugFeature(){return this._debugFeature}set debugFeature(e){this._debugFeature!==e&&(this._needInitialization=!0,this._debugFeature=e)}get debug(){return this._debug}set debug(e){this._debug!==e&&(this._debug=e,this._needInitialization=!0)}get environmentMap(){return this._environmentMap}set environmentMap(e){this._environmentMap!==e&&(this._needInitialization=!0,this._environmentMap=e)}get enableBlurDepth(){return this._enableBlurDepth}set enableBlurDepth(e){this._enableBlurDepth!==e&&(this._enableBlurDepth=e,this._needInitialization=!0)}get blurDepthSizeDivisor(){return this._blurDepthSizeDivisor}set blurDepthSizeDivisor(e){this._blurDepthSizeDivisor!==e&&(this._blurDepthSizeDivisor=e,this._needInitialization=!0)}get blurDepthFilterSize(){return this._blurDepthFilterSize}set blurDepthFilterSize(e){this._blurDepthFilterSize!==e&&(this._blurDepthFilterSize=e,this._setBlurParameters())}get blurDepthNumIterations(){return this._blurDepthNumIterations}set blurDepthNumIterations(e){this._blurDepthNumIterations!==e&&(this._blurDepthNumIterations=e,this._setBlurParameters())}get blurDepthMaxFilterSize(){return this._blurDepthMaxFilterSize}set blurDepthMaxFilterSize(e){this._blurDepthMaxFilterSize!==e&&(this._blurDepthMaxFilterSize=e,this._setBlurParameters())}get blurDepthDepthScale(){return this._blurDepthDepthScale}set blurDepthDepthScale(e){this._blurDepthDepthScale!==e&&(this._blurDepthDepthScale=e,this._setBlurParameters())}get enableBlurThickness(){return this._enableBlurThickness}set enableBlurThickness(e){this._enableBlurThickness!==e&&(this._enableBlurThickness=e,this._needInitialization=!0)}get blurThicknessSizeDivisor(){return this._blurThicknessSizeDivisor}set blurThicknessSizeDivisor(e){this._blurThicknessSizeDivisor!==e&&(this._blurThicknessSizeDivisor=e,this._needInitialization=!0)}get blurThicknessFilterSize(){return this._blurThicknessFilterSize}set blurThicknessFilterSize(e){this._blurThicknessFilterSize!==e&&(this._blurThicknessFilterSize=e,this._setBlurParameters())}get blurThicknessNumIterations(){return this._blurThicknessNumIterations}set blurThicknessNumIterations(e){this._blurThicknessNumIterations!==e&&(this._blurThicknessNumIterations=e,this._setBlurParameters())}get useFixedThickness(){return this._useFixedThickness}set useFixedThickness(e){this._useFixedThickness!==e&&(this._useFixedThickness=e,this._needInitialization=!0)}get useVelocity(){return this._useVelocity}set useVelocity(e){this._useVelocity!==e&&(this._useVelocity=e,this._needInitialization=!0,this._onUseVelocityChanged.notifyObservers(this))}get depthMapSize(){return this._depthMapSize}set depthMapSize(e){this._depthMapSize!==e&&(this._depthMapSize=e,this._needInitialization=!0)}get thicknessMapSize(){return this._thicknessMapSize}set thicknessMapSize(e){this._thicknessMapSize!==e&&(this._thicknessMapSize=e,this._needInitialization=!0)}get diffuseMapSize(){return this._diffuseMapSize}set diffuseMapSize(e){this._diffuseMapSize!==e&&(this._diffuseMapSize=e,this._needInitialization=!0)}get samples(){return this._samples}set samples(e){this._samples!==e&&(this._samples=e,this._needInitialization=!0)}get compositeMode(){return this._compositeMode}set compositeMode(e){this._compositeMode!==e&&(this._compositeMode=e,this._needInitialization=!0)}get camera(){return this._camera}get shaderLanguage(){return this._shaderLanguage}constructor(e,t,i){this._generateDiffuseTexture=!1,this.fluidColor=new ne(.085,.6375,.765),this.density=2,this.refractionStrength=.1,this.fresnelClamp=1,this.specularPower=250,this.minimumThickness=0,this.dirLight=new m(-2,-1,1).normalize(),this._debugFeature=1,this._debug=!1,this._enableBlurDepth=!0,this._blurDepthSizeDivisor=1,this._blurDepthFilterSize=7,this._blurDepthNumIterations=3,this._blurDepthMaxFilterSize=100,this._blurDepthDepthScale=10,this._enableBlurThickness=!0,this._blurThicknessSizeDivisor=1,this._blurThicknessFilterSize=5,this._blurThicknessNumIterations=1,this._useFixedThickness=!1,this._onUseVelocityChanged=new j,this._useVelocity=!1,this._depthMapSize=null,this._thicknessMapSize=null,this._diffuseMapSize=null,this._samples=1,this._compositeMode=!1,this._shaderLanguage=0,this._scene=e,this._engine=e.getEngine(),this._camera=t??e.activeCamera,this._needInitialization=!0,this._bgDepthTexture=null,this._invProjectionMatrix=new $,this._depthClearColor=new xe(1e6,1e6,1e6,1),this._thicknessClearColor=new xe(0,0,0,1),this._depthRenderTarget=null,this._diffuseRenderTarget=null,this._thicknessRenderTarget=null,this._renderPostProcess=null,this._shaderLanguage=i??(this._engine.isWebGPU?1:0)}_initialize(){this.dispose(),this._needInitialization=!1;const e=this._depthMapSize??this._engine.getRenderWidth(),t=this._depthMapSize!==null?Math.round(this._depthMapSize*this._engine.getRenderHeight()/this._engine.getRenderWidth()):this._engine.getRenderHeight();if(this._depthRenderTarget=new Yc("Depth",this._scene,e,t,e,t,1,7,1,7,!1,this._camera,!0,this._samples,this._shaderLanguage),this._initializeRenderTarget(this._depthRenderTarget),this.generateDiffuseTexture){const s=this._diffuseMapSize??this._engine.getRenderWidth(),n=this._diffuseMapSize!==null?Math.round(this._diffuseMapSize*this._engine.getRenderHeight()/this._engine.getRenderWidth()):this._engine.getRenderHeight();this._diffuseRenderTarget=new Yc("Diffuse",this._scene,s,n,0,0,0,5,0,5,!0,this._camera,!0,this._samples,this._shaderLanguage),this._initializeRenderTarget(this._diffuseRenderTarget)}const i=this._thicknessMapSize??this._engine.getRenderWidth(),r=this._thicknessMapSize!==null?Math.round(this._thicknessMapSize*this._engine.getRenderHeight()/this._engine.getRenderWidth()):this._engine.getRenderHeight();this._useFixedThickness||(this._thicknessRenderTarget=new Yc("Thickness",this._scene,i,r,i,r,2,6,2,6,!0,this._camera,!1,this._samples,this._shaderLanguage),this._initializeRenderTarget(this._thicknessRenderTarget)),this._createLiquidRenderingPostProcess()}_setBlurParameters(e=null){(e===null||e===this._depthRenderTarget)&&this._setBlurDepthParameters(),(e===null||e===this._thicknessRenderTarget)&&this._setBlurThicknessParameters()}_setBlurDepthParameters(){this._depthRenderTarget&&(this._depthRenderTarget.blurFilterSize=this.blurDepthFilterSize,this._depthRenderTarget.blurMaxFilterSize=this.blurDepthMaxFilterSize,this._depthRenderTarget.blurNumIterations=this.blurDepthNumIterations,this._depthRenderTarget.blurDepthScale=this.blurDepthDepthScale)}_setBlurThicknessParameters(){this._thicknessRenderTarget&&(this._thicknessRenderTarget.blurFilterSize=this.blurThicknessFilterSize,this._thicknessRenderTarget.blurNumIterations=this.blurThicknessNumIterations)}_initializeRenderTarget(e){e!==this._diffuseRenderTarget&&(e.enableBlur=e===this._depthRenderTarget?this.enableBlurDepth:this.enableBlurThickness,e.blurSizeDivisor=e===this._depthRenderTarget?this.blurDepthSizeDivisor:this.blurThicknessSizeDivisor),this._setBlurParameters(e),e.initialize()}_createLiquidRenderingPostProcess(){const e=this._scene.getEngine(),t=["viewMatrix","projectionMatrix","invProjectionMatrix","texelSize","dirLight","cameraFar","density","refractionStrength","fresnelClamp","specularPower"],i=["depthSampler"],r=[];if(this.dispose(!0),!this._camera)return;const s=this._depthRenderTarget.enableBlur?this._depthRenderTarget.textureBlur:this._depthRenderTarget.texture,n=new Q(1/s.getSize().width,1/s.getSize().height);this._scene.useRightHandedSystem&&r.push("#define FLUIDRENDERING_RHS"),this._environmentMap!==null&&(this._environmentMap??this._scene.environmentTexture)&&(i.push("reflectionSampler"),r.push("#define FLUIDRENDERING_ENVIRONMENT")),this._diffuseRenderTarget?(i.push("diffuseSampler"),r.push("#define FLUIDRENDERING_DIFFUSETEXTURE")):t.push("diffuseColor"),this._useVelocity&&(i.push("velocitySampler"),r.push("#define FLUIDRENDERING_VELOCITY")),this._useFixedThickness?(t.push("thickness"),i.push("bgDepthSampler"),r.push("#define FLUIDRENDERING_FIXED_THICKNESS")):(t.push("minimumThickness"),i.push("thicknessSampler")),this._compositeMode&&r.push("#define FLUIDRENDERING_COMPOSITE_MODE"),this._debug&&(r.push("#define FLUIDRENDERING_DEBUG"),this._debugFeature===5?r.push("#define FLUIDRENDERING_DEBUG_SHOWNORMAL"):this._debugFeature===6?r.push("#define FLUIDRENDERING_DEBUG_DIFFUSERENDERING"):(r.push("#define FLUIDRENDERING_DEBUG_TEXTURE"),i.push("debugSampler"),(this._debugFeature===0||this._debugFeature===1)&&r.push("#define FLUIDRENDERING_DEBUG_DEPTH"))),this._renderPostProcess=new Ce("FluidRendering","fluidRenderingRender",t,i,1,null,2,e,!1,null,0,void 0,void 0,!0,void 0,this._shaderLanguage,async()=>{this._shaderLanguage===1?await k(()=>Promise.resolve().then(()=>qz),void 0):await k(()=>Promise.resolve().then(()=>Lz),void 0)}),this._renderPostProcess.updateEffect(r.join(`
`)),this._renderPostProcess.samples=this._samples;const o=e,l=o.setTextureSampler;this._renderPostProcess.onApplyObservable.add(u=>{var c,h,d,f,p,g,_,S,b,y;if(this._invProjectionMatrix.copyFrom(this._scene.getProjectionMatrix()),this._invProjectionMatrix.invert(),l&&l.call(o,"textureSamplerSampler",this._renderPostProcess.inputTexture.texture),this._depthRenderTarget.enableBlur?(u.setTexture("depthSampler",this._depthRenderTarget.textureBlur),l&&l.call(o,"depthSamplerSampler",((h=this._depthRenderTarget.textureBlur)==null?void 0:h.getInternalTexture())??null)):(u.setTexture("depthSampler",this._depthRenderTarget.texture),l&&l.call(o,"depthSamplerSampler",((c=this._depthRenderTarget.texture)==null?void 0:c.getInternalTexture())??null)),this._diffuseRenderTarget?this._diffuseRenderTarget.enableBlur?(u.setTexture("diffuseSampler",this._diffuseRenderTarget.textureBlur),l&&l.call(o,"diffuseSamplerSampler",((f=this._diffuseRenderTarget.textureBlur)==null?void 0:f.getInternalTexture())??null)):(u.setTexture("diffuseSampler",this._diffuseRenderTarget.texture),l&&l.call(o,"diffuseSamplerSampler",((d=this._diffuseRenderTarget.texture)==null?void 0:d.getInternalTexture())??null)):u.setColor3("diffuseColor",this.fluidColor),this._useFixedThickness?(u.setFloat("thickness",this.minimumThickness),u._bindTexture("bgDepthSampler",this._bgDepthTexture),l&&l.call(o,"bgDepthSamplerSampler",this._bgDepthTexture??null)):(this._thicknessRenderTarget.enableBlur?(u.setTexture("thicknessSampler",this._thicknessRenderTarget.textureBlur),l&&l.call(o,"thicknessSamplerSampler",((g=this._thicknessRenderTarget.textureBlur)==null?void 0:g.getInternalTexture())??null)):(u.setTexture("thicknessSampler",this._thicknessRenderTarget.texture),l&&l.call(o,"thicknessSamplerSampler",((p=this._thicknessRenderTarget.texture)==null?void 0:p.getInternalTexture())??null)),u.setFloat("minimumThickness",this.minimumThickness)),this._environmentMap!==null){const T=this._environmentMap??this._scene.environmentTexture;T&&(u.setTexture("reflectionSampler",T),l&&l.call(o,"reflectionSamplerSampler",(T==null?void 0:T.getInternalTexture())??null))}if(u.setMatrix("viewMatrix",this._scene.getViewMatrix()),u.setMatrix("invProjectionMatrix",this._invProjectionMatrix),u.setMatrix("projectionMatrix",this._scene.getProjectionMatrix()),u.setVector2("texelSize",n),u.setFloat("density",this.density),u.setFloat("refractionStrength",this.refractionStrength),u.setFloat("fresnelClamp",this.fresnelClamp),u.setFloat("specularPower",this.specularPower),u.setVector3("dirLight",this.dirLight),u.setFloat("cameraFar",this._camera.maxZ),this._debug){let T=null;switch(this._debugFeature){case 0:T=this._depthRenderTarget.texture;break;case 1:T=this._depthRenderTarget.enableBlur?this._depthRenderTarget.textureBlur:this._depthRenderTarget.texture;break;case 2:T=((_=this._thicknessRenderTarget)==null?void 0:_.texture)??null;break;case 3:T=(S=this._thicknessRenderTarget)!=null&&S.enableBlur?((b=this._thicknessRenderTarget)==null?void 0:b.textureBlur)??null:((y=this._thicknessRenderTarget)==null?void 0:y.texture)??null;break;case 4:this._diffuseRenderTarget&&(T=this._diffuseRenderTarget.texture);break}this._debugFeature!==5&&(u.setTexture("debugSampler",T),l&&l.call(o,"debugSamplerSampler",(T==null?void 0:T.getInternalTexture())??null))}})}_clearTargets(){var e,t,i;(e=this._depthRenderTarget)!=null&&e.renderTarget&&(this._engine.bindFramebuffer(this._depthRenderTarget.renderTarget),this._engine.clear(this._depthClearColor,!0,!0,!1),this._engine.unBindFramebuffer(this._depthRenderTarget.renderTarget)),(t=this._diffuseRenderTarget)!=null&&t.renderTarget&&(this._engine.bindFramebuffer(this._diffuseRenderTarget.renderTarget),this._engine.clear(this._thicknessClearColor,!0,!0,!1),this._engine.unBindFramebuffer(this._diffuseRenderTarget.renderTarget)),(i=this._thicknessRenderTarget)!=null&&i.renderTarget&&(this._engine.bindFramebuffer(this._thicknessRenderTarget.renderTarget),this._engine.clear(this._thicknessClearColor,!0,!1,!1),this._engine.unBindFramebuffer(this._thicknessRenderTarget.renderTarget))}_render(e){var i,r,s,n,o,l;if(this._needInitialization||!e.isReady())return;const t=this._engine._currentRenderTarget;this._engine.setState(!1,void 0,void 0,void 0,!0),this._engine.setDepthBuffer(!0),this._engine.setDepthWrite(!0),this._engine.setAlphaMode(0),(i=this._depthRenderTarget)!=null&&i.renderTarget&&(this._engine.bindFramebuffer(this._depthRenderTarget.renderTarget),e.renderDepthTexture(),this._engine.unbindInstanceAttributes(),this._engine.unBindFramebuffer(this._depthRenderTarget.renderTarget)),(r=this._diffuseRenderTarget)!=null&&r.renderTarget&&(this._engine.bindFramebuffer(this._diffuseRenderTarget.renderTarget),e.renderDiffuseTexture(),this._engine.unbindInstanceAttributes(),this._engine.unBindFramebuffer(this._diffuseRenderTarget.renderTarget)),(s=this._thicknessRenderTarget)!=null&&s.renderTarget&&(this._engine.bindFramebuffer(this._thicknessRenderTarget.renderTarget),e.renderThicknessTexture(),this._engine.unbindInstanceAttributes(),this._engine.unBindFramebuffer(this._thicknessRenderTarget.renderTarget)),(n=this._depthRenderTarget)==null||n.applyBlurPostProcesses(),(o=this._diffuseRenderTarget)==null||o.applyBlurPostProcesses(),(l=this._thicknessRenderTarget)==null||l.applyBlurPostProcesses(),t&&this._engine.bindFramebuffer(t)}dispose(e=!1){var t,i,r,s;e||((t=this._depthRenderTarget)==null||t.dispose(),this._depthRenderTarget=null,(i=this._diffuseRenderTarget)==null||i.dispose(),this._diffuseRenderTarget=null,(r=this._thicknessRenderTarget)==null||r.dispose(),this._thicknessRenderTarget=null),this._renderPostProcess&&this._camera&&this._camera.detachPostProcess(this._renderPostProcess),(s=this._renderPostProcess)==null||s.dispose(),this._renderPostProcess=null,this._onUseVelocityChanged.clear(),this._needInitialization=!1}}class xz extends UE{getClassName(){return"FluidRenderingObjectCustomParticles"}get vertexBuffers(){return this._vertexBuffers}constructor(e,t,i,r){super(e,r),this._numParticles=i,this._diffuseEffectWrapper=null,this._vertexBuffers={},this.addBuffers(t)}addBuffers(e){for(const t in e){let i,r=!0;switch(t){case"velocity":i=3;break;case"offset":r=!1;break}this._vertexBuffers[t]=new N(this._engine,e[t],t,!0,!1,i,r)}}_createEffects(){super._createEffects();const e=["view","projection","size"],t=["position","offset","color"];this._diffuseEffectWrapper=new Qt({engine:this._engine,useShaderStore:!0,vertexShader:"fluidRenderingParticleDiffuse",fragmentShader:"fluidRenderingParticleDiffuse",attributeNames:t,uniformNames:e,samplerNames:[],shaderLanguage:this._shaderLanguage,extraInitializationsAsync:async()=>{this._shaderLanguage===1?await k(()=>Promise.resolve().then(()=>jz),void 0):await k(()=>Promise.resolve().then(()=>Oz),void 0)}})}isReady(){var e;return this._vertexBuffers.offset||(this._vertexBuffers.offset=new N(this._engine,[0,0,1,0,0,1,1,1],"offset",!1,!1,2)),super.isReady()&&(((e=this._diffuseEffectWrapper)==null?void 0:e.effect.isReady())??!1)}get numParticles(){return this._numParticles}setNumParticles(e){this._numParticles=e}renderDiffuseTexture(){const e=this.numParticles;if(!this._diffuseEffectWrapper||e===0)return;const t=this._diffuseEffectWrapper.drawWrapper,i=t.effect;this._engine.enableEffect(t),this._engine.bindBuffers(this.vertexBuffers,this.indexBuffer,i),i.setMatrix("view",this._scene.getViewMatrix()),i.setMatrix("projection",this._scene.getProjectionMatrix()),this._particleSize!==null&&i.setFloat2("size",this._particleSize,this._particleSize),this.useInstancing?this._engine.drawArraysType(7,0,4,e):this._engine.drawElementsType(0,0,e)}dispose(){var e;super.dispose(),(e=this._diffuseEffectWrapper)==null||e.dispose();for(const t in this._vertexBuffers)this._vertexBuffers[t].dispose();this._vertexBuffers={}}}class Sz{get depthRTWrapper(){return this._depthRTWrapper}constructor(e,t,i,r=1){this._engine=e,this._copyTextureToTexture=new I0(e,!0),this._depthRTWrapper=this._engine.createRenderTargetTexture({width:t,height:i},{generateMipMaps:!1,type:0,format:6,samplingMode:1,generateDepthBuffer:!0,generateStencilBuffer:!1,samples:r,noColorAttachment:!0,label:"FluidRenderingDepthTextureCopyRTT"});const s=this._depthRTWrapper.createDepthStencilTexture(0,!1,!1,1,void 0,"FluidRenderingDepthTextureCopyRTTDepthStencil");s.label=`FluidDepthTextureCopy${t}x${i}x${r}`}copy(e){return this._copyTextureToTexture.copy(e,this._depthRTWrapper)}dispose(){this._depthRTWrapper.dispose(),this._copyTextureToTexture.dispose()}}Object.defineProperty(Te.prototype,"fluidRenderer",{get:function(){return this._fluidRenderer},set:function(a){this._fluidRenderer=a},enumerable:!0,configurable:!0});Te.prototype.enableFluidRenderer=function(){return this._fluidRenderer?this._fluidRenderer:(this._fluidRenderer=new sg(this),this._fluidRenderer)};Te.prototype.disableFluidRenderer=function(){var a;(a=this._fluidRenderer)==null||a.dispose(),this._fluidRenderer=null};function vz(a){return!!a.particleSystem}function bz(a){return!!a.addBuffers}class yz{constructor(e){this.name=ge.NAME_FLUIDRENDERER,this.scene=e}register(){this.scene._gatherActiveCameraRenderTargetsStage.registerStep(ge.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER,this,this._gatherActiveCameraRenderTargets),this.scene._afterCameraDrawStage.registerStep(ge.STEP_AFTERCAMERADRAW_FLUIDRENDERER,this,this._afterCameraDraw)}_gatherActiveCameraRenderTargets(e){var t;(t=this.scene.fluidRenderer)==null||t._prepareRendering()}_afterCameraDraw(e){var t;(t=this.scene.fluidRenderer)==null||t._render(e)}rebuild(){const e=this.scene.fluidRenderer;if(!e)return;const t=new Set;for(let i=0;i<e.renderObjects.length;++i){const r=e.renderObjects[i].object;if(bz(r)){const s=r.vertexBuffers;for(const n in s)t.add(s[n].getWrapperBuffer())}}t.forEach(i=>{i._rebuild()})}dispose(){this.scene.disableFluidRenderer()}}class sg{static _SceneComponentInitialization(e){let t=e._getComponent(ge.NAME_FLUIDRENDERER);t||(t=new yz(e),e._addComponent(t))}get shaderLanguage(){return this._shaderLanguage}constructor(e){this._shaderLanguage=0,this._scene=e,this._engine=e.getEngine(),this._onEngineResizeObserver=null,this.renderObjects=[],this.targetRenderers=[],this._cameras=new Map,sg._SceneComponentInitialization(this._scene),this._onEngineResizeObserver=this._engine.onResizeObservable.add(()=>{this._initialize()}),this._engine.isWebGPU&&(this._shaderLanguage=1)}recreate(){this._sortRenderingObjects(),this._initialize()}getRenderObjectFromParticleSystem(e){const t=this._getParticleSystemIndex(e);return t!==-1?this.renderObjects[t]:null}addParticleSystem(e,t,i,r){const s=new gz(this._scene,e,this._shaderLanguage);s.onParticleSizeChanged.add(()=>this._setParticleSizeForRenderTargets()),i||(i=new Pb(this._scene,r,this._shaderLanguage),this.targetRenderers.push(i)),i._onUseVelocityChanged.hasObservers()||i._onUseVelocityChanged.add(()=>this._setUseVelocityForRenderObject()),t!==void 0&&(i.generateDiffuseTexture=t);const n={object:s,targetRenderer:i};return this.renderObjects.push(n),this._sortRenderingObjects(),this._setParticleSizeForRenderTargets(),n}addCustomParticles(e,t,i,r,s){const n=new xz(this._scene,e,t,this._shaderLanguage);n.onParticleSizeChanged.add(()=>this._setParticleSizeForRenderTargets()),r||(r=new Pb(this._scene,s,this._shaderLanguage),this.targetRenderers.push(r)),r._onUseVelocityChanged.hasObservers()||r._onUseVelocityChanged.add(()=>this._setUseVelocityForRenderObject()),i!==void 0&&(r.generateDiffuseTexture=i);const o={object:n,targetRenderer:r};return this.renderObjects.push(o),this._sortRenderingObjects(),this._setParticleSizeForRenderTargets(),o}removeRenderObject(e,t=!0){const i=this.renderObjects.indexOf(e);return i===-1?!1:(e.object.dispose(),this.renderObjects.splice(i,1),t&&this._removeUnusedTargetRenderers()?this._initialize():this._setParticleSizeForRenderTargets(),!0)}_sortRenderingObjects(){this.renderObjects.sort((e,t)=>e.object.priority<t.object.priority?-1:e.object.priority>t.object.priority?1:0)}_removeUnusedTargetRenderers(){const e={};for(let r=0;r<this.renderObjects.length;++r){const s=this.renderObjects[r].targetRenderer;e[this.targetRenderers.indexOf(s)]=!0}let t=!1;const i=[];for(let r=0;r<this.targetRenderers.length;++r)e[r]?i.push(this.targetRenderers[r]):(this.targetRenderers[r].dispose(),t=!0);return t&&(this.targetRenderers.length=0,this.targetRenderers.push(...i)),t}_getParticleSystemIndex(e){for(let t=0;t<this.renderObjects.length;++t){const i=this.renderObjects[t].object;if(vz(i)&&i.particleSystem===e)return t}return-1}_initialize(){for(let i=0;i<this.targetRenderers.length;++i)this.targetRenderers[i].dispose();const e=new Map;for(let i=0;i<this.targetRenderers.length;++i){const r=this.targetRenderers[i];if(r._initialize(),r.camera&&r._renderPostProcess){let s=e.get(r.camera);s||(s=[[],{}],e.set(r.camera,s)),s[0].push(r),r.camera.attachPostProcess(r._renderPostProcess,i)}}let t=e.keys();for(let i=t.next();i.done!==!0;i=t.next()){const r=i.value,s=e.get(r),n=r._getFirstPostProcess();if(!n)continue;const[o,l]=s;n.onSizeChangedObservable.add(()=>{var u;n.inputTexture.depthStencilTexture||n.inputTexture.createDepthStencilTexture(0,!0,this._engine.isStencilEnable,o[0].samples,this._engine.isStencilEnable?13:14,`PostProcessRTTDepthStencil-${n.name}`);for(const c of o){const h=(u=c._thicknessRenderTarget)==null?void 0:u.renderTarget,d=h==null?void 0:h.texture;if(h&&d){const f=d.width+"_"+d.height;let p=l[f];p||(p=l[f]=new Sz(this._engine,d.width,d.height)),p.depthRTWrapper.shareDepth(h)}}})}t=this._cameras.keys();for(let i=t.next();i.done!==!0;i=t.next()){const r=i.value,n=this._cameras.get(r)[1],o=e.get(r);if(o)for(const l in n)o[1][l]||n[l].dispose();else for(const l in n)n[l].dispose()}this._cameras.clear(),this._cameras=e,this._setParticleSizeForRenderTargets()}_setParticleSizeForRenderTargets(){const e=new Map;for(let t=0;t<this.renderObjects.length;++t){const i=this.renderObjects[t];let r=e.get(i.targetRenderer);r===void 0&&(r=0),e.set(i.targetRenderer,Math.max(r,i.object.particleSize))}e.forEach((t,i)=>{i._depthRenderTarget&&(i._depthRenderTarget.particleSize=t)})}_setUseVelocityForRenderObject(){for(const e of this.renderObjects)e.object.useVelocity=e.targetRenderer.useVelocity}_prepareRendering(){for(const e of this.targetRenderers)if(e.needInitialization){this._initialize();return}}_render(e){var i;for(let r=0;r<this.targetRenderers.length;++r)(!e||this.targetRenderers[r].camera===e)&&this.targetRenderers[r]._clearTargets();const t=this._cameras.keys();for(let r=t.next();r.done!==!0;r=t.next()){const s=r.value,n=this._cameras.get(s);if(e&&s!==e)continue;const o=s._getFirstPostProcess();if(!o)continue;const l=(i=o.inputTexture)==null?void 0:i.depthStencilTexture;if(l){const[u,c]=n;for(const h of u)h._bgDepthTexture=l;for(const h in c)c[h].copy(l)}}for(let r=0;r<this.renderObjects.length;++r){const s=this.renderObjects[r];(!e||s.targetRenderer.camera===e)&&s.targetRenderer._render(s.object)}}dispose(){this._engine.onResizeObservable.remove(this._onEngineResizeObserver),this._onEngineResizeObserver=null;for(let e=0;e<this.renderObjects.length;++e)this.renderObjects[e].object.dispose();for(let e=0;e<this.targetRenderers.length;++e)this.targetRenderers[e].dispose();this._cameras.forEach(e=>{const t=e[1];for(const i in t)t[i].dispose()}),this.renderObjects=[],this.targetRenderers=[],this._cameras.clear()}}const Wf="fluidRenderingParticleDepthVertexShader",GE=`attribute vec3 position;attribute vec2 offset;uniform mat4 view;uniform mat4 projection;uniform vec2 size;varying vec2 uv;varying vec3 viewPos;varying float sphereRadius;
#ifdef FLUIDRENDERING_VELOCITY
attribute vec3 velocity;varying float velocityNorm;
#endif
void main(void) {vec3 cornerPos;cornerPos.xy=vec2(offset.x-0.5,offset.y-0.5)*size;cornerPos.z=0.0;viewPos=(view*vec4(position,1.0)).xyz;gl_Position=projection*vec4(viewPos+cornerPos,1.0);uv=offset;sphereRadius=size.x/2.0;
#ifdef FLUIDRENDERING_VELOCITY
velocityNorm=length(velocity);
#endif
}
`;P.ShadersStore[Wf]||(P.ShadersStore[Wf]=GE);const Tz={name:Wf,shader:GE},Cz=Object.freeze(Object.defineProperty({__proto__:null,fluidRenderingParticleDepthVertexShader:Tz},Symbol.toStringTag,{value:"Module"})),$f="fluidRenderingParticleDepthPixelShader",WE=`uniform mat4 projection;varying vec2 uv;varying vec3 viewPos;varying float sphereRadius;
#ifdef FLUIDRENDERING_VELOCITY
varying float velocityNorm;
#endif
void main(void) {vec3 normal;normal.xy=uv*2.0-1.0;float r2=dot(normal.xy,normal.xy);if (r2>1.0) discard;normal.z=sqrt(1.0-r2);
#ifndef FLUIDRENDERING_RHS
normal.z=-normal.z;
#endif
vec4 realViewPos=vec4(viewPos+normal*sphereRadius,1.0);vec4 clipSpacePos=projection*realViewPos;
#ifdef WEBGPU
gl_FragDepth=clipSpacePos.z/clipSpacePos.w;
#else
gl_FragDepth=(clipSpacePos.z/clipSpacePos.w)*0.5+0.5;
#endif
#ifdef FLUIDRENDERING_RHS
realViewPos.z=-realViewPos.z;
#endif
#ifdef FLUIDRENDERING_VELOCITY
glFragColor=vec4(realViewPos.z,velocityNorm,0.,1.);
#else
glFragColor=vec4(realViewPos.z,0.,0.,1.);
#endif
}
`;P.ShadersStore[$f]||(P.ShadersStore[$f]=WE);const Pz={name:$f,shader:WE},Ez=Object.freeze(Object.defineProperty({__proto__:null,fluidRenderingParticleDepthPixelShader:Pz},Symbol.toStringTag,{value:"Module"})),Hf="fluidRenderingParticleThicknessVertexShader",$E=`attribute vec3 position;attribute vec2 offset;uniform mat4 view;uniform mat4 projection;uniform vec2 size;varying vec2 uv;void main(void) {vec3 cornerPos;cornerPos.xy=vec2(offset.x-0.5,offset.y-0.5)*size;cornerPos.z=0.0;vec3 viewPos=(view*vec4(position,1.0)).xyz+cornerPos;gl_Position=projection*vec4(viewPos,1.0);uv=offset;}
`;P.ShadersStore[Hf]||(P.ShadersStore[Hf]=$E);const Iz={name:Hf,shader:$E},Rz=Object.freeze(Object.defineProperty({__proto__:null,fluidRenderingParticleThicknessVertexShader:Iz},Symbol.toStringTag,{value:"Module"})),jf="fluidRenderingParticleThicknessPixelShader",HE=`uniform float particleAlpha;varying vec2 uv;void main(void) {vec3 normal;normal.xy=uv*2.0-1.0;float r2=dot(normal.xy,normal.xy);if (r2>1.0) discard;float thickness=sqrt(1.0-r2);glFragColor=vec4(vec3(particleAlpha*thickness),1.0);}
`;P.ShadersStore[jf]||(P.ShadersStore[jf]=HE);const Mz={name:jf,shader:HE},Az=Object.freeze(Object.defineProperty({__proto__:null,fluidRenderingParticleThicknessPixelShader:Mz},Symbol.toStringTag,{value:"Module"})),Yf="fluidRenderingParticleDiffuseVertexShader",jE=`attribute vec3 position;attribute vec2 offset;attribute vec4 color;uniform mat4 view;uniform mat4 projection;uniform vec2 size;varying vec2 uv;varying vec3 diffuseColor;void main(void) {vec3 cornerPos;cornerPos.xy=vec2(offset.x-0.5,offset.y-0.5)*size;cornerPos.z=0.0;vec3 viewPos=(view*vec4(position,1.0)).xyz+cornerPos;gl_Position=projection*vec4(viewPos,1.0);uv=offset;diffuseColor=color.rgb;}
`;P.ShadersStore[Yf]||(P.ShadersStore[Yf]=jE);const f$={name:Yf,shader:jE},Xf="fluidRenderingParticleDiffusePixelShader",YE=`uniform float particleAlpha;varying vec2 uv;varying vec3 diffuseColor;void main(void) {vec3 normal;normal.xy=uv*2.0-1.0;float r2=dot(normal.xy,normal.xy);if (r2>1.0) discard;glFragColor=vec4(diffuseColor,1.0);}
`;P.ShadersStore[Xf]||(P.ShadersStore[Xf]=YE);const Dz={name:Xf,shader:YE},Oz=Object.freeze(Object.defineProperty({__proto__:null,fluidRenderingParticleDiffusePixelShader:Dz},Symbol.toStringTag,{value:"Module"})),Zf="fluidRenderingBilateralBlurPixelShader",XE=`uniform sampler2D textureSampler;uniform int maxFilterSize;uniform vec2 blurDir;uniform float projectedParticleConstant;uniform float depthThreshold;varying vec2 vUV;void main(void) {float depth=textureLod(textureSampler,vUV,0.).x;if (depth>=1e6 || depth<=0.) {glFragColor=vec4(vec3(depth),1.);return;}
int filterSize=min(maxFilterSize,int(ceil(projectedParticleConstant/depth)));float sigma=float(filterSize)/3.0;float two_sigma2=2.0*sigma*sigma;float sigmaDepth=depthThreshold/3.0;float two_sigmaDepth2=2.0*sigmaDepth*sigmaDepth;float sum=0.;float wsum=0.;float sumVel=0.;for (int x=-filterSize; x<=filterSize; ++x) {vec2 coords=vec2(x);vec2 sampleDepthVel=textureLod(textureSampler,vUV+coords*blurDir,0.).rg;float r=dot(coords,coords);float w=exp(-r/two_sigma2);float rDepth=sampleDepthVel.r-depth;float wd=exp(-rDepth*rDepth/two_sigmaDepth2);sum+=sampleDepthVel.r*w*wd;sumVel+=sampleDepthVel.g*w*wd;wsum+=w*wd;}
glFragColor=vec4(sum/wsum,sumVel/wsum,0.,1.);}
`;P.ShadersStore[Zf]||(P.ShadersStore[Zf]=XE);const wz={name:Zf,shader:XE},Eb=Object.freeze(Object.defineProperty({__proto__:null,fluidRenderingBilateralBlurPixelShader:wz},Symbol.toStringTag,{value:"Module"})),qf="fluidRenderingStandardBlurPixelShader",ZE=`uniform sampler2D textureSampler;uniform int filterSize;uniform vec2 blurDir;varying vec2 vUV;void main(void) {vec4 s=textureLod(textureSampler,vUV,0.);if (s.r==0.) {glFragColor=vec4(0.,0.,0.,1.);return;}
float sigma=float(filterSize)/3.0;float twoSigma2=2.0*sigma*sigma;vec4 sum=vec4(0.);float wsum=0.;for (int x=-filterSize; x<=filterSize; ++x) {vec2 coords=vec2(x);vec4 sampl=textureLod(textureSampler,vUV+coords*blurDir,0.);float w=exp(-coords.x*coords.x/twoSigma2);sum+=sampl*w;wsum+=w;}
sum/=wsum;glFragColor=vec4(sum.rgb,1.);}
`;P.ShadersStore[qf]||(P.ShadersStore[qf]=ZE);const Nz={name:qf,shader:ZE},Ib=Object.freeze(Object.defineProperty({__proto__:null,fluidRenderingStandardBlurPixelShader:Nz},Symbol.toStringTag,{value:"Module"})),Qf="fluidRenderingRenderPixelShader",qE=`#define DISABLE_UNIFORMITY_ANALYSIS
#define IOR 1.333
#define ETA 1.0/IOR
#define F0 0.02
uniform sampler2D textureSampler;uniform sampler2D depthSampler;
#ifdef FLUIDRENDERING_DIFFUSETEXTURE
uniform sampler2D diffuseSampler;
#else
uniform vec3 diffuseColor;
#endif
#ifdef FLUIDRENDERING_FIXED_THICKNESS
uniform float thickness;uniform sampler2D bgDepthSampler;
#else
uniform float minimumThickness;uniform sampler2D thicknessSampler;
#endif
#ifdef FLUIDRENDERING_ENVIRONMENT
uniform samplerCube reflectionSampler;
#endif
#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)
uniform sampler2D debugSampler;
#endif
uniform mat4 viewMatrix;uniform mat4 projectionMatrix;uniform mat4 invProjectionMatrix;uniform vec2 texelSize;uniform vec3 dirLight;uniform float cameraFar;uniform float density;uniform float refractionStrength;uniform float fresnelClamp;uniform float specularPower;varying vec2 vUV;vec3 computeViewPosFromUVDepth(vec2 texCoord,float depth) {vec4 ndc;ndc.xy=texCoord*2.0-1.0;
#ifdef FLUIDRENDERING_RHS
ndc.z=-projectionMatrix[2].z+projectionMatrix[3].z/depth;
#else
ndc.z=projectionMatrix[2].z+projectionMatrix[3].z/depth;
#endif
ndc.w=1.0;vec4 eyePos=invProjectionMatrix*ndc;eyePos.xyz/=eyePos.w;return eyePos.xyz;}
vec3 getViewPosFromTexCoord(vec2 texCoord) {float depth=textureLod(depthSampler,texCoord,0.).x;return computeViewPosFromUVDepth(texCoord,depth);}
void main(void) {vec2 texCoord=vUV;
#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)
vec4 color=texture2D(debugSampler,texCoord);
#ifdef FLUIDRENDERING_DEBUG_DEPTH
glFragColor=vec4(color.rgb/vec3(2.0),1.);if (color.r>0.999 && color.g>0.999) {glFragColor=texture2D(textureSampler,texCoord);}
#else
glFragColor=vec4(color.rgb,1.);if (color.r<0.001 && color.g<0.001 && color.b<0.001) {glFragColor=texture2D(textureSampler,texCoord);}
#endif
return;
#endif
vec2 depthVel=textureLod(depthSampler,texCoord,0.).rg;float depth=depthVel.r;
#ifndef FLUIDRENDERING_FIXED_THICKNESS
float thickness=texture2D(thicknessSampler,texCoord).x;
#else
float bgDepth=texture2D(bgDepthSampler,texCoord).x;float depthNonLinear=projectionMatrix[2].z+projectionMatrix[3].z/depth;depthNonLinear=depthNonLinear*0.5+0.5;
#endif
vec4 backColor=texture2D(textureSampler,texCoord);
#ifndef FLUIDRENDERING_FIXED_THICKNESS
if (depth>=cameraFar || depth<=0. || thickness<=minimumThickness) {
#else
if (depth>=cameraFar || depth<=0. || bgDepth<=depthNonLinear) {
#endif
#ifdef FLUIDRENDERING_COMPOSITE_MODE
glFragColor.rgb=backColor.rgb*backColor.a;glFragColor.a=backColor.a;
#else
glFragColor=backColor;
#endif
return;}
vec3 viewPos=computeViewPosFromUVDepth(texCoord,depth);vec3 ddx=getViewPosFromTexCoord(texCoord+vec2(texelSize.x,0.))-viewPos;vec3 ddy=getViewPosFromTexCoord(texCoord+vec2(0.,texelSize.y))-viewPos;vec3 ddx2=viewPos-getViewPosFromTexCoord(texCoord+vec2(-texelSize.x,0.));if (abs(ddx.z)>abs(ddx2.z)) {ddx=ddx2;}
vec3 ddy2=viewPos-getViewPosFromTexCoord(texCoord+vec2(0.,-texelSize.y));if (abs(ddy.z)>abs(ddy2.z)) {ddy=ddy2;}
vec3 normal=normalize(cross(ddy,ddx));
#ifdef FLUIDRENDERING_RHS
normal=-normal;
#endif
#ifndef WEBGPU
if(isnan(normal.x) || isnan(normal.y) || isnan(normal.z) || isinf(normal.x) || isinf(normal.y) || isinf(normal.z)) {normal=vec3(0.,0.,-1.);}
#endif
#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_SHOWNORMAL)
glFragColor=vec4(normal*0.5+0.5,1.0);return;
#endif
vec3 rayDir=normalize(viewPos); 
#ifdef FLUIDRENDERING_DIFFUSETEXTURE
vec3 diffuseColor=textureLod(diffuseSampler,texCoord,0.0).rgb;
#endif
vec3 lightDir=normalize(vec3(viewMatrix*vec4(-dirLight,0.)));vec3 H =normalize(lightDir-rayDir);float specular=pow(max(0.0,dot(H,normal)),specularPower);
#ifdef FLUIDRENDERING_DEBUG_DIFFUSERENDERING
float diffuse =max(0.0,dot(lightDir,normal))*1.0;glFragColor=vec4(vec3(0.1) /*ambient*/+vec3(0.42,0.50,1.00)*diffuse+vec3(0,0,0.2)+specular,1.);return;
#endif
vec3 refractionDir=refract(rayDir,normal,ETA);vec4 transmitted=textureLod(textureSampler,vec2(texCoord+refractionDir.xy*thickness*refractionStrength),0.0);
#ifdef FLUIDRENDERING_COMPOSITE_MODE
if (transmitted.a==0.) transmitted.a=thickness;
#endif
vec3 transmittance=exp(-density*thickness*(1.0-diffuseColor)); 
vec3 refractionColor=transmitted.rgb*transmittance;
#ifdef FLUIDRENDERING_ENVIRONMENT
vec3 reflectionDir=reflect(rayDir,normal);vec3 reflectionColor=(textureCube(reflectionSampler,reflectionDir).rgb);float fresnel=clamp(F0+(1.0-F0)*pow(1.0-dot(normal,-rayDir),5.0),0.,fresnelClamp);vec3 finalColor=mix(refractionColor,reflectionColor,fresnel)+specular;
#else
vec3 finalColor=refractionColor+specular;
#endif
#ifdef FLUIDRENDERING_VELOCITY
float velocity=depthVel.g;finalColor=mix(finalColor,vec3(1.0),smoothstep(0.3,1.0,velocity/6.0));
#endif
glFragColor=vec4(finalColor,transmitted.a);}
`;P.ShadersStore[Qf]||(P.ShadersStore[Qf]=qE);const Fz={name:Qf,shader:qE},Lz=Object.freeze(Object.defineProperty({__proto__:null,fluidRenderingRenderPixelShader:Fz},Symbol.toStringTag,{value:"Module"})),Kf="fluidRenderingParticleDepthVertexShader",QE=`attribute position: vec3f;attribute offset: vec2f;uniform view: mat4x4f;uniform projection: mat4x4f;uniform size: vec2f;varying uv: vec2f;varying viewPos: vec3f;varying sphereRadius: f32;
#ifdef FLUIDRENDERING_VELOCITY
attribute velocity: vec3f;varying velocityNorm: f32;
#endif
@vertex
fn main(input: VertexInputs)->FragmentInputs {var cornerPos: vec3f=vec3f(
vec2f(input.offset.x-0.5,input.offset.y-0.5)*uniforms.size,
0.0
);vertexOutputs.viewPos=(uniforms.view*vec4f(input.position,1.0)).xyz;vertexOutputs.position=uniforms.projection*vec4f(vertexOutputs.viewPos+cornerPos,1.0);vertexOutputs.uv=input.offset;vertexOutputs.sphereRadius=uniforms.size.x/2.0;
#ifdef FLUIDRENDERING_VELOCITY
vertexOutputs.velocityNorm=length(velocity);
#endif
}
`;P.ShadersStoreWGSL[Kf]||(P.ShadersStoreWGSL[Kf]=QE);const Bz={name:Kf,shader:QE},Vz=Object.freeze(Object.defineProperty({__proto__:null,fluidRenderingParticleDepthVertexShaderWGSL:Bz},Symbol.toStringTag,{value:"Module"})),Jf="fluidRenderingParticleDepthPixelShader",KE=`uniform projection: mat4x4f;varying uv: vec2f;varying viewPos: vec3f;varying sphereRadius: f32;
#ifdef FLUIDRENDERING_VELOCITY
varying velocityNorm: f32;
#endif
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var normalxy: vec2f=input.uv*2.0-1.0;var r2: f32=dot(normalxy,normalxy);if (r2>1.0) {discard;}
var normal: vec3f=vec3f(normalxy,sqrt(1.0-r2));
#ifndef FLUIDRENDERING_RHS
normal.z=-normal.z;
#endif
var realViewPos: vec4f=vec4f(input.viewPos+normal*input.sphereRadius,1.0);var clipSpacePos: vec4f=uniforms.projection*realViewPos;fragmentOutputs.fragDepth=clipSpacePos.z/clipSpacePos.w;
#ifdef FLUIDRENDERING_RHS
realViewPos.z=-realViewPos.z;
#endif
#ifdef FLUIDRENDERING_VELOCITY
fragmentOutputs.color=vec4f(realViewPos.z,input.velocityNorm,0.,1.);
#else
fragmentOutputs.color=vec4f(realViewPos.z,0.,0.,1.);
#endif
}
`;P.ShadersStoreWGSL[Jf]||(P.ShadersStoreWGSL[Jf]=KE);const kz={name:Jf,shader:KE},zz=Object.freeze(Object.defineProperty({__proto__:null,fluidRenderingParticleDepthPixelShaderWGSL:kz},Symbol.toStringTag,{value:"Module"})),ep="fluidRenderingParticleThicknessVertexShader",JE=`attribute position: vec3f;attribute offset: vec2f;uniform view: mat4x4f;uniform projection: mat4x4f;uniform size: vec2f;varying uv: vec2f;@vertex
fn main(input: VertexInputs)->FragmentInputs {var cornerPos: vec3f=vec3f(
vec2f(input.offset.x-0.5,input.offset.y-0.5)*uniforms.size,
0.0
);var viewPos: vec3f=(uniforms.view*vec4f(input.position,1.0)).xyz+cornerPos;vertexOutputs.position=uniforms.projection*vec4f(viewPos,1.0);vertexOutputs.uv=input.offset;}
`;P.ShadersStoreWGSL[ep]||(P.ShadersStoreWGSL[ep]=JE);const Uz={name:ep,shader:JE},Gz=Object.freeze(Object.defineProperty({__proto__:null,fluidRenderingParticleThicknessVertexShaderWGSL:Uz},Symbol.toStringTag,{value:"Module"})),tp="fluidRenderingParticleThicknessPixelShader",eI=`uniform particleAlpha: f32;varying uv: vec2f;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var normalxy: vec2f=input.uv*2.0-1.0;var r2: f32=dot(normalxy,normalxy);if (r2>1.0) {discard;}
var thickness: f32=sqrt(1.0-r2);fragmentOutputs.color=vec4f(vec3f(uniforms.particleAlpha*thickness),1.0);}
`;P.ShadersStoreWGSL[tp]||(P.ShadersStoreWGSL[tp]=eI);const Wz={name:tp,shader:eI},$z=Object.freeze(Object.defineProperty({__proto__:null,fluidRenderingParticleThicknessPixelShaderWGSL:Wz},Symbol.toStringTag,{value:"Module"})),ip="fluidRenderingParticleDiffuseVertexShader",tI=`attribute position: vec3f;attribute offset: vec2f;attribute color: vec4f;uniform view: mat4x4f;uniform projection: mat4x4f;uniform size: vec2f;varying uv: vec2f;varying diffuseColor: vec3f;@vertex
fn main(input: VertexInputs)->FragmentInputs {var cornerPos: vec3f=vec3f(
vec2f(input.offset.x-0.5,input.offset.y-0.5)*uniforms.size,
0.0
);var viewPos: vec3f=(uniforms.view*vec4f(input.position,1.0)).xyz+cornerPos;vertexOutputs.position=uniforms.projection*vec4f(viewPos,1.0);vertexOutputs.uv=input.offset;vertexOutputs.diffuseColor=input.color.rgb;}
`;P.ShadersStoreWGSL[ip]||(P.ShadersStoreWGSL[ip]=tI);const p$={name:ip,shader:tI},rp="fluidRenderingParticleDiffusePixelShader",iI=`uniform particleAlpha: f32;varying uv: vec2f;varying diffuseColor: vec3f;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var normalxy: vec2f=input.uv*2.0-1.0;var r2: f32=dot(normalxy,normalxy);if (r2>1.0) {discard;}
fragmentOutputs.color=vec4f(input.diffuseColor,1.0);}
`;P.ShadersStoreWGSL[rp]||(P.ShadersStoreWGSL[rp]=iI);const Hz={name:rp,shader:iI},jz=Object.freeze(Object.defineProperty({__proto__:null,fluidRenderingParticleDiffusePixelShaderWGSL:Hz},Symbol.toStringTag,{value:"Module"})),sp="fluidRenderingBilateralBlurPixelShader",rI=`var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform maxFilterSize: i32;uniform blurDir: vec2f;uniform projectedParticleConstant: f32;uniform depthThreshold: f32;varying vUV: vec2f;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var depth: f32=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.).x;if (depth>=1e6 || depth<=0.) {fragmentOutputs.color=vec4f(vec3f(depth),1.);return fragmentOutputs;}
var filterSize: i32=min(uniforms.maxFilterSize,i32(ceil(uniforms.projectedParticleConstant/depth)));var sigma: f32=f32(filterSize)/3.0;var two_sigma2: f32=2.0*sigma*sigma;var sigmaDepth: f32=uniforms.depthThreshold/3.0;var two_sigmaDepth2: f32=2.0*sigmaDepth*sigmaDepth;var sum: f32=0.;var wsum: f32=0.;var sumVel: f32=0.;for (var x: i32=-filterSize; x<=filterSize; x++) {var coords: vec2f=vec2f(f32(x));var sampleDepthVel: vec2f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV+coords*uniforms.blurDir,0.).rg;var r: f32=dot(coords,coords);var w: f32=exp(-r/two_sigma2);var rDepth: f32=sampleDepthVel.r-depth;var wd: f32=exp(-rDepth*rDepth/two_sigmaDepth2);sum+=sampleDepthVel.r*w*wd;sumVel+=sampleDepthVel.g*w*wd;wsum+=w*wd;}
fragmentOutputs.color=vec4f(sum/wsum,sumVel/wsum,0.,1.);}
`;P.ShadersStoreWGSL[sp]||(P.ShadersStoreWGSL[sp]=rI);const Yz={name:sp,shader:rI},Rb=Object.freeze(Object.defineProperty({__proto__:null,fluidRenderingBilateralBlurPixelShaderWGSL:Yz},Symbol.toStringTag,{value:"Module"})),np="fluidRenderingStandardBlurPixelShader",sI=`var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform filterSize: i32;uniform blurDir: vec2f;varying vUV: vec2f;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var s: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.);if (s.r==0.) {fragmentOutputs.color=vec4f(0.,0.,0.,1.);return fragmentOutputs;}
var sigma: f32=f32(uniforms.filterSize)/3.0;var twoSigma2: f32=2.0*sigma*sigma;var sum: vec4f=vec4f(0.);var wsum: f32=0.;for (var x: i32=-uniforms.filterSize; x<=uniforms.filterSize; x++) {var coords: vec2f=vec2f(f32(x));var sampl: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV+coords*uniforms.blurDir,0.);var w: f32=exp(-coords.x*coords.x/twoSigma2);sum+=sampl*w;wsum+=w;}
sum/=wsum;fragmentOutputs.color=vec4f(sum.rgb,1.);}
`;P.ShadersStoreWGSL[np]||(P.ShadersStoreWGSL[np]=sI);const Xz={name:np,shader:sI},Mb=Object.freeze(Object.defineProperty({__proto__:null,fluidRenderingStandardBlurPixelShaderWGSL:Xz},Symbol.toStringTag,{value:"Module"})),ap="fluidRenderingRenderPixelShader",nI=`#define DISABLE_UNIFORMITY_ANALYSIS
#define IOR 1.333
#define ETA 1.0/IOR
#define F0 0.02
var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var depthSamplerSampler: sampler;var depthSampler: texture_2d<f32>;
#ifdef FLUIDRENDERING_DIFFUSETEXTURE
var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;
#else
uniform diffuseColor: vec3f;
#endif
#ifdef FLUIDRENDERING_FIXED_THICKNESS
uniform thickness: f32;var bgDepthSamplerSampler: sampler;var bgDepthSampler: texture_2d<f32>;
#else
uniform minimumThickness: f32;var thicknessSamplerSampler: sampler;var thicknessSampler: texture_2d<f32>;
#endif
#ifdef FLUIDRENDERING_ENVIRONMENT
var reflectionSamplerSampler: sampler;var reflectionSampler: texture_cube<f32>;
#endif
#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)
var debugSamplerSampler: sampler;var debugSampler: texture_2d<f32>;
#endif
uniform viewMatrix: mat4x4f;uniform projectionMatrix: mat4x4f;uniform invProjectionMatrix: mat4x4f;uniform texelSize: vec2f;uniform dirLight: vec3f;uniform cameraFar: f32;uniform density: f32;uniform refractionStrength: f32;uniform fresnelClamp: f32;uniform specularPower: f32;varying vUV: vec2f;fn computeViewPosFromUVDepth(texCoord: vec2f,depth: f32)->vec3f {var ndc: vec4f=vec4f(texCoord*2.0-1.0,0.0,1.0);
#ifdef FLUIDRENDERING_RHS
ndc.z=-uniforms.projectionMatrix[2].z+uniforms.projectionMatrix[3].z/depth;
#else
ndc.z=uniforms.projectionMatrix[2].z+uniforms.projectionMatrix[3].z/depth;
#endif
ndc.w=1.0;var eyePos: vec4f=uniforms.invProjectionMatrix*ndc;return eyePos.xyz/eyePos.w;}
fn getViewPosFromTexCoord(texCoord: vec2f)->vec3f {var depth: f32=textureSampleLevel(depthSampler,depthSamplerSampler,texCoord,0.).x;return computeViewPosFromUVDepth(texCoord,depth);}
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var texCoord: vec2f=input.vUV;
#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)
var color: vec4f=textureSample(debugSampler,debugSamplerSampler,texCoord);
#ifdef FLUIDRENDERING_DEBUG_DEPTH
fragmentOutputs.color=vec4f(color.rgb/vec3f(2.0),1.);if (color.r>0.999 && color.g>0.999) {fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,texCoord);}
#else
fragmentOutputs.color=vec4f(color.rgb,1.);if (color.r<0.001 && color.g<0.001 && color.b<0.001) {fragmentOutputs.color=textureSample(textureSampler,textureSamplerSampler,texCoord);}
#endif
return fragmentOutputs;
#endif
var depthVel: vec2f=textureSampleLevel(depthSampler,depthSamplerSampler,texCoord,0.).rg;var depth: f32=depthVel.r;
#ifndef FLUIDRENDERING_FIXED_THICKNESS
var thickness: f32=textureSample(thicknessSampler,thicknessSamplerSampler,texCoord).x;
#else
var thickness: f32=uniforms.thickness;var bgDepth: f32=textureSample(bgDepthSampler,bgDepthSamplerSampler,texCoord).x;var depthNonLinear: f32=uniforms.projectionMatrix[2].z+uniforms.projectionMatrix[3].z/depth;depthNonLinear=depthNonLinear*0.5+0.5;
#endif
var backColor: vec4f=textureSample(textureSampler,textureSamplerSampler,texCoord);
#ifndef FLUIDRENDERING_FIXED_THICKNESS
if (depth>=uniforms.cameraFar || depth<=0. || thickness<=uniforms.minimumThickness) {
#else
if (depth>=uniforms.cameraFar || depth<=0. || bgDepth<=depthNonLinear) {
#endif
#ifdef FLUIDRENDERING_COMPOSITE_MODE
fragmentOutputs.color=vec4f(backColor.rgb*backColor.a,backColor.a);
#else
fragmentOutputs.color=backColor;
#endif
return fragmentOutputs;}
var viewPos: vec3f=computeViewPosFromUVDepth(texCoord,depth);var ddx: vec3f=getViewPosFromTexCoord(texCoord+vec2f(uniforms.texelSize.x,0.))-viewPos;var ddy: vec3f=getViewPosFromTexCoord(texCoord+vec2f(0.,uniforms.texelSize.y))-viewPos;var ddx2: vec3f=viewPos-getViewPosFromTexCoord(texCoord+vec2f(-uniforms.texelSize.x,0.));if (abs(ddx.z)>abs(ddx2.z)) {ddx=ddx2;}
var ddy2: vec3f=viewPos-getViewPosFromTexCoord(texCoord+vec2f(0.,-uniforms.texelSize.y));if (abs(ddy.z)>abs(ddy2.z)) {ddy=ddy2;}
var normal: vec3f=normalize(cross(ddy,ddx));
#ifdef FLUIDRENDERING_RHS
normal=-normal;
#endif
#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_SHOWNORMAL)
fragmentOutputs.color=vec4f(normal*0.5+0.5,1.0);return fragmentOutputs;
#endif
var rayDir: vec3f=normalize(viewPos); 
#ifdef FLUIDRENDERING_DIFFUSETEXTURE
var diffuseColor: vec3f=textureSampleLevel(diffuseSampler,diffuseSamplerSampler,texCoord,0.0).rgb;
#else
var diffuseColor: vec3f=uniforms.diffuseColor;
#endif
var lightDir: vec3f=normalize((uniforms.viewMatrix*vec4f(-uniforms.dirLight,0.)).xyz);var H: vec3f =normalize(lightDir-rayDir);var specular: f32 =pow(max(0.0,dot(H,normal)),uniforms.specularPower);
#ifdef FLUIDRENDERING_DEBUG_DIFFUSERENDERING
var diffuse: f32 =max(0.0,dot(lightDir,normal))*1.0;fragmentOutputs.color=vec4f(vec3f(0.1) /*ambient*/+vec3f(0.42,0.50,1.00)*diffuse+vec3f(0,0,0.2)+specular,1.);return fragmentOutputs;
#endif
var refractionDir: vec3f=refract(rayDir,normal,ETA);var transmitted: vec4f=textureSampleLevel(textureSampler,textureSamplerSampler,vec2f(texCoord+refractionDir.xy*thickness*uniforms.refractionStrength),0.0);
#ifdef FLUIDRENDERING_COMPOSITE_MODE
if (transmitted.a==0.) {transmitted.a=thickness;}
#endif
var transmittance: vec3f=exp(-uniforms.density*thickness*(1.0-diffuseColor)); 
var refractionColor: vec3f=transmitted.rgb*transmittance;
#ifdef FLUIDRENDERING_ENVIRONMENT
var reflectionDir: vec3f=reflect(rayDir,normal);var reflectionColor: vec3f=(textureSample(reflectionSampler,reflectionSamplerSampler,reflectionDir).rgb);var fresnel: f32=clamp(F0+(1.0-F0)*pow(1.0-dot(normal,-rayDir),5.0),0.,uniforms.fresnelClamp);var finalColor: vec3f=mix(refractionColor,reflectionColor,fresnel)+specular;
#else
var finalColor: vec3f=refractionColor+specular;
#endif
#ifdef FLUIDRENDERING_VELOCITY
var velocity: f32=depthVel.g;finalColor=mix(finalColor,vec3f(1.0),smoothstep(0.3,1.0,velocity/6.0));
#endif
fragmentOutputs.color=vec4f(finalColor,transmitted.a);}
`;P.ShadersStoreWGSL[ap]||(P.ShadersStoreWGSL[ap]=nI);const Zz={name:ap,shader:nI},qz=Object.freeze(Object.defineProperty({__proto__:null,fluidRenderingRenderPixelShaderWGSL:Zz},Symbol.toStringTag,{value:"Module"}));class m${get enable(){return this._enable}set enable(e){this._enable!==e&&(this._enable=e,this._customRenderTarget(e))}get positionWorldTexture(){return this._mrt.textures[0]}get normalWorldTexture(){return this._mrt.textures[1]}get fluxTexture(){return this._mrt.textures[2]}get renderList(){return this._mrt.renderList}get light(){return this._light}constructor(e,t,i={width:512,height:512}){this._lightTransformMatrix=$.Identity(),this._enable=!1,this.forceUpdateLightParameters=!1,this._scene=e,this._light=t,this._textureDimensions=i,this._regularMatToMatWithPlugin=new Map,this._counters=[{name:"RSM Generation "+t.name,value:0}],this._createMultiRenderTarget(),this._recomputeLightTransformationMatrix(),this.enable=!0}setTextureDimensions(e){const t=this._mrt.renderList;this._textureDimensions=e,this._disposeMultiRenderTarget(),this._createMultiRenderTarget(),t==null||t.forEach(i=>{this._addMeshToMRT(i)})}addMesh(e){e?this._addMeshToMRT(e):this._scene.meshes.forEach(t=>{this._addMeshToMRT(t)}),this._recomputeLightTransformationMatrix()}updateLightParameters(){this._recomputeLightTransformationMatrix()}get lightTransformationMatrix(){return this.forceUpdateLightParameters&&this.updateLightParameters(),this._lightTransformMatrix}get countersGPU(){return this._counters}dispose(){this._disposeMultiRenderTarget()}_createMultiRenderTarget(){const e=this._light.name,t=this._scene.getEngine().getCaps(),i=t.rg11b10ufColorRenderable?13:2,r=t.rg11b10ufColorRenderable?4:5;this._mrt=new Zs("RSMmrt_"+e,this._textureDimensions,3,this._scene,{types:[2,11,i],samplingModes:[2,2,2],generateMipMaps:!1,targetTypes:[3553,3553,3553],formats:[5,5,r]},["RSMPosition_"+e,"RSMNormal_"+e,"RSMFlux_"+e]),this._mrt.renderList=[],this._mrt.clearColor=new xe(0,0,0,1),this._mrt.noPrePassRenderer=!0;let s,n;const o=this._scene.getEngine().supportsUniformBuffers;o&&(s=this._scene.createSceneUniformBuffer(`Scene for RSM (light "${e}")`));let l;this._mrt.onBeforeBindObservable.add(()=>{n=this._scene.getSceneUniformBuffer(),l=this._light.shadowEnabled,this._light.shadowEnabled=!1}),this._mrt.onBeforeRenderObservable.add(u=>{s&&this._scene.setSceneUniformBuffer(s);const c=this._light.getViewMatrix(u),h=this._light.getProjectionMatrix(c||void 0,this._mrt.renderList||void 0);c&&h&&this._scene.setTransformMatrix(c,h),o&&(this._scene.getSceneUniformBuffer().unbindEffect(),this._scene.finalizeSceneUbo())}),this._mrt.onAfterUnbindObservable.add(()=>{var u;s&&this._scene.setSceneUniformBuffer(n),this._scene.updateTransformMatrix(),this._light.shadowEnabled=l,this._counters[0].value=((u=this._mrt.renderTarget.gpuTimeInFrame)==null?void 0:u.counter.lastSecAverage)??0}),this._customRenderTarget(!0)}_customRenderTarget(e){const t=this._scene.customRenderTargets.indexOf(this._mrt);e?t===-1&&this._scene.customRenderTargets.push(this._mrt):t!==-1&&this._scene.customRenderTargets.splice(t,1)}_recomputeLightTransformationMatrix(){const e=this._light.getViewMatrix(),t=this._light.getProjectionMatrix(e||void 0,this._mrt.renderList||void 0);e&&t&&e.multiplyToRef(t,this._lightTransformMatrix)}_addMeshToMRT(e){var r;(r=this._mrt.renderList)==null||r.push(e);const t=e.material;if(e.getTotalVertices()===0||!t)return;let i=this._regularMatToMatWithPlugin.get(t);if(!i&&(i=t.clone("RSMCreate_"+t.name)||void 0,i)){Object.defineProperty(i,"canRenderToMRT",{get:function(){return!1},enumerable:!0,configurable:!0}),i.disableLighting=!0;const s=new aa(i);s.isEnabled=!0,s.light=this._light,this._regularMatToMatWithPlugin.set(t,i)}this._mrt.setMaterialForRendering(e,i)}_disposeMultiRenderTarget(){this._customRenderTarget(!1),this._mrt.dispose()}}class Qz extends ps{constructor(){super(...arguments),this.RSMCREATE=!1,this.RSMCREATE_PROJTEXTURE=!1,this.RSMCREATE_LIGHT_IS_SPOT=!1}}class aa extends Qn{_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}isCompatible(){return!0}constructor(e){super(e,aa.Name,300,new Qz),this._lightColor=new ne,this._hasProjectionTexture=!1,this._isEnabled=!1,this.isEnabled=!1,this._internalMarkAllSubMeshesAsTexturesDirty=e._dirtyCallbacks[1],this._varAlbedoName=e instanceof hr?"surfaceAlbedo":"baseColor.rgb"}prepareDefines(e){e.RSMCREATE=this._isEnabled,this._hasProjectionTexture=!1;const t=this.light.getTypeID()===rs.LIGHTTYPEID_SPOTLIGHT;if(t){const i=this.light;this._hasProjectionTexture=i.projectionTexture?i.projectionTexture.isReady():!1}e.RSMCREATE_PROJTEXTURE=this._hasProjectionTexture,e.RSMCREATE_LIGHT_IS_SPOT=t,e.SCENE_MRT_COUNT=3}getClassName(){return"RSMCreatePluginMaterial"}getUniforms(){return{ubo:[{name:"rsmTextureProjectionMatrix",size:16,type:"mat4"},{name:"rsmSpotInfo",size:4,type:"vec4"},{name:"rsmLightColor",size:3,type:"vec3"},{name:"rsmLightPosition",size:3,type:"vec3"}],fragment:`#ifdef RSMCREATE
                    uniform mat4 rsmTextureProjectionMatrix;
                    uniform vec4 rsmSpotInfo;
                    uniform vec3 rsmLightColor;
                    uniform vec3 rsmLightPosition;
                #endif`}}getSamplers(e){e.push("rsmTextureProjectionSampler")}bindForSubMesh(e){if(this._isEnabled&&(this.light.diffuse.scaleToRef(this.light.getScaledIntensity(),this._lightColor),e.updateColor3("rsmLightColor",this._lightColor),this.light.getTypeID()===rs.LIGHTTYPEID_SPOTLIGHT)){const t=this.light;this._hasProjectionTexture&&(e.updateMatrix("rsmTextureProjectionMatrix",t.projectionTextureMatrix),e.setTexture("rsmTextureProjectionSampler",t.projectionTexture));const i=V.Vector3[0];t.computeTransformedInformation()?(e.updateFloat3("rsmLightPosition",this.light.transformedPosition.x,this.light.transformedPosition.y,this.light.transformedPosition.z),t.transformedDirection.normalizeToRef(i)):(e.updateFloat3("rsmLightPosition",this.light.position.x,this.light.position.y,this.light.position.z),t.direction.normalizeToRef(i)),e.updateFloat4("rsmSpotInfo",i.x,i.y,i.z,Math.cos(t.angle*.5))}}getCustomCode(e,t){return e==="vertex"?null:t===1?{CUSTOM_FRAGMENT_DEFINITIONS:`
                #ifdef RSMCREATE
                    #ifdef RSMCREATE_PROJTEXTURE
                        var rsmTextureProjectionSamplerSampler: sampler;
                        var rsmTextureProjectionSampler: texture_2d<f32>;
                    #endif
                #endif
            `,CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:`
                #ifdef RSMCREATE
                    var rsmColor = ${this._varAlbedoName} * uniforms.rsmLightColor;
                    #ifdef RSMCREATE_PROJTEXTURE
                    {
                        var strq = uniforms.rsmTextureProjectionMatrix * vec4f(fragmentInputs.vPositionW, 1.0);
                        strq /= strq.w;
                        rsmColor *= textureSample(rsmTextureProjectionSampler, rsmTextureProjectionSamplerSampler, strq.xy).rgb;
                    }
                    #endif
                    #ifdef RSMCREATE_LIGHT_IS_SPOT
                    {
                        var cosAngle = max(0., dot(uniforms.rsmSpotInfo.xyz, normalize(fragmentInputs.vPositionW - uniforms.rsmLightPosition)));
                        rsmColor = sign(cosAngle - uniforms.rsmSpotInfo.w) * rsmColor;
                    }
                    #endif

                    #define MRT_AND_COLOR
                    fragmentOutputs.fragData0 = vec4f(fragmentInputs.vPositionW, 1.);
                    fragmentOutputs.fragData1 = vec4f(normalize(normalW) * 0.5 + 0.5, 1.);
                    fragmentOutputs.fragData2 = vec4f(rsmColor, 1.);
                #endif
            `}:{CUSTOM_FRAGMENT_BEGIN:`
                #ifdef RSMCREATE
                    #extension GL_EXT_draw_buffers : require
                #endif
            `,CUSTOM_FRAGMENT_DEFINITIONS:`
                #ifdef RSMCREATE
                    #ifdef RSMCREATE_PROJTEXTURE
                        uniform highp sampler2D rsmTextureProjectionSampler;                    
                    #endif
                    layout(location = 0) out highp vec4 glFragData[3];
                    vec4 glFragColor;
                #endif
            `,CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:`
                #ifdef RSMCREATE
                    vec3 rsmColor = ${this._varAlbedoName} * rsmLightColor;
                    #ifdef RSMCREATE_PROJTEXTURE
                    {
                        vec4 strq = rsmTextureProjectionMatrix * vec4(vPositionW, 1.0);
                        strq /= strq.w;
                        rsmColor *= texture2D(rsmTextureProjectionSampler, strq.xy).rgb;
                    }
                    #endif
                    #ifdef RSMCREATE_LIGHT_IS_SPOT
                    {
                        float cosAngle = max(0., dot(rsmSpotInfo.xyz, normalize(vPositionW - rsmLightPosition)));
                        rsmColor = sign(cosAngle - rsmSpotInfo.w) * rsmColor;
                    }
                    #endif
                    glFragData[0] = vec4(vPositionW, 1.);
                    glFragData[1] = vec4(normalize(normalW) * 0.5 + 0.5, 1.);
                    glFragData[2] = vec4(rsmColor, 1.);
                #endif
            `}}}aa.Name="RSMCreate";C([F()],aa.prototype,"light",void 0);C([F(),Ue("_markAllSubMeshesAsTexturesDirty")],aa.prototype,"isEnabled",void 0);B("BABYLON.RSMCreatePluginMaterial",aa);class ng{get enable(){return this._enable}set enable(e){this._giRSM.length===0&&(e=!1),e!==this._enable&&(this._enable=e,this._debugLayer.isEnabled=this._showOnlyGI&&e,this._materialsWithRenderPlugin.forEach(t=>{if(t.pluginManager){const i=t.pluginManager.getPlugin(br.Name);i.isEnabled=e}}),this.recreateResources(!e))}get enableBlur(){return this._enableBlur}set enableBlur(e){e!==this._enableBlur&&(this._enableBlur=e,this.recreateResources())}get useQualityBlur(){return this._useQualityBlur}set useQualityBlur(e){e!==this._useQualityBlur&&(this._useQualityBlur=e,this.recreateResources())}get fullSizeBlur(){return this._forceFullSizeBlur}set fullSizeBlur(e){this._forceFullSizeBlur!==e&&(this._forceFullSizeBlur=e,this.recreateResources())}get useQualityUpsampling(){return this._useQualityUpsampling}set useQualityUpsampling(e){e!==this._useQualityUpsampling&&(this._useQualityUpsampling=e,this.recreateResources())}get showOnlyGI(){return this._showOnlyGI}set showOnlyGI(e){this._showOnlyGI!==e&&(this._showOnlyGI=e,this._debugLayer.isEnabled=e)}get use32BitsDepthBuffer(){return this._use32BitsDepthBuffer}set use32BitsDepthBuffer(e){this._use32BitsDepthBuffer!==e&&(this._use32BitsDepthBuffer=e,this.recreateResources())}setOutputDimensions(e){this._outputDimensions=e,this.recreateResources()}setGITextureDimensions(e){this._giTextureDimensions=e,this.recreateResources()}get giTextureType(){return this._giTextureType}set giTextureType(e){this._giTextureType!==e&&(this._giTextureType=e,this.recreateResources())}get shaderLanguage(){return this._shaderLanguage}get giRSM(){return this._giRSM}addGIRSM(e){Array.isArray(e)?this._giRSM.push(...e):this._giRSM.push(e),this.recreateResources()}removeGIRSM(e){if(Array.isArray(e))for(let t=0;t<e.length;++t){const i=this._giRSM.indexOf(e[t]);i!==-1&&this._giRSM.splice(i,1)}else{const t=this._giRSM.indexOf(e);t!==-1&&this._giRSM.splice(t,1)}this._giRSM.length===0?this.enable=!1:this.recreateResources()}addMaterial(e){e?this._addGISupportToMaterial(e):this._scene.meshes.forEach(t=>{t.getTotalVertices()>0&&t.isEnabled()&&t.material&&this._addGISupportToMaterial(t.material)})}get countersGPU(){return this._counters}recreateResources(e=!1){if(!this._shadersLoaded){this._onShaderLoadedObservable.addOnce(()=>{this.recreateResources(e)});return}this._disposePostProcesses(e),this._createPostProcesses(),this._setPluginParameters()}generateSampleTexture(e){var i;(i=this._sampleTexture)==null||i.dispose(),this._maxSamples=e;const t=new Float32Array(this._maxSamples*4);for(let r=0;r<this._maxSamples;r++){const s=Math.random(),n=Math.random(),o=s*Math.sin(2*Math.PI*n),l=s*Math.cos(2*Math.PI*n);t[r*4+0]=o,t[r*4+1]=l,t[r*4+2]=s*s,t[r*4+3]=1}this._sampleTexture=new qt(t,this._maxSamples,1,5,this._scene,!1,!1,1,1),this._sampleTexture.name="GIRSMSamples"}dispose(){var e;this._disposePostProcesses(!0),(e=this._debugLayer.texture)==null||e.dispose(),this._debugLayer.dispose(),this._scene.onBeforeDrawPhaseObservable.remove(this._drawPhaseObserver),this._onShaderLoadedObservable.clear()}constructor(e,t,i={width:256,height:256},r=2048,s=11){this._giRSM=[],this._blurRTT=null,this._blurPostProcesses=null,this._blurXPostprocess=null,this._blurYPostprocess=null,this._upsamplingXPostprocess=null,this._upsamplingYPostprocess=null,this._ppGlobalIllumination=[],this._firstActivation=!0,this._geomBufferEnabled=!1,this._geomBufferEnablePosition=!1,this._tempMatrix=new $,this._enable=!1,this.pause=!1,this._enableBlur=!0,this._useQualityBlur=!1,this.blurDepthThreshold=.05,this.blurNormalThreshold=.25,this.blurKernel=12,this._forceFullSizeBlur=!1,this._useQualityUpsampling=!1,this.upsamplerKernel=6,this._showOnlyGI=!1,this._use32BitsDepthBuffer=!1,this._shaderLanguage=0,this._shadersLoaded=!1,this._onShaderLoadedObservable=new j,this._scene=e,this._engine=e.getEngine(),this._outputDimensions=t,this._giTextureDimensions=i,this._giTextureType=s,this._materialsWithRenderPlugin=[],this._maxSamples=r,this._debugLayer=new Yu("debug layer",null,this._scene,!1),this._debugLayer.isEnabled=!1,this._counters=[],this._countersRTW=[],this._initShaderSourceAsync(),this.generateSampleTexture(r),this._drawPhaseObserver=this._scene.onBeforeDrawPhaseObservable.add(()=>{var l,u;const n=this._engine._currentRenderTarget;let o=!1;if(this._enable&&this._shadersLoaded){!this.pause&&this._ppGlobalIllumination.length>0&&(this._scene.postProcessManager.directRender(this._ppGlobalIllumination,this._ppGlobalIllumination[0].inputTexture),this._engine.unBindFramebuffer(this._ppGlobalIllumination[0].inputTexture,!0),this._engine.setAlphaMode(0),o=!0,this.enableBlur&&this._blurPostProcesses&&(this._scene.postProcessManager.directRender(this._blurPostProcesses,this._blurRTT.renderTarget,!0),this._engine.unBindFramebuffer(this._blurRTT.renderTarget,!0)));for(let c=0;c<this._counters.length;++c){const h=this._countersRTW[c];for(let d=0;d<h.length;++d)d===0?this._counters[c].value=this.pause?0:((l=h[d].gpuTimeInFrame)==null?void 0:l.counter.lastSecAverage)??0:this.pause||(this._counters[c].value+=((u=h[d].gpuTimeInFrame)==null?void 0:u.counter.lastSecAverage)??0)}this._scene.activeCamera&&this._engine.setViewport(this._scene.activeCamera.viewport)}o&&n&&this._engine.bindFramebuffer(n)})}async _initShaderSourceAsync(){this._engine.isWebGPU?(this._shaderLanguage=1,await Promise.all([k(()=>Promise.resolve().then(()=>lU),void 0),k(()=>Promise.resolve().then(()=>cU),void 0),k(()=>Promise.resolve().then(()=>dU),void 0),k(()=>Promise.resolve().then(()=>pU),void 0)])):await Promise.all([k(()=>Promise.resolve().then(()=>eU),void 0),k(()=>Promise.resolve().then(()=>iU),void 0),k(()=>Promise.resolve().then(()=>sU),void 0),k(()=>Promise.resolve().then(()=>aU),void 0)]),this._shadersLoaded=!0,this._onShaderLoadedObservable.notifyObservers()}_disposePostProcesses(e=!1){var t,i,r,s,n;(t=this._blurRTT)==null||t.dispose(),this._blurRTT=null,this._blurPostProcesses=[],(i=this._blurXPostprocess)==null||i.dispose(),this._blurXPostprocess=null,(r=this._blurYPostprocess)==null||r.dispose(),this._blurYPostprocess=null,(s=this._upsamplingXPostprocess)==null||s.dispose(),this._upsamplingXPostprocess=null,(n=this._upsamplingYPostprocess)==null||n.dispose(),this._upsamplingYPostprocess=null;for(const o of this._ppGlobalIllumination)o.dispose();this._ppGlobalIllumination=[],e&&(this._geomBufferEnabled?(this._scene.enableGeometryBufferRenderer(),this._scene.geometryBufferRenderer.enablePosition=this._geomBufferEnablePosition):this._scene.disableGeometryBufferRenderer()),this._counters=[],this._countersRTW=[]}_setPluginParameters(){this._enable&&this._materialsWithRenderPlugin.forEach(e=>{if(e.pluginManager){const t=e.pluginManager.getPlugin(br.Name);t.textureGIContrib=this.enableBlur?this._blurRTT.renderTarget.texture:this._ppGlobalIllumination[0].inputTexture.texture,t.outputTextureWidth=this._outputDimensions.width,t.outputTextureHeight=this._outputDimensions.height}})}_createPostProcesses(){var n,o;if(!this._enable)return;const e=this._giTextureType===13?4:5;this._firstActivation&&(this._firstActivation=!1,this._geomBufferEnabled=!!this._scene.geometryBufferRenderer,this._geomBufferEnablePosition=((n=this._scene.geometryBufferRenderer)==null?void 0:n.enablePosition)??!1),this._geomBufferEnabled||this._scene.disableGeometryBufferRenderer();const t=this._scene.enableGeometryBufferRenderer(this._enableBlur?this._outputDimensions:this._giTextureDimensions,this._use32BitsDepthBuffer?14:15,ng.GeometryBufferTextureTypesAndFormats);if(!t)throw new Error("Geometry buffer renderer is not supported but is required for GIRSMManager.");t.enablePosition=!0,this._geomBufferEnabled||(t.generateNormalsInWorldSpace=!0);const i=t.normalsAreUnsigned,r=t.generateNormalsInWorldSpace;this._counters.push({name:"Geometry buffer renderer",value:0}),this._countersRTW.push([this._scene.geometryBufferRenderer.getGBuffer().renderTarget]);let s="";i&&(s+=`#define DECODE_NORMAL
`),r||(s+=`#define TRANSFORM_NORMAL
`);for(let l=0;l<this._giRSM.length;++l){const u=this._giRSM[l],c=u.rsm,h=new Ce("RSMGlobalIllumination"+l,u.useFullTexture?"rsmFullGlobalIllumination":"rsmGlobalIllumination",{...this._giTextureDimensions,uniforms:["rsmLightMatrix","rsmInfo","rsmInfo2","invView"],samplers:["normalSampler","rsmPositionW","rsmNormalW","rsmFlux","rsmSamples"],defines:s,samplingMode:2,engine:this._engine,textureType:this._giTextureType,textureFormat:e,shaderLanguage:this._shaderLanguage});this._ppGlobalIllumination.push(h),l!==0&&(h.shareOutputWith(this._ppGlobalIllumination[0]),h.alphaMode=1),h.autoClear=!1,h.externalTextureSamplerBinding=!0,h.onApplyObservable.add(d=>{d.setTexture("textureSampler",t.getGBuffer().textures[t.getTextureIndex(Re.POSITION_TEXTURE_TYPE)]),d.setTexture("normalSampler",t.getGBuffer().textures[t.getTextureIndex(Re.NORMAL_TEXTURE_TYPE)]),d.setTexture("rsmPositionW",c.positionWorldTexture),d.setTexture("rsmNormalW",c.normalWorldTexture),d.setTexture("rsmFlux",c.fluxTexture),d.setMatrix("rsmLightMatrix",c.lightTransformationMatrix),u.useFullTexture?d.setFloat4("rsmInfo",c.fluxTexture.getInternalTexture().width,c.fluxTexture.getInternalTexture().height,u.intensity,u.edgeArtifactCorrection):(d.setTexture("rsmSamples",this._sampleTexture),d.setFloat4("rsmInfo",u.numSamples,u.radius,u.intensity,u.edgeArtifactCorrection),d.setFloat4("rsmInfo2",u.noiseFactor,u.rotateSample?1:0,c.fluxTexture.getInternalTexture().width,c.fluxTexture.getInternalTexture().height)),r||(this._tempMatrix.copyFrom(this._scene.activeCamera.getViewMatrix()),this._tempMatrix.invert(),d.setMatrix("invView",this._tempMatrix))})}for(const l of this._ppGlobalIllumination)l.inputTexture||l.resize(this._giTextureDimensions.width,this._giTextureDimensions.height);if(this._counters.push({name:"GI generation",value:0}),this._countersRTW.push([this._ppGlobalIllumination[0].inputTexture]),this._enableBlur){const l=this._forceFullSizeBlur?this._outputDimensions:this._giTextureDimensions;this._blurRTT=new Kt("GIRSMContribution",this._outputDimensions,this._scene,{type:this._giTextureType,format:e,generateDepthBuffer:!1}),this._blurRTT.wrapU=0,this._blurRTT.wrapV=0,this._blurRTT.updateSamplingMode(1),this._blurRTT.skipInitialClear=!0;const u=[];if(this._counters.push({name:"GI blur",value:0}),this._countersRTW.push(u),this._blurXPostprocess=new Ce(this._useQualityBlur?"BilateralBlur":"BilateralBlurX",this._useQualityBlur?"bilateralBlurQuality":"bilateralBlur",{uniforms:["filterSize","blurDir","depthThreshold","normalThreshold"],samplers:["depthSampler","normalSampler"],defines:i?"#define DECODE_NORMAL":void 0,size:l,samplingMode:2,engine:this._engine,textureType:this._giTextureType,textureFormat:e,shaderLanguage:this._shaderLanguage}),this._blurXPostprocess.onApplyObservable.add(h=>{h._bindTexture("textureSampler",this._ppGlobalIllumination[0].inputTexture.texture),h.setTexture("depthSampler",t.getGBuffer().textures[t.getTextureIndex(Re.DEPTH_TEXTURE_TYPE)]),h.setTexture("normalSampler",t.getGBuffer().textures[t.getTextureIndex(Re.NORMAL_TEXTURE_TYPE)]),h.setInt("filterSize",this.blurKernel),h.setFloat2("blurDir",1/this._giTextureDimensions.width,this._useQualityBlur?1/this._giTextureDimensions.height:0),h.setFloat("depthThreshold",this.blurDepthThreshold),h.setFloat("normalThreshold",this.blurNormalThreshold)}),this._blurXPostprocess.externalTextureSamplerBinding=!0,this._blurXPostprocess.autoClear=!1,this._useQualityBlur||(this._blurYPostprocess=new Ce("BilateralBlurY","bilateralBlur",{uniforms:["filterSize","blurDir","depthThreshold","normalThreshold"],samplers:["depthSampler","normalSampler"],defines:i?"#define DECODE_NORMAL":void 0,size:l,samplingMode:2,engine:this._engine,textureType:this._giTextureType,textureFormat:e,shaderLanguage:this._shaderLanguage}),this._blurYPostprocess.autoClear=!1,this._blurYPostprocess.onApplyObservable.add(h=>{h.setTexture("depthSampler",t.getGBuffer().textures[t.getTextureIndex(Re.DEPTH_TEXTURE_TYPE)]),h.setTexture("normalSampler",t.getGBuffer().textures[t.getTextureIndex(Re.NORMAL_TEXTURE_TYPE)]),h.setInt("filterSize",this.blurKernel),h.setFloat2("blurDir",0,1/this._giTextureDimensions.height),h.setFloat("depthThreshold",this.blurDepthThreshold),h.setFloat("normalThreshold",this.blurNormalThreshold)}),this._blurYPostprocess.resize(l.width,l.height),u.push(this._blurYPostprocess.inputTexture)),this._blurPostProcesses=[this._blurXPostprocess],this._blurYPostprocess&&this._blurPostProcesses.push(this._blurYPostprocess),!(this._giTextureDimensions.width>=this._outputDimensions.width&&this._giTextureDimensions.height>=this._outputDimensions.height)&&!this._forceFullSizeBlur){const h=[];this._counters.push({name:"GI upsampling",value:0}),this._countersRTW.push(h),this._upsamplingXPostprocess=new Ce(this._useQualityUpsampling?"BilateralUpsampling":"BilateralUpsamplingX",this._useQualityUpsampling?"bilateralBlurQuality":"bilateralBlur",{uniforms:["filterSize","blurDir","depthThreshold","normalThreshold"],samplers:["depthSampler","normalSampler"],defines:i?"#define DECODE_NORMAL":void 0,size:l,samplingMode:2,engine:this._engine,textureType:this._giTextureType,textureFormat:e,shaderLanguage:this._shaderLanguage}),this._upsamplingXPostprocess.autoClear=!1,this._upsamplingXPostprocess.onApplyObservable.add(d=>{d.setTexture("depthSampler",t.getGBuffer().textures[t.getTextureIndex(Re.DEPTH_TEXTURE_TYPE)]),d.setTexture("normalSampler",t.getGBuffer().textures[t.getTextureIndex(Re.NORMAL_TEXTURE_TYPE)]),d.setInt("filterSize",this.upsamplerKernel),d.setFloat2("blurDir",1/this._outputDimensions.width,this._useQualityUpsampling?1/this._outputDimensions.height:0),d.setFloat("depthThreshold",this.blurDepthThreshold),d.setFloat("normalThreshold",this.blurNormalThreshold)}),this._upsamplingXPostprocess.resize(l.width,l.height),u.push(this._upsamplingXPostprocess.inputTexture),this.useQualityUpsampling||(this._upsamplingYPostprocess=new Ce("BilateralUpsamplingY","bilateralBlur",{uniforms:["filterSize","blurDir","depthThreshold","normalThreshold"],samplers:["depthSampler","normalSampler"],defines:i?"#define DECODE_NORMAL":void 0,size:this._outputDimensions,samplingMode:2,engine:this._engine,textureType:this._giTextureType,textureFormat:e,shaderLanguage:this._shaderLanguage}),this._upsamplingYPostprocess.autoClear=!1,this._upsamplingYPostprocess.onApplyObservable.add(d=>{d.setTexture("depthSampler",t.getGBuffer().textures[t.getTextureIndex(Re.DEPTH_TEXTURE_TYPE)]),d.setTexture("normalSampler",t.getGBuffer().textures[t.getTextureIndex(Re.NORMAL_TEXTURE_TYPE)]),d.setInt("filterSize",this.upsamplerKernel),d.setFloat2("blurDir",0,1/this._outputDimensions.height),d.setFloat("depthThreshold",this.blurDepthThreshold),d.setFloat("normalThreshold",this.blurNormalThreshold)}),this._upsamplingYPostprocess.resize(this._outputDimensions.width,this._outputDimensions.height),h.push(this._upsamplingYPostprocess.inputTexture)),h.push(this._blurRTT.renderTarget),this._blurPostProcesses.push(this._upsamplingXPostprocess),this._upsamplingYPostprocess&&this._blurPostProcesses.push(this._upsamplingYPostprocess)}else u.push(this._blurRTT.renderTarget)}(o=this._debugLayer.texture)==null||o.dispose(),this._debugLayer.texture=new Vr(this._scene,this._enableBlur?this._blurRTT.renderTarget.texture:this._ppGlobalIllumination[0].inputTexture.texture)}_addGISupportToMaterial(e){var i;if((i=e.pluginManager)!=null&&i.getPlugin(br.Name))return;const t=new br(e);this._enable&&this._ppGlobalIllumination.length>0&&(t.textureGIContrib=this._ppGlobalIllumination[0].inputTexture.texture,t.outputTextureWidth=this._outputDimensions.width,t.outputTextureHeight=this._outputDimensions.height),t.isEnabled=this._enable,this._materialsWithRenderPlugin.push(e)}}ng.GeometryBufferTextureTypesAndFormats={0:{textureType:2,textureFormat:6},1:{textureType:11,textureFormat:5},2:{textureType:2,textureFormat:5}};class Kz extends ps{constructor(){super(...arguments),this.RENDER_WITH_GIRSM=!1,this.RSMCREATE_PROJTEXTURE=!1}}class br extends Qn{_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}isCompatible(){return!0}constructor(e){super(e,br.Name,310,new Kz),this._isEnabled=!1,this.isEnabled=!1,this._internalMarkAllSubMeshesAsTexturesDirty=e._dirtyCallbacks[1],this._isPBR=e instanceof hr}prepareDefines(e){e.RENDER_WITH_GIRSM=this._isEnabled}getClassName(){return"GIRSMRenderPluginMaterial"}getUniforms(){return{ubo:[{name:"girsmTextureOutputSize",size:2,type:"vec2"}],fragment:`#ifdef RENDER_WITH_GIRSM
                    uniform vec2 girsmTextureOutputSize;
                #endif`}}getSamplers(e){e.push("girsmTextureGIContrib")}bindForSubMesh(e){this._isEnabled&&(e.bindTexture("girsmTextureGIContrib",this.textureGIContrib),e.updateFloat2("girsmTextureOutputSize",this.outputTextureWidth,this.outputTextureHeight))}getCustomCode(e,t){let i;return t===1?(i={CUSTOM_FRAGMENT_DEFINITIONS:`
                #ifdef RENDER_WITH_GIRSM
                    var girsmTextureGIContribSampler: sampler;
                    var girsmTextureGIContrib: texture_2d<f32>;

                    fn computeIndirect() -> vec3f {
                        var uv = fragmentInputs.position.xy / uniforms.girsmTextureOutputSize;
                        return textureSample(girsmTextureGIContrib, girsmTextureGIContribSampler, uv).rgb;
                    }
                #endif
            `,CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION:`
                #ifdef RENDER_WITH_GIRSM
                    finalDiffuse += computeIndirect() * surfaceAlbedo.rgb;
                #endif
            `},this._isPBR||(i.CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR=`
                #ifdef RENDER_WITH_GIRSM
                    color = vec4f(color.rgb + computeIndirect() * baseColor.rgb, color.a);
                #endif
            `)):(i={CUSTOM_FRAGMENT_DEFINITIONS:`
                #ifdef RENDER_WITH_GIRSM
                    uniform sampler2D girsmTextureGIContrib;

                    vec3 computeIndirect() {
                        vec2 uv = gl_FragCoord.xy / girsmTextureOutputSize;
                        return texture2D(girsmTextureGIContrib, uv).rgb;
                    }
                #endif
            `,CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION:`
                #ifdef RENDER_WITH_GIRSM
                    finalDiffuse += computeIndirect() * surfaceAlbedo.rgb;
                #endif
            `},this._isPBR||(i.CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR=`
                #ifdef RENDER_WITH_GIRSM
                    color.rgb += computeIndirect() * baseColor.rgb;
                #endif
            `)),e==="vertex"?null:i}}br.Name="GIRSMRender";C([F()],br.prototype,"textureGIContrib",void 0);C([F()],br.prototype,"outputTextureWidth",void 0);C([F()],br.prototype,"outputTextureHeight",void 0);C([F(),Ue("_markAllSubMeshesAsTexturesDirty")],br.prototype,"isEnabled",void 0);B("BABYLON.GIRSMRenderPluginMaterial",br);const op="bilateralBlurPixelShader",aI=`uniform sampler2D textureSampler;uniform sampler2D depthSampler;uniform sampler2D normalSampler;uniform int filterSize;uniform vec2 blurDir;uniform float depthThreshold;uniform float normalThreshold;varying vec2 vUV;void main(void) {vec3 color=textureLod(textureSampler,vUV,0.).rgb;float depth=textureLod(depthSampler,vUV,0.).x;if (depth>=1e6 || depth<=0.) {glFragColor=vec4(color,1.);return;}
vec3 normal=textureLod(normalSampler,vUV,0.).rgb;
#ifdef DECODE_NORMAL
normal=normal*2.0-1.0;
#endif
float sigma=float(filterSize);float two_sigma2=2.0*sigma*sigma;float sigmaDepth=depthThreshold;float two_sigmaDepth2=2.0*sigmaDepth*sigmaDepth;float sigmaNormal=normalThreshold;float two_sigmaNormal2=2.0*sigmaNormal*sigmaNormal;vec3 sum=vec3(0.);float wsum=0.;for (int x=-filterSize; x<=filterSize; ++x) {vec2 coords=vec2(x);vec3 sampleColor=textureLod(textureSampler,vUV+coords*blurDir,0.).rgb;float sampleDepth=textureLod(depthSampler,vUV+coords*blurDir,0.).r;vec3 sampleNormal=textureLod(normalSampler,vUV+coords*blurDir,0.).rgb;
#ifdef DECODE_NORMAL
sampleNormal=sampleNormal*2.0-1.0;
#endif
float r=dot(coords,coords);float w=exp(-r/two_sigma2);float depthDelta=abs(sampleDepth-depth);float wd=step(depthDelta,depthThreshold);vec3 normalDelta=abs(sampleNormal-normal);float wn=step(normalDelta.x+normalDelta.y+normalDelta.z,normalThreshold);sum+=sampleColor*w*wd*wn;wsum+=w*wd*wn;}
glFragColor=vec4(sum/wsum,1.);}
`;P.ShadersStore[op]||(P.ShadersStore[op]=aI);const Jz={name:op,shader:aI},eU=Object.freeze(Object.defineProperty({__proto__:null,bilateralBlurPixelShader:Jz},Symbol.toStringTag,{value:"Module"})),lp="bilateralBlurQualityPixelShader",oI=`uniform sampler2D textureSampler;uniform sampler2D depthSampler;uniform sampler2D normalSampler;uniform int filterSize;uniform vec2 blurDir;uniform float depthThreshold;uniform float normalThreshold;varying vec2 vUV;void main(void) {vec3 color=textureLod(textureSampler,vUV,0.).rgb;float depth=textureLod(depthSampler,vUV,0.).x;if (depth>=1e6 || depth<=0.) {glFragColor=vec4(color,1.);return;}
vec3 normal=textureLod(normalSampler,vUV,0.).rgb;
#ifdef DECODE_NORMAL
normal=normal*2.0-1.0;
#endif
float sigma=float(filterSize);float two_sigma2=2.0*sigma*sigma;float sigmaDepth=depthThreshold;float two_sigmaDepth2=2.0*sigmaDepth*sigmaDepth;float sigmaNormal=normalThreshold;float two_sigmaNormal2=2.0*sigmaNormal*sigmaNormal;vec3 sum=vec3(0.);float wsum=0.;for (int x=-filterSize; x<=filterSize; ++x) {for (int y=-filterSize; y<=filterSize; ++y) {vec2 coords=vec2(x,y)*blurDir;vec3 sampleColor=textureLod(textureSampler,vUV+coords,0.).rgb;float sampleDepth=textureLod(depthSampler,vUV+coords,0.).r;vec3 sampleNormal=textureLod(normalSampler,vUV+coords,0.).rgb;
#ifdef DECODE_NORMAL
sampleNormal=sampleNormal*2.0-1.0;
#endif
float r=dot(coords,coords);float w=exp(-r/two_sigma2);float rDepth=sampleDepth-depth;float wd=exp(-rDepth*rDepth/two_sigmaDepth2);float rNormal=abs(sampleNormal.x-normal.x)+abs(sampleNormal.y-normal.y)+abs(sampleNormal.z-normal.z);float wn=exp(-rNormal*rNormal/two_sigmaNormal2);sum+=sampleColor*w*wd*wn;wsum+=w*wd*wn;}}
glFragColor=vec4(sum/wsum,1.);}
`;P.ShadersStore[lp]||(P.ShadersStore[lp]=oI);const tU={name:lp,shader:oI},iU=Object.freeze(Object.defineProperty({__proto__:null,bilateralBlurQualityPixelShader:tU},Symbol.toStringTag,{value:"Module"})),up="rsmGlobalIlluminationPixelShader",lI=`/**
* The implementation is an application of the formula found in http:
* For better results,it also adds a random (noise) rotation to the RSM samples (the noise artifacts are easier to remove than the banding artifacts).
*/
precision highp float;varying vec2 vUV;uniform mat4 rsmLightMatrix;uniform vec4 rsmInfo;uniform vec4 rsmInfo2;uniform sampler2D textureSampler;uniform sampler2D normalSampler;uniform sampler2D rsmPositionW;uniform sampler2D rsmNormalW;uniform sampler2D rsmFlux;uniform sampler2D rsmSamples;
#ifdef TRANSFORM_NORMAL
uniform mat4 invView;
#endif
float mod289(float x){return x-floor(x*(1.0/289.0))*289.0;}
vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}
vec4 perm(vec4 x){return mod289(((x*34.0)+1.0)*x);}
float noise(vec3 p){vec3 a=floor(p);vec3 d=p-a;d=d*d*(3.0-2.0*d);vec4 b=a.xxyy+vec4(0.0,1.0,0.0,1.0);vec4 k1=perm(b.xyxy);vec4 k2=perm(k1.xyxy+b.zzww);vec4 c=k2+a.zzzz;vec4 k3=perm(c);vec4 k4=perm(c+1.0);vec4 o1=fract(k3*(1.0/41.0));vec4 o2=fract(k4*(1.0/41.0));vec4 o3=o2*d.z+o1*(1.0-d.z);vec2 o4=o3.yw*d.x+o3.xz*(1.0-d.x);return o4.y*d.y+o4.x*(1.0-d.y);}
vec3 computeIndirect(vec3 p,vec3 n) {vec3 indirectDiffuse=vec3(0.);int numSamples=int(rsmInfo.x);float radius=rsmInfo.y;float intensity=rsmInfo.z;float edgeArtifactCorrection=rsmInfo.w;vec4 texRSM=rsmLightMatrix*vec4(p,1.);texRSM.xy/=texRSM.w;texRSM.xy=texRSM.xy*0.5+0.5;float angle=noise(p*rsmInfo2.x);float c=cos(angle);float s=sin(angle);for (int i=0; i<numSamples; i++) {vec3 rsmSample=texelFetch(rsmSamples,ivec2(i,0),0).xyz;float weightSquare=rsmSample.z;if (rsmInfo2.y==1.0) rsmSample.xy=vec2(rsmSample.x*c+rsmSample.y*s,-rsmSample.x*s+rsmSample.y*c);vec2 uv=texRSM.xy+rsmSample.xy*radius;if (uv.x<0. || uv.x>1. || uv.y<0. || uv.y>1.) continue;vec3 vplPositionW=textureLod(rsmPositionW,uv,0.).xyz;vec3 vplNormalW=textureLod(rsmNormalW,uv,0.).xyz*2.0-1.0;vec3 vplFlux=textureLod(rsmFlux,uv,0.).rgb;vplPositionW-=vplNormalW*edgeArtifactCorrection; 
float dist2=dot(vplPositionW-p,vplPositionW-p);indirectDiffuse+=vplFlux*weightSquare*max(0.,dot(n,vplPositionW-p))*max(0.,dot(vplNormalW,p-vplPositionW))/(dist2*dist2);}
return clamp(indirectDiffuse*intensity,0.0,1.0);}
void main(void) 
{vec3 positionW=texture2D(textureSampler,vUV).xyz;vec3 normalW=texture2D(normalSampler,vUV).xyz;
#ifdef DECODE_NORMAL
normalW=normalW*2.0-1.0;
#endif
#ifdef TRANSFORM_NORMAL
normalW=(invView*vec4(normalW,0.)).xyz;
#endif
gl_FragColor.rgb=computeIndirect(positionW,normalW);gl_FragColor.a=1.0;}
`;P.ShadersStore[up]||(P.ShadersStore[up]=lI);const rU={name:up,shader:lI},sU=Object.freeze(Object.defineProperty({__proto__:null,rsmGlobalIlluminationPixelShader:rU},Symbol.toStringTag,{value:"Module"})),cp="rsmFullGlobalIlluminationPixelShader",uI=`/**
* The implementation is a direct application of the formula found in http:
*/
precision highp float;varying vec2 vUV;uniform mat4 rsmLightMatrix;uniform vec4 rsmInfo;uniform sampler2D textureSampler;uniform sampler2D normalSampler;uniform sampler2D rsmPositionW;uniform sampler2D rsmNormalW;uniform sampler2D rsmFlux;
#ifdef TRANSFORM_NORMAL
uniform mat4 invView;
#endif
vec3 computeIndirect(vec3 p,vec3 n) {vec3 indirectDiffuse=vec3(0.);float intensity=rsmInfo.z;float edgeArtifactCorrection=rsmInfo.w;vec4 texRSM=rsmLightMatrix*vec4(p,1.);texRSM.xy/=texRSM.w;texRSM.xy=texRSM.xy*0.5+0.5;int width=int(rsmInfo.x);int height=int(rsmInfo.y);for (int j=0; j<height; j++) {for (int i=0; i<width; i++) {ivec2 uv=ivec2(i,j);vec3 vplPositionW=texelFetch(rsmPositionW,uv,0).xyz;vec3 vplNormalW=texelFetch(rsmNormalW,uv,0).xyz*2.0-1.0;vec3 vplFlux=texelFetch(rsmFlux,uv,0).rgb;vplPositionW-=vplNormalW*edgeArtifactCorrection; 
float dist2=dot(vplPositionW-p,vplPositionW-p);indirectDiffuse+=vplFlux*max(0.,dot(n,vplPositionW-p))*max(0.,dot(vplNormalW,p-vplPositionW))/(dist2*dist2);}}
return clamp(indirectDiffuse*intensity,0.0,1.0);}
void main(void) 
{vec3 positionW=texture2D(textureSampler,vUV).xyz;vec3 normalW=texture2D(normalSampler,vUV).xyz;
#ifdef DECODE_NORMAL
normalW=normalW*2.0-1.0;
#endif
#ifdef TRANSFORM_NORMAL
normalW=(invView*vec4(normalW,0.)).xyz;
#endif
gl_FragColor.rgb=computeIndirect(positionW,normalW);gl_FragColor.a=1.0;}
`;P.ShadersStore[cp]||(P.ShadersStore[cp]=uI);const nU={name:cp,shader:uI},aU=Object.freeze(Object.defineProperty({__proto__:null,rsmFullGlobalIlluminationPixelShader:nU},Symbol.toStringTag,{value:"Module"})),hp="bilateralBlurPixelShader",cI=`var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var normalSamplerSampler: sampler;var normalSampler: texture_2d<f32>;var depthSamplerSampler: sampler;var depthSampler: texture_2d<f32>;uniform filterSize: i32;uniform blurDir: vec2f;uniform depthThreshold: f32;uniform normalThreshold: f32;varying vUV: vec2f;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var color: vec3f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.).rgb;var depth: f32=textureSampleLevel(depthSampler,depthSamplerSampler,input.vUV,0.).x;if (depth>=1e6 || depth<=0.) {fragmentOutputs.color= vec4f(color,1.);return fragmentOutputs;}
var normal: vec3f=textureSampleLevel(normalSampler,normalSamplerSampler,input.vUV,0.).rgb;
#ifdef DECODE_NORMAL
normal=normal*2.0-1.0;
#endif
var sigma: f32= f32(uniforms.filterSize);var two_sigma2: f32=2.0*sigma*sigma;var sigmaDepth: f32=uniforms.depthThreshold;var two_sigmaDepth2: f32=2.0*sigmaDepth*sigmaDepth;var sigmaNormal: f32=uniforms.normalThreshold;var two_sigmaNormal2: f32=2.0*sigmaNormal*sigmaNormal;var sum: vec3f= vec3f(0.);var wsum: f32=0.;for (var x: i32=-uniforms.filterSize; x<=uniforms.filterSize; x++) {var coords=vec2f(f32(x));var sampleColor: vec3f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV+coords*uniforms.blurDir,0.).rgb;var sampleDepth: f32=textureSampleLevel(depthSampler,depthSamplerSampler,input.vUV+coords*uniforms.blurDir,0.).r;var sampleNormal: vec3f=textureSampleLevel(normalSampler,normalSamplerSampler,input.vUV+coords*uniforms.blurDir,0.).rgb;
#ifdef DECODE_NORMAL
sampleNormal=sampleNormal*2.0-1.0;
#endif
var r: f32=dot(coords,coords);var w: f32=exp(-r/two_sigma2);var depthDelta: f32=abs(sampleDepth-depth);var wd: f32=step(depthDelta,uniforms.depthThreshold);var normalDelta: vec3f=abs(sampleNormal-normal);var wn: f32=step(normalDelta.x+normalDelta.y+normalDelta.z,uniforms.normalThreshold);sum+=sampleColor*w*wd*wn;wsum+=w*wd*wn;}
fragmentOutputs.color= vec4f(sum/wsum,1.);}
`;P.ShadersStoreWGSL[hp]||(P.ShadersStoreWGSL[hp]=cI);const oU={name:hp,shader:cI},lU=Object.freeze(Object.defineProperty({__proto__:null,bilateralBlurPixelShaderWGSL:oU},Symbol.toStringTag,{value:"Module"})),dp="bilateralBlurQualityPixelShader",hI=`var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var normalSamplerSampler: sampler;var normalSampler: texture_2d<f32>;var depthSamplerSampler: sampler;var depthSampler: texture_2d<f32>;uniform filterSize: i32;uniform blurDir: vec2f;uniform depthThreshold: f32;uniform normalThreshold: f32;varying vUV: vec2f;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var color: vec3f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV,0.).rgb;var depth: f32=textureSampleLevel(depthSampler,depthSamplerSampler,input.vUV,0.).x;if (depth>=1e6 || depth<=0.) {fragmentOutputs.color= vec4f(color,1.);return fragmentOutputs;}
var normal: vec3f=textureSampleLevel(normalSampler,normalSamplerSampler,input.vUV,0.).rgb;
#ifdef DECODE_NORMAL
normal=normal*2.0-1.0;
#endif
var sigma: f32= f32(uniforms.filterSize);var two_sigma2: f32=2.0*sigma*sigma;var sigmaDepth: f32=uniforms.depthThreshold;var two_sigmaDepth2: f32=2.0*sigmaDepth*sigmaDepth;var sigmaNormal: f32=uniforms.normalThreshold;var two_sigmaNormal2: f32=2.0*sigmaNormal*sigmaNormal;var sum: vec3f= vec3f(0.);var wsum: f32=0.;for (var x: i32=-uniforms.filterSize; x<=uniforms.filterSize; x++) {for (var y: i32=-uniforms.filterSize; y<=uniforms.filterSize; y++) {var coords: vec2f= vec2f(f32(x),f32(y))*uniforms.blurDir;var sampleColor: vec3f=textureSampleLevel(textureSampler,textureSamplerSampler,input.vUV+coords,0.).rgb;var sampleDepth: f32=textureSampleLevel(depthSampler,depthSamplerSampler,input.vUV+coords,0.).r;var sampleNormal: vec3f=textureSampleLevel(normalSampler,normalSamplerSampler,input.vUV+coords,0.).rgb;
#ifdef DECODE_NORMAL
sampleNormal=sampleNormal*2.0-1.0;
#endif
var r: f32=dot(coords,coords);var w: f32=exp(-r/two_sigma2);var rDepth: f32=sampleDepth-depth;var wd: f32=exp(-rDepth*rDepth/two_sigmaDepth2);var rNormal: f32=abs(sampleNormal.x-normal.x)+abs(sampleNormal.y-normal.y)+abs(sampleNormal.z-normal.z);var wn: f32=exp(-rNormal*rNormal/two_sigmaNormal2);sum+=sampleColor*w*wd*wn;wsum+=w*wd*wn;}}
fragmentOutputs.color= vec4f(sum/wsum,1.);}
`;P.ShadersStoreWGSL[dp]||(P.ShadersStoreWGSL[dp]=hI);const uU={name:dp,shader:hI},cU=Object.freeze(Object.defineProperty({__proto__:null,bilateralBlurQualityPixelShaderWGSL:uU},Symbol.toStringTag,{value:"Module"})),fp="rsmGlobalIlluminationPixelShader",dI=`/**
* The implementation is an application of the formula found in http:
* For better results,it also adds a random (noise) rotation to the RSM samples (the noise artifacts are easier to remove than the banding artifacts).
*/
varying vUV: vec2f;uniform rsmLightMatrix: mat4x4f;uniform rsmInfo: vec4f;uniform rsmInfo2: vec4f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var normalSamplerSampler: sampler;var normalSampler: texture_2d<f32>;var rsmPositionWSampler: sampler;var rsmPositionW: texture_2d<f32>;var rsmNormalWSampler: sampler;var rsmNormalW: texture_2d<f32>;var rsmFluxSampler: sampler;var rsmFlux: texture_2d<f32>;var rsmSamples: texture_2d<f32>;
#ifdef TRANSFORM_NORMAL
uniform invView: mat4x4f;
#endif
fn mod289(x: f32)->f32{return x-floor(x*(1.0/289.0))*289.0;}
fn mod289Vec4(x: vec4f)->vec4f {return x-floor(x*(1.0/289.0))* 289.0;}
fn perm(x: vec4f)->vec4f {return mod289Vec4(((x*34.0)+1.0)*x) ;}
fn noise(p: vec3f)->f32{var a: vec3f=floor(p);var d: vec3f=p-a;d=d*d*(3.0-2.0*d);var b: vec4f=a.xxyy+ vec4f(0.0,1.0,0.0,1.0);var k1: vec4f=perm(b.xyxy);var k2: vec4f=perm(k1.xyxy+b.zzww);var c: vec4f=k2+a.zzzz;var k3: vec4f=perm(c);var k4: vec4f=perm(c+1.0);var o1: vec4f=fract(k3*(1.0/41.0));var o2: vec4f=fract(k4*(1.0/41.0));var o3: vec4f=o2*d.z+o1*(1.0-d.z);var o4: vec2f=o3.yw*d.x+o3.xz*(1.0-d.x);return o4.y*d.y+o4.x*(1.0-d.y);}
fn computeIndirect(p: vec3f,n: vec3f)->vec3f {var indirectDiffuse: vec3f= vec3f(0.);var numSamples: i32= i32(uniforms.rsmInfo.x);var radius: f32=uniforms.rsmInfo.y;var intensity: f32=uniforms.rsmInfo.z;var edgeArtifactCorrection: f32=uniforms.rsmInfo.w;var texRSM: vec4f=uniforms.rsmLightMatrix* vec4f(p,1.);texRSM=vec4f(texRSM.xy/texRSM.w,texRSM.z,texRSM.w);texRSM=vec4f(texRSM.xy*0.5+0.5,texRSM.z,texRSM.w);var angle: f32=noise(p*uniforms.rsmInfo2.x);var c: f32=cos(angle);var s: f32=sin(angle);for (var i: i32=0; i<numSamples; i++) {var rsmSample: vec3f=textureLoad(rsmSamples,vec2<i32>(i,0),0).xyz;var weightSquare: f32=rsmSample.z;if (uniforms.rsmInfo2.y==1.0){rsmSample=vec3f(rsmSample.x*c+rsmSample.y*s,-rsmSample.x*s+rsmSample.y*c,rsmSample.z);}
var uv: vec2f=texRSM.xy+rsmSample.xy*radius;if (uv.x<0. || uv.x>1. || uv.y<0. || uv.y>1.) {continue;}
var vplPositionW: vec3f=textureSampleLevel(rsmPositionW,rsmPositionWSampler,uv,0.).xyz;var vplNormalW: vec3f=textureSampleLevel(rsmNormalW,rsmNormalWSampler,uv,0.).xyz*2.0-1.0;var vplFlux: vec3f=textureSampleLevel(rsmFlux,rsmFluxSampler,uv,0.).rgb;vplPositionW-=vplNormalW*edgeArtifactCorrection; 
var dist2: f32=dot(vplPositionW-p,vplPositionW-p);indirectDiffuse+=vplFlux*weightSquare*max(0.,dot(n,vplPositionW-p))*max(0.,dot(vplNormalW,p-vplPositionW))/(dist2*dist2);}
return clamp(indirectDiffuse*intensity,vec3f(0.0),vec3f(1.0));}
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var positionW: vec3f=textureSample(textureSampler,textureSamplerSampler,input.vUV).xyz;var normalW: vec3f=textureSample(normalSampler,normalSamplerSampler,input.vUV).xyz;
#ifdef DECODE_NORMAL
normalW=normalW*2.0-1.0;
#endif
#ifdef TRANSFORM_NORMAL
normalW=(uniforms.invView* vec4f(normalW,0.)).xyz;
#endif
fragmentOutputs.color=vec4f(computeIndirect(positionW,normalW),1.0);}
`;P.ShadersStoreWGSL[fp]||(P.ShadersStoreWGSL[fp]=dI);const hU={name:fp,shader:dI},dU=Object.freeze(Object.defineProperty({__proto__:null,rsmGlobalIlluminationPixelShaderWGSL:hU},Symbol.toStringTag,{value:"Module"})),pp="rsmFullGlobalIlluminationPixelShader",fI=`/**
* The implementation is a direct application of the formula found in http:
*/
varying vUV: vec2f;uniform rsmLightMatrix: mat4x4f;uniform rsmInfo: vec4f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var normalSamplerSampler: sampler;var normalSampler: texture_2d<f32>;var rsmPositionW: texture_2d<f32>;var rsmNormalW: texture_2d<f32>;var rsmFlux: texture_2d<f32>;
#ifdef TRANSFORM_NORMAL
uniform invView: mat4x4f;
#endif
fn computeIndirect(p: vec3f,n: vec3f)->vec3f {var indirectDiffuse: vec3f= vec3f(0.);var intensity: f32=uniforms.rsmInfo.z;var edgeArtifactCorrection: f32=uniforms.rsmInfo.w;var texRSM: vec4f=uniforms.rsmLightMatrix* vec4f(p,1.);texRSM=vec4f(texRSM.xy/texRSM.w,texRSM.z,texRSM.w);texRSM=vec4f(texRSM.xy*0.5+0.5,texRSM.z,texRSM.w);var width: i32= i32(uniforms.rsmInfo.x);var height: i32= i32(uniforms.rsmInfo.y);for (var j: i32=0; j<height; j++) {for (var i: i32=0; i<width; i++) {var uv=vec2<i32>(i,j);var vplPositionW: vec3f=textureLoad(rsmPositionW,uv,0).xyz;var vplNormalW: vec3f=textureLoad(rsmNormalW,uv,0).xyz*2.0-1.0;var vplFlux: vec3f=textureLoad(rsmFlux,uv,0).rgb;vplPositionW-=vplNormalW*edgeArtifactCorrection; 
var dist2: f32=dot(vplPositionW-p,vplPositionW-p);indirectDiffuse+=vplFlux*max(0.,dot(n,vplPositionW-p))*max(0.,dot(vplNormalW,p-vplPositionW))/(dist2*dist2);}}
return clamp(indirectDiffuse*intensity,vec3f(0.0),vec3f(1.0));}
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var positionW: vec3f=textureSample(textureSampler,textureSamplerSampler,fragmentInputs.vUV).xyz;var normalW: vec3f=textureSample(normalSampler,normalSamplerSampler,fragmentInputs.vUV).xyz;
#ifdef DECODE_NORMAL
normalW=normalW*2.0-1.0;
#endif
#ifdef TRANSFORM_NORMAL
normalW=(uniforms.invView* vec4f(normalW,0.)).xyz;
#endif
fragmentOutputs.color=vec4f(computeIndirect(positionW,normalW),1.0);}
`;P.ShadersStoreWGSL[pp]||(P.ShadersStoreWGSL[pp]=fI);const fU={name:pp,shader:fI},pU=Object.freeze(Object.defineProperty({__proto__:null,rsmFullGlobalIlluminationPixelShaderWGSL:fU},Symbol.toStringTag,{value:"Module"})),mp="depthPixelShader",pI=`#ifdef ALPHATEST
varying vUV: vec2f;var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;
#endif
#include<clipPlaneFragmentDeclaration>
varying vDepthMetric: f32;
#ifdef PACKED
#include<packingFunctions>
#endif
#ifdef STORE_CAMERASPACE_Z
varying vViewPos: vec4f;
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#include<clipPlaneFragment>
#ifdef ALPHATEST
if (textureSample(diffuseSampler,diffuseSamplerSampler,input.vUV).a<0.4) {discard;}
#endif
#ifdef STORE_CAMERASPACE_Z
#ifdef PACKED
fragmentOutputs.color=pack(input.vViewPos.z);
#else
fragmentOutputs.color= vec4f(input.vViewPos.z,0.0,0.0,1.0);
#endif
#else
#ifdef NONLINEARDEPTH
#ifdef PACKED
fragmentOutputs.color=pack(input.position.z);
#else
fragmentOutputs.color= vec4f(input.position.z,0.0,0.0,0.0);
#endif
#else
#ifdef PACKED
fragmentOutputs.color=pack(input.vDepthMetric);
#else
fragmentOutputs.color= vec4f(input.vDepthMetric,0.0,0.0,1.0);
#endif
#endif
#endif
}`;P.ShadersStoreWGSL[mp]||(P.ShadersStoreWGSL[mp]=pI);const mU={name:mp,shader:pI},_U=Object.freeze(Object.defineProperty({__proto__:null,depthPixelShaderWGSL:mU},Symbol.toStringTag,{value:"Module"})),_p="depthVertexShader",mI=`attribute position: vec3f;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform viewProjection: mat4x4f;uniform depthValues: vec2f;
#if defined(ALPHATEST) || defined(NEED_UV)
varying vUV: vec2f;uniform diffuseMatrix: mat4x4f;
#ifdef UV1
attribute uv: vec2f;
#endif
#ifdef UV2
attribute uv2: vec2f;
#endif
#endif
#ifdef STORE_CAMERASPACE_Z
uniform view: mat4x4f;varying vViewPos: vec4f;
#endif
varying vDepthMetric: f32;
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {var positionUpdated: vec3f=input.position;
#ifdef UV1
var uvUpdated: vec2f=input.uv;
#endif
#ifdef UV2
var uv2Updated: vec2f=input.uv2;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
var worldPos: vec4f=finalWorld* vec4f(positionUpdated,1.0);
#include<clipPlaneVertex>
vertexOutputs.position=uniforms.viewProjection*worldPos;
#ifdef STORE_CAMERASPACE_Z
vertexOutputs.vViewPos=uniforms.view*worldPos;
#else
#ifdef USE_REVERSE_DEPTHBUFFER
vertexOutputs.vDepthMetric=((-vertexOutputs.position.z+uniforms.depthValues.x)/(uniforms.depthValues.y));
#else
vertexOutputs.vDepthMetric=((vertexOutputs.position.z+uniforms.depthValues.x)/(uniforms.depthValues.y));
#endif
#endif
#if defined(ALPHATEST) || defined(BASIC_RENDER)
#ifdef UV1
vertexOutputs.vUV= (uniforms.diffuseMatrix* vec4f(uvUpdated,1.0,0.0)).xy;
#endif
#ifdef UV2
vertexOutputs.vUV= (uniforms.diffuseMatrix* vec4f(uv2Updated,1.0,0.0)).xy;
#endif
#endif
}
`;P.ShadersStoreWGSL[_p]||(P.ShadersStoreWGSL[_p]=mI);const gU={name:_p,shader:mI},xU=Object.freeze(Object.defineProperty({__proto__:null,depthVertexShaderWGSL:gU},Symbol.toStringTag,{value:"Module"})),gp="geometryPixelShader",_I=`#ifdef BUMP
varying vWorldView0: vec4f;varying vWorldView1: vec4f;varying vWorldView2: vec4f;varying vWorldView3: vec4f;varying vNormalW: vec3f;
#else
varying vNormalV: vec3f;
#endif
varying vViewPos: vec4f;
#if defined(POSITION) || defined(BUMP)
varying vPositionW: vec3f;
#endif
#if defined(VELOCITY) || defined(VELOCITY_LINEAR)
varying vCurrentPosition: vec4f;varying vPreviousPosition: vec4f;
#endif
#ifdef NEED_UV
varying vUV: vec2f;
#endif
#ifdef BUMP
uniform vBumpInfos: vec3f;uniform vTangentSpaceParams: vec2f;
#endif
#if defined(REFLECTIVITY)
#if defined(ORMTEXTURE) || defined(SPECULARGLOSSINESSTEXTURE) || defined(REFLECTIVITYTEXTURE)
var reflectivitySamplerSampler: sampler;var reflectivitySampler: texture_2d<f32>;varying vReflectivityUV: vec2f;
#endif
#ifdef ALBEDOTEXTURE
varying vAlbedoUV: vec2f;var albedoSamplerSampler: sampler;var albedoSampler: texture_2d<f32>;
#endif
#ifdef REFLECTIVITYCOLOR
uniform reflectivityColor: vec3f;
#endif
#ifdef ALBEDOCOLOR
uniform albedoColor: vec3f;
#endif
#ifdef METALLIC
uniform metallic: f32;
#endif
#if defined(ROUGHNESS) || defined(GLOSSINESS)
uniform glossiness: f32;
#endif
#endif
#if defined(ALPHATEST) && defined(NEED_UV)
var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;
#endif
#include<clipPlaneFragmentDeclaration>
#include<bumpFragmentMainFunctions>
#include<bumpFragmentFunctions>
#include<helperFunctions>
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#include<clipPlaneFragment>
#ifdef ALPHATEST
if (textureSample(diffuseSampler,diffuseSamplerSampler,input.vUV).a<0.4) {discard;}
#endif
var normalOutput: vec3f;
#ifdef BUMP
var normalW: vec3f=normalize(input.vNormalW);
#include<bumpFragment>
#ifdef NORMAL_WORLDSPACE
normalOutput=normalW;
#else
normalOutput=normalize( (mat4x4f(input.vWorldView0,input.vWorldView1,input.vWorldView2,input.vWorldView3)* vec4f(normalW,0.0)).xyz);
#endif
#else
normalOutput=normalize(input.vNormalV);
#endif
#ifdef ENCODE_NORMAL
normalOutput=normalOutput*0.5+0.5;
#endif
var fragData: array<vec4<f32>,SCENE_MRT_COUNT>;
#ifdef DEPTH
fragData[DEPTH_INDEX]=vec4f(input.vViewPos.z/input.vViewPos.w,0.0,0.0,1.0);
#endif
#ifdef NORMAL
fragData[NORMAL_INDEX]=vec4f(normalOutput,1.0);
#endif
#ifdef SCREENSPACE_DEPTH
fragData[SCREENSPACE_DEPTH_INDEX]=vec4f(fragmentInputs.position.z,0.0,0.0,1.0);
#endif
#ifdef POSITION
fragData[POSITION_INDEX]= vec4f(input.vPositionW,1.0);
#endif
#ifdef VELOCITY
var a: vec2f=(input.vCurrentPosition.xy/input.vCurrentPosition.w)*0.5+0.5;var b: vec2f=(input.vPreviousPosition.xy/input.vPreviousPosition.w)*0.5+0.5;var velocity: vec2f=abs(a-b);velocity= vec2f(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;fragData[VELOCITY_INDEX]= vec4f(velocity,0.0,1.0);
#endif
#ifdef VELOCITY_LINEAR
var velocity : vec2f=vec2f(0.5)*((input.vPreviousPosition.xy /
input.vPreviousPosition.w) -
(input.vCurrentPosition.xy /
input.vCurrentPosition.w));fragData[VELOCITY_LINEAR_INDEX]=vec4f(velocity,0.0,1.0);
#endif
#ifdef REFLECTIVITY
var reflectivity: vec4f= vec4f(0.0,0.0,0.0,1.0);
#ifdef METALLICWORKFLOW
var metal: f32=1.0;var roughness: f32=1.0;
#ifdef ORMTEXTURE
metal*=textureSample(reflectivitySampler,reflectivitySamplerSampler,input.vReflectivityUV).b;roughness*=textureSample(reflectivitySampler,reflectivitySamplerSampler,input.vReflectivityUV).g;
#endif
#ifdef METALLIC
metal*=uniforms.metallic;
#endif
#ifdef ROUGHNESS
roughness*=(1.0-uniforms.glossiness); 
#endif
reflectivity=vec4f(reflectivity.rgb,reflectivity.a-roughness);var color: vec3f= vec3f(1.0);
#ifdef ALBEDOTEXTURE
color=textureSample(albedoSampler,albedoSamplerSampler,input.vAlbedoUV).rgb;
#ifdef GAMMAALBEDO
color=toLinearSpaceVec4(color);
#endif
#endif
#ifdef ALBEDOCOLOR
color*=uniforms.albedoColor.xyz;
#endif
reflectivity=vec4f(mix( vec3f(0.04),color,metal),reflectivity.a);
#else
#if defined(SPECULARGLOSSINESSTEXTURE) || defined(REFLECTIVITYTEXTURE)
reflectivity=textureSample(reflectivitySampler,reflectivitySamplerSampler,input.vReflectivityUV);
#ifdef GAMMAREFLECTIVITYTEXTURE
reflectivity=vec4f(toLinearSpaceVec3(reflectivity.rgb),reflectivity.a);
#endif
#else 
#ifdef REFLECTIVITYCOLOR
reflectivity=vec4f(toLinearSpaceVec3(uniforms.reflectivityColor.xyz),1.0);
#endif
#endif
#ifdef GLOSSINESSS
reflectivity=vec4f(reflectivity.rgb,reflectivity.a*glossiness); 
#endif
#endif
fragData[REFLECTIVITY_INDEX]=reflectivity;
#endif
#if SCENE_MRT_COUNT>0
fragmentOutputs.fragData0=fragData[0];
#endif
#if SCENE_MRT_COUNT>1
fragmentOutputs.fragData1=fragData[1];
#endif
#if SCENE_MRT_COUNT>2
fragmentOutputs.fragData2=fragData[2];
#endif
#if SCENE_MRT_COUNT>3
fragmentOutputs.fragData3=fragData[3];
#endif
#if SCENE_MRT_COUNT>4
fragmentOutputs.fragData4=fragData[4];
#endif
#if SCENE_MRT_COUNT>5
fragmentOutputs.fragData5=fragData[5];
#endif
#if SCENE_MRT_COUNT>6
fragmentOutputs.fragData6=fragData[6];
#endif
#if SCENE_MRT_COUNT>7
fragmentOutputs.fragData7=fragData[7];
#endif
}
`;P.ShadersStoreWGSL[gp]||(P.ShadersStoreWGSL[gp]=_I);const SU={name:gp,shader:_I},vU=Object.freeze(Object.defineProperty({__proto__:null,geometryPixelShaderWGSL:SU},Symbol.toStringTag,{value:"Module"})),xp="geometryVertexShader",gI=`#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<instancesDeclaration>
#include<sceneUboDeclaration>
#include<clipPlaneVertexDeclaration>
attribute position: vec3f;attribute normal: vec3f;
#ifdef NEED_UV
varying vUV: vec2f;
#ifdef ALPHATEST
uniform diffuseMatrix: mat4x4f;
#endif
#ifdef BUMP
uniform bumpMatrix: mat4x4f;varying vBumpUV: vec2f;
#endif
#ifdef REFLECTIVITY
uniform reflectivityMatrix: mat4x4f;uniform albedoMatrix: mat4x4f;varying vReflectivityUV: vec2f;varying vAlbedoUV: vec2f;
#endif
#ifdef UV1
attribute uv: vec2f;
#endif
#ifdef UV2
attribute uv2: vec2f;
#endif
#endif
#ifdef BUMP
varying vWorldView0: vec4f;varying vWorldView1: vec4f;varying vWorldView2: vec4f;varying vWorldView3: vec4f;
#endif
#ifdef BUMP
varying vNormalW: vec3f;
#else
varying vNormalV: vec3f;
#endif
varying vViewPos: vec4f;
#if defined(POSITION) || defined(BUMP)
varying vPositionW: vec3f;
#endif
#if defined(VELOCITY) || defined(VELOCITY_LINEAR)
uniform previousViewProjection: mat4x4f;varying vCurrentPosition: vec4f;varying vPreviousPosition: vec4f;
#endif
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {var positionUpdated: vec3f=input.position;var normalUpdated: vec3f=input.normal;
#ifdef UV1
var uvUpdated: vec2f=input.uv;
#endif
#ifdef UV2
var uv2Updated: vec2f=input.uv2;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#if (defined(VELOCITY) || defined(VELOCITY_LINEAR)) && !defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=scene.viewProjection*finalWorld*vec4f(positionUpdated,1.0);vPreviousPosition=uniforms.previousViewProjection*finalPreviousWorld* vec4f(positionUpdated,1.0);
#endif
#include<bonesVertex>
#include<bakedVertexAnimation>
var worldPos: vec4f= vec4f(finalWorld* vec4f(positionUpdated,1.0));
#ifdef BUMP
let vWorldView=scene.view*finalWorld;vertexOutputs.vWorldView0=vWorldView[0];vertexOutputs.vWorldView1=vWorldView[1];vertexOutputs.vWorldView2=vWorldView[2];vertexOutputs.vWorldView3=vWorldView[3];let normalWorld: mat3x3f= mat3x3f(finalWorld[0].xyz,finalWorld[1].xyz,finalWorld[2].xyz);vertexOutputs.vNormalW=normalize(normalWorld*normalUpdated);
#else
#ifdef NORMAL_WORLDSPACE
vertexOutputs.vNormalV=normalize((finalWorld* vec4f(normalUpdated,0.0)).xyz);
#else
vertexOutputs.vNormalV=normalize(((scene.view*finalWorld)* vec4f(normalUpdated,0.0)).xyz);
#endif
#endif
vertexOutputs.vViewPos=scene.view*worldPos;
#if (defined(VELOCITY) || defined(VELOCITY_LINEAR)) && defined(BONES_VELOCITY_ENABLED)
vertexOutputs.vCurrentPosition=scene.viewProjection*finalWorld* vec4f(positionUpdated,1.0);
#if NUM_BONE_INFLUENCERS>0
var previousInfluence: mat4x4f;previousInfluence=mPreviousBones[ i32(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
previousInfluence+=mPreviousBones[ i32(matricesIndices[1])]*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
previousInfluence+=mPreviousBones[ i32(matricesIndices[2])]*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
previousInfluence+=mPreviousBones[ i32(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
previousInfluence+=mPreviousBones[ i32(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
previousInfluence+=mPreviousBones[ i32(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
previousInfluence+=mPreviousBones[ i32(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
previousInfluence+=mPreviousBones[ i32(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
vertexOutputs.vPreviousPosition=uniforms.previousViewProjection*finalPreviousWorld*previousInfluence* vec4f(positionUpdated,1.0);
#else
vertexOutputs.vPreviousPosition=uniforms.previousViewProjection*finalPreviousWorld* vec4f(positionUpdated,1.0);
#endif
#endif
#if defined(POSITION) || defined(BUMP)
vertexOutputs.vPositionW=worldPos.xyz/worldPos.w;
#endif
vertexOutputs.position=scene.viewProjection*finalWorld* vec4f(positionUpdated,1.0);
#include<clipPlaneVertex>
#ifdef NEED_UV
#ifdef UV1
#if defined(ALPHATEST) && defined(ALPHATEST_UV1)
vertexOutputs.vUV=(uniforms.diffuseMatrix* vec4f(uvUpdated,1.0,0.0)).xy;
#else
vertexOutputs.vUV=uvUpdated;
#endif
#ifdef BUMP_UV1
vertexOutputs.vBumpUV=(uniforms.bumpMatrix* vec4f(uvUpdated,1.0,0.0)).xy;
#endif
#ifdef REFLECTIVITY_UV1
vertexOutputs.vReflectivityUV=(uniforms.reflectivityMatrix* vec4f(uvUpdated,1.0,0.0)).xy;
#endif
#ifdef ALBEDO_UV1
vertexOutputs.vAlbedoUV=(uniforms.albedoMatrix* vec4f(uvUpdated,1.0,0.0)).xy;
#endif
#endif
#ifdef UV2
#if defined(ALPHATEST) && defined(ALPHATEST_UV2)
vertexOutputs.vUV=(uniforms.diffuseMatrix* vec4f(uv2Updated,1.0,0.0)).xy;
#else
vertexOutputs.vUV=uv2Updated;
#endif
#ifdef BUMP_UV2
vertexOutputs.vBumpUV=(uniforms.bumpMatrix* vec4f(uv2Updated,1.0,0.0)).xy;
#endif
#ifdef REFLECTIVITY_UV2
vertexOutputs.vReflectivityUV=(uniforms.reflectivityMatrix* vec4f(uv2Updated,1.0,0.0)).xy;
#endif
#ifdef ALBEDO_UV2
vertexOutputs.vAlbedoUV=(uniforms.albedoMatrix* vec4f(uv2Updated,1.0,0.0)).xy;
#endif
#endif
#endif
#include<bumpVertex>
}
`;P.ShadersStoreWGSL[xp]||(P.ShadersStoreWGSL[xp]=gI);const bU={name:xp,shader:gI},yU=Object.freeze(Object.defineProperty({__proto__:null,geometryVertexShaderWGSL:bU},Symbol.toStringTag,{value:"Module"})),Ab="boundingBoxRendererFragmentDeclaration",TU=`uniform vec4 color;
`;P.IncludesShadersStore[Ab]||(P.IncludesShadersStore[Ab]=TU);const Db="boundingBoxRendererUboDeclaration",CU=`#ifdef WEBGL2
uniform vec4 color;uniform mat4 world;uniform mat4 viewProjection;
#ifdef MULTIVIEW
uniform mat4 viewProjectionR;
#endif
#else
layout(std140,column_major) uniform;uniform BoundingBoxRenderer {vec4 color;mat4 world;mat4 viewProjection;mat4 viewProjectionR;};
#endif
`;P.IncludesShadersStore[Db]||(P.IncludesShadersStore[Db]=CU);const Sp="boundingBoxRendererPixelShader",xI=`#include<__decl__boundingBoxRendererFragment>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
gl_FragColor=color;
#define CUSTOM_FRAGMENT_MAIN_END
}`;P.ShadersStore[Sp]||(P.ShadersStore[Sp]=xI);const PU={name:Sp,shader:xI},Ob=Object.freeze(Object.defineProperty({__proto__:null,boundingBoxRendererPixelShader:PU},Symbol.toStringTag,{value:"Module"})),wb="boundingBoxRendererVertexDeclaration",EU=`uniform mat4 world;uniform mat4 viewProjection;
#ifdef MULTIVIEW
uniform mat4 viewProjectionR;
#endif
`;P.IncludesShadersStore[wb]||(P.IncludesShadersStore[wb]=EU);const vp="boundingBoxRendererVertexShader",SI=`attribute vec3 position;
#include<__decl__boundingBoxRendererVertex>
#ifdef INSTANCES
attribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;
#endif
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#ifdef INSTANCES
mat4 finalWorld=mat4(world0,world1,world2,world3);vec4 worldPos=finalWorld*vec4(position,1.0);
#else
vec4 worldPos=world*vec4(position,1.0);
#endif
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}
#else
gl_Position=viewProjection*worldPos;
#endif
#define CUSTOM_VERTEX_MAIN_END
}
`;P.ShadersStore[vp]||(P.ShadersStore[vp]=SI);const IU={name:vp,shader:SI},Nb=Object.freeze(Object.defineProperty({__proto__:null,boundingBoxRendererVertexShader:IU},Symbol.toStringTag,{value:"Module"})),bp="boundingBoxRendererPixelShader",vI=`uniform color: vec4f;
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
fragmentOutputs.color=uniforms.color;
#define CUSTOM_FRAGMENT_MAIN_END
}`;P.ShadersStoreWGSL[bp]||(P.ShadersStoreWGSL[bp]=vI);const RU={name:bp,shader:vI},Fb=Object.freeze(Object.defineProperty({__proto__:null,boundingBoxRendererPixelShaderWGSL:RU},Symbol.toStringTag,{value:"Module"})),yp="boundingBoxRendererVertexShader",bI=`attribute position: vec3f;uniform world: mat4x4f;uniform viewProjection: mat4x4f;
#ifdef INSTANCES
attribute world0 : vec4<f32>;attribute world1 : vec4<f32>;attribute world2 : vec4<f32>;attribute world3 : vec4<f32>;
#endif
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
#ifdef INSTANCES
var finalWorld=mat4x4<f32>(vertexInputs.world0,vertexInputs.world1,vertexInputs.world2,vertexInputs.world3);var worldPos: vec4f=finalWorld* vec4f(input.position,1.0);
#else
var worldPos: vec4f=uniforms.world* vec4f(input.position,1.0);
#endif
vertexOutputs.position=uniforms.viewProjection*worldPos;
#define CUSTOM_VERTEX_MAIN_END
}
`;P.ShadersStoreWGSL[yp]||(P.ShadersStoreWGSL[yp]=bI);const MU={name:yp,shader:bI},Lb=Object.freeze(Object.defineProperty({__proto__:null,boundingBoxRendererVertexShaderWGSL:MU},Symbol.toStringTag,{value:"Module"})),Tp="linePixelShader",yI=`#include<clipPlaneFragmentDeclaration>
uniform vec4 color;
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<logDepthDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<logDepthFragment>
#include<clipPlaneFragment>
gl_FragColor=color;
#define CUSTOM_FRAGMENT_MAIN_END
}`;P.ShadersStore[Tp]||(P.ShadersStore[Tp]=yI);const AU={name:Tp,shader:yI},DU=Object.freeze(Object.defineProperty({__proto__:null,linePixelShader:AU},Symbol.toStringTag,{value:"Module"})),Bb="lineVertexDeclaration",OU=`uniform mat4 viewProjection;
#define ADDITIONAL_VERTEX_DECLARATION
`;P.IncludesShadersStore[Bb]||(P.IncludesShadersStore[Bb]=OU);const Vb="lineUboDeclaration",wU=`layout(std140,column_major) uniform;
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;P.IncludesShadersStore[Vb]||(P.IncludesShadersStore[Vb]=wU);const Cp="lineVertexShader",TI=`#include<__decl__lineVertex>
#include<instancesDeclaration>
#include<clipPlaneVertexDeclaration>
attribute vec3 position;attribute vec4 normal;uniform float width;uniform float aspectRatio;
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
mat4 worldViewProjection=viewProjection*finalWorld;vec4 viewPosition=worldViewProjection*vec4(position,1.0);vec4 viewPositionNext=worldViewProjection*vec4(normal.xyz,1.0);vec2 currentScreen=viewPosition.xy/viewPosition.w;vec2 nextScreen=viewPositionNext.xy/viewPositionNext.w;currentScreen.x*=aspectRatio;nextScreen.x*=aspectRatio;vec2 dir=normalize(nextScreen-currentScreen);vec2 normalDir=vec2(-dir.y,dir.x);normalDir*=width/2.0;normalDir.x/=aspectRatio;vec4 offset=vec4(normalDir*normal.w,0.0,0.0);gl_Position=viewPosition+offset;
#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)
vec4 worldPos=finalWorld*vec4(position,1.0);
#include<clipPlaneVertex>
#endif
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStore[Cp]||(P.ShadersStore[Cp]=TI);const NU={name:Cp,shader:TI},FU=Object.freeze(Object.defineProperty({__proto__:null,lineVertexShader:NU},Symbol.toStringTag,{value:"Module"})),Pp="linePixelShader",CI=`#include<clipPlaneFragmentDeclaration>
uniform color: vec4f;
#include<logDepthDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<logDepthFragment>
#include<clipPlaneFragment>
fragmentOutputs.color=uniforms.color;
#define CUSTOM_FRAGMENT_MAIN_END
}`;P.ShadersStoreWGSL[Pp]||(P.ShadersStoreWGSL[Pp]=CI);const LU={name:Pp,shader:CI},BU=Object.freeze(Object.defineProperty({__proto__:null,linePixelShaderWGSL:LU},Symbol.toStringTag,{value:"Module"})),Ep="lineVertexShader",PI=`#define ADDITIONAL_VERTEX_DECLARATION
#include<instancesDeclaration>
#include<clipPlaneVertexDeclaration>
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
attribute position: vec3f;attribute normal: vec4f;uniform width: f32;uniform aspectRatio: f32;
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
var worldViewProjection: mat4x4f=scene.viewProjection*finalWorld;var viewPosition: vec4f=worldViewProjection* vec4f(input.position,1.0);var viewPositionNext: vec4f=worldViewProjection* vec4f(input.normal.xyz,1.0);var currentScreen: vec2f=viewPosition.xy/viewPosition.w;var nextScreen: vec2f=viewPositionNext.xy/viewPositionNext.w;currentScreen=vec2f(currentScreen.x*uniforms.aspectRatio,currentScreen.y);nextScreen=vec2f(nextScreen.x*uniforms.aspectRatio,nextScreen.y);var dir: vec2f=normalize(nextScreen-currentScreen);var normalDir: vec2f= vec2f(-dir.y,dir.x);normalDir*=uniforms.width/2.0;normalDir=vec2f(normalDir.x/uniforms.aspectRatio,normalDir.y);var offset: vec4f= vec4f(normalDir*input.normal.w,0.0,0.0);vertexOutputs.position=viewPosition+offset;
#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)
var worldPos: vec4f=finalWorld*vec4f(input.position,1.0);
#include<clipPlaneVertex>
#endif
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStoreWGSL[Ep]||(P.ShadersStoreWGSL[Ep]=PI);const VU={name:Ep,shader:PI},kU=Object.freeze(Object.defineProperty({__proto__:null,lineVertexShaderWGSL:VU},Symbol.toStringTag,{value:"Module"})),Ip="outlinePixelShader",EI=`#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
uniform vec4 color;
#ifdef ALPHATEST
varying vec2 vUV;uniform sampler2D diffuseSampler;
#endif
#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
#ifdef ALPHATEST
if (texture2D(diffuseSampler,vUV).a<0.4)
discard;
#endif
#include<logDepthFragment>
gl_FragColor=color;
#define CUSTOM_FRAGMENT_MAIN_END
}`;P.ShadersStore[Ip]||(P.ShadersStore[Ip]=EI);const zU={name:Ip,shader:EI},UU=Object.freeze(Object.defineProperty({__proto__:null,outlinePixelShader:zU},Symbol.toStringTag,{value:"Module"})),Rp="outlineVertexShader",II=`attribute vec3 position;attribute vec3 normal;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<clipPlaneVertexDeclaration>
uniform float offset;
#include<instancesDeclaration>
uniform mat4 viewProjection;
#ifdef ALPHATEST
varying vec2 vUV;uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{vec3 positionUpdated=position;vec3 normalUpdated=normal;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#ifdef UV2
vec2 uv2Updated=uv2;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
vec3 offsetPosition=positionUpdated+(normalUpdated*offset);
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(offsetPosition,1.0);gl_Position=viewProjection*worldPos;
#ifdef ALPHATEST
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2Updated,1.0,0.0));
#endif
#endif
#include<clipPlaneVertex>
#include<logDepthVertex>
}
`;P.ShadersStore[Rp]||(P.ShadersStore[Rp]=II);const GU={name:Rp,shader:II},WU=Object.freeze(Object.defineProperty({__proto__:null,outlineVertexShader:GU},Symbol.toStringTag,{value:"Module"})),Mp="outlinePixelShader",RI=`uniform color: vec4f;
#ifdef ALPHATEST
varying vUV: vec2f;var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;
#endif
#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
#ifdef ALPHATEST
if (textureSample(diffuseSampler,diffuseSamplerSampler,fragmentInputs.vUV).a<0.4) {discard;}
#endif
#include<logDepthFragment>
fragmentOutputs.color=uniforms.color;
#define CUSTOM_FRAGMENT_MAIN_END
}`;P.ShadersStoreWGSL[Mp]||(P.ShadersStoreWGSL[Mp]=RI);const $U={name:Mp,shader:RI},HU=Object.freeze(Object.defineProperty({__proto__:null,outlinePixelShaderWGSL:$U},Symbol.toStringTag,{value:"Module"})),Ap="outlineVertexShader",MI=`attribute position: vec3f;attribute normal: vec3f;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<clipPlaneVertexDeclaration>
uniform offset: f32;
#include<instancesDeclaration>
uniform viewProjection: mat4x4f;
#ifdef ALPHATEST
varying vUV: vec2f;uniform diffuseMatrix: mat4x4f; 
#ifdef UV1
attribute uv: vec2f;
#endif
#ifdef UV2
attribute uv2: vec2f;
#endif
#endif
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input: VertexInputs)->FragmentInputs {var positionUpdated: vec3f=vertexInputs.position;var normalUpdated: vec3f=vertexInputs.normal;
#ifdef UV1
var uvUpdated: vec2f=vertexInputs.uv;
#endif
#ifdef UV2
var uv2Updated: vec2f=vertexInputs.uv2;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
var offsetPosition: vec3f=positionUpdated+(normalUpdated*uniforms.offset);
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
var worldPos: vec4f=finalWorld*vec4f(offsetPosition,1.0);vertexOutputs.position=uniforms.viewProjection*worldPos;
#ifdef ALPHATEST
#ifdef UV1
vertexOutputs.vUV=(uniforms.diffuseMatrix*vec4f(uvUpdated,1.0,0.0)).xy;
#endif
#ifdef UV2
vertexOutputs.vUV=(uniforms.diffuseMatrix*vec4f(uv2Updated,1.0,0.0)).xy;
#endif
#endif
#include<clipPlaneVertex>
#include<logDepthVertex>
}
`;P.ShadersStoreWGSL[Ap]||(P.ShadersStoreWGSL[Ap]=MI);const jU={name:Ap,shader:MI},YU=Object.freeze(Object.defineProperty({__proto__:null,outlineVertexShaderWGSL:jU},Symbol.toStringTag,{value:"Module"})),Dp="copyTexture3DLayerToTexturePixelShader",AI=`precision highp sampler3D;uniform sampler3D textureSampler;uniform int layerNum;varying vec2 vUV;void main(void) {vec3 coord=vec3(0.0,0.0,float(layerNum));coord.xy=vec2(vUV.x,vUV.y)*vec2(textureSize(textureSampler,0).xy);vec3 color=texelFetch(textureSampler,ivec3(coord),0).rgb;gl_FragColor=vec4(color,1);}
`;P.ShadersStore[Dp]||(P.ShadersStore[Dp]=AI);const XU={name:Dp,shader:AI},_$=Object.freeze(Object.defineProperty({__proto__:null,copyTexture3DLayerToTexturePixelShader:XU},Symbol.toStringTag,{value:"Module"})),Op="copyTexture3DLayerToTexturePixelShader",DI=`var textureSampler: texture_3d<f32>;uniform layerNum: i32;varying vUV: vec2f;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {let coord=vec3f(vec2f(input.vUV.x,input.vUV.y)*vec2f(textureDimensions(textureSampler,0).xy),f32(uniforms.layerNum));let color=textureLoad(textureSampler,vec3i(coord),0).rgb;fragmentOutputs.color= vec4f(color,1);}`;P.ShadersStoreWGSL[Op]||(P.ShadersStoreWGSL[Op]=DI);const ZU={name:Op,shader:DI},g$=Object.freeze(Object.defineProperty({__proto__:null,copyTexture3DLayerToTexturePixelShaderWGSL:ZU},Symbol.toStringTag,{value:"Module"})),wp="iblShadowVoxelTracingPixelShader",OI=`precision highp sampler2D;precision highp sampler3D;
#define PI 3.1415927
varying vec2 vUV;
#define DISABLE_UNIFORMITY_ANALYSIS
uniform sampler2D depthSampler;uniform sampler2D worldNormalSampler;uniform sampler2D blueNoiseSampler;uniform sampler2D icdfSampler;uniform sampler3D voxelGridSampler;
#ifdef COLOR_SHADOWS
uniform samplerCube iblSampler;
#endif
uniform vec4 shadowParameters;
#define SHADOWdirs shadowParameters.x
#define SHADOWframe shadowParameters.y
#define SHADOWenvRot shadowParameters.w
uniform vec4 voxelBiasParameters;
#define highestMipLevel voxelBiasParameters.z
uniform vec4 sssParameters;
#define SSSsamples sssParameters.x
#define SSSstride sssParameters.y
#define SSSmaxDistance sssParameters.z
#define SSSthickness sssParameters.w
uniform vec4 shadowOpacity;uniform mat4 projMtx;uniform mat4 viewMtx;uniform mat4 invProjMtx;uniform mat4 invViewMtx;uniform mat4 wsNormalizationMtx;uniform mat4 invVPMtx;
#define PI 3.1415927
#define GOLD 0.618034
struct AABB3f {vec3 m_min;vec3 m_max;};struct Ray {vec3 orig;vec3 dir;vec3 dir_rcp;float t_min;float t_max;};Ray make_ray(const vec3 origin,const vec3 direction,const float tmin,
const float tmax) {Ray ray;ray.orig=origin;ray.dir=direction;ray.dir_rcp=1.0f/direction;ray.t_min=tmin;ray.t_max=tmax;return ray;}
bool ray_box_intersection(const in AABB3f aabb,const in Ray ray,
out float distance_near,out float distance_far) {vec3 tbot=ray.dir_rcp*(aabb.m_min-ray.orig);vec3 ttop=ray.dir_rcp*(aabb.m_max-ray.orig);vec3 tmin=min(ttop,tbot);vec3 tmax=max(ttop,tbot);distance_near=max(ray.t_min,max(tmin.x,max(tmin.y,tmin.z)));distance_far=min(ray.t_max,min(tmax.x,min(tmax.y,tmax.z)));return distance_near<=distance_far;}
#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
struct VoxelMarchDiagnosticInfo {float heat;ivec3 voxel_intersect_coords;};
#endif
uint hash(uint i) {i ^= i>>16u;i*=0x7FEB352Du;i ^= i>>15u;i*=0x846CA68Bu;i ^= i>>16u;return i;}
float uint2float(uint i) {return uintBitsToFloat(0x3F800000u | (i>>9u))-1.0;}
vec3 uv_to_normal(vec2 uv) {vec3 N;vec2 uvRange=uv;float theta=uvRange.x*2.0*PI;float phi=uvRange.y*PI;N.x=cos(theta)*sin(phi);N.z=sin(theta)*sin(phi);N.y=cos(phi);return N;}
vec2 plasticSequence(const uint rstate) {return vec2(uint2float(rstate*3242174889u),
uint2float(rstate*2447445414u));}
float goldenSequence(const uint rstate) {return uint2float(rstate*2654435769u);}
float distanceSquared(vec2 a,vec2 b) {vec2 diff=a-b;return dot(diff,diff);}
void genTB(const vec3 N,out vec3 T,out vec3 B) {float s=N.z<0.0 ? -1.0 : 1.0;float a=-1.0/(s+N.z);float b=N.x*N.y*a;T=vec3(1.0+s*N.x*N.x*a,s*b,-s*N.x);B=vec3(b,s+N.y*N.y*a,-N.y);}
int stack[24]; 
#define PUSH(i) stack[stackLevel++]=i; 
#define POP() stack[--stackLevel] 
#ifdef VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
bool anyHitVoxels(const Ray ray_vs,
out VoxelMarchDiagnosticInfo voxel_march_diagnostic_info) {
#else
bool anyHitVoxels(const Ray ray_vs) {
#endif
vec3 invD=ray_vs.dir_rcp;vec3 D=ray_vs.dir;vec3 O=ray_vs.orig;ivec3 negD=ivec3(lessThan(D,vec3(0,0,0)));int voxel0=negD.x | negD.y<<1 | negD.z<<2;vec3 t0=-O*invD,t1=(vec3(1.0)-O)*invD;int maxLod=int(highestMipLevel);int stackLevel=0;
#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
uint steps=0u;
#endif
PUSH(maxLod<<24);while (stackLevel>0) {int elem=POP();ivec4 Coords =
ivec4(elem & 0xFF,elem>>8 & 0xFF,elem>>16 & 0xFF,elem>>24);if (Coords.w==0) {
#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
voxel_march_diagnostic_info.heat=float(steps)/24.0;
#endif
return true;}
#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
++steps;
#endif
float invRes=exp2(float(Coords.w-maxLod));vec3 bbmin=invRes*vec3(Coords.xyz+negD);vec3 bbmax=invRes*vec3(Coords.xyz-negD+ivec3(1));vec3 mint=mix(t0,t1,bbmin);vec3 maxt=mix(t0,t1,bbmax);vec3 midt=0.5*(mint+maxt);mint.x=max(0.0,mint.x);midt.x=max(0.0,midt.x);int nodeMask=int(
round(texelFetch(voxelGridSampler,Coords.xyz,Coords.w).x*255.0));Coords.w--;int voxelBit=voxel0;Coords.xyz=(Coords.xyz<<1)+negD;int packedCoords =
Coords.x | Coords.y<<8 | Coords.z<<16 | Coords.w<<24;if (max(mint.x,max(mint.y,mint.z))<min(midt.x,min(midt.y,midt.z)) &&
(1<<voxelBit & nodeMask) != 0)
PUSH(packedCoords);voxelBit ^= 0x1;packedCoords ^= 0x00001;if (max(midt.x,max(mint.y,mint.z))<min(maxt.x,min(midt.y,midt.z)) &&
(1<<voxelBit & nodeMask) != 0)
PUSH(packedCoords);voxelBit ^= 0x2;packedCoords ^= 0x00100;if (max(midt.x,max(midt.y,mint.z))<min(maxt.x,min(maxt.y,midt.z)) &&
(1<<voxelBit & nodeMask) != 0)
PUSH(packedCoords);voxelBit ^= 0x1;packedCoords ^= 0x00001;if (max(mint.x,max(midt.y,mint.z))<min(midt.x,min(maxt.y,midt.z)) &&
(1<<voxelBit & nodeMask) != 0)
PUSH(packedCoords);voxelBit ^= 0x4;packedCoords ^= 0x10000;if (max(mint.x,max(midt.y,midt.z))<min(midt.x,min(maxt.y,maxt.z)) &&
(1<<voxelBit & nodeMask) != 0)
PUSH(packedCoords);voxelBit ^= 0x1;packedCoords ^= 0x00001;if (max(midt.x,max(midt.y,midt.z))<min(maxt.x,min(maxt.y,maxt.z)) &&
(1<<voxelBit & nodeMask) != 0)
PUSH(packedCoords);voxelBit ^= 0x2;packedCoords ^= 0x00100;if (max(midt.x,max(mint.y,midt.z))<min(maxt.x,min(midt.y,maxt.z)) &&
(1<<voxelBit & nodeMask) != 0)
PUSH(packedCoords);voxelBit ^= 0x1;packedCoords ^= 0x00001;if (max(mint.x,max(mint.y,midt.z))<min(midt.x,min(midt.y,maxt.z)) &&
(1<<voxelBit & nodeMask) != 0)
PUSH(packedCoords);}
#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
voxel_march_diagnostic_info.heat=float(steps)/24.0;
#endif
return false;}
float linearizeDepth(float depth,float near,float far) {return (near*far)/(far-depth*(far-near));}
float screenSpaceShadow(vec3 csOrigin,vec3 csDirection,vec2 csZBufferSize,
float nearPlaneZ,float farPlaneZ,float noise) {
#ifdef RIGHT_HANDED
float csZDir=-1.0;
#else 
float csZDir=1.0;
#endif
float ssSamples=SSSsamples;float ssMaxDist=SSSmaxDistance;float ssStride=SSSstride;float ssThickness=SSSthickness;float rayLength =
csZDir*(csOrigin.z+ssMaxDist*csDirection.z)<csZDir*nearPlaneZ
? 
(nearPlaneZ-csOrigin.z)/csDirection.z
: ssMaxDist;vec3 csEndPoint=csOrigin+rayLength*csDirection;vec4 H0=projMtx*vec4(csOrigin,1.0);vec4 H1=projMtx*vec4(csEndPoint,1.0);vec2 Z0=vec2(csOrigin.z ,1.0)/H0.w;vec2 Z1=vec2(csEndPoint.z,1.0)/H1.w;vec2 P0=csZBufferSize*(0.5*H0.xy*Z0.y+0.5);vec2 P1=csZBufferSize*(0.5*H1.xy*Z1.y+0.5);P1+=vec2(distanceSquared(P0,P1)<0.0001 ? 0.01 : 0.0);vec2 delta=P1-P0;bool permute=false;if (abs(delta.x)<abs(delta.y)) {permute=true;P0=P0.yx;P1=P1.yx;delta=delta.yx;}
float stepDirection=sign(delta.x);float invdx=stepDirection/delta.x;vec2 dP=ssStride*vec2(stepDirection,invdx*delta.y);vec2 dZ=ssStride*invdx*(Z1-Z0);float opacity=0.0;vec2 P=P0+noise*dP;vec2 Z=Z0+noise*dZ;float end=P1.x*stepDirection;float rayZMax=csZDir*Z.x/Z.y;float sceneDepth=rayZMax;Z+=dZ;for (float stepCount=0.0;opacity<1.0 && P.x*stepDirection<end && sceneDepth>0.0 && stepCount<ssSamples;stepCount++,P+=dP,
Z+=dZ) { 
ivec2 coords=ivec2(permute ? P.yx : P);sceneDepth=texelFetch(depthSampler,coords,0).x;sceneDepth=linearizeDepth(sceneDepth,nearPlaneZ,farPlaneZ);sceneDepth=csZDir*sceneDepth;if (sceneDepth<=0.0) {break;}
float rayZMin=rayZMax;rayZMax=csZDir*Z.x/Z.y;opacity+=max(opacity,step(rayZMax,sceneDepth+ssThickness)*step(sceneDepth,rayZMin));}
return opacity;}
#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
float voxelShadow(vec3 wsOrigin,vec3 wsDirection,vec3 wsNormal,
vec2 DitherNoise,
out VoxelMarchDiagnosticInfo voxel_march_diagnostic_info) {
#else
float voxelShadow(vec3 wsOrigin,vec3 wsDirection,vec3 wsNormal,
vec2 DitherNoise) {
#endif
float vxResolution=float(textureSize(voxelGridSampler,0).x);vec3 T,B;genTB(wsDirection,T,B);vec2 DitherXY=sqrt(DitherNoise.x)*vec2(cos(2.0*PI*DitherNoise.y),
sin(2.0*PI*DitherNoise.y));float sceneScale=wsNormalizationMtx[0][0];vec3 Dithering =
(voxelBiasParameters.x*wsNormal+voxelBiasParameters.y*wsDirection +
DitherXY.x*T+DitherXY.y*B) /
vxResolution;vec3 O=0.5*wsOrigin+0.5+Dithering;Ray ray_vs=make_ray(O,wsDirection,0.0,10.0);AABB3f voxel_aabb;voxel_aabb.m_min=vec3(0);voxel_aabb.m_max=vec3(1);float near,far;if (!ray_box_intersection(voxel_aabb,ray_vs,near,far))
return 0.0;ray_vs.t_min=max(ray_vs.t_min,near);ray_vs.t_max=min(ray_vs.t_max,far);
#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
return anyHitVoxels(ray_vs,voxel_march_diagnostic_info) ? 1.0f : 0.0f;
#else
return anyHitVoxels(ray_vs) ? 1.0f : 0.0f;
#endif
}
void main(void) {uint nbDirs=uint(SHADOWdirs);uint frameId=uint(SHADOWframe);float envRot=SHADOWenvRot;vec2 Resolution=vec2(textureSize(depthSampler,0));ivec2 currentPixel=ivec2(vUV*Resolution);uint GlobalIndex=(frameId*uint(Resolution.y)+uint(currentPixel.y)) *
uint(Resolution.x) +
uint(currentPixel.x);vec3 N=texelFetch(worldNormalSampler,currentPixel,0).xyz;if (length(N)<0.01) {glFragColor=vec4(1.0,1.0,0.0,1.0);return;}
float normalizedRotation=envRot/(2.0*PI);float depth=texelFetch(depthSampler,currentPixel,0).x;
#ifndef IS_NDC_HALF_ZRANGE
depth=depth*2.0-1.0;
#endif
vec2 temp=(vec2(currentPixel)+vec2(0.5))*2.0/Resolution-vec2(1.0);vec4 VP=invProjMtx*vec4(temp.x,-temp.y,depth,1.0);VP/=VP.w;N=normalize(N);vec3 noise=texelFetch(blueNoiseSampler,currentPixel & 0xFF,0).xyz;noise.z=fract(noise.z+goldenSequence(frameId*nbDirs));
#ifdef VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
float heat=0.0f;
#endif
float shadowAccum=0.001;float specShadowAccum=0.001;float sampleWeight=0.001;
#ifdef COLOR_SHADOWS
vec3 totalLight=vec3(0.001);vec3 shadowedLight=vec3(0.0);
#endif
for (uint i=0u; i<nbDirs; i++) {uint dirId=nbDirs*GlobalIndex+i;vec4 L;vec2 T;{vec2 r=plasticSequence(frameId*nbDirs+i);r=fract(r+vec2(2.0)*abs(noise.xy-vec2(0.5)));T.x=textureLod(icdfSampler,vec2(r.x,0.0),0.0).x;T.y=textureLod(icdfSampler,vec2(T.x,r.y),0.0).y;L=vec4(uv_to_normal(vec2(T.x-normalizedRotation,T.y)),0);
#ifndef RIGHT_HANDED
L.z*=-1.0;
#endif
}
#ifdef COLOR_SHADOWS
vec3 lightDir=uv_to_normal(vec2(1.0-fract(T.x+0.25),T.y));vec3 ibl=textureLod(iblSampler,lightDir,0.0).xyz;float pdf=textureLod(icdfSampler,T,0.0).z;
#endif
float cosNL=dot(N,L.xyz);float opacity=0.0;if (cosNL>0.0) {vec4 VP2=VP;VP2.y*=-1.0;vec4 unormWP=invViewMtx*VP2;vec3 WP=(wsNormalizationMtx*unormWP).xyz;vec2 vxNoise=vec2(uint2float(hash(dirId*2u)),uint2float(hash(dirId*2u+1u)));
#ifdef VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
VoxelMarchDiagnosticInfo voxel_march_diagnostic_info;opacity=max(opacity,shadowOpacity.x*voxelShadow(WP,L.xyz,N,vxNoise,voxel_march_diagnostic_info));heat+=voxel_march_diagnostic_info.heat;
#else
opacity =
max(opacity,shadowOpacity.x*voxelShadow(WP,L.xyz,N,vxNoise));
#endif
vec3 VL=(viewMtx*L).xyz;
#ifdef RIGHT_HANDED
float nearPlaneZ=-projMtx[3][2]/(projMtx[2][2]-1.0); 
float farPlaneZ=-projMtx[3][2]/(projMtx[2][2]+1.0);
#else
float nearPlaneZ=-projMtx[3][2]/(projMtx[2][2]+1.0); 
float farPlaneZ=-projMtx[3][2]/(projMtx[2][2]-1.0);
#endif
float ssShadow=shadowOpacity.y *
screenSpaceShadow(VP2.xyz,VL,Resolution,nearPlaneZ,farPlaneZ,
abs(2.0*noise.z-1.0));opacity=max(opacity,ssShadow);
#ifdef COLOR_SHADOWS
vec3 light=pdf<1e-6 ? vec3(0.0) : vec3(cosNL)/vec3(pdf)*ibl;shadowedLight+=light*opacity;totalLight+=light;
#else
float rcos=(1.0-cosNL);shadowAccum+=(1.0-opacity*(1.0-pow(rcos,8.0)));sampleWeight+=1.0;vec3 VR=-(viewMtx*vec4(reflect(-L.xyz,N),0.0)).xyz;specShadowAccum+=max(1.0-(opacity*pow(VR.z,8.0)),0.0);
#endif
}
noise.z=fract(noise.z+GOLD);}
#ifdef COLOR_SHADOWS
vec3 shadow=(totalLight-shadowedLight)/totalLight;float maxShadow=max(max(shadow.x,max(shadow.y,shadow.z)),1.0);glFragColor=vec4(shadow/maxShadow,1.0);
#else
#ifdef VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
gl_FragColor=vec4(shadowAccum/float(sampleWeight),
specShadowAccum/float(sampleWeight),heat/float(sampleWeight),1.0);
#else
gl_FragColor=vec4(shadowAccum/float(sampleWeight),specShadowAccum/float(sampleWeight),0.0,1.0);
#endif
#endif
}`;P.ShadersStore[wp]||(P.ShadersStore[wp]=OI);const qU={name:wp,shader:OI},x$=Object.freeze(Object.defineProperty({__proto__:null,iblShadowVoxelTracingPixelShader:qU},Symbol.toStringTag,{value:"Module"})),Np="iblShadowVoxelTracingPixelShader",wI=`#define PI 3.1415927
varying vUV: vec2f;
#define DISABLE_UNIFORMITY_ANALYSIS
var depthSampler: texture_2d<f32>;var worldNormalSampler : texture_2d<f32>;var blueNoiseSampler: texture_2d<f32>;var icdfSamplerSampler: sampler;var icdfSampler: texture_2d<f32>;var voxelGridSamplerSampler: sampler;var voxelGridSampler: texture_3d<f32>;
#ifdef COLOR_SHADOWS
var iblSamplerSampler: sampler;var iblSampler: texture_cube<f32>;
#endif
uniform shadowParameters: vec4f;
#define SHADOWdirs uniforms.shadowParameters.x
#define SHADOWframe uniforms.shadowParameters.y
#define SHADOWenvRot uniforms.shadowParameters.w
uniform voxelBiasParameters : vec4f;
#define highestMipLevel uniforms.voxelBiasParameters.z
uniform sssParameters: vec4f;
#define SSSsamples uniforms.sssParameters.x
#define SSSstride uniforms.sssParameters.y
#define SSSmaxDistance uniforms.sssParameters.z
#define SSSthickness uniforms.sssParameters.w
uniform shadowOpacity: vec4f;uniform projMtx: mat4x4f;uniform viewMtx: mat4x4f;uniform invProjMtx: mat4x4f;uniform invViewMtx: mat4x4f;uniform wsNormalizationMtx: mat4x4f;uniform invVPMtx: mat4x4f;
#define PI 3.1415927
#define GOLD 0.618034
struct AABB3f {m_min: vec3f,
m_max: vec3f,};struct Ray {orig: vec3f,
dir: vec3f,
dir_rcp: vec3f,
t_min: f32,
t_max: f32,};fn make_ray(origin: vec3f,direction: vec3f,tmin: f32,
tmax: f32)->Ray {var ray: Ray;ray.orig=origin;ray.dir=direction;ray.dir_rcp=1.0f/direction;ray.t_min=tmin;ray.t_max=tmax;return ray;}
fn ray_box_intersection(aabb: AABB3f,ray: Ray ,
distance_near: ptr<function,f32>,distance_far: ptr<function,f32>)->bool{var tbot: vec3f=ray.dir_rcp*(aabb.m_min-ray.orig);var ttop: vec3f=ray.dir_rcp*(aabb.m_max-ray.orig);var tmin: vec3f=min(ttop,tbot);var tmax: vec3f=max(ttop,tbot);*distance_near=max(ray.t_min,max(tmin.x,max(tmin.y,tmin.z)));*distance_far=min(ray.t_max,min(tmax.x,min(tmax.y,tmax.z)));return *distance_near<=*distance_far;}
#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
struct VoxelMarchDiagnosticInfo {heat: f32,
voxel_intersect_coords: vec3i,};
#endif
fn hash(i: u32)->u32 {var temp=i ^ (i>>16u);temp*=0x7FEB352Du;temp ^= temp>>15u;temp*=0x846CA68Bu;temp ^= temp>>16u;return temp;}
fn uintBitsToFloat(x: u32)->f32 {return bitcast<f32>(x);}
fn uint2float(i: u32)->f32 {return uintBitsToFloat(0x3F800000u | (i>>9u))-1.0;}
fn uv_to_normal(uv: vec2f)->vec3f {var N: vec3f;var uvRange: vec2f=uv;var theta: f32=uvRange.x*2.0*PI;var phi: f32=uvRange.y*PI;N.x=cos(theta)*sin(phi);N.z=sin(theta)*sin(phi);N.y=cos(phi);return N;}
fn plasticSequence(rstate: u32)->vec2f {return vec2f(uint2float(rstate*3242174889u),
uint2float(rstate*2447445414u));}
fn goldenSequence(rstate: u32)->f32 {return uint2float(rstate*2654435769u);}
fn distanceSquared(a: vec2f,b: vec2f)->f32 {var diff: vec2f=a-b;return dot(diff,diff);}
fn genTB(N: vec3f,T: ptr<function,vec3f>,B: ptr<function,vec3f>) {var s: f32=select(1.0,-1.0,N.z<0.0);var a: f32=-1.0/(s+N.z);var b: f32=N.x*N.y*a;*T= vec3f(1.0+s*N.x*N.x*a,s*b,-s*N.x);*B= vec3f(b,s+N.y*N.y*a,-N.y);}
fn lessThan(x: vec3f,y: vec3f)->vec3<bool> {return x<y;}
#ifdef VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
fn anyHitVoxels(ray_vs: Ray,
voxel_march_diagnostic_info: ptr<function,VoxelMarchDiagnosticInfo>)->bool {
#else
fn anyHitVoxels(ray_vs: Ray)->bool {
#endif
var stack=array<i32,24>(); 
var invD: vec3f=ray_vs.dir_rcp;var D: vec3f=ray_vs.dir;var O: vec3f=ray_vs.orig;var negD=vec3i(lessThan(D, vec3f(0,0,0)));var voxel0: i32=negD.x | (negD.y<<1) | (negD.z<<2);var t0: vec3f=-O*invD;var t1=(vec3f(1.0)-O)*invD;var maxLod: i32= i32(highestMipLevel);var stackLevel: i32=0;
#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
var steps: u32=0u;
#endif
stack[stackLevel]=maxLod<<24;stackLevel++;while (stackLevel>0) {stackLevel=stackLevel-1;var elem: i32=stack[stackLevel];var Coords: vec4i =
vec4i(elem & 0xFF,(elem>>8) & 0xFF,(elem>>16) & 0xFF,elem>>24);if (Coords.w==0) {
#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
*voxel_march_diagnostic_info.heat= f32(steps)/24.0;
#endif
return true;}
#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
++steps;
#endif
var invRes: f32=exp2(f32(Coords.w-maxLod));var bbmin: vec3f=invRes*vec3f(Coords.xyz+negD);var bbmax: vec3f=invRes*vec3f(Coords.xyz-negD+vec3i(1));var mint: vec3f=mix(t0,t1,bbmin);var maxt: vec3f=mix(t0,t1,bbmax);var midt: vec3f=0.5*(mint+maxt);mint.x=max(0.0,mint.x);midt.x=max(0.0,midt.x);var nodeMask: u32= u32(
round(textureLoad(voxelGridSampler,Coords.xyz,Coords.w).x*255.0));Coords.w--;var voxelBit: u32=u32(voxel0);Coords=vec4i((Coords.xyz<<vec3u(1))+negD,Coords.w);var packedCoords: i32 =
Coords.x | (Coords.y<<8) | (Coords.z<<16) | (Coords.w<<24);if (max(mint.x,max(mint.y,mint.z))<min(midt.x,min(midt.y,midt.z)) &&
((1u<<voxelBit) & nodeMask) != 0) {stack[stackLevel]=packedCoords;stackLevel++;}
voxelBit ^= 0x1;packedCoords ^= 0x00001;if (max(midt.x,max(mint.y,mint.z))<min(maxt.x,min(midt.y,midt.z)) &&
((1u<<voxelBit) & nodeMask) != 0) {stack[stackLevel]=packedCoords;stackLevel++;}
voxelBit ^= 0x2;packedCoords ^= 0x00100;if (max(midt.x,max(midt.y,mint.z))<min(maxt.x,min(maxt.y,midt.z)) &&
((1u<<voxelBit) & nodeMask) != 0) {stack[stackLevel]=packedCoords;stackLevel++;}
voxelBit ^= 0x1;packedCoords ^= 0x00001;if (max(mint.x,max(midt.y,mint.z))<min(midt.x,min(maxt.y,midt.z)) &&
((1u<<voxelBit) & nodeMask) != 0) {stack[stackLevel]=packedCoords;stackLevel++;}
voxelBit ^= 0x4;packedCoords ^= 0x10000;if (max(mint.x,max(midt.y,midt.z))<min(midt.x,min(maxt.y,maxt.z)) &&
((1u<<voxelBit) & nodeMask) != 0) {stack[stackLevel]=packedCoords;stackLevel++;}
voxelBit ^= 0x1;packedCoords ^= 0x00001;if (max(midt.x,max(midt.y,midt.z))<min(maxt.x,min(maxt.y,maxt.z)) &&
((1u<<voxelBit) & nodeMask) != 0) {stack[stackLevel]=packedCoords;stackLevel++;}
voxelBit ^= 0x2;packedCoords ^= 0x00100;if (max(midt.x,max(mint.y,midt.z))<min(maxt.x,min(midt.y,maxt.z)) &&
((1u<<voxelBit) & nodeMask) != 0) {stack[stackLevel]=packedCoords;stackLevel++;}
voxelBit ^= 0x1;packedCoords ^= 0x00001;if (max(mint.x,max(mint.y,midt.z))<min(midt.x,min(midt.y,maxt.z)) &&
((1u<<voxelBit) & nodeMask) != 0) {stack[stackLevel]=packedCoords;stackLevel++;}}
#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
*voxel_march_diagnostic_info.heat= f32(steps)/24.0;
#endif
return false;}
fn linearizeDepth(depth: f32,near: f32,far: f32)->f32 {return (near*far)/(far-depth*(far-near));}
fn screenSpaceShadow(csOrigin: vec3f,csDirection: vec3f,csZBufferSize: vec2f,
nearPlaneZ: f32,farPlaneZ: f32,noise: f32)->f32 {
#ifdef RIGHT_HANDED
var csZDir : f32=-1.0;
#else 
var csZDir : f32=1.0;
#endif
var ssSamples: f32=SSSsamples;var ssMaxDist: f32=SSSmaxDistance;var ssStride: f32=SSSstride;var ssThickness: f32=SSSthickness;var rayLength: f32 =
select(ssMaxDist,(nearPlaneZ-csOrigin.z)/csDirection.z,
csZDir*(csOrigin.z+ssMaxDist*csDirection.z)<csZDir*nearPlaneZ);var csEndPoint: vec3f=csOrigin+rayLength*csDirection;var H0: vec4f=uniforms.projMtx*vec4f(csOrigin,1.0);var H1: vec4f=uniforms.projMtx*vec4f(csEndPoint,1.0);var Z0=vec2f(csOrigin.z ,1.0)/H0.w;var Z1=vec2f(csEndPoint.z,1.0)/H1.w;var P0=csZBufferSize*(0.5*H0.xy*Z0.y+0.5);var P1=csZBufferSize*(0.5*H1.xy*Z1.y+0.5);P1+= vec2f(select(0.0,0.01,distanceSquared(P0,P1)<0.0001));var delta: vec2f=P1-P0;var permute: bool=false;if (abs(delta.x)<abs(delta.y)) {permute=true;P0=P0.yx;P1=P1.yx;delta=delta.yx;}
var stepDirection: f32=sign(delta.x);var invdx: f32=stepDirection/delta.x;var dP: vec2f=ssStride* vec2f(stepDirection,invdx*delta.y);var dZ: vec2f=ssStride*invdx*(Z1-Z0);var opacity: f32=0.0;var P: vec2f=P0+noise*dP;var Z: vec2f=Z0+noise*dZ;var end: f32=P1.x*stepDirection;var rayZMax=csZDir*Z.x/Z.y;var sceneDepth=rayZMax;Z+=dZ;for (var stepCount: f32=0.0; 
opacity<1.0 && P.x*stepDirection<end && sceneDepth>0.0 && stepCount<ssSamples;stepCount+=1) { 
var coords=vec2i(select(P,P.yx,permute));sceneDepth=textureLoad(depthSampler,coords,0).x;sceneDepth=linearizeDepth(sceneDepth,nearPlaneZ,farPlaneZ);sceneDepth=csZDir*sceneDepth;if (sceneDepth<=0.0) {break;}
var rayZMin: f32=rayZMax;rayZMax=csZDir*Z.x/Z.y;opacity+=max(opacity,step(rayZMax,sceneDepth+ssThickness)*step(sceneDepth,rayZMin));P+=dP;Z+=dZ;}
return opacity;}
#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
fn voxelShadow(wsOrigin: vec3f,wsDirection: vec3f,wsNormal: vec3f,
DitherNoise: vec2f,
voxel_march_diagnostic_info: ptr<function,VoxelMarchDiagnosticInfo>)->f32 {
#else
fn voxelShadow(wsOrigin: vec3f,wsDirection: vec3f,wsNormal: vec3f,
DitherNoise: vec2f)->f32 {
#endif
var vxResolution: f32=f32(textureDimensions(voxelGridSampler,0).x);var T: vec3f;var B: vec3f;genTB(wsDirection,&T,&B);var DitherXY: vec2f=sqrt(DitherNoise.x)* vec2f(cos(2.0*PI*DitherNoise.y),
sin(2.0*PI*DitherNoise.y));var Dithering : vec3f=(uniforms.voxelBiasParameters.x*wsNormal +
uniforms.voxelBiasParameters.y*wsDirection +
DitherXY.x*T+DitherXY.y*B) /
vxResolution;var O: vec3f=0.5*wsOrigin+0.5+Dithering;var ray_vs=make_ray(O,wsDirection,0.0,10.0);var voxel_aabb: AABB3f;voxel_aabb.m_min=vec3f(0);voxel_aabb.m_max=vec3f(1);var near: f32=0;var far: f32=0;if (!ray_box_intersection(voxel_aabb,ray_vs,&near,&far)) {return 0.0;}
ray_vs.t_min=max(ray_vs.t_min,near);ray_vs.t_max=min(ray_vs.t_max,far);
#if VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
return select(0.0f,1.0f,anyHitVoxels(ray_vs,voxel_march_diagnostic_info));
#else
return select(0.0f,1.0f,anyHitVoxels(ray_vs));
#endif
}
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var nbDirs=u32(SHADOWdirs);var frameId=u32(SHADOWframe);var envRot: f32=SHADOWenvRot;var Resolution: vec2f= vec2f(textureDimensions(depthSampler,0));var currentPixel=vec2i(fragmentInputs.vUV*Resolution);var GlobalIndex =
(frameId*u32(Resolution.y)+u32(currentPixel.y))*u32(Resolution.x) +
u32(currentPixel.x);var N : vec3f=textureLoad(worldNormalSampler,currentPixel,0).xyz;if (length(N)<0.01) {fragmentOutputs.color=vec4f(1.0,1.0,0.0,1.0);return fragmentOutputs;}
var normalizedRotation: f32=envRot/(2.0*PI);var depth : f32=textureLoad(depthSampler,currentPixel,0).x;
#ifndef IS_NDC_HALF_ZRANGE
depth=depth*2.0-1.0;
#endif
var temp : vec2f=(vec2f(currentPixel)+vec2f(0.5))*2.0/Resolution -
vec2f(1.0);var VP : vec4f=uniforms.invProjMtx*vec4f(temp.x,-temp.y,depth,1.0);VP/=VP.w;N=normalize(N);var noise : vec3f=textureLoad(blueNoiseSampler,currentPixel & vec2i(0xFF),0).xyz;noise.z=fract(noise.z+goldenSequence(frameId*nbDirs));
#ifdef VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
var heat: f32=0.0f;
#endif
var shadowAccum: f32=0.001;var specShadowAccum: f32=0.001;var sampleWeight : f32=0.001;
#ifdef COLOR_SHADOWS
var totalLight: vec3f=vec3f(0.001);var shadowedLight: vec3f=vec3f(0.0);
#endif
for (var i: u32=0; i<nbDirs; i++) {var dirId: u32=nbDirs*GlobalIndex+i;var L: vec4f;var T: vec2f;{var r: vec2f=plasticSequence(frameId*nbDirs+i);r=fract(r+ vec2f(2.0)*abs(noise.xy- vec2f(0.5)));T.x=textureSampleLevel(icdfSampler,icdfSamplerSampler,vec2f(r.x,0.0),0.0).x;T.y=textureSampleLevel(icdfSampler,icdfSamplerSampler,vec2f(T.x,r.y),0.0).y;L= vec4f(uv_to_normal(vec2f(T.x-normalizedRotation,T.y)),0);
#ifndef RIGHT_HANDED
L.z*=-1.0;
#endif
}
#ifdef COLOR_SHADOWS
var lightDir: vec3f=uv_to_normal(vec2f(1.0-fract(T.x+0.25),T.y));var ibl: vec3f=textureSampleLevel(iblSampler,iblSamplerSampler,lightDir,0.0).xyz;var pdf: f32=textureSampleLevel(icdfSampler,icdfSamplerSampler,T,0.0).z;
#endif
var cosNL: f32=dot(N,L.xyz);var opacity: f32=0.0;if (cosNL>0.0) {var VP2: vec4f=VP;VP2.y*=-1.0;var unormWP : vec4f=uniforms.invViewMtx*VP2;var WP: vec3f=(uniforms.wsNormalizationMtx*unormWP).xyz;var vxNoise: vec2f=vec2f(uint2float(hash(dirId*2)),uint2float(hash(dirId*2+1)));
#ifdef VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
VoxelMarchDiagnosticInfo voxel_march_diagnostic_info;opacity=max(opacity,
uniforms.shadowOpacity.x*voxelShadow(WP,L.xyz,N,vxNoise,
voxel_march_diagnostic_info));heat+=voxel_march_diagnostic_info.heat;
#else
opacity =
max(opacity,uniforms.shadowOpacity.x*voxelShadow(WP,L.xyz,N,vxNoise));
#endif
var VL : vec3f=(uniforms.viewMtx*L).xyz;
#ifdef RIGHT_HANDED
var nearPlaneZ: f32=-2.0*uniforms.projMtx[3][2]/(uniforms.projMtx[2][2]-1.0); 
var farPlaneZ: f32=-uniforms.projMtx[3][2]/(uniforms.projMtx[2][2]+1.0);
#else
var nearPlaneZ: f32=-2.0*uniforms.projMtx[3][2]/(uniforms.projMtx[2][2]+1.0); 
var farPlaneZ: f32=-uniforms.projMtx[3][2]/(uniforms.projMtx[2][2]-1.0);
#endif
var ssShadow: f32=uniforms.shadowOpacity.y *
screenSpaceShadow(VP2.xyz,VL,Resolution,nearPlaneZ,farPlaneZ,
abs(2.0*noise.z-1.0));opacity=max(opacity,ssShadow);
#ifdef COLOR_SHADOWS
var light: vec3f=select(vec3f(0.0),vec3f(cosNL)/vec3f(pdf)*ibl,pdf>1e-6);shadowedLight+=light*opacity;totalLight+=light;
#else
var rcos: f32=1.0-cosNL;shadowAccum+=(1.0-opacity*(1.0-pow(rcos,8.0)));sampleWeight+=1.0;var VR : vec3f=abs((uniforms.viewMtx*vec4f(reflect(-L.xyz,N),0.0)).xyz);specShadowAccum+=max(1.0-(opacity*pow(VR.z,8.0)),0.0);
#endif
}
noise.z=fract(noise.z+GOLD);}
#ifdef COLOR_SHADOWS
var shadow: vec3f=(totalLight-shadowedLight)/totalLight;var maxShadow: f32=max(max(shadow.x,max(shadow.y,shadow.z)),1.0);fragmentOutputs.color=vec4f(shadow/maxShadow,1.0);
#else
#ifdef VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION
fragmentOutputs.color =
vec4f(shadowAccum/sampleWeight,specShadowAccum/sampleWeight,heat/sampleWeight,1.0);
#else
fragmentOutputs.color=vec4f(shadowAccum/sampleWeight,specShadowAccum/sampleWeight,0.0,1.0);
#endif
#endif
}`;P.ShadersStoreWGSL[Np]||(P.ShadersStoreWGSL[Np]=wI);const QU={name:Np,shader:wI},S$=Object.freeze(Object.defineProperty({__proto__:null,iblShadowVoxelTracingPixelShaderWGSL:QU},Symbol.toStringTag,{value:"Module"})),Fp="iblShadowDebugPixelShader",NI=`#ifdef GL_ES
precision mediump float;
#endif
varying vec2 vUV;uniform sampler2D textureSampler;uniform sampler2D debugSampler;uniform vec4 sizeParams;
#define offsetX sizeParams.x
#define offsetY sizeParams.y
#define widthScale sizeParams.z
#define heightScale sizeParams.w
void main(void) {vec2 uv =
vec2((offsetX+vUV.x)*widthScale,(offsetY+vUV.y)*heightScale);vec4 background=texture2D(textureSampler,vUV);vec4 debugColour=texture2D(debugSampler,vUV);if (uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) {gl_FragColor.rgba=background;} else {gl_FragColor.rgb=mix(debugColour.rgb,background.rgb,0.0);gl_FragColor.a=1.0;}}`;P.ShadersStore[Fp]||(P.ShadersStore[Fp]=NI);const KU={name:Fp,shader:NI},v$=Object.freeze(Object.defineProperty({__proto__:null,iblShadowDebugPixelShader:KU},Symbol.toStringTag,{value:"Module"})),Lp="iblShadowDebugPixelShader",FI=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var debugSamplerSampler: sampler;var debugSampler: texture_2d<f32>;uniform sizeParams: vec4f;
#define offsetX uniforms.sizeParams.x
#define offsetY uniforms.sizeParams.y
#define widthScale uniforms.sizeParams.z
#define heightScale uniforms.sizeParams.w
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var uv: vec2f =
vec2f((offsetX+fragmentInputs.vUV.x)*widthScale,(offsetY+fragmentInputs.vUV.y)*heightScale);var background: vec4f=textureSample(textureSampler,textureSamplerSampler,fragmentInputs.vUV);var debugColour: vec4f=textureSample(debugSampler,debugSamplerSampler,fragmentInputs.vUV);if (uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) {fragmentOutputs.color=background;} else {fragmentOutputs.color=vec4f(mix(debugColour.rgb,background.rgb,0.0),1.0);}}`;P.ShadersStoreWGSL[Lp]||(P.ShadersStoreWGSL[Lp]=FI);const JU={name:Lp,shader:FI},b$=Object.freeze(Object.defineProperty({__proto__:null,iblShadowDebugPixelShaderWGSL:JU},Symbol.toStringTag,{value:"Module"})),Bp="iblShadowSpatialBlurPixelShader",LI=`#define PI 3.1415927
varying vUV: vec2f;var depthSampler: texture_2d<f32>;var worldNormalSampler: texture_2d<f32>;var voxelTracingSampler : texture_2d<f32>;uniform blurParameters: vec4f;
#define stridef uniforms.blurParameters.x
#define worldScale uniforms.blurParameters.y
const weights=array<f32,5>(0.0625,0.25,0.375,0.25,0.0625);const nbWeights: i32=5;fn max2(v: vec2f,w: vec2f)->vec2f {return vec2f(max(v.x,w.x),max(v.y,w.y));}
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var gbufferRes=vec2f(textureDimensions(depthSampler,0));var gbufferPixelCoord= vec2i(fragmentInputs.vUV*gbufferRes);var shadowRes=vec2f(textureDimensions(voxelTracingSampler,0));var shadowPixelCoord= vec2i(fragmentInputs.vUV*shadowRes);var N: vec3f=textureLoad(worldNormalSampler,gbufferPixelCoord,0).xyz;if (length(N)<0.01) {fragmentOutputs.color=vec4f(1.0,1.0,0.0,1.0);return fragmentOutputs;}
var depth: f32=-textureLoad(depthSampler,gbufferPixelCoord,0).x;var X: vec4f= vec4f(0.0);for(var y: i32=0; y<nbWeights; y++) {for(var x: i32=0; x<nbWeights; x++) {var gBufferCoords: vec2i=gbufferPixelCoord+i32(stridef)*vec2i(x-(nbWeights>>1),y-(nbWeights>>1));var shadowCoords: vec2i=shadowPixelCoord+i32(stridef)*vec2i(x-(nbWeights>>1),y-(nbWeights>>1));var T : vec3f=textureLoad(voxelTracingSampler,shadowCoords,0).xyz;var ddepth: f32=-textureLoad(depthSampler,gBufferCoords,0).x-depth;var dN: vec3f=textureLoad(worldNormalSampler,gBufferCoords,0).xyz-N;var w: f32=weights[x]*weights[y] *
exp2(max(-1000.0/(worldScale*worldScale),-0.5) *
(ddepth*ddepth) -
1e1*dot(dN,dN));X+= vec4f(w*T.x,w*T.y,w*T.z,w);}}
fragmentOutputs.color= vec4f(X.x/X.w,X.y/X.w,X.z/X.w,1.0);}`;P.ShadersStoreWGSL[Bp]||(P.ShadersStoreWGSL[Bp]=LI);const eG={name:Bp,shader:LI},y$=Object.freeze(Object.defineProperty({__proto__:null,iblShadowSpatialBlurPixelShaderWGSL:eG},Symbol.toStringTag,{value:"Module"})),Vp="iblShadowSpatialBlurPixelShader",BI=`precision highp sampler2D;
#define PI 3.1415927
varying vec2 vUV;uniform sampler2D depthSampler;uniform sampler2D worldNormalSampler;uniform sampler2D voxelTracingSampler;uniform vec4 blurParameters;
#define stridef blurParameters.x
#define worldScale blurParameters.y
const float weights[5]=float[5](0.0625,0.25,0.375,0.25,0.0625);const int nbWeights=5;vec2 max2(vec2 v,vec2 w) {return vec2(max(v.x,w.x),max(v.y,w.y));}
void main(void)
{vec2 gbufferRes=vec2(textureSize(depthSampler,0));ivec2 gbufferPixelCoord=ivec2(vUV*gbufferRes);vec2 shadowRes=vec2(textureSize(voxelTracingSampler,0));ivec2 shadowPixelCoord=ivec2(vUV*shadowRes);vec3 N=texelFetch(worldNormalSampler,gbufferPixelCoord,0).xyz;if (length(N)<0.01) {glFragColor=vec4(1.0,1.0,0.0,1.0);return;}
float depth=-texelFetch(depthSampler,gbufferPixelCoord,0).x;vec4 X=vec4(0.0);for(int y=0; y<nbWeights; ++y) {for(int x=0; x<nbWeights; ++x) {ivec2 gBufferCoords=gbufferPixelCoord+int(stridef)*ivec2(x-(nbWeights>>1),y-(nbWeights>>1));ivec2 shadowCoords=shadowPixelCoord+int(stridef)*ivec2(x-(nbWeights>>1),y-(nbWeights>>1));vec4 T=texelFetch(voxelTracingSampler,shadowCoords,0);float ddepth=-texelFetch(depthSampler,gBufferCoords,0).x-depth;vec3 dN=texelFetch(worldNormalSampler,gBufferCoords,0).xyz-N;float w=weights[x]*weights[y] *
exp2(max(-1000.0/(worldScale*worldScale),-0.5) *
(ddepth*ddepth) -
1e1*dot(dN,dN));X+=vec4(w*T.x,w*T.y,w*T.z,w);}}
gl_FragColor=vec4(X.x/X.w,X.y/X.w,X.z/X.w,1.0);}`;P.ShadersStore[Vp]||(P.ShadersStore[Vp]=BI);const tG={name:Vp,shader:BI},T$=Object.freeze(Object.defineProperty({__proto__:null,iblShadowSpatialBlurPixelShader:tG},Symbol.toStringTag,{value:"Module"})),kp="iblShadowAccumulationPixelShader",VI=`varying vUV: vec2f;uniform accumulationParameters: vec4f;
#define remanence uniforms.accumulationParameters.x
#define resetb uniforms.accumulationParameters.y
#define sceneSize uniforms.accumulationParameters.z
var motionSampler: texture_2d<f32>;var positionSampler: texture_2d<f32>;var spatialBlurSampler : texture_2d<f32>;var oldAccumulationSamplerSampler: sampler;var oldAccumulationSampler: texture_2d<f32>;var prevPositionSamplerSampler: sampler;var prevPositionSampler: texture_2d<f32>;fn max2(v: vec2f,w: vec2f)->vec2f { 
return vec2f(max(v.x,w.x),max(v.y,w.y)); }
fn lessThan(x: vec2f,y: vec2f)->vec2<bool> {return x<y;}
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var reset: bool= bool(resetb);var gbufferRes : vec2f=vec2f(textureDimensions(positionSampler,0));var gbufferPixelCoord: vec2i= vec2i(input.vUV*gbufferRes);var shadowRes : vec2f=vec2f(textureDimensions(spatialBlurSampler,0));var shadowPixelCoord: vec2i= vec2i(input.vUV*shadowRes);var LP: vec4f=textureLoad(positionSampler,gbufferPixelCoord,0);if (0.0==LP.w) {fragmentOutputs.color=vec4f(1.0,0.0,0.0,1.0);return fragmentOutputs;}
var velocityColor: vec2f=textureLoad(motionSampler,gbufferPixelCoord,0).xy;var prevCoord: vec2f=input.vUV+velocityColor;var PrevLP: vec3f=textureSampleLevel(prevPositionSampler,prevPositionSamplerSampler,prevCoord,0.0).xyz;var PrevShadows: vec4f=textureSampleLevel(oldAccumulationSampler,oldAccumulationSamplerSampler,prevCoord,0.0);var newShadows : vec3f=textureLoad(spatialBlurSampler,shadowPixelCoord,0).xyz;PrevShadows.a=select(1.0,max(PrevShadows.a/(1.0+PrevShadows.a),1.0-remanence),!reset && all(lessThan(abs(prevCoord- vec2f(0.5)), vec2f(0.5))) &&
distance(LP.xyz,PrevLP)<5e-2*sceneSize);PrevShadows=max( vec4f(0.0),PrevShadows);fragmentOutputs.color= vec4f(mix(PrevShadows.x,newShadows.x,PrevShadows.a),
mix(PrevShadows.y,newShadows.y,PrevShadows.a),
mix(PrevShadows.z,newShadows.z,PrevShadows.a),PrevShadows.a);}`;P.ShadersStoreWGSL[kp]||(P.ShadersStoreWGSL[kp]=VI);const iG={name:kp,shader:VI},C$=Object.freeze(Object.defineProperty({__proto__:null,iblShadowAccumulationPixelShaderWGSL:iG},Symbol.toStringTag,{value:"Module"})),zp="iblShadowAccumulationPixelShader",kI=`#ifdef GL_ES
precision mediump float;
#endif
varying vec2 vUV;uniform vec4 accumulationParameters;
#define remanence accumulationParameters.x
#define resetb accumulationParameters.y
#define sceneSize accumulationParameters.z
uniform sampler2D motionSampler;uniform sampler2D positionSampler;uniform sampler2D spatialBlurSampler;uniform sampler2D oldAccumulationSampler;uniform sampler2D prevPositionSampler;vec2 max2(vec2 v,vec2 w) { return vec2(max(v.x,w.x),max(v.y,w.y)); }
void main(void) {bool reset=bool(resetb);vec2 gbufferRes=vec2(textureSize(motionSampler,0));ivec2 gbufferPixelCoord=ivec2(vUV*gbufferRes);vec2 shadowRes=vec2(textureSize(spatialBlurSampler,0));ivec2 shadowPixelCoord=ivec2(vUV*shadowRes);vec4 LP=texelFetch(positionSampler,gbufferPixelCoord,0);if (0.0==LP.w) {gl_FragColor=vec4(1.0,0.0,0.0,1.0);return;}
vec2 velocityColor=texelFetch(motionSampler,gbufferPixelCoord,0).xy;vec2 prevCoord=vUV+velocityColor;vec3 PrevLP=texture(prevPositionSampler,prevCoord).xyz;vec4 PrevShadows=texture(oldAccumulationSampler,prevCoord);vec3 newShadows=texelFetch(spatialBlurSampler,shadowPixelCoord,0).xyz;PrevShadows.a =
!reset && all(lessThan(abs(prevCoord-vec2(0.5)),vec2(0.5))) &&
distance(LP.xyz,PrevLP)<5e-2*sceneSize
? max(PrevShadows.a/(1.0+PrevShadows.a),1.0-remanence)
: 1.0;PrevShadows=max(vec4(0.0),PrevShadows);gl_FragColor =
vec4(mix(PrevShadows.x,newShadows.x,PrevShadows.a),
mix(PrevShadows.y,newShadows.y,PrevShadows.a),
mix(PrevShadows.z,newShadows.z,PrevShadows.a),PrevShadows.a);}`;P.ShadersStore[zp]||(P.ShadersStore[zp]=kI);const rG={name:zp,shader:kI},P$=Object.freeze(Object.defineProperty({__proto__:null,iblShadowAccumulationPixelShader:rG},Symbol.toStringTag,{value:"Module"})),Up="iblShadowsCombinePixelShader",zI=`precision highp float;varying vec2 vUV;uniform sampler2D shadowSampler;uniform sampler2D textureSampler;uniform float shadowOpacity;void main(void)
{vec3 shadow=texture(shadowSampler,vUV).rgb;vec3 sceneColor=texture(textureSampler,vUV).rgb;float shadowValue=mix(1.0,shadow.x,shadowOpacity);gl_FragColor=vec4(sceneColor*shadowValue,1.0);}`;P.ShadersStore[Up]||(P.ShadersStore[Up]=zI);const E$={name:Up,shader:zI},Gp="iblShadowsCombinePixelShader",UI=`varying vUV: vec2f;var shadowSamplerSampler : sampler;var shadowSampler : texture_2d<f32>;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform shadowOpacity: f32;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var shadow
: vec3f =
textureSample(shadowSampler,shadowSamplerSampler,input.vUV).rgb;var color
: vec3f =
textureSample(textureSampler,textureSamplerSampler,input.vUV).rgb;var shadowValue: f32=mix(1.0,shadow.x,uniforms.shadowOpacity);fragmentOutputs.color=vec4f(color*shadowValue,1.0);}`;P.ShadersStoreWGSL[Gp]||(P.ShadersStoreWGSL[Gp]=UI);const I$={name:Gp,shader:UI},Wp="iblCombineVoxelGridsPixelShader",GI=`varying vUV: vec2f;var voxelXaxisSamplerSampler: sampler;var voxelXaxisSampler: texture_3d<f32>;var voxelYaxisSamplerSampler: sampler;var voxelYaxisSampler: texture_3d<f32>;var voxelZaxisSamplerSampler: sampler;var voxelZaxisSampler: texture_3d<f32>;uniform layer: f32;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var coordZ: vec3f= vec3f(fragmentInputs.vUV.x,fragmentInputs.vUV.y,uniforms.layer);var voxelZ: f32=textureSample(voxelZaxisSampler,voxelZaxisSamplerSampler,coordZ).r;var coordX: vec3f= vec3f(1.0-uniforms.layer,fragmentInputs.vUV.y,fragmentInputs.vUV.x);var voxelX: f32=textureSample(voxelXaxisSampler,voxelXaxisSamplerSampler,coordX).r;var coordY: vec3f= vec3f(uniforms.layer,fragmentInputs.vUV.x,fragmentInputs.vUV.y);var voxelY: f32=textureSample(voxelYaxisSampler,voxelYaxisSamplerSampler,coordY).r;var voxel=select(0.0,1.0,(voxelX>0.0 || voxelY>0.0 || voxelZ>0.0));fragmentOutputs.color= vec4f( vec3f(voxel),1.0);}`;P.ShadersStoreWGSL[Wp]||(P.ShadersStoreWGSL[Wp]=GI);const sG={name:Wp,shader:GI},R$=Object.freeze(Object.defineProperty({__proto__:null,iblCombineVoxelGridsPixelShaderWGSL:sG},Symbol.toStringTag,{value:"Module"})),$p="iblCombineVoxelGridsPixelShader",WI="precision highp float;precision highp sampler3D;varying vec2 vUV;uniform sampler3D voxelXaxisSampler;uniform sampler3D voxelYaxisSampler;uniform sampler3D voxelZaxisSampler;uniform float layer;void main(void) {vec3 coordZ=vec3(vUV.x,vUV.y,layer);float voxelZ=texture(voxelZaxisSampler,coordZ).r;vec3 coordX=vec3(1.0-layer,vUV.y,vUV.x);float voxelX=texture(voxelXaxisSampler,coordX).r;vec3 coordY=vec3(layer,vUV.x,vUV.y);float voxelY=texture(voxelYaxisSampler,coordY).r;float voxel=(voxelX>0.0 || voxelY>0.0 || voxelZ>0.0) ? 1.0 : 0.0;glFragColor=vec4(vec3(voxel),1.0);}";P.ShadersStore[$p]||(P.ShadersStore[$p]=WI);const nG={name:$p,shader:WI},M$=Object.freeze(Object.defineProperty({__proto__:null,iblCombineVoxelGridsPixelShader:nG},Symbol.toStringTag,{value:"Module"})),Hp="iblGenerateVoxelMipPixelShader",$I=`precision highp float;precision highp sampler3D;varying vec2 vUV;uniform sampler3D srcMip;uniform int layerNum;void main(void) {ivec3 Coords=ivec3(2)*ivec3(gl_FragCoord.x,gl_FragCoord.y,layerNum);uint tex =
uint(texelFetch(srcMip,Coords+ivec3(0,0,0),0).x>0.0f ? 1u : 0u)
<< 0u |
uint(texelFetch(srcMip,Coords+ivec3(1,0,0),0).x>0.0f ? 1u : 0u)
<< 1u |
uint(texelFetch(srcMip,Coords+ivec3(0,1,0),0).x>0.0f ? 1u : 0u)
<< 2u |
uint(texelFetch(srcMip,Coords+ivec3(1,1,0),0).x>0.0f ? 1u : 0u)
<< 3u |
uint(texelFetch(srcMip,Coords+ivec3(0,0,1),0).x>0.0f ? 1u : 0u)
<< 4u |
uint(texelFetch(srcMip,Coords+ivec3(1,0,1),0).x>0.0f ? 1u : 0u)
<< 5u |
uint(texelFetch(srcMip,Coords+ivec3(0,1,1),0).x>0.0f ? 1u : 0u)
<< 6u |
uint(texelFetch(srcMip,Coords+ivec3(1,1,1),0).x>0.0f ? 1u : 0u)
<< 7u;glFragColor.rgb=vec3(float(tex)/255.0f,0.0f,0.0f);glFragColor.a=1.0;}`;P.ShadersStore[Hp]||(P.ShadersStore[Hp]=$I);const aG={name:Hp,shader:$I},A$=Object.freeze(Object.defineProperty({__proto__:null,iblGenerateVoxelMipPixelShader:aG},Symbol.toStringTag,{value:"Module"})),jp="iblGenerateVoxelMipPixelShader",HI=`varying vUV: vec2f;var srcMip: texture_3d<f32>;uniform layerNum: i32;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var Coords=vec3i(2)*vec3i(vec2i(fragmentInputs.position.xy),uniforms.layerNum);var tex =
(u32(select(0u,1u,textureLoad(srcMip,Coords+vec3i(0,0,0),0).x>0.0f))
<< 0u) |
(u32(select(0u,1u,textureLoad(srcMip,Coords+vec3i(1,0,0),0).x>0.0f))
<< 1u) |
(u32(select(0u,1u,textureLoad(srcMip,Coords+vec3i(0,1,0),0).x>0.0f))
<< 2u) |
(u32(select(0u,1u,textureLoad(srcMip,Coords+vec3i(1,1,0),0).x>0.0f))
<< 3u) |
(u32(select(0u,1u,textureLoad(srcMip,Coords+vec3i(0,0,1),0).x>0.0f))
<< 4u) |
(u32(select(0u,1u,textureLoad(srcMip,Coords+vec3i(1,0,1),0).x>0.0f))
<< 5u) |
(u32(select(0u,1u,textureLoad(srcMip,Coords+vec3i(0,1,1),0).x>0.0f))
<< 6u) |
(u32(select(0u,1u,textureLoad(srcMip,Coords+vec3i(1,1,1),0).x>0.0f))
<< 7u);fragmentOutputs.color=vec4f( f32(tex)/255.0f,0.0f,0.0f,1.0);}`;P.ShadersStoreWGSL[jp]||(P.ShadersStoreWGSL[jp]=HI);const oG={name:jp,shader:HI},D$=Object.freeze(Object.defineProperty({__proto__:null,iblGenerateVoxelMipPixelShaderWGSL:oG},Symbol.toStringTag,{value:"Module"})),Yp="iblShadowGBufferDebugPixelShader",jI=`#ifdef GL_ES
precision mediump float;
#endif
varying vec2 vUV;uniform sampler2D textureSampler;uniform sampler2D depthSampler;uniform sampler2D normalSampler;uniform sampler2D positionSampler;uniform sampler2D velocitySampler;uniform vec4 sizeParams;uniform float maxDepth;
#define offsetX sizeParams.x
#define offsetY sizeParams.y
#define widthScale sizeParams.z
#define heightScale sizeParams.w
void main(void) {vec2 uv =
vec2((offsetX+vUV.x)*widthScale,(offsetY+vUV.y)*heightScale);vec4 backgroundColour=texture2D(textureSampler,vUV).rgba;vec4 depth=texture2D(depthSampler,vUV);vec4 worldNormal=texture2D(normalSampler,vUV);vec4 worldPosition=texture2D(positionSampler,vUV);vec4 velocityLinear=texture2D(velocitySampler,vUV);if (uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) {gl_FragColor.rgba=backgroundColour;} else {gl_FragColor.a=1.0;if (uv.x<=0.25) {gl_FragColor.rgb=depth.rgb;gl_FragColor.a=1.0;} else if (uv.x<=0.5) {velocityLinear.rg=velocityLinear.rg*0.5+0.5;gl_FragColor.rgb=velocityLinear.rgb;} else if (uv.x<=0.75) {gl_FragColor.rgb=worldPosition.rgb;} else {gl_FragColor.rgb=worldNormal.rgb;}}}`;P.ShadersStore[Yp]||(P.ShadersStore[Yp]=jI);const lG={name:Yp,shader:jI},O$=Object.freeze(Object.defineProperty({__proto__:null,iblShadowGBufferDebugPixelShader:lG},Symbol.toStringTag,{value:"Module"})),Xp="iblShadowGBufferDebugPixelShader",YI=`varying vUV: vec2f;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;var depthSampler: sampler;var depthTexture: texture_2d<f32>;var normalSampler: sampler;var normalTexture: texture_2d<f32>;var positionSampler: sampler;var positionTexture: texture_2d<f32>;var velocitySampler: sampler;var velocityTexture: texture_2d<f32>;uniform sizeParams: vec4f;uniform maxDepth: f32;
#define offsetX uniforms.sizeParams.x
#define offsetY uniforms.sizeParams.y
#define widthScale uniforms.sizeParams.z
#define heightScale uniforms.sizeParams.w
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var uv: vec2f =
vec2f((offsetX+input.vUV.x)*widthScale,(offsetY+input.vUV.y)*heightScale);var backgroundColour: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV).rgba;var depth: vec4f=textureSample(depthTexture,depthSampler,input.vUV);var worldNormal: vec4f=textureSample(normalTexture,normalSampler,input.vUV);var worldPosition: vec4f=textureSample(positionTexture,positionSampler,input.vUV);var velocityLinear: vec4f=textureSample(velocityTexture,velocitySampler,input.vUV);if (uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) {fragmentOutputs.color=backgroundColour;} else {if (uv.x<=0.25) {fragmentOutputs.color=vec4f(depth.rgb,1.0);} else if (uv.x<=0.5) {velocityLinear=vec4f(velocityLinear.r*0.5+0.5,velocityLinear.g*0.5+0.5,velocityLinear.b,velocityLinear.a);fragmentOutputs.color=vec4f(velocityLinear.rgb,1.0);} else if (uv.x<=0.75) {fragmentOutputs.color=vec4f(worldPosition.rgb,1.0);} else {fragmentOutputs.color=vec4f(worldNormal.rgb,1.0);}}}`;P.ShadersStoreWGSL[Xp]||(P.ShadersStoreWGSL[Xp]=YI);const uG={name:Xp,shader:YI},w$=Object.freeze(Object.defineProperty({__proto__:null,iblShadowGBufferDebugPixelShaderWGSL:uG},Symbol.toStringTag,{value:"Module"})),Zp="iblCdfxPixelShader",XI=`#define PI 3.1415927
varying vUV: vec2f;var cdfy: texture_2d<f32>;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var cdfyRes=textureDimensions(cdfy,0);var currentPixel=vec2u(fragmentInputs.position.xy);var cdfx: f32=0.0;for (var x: u32=1; x<=currentPixel.x; x++) {cdfx+=textureLoad(cdfy, vec2u(x-1,cdfyRes.y-1),0).x;}
fragmentOutputs.color= vec4f( vec3f(cdfx),1.0);}`;P.ShadersStoreWGSL[Zp]||(P.ShadersStoreWGSL[Zp]=XI);const cG={name:Zp,shader:XI},hG=Object.freeze(Object.defineProperty({__proto__:null,iblCdfxPixelShaderWGSL:cG},Symbol.toStringTag,{value:"Module"})),qp="iblCdfxPixelShader",ZI=`precision highp sampler2D;
#define PI 3.1415927
varying vec2 vUV;uniform sampler2D cdfy;void main(void) {ivec2 cdfyRes=textureSize(cdfy,0);ivec2 currentPixel=ivec2(gl_FragCoord.xy);float cdfx=0.0;for (int x=1; x<=currentPixel.x; x++) {cdfx+=texelFetch(cdfy,ivec2(x-1,cdfyRes.y-1),0).x;}
gl_FragColor=vec4(vec3(cdfx),1.0);}`;P.ShadersStore[qp]||(P.ShadersStore[qp]=ZI);const dG={name:qp,shader:ZI},fG=Object.freeze(Object.defineProperty({__proto__:null,iblCdfxPixelShader:dG},Symbol.toStringTag,{value:"Module"})),Qp="iblCdfyPixelShader",qI=`varying vUV : vec2f;
#include <helperFunctions>
#ifdef IBL_USE_CUBE_MAP
var iblSourceSampler: sampler;var iblSource: texture_cube<f32>;
#else
var iblSourceSampler: sampler;var iblSource: texture_2d<f32>;
#endif
uniform iblHeight: i32;
#ifdef IBL_USE_CUBE_MAP
fn fetchCube(uv: vec2f)->f32 {var direction: vec3f=equirectangularToCubemapDirection(uv);return sin(PI*uv.y) *
dot(textureSampleLevel(iblSource,iblSourceSampler,direction,0.0)
.rgb,
LuminanceEncodeApprox);}
#else
fn fetchPanoramic(Coords: vec2i,envmapHeight: f32)->f32 {return sin(PI*(f32(Coords.y)+0.5)/envmapHeight) *
dot(textureLoad(iblSource,Coords,0).rgb,LuminanceEncodeApprox);}
#endif
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var coords: vec2i= vec2i(fragmentInputs.position.xy);var cdfy: f32=0.0;for (var y: i32=1; y<=coords.y; y++) {
#ifdef IBL_USE_CUBE_MAP
var uv: vec2f= vec2f(input.vUV.x,( f32(y-1)+0.5)/ f32(uniforms.iblHeight));cdfy+=fetchCube(uv);
#else
cdfy+=fetchPanoramic( vec2i(coords.x,y-1), f32(uniforms.iblHeight));
#endif
}
fragmentOutputs.color= vec4f(cdfy,0.0,0.0,1.0);}`;P.ShadersStoreWGSL[Qp]||(P.ShadersStoreWGSL[Qp]=qI);const pG={name:Qp,shader:qI},mG=Object.freeze(Object.defineProperty({__proto__:null,iblCdfyPixelShaderWGSL:pG},Symbol.toStringTag,{value:"Module"})),Kp="iblCdfyPixelShader",QI=`precision highp sampler2D;precision highp samplerCube;
#include<helperFunctions>
#define PI 3.1415927
varying vec2 vUV;
#ifdef IBL_USE_CUBE_MAP
uniform samplerCube iblSource;
#else
uniform sampler2D iblSource;
#endif
uniform int iblHeight;
#ifdef IBL_USE_CUBE_MAP
float fetchCube(vec2 uv) {vec3 direction=equirectangularToCubemapDirection(uv);return sin(PI*uv.y)*dot(textureCubeLodEXT(iblSource,direction,0.0).rgb,LuminanceEncodeApprox);}
#else
float fetchPanoramic(ivec2 Coords,float envmapHeight) {return sin(PI*(float(Coords.y)+0.5)/envmapHeight) *
dot(texelFetch(iblSource,Coords,0).rgb,LuminanceEncodeApprox);}
#endif
void main(void) {ivec2 coords=ivec2(gl_FragCoord.x,gl_FragCoord.y);float cdfy=0.0;for (int y=1; y<=coords.y; y++) {
#ifdef IBL_USE_CUBE_MAP
vec2 uv=vec2(vUV.x,(float(y-1)+0.5)/float(iblHeight));cdfy+=fetchCube(uv);
#else
cdfy+=fetchPanoramic(ivec2(coords.x,y-1),float(iblHeight));
#endif
}
gl_FragColor=vec4(cdfy,0.0,0.0,1.0);}`;P.ShadersStore[Kp]||(P.ShadersStore[Kp]=QI);const _G={name:Kp,shader:QI},gG=Object.freeze(Object.defineProperty({__proto__:null,iblCdfyPixelShader:_G},Symbol.toStringTag,{value:"Module"})),Jp="iblIcdfPixelShader",KI=`#include<helperFunctions>
varying vUV: vec2f;
#ifdef IBL_USE_CUBE_MAP
var iblSourceSampler: sampler;var iblSource: texture_cube<f32>;
#else
var iblSourceSampler: sampler;var iblSource: texture_2d<f32>;
#endif
var scaledLuminanceSamplerSampler : sampler;var scaledLuminanceSampler : texture_2d<f32>;var cdfx: texture_2d<f32>;var cdfy: texture_2d<f32>;fn fetchLuminance(coords: vec2f)->f32 {
#ifdef IBL_USE_CUBE_MAP
var direction: vec3f=equirectangularToCubemapDirection(coords);var color: vec3f=textureSampleLevel(iblSource,iblSourceSampler,direction,0.0).rgb;
#else
var color: vec3f=textureSampleLevel(iblSource,iblSourceSampler,coords,0.0).rgb;
#endif
return dot(color,LuminanceEncodeApprox);}
fn fetchCDFx(x: u32)->f32 {return textureLoad(cdfx, vec2u(x,0),0).x;}
fn bisectx(size: u32,targetValue: f32)->f32
{var a: u32=0;var b=size-1;while (b-a>1) {var c: u32=(a+b)>>1;if (fetchCDFx(c)<targetValue) {a=c;}
else {b=c;}}
return mix( f32(a), f32(b),(targetValue-fetchCDFx(a))/(fetchCDFx(b)-fetchCDFx(a)))/ f32(size-1);}
fn fetchCDFy(y: u32,invocationId: u32)->f32 {return textureLoad(cdfy, vec2u(invocationId,y),0).x;}
fn bisecty(size: u32,targetValue: f32,invocationId: u32)->f32
{var a: u32=0;var b=size-1;while (b-a>1) {var c=(a+b)>>1;if (fetchCDFy(c,invocationId)<targetValue) {a=c;}
else {b=c;}}
return mix( f32(a), f32(b),(targetValue-fetchCDFy(a,invocationId))/(fetchCDFy(b,invocationId)-fetchCDFy(a,invocationId)))/ f32(size-1);}
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var cdfxSize: vec2u=textureDimensions(cdfx,0);var cdfWidth: u32=cdfxSize.x;var icdfWidth: u32=cdfWidth-1;var currentPixel: vec2u= vec2u(fragmentInputs.position.xy);var outputColor: vec3f=vec3f(1.0);if (currentPixel.x==0)
{outputColor.x= 0.0;}
else if (currentPixel.x==icdfWidth-1) {outputColor.x= 1.0;} else {var targetValue: f32=fetchCDFx(cdfWidth-1)*input.vUV.x;outputColor.x= bisectx(cdfWidth,targetValue);}
var cdfySize: vec2u=textureDimensions(cdfy,0);var cdfHeight: u32=cdfySize.y;if (currentPixel.y==0) {outputColor.y= 0.0;}
else if (currentPixel.y==cdfHeight-2) {outputColor.y= 1.0;} else {var targetValue: f32=fetchCDFy(cdfHeight-1,currentPixel.x)*input.vUV.y;outputColor.y= max(bisecty(cdfHeight,targetValue,currentPixel.x),0.0);}
var size : vec2f=vec2f(textureDimensions(scaledLuminanceSampler,0));var highestMip: f32=floor(log2(size.x));var normalization : f32=textureSampleLevel(scaledLuminanceSampler,
scaledLuminanceSamplerSampler,
input.vUV,highestMip)
.r;var pixelLuminance: f32=fetchLuminance(input.vUV);outputColor.z=pixelLuminance/(2.0*PI*normalization);fragmentOutputs.color=vec4( outputColor,1.0);}`;P.ShadersStoreWGSL[Jp]||(P.ShadersStoreWGSL[Jp]=KI);const xG={name:Jp,shader:KI},SG=Object.freeze(Object.defineProperty({__proto__:null,iblIcdfPixelShaderWGSL:xG},Symbol.toStringTag,{value:"Module"})),em="iblIcdfPixelShader",JI=`precision highp sampler2D;
#include<helperFunctions>
varying vec2 vUV;
#ifdef IBL_USE_CUBE_MAP
uniform samplerCube iblSource;
#else
uniform sampler2D iblSource;
#endif
uniform sampler2D scaledLuminanceSampler;uniform int iblWidth;uniform int iblHeight;uniform sampler2D cdfx;uniform sampler2D cdfy;float fetchLuminance(vec2 coords) {
#ifdef IBL_USE_CUBE_MAP
vec3 direction=equirectangularToCubemapDirection(coords);vec3 color=textureCubeLodEXT(iblSource,direction,0.0).rgb;
#else
vec3 color=textureLod(iblSource,coords,0.0).rgb;
#endif
return dot(color,LuminanceEncodeApprox);}
float fetchCDFx(int x) { return texelFetch(cdfx,ivec2(x,0),0).x; }
float bisectx(int size,float targetValue) {int a=0,b=size-1;while (b-a>1) {int c=a+b>>1;if (fetchCDFx(c)<targetValue)
a=c;else
b=c;}
return mix(float(a),float(b),
(targetValue-fetchCDFx(a))/(fetchCDFx(b)-fetchCDFx(a))) /
float(size-1);}
float fetchCDFy(int y,int invocationId) {return texelFetch(cdfy,ivec2(invocationId,y),0).x;}
float bisecty(int size,float targetValue,int invocationId) {int a=0,b=size-1;while (b-a>1) {int c=a+b>>1;if (fetchCDFy(c,invocationId)<targetValue)
a=c;else
b=c;}
return mix(float(a),float(b),
(targetValue-fetchCDFy(a,invocationId)) /
(fetchCDFy(b,invocationId)-fetchCDFy(a,invocationId))) /
float(size-1);}
void main(void) {ivec2 cdfxSize=textureSize(cdfx,0);int cdfWidth=cdfxSize.x;int icdfWidth=cdfWidth-1;ivec2 currentPixel=ivec2(gl_FragCoord.xy);vec3 outputColor=vec3(1.0);if (currentPixel.x==0) {outputColor.x=0.0;} else if (currentPixel.x==icdfWidth-1) {outputColor.x=1.0;} else {float targetValue=fetchCDFx(cdfWidth-1)*vUV.x;outputColor.x=bisectx(cdfWidth,targetValue);}
ivec2 cdfySize=textureSize(cdfy,0);int cdfHeight=cdfySize.y;if (currentPixel.y==0) {outputColor.y=0.0;} else if (currentPixel.y==cdfHeight-2) {outputColor.y=1.0;} else {float targetValue=fetchCDFy(cdfHeight-1,currentPixel.x)*vUV.y;outputColor.y=max(bisecty(cdfHeight,targetValue,currentPixel.x),0.0);}
vec2 size=vec2(textureSize(scaledLuminanceSampler,0));float highestMip=floor(log2(size.x));float normalization=texture(scaledLuminanceSampler,vUV,highestMip).r;float pixelLuminance=fetchLuminance(vUV);outputColor.z=pixelLuminance/(2.0*PI*normalization);gl_FragColor=vec4(outputColor,1.0);}
`;P.ShadersStore[em]||(P.ShadersStore[em]=JI);const vG={name:em,shader:JI},bG=Object.freeze(Object.defineProperty({__proto__:null,iblIcdfPixelShader:vG},Symbol.toStringTag,{value:"Module"})),tm="iblCdfDebugPixelShader",eR=`#define PI 3.1415927
varying vUV: vec2f;var cdfySampler: sampler;var cdfy: texture_2d<f32>;var cdfxSampler: sampler;var cdfx: texture_2d<f32>;var icdfSampler: sampler;var icdf: texture_2d<f32>;
#ifdef IBL_USE_CUBE_MAP
var iblSourceSampler: sampler;var iblSource: texture_cube<f32>;
#else
var iblSourceSampler: sampler;var iblSource: texture_2d<f32>;
#endif
var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;
#define cdfyVSize (0.8/3.0)
#define cdfxVSize 0.1
#define cdfyHSize 0.5
uniform sizeParams: vec4f;
#ifdef IBL_USE_CUBE_MAP
fn equirectangularToCubemapDirection(uv: vec2f)->vec3f {var longitude: f32=uv.x*2.0*PI-PI;var latitude: f32=PI*0.5-uv.y*PI;var direction: vec3f;direction.x=cos(latitude)*sin(longitude);direction.y=sin(latitude);direction.z=cos(latitude)*cos(longitude);return direction;}
#endif
@fragment
fn main(input: FragmentInputs)->FragmentOutputs { 
var colour: vec3f= vec3f(0.0);var uv: vec2f =
vec2f((uniforms.sizeParams.x+input.vUV.x)*uniforms.sizeParams.z,(uniforms.sizeParams.y+input.vUV.y)*uniforms.sizeParams.w);var backgroundColour: vec3f=textureSample(textureSampler,textureSamplerSampler,input.vUV).rgb;var cdfxWidth: u32=textureDimensions(cdfx,0).x;var cdfyHeight: u32=textureDimensions(cdfy,0).y;const iblStart: f32=1.0-cdfyVSize;const pdfStart: f32=1.0-2.0*cdfyVSize;const cdfyStart: f32=1.0-3.0*cdfyVSize;const cdfxStart: f32=1.0-3.0*cdfyVSize-cdfxVSize;const icdfxStart: f32=1.0-3.0*cdfyVSize-2.0*cdfxVSize;
#ifdef IBL_USE_CUBE_MAP
var direction: vec3f=equirectangularToCubemapDirection(
(uv- vec2f(0.0,iblStart))* vec2f(1.0,1.0/cdfyVSize));var iblColour: vec3f=textureSampleLevel(iblSource,iblSourceSampler,direction,0.0).rgb;
#else
var iblColour: vec3f=textureSample(iblSource,iblSourceSampler,(uv- vec2f(0.0,iblStart)) *
vec2f(1.0,1.0/cdfyVSize))
.rgb;
#endif
var pdfColour: vec3f =
textureSample(icdf,icdfSampler,(uv- vec2f(0.0,pdfStart))* vec2f(1.0,1.0/cdfyVSize)).zzz;var cdfyColour: f32 =
textureSample(cdfy,cdfySampler,(uv- vec2f(0.0,cdfyStart))* vec2f(2.0,1.0/cdfyVSize)).r;var icdfyColour: f32 =
textureSample(icdf,icdfSampler,(uv- vec2f(0.5,cdfyStart))* vec2f(2.0,1.0/cdfyVSize)).g;var cdfxColour: f32 =
textureSample(cdfx,cdfxSampler,(uv- vec2f(0.0,cdfxStart))* vec2f(1.0,1.0/cdfxVSize)).r;var icdfxColour: f32=textureSample(icdf,icdfSampler,(uv- vec2f(0.0,icdfxStart)) *
vec2f(1.0,1.0/cdfxVSize)).r;if (uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) {colour=backgroundColour;} else if (uv.y>iblStart) {colour+=iblColour;} else if (uv.y>pdfStart) {colour+=pdfColour;} else if (uv.y>cdfyStart && uv.x<0.5) {colour.r+=cdfyColour/f32(cdfyHeight);} else if (uv.y>cdfyStart && uv.x>0.5) {colour.r+=icdfyColour;} else if (uv.y>cdfxStart) {colour.r+=cdfxColour/f32(cdfxWidth);} else if (uv.y>icdfxStart) {colour.r+=icdfxColour;}
fragmentOutputs.color =vec4(mix(colour,backgroundColour,0.5),1.0);}`;P.ShadersStoreWGSL[tm]||(P.ShadersStoreWGSL[tm]=eR);const yG={name:tm,shader:eR},TG=Object.freeze(Object.defineProperty({__proto__:null,iblCdfDebugPixelShaderWGSL:yG},Symbol.toStringTag,{value:"Module"})),im="iblCdfDebugPixelShader",tR=`precision highp samplerCube;
#define PI 3.1415927
varying vec2 vUV;uniform sampler2D cdfy;uniform sampler2D cdfx;uniform sampler2D icdf;uniform sampler2D pdf;
#ifdef IBL_USE_CUBE_MAP
uniform samplerCube iblSource;
#else
uniform sampler2D iblSource;
#endif
uniform sampler2D textureSampler;
#define cdfyVSize (0.8/3.0)
#define cdfxVSize 0.1
#define cdfyHSize 0.5
uniform vec4 sizeParams;
#define offsetX sizeParams.x
#define offsetY sizeParams.y
#define widthScale sizeParams.z
#define heightScale sizeParams.w
#ifdef IBL_USE_CUBE_MAP
vec3 equirectangularToCubemapDirection(vec2 uv) {float longitude=uv.x*2.0*PI-PI;float latitude=PI*0.5-uv.y*PI;vec3 direction;direction.x=cos(latitude)*sin(longitude);direction.y=sin(latitude);direction.z=cos(latitude)*cos(longitude);return direction;}
#endif
void main(void) {vec3 colour=vec3(0.0);vec2 uv =
vec2((offsetX+vUV.x)*widthScale,(offsetY+vUV.y)*heightScale);vec3 backgroundColour=texture2D(textureSampler,vUV).rgb;int cdfxWidth=textureSize(cdfx,0).x;int cdfyHeight=textureSize(cdfy,0).y;const float iblStart=1.0-cdfyVSize;const float pdfStart=1.0-2.0*cdfyVSize;const float cdfyStart=1.0-3.0*cdfyVSize;const float cdfxStart=1.0-3.0*cdfyVSize-cdfxVSize;const float icdfxStart=1.0-3.0*cdfyVSize-2.0*cdfxVSize;
#ifdef IBL_USE_CUBE_MAP
vec3 direction=equirectangularToCubemapDirection(
(uv-vec2(0.0,iblStart))*vec2(1.0,1.0/cdfyVSize));vec3 iblColour=textureCubeLodEXT(iblSource,direction,0.0).rgb;
#else
vec3 iblColour=texture2D(iblSource,(uv-vec2(0.0,iblStart)) *
vec2(1.0,1.0/cdfyVSize))
.rgb;
#endif
vec3 pdfColour=texture(icdf,(uv-vec2(0.0,pdfStart)) *
vec2(1.0,1.0/cdfyVSize)).zzz;float cdfyColour =
texture2D(cdfy,(uv-vec2(0.0,cdfyStart))*vec2(2.0,1.0/cdfyVSize))
.r;float icdfyColour =
texture2D(icdf,(uv-vec2(0.5,cdfyStart))*vec2(2.0,1.0/cdfyVSize))
.g;float cdfxColour =
texture2D(cdfx,(uv-vec2(0.0,cdfxStart))*vec2(1.0,1.0/cdfxVSize))
.r;float icdfxColour=texture2D(icdf,(uv-vec2(0.0,icdfxStart)) *
vec2(1.0,1.0/cdfxVSize))
.r;if (uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) {colour=backgroundColour;} else if (uv.y>iblStart) {colour+=iblColour;} else if (uv.y>pdfStart) {colour+=pdfColour;} else if (uv.y>cdfyStart && uv.x<0.5) {colour.r+=cdfyColour/float(cdfyHeight);} else if (uv.y>cdfyStart && uv.x>0.5) {colour.r+=icdfyColour;} else if (uv.y>cdfxStart) {colour.r+=cdfxColour/float(cdfxWidth);} else if (uv.y>icdfxStart) {colour.r+=icdfxColour;}
gl_FragColor=vec4(colour,1.0);glFragColor.rgb=mix(gl_FragColor.rgb,backgroundColour,0.5);}
`;P.ShadersStore[im]||(P.ShadersStore[im]=tR);const CG={name:im,shader:tR},PG=Object.freeze(Object.defineProperty({__proto__:null,iblCdfDebugPixelShader:CG},Symbol.toStringTag,{value:"Module"})),rm="iblScaledLuminancePixelShader",iR=`#include<helperFunctions>
#ifdef IBL_USE_CUBE_MAP
var iblSourceSampler: sampler;var iblSource: texture_cube<f32>;
#else
var iblSourceSampler: sampler;var iblSource: texture_2d<f32>;
#endif
uniform iblHeight: i32;uniform iblWidth: i32;fn fetchLuminance(coords: vec2f)->f32 {
#ifdef IBL_USE_CUBE_MAP
var direction: vec3f=equirectangularToCubemapDirection(coords);var color: vec3f=textureSampleLevel(iblSource,iblSourceSampler,direction,0.0).rgb;
#else
var color: vec3f=textureSampleLevel(iblSource,iblSourceSampler,coords,0.0).rgb;
#endif
return dot(color,LuminanceEncodeApprox);}
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var deform: f32=sin(input.vUV.y*PI);var luminance: f32=fetchLuminance(input.vUV);fragmentOutputs.color=vec4f(vec3f(deform*luminance),1.0);}`;P.ShadersStoreWGSL[rm]||(P.ShadersStoreWGSL[rm]=iR);const EG={name:rm,shader:iR},IG=Object.freeze(Object.defineProperty({__proto__:null,iblScaledLuminancePixelShaderWGSL:EG},Symbol.toStringTag,{value:"Module"})),sm="iblScaledLuminancePixelShader",rR=`precision highp sampler2D;precision highp samplerCube;
#include<helperFunctions>
varying vec2 vUV;
#ifdef IBL_USE_CUBE_MAP
uniform samplerCube iblSource;
#else
uniform sampler2D iblSource;
#endif
uniform int iblWidth;uniform int iblHeight;float fetchLuminance(vec2 coords) {
#ifdef IBL_USE_CUBE_MAP
vec3 direction=equirectangularToCubemapDirection(coords);vec3 color=textureCubeLodEXT(iblSource,direction,0.0).rgb;
#else
vec3 color=textureLod(iblSource,coords,0.0).rgb;
#endif
return dot(color,LuminanceEncodeApprox);}
void main(void) {float deform=sin(vUV.y*PI);float luminance=fetchLuminance(vUV);gl_FragColor=vec4(vec3(deform*luminance),1.0);}`;P.ShadersStore[sm]||(P.ShadersStore[sm]=rR);const RG={name:sm,shader:rR},MG=Object.freeze(Object.defineProperty({__proto__:null,iblScaledLuminancePixelShader:RG},Symbol.toStringTag,{value:"Module"})),nm="iblVoxelGrid2dArrayDebugPixelShader",sR="precision highp sampler2DArray;varying vec2 vUV;uniform sampler2DArray voxelTexture;uniform sampler2D textureSampler;uniform int slice;void main(void) {ivec3 size=textureSize(voxelTexture,0);float dimension=sqrt(float(size.z));vec2 samplePos=fract(vUV.xy*vec2(dimension));int sampleIndex=int(floor(vUV.x*float(dimension))+floor(vUV.y*float(dimension))*dimension);glFragColor.rgb=texture(voxelTexture,vec3(samplePos.xy,sampleIndex)).rrr;glFragColor.a=1.0;glFragColor.rgb+=texture(textureSampler,vUV.xy).rgb;}";P.ShadersStore[nm]||(P.ShadersStore[nm]=sR);const AG={name:nm,shader:sR},N$=Object.freeze(Object.defineProperty({__proto__:null,iblVoxelGrid2dArrayDebugPixelShader:AG},Symbol.toStringTag,{value:"Module"})),am="iblVoxelGrid2dArrayDebugPixelShader",nR=`varying vUV: vec2f;var voxelTextureSampler: sampler;var voxelTexture: texture_3d<f32>;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform slice: i32;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var size: vec3u=textureDimensions(voxelTexture,0);var dimension: f32=sqrt( f32(size.z));var samplePos: vec2f=fract(input.vUV.xy* vec2f(dimension));var sampleIndex: u32= u32(floor(input.vUV.x* f32(dimension))+floor(input.vUV.y* f32(dimension))*dimension);var color=textureSample(voxelTexture,voxelTextureSampler, vec3f(samplePos.xy,sampleIndex)).rrr;color+=textureSample(textureSampler,textureSamplerSampler,input.vUV.xy).rgb;fragmentOutputs.color=vec4f(color,1.0);}`;P.ShadersStoreWGSL[am]||(P.ShadersStoreWGSL[am]=nR);const DG={name:am,shader:nR},F$=Object.freeze(Object.defineProperty({__proto__:null,iblVoxelGrid2dArrayDebugPixelShaderWGSL:DG},Symbol.toStringTag,{value:"Module"})),om="iblVoxelGridPixelShader",aR=`precision highp float;layout(location=0) out highp float glFragData[MAX_DRAW_BUFFERS];varying vec3 vNormalizedPosition;uniform float nearPlane;uniform float farPlane;uniform float stepSize;void main(void) {vec3 normPos=vNormalizedPosition.xyz;if (normPos.z<nearPlane || normPos.z>farPlane) {discard;}
glFragData[0]=normPos.z<nearPlane+stepSize ? 1.0 : 0.0;glFragData[1]=normPos.z>=nearPlane+stepSize && normPos.z<nearPlane+2.0*stepSize ? 1.0 : 0.0;glFragData[2]=normPos.z>=nearPlane+2.0*stepSize && normPos.z<nearPlane+3.0*stepSize ? 1.0 : 0.0;glFragData[3]=normPos.z>=nearPlane+3.0*stepSize && normPos.z<nearPlane+4.0*stepSize ? 1.0 : 0.0;
#if MAX_DRAW_BUFFERS>4
glFragData[4]=normPos.z>=nearPlane+4.0*stepSize && normPos.z<nearPlane+5.0*stepSize ? 1.0 : 0.0;glFragData[5]=normPos.z>=nearPlane+5.0*stepSize && normPos.z<nearPlane+6.0*stepSize ? 1.0 : 0.0;glFragData[6]=normPos.z>=nearPlane+6.0*stepSize && normPos.z<nearPlane+7.0*stepSize ? 1.0 : 0.0;glFragData[7]=normPos.z>=nearPlane+7.0*stepSize && normPos.z<nearPlane+8.0*stepSize ? 1.0 : 0.0;
#endif
}`;P.ShadersStore[om]||(P.ShadersStore[om]=aR);const OG={name:om,shader:aR},L$=Object.freeze(Object.defineProperty({__proto__:null,iblVoxelGridPixelShader:OG},Symbol.toStringTag,{value:"Module"})),lm="iblVoxelGridVertexShader",oR=`attribute vec3 position;attribute vec3 normal;varying vec3 vNormalizedPosition;uniform mat4 world;uniform mat4 invWorldScale;uniform mat4 viewMatrix;void main(void) {gl_Position=viewMatrix*invWorldScale*world*vec4(position,1.);vNormalizedPosition.xyz=gl_Position.xyz*0.5+0.5;
#ifdef IS_NDC_HALF_ZRANGE
gl_Position.z=gl_Position.z*0.5+0.5;
#endif
}`;P.ShadersStore[lm]||(P.ShadersStore[lm]=oR);const wG={name:lm,shader:oR},B$=Object.freeze(Object.defineProperty({__proto__:null,iblVoxelGridVertexShader:wG},Symbol.toStringTag,{value:"Module"})),um="iblVoxelGridPixelShader",lR=`varying vNormalizedPosition: vec3f;uniform nearPlane: f32;uniform farPlane: f32;uniform stepSize: f32;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var normPos: vec3f=input.vNormalizedPosition.xyz;if (normPos.z<uniforms.nearPlane || normPos.z>uniforms.farPlane) {discard;}
fragmentOutputs.fragData0=select(vec4f(0.0),vec4f(1.0),normPos.z<uniforms.nearPlane+uniforms.stepSize);fragmentOutputs.fragData1=select(vec4f(0.0),vec4f(1.0),normPos.z>=uniforms.nearPlane+uniforms.stepSize && normPos.z<uniforms.nearPlane+2.0*uniforms.stepSize);fragmentOutputs.fragData2=select(vec4f(0.0),vec4f(1.0),normPos.z>=uniforms.nearPlane+2.0*uniforms.stepSize && normPos.z<uniforms.nearPlane+3.0*uniforms.stepSize);fragmentOutputs.fragData3=select(vec4f(0.0),vec4f(1.0),normPos.z>=uniforms.nearPlane+3.0*uniforms.stepSize && normPos.z<uniforms.nearPlane+4.0*uniforms.stepSize);
#if MAX_DRAW_BUFFERS>4
fragmentOutputs.fragData4=select(vec4f(0.0),vec4f(1.0),normPos.z>=uniforms.nearPlane+4.0*uniforms.stepSize && normPos.z<uniforms.nearPlane+5.0*uniforms.stepSize);fragmentOutputs.fragData5=select(vec4f(0.0),vec4f(1.0),normPos.z>=uniforms.nearPlane+5.0*uniforms.stepSize && normPos.z<uniforms.nearPlane+6.0*uniforms.stepSize);fragmentOutputs.fragData6=select(vec4f(0.0),vec4f(1.0),normPos.z>=uniforms.nearPlane+6.0*uniforms.stepSize && normPos.z<uniforms.nearPlane+7.0*uniforms.stepSize);fragmentOutputs.fragData7=select(vec4f(0.0),vec4f(1.0),normPos.z>=uniforms.nearPlane+7.0*uniforms.stepSize && normPos.z<uniforms.nearPlane+8.0*uniforms.stepSize);
#endif
}`;P.ShadersStoreWGSL[um]||(P.ShadersStoreWGSL[um]=lR);const NG={name:um,shader:lR},V$=Object.freeze(Object.defineProperty({__proto__:null,iblVoxelGridPixelShaderWGSL:NG},Symbol.toStringTag,{value:"Module"})),cm="iblVoxelGridVertexShader",uR=`attribute position: vec3f;attribute normal: vec3f;varying vNormalizedPosition: vec3f;uniform world: mat4x4f;uniform invWorldScale: mat4x4f;uniform viewMatrix: mat4x4f;@vertex
fn main(input : VertexInputs)->FragmentInputs {vertexOutputs.position=uniforms.viewMatrix*uniforms.invWorldScale*uniforms.world* vec4f(input.position,1.);vertexOutputs.vNormalizedPosition=vertexOutputs.position.xyz*0.5+0.5;
#ifdef IS_NDC_HALF_ZRANGE
vertexOutputs.position=vec4f(vertexOutputs.position.x,vertexOutputs.position.y,vertexOutputs.position.z*0.5+0.5,vertexOutputs.position.w);
#endif
}`;P.ShadersStoreWGSL[cm]||(P.ShadersStoreWGSL[cm]=uR);const FG={name:cm,shader:uR},k$=Object.freeze(Object.defineProperty({__proto__:null,iblVoxelGridVertexShaderWGSL:FG},Symbol.toStringTag,{value:"Module"})),hm="iblVoxelGrid3dDebugPixelShader",cR=`precision highp sampler3D;varying vec2 vUV;uniform sampler3D voxelTexture;uniform sampler2D voxelSlabTexture;uniform sampler2D textureSampler;uniform vec4 sizeParams;
#define offsetX sizeParams.x
#define offsetY sizeParams.y
#define widthScale sizeParams.z
#define heightScale sizeParams.w
uniform float mipNumber;void main(void) {vec2 uv =
vec2((offsetX+vUV.x)*widthScale,(offsetY+vUV.y)*heightScale);vec4 background=texture2D(textureSampler,vUV);vec4 voxelSlab=texture2D(voxelSlabTexture,vUV);ivec3 size=textureSize(voxelTexture,int(mipNumber));float dimension=ceil(sqrt(float(size.z)));vec2 samplePos=fract(uv.xy*vec2(dimension));int sampleIndex=int(floor(uv.x*float(dimension)) +
floor(uv.y*float(dimension))*dimension);float mip_separator=0.0;if (samplePos.x<0.01 || samplePos.y<0.01) {mip_separator=1.0;}
bool outBounds=sampleIndex>size.z-1 ? true : false;sampleIndex=clamp(sampleIndex,0,size.z-1);ivec2 samplePosInt=ivec2(samplePos.xy*vec2(size.xy));vec3 voxel=texelFetch(voxelTexture,
ivec3(samplePosInt.x,samplePosInt.y,sampleIndex),
int(mipNumber))
.rgb;if (uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) {gl_FragColor.rgba=background;} else {if (outBounds) {voxel=vec3(0.15,0.0,0.0);} else {if (voxel.r>0.001) {voxel.g=1.0;}
voxel.r+=mip_separator;}
glFragColor.rgb=mix(background.rgb,voxelSlab.rgb,voxelSlab.a)+voxel;glFragColor.a=1.0;}}`;P.ShadersStore[hm]||(P.ShadersStore[hm]=cR);const LG={name:hm,shader:cR},z$=Object.freeze(Object.defineProperty({__proto__:null,iblVoxelGrid3dDebugPixelShader:LG},Symbol.toStringTag,{value:"Module"})),dm="iblVoxelGrid3dDebugPixelShader",hR=`varying vUV: vec2f;var voxelTextureSampler: sampler;var voxelTexture: texture_3d<f32>;var voxelSlabTextureSampler: sampler;var voxelSlabTexture: texture_2d<f32>;var textureSamplerSampler: sampler;var textureSampler: texture_2d<f32>;uniform sizeParams: vec4f;
#define offsetX uniforms.sizeParams.x
#define offsetY uniforms.sizeParams.y
#define widthScale uniforms.sizeParams.z
#define heightScale uniforms.sizeParams.w
uniform mipNumber: f32;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var uv: vec2f =
vec2f((offsetX+input.vUV.x)*widthScale,(offsetY+input.vUV.y)*heightScale);var background: vec4f=textureSample(textureSampler,textureSamplerSampler,input.vUV);var voxelSlab: vec4f=textureSample(voxelSlabTexture,voxelSlabTextureSampler,input.vUV);var size: vec3u=textureDimensions(voxelTexture, i32(uniforms.mipNumber));var dimension: f32=ceil(sqrt( f32(size.z)));var samplePos: vec2f=fract(uv.xy* vec2f(dimension));var sampleIndex: u32= u32(floor(uv.x* f32(dimension)) +
floor(uv.y* f32(dimension))*dimension);var mip_separator: f32=0.0;if (samplePos.x<0.01 || samplePos.y<0.01) {mip_separator=1.0;}
var outBounds: bool=select(false,true,sampleIndex>size.z-1);sampleIndex=clamp(sampleIndex,0,size.z-1);var samplePosInt: vec2i= vec2i(samplePos.xy* vec2f(size.xy));var voxel: vec3f=textureLoad(voxelTexture,
vec3i(i32(samplePosInt.x),i32(samplePosInt.y),i32(sampleIndex)),
i32(uniforms.mipNumber)).rgb;if (uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) {fragmentOutputs.color=background;} else {if (outBounds) {voxel= vec3f(0.15,0.0,0.0);} else {if (voxel.r>0.001) {voxel.g=1.0;}
voxel.r+=mip_separator;}
fragmentOutputs.color=vec4f(mix(background.rgb,voxelSlab.rgb,voxelSlab.a)+voxel,1.0);}}`;P.ShadersStoreWGSL[dm]||(P.ShadersStoreWGSL[dm]=hR);const BG={name:dm,shader:hR},U$=Object.freeze(Object.defineProperty({__proto__:null,iblVoxelGrid3dDebugPixelShaderWGSL:BG},Symbol.toStringTag,{value:"Module"})),fm="iblVoxelSlabDebugVertexShader",dR="attribute vec3 position;varying vec3 vNormalizedPosition;uniform mat4 world;uniform mat4 invWorldScale;uniform mat4 cameraViewMatrix;uniform mat4 projection;uniform mat4 viewMatrix;void main(void) {vec4 worldPosition=(world*vec4(position,1.));gl_Position=projection*cameraViewMatrix*worldPosition;vNormalizedPosition=(viewMatrix*invWorldScale*worldPosition).rgb;vNormalizedPosition.xyz=vNormalizedPosition.xyz*vec3(0.5)+vec3(0.5);}";P.ShadersStore[fm]||(P.ShadersStore[fm]=dR);const VG={name:fm,shader:dR},G$=Object.freeze(Object.defineProperty({__proto__:null,iblVoxelSlabDebugVertexShader:VG},Symbol.toStringTag,{value:"Module"})),pm="iblVoxelSlabDebugPixelShader",fR=`precision highp float;varying vec3 vNormalizedPosition;uniform float nearPlane;uniform float farPlane;uniform float stepSize;void main(void) {vec3 normPos=vNormalizedPosition.xyz;float chunkSize=stepSize*float(MAX_DRAW_BUFFERS);float numChunks=1.0/chunkSize;float positionInChunk=fract(normPos.z/chunkSize);float slab=floor(positionInChunk*float(MAX_DRAW_BUFFERS)) /
float(MAX_DRAW_BUFFERS);if (normPos.x<0.0 || normPos.y<0.0 || normPos.z<0.0 ||
normPos.x>1.0 || normPos.y>1.0 || normPos.z>1.0) {gl_FragColor=vec4(0.0,0.0,0.0,0.0);} else {gl_FragColor=vec4(slab,0.0,0.0,0.75);}}`;P.ShadersStore[pm]||(P.ShadersStore[pm]=fR);const kG={name:pm,shader:fR},W$=Object.freeze(Object.defineProperty({__proto__:null,iblVoxelSlabDebugPixelShader:kG},Symbol.toStringTag,{value:"Module"})),mm="iblVoxelSlabDebugVertexShader",pR=`attribute position: vec3f;varying vNormalizedPosition: vec3f;uniform world: mat4x4f;uniform invWorldScale: mat4x4f;uniform cameraViewMatrix: mat4x4f;uniform projection: mat4x4f;uniform viewMatrix: mat4x4f;@vertex
fn main(input : VertexInputs)->FragmentInputs {var worldPosition: vec4f=(uniforms.world* vec4f(input.position,1.));vertexOutputs.position=uniforms.projection*uniforms.cameraViewMatrix*worldPosition;vertexOutputs.vNormalizedPosition=(uniforms.viewMatrix*uniforms.invWorldScale*worldPosition).rgb;vertexOutputs.vNormalizedPosition=vertexOutputs.vNormalizedPosition* vec3f(0.5)+ vec3f(0.5);}`;P.ShadersStoreWGSL[mm]||(P.ShadersStoreWGSL[mm]=pR);const zG={name:mm,shader:pR},$$=Object.freeze(Object.defineProperty({__proto__:null,iblVoxelSlabDebugVertexShaderWGSL:zG},Symbol.toStringTag,{value:"Module"})),_m="iblVoxelSlabDebugPixelShader",mR=`varying vNormalizedPosition: vec3f;uniform nearPlane: f32;uniform farPlane: f32;uniform stepSize: f32;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var normPos: vec3f=input.vNormalizedPosition.xyz;var chunkSize: f32=uniforms.stepSize* f32(MAX_DRAW_BUFFERS);var numChunks: f32=1.0/chunkSize;var positionInChunk: f32=fract(normPos.z/chunkSize);var slab: f32=floor(positionInChunk* f32(MAX_DRAW_BUFFERS)) /
f32(MAX_DRAW_BUFFERS);if (normPos.x<0.0 || normPos.y<0.0 || normPos.z<0.0 ||
normPos.x>1.0 || normPos.y>1.0 || normPos.z>1.0) {fragmentOutputs.color= vec4f(0.0,0.0,0.0,0.0);} else {fragmentOutputs.color= vec4f(slab,0.0,0.0,0.75);}}`;P.ShadersStoreWGSL[_m]||(P.ShadersStoreWGSL[_m]=mR);const UG={name:_m,shader:mR},H$=Object.freeze(Object.defineProperty({__proto__:null,iblVoxelSlabDebugPixelShaderWGSL:UG},Symbol.toStringTag,{value:"Module"})),gm="oitBackBlendPixelShader",_R=`precision highp float;uniform sampler2D uBackColor;void main() {glFragColor=texelFetch(uBackColor,ivec2(gl_FragCoord.xy),0);if (glFragColor.a==0.0) { 
discard;}}`;P.ShadersStore[gm]||(P.ShadersStore[gm]=_R);const GG={name:gm,shader:_R},kb=Object.freeze(Object.defineProperty({__proto__:null,oitBackBlendPixelShader:GG},Symbol.toStringTag,{value:"Module"})),xm="oitFinalPixelShader",gR=`precision highp float;uniform sampler2D uFrontColor;uniform sampler2D uBackColor;void main() {ivec2 fragCoord=ivec2(gl_FragCoord.xy);vec4 frontColor=texelFetch(uFrontColor,fragCoord,0);vec4 backColor=texelFetch(uBackColor,fragCoord,0);float alphaMultiplier=1.0-frontColor.a;glFragColor=vec4(
frontColor.rgb+alphaMultiplier*backColor.rgb,
frontColor.a+backColor.a
);}`;P.ShadersStore[xm]||(P.ShadersStore[xm]=gR);const WG={name:xm,shader:gR},$G=Object.freeze(Object.defineProperty({__proto__:null,oitFinalPixelShader:WG},Symbol.toStringTag,{value:"Module"})),Sm="oitBackBlendPixelShader",xR=`var uBackColor: texture_2d<f32>;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=textureLoad(uBackColor,vec2i(fragmentInputs.position.xy),0);if (fragmentOutputs.color.a==0.0) {discard;}}
`;P.ShadersStoreWGSL[Sm]||(P.ShadersStoreWGSL[Sm]=xR);const HG={name:Sm,shader:xR},zb=Object.freeze(Object.defineProperty({__proto__:null,oitBackBlendPixelShaderWGSL:HG},Symbol.toStringTag,{value:"Module"})),vm="oitFinalPixelShader",SR=`var uFrontColor: texture_2d<f32>;var uBackColor: texture_2d<f32>;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {var fragCoord: vec2i=vec2i(fragmentInputs.position.xy);var frontColor: vec4f=textureLoad(uFrontColor,fragCoord,0);var backColor: vec4f=textureLoad(uBackColor,fragCoord,0);var alphaMultiplier: f32=1.0-frontColor.a;fragmentOutputs.color=vec4f(
frontColor.rgb+alphaMultiplier*backColor.rgb,
frontColor.a+backColor.a
);}
`;P.ShadersStoreWGSL[vm]||(P.ShadersStoreWGSL[vm]=SR);const jG={name:vm,shader:SR},YG=Object.freeze(Object.defineProperty({__proto__:null,oitFinalPixelShaderWGSL:jG},Symbol.toStringTag,{value:"Module"})),Ub="spriteMapPixelShader",XG=`#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)
#else
#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)
#endif
precision highp float;varying vec3 vPosition;varying vec2 vUV;varying vec2 tUV;uniform float time;uniform float spriteCount;uniform sampler2D spriteSheet;uniform vec2 spriteMapSize;uniform vec2 outputSize;uniform vec2 stageSize;uniform sampler2D frameMap;uniform sampler2D tileMaps[LAYERS];uniform sampler2D animationMap;uniform vec3 colorMul;
#include<fogFragmentDeclaration>
#include<logDepthDeclaration>
float mt;const float fdStep=1.0*0.25;const float aFrameSteps=MAX_ANIMATION_FRAMES==0.0 ? 0.0 : 1.0/MAX_ANIMATION_FRAMES;mat4 getFrameData(float frameID) {float fX=frameID/spriteCount;return mat4(
TEXTUREFUNC(frameMap,vec2(fX,0.0),0.0),
TEXTUREFUNC(frameMap,vec2(fX,fdStep*1.0),0.0),
TEXTUREFUNC(frameMap,vec2(fX,fdStep*2.0),0.0),
vec4(0.0)
);}
void main() {vec4 color=vec4(0.0);vec2 tileUV=fract(tUV);vec2 tileID=floor(tUV);vec2 sheetUnits=1.0/spriteMapSize;float spriteUnits=1.0/spriteCount;vec2 stageUnits=1.0/stageSize;for(int i=0; i<LAYERS; i++) {float frameID;
#define LAYER_ID_SWITCH
vec4 animationData=TEXTUREFUNC(animationMap,vec2((frameID+0.5)/spriteCount,0.0),0.0);if(animationData.y>0.0) {mt=mod(time*animationData.z,1.0);for(float f=0.0; f<MAX_ANIMATION_FRAMES; f++) {if(animationData.y>mt) {frameID=animationData.x;break;}
animationData=TEXTUREFUNC(animationMap,vec2((frameID+0.5)/spriteCount,aFrameSteps*f),0.0);}}
mat4 frameData=getFrameData(frameID+0.5);vec2 frameSize=(frameData[0].zw)/spriteMapSize;vec2 offset=frameData[0].xy*sheetUnits;vec2 ratio=frameData[2].xy/frameData[0].zw;
#ifdef FR_CW
if (frameData[2].z==1.0) {tileUV.xy=tileUV.yx;} else {tileUV.xy=fract(tUV).xy;}
#ifdef FLIPU
tileUV.y=1.0-tileUV.y;
#endif
#else
if (frameData[2].z==1.0) {
#ifdef FLIPU
tileUV.y=1.0-tileUV.y;
#endif
tileUV.xy=tileUV.yx;} else {tileUV.xy=fract(tUV).xy;
#ifdef FLIPU
tileUV.y=1.0-tileUV.y;
#endif
}
#endif
vec4 nc=TEXTUREFUNC(spriteSheet,tileUV*frameSize+offset,0.0);if (i==0) {color=nc;} else {float alpha=min(color.a+nc.a,1.0);vec3 mixed=mix(color.xyz,nc.xyz,nc.a);color=vec4(mixed,alpha);}}
color.xyz*=colorMul;
#include<logDepthFragment>
#include<fogFragment>
gl_FragColor=color;}`;P.ShadersStore[Ub]||(P.ShadersStore[Ub]=XG);const Gb="spriteMapVertexShader",ZG=`precision highp float;attribute vec3 position;attribute vec3 normal;attribute vec2 uv;varying vec3 vPosition;varying vec2 vUV;varying vec2 tUV;uniform float time;uniform mat4 world;uniform mat4 view;uniform mat4 projection;uniform vec2 stageSize;uniform float stageScale;
#include<fogVertexDeclaration>
#include<logDepthDeclaration>
void main() {vec4 p=vec4( position,1. );vPosition=p.xyz;vUV=uv;tUV=uv*stageSize; 
vec3 viewPos=(view*world*p).xyz; 
gl_Position=projection*vec4(viewPos,1.0); 
#ifdef FOG
vFogDistance=viewPos;
#endif
#include<logDepthVertex>
}`;P.ShadersStore[Gb]||(P.ShadersStore[Gb]=ZG);var bm;(function(a){a[a.CCW=0]="CCW",a[a.CW=1]="CW"})(bm||(bm={}));class j${get spriteCount(){return this.sprites.length}get position(){return this._output.position}set position(e){this._output.position=e}get rotation(){return this._output.rotation}set rotation(e){this._output.rotation=e}get animationMap(){return this._animationMap}set animationMap(e){const t=e._texture._bufferView,i=this._createTileAnimationBuffer(t);this._animationMap.dispose(),this._animationMap=i,this._material.setTexture("animationMap",this._animationMap)}get fogEnabled(){return this._material.fogEnabled}set fogEnabled(e){this._material.fogEnabled=e}get useLogarithmicDepth(){return this._material.useLogarithmicDepth}set useLogarithmicDepth(e){this._material.useLogarithmicDepth=e}constructor(e,t,i,r,s){this.name=e,this.sprites=[],this.atlasJSON=t,this.sprites=this.atlasJSON.frames,this.spriteSheet=i,this.options=r,r.stageSize=r.stageSize||new Q(1,1),r.outputSize=r.outputSize||r.stageSize,r.outputPosition=r.outputPosition||m.Zero(),r.outputRotation=r.outputRotation||m.Zero(),r.layerCount=r.layerCount||1,r.maxAnimationFrames=r.maxAnimationFrames||0,r.baseTile=r.baseTile||0,r.flipU=r.flipU||!1,r.colorMultiply=r.colorMultiply||new m(1,1,1),this._scene=s,this._frameMap=this._createFrameBuffer(),this._tileMaps=new Array;for(let d=0;d<r.layerCount;d++)this._tileMaps.push(this._createTileBuffer(null,d));this._animationMap=this._createTileAnimationBuffer(null);const n=[];n.push("#define LAYERS "+r.layerCount),(r==null?void 0:r.frameRotationDirection)===bm.CW&&n.push("#define FR_CW"),r.flipU&&n.push("#define FLIPU"),n.push(`#define MAX_ANIMATION_FRAMES ${r.maxAnimationFrames}.0`);const o=_i.ShadersStore.spriteMapPixelShader;let l;if(s.getEngine()._features.supportSwitchCaseInShader){l="switch(i) {";for(let d=0;d<r.layerCount;d++)l+="case "+d+" : frameID = texture(tileMaps["+d+"], (tileID + 0.5) / stageSize, 0.).x;",l+="break;";l+="}"}else{l="";for(let d=0;d<r.layerCount;d++)l+=`if (${d} == i) { frameID = texture2D(tileMaps[${d}], (tileID + 0.5) / stageSize, 0.).x; }`}_i.ShadersStore["spriteMap"+this.name+"PixelShader"]=o.replace("#define LAYER_ID_SWITCH",l),this._material=new Wr("spriteMap:"+this.name,this._scene,{vertex:"spriteMap",fragment:"spriteMap"+this.name},{defines:n,attributes:["position","normal","uv"],uniforms:["world","view","projection","time","stageSize","outputSize","spriteMapSize","spriteCount","time","colorMul","mousePosition","curTile","flipU"],samplers:["spriteSheet","frameMap","tileMaps","animationMap"],needAlphaBlending:!0}),this._time=0,this._material.setFloat("spriteCount",this.spriteCount),this._material.setVector2("stageSize",r.stageSize),this._material.setVector2("outputSize",r.outputSize),this._material.setTexture("spriteSheet",this.spriteSheet),this._material.setVector2("spriteMapSize",new Q(1,1)),this._material.setVector3("colorMul",r.colorMultiply);let u=0;const c=()=>{if(this.spriteSheet&&this.spriteSheet.isReady()&&this.spriteSheet._texture){this._material.setVector2("spriteMapSize",new Q(this.spriteSheet._texture.baseWidth||1,this.spriteSheet._texture.baseHeight||1));return}u<100&&setTimeout(()=>{u++,c()},100)};c(),this._material.setVector3("colorMul",r.colorMultiply),this._material.setTexture("frameMap",this._frameMap),this._material.setTextureArray("tileMaps",this._tileMaps),this._material.setTexture("animationMap",this._animationMap),this._material.setFloat("time",this._time),this._output=gn(e+":output",{size:1,updatable:!0},s),this._output.scaling.x=r.outputSize.x,this._output.scaling.y=r.outputSize.y,this.position=r.outputPosition,this.rotation=r.outputRotation;const h=()=>{this._time+=this._scene.getEngine().getDeltaTime(),this._material.setFloat("time",this._time)};this._scene.onBeforeRenderObservable.add(h),this._output.material=this._material}getTileIdxByName(e){return this.atlasJSON.frames.findIndex(i=>i.filename===e)}getTileID(){const e=this.getMousePosition();return e.multiplyInPlace(this.options.stageSize||Q.Zero()),e.x=Math.floor(e.x),e.y=Math.floor(e.y),e}getMousePosition(){const e=this._output,t=this._scene.pick(this._scene.pointerX,this._scene.pointerY,r=>r===e);if(!t||!t.hit||!t.getTextureCoordinates)return new Q(-1,-1);const i=t.getTextureCoordinates();return i||new Q(-1,-1)}_createFrameBuffer(){const e=[];for(let r=0;r<this.spriteCount;r++)e.push(0,0,0,0),e.push(0,0,0,0),e.push(0,0,0,0),e.push(0,0,0,0);for(let r=0;r<this.spriteCount;r++){const s=this.sprites[r].frame,n=this.sprites[r].spriteSourceSize,o=this.sprites[r].sourceSize,l=this.sprites[r].rotated?1:0,u=this.sprites[r].trimmed?1:0;e[r*4]=s.x,e[r*4+1]=s.y,e[r*4+2]=s.w,e[r*4+3]=s.h,e[r*4+this.spriteCount*4]=n.x,e[r*4+1+this.spriteCount*4]=n.y,e[r*4+3+this.spriteCount*4]=n.h,e[r*4+this.spriteCount*8]=o.w,e[r*4+1+this.spriteCount*8]=o.h,e[r*4+2+this.spriteCount*8]=l,e[r*4+3+this.spriteCount*8]=u}const t=new Float32Array(e);return qt.CreateRGBATexture(t,this.spriteCount,4,this._scene,!1,!1,Y.NEAREST_NEAREST,1)}_createTileBuffer(e,t=0){let i=[];const r=this.options.stageSize.y||0,s=this.options.stageSize.x||0;if(e)i=e;else{let l=this.options.baseTile;t!=0&&(l=0);for(let u=0;u<r;u++)for(let c=0;c<s*4;c+=4)i.push(l,0,0,0)}const n=new Float32Array(i);return qt.CreateRGBATexture(n,s,r,this._scene,!1,!1,Y.NEAREST_NEAREST,1)}changeTiles(e=0,t,i=0){const r=this._tileMaps[e]._texture._bufferView;if(r===null)return;let s=[];t instanceof Q?s.push(t):s=t;const n=this.options.stageSize.x||0;for(let l=0;l<s.length;l++){const u=s[l];u.x=Math.floor(u.x),u.y=Math.floor(u.y);const c=u.x*4+u.y*(n*4);r[c]=i}const o=this._createTileBuffer(r);this._tileMaps[e].dispose(),this._tileMaps[e]=o,this._material.setTextureArray("tileMap",this._tileMaps)}_createTileAnimationBuffer(e){const t=[];let i;if(e)i=e;else{for(let s=0;s<this.spriteCount;s++){t.push(0,0,0,0);let n=1;for(;n<(this.options.maxAnimationFrames||4);)t.push(0,0,0,0),n++}i=new Float32Array(t)}return qt.CreateRGBATexture(i,this.spriteCount,this.options.maxAnimationFrames||4,this._scene,!1,!1,Y.NEAREST_NEAREST,1)}addAnimationToTile(e=0,t=0,i=0,r=0,s=1){const n=this._animationMap._texture._bufferView,o=e*4+this.spriteCount*4*t;if(!n)return;n[o]=i,n[o+1]=r,n[o+2]=s;const l=this._createTileAnimationBuffer(n);this._animationMap.dispose(),this._animationMap=l,this._material.setTexture("animationMap",this._animationMap)}saveTileMaps(){let e="";for(let i=0;i<this._tileMaps.length;i++)i>0&&(e+=`
\r`),e+=this._tileMaps[i]._texture._bufferView.toString();const t=document.createElement("a");t.href="data:octet/stream;charset=utf-8,"+encodeURI(e),t.target="_blank",t.download=this.name+".tilemaps",t.click(),t.remove()}loadTileMaps(e){const t=new XMLHttpRequest;t.open("GET",e);const i=this.options.layerCount||0;t.onload=()=>{const r=t.response.split(`
\r`);for(let s=0;s<i;s++){const n=r[s].split(",").map(Number),o=this._createTileBuffer(n);this._tileMaps[s].dispose(),this._tileMaps[s]=o}this._material.setTextureArray("tileMap",this._tileMaps)},t.send()}dispose(){this._output.dispose(),this._material.dispose(),this._animationMap.dispose(),this._tileMaps.forEach(e=>{e.dispose()}),this._frameMap.dispose()}}const Wb="imageProcessingCompatibility",qG=`#ifdef IMAGEPROCESSINGPOSTPROCESS
gl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(2.2));
#endif
`;P.IncludesShadersStore[Wb]||(P.IncludesShadersStore[Wb]=qG);const ym="spritesPixelShader",vR=`#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
uniform bool alphaTest;varying vec4 vColor;varying vec2 vUV;uniform sampler2D diffuseSampler;
#include<fogFragmentDeclaration>
#include<logDepthDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
#ifdef PIXEL_PERFECT
vec2 uvPixelPerfect(vec2 uv) {vec2 res=vec2(textureSize(diffuseSampler,0));uv=uv*res;vec2 seam=floor(uv+0.5);uv=seam+clamp((uv-seam)/fwidth(uv),-0.5,0.5);return uv/res;}
#endif
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#ifdef PIXEL_PERFECT
vec2 uv=uvPixelPerfect(vUV);
#else
vec2 uv=vUV;
#endif
vec4 color=texture2D(diffuseSampler,uv);float fAlphaTest=float(alphaTest);if (fAlphaTest != 0.)
{if (color.a<0.95)
discard;}
color*=vColor;
#include<logDepthFragment>
#include<fogFragment>
gl_FragColor=color;
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}`;P.ShadersStore[ym]||(P.ShadersStore[ym]=vR);const QG={name:ym,shader:vR},KG=Object.freeze(Object.defineProperty({__proto__:null,spritesPixelShader:QG},Symbol.toStringTag,{value:"Module"})),Tm="spritesVertexShader",bR=`attribute vec4 position;attribute vec2 options;attribute vec2 offsets;attribute vec2 inverts;attribute vec4 cellInfo;attribute vec4 color;uniform mat4 view;uniform mat4 projection;varying vec2 vUV;varying vec4 vColor;
#include<fogVertexDeclaration>
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec3 viewPos=(view*vec4(position.xyz,1.0)).xyz; 
vec2 cornerPos;float angle=position.w;vec2 size=vec2(options.x,options.y);vec2 offset=offsets.xy;cornerPos=vec2(offset.x-0.5,offset.y -0.5)*size;vec3 rotatedCorner;rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.z=0.;viewPos+=rotatedCorner;gl_Position=projection*vec4(viewPos,1.0); 
vColor=color;vec2 uvOffset=vec2(abs(offset.x-inverts.x),abs(1.0-offset.y-inverts.y));vec2 uvPlace=cellInfo.xy;vec2 uvSize=cellInfo.zw;vUV.x=uvPlace.x+uvSize.x*uvOffset.x;vUV.y=uvPlace.y+uvSize.y*uvOffset.y;
#ifdef FOG
vFogDistance=viewPos;
#endif
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStore[Tm]||(P.ShadersStore[Tm]=bR);const JG={name:Tm,shader:bR},e4=Object.freeze(Object.defineProperty({__proto__:null,spritesVertexShader:JG},Symbol.toStringTag,{value:"Module"})),$b="imageProcessingCompatibility",t4=`#ifdef IMAGEPROCESSINGPOSTPROCESS
fragmentOutputs.color=vec4f(pow(fragmentOutputs.color.rgb, vec3f(2.2)),fragmentOutputs.color.a);
#endif
`;P.IncludesShadersStoreWGSL[$b]||(P.IncludesShadersStoreWGSL[$b]=t4);const Cm="spritesPixelShader",yR=`uniform alphaTest: i32;varying vColor: vec4f;varying vUV: vec2f;var diffuseSamplerSampler: sampler;var diffuseSampler: texture_2d<f32>;
#include<fogFragmentDeclaration>
#include<logDepthDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
#ifdef PIXEL_PERFECT
fn uvPixelPerfect(uv: vec2f)->vec2f {var res: vec2f= vec2f(textureDimensions(diffuseSampler,0));var uvTemp=uv*res;var seam: vec2f=floor(uvTemp+0.5);uvTemp=seam+clamp((uvTemp-seam)/fwidth(uvTemp),vec2f(-0.5),vec2f(0.5));return uvTemp/res;}
#endif
@fragment
fn main(input: FragmentInputs)->FragmentOutputs {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#ifdef PIXEL_PERFECT
var uv: vec2f=uvPixelPerfect(input.vUV);
#else
var uv: vec2f=input.vUV;
#endif
var color: vec4f=textureSample(diffuseSampler,diffuseSamplerSampler,uv);var fAlphaTest: f32= f32(uniforms.alphaTest);if (fAlphaTest != 0.)
{if (color.a<0.95) {discard;}}
color*=input.vColor;
#include<logDepthFragment>
#include<fogFragment>
fragmentOutputs.color=color;
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}`;P.ShadersStoreWGSL[Cm]||(P.ShadersStoreWGSL[Cm]=yR);const i4={name:Cm,shader:yR},r4=Object.freeze(Object.defineProperty({__proto__:null,spritesPixelShaderWGSL:i4},Symbol.toStringTag,{value:"Module"})),Pm="spritesVertexShader",TR=`attribute position: vec4f;attribute options: vec2f;attribute offsets: vec2f;attribute inverts: vec2f;attribute cellInfo: vec4f;attribute color: vec4f;uniform view: mat4x4f;uniform projection: mat4x4f;varying vUV: vec2f;varying vColor: vec4f;
#include<fogVertexDeclaration>
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
@vertex
fn main(input : VertexInputs)->FragmentInputs {
#define CUSTOM_VERTEX_MAIN_BEGIN
var viewPos: vec3f=(uniforms.view* vec4f(input.position.xyz,1.0)).xyz; 
var cornerPos: vec2f;var angle: f32=input.position.w;var size: vec2f= vec2f(input.options.x,input.options.y);var offset: vec2f=input.offsets.xy;cornerPos= vec2f(offset.x-0.5,offset.y -0.5)*size;var rotatedCorner: vec3f;rotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);rotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);rotatedCorner.z=0.;viewPos+=rotatedCorner;vertexOutputs.position=uniforms.projection*vec4f(viewPos,1.0); 
vertexOutputs.vColor=input.color;var uvOffset: vec2f= vec2f(abs(offset.x-input.inverts.x),abs(1.0-offset.y-input.inverts.y));var uvPlace: vec2f=input.cellInfo.xy;var uvSize: vec2f=input.cellInfo.zw;vertexOutputs.vUV.x=uvPlace.x+uvSize.x*uvOffset.x;vertexOutputs.vUV.y=uvPlace.y+uvSize.y*uvOffset.y;
#ifdef FOG
vertexOutputs.vFogDistance=viewPos;
#endif
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStoreWGSL[Pm]||(P.ShadersStoreWGSL[Pm]=TR);const s4={name:Pm,shader:TR},n4=Object.freeze(Object.defineProperty({__proto__:null,spritesVertexShaderWGSL:s4},Symbol.toStringTag,{value:"Module"}));var Hb;(function(a){a[a.ENTERING_XR=0]="ENTERING_XR",a[a.EXITING_XR=1]="EXITING_XR",a[a.IN_XR=2]="IN_XR",a[a.NOT_IN_XR=3]="NOT_IN_XR"})(Hb||(Hb={}));var jb;(function(a){a[a.NOT_TRACKING=0]="NOT_TRACKING",a[a.TRACKING_LOST=1]="TRACKING_LOST",a[a.TRACKING=2]="TRACKING"})(jb||(jb={}));class hn extends ti{constructor(e,t={}){super(e),this.options=t,this._direction=new m(0,0,-1),this._mat=new $,this._onSelectEnabled=!1,this._origin=new m(0,0,0),this.lastNativeXRHitResults=[],this.onHitTestResultObservable=new j,this._onHitTestResults=i=>{const r=i.map(s=>{const n=$.FromArray(s.hitMatrix);return this._xrSessionManager.scene.useRightHandedSystem||n.toggleModelMatrixHandInPlace(),this.options.worldParentNode&&n.multiplyToRef(this.options.worldParentNode.getWorldMatrix(),n),{xrHitResult:s,transformationMatrix:n}});this.lastNativeXRHitResults=i,this.onHitTestResultObservable.notifyObservers(r)},this._onSelect=i=>{this._onSelectEnabled&&hn.XRHitTestWithSelectEvent(i,this._xrSessionManager.referenceSpace)},this.xrNativeFeatureName="hit-test",ae.Warn("A newer version of this plugin is available")}static XRHitTestWithRay(e,t,i,r){return e.requestHitTest(t,i).then(s=>{const n=r||(o=>!!o.hitMatrix);return s.filter(n)})}static XRHitTestWithSelectEvent(e,t){const i=e.frame.getPose(e.inputSource.targetRaySpace,t);if(!i)return Promise.resolve([]);const r=new XRRay(i.transform);return this.XRHitTestWithRay(e.frame.session,r,t)}attach(){return super.attach()?(this.options.testOnPointerDownOnly&&this._xrSessionManager.session.addEventListener("select",this._onSelect,!1),!0):!1}detach(){return super.detach()?(this._onSelectEnabled=!1,this._xrSessionManager.session.removeEventListener("select",this._onSelect),!0):!1}dispose(){super.dispose(),this.onHitTestResultObservable.clear()}_onXRFrame(e){if(!this.attached||this.options.testOnPointerDownOnly)return;const t=e.getViewerPose(this._xrSessionManager.referenceSpace);if(!t)return;$.FromArrayToRef(t.transform.matrix,0,this._mat),m.TransformCoordinatesFromFloatsToRef(0,0,0,this._mat,this._origin),m.TransformCoordinatesFromFloatsToRef(0,0,-1,this._mat,this._direction),this._direction.subtractInPlace(this._origin),this._direction.normalize();const i=new XRRay({x:this._origin.x,y:this._origin.y,z:this._origin.z,w:0},{x:this._direction.x,y:this._direction.y,z:this._direction.z,w:0});hn.XRHitTestWithRay(this._xrSessionManager.session,i,this._xrSessionManager.referenceSpace).then(this._onHitTestResults)}}hn.Name=ke.HIT_TEST;hn.Version=1;Tt.AddWebXRFeature(hn.Name,(a,e)=>()=>new hn(a,e),hn.Version,!1);let a4=0;class yo extends ti{set referenceSpaceForFrameAnchors(e){this._referenceSpaceForFrameAnchors=e}constructor(e,t={}){super(e),this._options=t,this._lastFrameDetected=new Set,this._trackedAnchors=[],this._futureAnchors=[],this.onAnchorAddedObservable=new j,this.onAnchorRemovedObservable=new j,this.onAnchorUpdatedObservable=new j,this._tmpVector=new m,this._tmpQuaternion=new re,this.xrNativeFeatureName="anchors",this._options.clearAnchorsOnSessionInit&&this._xrSessionManager.onXRSessionInit.add(()=>{this._trackedAnchors.length=0,this._futureAnchors.length=0,this._lastFrameDetected.clear()})}_populateTmpTransformation(e,t){return this._tmpVector.copyFrom(e),this._tmpQuaternion.copyFrom(t),this._xrSessionManager.scene.useRightHandedSystem||(this._tmpVector.z*=-1,this._tmpQuaternion.z*=-1,this._tmpQuaternion.w*=-1),{position:this._tmpVector,rotationQuaternion:this._tmpQuaternion}}async addAnchorPointUsingHitTestResultAsync(e,t=new m,i=new re){this._populateTmpTransformation(t,i);const r=new XRRigidTransform({x:this._tmpVector.x,y:this._tmpVector.y,z:this._tmpVector.z},{x:this._tmpQuaternion.x,y:this._tmpQuaternion.y,z:this._tmpQuaternion.z,w:this._tmpQuaternion.w});if(e.xrHitResult.createAnchor)try{const s=await e.xrHitResult.createAnchor(r);return new Promise((n,o)=>{this._futureAnchors.push({nativeAnchor:s,resolved:!1,submitted:!0,xrTransformation:r,resolve:n,reject:o})})}catch(s){throw new Error(s)}else throw this.detach(),new Error("Anchors not enabled in this environment/browser")}async addAnchorAtPositionAndRotationAsync(e,t=new re,i=!1){this._populateTmpTransformation(e,t);const r=new XRRigidTransform({x:this._tmpVector.x,y:this._tmpVector.y,z:this._tmpVector.z},{x:this._tmpQuaternion.x,y:this._tmpQuaternion.y,z:this._tmpQuaternion.z,w:this._tmpQuaternion.w}),s=i&&this.attached&&this._xrSessionManager.currentFrame?await this._createAnchorAtTransformation(r,this._xrSessionManager.currentFrame):void 0;return new Promise((n,o)=>{this._futureAnchors.push({nativeAnchor:s,resolved:!1,submitted:!1,xrTransformation:r,resolve:n,reject:o})})}get anchors(){return this._trackedAnchors}detach(){if(!super.detach())return!1;if(!this._options.doNotRemoveAnchorsOnSessionEnded)for(;this._trackedAnchors.length;){const e=this._trackedAnchors.pop();e&&!e._removed&&(this.onAnchorRemovedObservable.notifyObservers(e),e._removed=!0)}return!0}dispose(){this._futureAnchors.length=0,super.dispose(),this.onAnchorAddedObservable.clear(),this.onAnchorRemovedObservable.clear(),this.onAnchorUpdatedObservable.clear()}_onXRFrame(e){if(!this.attached||!e)return;const t=e.trackedAnchors;if(t){const i=this._trackedAnchors.filter(s=>s._removed).map(s=>this._trackedAnchors.indexOf(s));let r=0;i.forEach(s=>{const n=this._trackedAnchors.splice(s-r,1)[0];n.xrAnchor.delete(),this.onAnchorRemovedObservable.notifyObservers(n),r++}),t.forEach(s=>{if(this._lastFrameDetected.has(s)){const n=this._findIndexInAnchorArray(s),o=this._trackedAnchors[n];try{this._updateAnchorWithXRFrame(s,o,e),o.attachedNode&&(o.attachedNode.rotationQuaternion=o.attachedNode.rotationQuaternion||new re,o.transformationMatrix.decompose(o.attachedNode.scaling,o.attachedNode.rotationQuaternion,o.attachedNode.position)),this.onAnchorUpdatedObservable.notifyObservers(o)}catch{ae.Warn("Anchor could not be updated")}}else{const n={id:a4++,xrAnchor:s,remove:()=>{n._removed=!0}},o=this._updateAnchorWithXRFrame(s,n,e);this._trackedAnchors.push(o),this.onAnchorAddedObservable.notifyObservers(o);const u=this._futureAnchors.filter(c=>c.nativeAnchor===s)[0];u&&(u.resolve(o),u.resolved=!0)}}),this._lastFrameDetected=t}this._futureAnchors.forEach(i=>{!i.resolved&&!i.submitted&&(this._createAnchorAtTransformation(i.xrTransformation,e).then(r=>{i.nativeAnchor=r},r=>{i.resolved=!0,i.reject(r)}),i.submitted=!0)})}_findIndexInAnchorArray(e){for(let t=0;t<this._trackedAnchors.length;++t)if(this._trackedAnchors[t].xrAnchor===e)return t;return-1}_updateAnchorWithXRFrame(e,t,i){const r=i.getPose(e.anchorSpace,this._xrSessionManager.referenceSpace);if(r){const s=t.transformationMatrix||new $;$.FromArrayToRef(r.transform.matrix,0,s),this._xrSessionManager.scene.useRightHandedSystem||s.toggleModelMatrixHandInPlace(),t.transformationMatrix=s,this._options.worldParentNode&&s.multiplyToRef(this._options.worldParentNode.getWorldMatrix(),s)}return t}async _createAnchorAtTransformation(e,t){if(t.createAnchor)try{return t.createAnchor(e,this._referenceSpaceForFrameAnchors??this._xrSessionManager.referenceSpace)}catch(i){throw new Error(i)}else throw this.detach(),new Error("Anchors are not enabled in your browser")}}yo.Name=ke.ANCHOR_SYSTEM;yo.Version=1;Tt.AddWebXRFeature(yo.Name,(a,e)=>()=>new yo(a,e),yo.Version);let o4=0;class To extends ti{constructor(e,t={}){super(e),this._options=t,this._detectedPlanes=[],this._enabled=!1,this._lastFrameDetected=new Set,this.onPlaneAddedObservable=new j,this.onPlaneRemovedObservable=new j,this.onPlaneUpdatedObservable=new j,this.xrNativeFeatureName="plane-detection",this._xrSessionManager.session?this._init():this._xrSessionManager.onXRSessionInit.addOnce(()=>{this._init()})}detach(){if(!super.detach())return!1;if(!this._options.doNotRemovePlanesOnSessionEnded)for(;this._detectedPlanes.length;){const e=this._detectedPlanes.pop();e&&this.onPlaneRemovedObservable.notifyObservers(e)}return!0}dispose(){super.dispose(),this.onPlaneAddedObservable.clear(),this.onPlaneRemovedObservable.clear(),this.onPlaneUpdatedObservable.clear()}isCompatible(){return typeof XRPlane<"u"}async initiateRoomCapture(){return this._xrSessionManager.session.initiateRoomCapture?this._xrSessionManager.session.initiateRoomCapture():Promise.reject("initiateRoomCapture is not supported on this session")}_onXRFrame(e){var i;if(!this.attached||!this._enabled||!e)return;const t=e.detectedPlanes||((i=e.worldInformation)==null?void 0:i.detectedPlanes);if(t){for(let r=0;r<this._detectedPlanes.length;r++){const s=this._detectedPlanes[r];t.has(s.xrPlane)||(this._detectedPlanes.splice(r--,1),this.onPlaneRemovedObservable.notifyObservers(s))}t.forEach(r=>{if(this._lastFrameDetected.has(r)){if(r.lastChangedTime===this._xrSessionManager.currentTimestamp){const s=this._findIndexInPlaneArray(r),n=this._detectedPlanes[s];this._updatePlaneWithXRPlane(r,n,e),this.onPlaneUpdatedObservable.notifyObservers(n)}}else{const s={id:o4++,xrPlane:r,polygonDefinition:[]},n=this._updatePlaneWithXRPlane(r,s,e);this._detectedPlanes.push(n),this.onPlaneAddedObservable.notifyObservers(n)}}),this._lastFrameDetected=t}}_init(){const e=()=>{this._enabled=!0,this._detectedPlanes.length&&(this._detectedPlanes.length=0)};if(this._xrSessionManager.isNative&&this._options.preferredDetectorOptions&&this._xrSessionManager.session.trySetPreferredPlaneDetectorOptions&&this._xrSessionManager.session.trySetPreferredPlaneDetectorOptions(this._options.preferredDetectorOptions),!this._xrSessionManager.session.updateWorldTrackingState){e();return}this._xrSessionManager.session.updateWorldTrackingState({planeDetectionState:{enabled:!0}}),e()}_updatePlaneWithXRPlane(e,t,i){t.polygonDefinition=e.polygon.map(s=>{const n=this._xrSessionManager.scene.useRightHandedSystem?1:-1;return new m(s.x,s.y,s.z*n)});const r=i.getPose(e.planeSpace,this._xrSessionManager.referenceSpace);if(r){const s=t.transformationMatrix||new $;$.FromArrayToRef(r.transform.matrix,0,s),this._xrSessionManager.scene.useRightHandedSystem||s.toggleModelMatrixHandInPlace(),t.transformationMatrix=s,this._options.worldParentNode&&s.multiplyToRef(this._options.worldParentNode.getWorldMatrix(),s)}return t}_findIndexInPlaneArray(e){for(let t=0;t<this._detectedPlanes.length;++t)if(this._detectedPlanes[t].xrPlane===e)return t;return-1}}To.Name=ke.PLANE_DETECTION;To.Version=1;Tt.AddWebXRFeature(To.Name,(a,e)=>()=>new To(a,e),To.Version);class Co extends ti{constructor(e,t={}){super(e),this.options=t,this.onBackgroundStateChangedObservable=new j}attach(){return this._setBackgroundState(!1),super.attach()}detach(){return this._setBackgroundState(!0),super.detach()}dispose(){super.dispose(),this.onBackgroundStateChangedObservable.clear()}_onXRFrame(e){}_setBackgroundState(e){const t=this._xrSessionManager.scene;if(!this.options.ignoreEnvironmentHelper)if(this.options.environmentHelperRemovalFlags){if(this.options.environmentHelperRemovalFlags.skyBox){const i=t.getMeshByName("BackgroundSkybox");i&&i.setEnabled(e)}if(this.options.environmentHelperRemovalFlags.ground){const i=t.getMeshByName("BackgroundPlane");i&&i.setEnabled(e)}}else{const i=t.getMeshByName("BackgroundHelper");i&&i.setEnabled(e)}this.options.backgroundMeshes&&this.options.backgroundMeshes.forEach(i=>i.setEnabled(e)),this.onBackgroundStateChangedObservable.notifyObservers(e)}}Co.Name=ke.BACKGROUND_REMOVER;Co.Version=1;Tt.AddWebXRFeature(Co.Name,(a,e)=>()=>new Co(a,e),Co.Version,!0);class Y${}class Po extends ti{_createPhysicsImpostor(e){const t=this._options.physicsProperties.impostorType||ve.SphereImpostor,i=this._options.physicsProperties.impostorSize||.1,r=Ti("impostor-mesh-"+e.uniqueId,{diameterX:typeof i=="number"?i:i.width,diameterY:typeof i=="number"?i:i.height,diameterZ:typeof i=="number"?i:i.depth});r.isVisible=this._debugMode,r.isPickable=!1,r.rotationQuaternion=new re;const s=e.grip||e.pointer;r.position.copyFrom(s.position),r.rotationQuaternion.copyFrom(s.rotationQuaternion);const n=new ve(r,t,{mass:0,...this._options.physicsProperties});this._controllers[e.uniqueId]={xrController:e,impostor:n,impostorMesh:r}}constructor(e,t){super(e),this._options=t,this._attachController=i=>{this._controllers[i.uniqueId]||(this._xrSessionManager.scene.isPhysicsEnabled()||L.Warn("physics engine not enabled, skipped. Please add this controller manually."),this._options.physicsProperties.useControllerMesh&&i.inputSource.gamepad?i.onMotionControllerInitObservable.addOnce(r=>{r._doNotLoadControllerMesh?this._createPhysicsImpostor(i):r.onModelLoadedObservable.addOnce(()=>{const s=new ve(r.rootMesh,ve.MeshImpostor,{mass:0,...this._options.physicsProperties}),n=i.grip||i.pointer;this._controllers[i.uniqueId]={xrController:i,impostor:s,oldPos:n.position.clone(),oldRotation:n.rotationQuaternion.clone()}})}):this._createPhysicsImpostor(i))},this._controllers={},this._debugMode=!1,this._delta=0,this._lastTimestamp=0,this._tmpQuaternion=new re,this._tmpVector=new m,this._options.physicsProperties||(this._options.physicsProperties={})}_enablePhysicsDebug(){this._debugMode=!0,Object.keys(this._controllers).forEach(e=>{const t=this._controllers[e];t.impostorMesh&&(t.impostorMesh.isVisible=!0)})}addController(e){this._attachController(e)}attach(){if(!super.attach())return!1;if(!this._options.xrInput)return!0;if(this._options.xrInput.controllers.forEach(this._attachController),this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable,this._attachController),this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable,e=>{this._detachController(e.uniqueId)}),this._options.enableHeadsetImpostor){const e=this._options.headsetImpostorParams||{impostorType:ve.SphereImpostor,restitution:.8,impostorSize:.3},t=e.impostorSize||.3;this._headsetMesh=Ti("headset-mesh",{diameterX:typeof t=="number"?t:t.width,diameterY:typeof t=="number"?t:t.height,diameterZ:typeof t=="number"?t:t.depth}),this._headsetMesh.rotationQuaternion=new re,this._headsetMesh.isVisible=!1,this._headsetImpostor=new ve(this._headsetMesh,e.impostorType,{mass:0,...e})}return!0}detach(){return super.detach()?(Object.keys(this._controllers).forEach(e=>{this._detachController(e)}),this._headsetMesh&&this._headsetMesh.dispose(),!0):!1}getHeadsetImpostor(){return this._headsetImpostor}getImpostorForController(e){const t=typeof e=="string"?e:e.uniqueId;return this._controllers[t]?this._controllers[t].impostor:null}setPhysicsProperties(e){this._options.physicsProperties={...this._options.physicsProperties,...e}}_onXRFrame(e){var t,i;if(this._delta=this._xrSessionManager.currentTimestamp-this._lastTimestamp,this._lastTimestamp=this._xrSessionManager.currentTimestamp,this._headsetMesh&&this._headsetImpostor){if(this._headsetMesh.position.copyFrom(this._options.xrInput.xrCamera.globalPosition),this._headsetMesh.rotationQuaternion.copyFrom(this._options.xrInput.xrCamera.absoluteRotation),(t=this._options.xrInput.xrCamera._lastXRViewerPose)!=null&&t.linearVelocity){const r=this._options.xrInput.xrCamera._lastXRViewerPose.linearVelocity;this._tmpVector.set(r.x,r.y,r.z),this._headsetImpostor.setLinearVelocity(this._tmpVector)}if((i=this._options.xrInput.xrCamera._lastXRViewerPose)!=null&&i.angularVelocity){const r=this._options.xrInput.xrCamera._lastXRViewerPose.angularVelocity;this._tmpVector.set(r.x,r.y,r.z),this._headsetImpostor.setAngularVelocity(this._tmpVector)}}Object.keys(this._controllers).forEach(r=>{var u,c;const s=this._controllers[r],n=s.xrController.grip||s.xrController.pointer,o=s.oldPos||s.impostorMesh.position;if((u=s.xrController._lastXRPose)!=null&&u.linearVelocity){const h=s.xrController._lastXRPose.linearVelocity;this._tmpVector.set(h.x,h.y,h.z),s.impostor.setLinearVelocity(this._tmpVector)}else n.position.subtractToRef(o,this._tmpVector),this._tmpVector.scaleInPlace(1e3/this._delta),s.impostor.setLinearVelocity(this._tmpVector);o.copyFrom(n.position),this._debugMode&&L.Log([this._tmpVector,"linear"]);const l=s.oldRotation||s.impostorMesh.rotationQuaternion;if((c=s.xrController._lastXRPose)!=null&&c.angularVelocity){const h=s.xrController._lastXRPose.angularVelocity;this._tmpVector.set(h.x,h.y,h.z),s.impostor.setAngularVelocity(this._tmpVector)}else if(!l.equalsWithEpsilon(n.rotationQuaternion)){l.conjugateInPlace().multiplyToRef(n.rotationQuaternion,this._tmpQuaternion);const h=Math.sqrt(this._tmpQuaternion.x*this._tmpQuaternion.x+this._tmpQuaternion.y*this._tmpQuaternion.y+this._tmpQuaternion.z*this._tmpQuaternion.z);if(this._tmpVector.set(this._tmpQuaternion.x,this._tmpQuaternion.y,this._tmpQuaternion.z),h<.001)this._tmpVector.scaleInPlace(2);else{const d=2*Math.atan2(h,this._tmpQuaternion.w);this._tmpVector.scaleInPlace(d/(h*(this._delta/1e3)))}s.impostor.setAngularVelocity(this._tmpVector)}l.copyFrom(n.rotationQuaternion),this._debugMode&&L.Log([this._tmpVector,this._tmpQuaternion,"angular"])})}_detachController(e){const t=this._controllers[e];t&&(t.impostorMesh&&t.impostorMesh.dispose(),delete this._controllers[e])}}Po.Name=ke.PHYSICS_CONTROLLERS;Po.Version=1;Tt.AddWebXRFeature(Po.Name,(a,e)=>()=>new Po(a,e),Po.Version,!0);class Eo extends ti{constructor(e,t={}){super(e),this.options=t,this._tmpMat=new $,this._tmpPos=new m,this._tmpQuat=new re,this._initHitTestSource=i=>{if(!i)return;const r=new XRRay(this.options.offsetRay||{}),s={space:this.options.useReferenceSpace?i:this._xrSessionManager.viewerReferenceSpace,offsetRay:r};if(this.options.entityTypes&&(s.entityTypes=this.options.entityTypes),!s.space){ae.Warn("waiting for viewer reference space to initialize");return}this._xrSessionManager.session.requestHitTestSource(s).then(n=>{this._xrHitTestSource&&this._xrHitTestSource.cancel(),this._xrHitTestSource=n})},this.autoCloneTransformation=!1,this.onHitTestResultObservable=new j,this.paused=!1,this.xrNativeFeatureName="hit-test",ae.Warn("Hit test is an experimental and unstable feature.")}attach(){if(!super.attach()||!this._xrSessionManager.session.requestHitTestSource)return!1;if(this.options.disablePermanentHitTest||(this._xrSessionManager.referenceSpace&&this._initHitTestSource(this._xrSessionManager.referenceSpace),this._xrSessionManager.onXRReferenceSpaceChanged.add(this._initHitTestSource)),this.options.enableTransientHitTest){const e=new XRRay(this.options.transientOffsetRay||{});this._xrSessionManager.session.requestHitTestSourceForTransientInput({profile:this.options.transientHitTestProfile||"generic-touchscreen",offsetRay:e,entityTypes:this.options.entityTypes}).then(t=>{this._transientXrHitTestSource=t})}return!0}detach(){return super.detach()?(this._xrHitTestSource&&(this._xrHitTestSource.cancel(),this._xrHitTestSource=null),this._xrSessionManager.onXRReferenceSpaceChanged.removeCallback(this._initHitTestSource),this._transientXrHitTestSource&&(this._transientXrHitTestSource.cancel(),this._transientXrHitTestSource=null),!0):!1}dispose(){super.dispose(),this.onHitTestResultObservable.clear()}_onXRFrame(e){if(!(!this.attached||this.paused)){if(this._xrHitTestSource){const t=e.getHitTestResults(this._xrHitTestSource);this._processWebXRHitTestResult(t)}this._transientXrHitTestSource&&e.getHitTestResultsForTransientInput(this._transientXrHitTestSource).forEach(i=>{this._processWebXRHitTestResult(i.results,i.inputSource)})}}_processWebXRHitTestResult(e,t){const i=[];e.forEach(r=>{const s=r.getPose(this._xrSessionManager.referenceSpace);if(!s)return;const n=s.transform.position,o=s.transform.orientation;this._tmpPos.set(n.x,n.y,n.z).scaleInPlace(this._xrSessionManager.worldScalingFactor),this._tmpQuat.set(o.x,o.y,o.z,o.w),$.FromFloat32ArrayToRefScaled(s.transform.matrix,0,1,this._tmpMat),this._xrSessionManager.scene.useRightHandedSystem||(this._tmpPos.z*=-1,this._tmpQuat.z*=-1,this._tmpQuat.w*=-1,this._tmpMat.toggleModelMatrixHandInPlace());const l={position:this.autoCloneTransformation?this._tmpPos.clone():this._tmpPos,rotationQuaternion:this.autoCloneTransformation?this._tmpQuat.clone():this._tmpQuat,transformationMatrix:this.autoCloneTransformation?this._tmpMat.clone():this._tmpMat,inputSource:t,isTransient:!!t,xrHitResult:r};i.push(l)}),this.onHitTestResultObservable.notifyObservers(i)}}Eo.Name=ke.HIT_TEST;Eo.Version=2;Tt.AddWebXRFeature(Eo.Name,(a,e)=>()=>new Eo(a,e),Eo.Version,!1);class Io extends ti{get featurePointCloud(){return this._featurePointCloud}constructor(e){super(e),this._enabled=!1,this._featurePointCloud=[],this.onFeaturePointsAddedObservable=new j,this.onFeaturePointsUpdatedObservable=new j,this.xrNativeFeatureName="bjsfeature-points",this._xrSessionManager.session?this._init():this._xrSessionManager.onXRSessionInit.addOnce(()=>{this._init()})}detach(){return super.detach()?(this.featurePointCloud.length=0,!0):!1}dispose(){super.dispose(),this._featurePointCloud.length=0,this.onFeaturePointsUpdatedObservable.clear(),this.onFeaturePointsAddedObservable.clear()}_onXRFrame(e){if(!this.attached||!this._enabled||!e)return;const t=e.featurePointCloud;if(!(!t||t.length===0)){if(t.length%5!==0)throw new Error("Received malformed feature point cloud of length: "+t.length);const i=t.length/5,r=[],s=[];for(let n=0;n<i;n++){const o=n*5,l=t[o+4];this._featurePointCloud[l]?r.push(l):(this._featurePointCloud[l]={position:new m,confidenceValue:0},s.push(l)),this._featurePointCloud[l].position.x=t[o],this._featurePointCloud[l].position.y=t[o+1],this._featurePointCloud[l].position.z=t[o+2],this._featurePointCloud[l].confidenceValue=t[o+3]}s.length>0&&this.onFeaturePointsAddedObservable.notifyObservers(s),r.length>0&&this.onFeaturePointsUpdatedObservable.notifyObservers(r)}}_init(){!this._xrSessionManager.session.trySetFeaturePointCloudEnabled||!this._xrSessionManager.session.trySetFeaturePointCloudEnabled(!0)||(this._enabled=!0)}}Io.Name=ke.FEATURE_POINTS;Io.Version=1;Tt.AddWebXRFeature(Io.Name,a=>()=>new Io(a),Io.Version);let l4=0;class Ro extends ti{constructor(e,t={}){super(e),this._options=t,this._detectedMeshes=new Map,this.onMeshAddedObservable=new j,this.onMeshRemovedObservable=new j,this.onMeshUpdatedObservable=new j,this.xrNativeFeatureName="mesh-detection",this._options.generateMeshes&&(this._options.convertCoordinateSystems=!0),this._xrSessionManager.session?this._init():this._xrSessionManager.onXRSessionInit.addOnce(()=>{this._init()})}detach(){return super.detach()?(this._xrSessionManager.isNative&&this._xrSessionManager.session.trySetMeshDetectorEnabled&&this._xrSessionManager.session.trySetMeshDetectorEnabled(!1),this._options.doNotRemoveMeshesOnSessionEnded||(this._detectedMeshes.forEach(e=>{this.onMeshRemovedObservable.notifyObservers(e)}),this._detectedMeshes.clear()),!0):!1}dispose(){super.dispose(),this.onMeshAddedObservable.clear(),this.onMeshRemovedObservable.clear(),this.onMeshUpdatedObservable.clear()}_onXRFrame(e){var t;try{if(!this.attached||!e)return;const i=e.detectedMeshes||((t=e.worldInformation)==null?void 0:t.detectedMeshes);if(i){const r=new Set;this._detectedMeshes.forEach((s,n)=>{i.has(n)||r.add(n)}),r.forEach(s=>{const n=this._detectedMeshes.get(s);n&&(this.onMeshRemovedObservable.notifyObservers(n),this._detectedMeshes.delete(s))}),i.forEach(s=>{if(this._detectedMeshes.has(s)){if(s.lastChangedTime===this._xrSessionManager.currentTimestamp){const n=this._detectedMeshes.get(s);n&&(this._updateVertexDataWithXRMesh(s,n,e),this.onMeshUpdatedObservable.notifyObservers(n))}}else{const n={id:l4++,xrMesh:s},o=this._updateVertexDataWithXRMesh(s,n,e);this._detectedMeshes.set(s,o),this.onMeshAddedObservable.notifyObservers(o)}})}}catch(i){L.Log(i.stack)}}_init(){this._xrSessionManager.isNative&&(this._xrSessionManager.session.trySetMeshDetectorEnabled&&this._xrSessionManager.session.trySetMeshDetectorEnabled(!0),this._options.preferredDetectorOptions&&this._xrSessionManager.session.trySetPreferredMeshDetectorOptions&&this._xrSessionManager.session.trySetPreferredMeshDetectorOptions(this._options.preferredDetectorOptions))}_updateVertexDataWithXRMesh(e,t,i){var s;t.xrMesh=e,t.worldParentNode=this._options.worldParentNode;const r=e.vertices||e.positions;if(this._options.convertCoordinateSystems){if(this._xrSessionManager.scene.useRightHandedSystem)t.positions=r,t.normals=e.normals;else{t.positions=new Float32Array(r.length);for(let o=0;o<r.length;o+=3)t.positions[o]=r[o],t.positions[o+1]=r[o+1],t.positions[o+2]=-1*r[o+2];if(e.normals){t.normals=new Float32Array(e.normals.length);for(let o=0;o<e.normals.length;o+=3)t.normals[o]=e.normals[o],t.normals[o+1]=e.normals[o+1],t.normals[o+2]=-1*e.normals[o+2]}}t.indices=e.indices;const n=i.getPose(e.meshSpace,this._xrSessionManager.referenceSpace);if(n){const o=t.transformationMatrix||new $;$.FromArrayToRef(n.transform.matrix,0,o),this._xrSessionManager.scene.useRightHandedSystem||o.toggleModelMatrixHandInPlace(),t.transformationMatrix=o,this._options.worldParentNode&&o.multiplyToRef(this._options.worldParentNode.getWorldMatrix(),o)}if(this._options.generateMeshes){if(t.mesh){const o=t.mesh;o.updateVerticesData(N.PositionKind,t.positions),t.normals?o.updateVerticesData(N.NormalKind,t.normals):o.createNormals(!0),o.updateIndices(t.indices)}else{const o=new z("xr mesh "+t.id,this._xrSessionManager.scene);o.rotationQuaternion=new re,o.setVerticesData(N.PositionKind,t.positions),t.normals?o.setVerticesData(N.NormalKind,t.normals):o.createNormals(!0),o.setIndices(t.indices,void 0,!0),t.mesh=o}(s=t.transformationMatrix)==null||s.decompose(t.mesh.scaling,t.mesh.rotationQuaternion,t.mesh.position)}}return t}}Ro.Name=ke.MESH_DETECTION;Ro.Version=1;Tt.AddWebXRFeature(Ro.Name,(a,e)=>()=>new Ro(a,e),Ro.Version,!1);var Yr;(function(a){a[a.NotReceived=0]="NotReceived",a[a.Waiting=1]="Waiting",a[a.Received=2]="Received"})(Yr||(Yr={}));class Mo extends ti{constructor(e,t){super(e),this.options=t,this.onUntrackableImageFoundObservable=new j,this.onTrackableImageFoundObservable=new j,this.onTrackedImageUpdatedObservable=new j,this._trackableScoreStatus=Yr.NotReceived,this._trackedImages=[],this.xrNativeFeatureName="image-tracking"}attach(){return super.attach()}detach(){return super.detach()}getTrackedImageById(e){return this._trackedImages[e]||null}dispose(){super.dispose(),this._trackedImages.forEach(e=>{e.originalBitmap.close()}),this._trackedImages.length=0,this.onTrackableImageFoundObservable.clear(),this.onUntrackableImageFoundObservable.clear(),this.onTrackedImageUpdatedObservable.clear()}async getXRSessionInitExtension(){if(!this.options.images||!this.options.images.length)return{};const e=this.options.images.map(t=>typeof t.src=="string"?this._xrSessionManager.scene.getEngine()._createImageBitmapFromSource(t.src):Promise.resolve(t.src));try{const t=await Promise.all(e);return this._originalTrackingRequest=t.map((i,r)=>({image:i,widthInMeters:this.options.images[r].estimatedRealWorldWidth})),{trackedImages:this._originalTrackingRequest}}catch{return ae.Error("Error loading images for tracking, WebXRImageTracking disabled for this session."),{}}}_onXRFrame(e){if(!e.getImageTrackingResults||this._trackableScoreStatus===Yr.Waiting)return;if(this._trackableScoreStatus===Yr.NotReceived){this._checkScoresAsync();return}const t=e.getImageTrackingResults();for(const i of t){let r=!1;const s=i.index,n=this._trackedImages[s];if(!n)continue;n.xrTrackingResult=i,n.realWorldWidth!==i.measuredWidthInMeters&&(n.realWorldWidth=i.measuredWidthInMeters,r=!0);const o=e.getPose(i.imageSpace,this._xrSessionManager.referenceSpace);if(o){const c=n.transformationMatrix;$.FromArrayToRef(o.transform.matrix,0,c),this._xrSessionManager.scene.useRightHandedSystem||c.toggleModelMatrixHandInPlace(),r=!0}const u=i.trackingState==="emulated";n.emulated!==u&&(n.emulated=u,r=!0),r&&this.onTrackedImageUpdatedObservable.notifyObservers(n)}}async _checkScoresAsync(){if(!this._xrSessionManager.session.getTrackedImageScores||this._trackableScoreStatus!==Yr.NotReceived)return;this._trackableScoreStatus=Yr.Waiting;const e=await this._xrSessionManager.session.getTrackedImageScores();if(!e||e.length===0){this._trackableScoreStatus=Yr.NotReceived;return}for(let t=0;t<e.length;++t)if(e[t]=="untrackable")this.onUntrackableImageFoundObservable.notifyObservers(t);else{const i=this._originalTrackingRequest[t].image,r={id:t,originalBitmap:i,transformationMatrix:new $,ratio:i.width/i.height};this._trackedImages[t]=r,this.onTrackableImageFoundObservable.notifyObservers(r)}this._trackableScoreStatus=e.length>0?Yr.Received:Yr.NotReceived}}Mo.Name=ke.IMAGE_TRACKING;Mo.Version=1;Tt.AddWebXRFeature(Mo.Name,(a,e)=>()=>new Mo(a,e),Mo.Version,!1);class Ao extends ti{constructor(e,t){super(e),this.options=t,this._domOverlayType=null,this._beforeXRSelectListener=null,this._element=null,this.xrNativeFeatureName="dom-overlay",ae.Warn("dom-overlay is an experimental and unstable feature.")}attach(){return!super.attach()||!this._xrSessionManager.session.domOverlayState||this._xrSessionManager.session.domOverlayState.type===null?!1:(this._domOverlayType=this._xrSessionManager.session.domOverlayState.type,this._element!==null&&this.options.supressXRSelectEvents===!0&&(this._beforeXRSelectListener=e=>{e.preventDefault()},this._element.addEventListener("beforexrselect",this._beforeXRSelectListener)),!0)}get domOverlayType(){return this._domOverlayType}dispose(){super.dispose(),this._element!==null&&this._beforeXRSelectListener&&this._element.removeEventListener("beforexrselect",this._beforeXRSelectListener)}_onXRFrame(e){}async getXRSessionInitExtension(){if(this.options.element===void 0)return ae.Warn('"element" option must be provided to attach xr-dom-overlay feature.'),{};if(typeof this.options.element=="string"){const e=document.querySelector(this.options.element);if(e===null)return ae.Warn(`element not found '${this.options.element}' (not requesting xr-dom-overlay)`),{};this._element=e}else this._element=this.options.element;return{domOverlay:{root:this._element}}}}Ao.Name=ke.DOM_OVERLAY;Ao.Version=1;Tt.AddWebXRFeature(Ao.Name,(a,e)=>()=>new Ao(a,e),Ao.Version,!1);class dn extends ti{get movementDirection(){return this._movementDirection}get movementEnabled(){return this._featureContext.movementEnabled}set movementEnabled(e){this._featureContext.movementEnabled=e}get movementOrientationFollowsViewerPose(){return this._featureContext.movementOrientationFollowsViewerPose}set movementOrientationFollowsViewerPose(e){this._featureContext.movementOrientationFollowsViewerPose=e}get movementSpeed(){return this._featureContext.movementSpeed}set movementSpeed(e){this._featureContext.movementSpeed=e}get movementThreshold(){return this._featureContext.movementThreshold}set movementThreshold(e){this._featureContext.movementThreshold=e}get rotationEnabled(){return this._featureContext.rotationEnabled}set rotationEnabled(e){this._featureContext.rotationEnabled=e}get rotationSpeed(){return this._featureContext.rotationSpeed}set rotationSpeed(e){this._featureContext.rotationSpeed=e}get rotationThreshold(){return this._featureContext.rotationThreshold}set rotationThreshold(e){this._featureContext.rotationThreshold=e}constructor(e,t){if(super(e),this._controllers={},this._currentRegistrationConfigurations=[],this._movementDirection=new re,this._tmpRotationMatrix=$.Identity(),this._tmpTranslationDirection=new m,this._tmpMovementTranslation=new m,this._tempCacheQuaternion=new re,this._attachController=i=>{if(this._controllers[i.uniqueId])return;this._controllers[i.uniqueId]={xrController:i,registeredComponents:[]};const r=this._controllers[i.uniqueId];if(r.xrController.inputSource.targetRayMode==="tracked-pointer"&&r.xrController.inputSource.gamepad){const s=()=>{if(i.motionController)for(const n of this._currentRegistrationConfigurations){let o=null;if(n.allowedComponentTypes)for(const u of n.allowedComponentTypes){const c=i.motionController.getComponentOfType(u);if(c!==null){o=c;break}}if(n.mainComponentOnly){const u=i.motionController.getMainComponent();if(u===null)continue;o=u}if(typeof n.componentSelectionPredicate=="function"&&(o=n.componentSelectionPredicate(i)),o&&n.forceHandedness&&i.inputSource.handedness!==n.forceHandedness||o===null)continue;const l={registrationConfiguration:n,component:o};r.registeredComponents.push(l),"axisChangedHandler"in n&&(l.onAxisChangedObserver=o.onAxisValueChangedObservable.add(u=>{n.axisChangedHandler(u,this._movementState,this._featureContext,this._xrInput)})),"buttonChangedHandler"in n&&(l.onButtonChangedObserver=o.onButtonStateChangedObservable.add(u=>{u.changes.pressed&&n.buttonChangedHandler(u.changes.pressed,this._movementState,this._featureContext,this._xrInput)}))}};i.motionController?s():i.onMotionControllerInitObservable.addOnce(()=>{s()})}},!t||t.xrInput===void 0){ae.Error('WebXRControllerMovement feature requires "xrInput" option.');return}Array.isArray(t.customRegistrationConfigurations)?this._currentRegistrationConfigurations=t.customRegistrationConfigurations:this._currentRegistrationConfigurations=dn.REGISTRATIONS.default,this._featureContext={movementEnabled:t.movementEnabled||!0,movementOrientationFollowsViewerPose:t.movementOrientationFollowsViewerPose??!0,movementOrientationFollowsController:t.movementOrientationFollowsController??!1,orientationPreferredHandedness:t.orientationPreferredHandedness,movementSpeed:t.movementSpeed??1,movementThreshold:t.movementThreshold??.25,rotationEnabled:t.rotationEnabled??!0,rotationSpeed:t.rotationSpeed??1,rotationThreshold:t.rotationThreshold??.25},this._movementState={moveX:0,moveY:0,rotateX:0,rotateY:0},this._xrInput=t.xrInput}attach(){return super.attach()?(this._xrInput.controllers.forEach(this._attachController),this._addNewAttachObserver(this._xrInput.onControllerAddedObservable,this._attachController),this._addNewAttachObserver(this._xrInput.onControllerRemovedObservable,e=>{this._detachController(e.uniqueId)}),!0):!1}detach(){return super.detach()?(Object.keys(this._controllers).forEach(e=>{this._detachController(e)}),this._controllers={},!0):!1}_onXRFrame(e){if(this.attached){if(this._movementState.rotateX!==0&&this._featureContext.rotationEnabled){const i=this._xrSessionManager.scene.getEngine().getDeltaTime()*.001*this._featureContext.rotationSpeed*this._movementState.rotateX*(this._xrSessionManager.scene.useRightHandedSystem?-1:1);if(this._featureContext.movementOrientationFollowsViewerPose)this._xrInput.xrCamera.cameraRotation.y+=i,re.RotationYawPitchRollToRef(i,0,0,this._tempCacheQuaternion),this._xrInput.xrCamera.rotationQuaternion.multiplyToRef(this._tempCacheQuaternion,this._movementDirection);else if(this._featureContext.movementOrientationFollowsController){this._xrInput.xrCamera.cameraRotation.y+=i;const r=this._featureContext.orientationPreferredHandedness||"right",s=Object.keys(this._controllers).find(o=>{var l,u;return((u=(l=this._controllers[o])==null?void 0:l.xrController)==null?void 0:u.inputSource.handedness)===r})||Object.keys(this._controllers)[0],n=this._controllers[s];re.RotationYawPitchRollToRef(i,0,0,this._tempCacheQuaternion),((n==null?void 0:n.xrController.pointer.rotationQuaternion)||re.Identity()).multiplyToRef(this._tempCacheQuaternion,this._movementDirection)}else re.RotationYawPitchRollToRef(i*3,0,0,this._tempCacheQuaternion),this._movementDirection.multiplyInPlace(this._tempCacheQuaternion)}else if(this._featureContext.movementOrientationFollowsViewerPose)this._movementDirection.copyFrom(this._xrInput.xrCamera.rotationQuaternion);else if(this._featureContext.movementOrientationFollowsController){const t=this._featureContext.orientationPreferredHandedness||"right",i=Object.keys(this._controllers).find(s=>{var n;return((n=this._controllers[s])==null?void 0:n.xrController.inputSource.handedness)===t})||Object.keys(this._controllers)[0],r=this._controllers[i];this._movementDirection.copyFrom((r==null?void 0:r.xrController.pointer.rotationQuaternion)||re.Identity())}(this._movementState.moveX||this._movementState.moveY)&&this._featureContext.movementEnabled&&($.FromQuaternionToRef(this._movementDirection,this._tmpRotationMatrix),this._tmpTranslationDirection.set(this._movementState.moveX,0,this._movementState.moveY*(this._xrSessionManager.scene.useRightHandedSystem?1:-1)),m.TransformCoordinatesToRef(this._tmpTranslationDirection,this._tmpRotationMatrix,this._tmpMovementTranslation),this._tmpMovementTranslation.scaleInPlace(this._xrInput.xrCamera._computeLocalCameraSpeed()*this._featureContext.movementSpeed),this._xrInput.xrCamera.cameraDirection.addInPlace(this._tmpMovementTranslation))}}_detachController(e){const t=this._controllers[e];if(t){for(const i of t.registeredComponents)i.onAxisChangedObserver&&i.component.onAxisValueChangedObservable.remove(i.onAxisChangedObserver),i.onButtonChangedObserver&&i.component.onButtonStateChangedObservable.remove(i.onButtonChangedObserver);delete this._controllers[e]}}}dn.Name=ke.MOVEMENT;dn.REGISTRATIONS={default:[{allowedComponentTypes:[Ji.THUMBSTICK_TYPE,Ji.TOUCHPAD_TYPE],forceHandedness:"left",axisChangedHandler:(a,e,t)=>{e.rotateX=Math.abs(a.x)>t.rotationThreshold?a.x:0,e.rotateY=Math.abs(a.y)>t.rotationThreshold?a.y:0}},{allowedComponentTypes:[Ji.THUMBSTICK_TYPE,Ji.TOUCHPAD_TYPE],forceHandedness:"right",axisChangedHandler:(a,e,t)=>{e.moveX=Math.abs(a.x)>t.movementThreshold?a.x:0,e.moveY=Math.abs(a.y)>t.movementThreshold?a.y:0}}]};dn.Version=1;Tt.AddWebXRFeature(dn.Name,(a,e)=>()=>new dn(a,e),dn.Version,!0);class Do extends ti{constructor(e,t){super(e),this.options=t,this._canvasContext=null,this._reflectionCubeMap=null,this._xrLightEstimate=null,this._xrLightProbe=null,this._xrWebGLBinding=null,this._lightDirection=m.Up().negateInPlace(),this._lightColor=ne.White(),this._intensity=1,this._sphericalHarmonics=new WM,this._cubeMapPollTime=Date.now(),this._lightEstimationPollTime=Date.now(),this._reflectionCubeMapTextureSize=16,this.directionalLight=null,this.onReflectionCubeMapUpdatedObservable=new j,this._updateReflectionCubeMap=()=>{var r;if(!this._xrLightProbe)return;if(this.options.cubeMapPollInterval){const s=Date.now();if(s-this._cubeMapPollTime<this.options.cubeMapPollInterval)return;this._cubeMapPollTime=s}const i=this._getXRGLBinding().getReflectionCubeMap(this._xrLightProbe);if(i&&this._reflectionCubeMap){if(this._reflectionCubeMap._texture)(r=this._reflectionCubeMap._texture._hardwareTexture)==null||r.set(i),this._reflectionCubeMap._texture.getEngine().resetTextureCache();else{const s=new Dt(this._xrSessionManager.scene.getEngine(),0);s.isCube=!0,s.invertY=!1,s._useSRGBBuffer=this.options.reflectionFormat==="srgba8",s.format=5,s.generateMipMaps=!0,s.type=this.options.reflectionFormat!=="srgba8"?2:0,s.samplingMode=3,s.width=this._reflectionCubeMapTextureSize,s.height=this._reflectionCubeMapTextureSize,s._cachedWrapU=1,s._cachedWrapV=1,s._hardwareTexture=new hu(i,this._getCanvasContext()),this._reflectionCubeMap._texture=s}this._reflectionCubeMap._texture.isReady=!0,this.options.disablePreFiltering?(this._xrSessionManager.scene.markAllMaterialsAsDirty(1),this.onReflectionCubeMapUpdatedObservable.notifyObservers(this._reflectionCubeMap)):(this._xrLightProbe.removeEventListener("reflectionchange",this._updateReflectionCubeMap),this._hdrFilter.prefilter(this._reflectionCubeMap).then(()=>{this._xrSessionManager.scene.markAllMaterialsAsDirty(1),this.onReflectionCubeMapUpdatedObservable.notifyObservers(this._reflectionCubeMap),this._xrLightProbe.addEventListener("reflectionchange",this._updateReflectionCubeMap)}))}},this.xrNativeFeatureName="light-estimation",this.options.createDirectionalLightSource&&(this.directionalLight=new Bm("light estimation directional",this._lightDirection,this._xrSessionManager.scene),this.directionalLight.position=new m(0,8,0),this.directionalLight.intensity=0,this.directionalLight.falloffType=$M.FALLOFF_GLTF),this._hdrFilter=new AT(this._xrSessionManager.scene.getEngine()),ae.Warn("light-estimation is an experimental and unstable feature.")}get reflectionCubeMapTexture(){return this._reflectionCubeMap}get xrLightingEstimate(){return this._xrLightEstimate?{lightColor:this._lightColor,lightDirection:this._lightDirection,lightIntensity:this._intensity,sphericalHarmonics:this._sphericalHarmonics}:this._xrLightEstimate}_getCanvasContext(){return this._canvasContext===null&&(this._canvasContext=this._xrSessionManager.scene.getEngine()._gl),this._canvasContext}_getXRGLBinding(){if(this._xrWebGLBinding===null){const e=this._getCanvasContext();this._xrWebGLBinding=new XRWebGLBinding(this._xrSessionManager.session,e)}return this._xrWebGLBinding}attach(){if(!super.attach())return!1;const e=this.options.reflectionFormat??(this._xrSessionManager.session.preferredReflectionFormat||"srgba8");return this.options.reflectionFormat=e,this._xrSessionManager.session.requestLightProbe({reflectionFormat:e}).then(t=>{this._xrLightProbe=t,this.options.disableCubeMapReflection||(this._reflectionCubeMap||(this._reflectionCubeMap=new Vr(this._xrSessionManager.scene),this._reflectionCubeMap._isCube=!0,this._reflectionCubeMap.coordinatesMode=3,this.options.setSceneEnvironmentTexture&&(this._xrSessionManager.scene.environmentTexture=this._reflectionCubeMap)),this._xrLightProbe.addEventListener("reflectionchange",this._updateReflectionCubeMap))}),!0}detach(){const e=super.detach();return this._xrLightProbe!==null&&!this.options.disableCubeMapReflection&&(this._xrLightProbe.removeEventListener("reflectionchange",this._updateReflectionCubeMap),this._xrLightProbe=null),this._canvasContext=null,this._xrLightEstimate=null,this._xrWebGLBinding=null,e}dispose(){super.dispose(),this.onReflectionCubeMapUpdatedObservable.clear(),this.directionalLight&&(this.directionalLight.dispose(),this.directionalLight=null),this._reflectionCubeMap!==null&&(this._reflectionCubeMap._texture&&this._reflectionCubeMap._texture.dispose(),this._reflectionCubeMap.dispose(),this._reflectionCubeMap=null)}_onXRFrame(e){var t;if(this._xrLightProbe!==null){if(this.options.lightEstimationPollInterval){const i=Date.now();if(i-this._lightEstimationPollTime<this.options.lightEstimationPollInterval)return;this._lightEstimationPollTime=i}if(this._xrLightEstimate=e.getLightEstimate(this._xrLightProbe),this._xrLightEstimate){this._intensity=Math.max(1,this._xrLightEstimate.primaryLightIntensity.x,this._xrLightEstimate.primaryLightIntensity.y,this._xrLightEstimate.primaryLightIntensity.z);const i=this._xrSessionManager.scene.useRightHandedSystem?1:-1;this.options.disableVectorReuse&&(this._lightDirection=new m,this._lightColor=new ne,this.directionalLight&&(this.directionalLight.direction=this._lightDirection,this.directionalLight.diffuse=this._lightColor)),this._lightDirection.copyFromFloats(this._xrLightEstimate.primaryLightDirection.x,this._xrLightEstimate.primaryLightDirection.y,this._xrLightEstimate.primaryLightDirection.z*i),this._lightColor.copyFromFloats(this._xrLightEstimate.primaryLightIntensity.x/this._intensity,this._xrLightEstimate.primaryLightIntensity.y/this._intensity,this._xrLightEstimate.primaryLightIntensity.z/this._intensity),this._sphericalHarmonics.updateFromFloatsArray(this._xrLightEstimate.sphericalHarmonicsCoefficients),this._reflectionCubeMap&&!this.options.disableSphericalPolynomial&&(this._reflectionCubeMap.sphericalPolynomial=this._reflectionCubeMap.sphericalPolynomial||new ny,(t=this._reflectionCubeMap.sphericalPolynomial)==null||t.updateFromHarmonics(this._sphericalHarmonics)),this._lightDirection.negateInPlace(),this.directionalLight&&(this.directionalLight.direction.copyFrom(this._lightDirection),this.directionalLight.intensity=Math.min(this._intensity,1),this.directionalLight.diffuse.copyFrom(this._lightColor))}}}}Do.Name=ke.LIGHT_ESTIMATION;Do.Version=1;Tt.AddWebXRFeature(Do.Name,(a,e)=>()=>new Do(a,e),Do.Version,!1);class Oo extends ti{constructor(e){super(e),this.onEyeTrackingStartedObservable=new j,this.onEyeTrackingEndedObservable=new j,this.onEyeTrackingFrameUpdateObservable=new j,this._eyeTrackingStartListener=t=>{this._latestEyeSpace=t.gazeSpace,this._gazeRay=new Zt(m.Zero(),m.Forward()),this.onEyeTrackingStartedObservable.notifyObservers(this._gazeRay)},this._eyeTrackingEndListener=()=>{this._latestEyeSpace=null,this._gazeRay=null,this.onEyeTrackingEndedObservable.notifyObservers()},this.xrNativeFeatureName="eye-tracking",this._xrSessionManager.session?this._init():this._xrSessionManager.onXRSessionInit.addOnce(()=>{this._init()})}dispose(){super.dispose(),this._xrSessionManager.session.removeEventListener("eyetrackingstart",this._eyeTrackingStartListener),this._xrSessionManager.session.removeEventListener("eyetrackingend",this._eyeTrackingEndListener),this.onEyeTrackingStartedObservable.clear(),this.onEyeTrackingEndedObservable.clear(),this.onEyeTrackingFrameUpdateObservable.clear()}get isEyeGazeValid(){return!!this._gazeRay}getEyeGaze(){return this._gazeRay}_onXRFrame(e){if(!(!this.attached||!e)&&this._latestEyeSpace&&this._gazeRay){const t=e.getPose(this._latestEyeSpace,this._xrSessionManager.referenceSpace);if(t){this._gazeRay.origin.set(t.transform.position.x,t.transform.position.y,t.transform.position.z).scaleInPlace(this._xrSessionManager.worldScalingFactor);const i=t.transform.orientation;V.Quaternion[0].set(i.x,i.y,i.z,i.w),this._xrSessionManager.scene.useRightHandedSystem?m.RightHandedForwardReadOnly.rotateByQuaternionToRef(V.Quaternion[0],this._gazeRay.direction):(this._gazeRay.origin.z*=-1,V.Quaternion[0].z*=-1,V.Quaternion[0].w*=-1,m.LeftHandedForwardReadOnly.rotateByQuaternionToRef(V.Quaternion[0],this._gazeRay.direction)),this.onEyeTrackingFrameUpdateObservable.notifyObservers(this._gazeRay)}}}_init(){this._xrSessionManager.isNative&&(this._xrSessionManager.session.addEventListener("eyetrackingstart",this._eyeTrackingStartListener),this._xrSessionManager.session.addEventListener("eyetrackingend",this._eyeTrackingEndListener))}}Oo.Name=ke.EYE_TRACKING;Oo.Version=1;Tt.AddWebXRFeature(Oo.Name,a=>()=>new Oo(a),Oo.Version,!1);class u4{constructor(e,t){this._samples=[],this._idx=0;for(let i=0;i<e;++i)this._samples.push(t?t():Q.Zero())}get length(){return this._samples.length}push(e,t){this._idx=(this._idx+this._samples.length-1)%this._samples.length,this.at(0).copyFromFloats(e,t)}at(e){if(e>=this._samples.length)throw new Error("Index out of bounds");return this._samples[(this._idx+e)%this._samples.length]}}class c4{constructor(){this._samples=new u4(20),this._entropy=0,this.onFirstStepDetected=new j}update(e,t,i,r){this._samples.push(e,t);const s=this._samples.at(0);if(this._entropy*=this._entropyDecayFactor,this._entropy+=Q.Distance(s,this._samples.at(1)),this._entropy>this._entropyThreshold)return;let n;for(n=this._samePointCheckStartIdx;n<this._samples.length&&!(Q.DistanceSquared(s,this._samples.at(n))<this._samePointSquaredDistanceThreshold);++n);if(n===this._samples.length)return;let o=-1,l=0;for(let T,v=1;v<n;++v)T=Q.DistanceSquared(s,this._samples.at(v)),T>o&&(l=v,o=T);if(o<this._apexSquaredDistanceThreshold)return;const u=this._samples.at(l),c=u.subtract(s);c.normalize();const h=V.Vector2[0];let d,f,p=0;for(let T=1;T<n;++T)f=this._samples.at(T),f.subtractToRef(s,h),d=Q.Dot(c,h),p+=h.lengthSquared()-d*d;if(p>n*this._squaredProjectionDistanceThreshold)return;const g=V.Vector3[0];g.set(i,r,0);const _=V.Vector3[1];_.set(c.x,c.y,0);const S=m.Cross(g,_).z>0,b=s.clone(),y=s.clone();u.subtractToRef(s,c),S?(c.scaleAndAddToRef(this._axisToApexShrinkFactor,b),c.scaleAndAddToRef(this._axisToApexExtendFactor,y)):(c.scaleAndAddToRef(this._axisToApexExtendFactor,b),c.scaleAndAddToRef(this._axisToApexShrinkFactor,y)),this.onFirstStepDetected.notifyObservers({leftApex:b,rightApex:y,currentPosition:s,currentStepDirection:S?"right":"left"})}reset(){for(let e=0;e<this._samples.length;++e)this._samples.at(e).copyFromFloats(0,0)}get _samePointCheckStartIdx(){return Math.floor(this._samples.length/3)}get _samePointSquaredDistanceThreshold(){return .03*.03}get _apexSquaredDistanceThreshold(){return .09*.09}get _squaredProjectionDistanceThreshold(){return .03*.03}get _axisToApexShrinkFactor(){return .8}get _axisToApexExtendFactor(){return-1.6}get _entropyDecayFactor(){return .93}get _entropyThreshold(){return .4}}class h4{constructor(e,t,i,r){this._leftApex=new Q,this._rightApex=new Q,this._currentPosition=new Q,this._axis=new Q,this._axisLength=-1,this._forward=new Q,this._steppingLeft=!1,this._t=-1,this._maxT=-1,this._maxTPosition=new Q,this._vitality=0,this.onMovement=new j,this.onFootfall=new j,this._reset(e,t,i,r==="left")}_reset(e,t,i,r){this._leftApex.copyFrom(e),this._rightApex.copyFrom(t),this._steppingLeft=r,this._steppingLeft?(this._leftApex.subtractToRef(this._rightApex,this._axis),this._forward.copyFromFloats(-this._axis.y,this._axis.x)):(this._rightApex.subtractToRef(this._leftApex,this._axis),this._forward.copyFromFloats(this._axis.y,-this._axis.x)),this._axisLength=this._axis.length(),this._forward.scaleInPlace(1/this._axisLength),this._updateTAndVitality(i.x,i.y),this._maxT=this._t,this._maxTPosition.copyFrom(i),this._vitality=1}_updateTAndVitality(e,t){this._currentPosition.copyFromFloats(e,t),this._steppingLeft?this._currentPosition.subtractInPlace(this._rightApex):this._currentPosition.subtractInPlace(this._leftApex);const i=this._t,r=Q.Dot(this._currentPosition,this._axis);this._t=r/(this._axisLength*this._axisLength);const s=this._currentPosition.lengthSquared()-r/this._axisLength*(r/this._axisLength);this._vitality*=.92-100*Math.max(s-.0016,0)+Math.max(this._t-i,0)}update(e,t){if(this._vitality<this._vitalityThreshold)return!1;const i=this._t;return this._updateTAndVitality(e,t),this._t>this._maxT&&(this._maxT=this._t,this._maxTPosition.copyFromFloats(e,t)),!(this._vitality<this._vitalityThreshold||(this._t>i&&(this.onMovement.notifyObservers({deltaT:this._t-i}),i<.5&&this._t>=.5&&this.onFootfall.notifyObservers({foot:this._steppingLeft?"left":"right"})),this._t<.95*this._maxT&&(this._currentPosition.copyFromFloats(e,t),this._steppingLeft?this._leftApex.copyFrom(this._maxTPosition):this._rightApex.copyFrom(this._maxTPosition),this._reset(this._leftApex,this._rightApex,this._currentPosition,!this._steppingLeft)),this._axisLength<.03))}get _vitalityThreshold(){return .1}get forward(){return this._forward}}class wo{static get _MillisecondsPerUpdate(){return 1e3/15}constructor(e){this._detector=new c4,this._walker=null,this._movement=new Q,this._millisecondsSinceLastUpdate=wo._MillisecondsPerUpdate,this.movementThisFrame=m.Zero(),this._engine=e,this._detector.onFirstStepDetected.add(t=>{this._walker||(this._walker=new h4(t.leftApex,t.rightApex,t.currentPosition,t.currentStepDirection),this._walker.onFootfall.add(()=>{L.Log("Footfall!")}),this._walker.onMovement.add(i=>{this._walker.forward.scaleAndAddToRef(.024*i.deltaT,this._movement)}))})}update(e,t){t.y=0,t.normalize(),this._millisecondsSinceLastUpdate+=this._engine.getDeltaTime(),this._millisecondsSinceLastUpdate>=wo._MillisecondsPerUpdate&&(this._millisecondsSinceLastUpdate-=wo._MillisecondsPerUpdate,this._detector.update(e.x,e.z,t.x,t.z),this._walker&&(this._walker.update(e.x,e.z)||(this._walker=null)),this._movement.scaleInPlace(.85)),this.movementThisFrame.set(this._movement.x,0,this._movement.y)}}class Xc extends ti{static get Name(){return ke.WALKING_LOCOMOTION}static get Version(){return 1}get locomotionTarget(){return this._locomotionTarget}set locomotionTarget(e){this._locomotionTarget=e,this._isLocomotionTargetWebXRCamera=this._locomotionTarget.getClassName()==="WebXRCamera"}constructor(e,t){super(e),this._up=new m,this._forward=new m,this._position=new m,this._movement=new m,this._sessionManager=e,this.locomotionTarget=t.locomotionTarget,this._isLocomotionTargetWebXRCamera&&L.Warn("Using walking locomotion directly on a WebXRCamera may have unintended interactions with other XR techniques. Using an XR space parent is highly recommended")}isCompatible(){return this._sessionManager.sessionMode===void 0||this._sessionManager.sessionMode==="immersive-vr"}attach(){return!this.isCompatible||!super.attach()?!1:(this._walker=new wo(this._sessionManager.scene.getEngine()),!0)}detach(){return super.detach()?(this._walker=null,!0):!1}_onXRFrame(e){const t=e.getViewerPose(this._sessionManager.baseReferenceSpace);if(!t)return;const i=this.locomotionTarget.getScene().useRightHandedSystem?1:-1,r=t.transform.matrix;this._up.copyFromFloats(r[4],r[5],i*r[6]),this._forward.copyFromFloats(r[8],r[9],i*r[10]),this._position.copyFromFloats(r[12],r[13],i*r[14]),this._forward.scaleAndAddToRef(.05,this._position),this._up.scaleAndAddToRef(-.05,this._position),this._walker.update(this._position,this._forward),this._movement.copyFrom(this._walker.movementThisFrame),this._isLocomotionTargetWebXRCamera||m.TransformNormalToRef(this._movement,this.locomotionTarget.getWorldMatrix(),this._movement),this.locomotionTarget.position.addInPlace(this._movement)}}Tt.AddWebXRFeature(Xc.Name,(a,e)=>()=>new Xc(a,e),Xc.Version,!1);class CR extends i_{constructor(e,t,i,r,s,n,o=null){super(e,t,i,r,n),this.getWidth=e,this.getHeight=t,this.layer=i,this.layerType=r,this.isMultiview=s,this.createRTTProvider=n,this._originalInternalTexture=o}}class PR extends r_{constructor(e,t,i){super(e.scene,i),this._xrSessionManager=e,this._xrWebGLBinding=t,this.layerWrapper=i,this._lastSubImages=new Map,this.onRenderTargetTextureCreatedObservable=new j,this._compositionLayer=i.layer}_getRenderTargetForSubImage(e,t="none"){const i=this._lastSubImages.get(t),r=t=="right"?1:0,s=e.colorTextureWidth??e.textureWidth,n=e.colorTextureHeight??e.textureHeight;if(!this._renderTargetTextures[r]||(i==null?void 0:i.textureWidth)!==s||(i==null?void 0:i.textureHeight)!==n){let o;const l=e.depthStencilTextureWidth??s,u=e.depthStencilTextureHeight??n;(s===l||n===u)&&(o=e.depthStencilTexture),this._renderTargetTextures[r]=this._createRenderTargetTexture(s,n,null,e.colorTexture,o,this.layerWrapper.isMultiview),this._framebufferDimensions={framebufferWidth:s,framebufferHeight:n},this.onRenderTargetTextureCreatedObservable.notifyObservers({texture:this._renderTargetTextures[r],eye:t})}return this._lastSubImages.set(t,e),this._renderTargetTextures[r]}_getSubImageForEye(e){const t=this._xrSessionManager.currentFrame;return t?this._xrWebGLBinding.getSubImage(this._compositionLayer,t,e):null}getRenderTargetTextureForEye(e){const t=this._getSubImageForEye(e);return t?this._getRenderTargetForSubImage(t,e):null}getRenderTargetTextureForView(e){return this.getRenderTargetTextureForEye(e==null?void 0:e.eye)}_setViewportForSubImage(e,t){const i=t.colorTextureWidth??t.textureWidth,r=t.colorTextureHeight??t.textureHeight,s=t.viewport;e.x=s.x/i,e.y=s.y/r,e.width=s.width/i,e.height=s.height/r}trySetViewportForView(e,t){const i=this._lastSubImages.get(t.eye)||this._getSubImageForEye(t.eye);return i?(this._setViewportForSubImage(e,i),!0):!1}}class d4 extends CR{constructor(e,t,i){super(()=>e.textureWidth,()=>e.textureHeight,e,"XRProjectionLayer",t,r=>new f4(r,i,this)),this.layer=e}}class f4 extends PR{constructor(e,t,i){super(e,t,i),this.layerWrapper=i,this._projectionLayer=i.layer}_getSubImageForView(e){return this._xrWebGLBinding.getViewSubImage(this._projectionLayer,e)}getRenderTargetTextureForView(e){return this._getRenderTargetForSubImage(this._getSubImageForView(e),e.eye)}getRenderTargetTextureForEye(e){const t=this._lastSubImages.get(e);return t?this._getRenderTargetForSubImage(t,e):null}trySetViewportForView(e,t){const i=this._lastSubImages.get(t.eye)||this._getSubImageForView(t);return i?(this._setViewportForSubImage(e,i),!0):!1}}const Yb={textureType:"texture",colorFormat:6408,depthFormat:35056,scaleFactor:1,clearOnAccess:!1},p4={};class No extends ti{constructor(e,t={}){super(e),this._options=t,this._existingLayers=[],this._isMultiviewEnabled=!1,this._projectionLayerInitialized=!1,this._compositionLayerTextureMapping=new WeakMap,this._layerToRTTProviderMapping=new WeakMap,this.xrNativeFeatureName="layers"}attach(){if(!super.attach())return!1;const e=this._xrSessionManager.scene.getEngine();this._glContext=e._gl,this._xrWebGLBinding=new XRWebGLBinding(this._xrSessionManager.session,this._glContext),this._existingLayers.length=0;const t={...Yb,...this._options.projectionLayerInit};return this._isMultiviewEnabled=this._options.preferMultiviewOnInit&&e.getCaps().multiview,this.createProjectionLayer(t),this._projectionLayerInitialized=!0,!0}detach(){return super.detach()?(this._existingLayers.forEach(e=>{e.dispose()}),this._existingLayers.length=0,this._projectionLayerInitialized=!1,!0):!1}createXRWebGLLayer(e=p4){const t=new XRWebGLLayer(this._xrSessionManager.session,this._glContext,e);return new s_(t)}_validateLayerInit(e,t=this._isMultiviewEnabled){if(!this._xrSessionManager.inXRSession)throw new Error("Cannot create a layer outside of a WebXR session. Make sure the session has started before creating layers.");if(t&&e.textureType!=="texture-array")throw new Error("Projection layers can only be made multiview if they use texture arrays. Set the textureType parameter to 'texture-array'.");if(!t&&e.textureType==="texture-array")throw new Error("We currently only support multiview rendering when the textureType parameter is set to 'texture-array'.")}_extendXRLayerInit(e,t=this._isMultiviewEnabled){return t&&(e.textureType="texture-array"),e}createProjectionLayer(e=Yb,t=this._isMultiviewEnabled){this._extendXRLayerInit(e,t),this._validateLayerInit(e,t);const i=this._xrWebGLBinding.createProjectionLayer(e),r=new d4(i,t,this._xrWebGLBinding);return this.addXRSessionLayer(r),r}_createQuadLayer(e={params:{}},t){this._extendXRLayerInit(e.params,!1);const i=this._existingLayers[0].layer.textureWidth,r=this._existingLayers[0].layer.textureHeight,s={space:this._xrSessionManager.referenceSpace,viewPixelWidth:i,viewPixelHeight:r,clearOnAccess:!0,...e.params};this._validateLayerInit(s,!1);const n=this._xrWebGLBinding.createQuadLayer(s);n.width=this._isMultiviewEnabled?1:2,n.height=1;const o=new CR(()=>n.width,()=>n.height,n,"XRQuadLayer",!1,u=>new PR(u,this._xrWebGLBinding,o));t&&this._compositionLayerTextureMapping.set(n,t);const l=o.createRenderTargetTextureProvider(this._xrSessionManager);return this._layerToRTTProviderMapping.set(n,l),this.addXRSessionLayer(o),o}addFullscreenAdvancedDynamicTexture(e,t={distanceFromHeadset:1.5}){const i=this._createQuadLayer({params:{space:this._xrSessionManager.viewerReferenceSpace,textureType:"texture",layout:"mono"}},e),r=i.layer,n={x:0,y:0,z:-Math.max(.1,t.distanceFromHeadset)},o={x:0,y:0,z:0,w:1};r.transform=new XRRigidTransform(n,o);const l=this._layerToRTTProviderMapping.get(r);if(!l)throw new Error("Could not find the RTT provider for the layer");const u=this._xrSessionManager.scene.layers.find(c=>c.texture===e);if(!u)throw new Error("Could not find the babylon layer for the texture");return l.onRenderTargetTextureCreatedObservable.add(c=>{c.eye&&c.eye==="right"||(c.texture.clearColor=new xe(0,0,0,0),u.renderTargetTextures.push(c.texture),u.renderOnlyInRenderTargetTextures=!0,this._xrSessionManager.scene.onBeforeRenderObservable.add(()=>{c.texture.render()}),u.renderTargetTextures.push(c.texture),u.renderOnlyInRenderTargetTextures=!0,this._xrSessionManager.onXRSessionEnded.addOnce(()=>{u.renderTargetTextures.splice(u.renderTargetTextures.indexOf(c.texture),1),u.renderOnlyInRenderTargetTextures=!1}))}),i}_addLensFlareSystem(e){const t=this._createQuadLayer({params:{space:this._xrSessionManager.viewerReferenceSpace,textureType:"texture",layout:"mono"}}),i=t.layer;i.width=2,i.height=1;const r={x:0,y:0,z:-10},s={x:0,y:0,z:0,w:1};i.transform=new XRRigidTransform(r,s);const n=this._layerToRTTProviderMapping.get(i);if(!n)throw new Error("Could not find the RTT provider for the layer");return n.onRenderTargetTextureCreatedObservable.add(o=>{o.texture.clearColor=new xe(0,0,0,0),o.texture.customRenderFunction=()=>{e.render()}}),this._xrSessionManager.onXRSessionInit.add(()=>{this._xrSessionManager.scene.lensFlareSystems.splice(this._xrSessionManager.scene.lensFlareSystems.indexOf(e),1)}),this._xrSessionManager.onXRSessionEnded.add(()=>{this._xrSessionManager.scene.lensFlareSystems.push(e)}),t}addXRSessionLayer(e){this._existingLayers.push(e),this.setXRSessionLayers(this._existingLayers)}setXRSessionLayers(e=this._existingLayers){const t={...this._xrSessionManager.session.renderState};t.baseLayer=void 0,t.layers=e.map(i=>i.layer),this._xrSessionManager.updateRenderState(t),this._projectionLayerInitialized||this._xrSessionManager._setBaseLayerWrapper(e.length>0?e.at(0):null)}isCompatible(){return!this._xrSessionManager.isNative&&typeof XRWebGLBinding<"u"&&!!XRWebGLBinding.prototype.createProjectionLayer}dispose(){super.dispose()}_onXRFrame(e){const t=this._existingLayers;for(let i=0;i<t.length;++i){const r=t[i];if(r.layerType!=="XRProjectionLayer"){const s=this._layerToRTTProviderMapping.get(r.layer);if(!s)continue;if(s.layerWrapper.isMultiview){const n=e.getViewerPose(this._xrSessionManager.referenceSpace);if(n){const o=n.views;for(let l=0;l<o.length;++l){const u=o[l];s.getRenderTargetTextureForView(u)}}}else s.getRenderTargetTextureForView()}}}}No.Name=ke.LAYERS;No.Version=1;Tt.AddWebXRFeature(No.Name,(a,e)=>()=>new No(a,e),No.Version,!1);class m4 extends ps{constructor(){super(...arguments),this.DEPTH_SENSING=!1,this.DEPTH_SENSING_TEXTURE_ARRAY=!1,this.DEPTH_SENSING_TEXTURE_AL=!1,this.DEPTH_SENSING_DISCARD=!0}}let va=!1,Ts=null,Em=!1;const lu={width:512,height:512},en={x:0,y:0,width:1,height:1};let Im=1,ER=0,IR=!0;const Rm=$.Identity(),Fo=[];class _4 extends Qn{_markAllDefinesAsDirty(){this._enable(this._isEnabled),this.markAllDefinesAsDirty()}get isEnabled(){return this._isEnabled}set isEnabled(e){this._isEnabled!==e&&(this._isEnabled=e,this._markAllDefinesAsDirty())}isCompatible(e){switch(e){case 0:return!0;default:return!0}}constructor(e){super(e,"DepthSensing",222,new m4),this._isEnabled=!1,this._varColorName=e instanceof hr?"finalColor":"color",Fo.push(this)}prepareDefines(e){e.DEPTH_SENSING=!!Ts&&va,e.DEPTH_SENSING_TEXTURE_ARRAY=(Ts==null?void 0:Ts.is2DArray)??!1,e.DEPTH_SENSING_TEXTURE_AL=Em,e.DEPTH_SENSING_DISCARD=IR}getUniforms(){return{ubo:[{name:"ds_invScreenSize",size:2,type:"vec2"},{name:"ds_rawValueToMeters",size:1,type:"float"},{name:"ds_viewIndex",size:1,type:"float"},{name:"ds_shaderViewport",size:4,type:"vec4"},{name:"ds_uvTransform",size:16,type:"mat4"}],fragment:`#ifdef DEPTH_SENSING
                uniform vec2 ds_invScreenSize;
                uniform float ds_rawValueToMeters;
                uniform float ds_viewIndex;
                uniform vec4 ds_shaderViewport;
                uniform mat4 ds_uvTransform;
                #endif
                `}}getSamplers(e){e.push("ds_depthSampler")}bindForSubMesh(e){va&&Ts&&(e.updateFloat2("ds_invScreenSize",1/lu.width,1/lu.height),e.updateFloat("ds_rawValueToMeters",Im),e.updateFloat("ds_viewIndex",ER),e.updateFloat4("ds_shaderViewport",en.x,en.y,en.width,en.height),e.setTexture("ds_depthSampler",Ts),e.updateMatrix("ds_uvTransform",Rm))}getClassName(){return"DepthSensingMaterialPlugin"}getCustomCode(e){return e==="vertex"?{CUSTOM_VERTEX_MAIN_BEGIN:`
                #ifdef DEPTH_SENSING
                #ifdef MULTIVIEW
                    ds_viewIndexMultiview = float(gl_ViewID_OVR);
                #endif
                #endif
                `,CUSTOM_VERTEX_DEFINITIONS:`
                #ifdef DEPTH_SENSING
                #ifdef MULTIVIEW
                    varying float ds_viewIndexMultiview;
                #endif
                #endif
                `}:{CUSTOM_FRAGMENT_DEFINITIONS:`
                    #ifdef DEPTH_SENSING
                        #ifdef DEPTH_SENSING_TEXTURE_ARRAY
                            uniform highp sampler2DArray ds_depthSampler;
                        #else
                            uniform sampler2D ds_depthSampler;
                        #endif
                        #ifdef MULTIVIEW
                            varying float ds_viewIndexMultiview;
                        #endif
                    #endif
                  `,CUSTOM_FRAGMENT_MAIN_BEGIN:`
#ifdef DEPTH_SENSING
    #ifdef MULTIVIEW
        float ds_viewIndexSet = ds_viewIndexMultiview;
        vec2 ds_compensation = vec2(0.0, 0.0);
    #else
        float ds_viewIndexSet = ds_viewIndex;
        vec2 ds_compensation = vec2(ds_viewIndexSet, 0.0);
    #endif
    vec2 ds_baseUv = gl_FragCoord.xy * ds_invScreenSize;
    #ifdef DEPTH_SENSING_TEXTURE_ARRAY
        vec2 ds_uv = ds_baseUv - ds_compensation;
        vec3 ds_depthUv = vec3((ds_uvTransform * vec4(ds_uv, 0.0, 1.0)).xy, ds_viewIndexSet);
    #else
        vec2 ds_depthUv = (ds_uvTransform * vec4(ds_baseUv.x, 1.0 - ds_baseUv.y, 0.0, 1.0)).xy;
    #endif
    #ifdef DEPTH_SENSING_TEXTURE_AL
        // from alpha-luminance - taken from the explainer
        vec2 ds_alphaLuminance = texture(ds_depthSampler, ds_depthUv).ra;
        float ds_cameraDepth = dot(ds_alphaLuminance, vec2(255.0, 256.0 * 255.0));
    #else
        float ds_cameraDepth = texture(ds_depthSampler, ds_depthUv).r;
    #endif

    ds_cameraDepth = ds_cameraDepth * ds_rawValueToMeters;

    float ds_assetDepth = gl_FragCoord.z;
    #ifdef DEPTH_SENSING_DISCARD
    if(ds_cameraDepth < ds_assetDepth) {
        discard;
    }
    #endif
#endif  
                  `,CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:`
#ifdef DEPTH_SENSING
    #ifndef DEPTH_SENSING_DISCARD
        const float ds_depthTolerancePerM = 0.005;
        float ds_occlusion = clamp(1.0 - 0.5 * (ds_cameraDepth - ds_assetDepth) / (ds_depthTolerancePerM * ds_assetDepth) +
            0.5, 0.0, 1.0);
        ${this._varColorName} *= (1.0 - ds_occlusion);
    #endif
#endif                  
                  `}}dispose(e){const t=Fo.indexOf(this);t!==-1&&Fo.splice(t,1),super.dispose(e)}}class Lo extends ti{get width(){return this._width}get height(){return this._height}get rawValueToMeters(){return this._rawValueToMeters}get normDepthBufferFromNormView(){return this._normDepthBufferFromNormView}get depthUsage(){switch(this._xrSessionManager.session.depthUsage){case"cpu-optimized":return"cpu";case"gpu-optimized":return"gpu"}}get depthDataFormat(){switch(this._xrSessionManager.session.depthDataFormat){case"luminance-alpha":return"ushort";case"float32":return"float";case"unsigned-short":return"ushort"}}get latestInternalTexture(){return this._cachedWebGLTexture?this._getInternalTextureFromDepthInfo():null}get latestDepthBuffer(){return this._cachedDepthBuffer?this.depthDataFormat==="float"?new Float32Array(this._cachedDepthBuffer):new Uint16Array(this._cachedDepthBuffer):null}get latestDepthImageTexture(){return this._cachedDepthImageTexture}constructor(e,t){super(e),this.options=t,this._width=null,this._height=null,this._rawValueToMeters=null,this._textureType=null,this._normDepthBufferFromNormView=null,this._cachedDepthBuffer=null,this._cachedWebGLTexture=null,this._cachedDepthImageTexture=null,this._onCameraObserver=null,this.onGetDepthInMetersAvailable=new j,this.xrNativeFeatureName="depth-sensing",ae.Warn("depth-sensing is an experimental and unstable feature."),IR=!t.useToleranceFactorForDepthSensing}attach(e){return!super.attach(e)||this._xrSessionManager.session.depthDataFormat==null||this._xrSessionManager.session.depthUsage==null?!1:(this._glBinding=new XRWebGLBinding(this._xrSessionManager.session,this._xrSessionManager.scene.getEngine()._gl),va=!this.options.disableDepthSensingOnMaterials,va&&(Fo.forEach(i=>{i.isEnabled=!0}),this._onCameraObserver=this._xrSessionManager.scene.onBeforeCameraRenderObservable.add(i=>{if(va&&i.outputRenderTarget){const r=i.rigCameras.length>0?i.rigCameras[0].viewport:i.viewport;lu.width=i.outputRenderTarget.getRenderWidth()/(i.rigParent&&i.rigParent.rigCameras.length||1),lu.height=i.outputRenderTarget.getRenderHeight(),en.x=r.x,en.y=r.y,en.width=r.width,en.height=r.height,i.rigParent&&(ER=i.isLeftCamera?0:1)}})),!0)}detach(){return va=!1,Ts=null,this._cachedWebGLTexture=null,this._cachedDepthBuffer=null,Fo.forEach(e=>{e.isEnabled=!1}),this._onCameraObserver&&this._xrSessionManager.scene.onBeforeCameraRenderObservable.remove(this._onCameraObserver),super.detach()}dispose(){var e;(e=this._cachedDepthImageTexture)==null||e.dispose(),this.onGetDepthInMetersAvailable.clear(),this._onCameraObserver&&this._xrSessionManager.scene.onBeforeCameraRenderObservable.remove(this._onCameraObserver)}_onXRFrame(e){const t=this._xrSessionManager.referenceSpace,i=e.getViewerPose(t);if(i!=null)for(const r of i.views)switch(this.depthUsage){case"cpu":this._updateDepthInformationAndTextureCPUDepthUsage(e,r,this.depthDataFormat);break;case"gpu":if(!this._glBinding)break;this._updateDepthInformationAndTextureWebGLDepthUsage(this._glBinding,r,this.depthDataFormat);break;default:ae.Error("Unknown depth usage"),this.detach();break}}_updateDepthInformationAndTextureCPUDepthUsage(e,t,i){const r=e.getDepthInformation(t);if(r===null)return;const{data:s,width:n,height:o,rawValueToMeters:l,getDepthInMeters:u,normDepthBufferFromNormView:c}=r;this._width=n,this._height=o,this._rawValueToMeters=l,this._cachedDepthBuffer=s,Im=l,Em=i==="luminance-alpha",Rm.fromArray(c.matrix),this.onGetDepthInMetersAvailable.notifyObservers(u.bind(r)),this._cachedDepthImageTexture||(this._cachedDepthImageTexture=qt.CreateRTexture(null,n,o,this._xrSessionManager.scene,!1,!1,Y.NEAREST_SAMPLINGMODE,1),Ts=this._cachedDepthImageTexture);let h=null;switch(i){case"ushort":case"luminance-alpha":h=Float32Array.from(new Uint16Array(s));break;case"float":h=new Float32Array(s);break}h&&(this.options.prepareTextureForVisualization&&(h=h.map(d=>d*l)),this._cachedDepthImageTexture.update(h))}_updateDepthInformationAndTextureWebGLDepthUsage(e,t,i){const r=e.getDepthInformation(t);if(r===null)return;const{texture:s,width:n,height:o,textureType:l,rawValueToMeters:u,normDepthBufferFromNormView:c}=r;if(Im=u,Em=i==="luminance-alpha",Rm.fromArray(c.matrix),this._cachedWebGLTexture)return;this._width=n,this._height=o,this._cachedWebGLTexture=s,this._textureType=l;const h=this._xrSessionManager.scene,d=this._getInternalTextureFromDepthInfo();this._cachedDepthImageTexture||(this._cachedDepthImageTexture=qt.CreateRTexture(null,n,o,h,!1,!0,Y.NEAREST_SAMPLINGMODE,i==="float"?1:0)),this._cachedDepthImageTexture._texture=d,Ts=this._cachedDepthImageTexture,this._xrSessionManager.scene.markAllMaterialsAsDirty(1)}getXRSessionInitExtension(){const e=this.options.usagePreference!=null&&this.options.usagePreference.length!==0,t=this.options.dataFormatPreference!=null&&this.options.dataFormatPreference.length!==0;return new Promise(i=>{if(e&&t){const r=this.options.usagePreference.map(n=>{switch(n){case"cpu":return"cpu-optimized";case"gpu":return"gpu-optimized"}}),s=this.options.dataFormatPreference.map(n=>{switch(n){case"luminance-alpha":return"luminance-alpha";case"float":return"float32";case"ushort":return"unsigned-short"}});i({depthSensing:{usagePreference:r,dataFormatPreference:s}})}else i({})})}_getInternalTextureFromDepthInfo(){const e=this._xrSessionManager.scene.getEngine(),t=this.depthDataFormat,i=this._textureType;if(!this._width||!this._height||!this._cachedWebGLTexture)throw new Error("Depth information is not available");const r=e.wrapWebGLTexture(this._cachedWebGLTexture,!1,1,this._width||256,this._height||256);return r.isCube=!1,r.invertY=!1,r._useSRGBBuffer=!1,r.format=t==="luminance-alpha"?2:5,r.generateMipMaps=!1,r.type=t==="float"?1:t==="ushort"?5:0,r._cachedWrapU=1,r._cachedWrapV=1,r._hardwareTexture=new hu(this._cachedWebGLTexture,e._gl),r.is2DArray=i==="texture-array",r}}Lo.Name=ke.DEPTH_SENSING;Lo.Version=1;Tt.AddWebXRFeature(Lo.Name,(a,e)=>()=>new Lo(a,e),Lo.Version,!1);HM("WebXRDepthSensingMaterialPlugin",a=>new _4(a));const Xb="velocityPixelShader",g4=`precision highp float;
#define CUSTOM_FRAGMENT_BEGIN
varying vec4 clipPos;varying vec4 previousClipPos;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
highp vec4 motionVector=( clipPos/clipPos.w-previousClipPos/previousClipPos.w );gl_FragColor=motionVector;
#define CUSTOM_FRAGMENT_MAIN_END
}`;P.ShadersStore[Xb]||(P.ShadersStore[Xb]=g4);const Zb="velocityVertexShader",x4=`#define CUSTOM_VERTEX_BEGIN
#define VELOCITY
attribute vec3 position;
#include<instancesDeclaration>
uniform mat4 viewProjection;uniform mat4 previousViewProjection;
#ifdef MULTIVIEW
uniform mat4 viewProjectionR;uniform mat4 previousViewProjectionR;
#endif
varying vec4 clipPos;varying vec4 previousClipPos;
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec3 positionUpdated=position;
#include<instancesVertex>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);vec4 previousWorldPos=finalPreviousWorld*vec4(positionUpdated,1.0);
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {clipPos=viewProjection*worldPos;previousClipPos=previousViewProjection*previousWorldPos;gl_Position=clipPos;} else {clipPos=viewProjectionR*worldPos;previousClipPos=previousViewProjectionR*previousWorldPos;gl_Position=clipPos;}
#elif
clipPos=viewProjection*worldPos;previousClipPos=previousViewProjection*previousWorldPos;gl_Position=clipPos;
#endif
#define CUSTOM_VERTEX_MAIN_END
}`;P.ShadersStore[Zb]||(P.ShadersStore[Zb]=x4);class S4 extends Kt{constructor(e,t,i,r=512){super("spacewarp rtt",r,i,!1,!0,2,!1,void 0,!1,!1,!0,void 0,!0),this._originalPairing=[],this._previousWorldMatrices=[],this._previousTransforms=[$.Identity(),$.Identity()],this._renderTarget=this.getScene().getEngine().createMultiviewRenderTargetTexture(this.getRenderWidth(),this.getRenderHeight(),e,t),this._renderTarget._disposeOnlyFramebuffers=!0,this._texture=this._renderTarget.texture,this._texture.isMultiview=!0,this._texture.format=5,i&&(this._velocityMaterial=new Wr("velocity shader material",i,{vertex:"velocity",fragment:"velocity"},{uniforms:["world","previousWorld","viewProjection","viewProjectionR","previousViewProjection","previousViewProjectionR"]}),this._velocityMaterial._materialHelperNeedsPreviousMatrices=!0,this._velocityMaterial.onBindObservable.add(s=>{this._previousWorldMatrices[s.uniqueId]=this._previousWorldMatrices[s.uniqueId]||s.getWorldMatrix(),this._velocityMaterial.getEffect().setMatrix("previousWorld",this._previousWorldMatrices[s.uniqueId]),this._previousWorldMatrices[s.uniqueId]=s.getWorldMatrix(),this._velocityMaterial.getEffect().setMatrix("previousViewProjection",this._previousTransforms[0]),this._velocityMaterial.getEffect().setMatrix("previousViewProjectionR",this._previousTransforms[1]),this._previousTransforms[0].copyFrom(i.getTransformMatrix()),this._previousTransforms[1].copyFrom(i._transformMatrixR)}),this._velocityMaterial.freeze())}render(e=!1,t=!1){this._originalPairing.length=0;const i=this.getScene();i&&this._velocityMaterial&&i.getActiveMeshes().forEach(r=>{this._originalPairing.push([r,r.material]),r.material=this._velocityMaterial}),super.render(e,t),this._originalPairing.forEach(r=>{r[0].material=r[1]})}_bindFrameBuffer(){this._renderTarget&&this.getScene().getEngine().bindSpaceWarpFramebuffer(this._renderTarget)}getViewCount(){return 2}dispose(){super.dispose(),this._velocityMaterial.dispose(),this._previousTransforms.length=0,this._previousWorldMatrices.length=0,this._originalPairing.length=0}}class v4{constructor(e,t,i){this._scene=e,this._xrSessionManager=t,this._xrWebGLBinding=i,this._lastSubImages=new Map,this._renderTargetTextures=new Map,this._engine=e.getEngine()}_getSubImageForView(e){const t=this._xrSessionManager._getBaseLayerWrapper();if(!t)throw new Error("For Space Warp, the base layer should be a WebXR Projection Layer.");if(t.layerType!=="XRProjectionLayer")throw new Error('For Space Warp, the base layer type should "XRProjectionLayer".');const i=t.layer;return this._xrWebGLBinding.getViewSubImage(i,e)}_setViewportForSubImage(e,t){e.x=0,e.y=0,e.width=t.motionVectorTextureWidth,e.height=t.motionVectorTextureHeight}_createRenderTargetTexture(e,t,i,r,s){if(!this._engine)throw new Error("Engine is disposed");const n={width:e,height:t},o=new S4(r,s,this._scene,n),l=o.renderTarget;return i&&(l._framebuffer=i),l._colorTextureArray=r,l._depthStencilTextureArray=s,o.disableRescaling(),o.renderListPredicate=()=>!0,o}_getRenderTargetForSubImage(e,t){const i=this._lastSubImages.get(t);let r=this._renderTargetTextures.get(t.eye);const s=e.motionVectorTextureWidth,n=e.motionVectorTextureHeight;return(!r||(i==null?void 0:i.textureWidth)!==s||(i==null?void 0:i.textureHeight)!=n)&&(r=this._createRenderTargetTexture(s,n,null,e.motionVectorTexture,e.depthStencilTexture),this._renderTargetTextures.set(t.eye,r),this._framebufferDimensions={framebufferWidth:s,framebufferHeight:n}),this._lastSubImages.set(t,e),r}trySetViewportForView(e,t){const i=this._lastSubImages.get(t)||this._getSubImageForView(t);return i?(this._setViewportForSubImage(e,i),!0):!1}accessMotionVector(e){const t=this._getSubImageForView(e);t&&(t.motionVectorTexture,t.depthStencilTexture)}getRenderTargetTextureForEye(e){return null}getRenderTargetTextureForView(e){const t=this._getSubImageForView(e);return t?this._getRenderTargetForSubImage(t,e):null}dispose(){this._renderTargetTextures.forEach(e=>e.dispose()),this._renderTargetTextures.clear()}}class Bo extends ti{constructor(e){super(e),this._onAfterRenderObserver=null,this.dependsOn=[ke.LAYERS],this.xrNativeFeatureName="space-warp",this._xrSessionManager.scene.needsPreviousWorldMatrices=!0}attach(){if(!super.attach())return!1;const e=this._xrSessionManager.scene.getEngine();return this._glContext=e._gl,this._xrWebGLBinding=new XRWebGLBinding(this._xrSessionManager.session,this._glContext),this.spaceWarpRTTProvider=new v4(this._xrSessionManager.scene,this._xrSessionManager,this._xrWebGLBinding),this._onAfterRenderObserver=this._xrSessionManager.scene.onAfterRenderObservable.add(()=>this._onAfterRender()),!0}detach(){return this._xrSessionManager.scene.onAfterRenderObservable.remove(this._onAfterRenderObserver),super.detach()}_onAfterRender(){this.attached&&this._renderTargetTexture&&this._renderTargetTexture.render(!1,!1)}isCompatible(){return this._xrSessionManager.scene.getEngine().getCaps().colorBufferHalfFloat||!1}dispose(){super.dispose()}_onXRFrame(e){const t=e.getViewerPose(this._xrSessionManager.referenceSpace);if(!t)return;const i=t.views[0];this._renderTargetTexture=this._renderTargetTexture||this.spaceWarpRTTProvider.getRenderTargetTextureForView(i),this.spaceWarpRTTProvider.accessMotionVector(i)}}Bo.Name=ke.SPACE_WARP;Bo.Version=1;Tt.AddWebXRFeature(Bo.Name,a=>()=>new Bo(a),Bo.Version,!1);class Vo extends ti{constructor(e,t={}){super(e),this.options=t,this._cachedInternalTextures=[],this.texturesData=[],this.viewIndex=[],this.cameraIntrinsics=[],this.onTexturesUpdatedObservable=new j,this.xrNativeFeatureName="camera-access"}attach(e){return super.attach(e)?(this._glContext=this._xrSessionManager.scene.getEngine()._gl,this._glBinding=new XRWebGLBinding(this._xrSessionManager.session,this._glContext),!0):!1}detach(){return super.detach()?(this._glBinding=void 0,this.options.doNotDisposeOnDetach||(this._cachedInternalTextures.forEach(e=>e.dispose()),this.texturesData.forEach(e=>e.dispose()),this._cachedInternalTextures.length=0,this.texturesData.length=0,this.cameraIntrinsics.length=0),!0):!1}dispose(){super.dispose(),this.onTexturesUpdatedObservable.clear()}_updateCameraIntrinsics(e,t){const i={width:e.camera.width,height:e.camera.height,x:0,y:0},r=e.projectionMatrix,s=(1-r[8])*i.width/2+i.x,n=(1-r[9])*i.height/2+i.y,o=i.width/2*r[0],l=i.height/2*r[5],u=i.width/2*r[4];this.cameraIntrinsics[t]={u0:s,v0:n,ax:o,ay:l,gamma:u,width:i.width,height:i.height,viewportX:i.x,viewportY:i.y}}_updateInternalTextures(e,t=0){var r,s;if(!e.camera)return!1;this.viewIndex[t]=e.eye;const i=(r=this._glBinding)==null?void 0:r.getCameraImage(e.camera);if(this._cachedInternalTextures[t])(s=this._cachedInternalTextures[t]._hardwareTexture)==null||s.set(i);else{const n=new Dt(this._xrSessionManager.scene.getEngine(),0,!0);n.invertY=!1,n.format=5,n.generateMipMaps=!0,n.type=0,n.samplingMode=3,n.width=e.camera.width,n.height=e.camera.height,n._cachedWrapU=1,n._cachedWrapV=1,n._hardwareTexture=new hu(i,this._glContext),this._cachedInternalTextures[t]=n;const o=new Vr(this._xrSessionManager.scene);o.name=`WebXR Raw Camera Access (${t})`,o._texture=this._cachedInternalTextures[t],this.texturesData[t]=o,this._updateCameraIntrinsics(e,t)}return this._cachedInternalTextures[t].isReady=!0,!0}_onXRFrame(e){const t=this._xrSessionManager.referenceSpace,i=e.getViewerPose(t);if(!i||!i.views)return;let r=!0;i.views.forEach((s,n)=>{r=r&&this._updateInternalTextures(s,n)}),r&&this.onTexturesUpdatedObservable.notifyObservers(this.texturesData)}}Vo.Name=ke.RAW_CAMERA_ACCESS;Vo.Version=1;Tt.AddWebXRFeature(Vo.Name,(a,e)=>()=>new Vo(a,e),Vo.Version,!1);class b4 extends ro{constructor(e,t,i){super(e,y4[i],t,i,!0),this.profileId="generic-hand-select-grasp"}_getFilenameAndPath(){return{filename:"generic.babylon",path:"https://controllers.babylonjs.com/generic/"}}_getModelLoadingConstraints(){return!0}_processLoadedModel(e){}_setRootMesh(e){}_updateModel(){}}Yt.RegisterController("generic-hand-select-grasp",(a,e)=>new b4(e,a.gamepad,a.handedness));const y4={left:{selectComponentId:"xr-standard-trigger",components:{"xr-standard-trigger":{type:"trigger",gamepadIndices:{button:0},rootNodeName:"xr-standard-trigger",visualResponses:{}},grasp:{type:"trigger",gamepadIndices:{button:4},rootNodeName:"grasp",visualResponses:{}}},gamepadMapping:"xr-standard",rootNodeName:"generic-hand-select-grasp-left",assetPath:"left.glb"},right:{selectComponentId:"xr-standard-trigger",components:{"xr-standard-trigger":{type:"trigger",gamepadIndices:{button:0},rootNodeName:"xr-standard-trigger",visualResponses:{}},grasp:{type:"trigger",gamepadIndices:{button:4},rootNodeName:"grasp",visualResponses:{}}},gamepadMapping:"xr-standard",rootNodeName:"generic-hand-select-grasp-right",assetPath:"right.glb"},none:{selectComponentId:"xr-standard-trigger",components:{"xr-standard-trigger":{type:"trigger",gamepadIndices:{button:0},rootNodeName:"xr-standard-trigger",visualResponses:{}},grasp:{type:"trigger",gamepadIndices:{button:4},rootNodeName:"grasp",visualResponses:{}}},gamepadMapping:"xr-standard",rootNodeName:"generic-hand-select-grasp-none",assetPath:"none.glb"}};class fn extends ro{constructor(e,t,i){super(e,T4["left-right"],t,i),this._mapping={defaultButton:{valueNodeName:"VALUE",unpressedNodeName:"UNPRESSED",pressedNodeName:"PRESSED"},defaultAxis:{valueNodeName:"VALUE",minNodeName:"MIN",maxNodeName:"MAX"},buttons:{"xr-standard-trigger":{rootNodeName:"SELECT",componentProperty:"button",states:["default","touched","pressed"]},"xr-standard-squeeze":{rootNodeName:"GRASP",componentProperty:"state",states:["pressed"]},"xr-standard-touchpad":{rootNodeName:"TOUCHPAD_PRESS",labelAnchorNodeName:"squeeze-label",touchPointNodeName:"TOUCH"},"xr-standard-thumbstick":{rootNodeName:"THUMBSTICK_PRESS",componentProperty:"state",states:["pressed"]}},axes:{"xr-standard-touchpad":{"x-axis":{rootNodeName:"TOUCHPAD_TOUCH_X"},"y-axis":{rootNodeName:"TOUCHPAD_TOUCH_Y"}},"xr-standard-thumbstick":{"x-axis":{rootNodeName:"THUMBSTICK_X"},"y-axis":{rootNodeName:"THUMBSTICK_Y"}}}},this.profileId="microsoft-mixed-reality"}_getFilenameAndPath(){let e="";this.handedness==="left"?e=fn.MODEL_LEFT_FILENAME:e=fn.MODEL_RIGHT_FILENAME;const i=fn.MODEL_BASE_URL+"default"+"/";return{filename:e,path:i}}_getModelLoadingConstraints(){const e=At.IsPluginForExtensionAvailable(".glb");return e||L.Warn("glTF / glb loaded was not registered, using generic controller instead"),e}_processLoadedModel(e){this.rootMesh&&(this.getComponentIds().forEach((t,i)=>{if(!this.disableAnimation&&t&&this.rootMesh){const r=this._mapping.buttons[t],s=r.rootNodeName;if(!s){L.Log("Skipping unknown button at index: "+i+" with mapped name: "+t);return}const n=this._getChildByName(this.rootMesh,s);if(!n){L.Warn("Missing button mesh with name: "+s);return}if(r.valueMesh=this._getImmediateChildByName(n,this._mapping.defaultButton.valueNodeName),r.pressedMesh=this._getImmediateChildByName(n,this._mapping.defaultButton.pressedNodeName),r.unpressedMesh=this._getImmediateChildByName(n,this._mapping.defaultButton.unpressedNodeName),r.valueMesh&&r.pressedMesh&&r.unpressedMesh){const o=this.getComponent(t);o&&o.onButtonStateChangedObservable.add(l=>{this._lerpTransform(r,l.value)},void 0,!0)}else L.Warn("Missing button submesh under mesh with name: "+s)}}),this.getComponentIds().forEach(t=>{const i=this.getComponent(t);i.isAxes()&&["x-axis","y-axis"].forEach(r=>{if(!this.rootMesh)return;const s=this._mapping.axes[t][r],n=this._getChildByName(this.rootMesh,s.rootNodeName);if(!n){L.Warn("Missing axis mesh with name: "+s.rootNodeName);return}s.valueMesh=this._getImmediateChildByName(n,this._mapping.defaultAxis.valueNodeName),s.minMesh=this._getImmediateChildByName(n,this._mapping.defaultAxis.minNodeName),s.maxMesh=this._getImmediateChildByName(n,this._mapping.defaultAxis.maxNodeName),s.valueMesh&&s.minMesh&&s.maxMesh?i&&i.onAxisValueChangedObservable.add(o=>{const l=r==="x-axis"?o.x:o.y;this._lerpTransform(s,l,!0)},void 0,!0):L.Warn("Missing axis submesh under mesh with name: "+s.rootNodeName)})}))}_setRootMesh(e){this.rootMesh=new z(this.profileId+" "+this.handedness,this.scene),this.rootMesh.isPickable=!1;let t;for(let i=0;i<e.length;i++){const r=e[i];r.isPickable=!1,r.parent||(t=r)}t&&t.setParent(this.rootMesh),this.scene.useRightHandedSystem||(this.rootMesh.rotationQuaternion=re.FromEulerAngles(0,Math.PI,0))}_updateModel(){}}fn.MODEL_BASE_URL="https://controllers.babylonjs.com/microsoft/";fn.MODEL_LEFT_FILENAME="left.glb";fn.MODEL_RIGHT_FILENAME="right.glb";Yt.RegisterController("windows-mixed-reality",(a,e)=>new fn(e,a.gamepad,a.handedness));const T4={};class Br extends ro{constructor(e,t,i,r=!1,s=!1){super(e,C4[i],t,i),this._forceLegacyControllers=s,this.profileId="oculus-touch"}_getFilenameAndPath(){let e="";this.handedness==="left"?e=Br.MODEL_LEFT_FILENAME:e=Br.MODEL_RIGHT_FILENAME;const t=this._isQuest()?Br.QUEST_MODEL_BASE_URL:Br.MODEL_BASE_URL;return{filename:e,path:t}}_getModelLoadingConstraints(){return!0}_processLoadedModel(e){const t=this._isQuest(),i=this.handedness==="right"?-1:1;this.getComponentIds().forEach(r=>{const s=r&&this.getComponent(r);s&&s.onButtonStateChangedObservable.add(n=>{if(!(!this.rootMesh||this.disableAnimation))switch(r){case"xr-standard-trigger":t||(this._modelRootNode.getChildren()[3].rotation.x=-n.value*.2,this._modelRootNode.getChildren()[3].position.y=-n.value*.005,this._modelRootNode.getChildren()[3].position.z=-n.value*.005);return;case"xr-standard-squeeze":t||(this._modelRootNode.getChildren()[4].position.x=i*n.value*.0035);return;case"xr-standard-thumbstick":return;case"a-button":case"x-button":t||(n.pressed?this._modelRootNode.getChildren()[1].position.y=-.001:this._modelRootNode.getChildren()[1].position.y=0);return;case"b-button":case"y-button":t||(n.pressed?this._modelRootNode.getChildren()[2].position.y=-.001:this._modelRootNode.getChildren()[2].position.y=0);return}},void 0,!0)})}_setRootMesh(e){this.rootMesh=new z(this.profileId+" "+this.handedness,this.scene),this.scene.useRightHandedSystem||(this.rootMesh.rotationQuaternion=re.FromEulerAngles(0,Math.PI,0)),e.forEach(t=>{t.isPickable=!1}),this._isQuest()?this._modelRootNode=e[0]:(this._modelRootNode=e[1],this.rootMesh.position.y=.034,this.rootMesh.position.z=.052),this._modelRootNode.parent=this.rootMesh}_updateModel(){}_isQuest(){return!!navigator.userAgent.match(/Quest/gi)&&!this._forceLegacyControllers}}Br.MODEL_BASE_URL="https://controllers.babylonjs.com/oculus/";Br.MODEL_LEFT_FILENAME="left.babylon";Br.MODEL_RIGHT_FILENAME="right.babylon";Br.QUEST_MODEL_BASE_URL="https://controllers.babylonjs.com/oculusQuest/";Yt.RegisterController("oculus-touch",(a,e)=>new Br(e,a.gamepad,a.handedness));Yt.RegisterController("oculus-touch-legacy",(a,e)=>new Br(e,a.gamepad,a.handedness,!0));const C4={left:{selectComponentId:"xr-standard-trigger",components:{"xr-standard-trigger":{type:"trigger",gamepadIndices:{button:0},rootNodeName:"xr_standard_trigger",visualResponses:{}},"xr-standard-squeeze":{type:"squeeze",gamepadIndices:{button:1},rootNodeName:"xr_standard_squeeze",visualResponses:{}},"xr-standard-thumbstick":{type:"thumbstick",gamepadIndices:{button:3,xAxis:2,yAxis:3},rootNodeName:"xr_standard_thumbstick",visualResponses:{}},"x-button":{type:"button",gamepadIndices:{button:4},rootNodeName:"x_button",visualResponses:{}},"y-button":{type:"button",gamepadIndices:{button:5},rootNodeName:"y_button",visualResponses:{}},thumbrest:{type:"button",gamepadIndices:{button:6},rootNodeName:"thumbrest",visualResponses:{}}},gamepadMapping:"xr-standard",rootNodeName:"oculus-touch-v2-left",assetPath:"left.glb"},right:{selectComponentId:"xr-standard-trigger",components:{"xr-standard-trigger":{type:"trigger",gamepadIndices:{button:0},rootNodeName:"xr_standard_trigger",visualResponses:{}},"xr-standard-squeeze":{type:"squeeze",gamepadIndices:{button:1},rootNodeName:"xr_standard_squeeze",visualResponses:{}},"xr-standard-thumbstick":{type:"thumbstick",gamepadIndices:{button:3,xAxis:2,yAxis:3},rootNodeName:"xr_standard_thumbstick",visualResponses:{}},"a-button":{type:"button",gamepadIndices:{button:4},rootNodeName:"a_button",visualResponses:{}},"b-button":{type:"button",gamepadIndices:{button:5},rootNodeName:"b_button",visualResponses:{}},thumbrest:{type:"button",gamepadIndices:{button:6},rootNodeName:"thumbrest",visualResponses:{}}},gamepadMapping:"xr-standard",rootNodeName:"oculus-touch-v2-right",assetPath:"right.glb"}};class Ya extends ro{constructor(e,t,i){super(e,P4[i],t,i),this.profileId="htc-vive"}_getFilenameAndPath(){const e=Ya.MODEL_FILENAME,t=Ya.MODEL_BASE_URL;return{filename:e,path:t}}_getModelLoadingConstraints(){return!0}_processLoadedModel(e){this.getComponentIds().forEach(t=>{const i=t&&this.getComponent(t);i&&i.onButtonStateChangedObservable.add(r=>{if(!(!this.rootMesh||this.disableAnimation))switch(t){case"xr-standard-trigger":this._modelRootNode.getChildren()[6].rotation.x=-r.value*.15;return;case"xr-standard-touchpad":return;case"xr-standard-squeeze":return}},void 0,!0)})}_setRootMesh(e){this.rootMesh=new z(this.profileId+" "+this.handedness,this.scene),e.forEach(t=>{t.isPickable=!1}),this._modelRootNode=e[1],this._modelRootNode.parent=this.rootMesh,this.scene.useRightHandedSystem||(this.rootMesh.rotationQuaternion=re.FromEulerAngles(0,Math.PI,0))}_updateModel(){}}Ya.MODEL_BASE_URL="https://controllers.babylonjs.com/vive/";Ya.MODEL_FILENAME="wand.babylon";Yt.RegisterController("htc-vive",(a,e)=>new Ya(e,a.gamepad,a.handedness));const P4={left:{selectComponentId:"xr-standard-trigger",components:{"xr-standard-trigger":{type:"trigger",gamepadIndices:{button:0},rootNodeName:"xr_standard_trigger",visualResponses:{}},"xr-standard-squeeze":{type:"squeeze",gamepadIndices:{button:1},rootNodeName:"xr_standard_squeeze",visualResponses:{}},"xr-standard-touchpad":{type:"touchpad",gamepadIndices:{button:2,xAxis:0,yAxis:1},rootNodeName:"xr_standard_touchpad",visualResponses:{}},menu:{type:"button",gamepadIndices:{button:4},rootNodeName:"menu",visualResponses:{}}},gamepadMapping:"xr-standard",rootNodeName:"htc_vive_none",assetPath:"none.glb"},right:{selectComponentId:"xr-standard-trigger",components:{"xr-standard-trigger":{type:"trigger",gamepadIndices:{button:0},rootNodeName:"xr_standard_trigger",visualResponses:{}},"xr-standard-squeeze":{type:"squeeze",gamepadIndices:{button:1},rootNodeName:"xr_standard_squeeze",visualResponses:{}},"xr-standard-touchpad":{type:"touchpad",gamepadIndices:{button:2,xAxis:0,yAxis:1},rootNodeName:"xr_standard_touchpad",visualResponses:{}},menu:{type:"button",gamepadIndices:{button:4},rootNodeName:"menu",visualResponses:{}}},gamepadMapping:"xr-standard",rootNodeName:"htc_vive_none",assetPath:"none.glb"},none:{selectComponentId:"xr-standard-trigger",components:{"xr-standard-trigger":{type:"trigger",gamepadIndices:{button:0},rootNodeName:"xr_standard_trigger",visualResponses:{}},"xr-standard-squeeze":{type:"squeeze",gamepadIndices:{button:1},rootNodeName:"xr_standard_squeeze",visualResponses:{}},"xr-standard-touchpad":{type:"touchpad",gamepadIndices:{button:2,xAxis:0,yAxis:1},rootNodeName:"xr_standard_touchpad",visualResponses:{}},menu:{type:"button",gamepadIndices:{button:4},rootNodeName:"menu",visualResponses:{}}},gamepadMapping:"xr-standard",rootNodeName:"htc-vive-none",assetPath:"none.glb"}};class E4{get session(){return this._nativeImpl.session}constructor(e){this._nativeImpl=e,this._xrTransform=new XRRigidTransform,this._xrPose={transform:this._xrTransform,emulatedPosition:!1},this._xrPoseVectorData=new Float32Array(8),this.fillPoses=this._nativeImpl.fillPoses.bind(this._nativeImpl),this.getViewerPose=this._nativeImpl.getViewerPose.bind(this._nativeImpl),this.getHitTestResults=this._nativeImpl.getHitTestResults.bind(this._nativeImpl),this.getHitTestResultsForTransientInput=()=>{throw new Error("XRFrame.getHitTestResultsForTransientInput not supported on native.")},this.createAnchor=this._nativeImpl.createAnchor.bind(this._nativeImpl),this.getJointPose=this._nativeImpl.getJointPose.bind(this._nativeImpl),this.fillJointRadii=this._nativeImpl.fillJointRadii.bind(this._nativeImpl),this.getLightEstimate=()=>{throw new Error("XRFrame.getLightEstimate not supported on native.")},this.getImageTrackingResults=()=>this._nativeImpl._imageTrackingResults??[]}getPose(e,t){if(!this._nativeImpl.getPoseData(e,t,this._xrPoseVectorData.buffer,this._xrTransform.matrix.buffer))return;const i=this._xrTransform.position;i.x=this._xrPoseVectorData[0],i.y=this._xrPoseVectorData[1],i.z=this._xrPoseVectorData[2],i.w=this._xrPoseVectorData[3];const r=this._xrTransform.orientation;return r.x=this._xrPoseVectorData[4],r.y=this._xrPoseVectorData[5],r.z=this._xrPoseVectorData[6],r.w=this._xrPoseVectorData[7],this._xrPose}get trackedAnchors(){return this._nativeImpl.trackedAnchors}get worldInformation(){return this._nativeImpl.worldInformation}get detectedPlanes(){return this._nativeImpl.detectedPlanes}get featurePointCloud(){return this._nativeImpl.featurePointCloud}getDepthInformation(e){throw new Error("This function is not available in Babylon Native")}}mO("NativeXRFrame",E4);export{KM as $,Ay as A,wW as B,Cs as C,Xe as D,Zs as E,On as F,Tr as G,Re as H,Ee as I,na as J,Ps as K,pt as L,MW as M,De as N,Qe as O,ut as P,Wo as Q,cl as R,HA as S,Jl as T,Ka as U,kl as V,ct as W,$t as X,qM as Y,QM as Z,X4 as _,q4 as a,Hy as a$,JM as a0,eA as a1,tA as a2,iA as a3,rA as a4,Ry as a5,sA as a6,nA as a7,My as a8,aA as a9,yg as aA,bu as aB,yu as aC,Da as aD,Gy as aE,Oa as aF,Qa as aG,$A as aH,Ln as aI,Fi as aJ,Eg as aK,Ig as aL,Rg as aM,tW as aN,nr as aO,ni as aP,qm as aQ,Tu as aR,Hr as aS,sl as aT,Vi as aU,$y as aV,xn as aW,Cu as aX,ui as aY,Kn as aZ,ki as a_,oA as aa,lA as ab,xg as ac,Sg as ad,Y4 as ae,Ly as af,vg as ag,jm as ah,By as ai,fA as aj,pA as ak,mA as al,_A as am,gA as an,go as ao,cA as ap,hA as aq,xi as ar,vu as as,xA as at,SA as au,vA as av,Vy as aw,bA as ax,yA as ay,bg as az,gi as b,rx as b$,Pu as b0,jy as b1,Yy as b2,XA as b3,ZA as b4,lt as b5,Qm as b6,Km as b7,nl as b8,qA as b9,ID as bA,MD as bB,DD as bC,Na as bD,qs as bE,Fa as bF,$l as bG,r0 as bH,Wg as bI,La as bJ,Ni as bK,QD as bL,AW as bM,DW as bN,$g as bO,Un as bP,gO as bQ,Xg as bR,Zg as bS,qg as bT,tt as bU,Qg as bV,Kg as bW,Jg as bX,ex as bY,tx as bZ,ix as b_,rr as ba,Xy as bb,QA as bc,Jm as bd,iD as be,rD as bf,sD as bg,nD as bh,lD as bi,uD as bj,cD as bk,hD as bl,dD as bm,Ja as bn,_D as bo,t_ as bp,gD as bq,aW as br,wa as bs,Eu as bt,Iu as bu,e_ as bv,Du as bw,CD as bx,Bt as by,PD as bz,ri as c,eo as c$,sx as c0,nx as c1,ax as c2,ox as c3,lx as c4,ux as c5,cx as c6,hx as c7,dx as c8,fx as c9,JO as cA,Nt as cB,$i as cC,pO as cD,mO as cE,Ba as cF,Bn as cG,ya as cH,OW as cI,Gx as cJ,ji as cK,pi as cL,Dn as cM,gw as cN,J as cO,Wx as cP,$x as cQ,Sw as cR,vw as cS,bw as cT,ga as cU,E0 as cV,yw as cW,ea as cX,Sn as cY,Cw as cZ,L0 as c_,px as ca,mx as cb,_x as cc,gx as cd,xx as ce,Sx as cf,vx as cg,bx as ch,yx as ci,Tx as cj,Cx as ck,Px as cl,Ex as cm,Ix as cn,Rx as co,Mx as cp,Ax as cq,Dx as cr,Ox as cs,wx as ct,bt as cu,Nr as cv,at as cw,An as cx,Uu as cy,xO as cz,tr as d,Dg as d$,D_ as d0,Wu as d1,to as d2,vn as d3,U0 as d4,Ow as d5,ww as d6,Ot as d7,Ls as d8,Ct as d9,sr as dA,sS as dB,M0 as dC,rw as dD,Gw as dE,$w as dF,N0 as dG,xw as dH,nS as dI,Ql as dJ,w0 as dK,aS as dL,oS as dM,nw as dN,R0 as dO,M_ as dP,sw as dQ,zi as dR,wr as dS,Hi as dT,ar as dU,iW as dV,Jt as dW,jA as dX,eD as dY,tD as dZ,Ag as d_,A_ as da,Vw as db,io as dc,W0 as dd,zw as de,Uw as df,Jn as dg,Ww as dh,Hw as di,lh as dj,R_ as dk,Zl as dl,Qx as dm,Kx as dn,dh as dp,Tw as dq,Pw as dr,Jx as ds,Va as dt,Iw as du,k0 as dv,iS as dw,V0 as dx,Aw as dy,Dw as dz,gt as e,WN as e$,KA as e0,Og as e1,wg as e2,JA as e3,lS as e4,Ug as e5,Gg as e6,Dr as e7,vo as e8,Wn as e9,I1 as eA,V_ as eB,nn as eC,M1 as eD,A1 as eE,O1 as eF,N1 as eG,L1 as eH,Vt as eI,V1 as eJ,H1 as eK,Q1 as eL,J1 as eM,tN as eN,oN as eO,gN as eP,SN as eQ,bN as eR,PN as eS,qu as eT,Ks as eU,VW as eV,Ul as eW,Fe as eX,ON as eY,FN as eZ,kN as e_,O_ as ea,BW as eb,B_ as ec,v0 as ed,pr as ee,n1 as ef,$r as eg,Yu as eh,a1 as ei,kr as ej,sn as ek,Gn as el,ur as em,o1 as en,u1 as eo,h1 as ep,f1 as eq,m1 as er,_1 as es,g1 as et,x1 as eu,S1 as ev,v1 as ew,b1 as ex,T1 as ey,P1 as ez,ve as f,mN as f$,tu as f0,yt as f1,Ai as f2,Os as f3,ws as f4,zS as f5,Pa as f6,Is as f7,Yo as f8,C0 as f9,hS as fA,ka as fB,le as fC,Dl as fD,ht as fE,gF as fF,xF as fG,qT as fH,SF as fI,Qr as fJ,QT as fK,hl as fL,vF as fM,bF as fN,yF as fO,TF as fP,CF as fQ,PF as fR,EF as fS,so as fT,Ju as fU,IF as fV,RF as fW,MF as fX,Z1 as fY,k1 as fZ,W1 as f_,AT as fa,an as fb,z_ as fc,$u as fd,Fr as fe,US as ff,iu as fg,t1 as fh,Ds as fi,js as fj,ql as fk,qN as fl,QN as fm,KN as fn,eF as fo,iF as fp,sF as fq,aF as fr,lF as fs,cF as ft,dF as fu,A as fv,x as fw,HS as fx,dt as fy,cS as fz,Xi as g,tc as g$,aw as g0,nN as g1,AF as g2,ld as g3,ru as g4,Xo as g5,DF as g6,$0 as g7,ec as g8,Zi as g9,XF as gA,ZF as gB,qF as gC,QF as gD,KF as gE,JF as gF,e2 as gG,t2 as gH,i2 as gI,r2 as gJ,s2 as gK,n2 as gL,a2 as gM,jS as gN,eC as gO,kc as gP,o2 as gQ,l2 as gR,tC as gS,u2 as gT,c2 as gU,h2 as gV,d2 as gW,f2 as gX,p2 as gY,Wt as gZ,no as g_,OF as ga,ys as gb,wF as gc,NF as gd,FF as ge,fh as gf,LF as gg,BF as gh,U_ as gi,VF as gj,kF as gk,zF as gl,Hu as gm,UF as gn,Ye as go,N_ as gp,GF as gq,zl as gr,X0 as gs,WF as gt,$F as gu,HF as gv,jF as gw,YF as gx,KT as gy,JT as gz,Ti as h,ev as h$,ao as h0,Vn as h1,ta as h2,qo as h3,Zo as h4,H0 as h5,j0 as h6,Y0 as h7,_2 as h8,g2 as h9,Gr as hA,D2 as hB,za as hC,ZS as hD,qS as hE,QS as hF,Xt as hG,KS as hH,ei as hI,W2 as hJ,H2 as hK,Y2 as hL,Z2 as hM,kw as hN,Q2 as hO,K2 as hP,J2 as hQ,Or as hR,Sr as hS,Xr as hT,al as hU,ku as hV,su as hW,as as hX,c0 as hY,zW as hZ,rL as h_,Ht as ha,iC as hb,rC as hc,x2 as hd,S2 as he,G_ as hf,v2 as hg,b2 as hh,y2 as hi,YS as hj,sC as hk,Ae as hl,nC as hm,T2 as hn,oo as ho,C2 as hp,P2 as hq,E2 as hr,kW as hs,oC as ht,jx as hu,U as hv,XS as hw,I2 as hx,dl as hy,A2 as hz,f_ as i,HD as i$,oL as i0,lL as i1,bW as i2,VD as i3,_0 as i4,nh as i5,Vu as i6,uL as i7,c_ as i8,LD as i9,__ as iA,vW as iB,f0 as iC,wu as iD,Nu as iE,yW as iF,Fu as iG,Lu as iH,TW as iI,g_ as iJ,CW as iK,Wy as iL,eW as iM,So as iN,a0 as iO,gW as iP,Zr as iQ,Qy as iR,Ky as iS,ol as iT,n_ as iU,a_ as iV,sW as iW,x_ as iX,PW as iY,m0 as iZ,EW as i_,uW as ia,o0 as ib,l0 as ic,xW as id,p_ as ie,_W as ig,n0 as ih,mn as ii,mW as ij,h_ as ik,cW as il,Kl as im,NW as io,u_ as ip,lW as iq,o_ as ir,fs as is,nW as it,u0 as iu,m_ as iv,SW as iw,h0 as ix,d0 as iy,ba as iz,ai as j,OC as j$,jD as j0,YD as j1,v_ as j2,RW as j3,S_ as j4,$o as j5,IW as j6,d_ as j7,pW as j8,g0 as j9,$e as jA,ic as jB,gC as jC,Ft as jD,xC as jE,W_ as jF,SC as jG,vC as jH,bC as jI,yC as jJ,TC as jK,CC as jL,PC as jM,EC as jN,TL as jO,CL as jP,IC as jQ,RC as jR,$_ as jS,MC as jT,AC as jU,Ei as jV,DC as jW,PL as jX,jt as jY,H_ as jZ,lr as j_,qD as ja,sv as jb,nv as jc,cL as jd,UW as je,hL as jf,dL as jg,fL as jh,BO as ji,ii as jj,Et as jk,tv as jl,iv as jm,rv as jn,fC as jo,Ko as jp,mL as jq,_L as jr,bL as js,Yi as jt,be as ju,ov as jv,lv as jw,uv as jx,yL as jy,I as jz,Qs as k,YN as k$,EL as k0,wC as k1,NC as k2,FC as k3,IL as k4,RL as k5,ML as k6,AL as k7,LC as k8,fl as k9,or as kA,sc as kB,YL as kC,XL as kD,ZL as kE,qL as kF,QL as kG,KL as kH,JL as kI,eB as kJ,tB as kK,Oe as kL,WC as kM,iB as kN,rB as kO,sB as kP,nB as kQ,aB as kR,oB as kS,lB as kT,uB as kU,we as kV,$C as kW,Jr as kX,X_ as kY,Z_ as kZ,HN as k_,We as ka,BC as kb,VC as kc,DL as kd,OL as ke,wL as kf,NL as kg,FL as kh,LL as ki,j_ as kj,kC as kk,Y_ as kl,BL as km,VL as kn,kL as ko,zL as kp,UL as kq,GL as kr,Kr as ks,zC as kt,WL as ku,$L as kv,HL as kw,UC as kx,GC as ky,jL as kz,gn as l,Ws as l$,cB as l0,dB as l1,pB as l2,mB as l3,_B as l4,gB as l5,xB as l6,SB as l7,vB as l8,bB as l9,Hc as lA,dv as lB,on as lC,Ia as lD,aP as lE,nu as lF,Mg as lG,me as lH,Ke as lI,nc as lJ,lP as lK,VB as lL,ac as lM,uP as lN,i$ as lO,fv as lP,hP as lQ,zB as lR,dP as lS,Wi as lT,pw as lU,mw as lV,pv as lW,nt as lX,Ad as lY,au as lZ,Ar as l_,yB as la,TB as lb,CB as lc,PB as ld,cv as le,_s as lf,EB as lg,IB as lh,RB as li,e$ as lj,MB as lk,AB as ll,DB as lm,OB as ln,wB as lo,NB as lp,FB as lq,t$ as lr,nP as ls,Bs as lt,Uc as lu,hv as lv,Gc as lw,Wc as lx,$c as ly,LB as lz,Ys as m,NP as m$,Hx as m0,I0 as m1,Je as m2,YB as m3,ZB as m4,Pi as m5,kt as m6,ln as m7,_l as m8,hc as m9,Hh as mA,is as mB,DS as mC,K_ as mD,AP as mE,J_ as mF,DP as mG,OP as mH,r$ as mI,s$ as mJ,n$ as mK,a$ as mL,o$ as mM,Fv as mN,Ev as mO,Iv as mP,Rv as mQ,Mv as mR,Av as mS,Dv as mT,Ov as mU,Nv as mV,Lv as mW,l$ as mX,u$ as mY,bo as mZ,wP as m_,ml as ma,cc as mb,lc as mc,oc as md,pl as me,uc as mf,cn as mg,Q_ as mh,JB as mi,tV as mj,Lr as mk,Jo as ml,Ha as mm,$a as mn,mv as mo,un as mp,aV as mq,lV as mr,uV as ms,hV as mt,DT as mu,rt as mv,hW as mw,s0 as mx,dW as my,fW as mz,Bu as n,E3 as n$,zv as n0,Uv as n1,Qu as n2,Zy as n3,fc as n4,Gv as n5,tg as n6,zt as n7,gs as n8,uo as n9,KV as nA,t3 as nB,r3 as nC,n3 as nD,MV as nE,AV as nF,ho as nG,oD as nH,rW as nI,sb as nJ,c$ as nK,mr as nL,Fg as nM,mD as nN,Er as nO,xl as nP,ns as nQ,os as nR,B0 as nS,It as nT,ls as nU,yi as nV,tS as nW,z0 as nX,zr as nY,x3 as nZ,b3 as n_,pc as na,xs as nb,Bd as nc,Wv as nd,$v as ne,_V as nf,ig as ng,eg as nh,mc as ni,lo as nj,co as nk,rg as nl,ia as nm,ra as nn,ci as no,Gt as np,gl as nq,qe as nr,St as ns,bn as nt,WV as nu,BV as nv,$V as nw,HV as nx,XV as ny,qV as nz,er as o,Pz as o$,M3 as o0,D3 as o1,w3 as o2,F3 as o3,B3 as o4,IV as o5,k3 as o6,U3 as o7,W3 as o8,DV as o9,Gk as oA,Wk as oB,Hk as oC,Yk as oD,Zk as oE,Jk as oF,As as oG,ez as oH,Es as oI,iz as oJ,_c as oK,sz as oL,PV as oM,$n as oN,nz as oO,di as oP,lz as oQ,_z as oR,tl as oS,yz as oT,sg as oU,UE as oV,gz as oW,xz as oX,Cb as oY,Pb as oZ,Tz as o_,H3 as oa,Y3 as ob,Z3 as oc,Q3 as od,J3 as oe,tk as of,rk as og,nk as oh,ok as oi,uk as oj,hk as ok,fk as ol,mk as om,gk as on,Sk as oo,bk as op,Tk as oq,Pk as or,Ik as os,Mk as ot,Dk as ou,wk as ov,Fk as ow,Bk as ox,kk as oy,Uk as oz,_F as p,oG as p$,Iz as p0,Mz as p1,f$ as p2,Dz as p3,wz as p4,Nz as p5,Fz as p6,Bz as p7,kz as p8,Uz as p9,PU as pA,IU as pB,RU as pC,MU as pD,AU as pE,NU as pF,LU as pG,VU as pH,zU as pI,GU as pJ,$U as pK,jU as pL,XU as pM,ZU as pN,qU as pO,QU as pP,KU as pQ,JU as pR,eG as pS,tG as pT,iG as pU,rG as pV,E$ as pW,I$ as pX,sG as pY,nG as pZ,aG as p_,Wz as pa,p$ as pb,Hz as pc,Yz as pd,Xz as pe,Zz as pf,m$ as pg,aa as ph,ng as pi,br as pj,Jz as pk,tU as pl,rU as pm,nU as pn,oU as po,uU as pp,hU as pq,fU as pr,lw as ps,hw as pt,mU as pu,gU as pv,xV as pw,yV as px,SU as py,bU as pz,pF as q,mS as q$,lG as q0,uG as q1,cG as q2,dG as q3,pG as q4,_G as q5,xG as q6,vG as q7,yG as q8,CG as q9,Ho as qA,i1 as qB,FW as qC,F_ as qD,w_ as qE,Qw as qF,qw as qG,Ru as qH,SD as qI,Hb as qJ,jb as qK,Mu as qL,LW as qM,L_ as qN,ke as qO,Tt as qP,ti as qQ,hn as qR,yo as qS,To as qT,Co as qU,Ta as qV,cs as qW,Y$ as qX,Po as qY,Eo as qZ,Io as q_,EG as qa,RG as qb,AG as qc,DG as qd,OG as qe,wG as qf,NG as qg,FG as qh,LG as qi,BG as qj,VG as qk,kG as ql,zG as qm,UG as qn,GG as qo,WG as qp,HG as qq,jG as qr,k_ as qs,bm as qt,j$ as qu,MN as qv,QG as qw,JG as qx,i4 as qy,s4 as qz,mF as r,A$ as r$,_S as r0,s1 as r1,je as r2,Ro as r3,Mo as r4,pS as r5,hs as r6,Ao as r7,dn as r8,Do as r9,oW as rA,GW as rB,WW as rC,$W as rD,HW as rE,jW as rF,YW as rG,XW as rH,ZW as rI,qW as rJ,QW as rK,KW as rL,JW as rM,h$ as rN,d$ as rO,_$ as rP,g$ as rQ,x$ as rR,S$ as rS,v$ as rT,b$ as rU,y$ as rV,T$ as rW,C$ as rX,P$ as rY,R$ as rZ,M$ as r_,Oo as ra,Xc as rb,No as rc,Lo as rd,S4 as re,v4 as rf,Bo as rg,Vo as rh,ro as ri,Ji as rj,b4 as rk,jo as rl,fn as rm,Yt as rn,Br as ro,Ya as rp,Xw as rq,vD as rr,bD as rs,yD as rt,E4 as ru,r_ as rv,Z4 as rw,Q4 as rx,K4 as ry,J4 as rz,bi as s,D$ as s0,O$ as s1,w$ as s2,N$ as s3,F$ as s4,L$ as s5,B$ as s6,V$ as s7,k$ as s8,z$ as s9,U$ as sa,G$ as sb,W$ as sc,$$ as sd,H$ as se,Sa as t,de as u,Ou as v,wv as w,Vs as x,IN as y,sa as z};
//# sourceMappingURL=nativeXRFrame-DgHx7Vcb.js.map
