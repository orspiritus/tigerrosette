import{L as R,c as z}from"./pointsCloudSystem-2vcS-S4d.js";import{P as U,c as P,j as D,k as _,I as k,e as C,B as I,d as T,R as M,H as F,W as N,A as W,l as A,U as Z,C as m,a as E,E as S,i as G,D as H,F as L,h as j,g as X,b as Y}from"./exrLoader.configuration-BDKsI_eb.js";const V=20000630;function $(n,l){if(n.getUint32(0,!0)!=V)throw new Error("Incorrect OpenEXR format");const s=n.getUint8(4),i=n.getUint8(5),e={singleTile:!!(i&2),longName:!!(i&4),deepFormat:!!(i&8),multiPart:!!(i&16)};l.value=8;const r={};let t=!0;for(;t;){const a=U(n.buffer,l);if(!a)t=!1;else{const c=U(n.buffer,l),o=P(n,l),u=D(n,l,c,o);u===void 0?R.Warn(`Unknown header attribute type ${c}'.`):r[a]=u}}if(i&-5)throw new Error("Unsupported file format");return{version:s,spec:e,...r}}function q(n){let l=n.byteLength;const s=new Array;let i=0;const e=new DataView(n);for(;l>0;){const r=e.getInt8(i++);if(r<0){const t=-r;l-=t+1;for(let a=0;a<t;a++)s.push(e.getUint8(i++))}else{const t=r;l-=2;const a=e.getUint8(i++);for(let c=0;c<t+1;c++)s.push(a)}}return s}function B(n){return new DataView(n.array.buffer,n.offset.value,n.size)}function J(n){const l=n.viewer.buffer.slice(n.offset.value,n.offset.value+n.size),s=new Uint8Array(q(l)),i=new Uint8Array(s.length);return _(s),k(s,i),new DataView(i.buffer)}function x(n){const l=n.array.slice(n.offset.value,n.offset.value+n.size),s=fflate.unzlibSync(l),i=new Uint8Array(s.length);return _(s),k(s,i),new DataView(i.buffer)}function K(n){const l=n.array.slice(n.offset.value,n.offset.value+n.size),s=fflate.unzlibSync(l),i=n.lines*n.channels*n.width,e=n.type==1?new Uint16Array(i):new Uint32Array(i);let r=0,t=0;const a=new Array(4);for(let c=0;c<n.lines;c++)for(let o=0;o<n.channels;o++){let u=0;switch(n.type){case 1:a[0]=r,a[1]=a[0]+n.width,r=a[1]+n.width;for(let h=0;h<n.width;++h){const w=s[a[0]++]<<8|s[a[1]++];u+=w,e[t]=u,t++}break;case 2:a[0]=r,a[1]=a[0]+n.width,a[2]=a[1]+n.width,r=a[2]+n.width;for(let h=0;h<n.width;++h){const w=s[a[0]++]<<24|s[a[1]++]<<16|s[a[2]++]<<8;u+=w,e[t]=u,t++}break}}return new DataView(e.buffer)}function Q(n){const l=n.viewer,s={value:n.offset.value},i=new Uint16Array(n.width*n.scanlineBlockSize*(n.channels*n.type)),e=new Uint8Array(I);let r=0;const t=new Array(n.channels);for(let f=0;f<n.channels;f++)t[f]={},t[f].start=r,t[f].end=t[f].start,t[f].nx=n.width,t[f].ny=n.lines,t[f].size=n.type,r+=t[f].nx*t[f].ny*t[f].size;const a=C(l,s),c=C(l,s);if(c>=I)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(a<=c)for(let f=0;f<c-a+1;f++)e[f+a]=T(l,s);const o=new Uint16Array(Z),u=M(e,o),h=P(l,s);F(n.array,l,s,h,i,r);for(let f=0;f<n.channels;++f){const p=t[f];for(let y=0;y<t[f].size;++y)N(i,p.start+y,p.nx,p.size,p.ny,p.nx*p.size,u)}W(o,i,r);let w=0;const O=new Uint8Array(i.buffer.byteLength);for(let f=0;f<n.lines;f++)for(let p=0;p<n.channels;p++){const y=t[p],b=y.nx*y.size,g=new Uint8Array(i.buffer,y.end*A,b*A);O.set(g,w),w+=b*A,y.end+=b}return new DataView(O.buffer)}async function d(n,l,s,i){const e={size:0,viewer:l,array:new Uint8Array(l.buffer),offset:s,width:n.dataWindow.xMax-n.dataWindow.xMin+1,height:n.dataWindow.yMax-n.dataWindow.yMin+1,channels:n.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(n.compression){case m.NO_COMPRESSION:e.lines=1,e.uncompress=B;break;case m.RLE_COMPRESSION:e.lines=1,e.uncompress=J;break;case m.ZIPS_COMPRESSION:e.lines=1,e.uncompress=x,await z.LoadScriptAsync(E.FFLATEUrl);break;case m.ZIP_COMPRESSION:e.lines=16,e.uncompress=x,await z.LoadScriptAsync(E.FFLATEUrl);break;case m.PIZ_COMPRESSION:e.lines=32,e.uncompress=Q;break;case m.PXR24_COMPRESSION:e.lines=16,e.uncompress=K,await z.LoadScriptAsync(E.FFLATEUrl);break;default:throw new Error(m[n.compression]+" is unsupported")}e.scanlineBlockSize=e.lines;const r={};for(const o of n.channels)switch(o.name){case"Y":case"R":case"G":case"B":case"A":r[o.name]=!0,e.type=o.pixelType}let t=!1;if(r.R&&r.G&&r.B)t=!r.A,e.outputChannels=4,e.decodeChannels={R:0,G:1,B:2,A:3};else if(r.Y)e.outputChannels=1,e.decodeChannels={Y:0};else throw new Error("EXRLoader.parse: file contains unsupported data channels.");if(e.type===1)switch(i){case S.Float:e.getter=G,e.inputSize=A;break;case S.HalfFloat:e.getter=C,e.inputSize=A;break}else if(e.type===2)switch(i){case S.Float:e.getter=j,e.inputSize=L;break;case S.HalfFloat:e.getter=H,e.inputSize=L}else throw new Error("Unsupported pixelType "+e.type+" for "+n.compression);e.blockCount=e.height/e.scanlineBlockSize;for(let o=0;o<e.blockCount;o++)X(l,s);const a=e.width*e.height*e.outputChannels;switch(i){case S.Float:e.byteArray=new Float32Array(a),e.textureType=1,t&&e.byteArray.fill(1,0,a);break;case S.HalfFloat:e.byteArray=new Uint16Array(a),e.textureType=2,t&&e.byteArray.fill(15360,0,a);break;default:throw new Error("Unsupported type: "+i)}let c=0;for(const o of n.channels)e.decodeChannels[o.name]!==void 0&&(e.channelLineOffsets[o.name]=c*e.width),c+=o.pixelType*2;return e.bytesPerLine=e.width*c,e.outLineWidth=e.width*e.outputChannels,n.lineOrder==="INCREASING_Y"?e.scanOrder=o=>o:e.scanOrder=o=>e.height-1-o,e.outputChannels==4?(e.format=5,e.linearSpace=!0):(e.format=6,e.linearSpace=!1),e}function nn(n,l,s,i){const e={value:0};for(let r=0;r<n.height/n.scanlineBlockSize;r++){const t=Y(s,i)-l.dataWindow.yMin;n.size=P(s,i),n.lines=t+n.scanlineBlockSize>n.height?n.height-t:n.scanlineBlockSize;const c=n.size<n.lines*n.bytesPerLine&&n.uncompress?n.uncompress(n):B(n);i.value+=n.size;for(let o=0;o<n.scanlineBlockSize;o++){const u=r*n.scanlineBlockSize,h=o+n.scanOrder(u);if(h>=n.height)continue;const w=o*n.bytesPerLine,O=(n.height-1-h)*n.outLineWidth;for(let f=0;f<n.channels;f++){const p=l.channels[f].name,y=n.channelLineOffsets[p],b=n.decodeChannels[p];if(b!==void 0){e.value=w+y;for(let g=0;g<n.width;g++){const v=O+g*n.outputChannels+b;n.byteArray&&(n.byteArray[v]=n.getter(c,e))}}}}}}class en{constructor(){this.supportCascades=!1}loadCubeData(l,s,i,e,r){throw".exr not supported in Cube."}async loadData(l,s,i){const e=new DataView(l.buffer),r={value:0},t=$(e,r),a=await d(t,e,r,E.DefaultOutputType);nn(a,t,e,r);const c=t.dataWindow.xMax-t.dataWindow.xMin+1,o=t.dataWindow.yMax-t.dataWindow.yMin+1;i(c,o,s.generateMipMaps,!1,()=>{const u=s.getEngine();s.format=t.format,s.type=a.textureType,s.invertY=!1,s._gammaSpace=!t.linearSpace,a.byteArray&&u._uploadDataToTextureDirectly(s,a.byteArray,0,0,void 0,!0)})}}const an=Object.freeze(Object.defineProperty({__proto__:null,_ExrTextureLoader:en},Symbol.toStringTag,{value:"Module"}));export{d as C,q as D,$ as G,nn as S,B as U,en as _,J as a,x as b,K as c,Q as d,an as e};
//# sourceMappingURL=exrTextureLoader-B-9p8Lmj.js.map
